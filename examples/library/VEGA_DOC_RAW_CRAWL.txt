Vega
            
              Vega-Lite
              Altair
              Vega-Lite API
            
          
          
            
              Examples
              Tutorials
              Documentation
              Usage
              About
            
            
              GitHub
              Try Online
            
          
        
      

      
        

  
  
    Documentation
    The Vega visualization grammar provides basic building blocks for a wide variety of visualization designs. This page provides documentation of Vega JSON specifications and JavaScript API.

To start learning Vega, we recommend first working through the introductory Let’s Make A Bar Chart tutorial and exploring the example gallery, then digging into the documentation. These pages document Vega version 3.0 and later; if you are familiar with Vega 2.x, you might begin with the Vega 2 porting guide.

Specification Reference

A Vega specification is a JSON object that describes an interactive visualization design. A specification consists of basic properties (such as the width and height of the view) and definitions for the data to visualize, scales that map data values to visual values, axes and legends that visualize these scales, cartographic projections for drawing maps, graphical marks such as rectangles, lines, and symbols to visually represent data, and signals to process user input and modify the visualization in response.


  
    
      Specification
      Overview of a full Vega specification, including sizing and metadata.
    
    
      Config
      Configure defaults for visual encoding choices.
    
    
      Data
      Define, load, and parse data to visualize.
    
    
      Transforms
      Apply data transforms (filter, sort, aggregate, layout) prior to visualization.
    
    
      Triggers
      Modify data sets or mark properties in response to signal values.
    
    
      Projections
      Cartographic projections to map (longitude, latitude) data.
    
    
      Scales
      Map data values (numbers, strings) to visual properties (coordinates, colors, sizes).
    
    
      Schemes
      Color schemes that can be used as scale ranges.
    
    
      Axes
      Visualize scale mappings for spatial encodings using coordinate axes.
    
    
      Legends
      Visualize scale mappings for color, shape and size encodings.
    
    
      Title
      Specify a chart title for a visualization.
    
    
      Marks
      Visually encode data with graphical marks such as rectangles, lines, and symbols.
    
    
      Signals
      Dynamic variables that can drive interactive updates.
    
    
      Event Streams
      Define input event streams to specify interactions.
    
    
      Expressions
      Express custom calculations over data and signals.
    
    
      Layout
      Perform grid layout for a collection of group marks.
    
    
      Types
      Documentation of recurring parameter types.
    
  


Vega API Reference

Vega also provides a JavaScript runtime API, responsible for parsing JSON specifications to produce interactive views backed by a reactive dataflow graph of data processing operators. For more on deploying Vega, see the usage instructions.


  
    
      Parser
      Parse Vega JSON specifications to dataflow descriptions.
    
    
      View
      Create interactive views from dataflow descriptions.
    
    
      Locale
      Use number and date formats for a specific locale.
    
    
      Extensibility
      Extend Vega with new projections, scales, color schemes, or data transforms.
    
    
      Statistics
      Statistical methods used by Vega.
    
    
      Time
      Utility methods for date-time values.
    
    
      Util
      General JavaScript utilities.
    
    
      Debugging
      A guide to debugging Vega visualizations at runtime.\nVega
            
              Vega-Lite
              Altair
              Vega-Lite API\nVega-Lite
              Altair
              Vega-Lite API\nExamples
              Tutorials
              Documentation
              Usage
              About
            
            
              GitHub
              Try Online\nExamples
              Tutorials
              Documentation
              Usage
              About\nGitHub
              Try Online\nDocumentation
    The Vega visualization grammar provides basic building blocks for a wide variety of visualization designs. This page provides documentation of Vega JSON specifications and JavaScript API.

To start learning Vega, we recommend first working through the introductory Let’s Make A Bar Chart tutorial and exploring the example gallery, then digging into the documentation. These pages document Vega version 3.0 and later; if you are familiar with Vega 2.x, you might begin with the Vega 2 porting guide.

Specification Reference

A Vega specification is a JSON object that describes an interactive visualization design. A specification consists of basic properties (such as the width and height of the view) and definitions for the data to visualize, scales that map data values to visual values, axes and legends that visualize these scales, cartographic projections for drawing maps, graphical marks such as rectangles, lines, and symbols to visually represent data, and signals to process user input and modify the visualization in response.


  
    
      Specification
      Overview of a full Vega specification, including sizing and metadata.
    
    
      Config
      Configure defaults for visual encoding choices.
    
    
      Data
      Define, load, and parse data to visualize.
    
    
      Transforms
      Apply data transforms (filter, sort, aggregate, layout) prior to visualization.
    
    
      Triggers
      Modify data sets or mark properties in response to signal values.
    
    
      Projections
      Cartographic projections to map (longitude, latitude) data.
    
    
      Scales
      Map data values (numbers, strings) to visual properties (coordinates, colors, sizes).
    
    
      Schemes
      Color schemes that can be used as scale ranges.
    
    
      Axes
      Visualize scale mappings for spatial encodings using coordinate axes.
    
    
      Legends
      Visualize scale mappings for color, shape and size encodings.
    
    
      Title
      Specify a chart title for a visualization.
    
    
      Marks
      Visually encode data with graphical marks such as rectangles, lines, and symbols.
    
    
      Signals
      Dynamic variables that can drive interactive updates.
    
    
      Event Streams
      Define input event streams to specify interactions.
    
    
      Expressions
      Express custom calculations over data and signals.
    
    
      Layout
      Perform grid layout for a collection of group marks.
    
    
      Types
      Documentation of recurring parameter types.
    
  


Vega API Reference

Vega also provides a JavaScript runtime API, responsible for parsing JSON specifications to produce interactive views backed by a reactive dataflow graph of data processing operators. For more on deploying Vega, see the usage instructions.


  
    
      Parser
      Parse Vega JSON specifications to dataflow descriptions.
    
    
      View
      Create interactive views from dataflow descriptions.
    
    
      Locale
      Use number and date formats for a specific locale.
    
    
      Extensibility
      Extend Vega with new projections, scales, color schemes, or data transforms.
    
    
      Statistics
      Statistical methods used by Vega.
    
    
      Time
      Utility methods for date-time values.
    
    
      Util
      General JavaScript utilities.
    
    
      Debugging
      A guide to debugging Vega visualizations at runtime.\nThe Vega visualization grammar provides basic building blocks for a wide variety of visualization designs. This page provides documentation of Vega JSON specifications and JavaScript API.\nVega JSON specifications\nTo start learning Vega, we recommend first working through the introductory Let’s Make A Bar Chart tutorial and exploring the example gallery, then digging into the documentation. These pages document Vega version 3.0 and later; if you are familiar with Vega 2.x, you might begin with the Vega 2 porting guide.\nLet’s Make A Bar Chart tutorial\nSpecification Reference\nA Vega specification is a JSON object that describes an interactive visualization design. A specification consists of basic properties (such as the width and height of the view) and definitions for the data to visualize, scales that map data values to visual values, axes and legends that visualize these scales, cartographic projections for drawing maps, graphical marks such as rectangles, lines, and symbols to visually represent data, and signals to process user input and modify the visualization in response.\nOverview of a full Vega specification, including sizing and metadata.\nConfigure defaults for visual encoding choices.\nDefine, load, and parse data to visualize.\nApply data transforms (filter, sort, aggregate, layout) prior to visualization.\nModify data sets or mark properties in response to signal values.\nCartographic projections to map (longitude, latitude) data.\nMap data values (numbers, strings) to visual properties (coordinates, colors, sizes).\nColor schemes that can be used as scale ranges.\nVisualize scale mappings for spatial encodings using coordinate axes.\nVisualize scale mappings for color, shape and size encodings.\nSpecify a chart title for a visualization.\nVisually encode data with graphical marks such as rectangles, lines, and symbols.\nDynamic variables that can drive interactive updates.\nDefine input event streams to specify interactions.\nExpress custom calculations over data and signals.\nPerform grid layout for a collection of group marks.\nDocumentation of recurring parameter types.\nVega also provides a JavaScript runtime API, responsible for parsing JSON specifications to produce interactive views backed by a reactive dataflow graph of data processing operators. For more on deploying Vega, see the usage instructions.\nParse Vega JSON specifications to dataflow descriptions.\nCreate interactive views from dataflow descriptions.\nUse number and date formats for a specific locale.\nExtend Vega with new projections, scales, color schemes, or data transforms.\nStatistical methods used by Vega.\nUtility methods for date-time values.\nGeneral JavaScript utilities.\nA guide to debugging Vega visualizations at runtime.\n\n\nVega
            
              Vega-Lite
              Altair
              Vega-Lite API
            
          
          
            
              Examples
              Tutorials
              Documentation
              Usage
              About
            
            
              GitHub
              Try Online
            
          
        
      

      
        
  
    Vega – A Visualization Grammar
  






  
    Vega is a visualization grammar, a declarative language for creating, saving, and sharing interactive visualization designs. With Vega, you can describe the visual appearance and interactive behavior of a visualization in a JSON format, and generate web-based views using Canvas or SVG.

Version 5.31.0

Vega provides basic building blocks for a wide variety of visualization designs: data loading and transformation, scales, map projections, axes, legends, and graphical marks such as rectangles, lines, plotting symbols, etc. Interaction techniques can be specified using reactive signals that dynamically modify a visualization in response to input event streams.

A Vega specification defines an interactive visualization in a JSON format. Specifications are parsed by Vega’s JavaScript runtime to generate both static images or interactive web-based views. Vega provides a convenient representation for computational generation of visualizations, and can serve as a foundation for new APIs and visual analysis tools.

To get started with Vega, take a look at the tutorials, example gallery, and usage guide, or read about the project’s goals.

To rapidly create common statistical graphics, check out Vega-Lite, a higher-level language built on top of Vega. Not that into JavaScript? Take a look at the Altair Python API for Vega-Lite.

Need help or want to share examples? Join the Vega discussion forum or the Vega Slack organization!\nVega
            
              Vega-Lite
              Altair
              Vega-Lite API\nVega-Lite
              Altair
              Vega-Lite API\nExamples
              Tutorials
              Documentation
              Usage
              About
            
            
              GitHub
              Try Online\nExamples
              Tutorials
              Documentation
              Usage
              About\nGitHub
              Try Online\nVega – A Visualization Grammar\nVega – A Visualization Grammar\nVega is a visualization grammar, a declarative language for creating, saving, and sharing interactive visualization designs. With Vega, you can describe the visual appearance and interactive behavior of a visualization in a JSON format, and generate web-based views using Canvas or SVG.

Version 5.31.0

Vega provides basic building blocks for a wide variety of visualization designs: data loading and transformation, scales, map projections, axes, legends, and graphical marks such as rectangles, lines, plotting symbols, etc. Interaction techniques can be specified using reactive signals that dynamically modify a visualization in response to input event streams.

A Vega specification defines an interactive visualization in a JSON format. Specifications are parsed by Vega’s JavaScript runtime to generate both static images or interactive web-based views. Vega provides a convenient representation for computational generation of visualizations, and can serve as a foundation for new APIs and visual analysis tools.

To get started with Vega, take a look at the tutorials, example gallery, and usage guide, or read about the project’s goals.

To rapidly create common statistical graphics, check out Vega-Lite, a higher-level language built on top of Vega. Not that into JavaScript? Take a look at the Altair Python API for Vega-Lite.

Need help or want to share examples? Join the Vega discussion forum or the Vega Slack organization!\nVega is a visualization grammar, a declarative language for creating, saving, and sharing interactive visualization designs. With Vega, you can describe the visual appearance and interactive behavior of a visualization in a JSON format, and generate web-based views using Canvas or SVG.\nVega provides basic building blocks for a wide variety of visualization designs: data loading and transformation, scales, map projections, axes, legends, and graphical marks such as rectangles, lines, plotting symbols, etc. Interaction techniques can be specified using reactive signals that dynamically modify a visualization in response to input event streams.\nA Vega specification defines an interactive visualization in a JSON format. Specifications are parsed by Vega’s JavaScript runtime to generate both static images or interactive web-based views. Vega provides a convenient representation for computational generation of visualizations, and can serve as a foundation for new APIs and visual analysis tools.\nTo get started with Vega, take a look at the tutorials, example gallery, and usage guide, or read about the project’s goals.\nabout the project’s goals\nTo rapidly create common statistical graphics, check out Vega-Lite, a higher-level language built on top of Vega. Not that into JavaScript? Take a look at the Altair Python API for Vega-Lite.\nNeed help or want to share examples? Join the Vega discussion forum or the Vega Slack organization!\nVega discussion forum\nVega Slack organization\n\n\nVega-Lite
        
          Vega
          Altair
          Vega-Lite API
        
      
      
        
          Examples
          Tutorials
          Documentation
          Usage
          Ecosystem
        
        
          GitHub
          Try Online
        
      
    
  
  
    
  
Vega-Lite – A Grammar of Interactive Graphics



  
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
  




  
  Vega-Lite is a high-level grammar of interactive graphics. It provides a concise, declarative JSON syntax to create an expressive range of visualizations for data analysis and presentation.



  
    Vega-Lite specifications describe visualizations as encoding mappings from data to properties of graphical marks (e.g., points or bars).
    The Vega-Lite compiler automatically produces visualization components including axes, legends, and scales.
    It determines default properties of these components based on a set of carefully designed rules.
    This approach allows Vega-Lite specifications to be concise for quick visualization authoring, while giving user control to override defaults and customize various parts of a visualization.
    As we also designed Vega-Lite to support data analysis, Vega-Lite supports both data transformations (e.g., aggregation, binning, filtering, sorting) and visual transformations (e.g., stacking and faceting).
    Moreover, Vega-Lite specifications can be composed into layered and multi-view displays, and made interactive with selections.
  
  
  Get startedLatest Version: 6.1.0
  Try online
  


Compared to Vega, Vega-Lite provides a more concise and convenient form to author common visualizations. As Vega-Lite can compile its specifications to Vega specifications, users may use Vega-Lite as the primary visualization tool and, if needed, transition to use the lower-level Vega for advanced use cases.

For more information, read our introduction article to Vega-Lite v2 on Medium, watch our OpenVis Conf talk about the new features in Vega-Lite v2, see the documentation and take a look at our example gallery. Follow us on Twitter at @vega_vis to stay informed about updates.

Example


  
    With Vega-Lite, we can start with a bar chart of the average monthly precipitation in Seattle, overlay a rule for the overall yearly average, and have it represent an interactive moving average for a dragged region. Next step
  

  
    
      
    
    
      
    
    
      
      
        
      
    
  
  
    
    
    
  


Additional Links


  Award winning research paper and video of our OpenVis Conf talk on the design of Vega-Lite
  The about page for the Vega project
  Listen to a Data Stories episode about Declarative Visualization with Vega-Lite and Altair

  
JSON schema specification for Vega-Lite (latest)
  Ask questions about Vega-Lite on Stack Overflow or Slack

  Fork our Observable Notebook.


Users

Vega-Lite is used by thousands of data enthusiasts, developers, journalists, data scientists, teachers, and researchers across many organizations. Here are some of them. Learn about integrations on our ecosystem page.


  
  
  
  
  
  
  
  
  
  
  
  
  


Team

The development of Vega-Lite is led by the alumni and members of the University of Washington Interactive Data Lab (UW IDL), including Kanit “Ham” Wongsuphasawat (now at Databricks), Dominik Moritz (now at CMU / Apple), Arvind Satyanarayan (now at MIT), and Jeffrey Heer (UW IDL).

Vega-Lite gets significant contributions from its community. Please see the contributors page for the full list of contributors.\nVega-Lite
        
          Vega
          Altair
          Vega-Lite API\nVega
          Altair
          Vega-Lite API\nExamples
          Tutorials
          Documentation
          Usage
          Ecosystem
        
        
          GitHub
          Try Online\nExamples
          Tutorials
          Documentation
          Usage
          Ecosystem\nGitHub
          Try Online\nVega-Lite – A Grammar of Interactive Graphics\nVega-Lite – A Grammar of Interactive Graphics\nVega-Lite is a high-level grammar of interactive graphics. It provides a concise, declarative JSON syntax to create an expressive range of visualizations for data analysis and presentation.



  
    Vega-Lite specifications describe visualizations as encoding mappings from data to properties of graphical marks (e.g., points or bars).
    The Vega-Lite compiler automatically produces visualization components including axes, legends, and scales.
    It determines default properties of these components based on a set of carefully designed rules.
    This approach allows Vega-Lite specifications to be concise for quick visualization authoring, while giving user control to override defaults and customize various parts of a visualization.
    As we also designed Vega-Lite to support data analysis, Vega-Lite supports both data transformations (e.g., aggregation, binning, filtering, sorting) and visual transformations (e.g., stacking and faceting).
    Moreover, Vega-Lite specifications can be composed into layered and multi-view displays, and made interactive with selections.
  
  
  Get startedLatest Version: 6.1.0
  Try online
  


Compared to Vega, Vega-Lite provides a more concise and convenient form to author common visualizations. As Vega-Lite can compile its specifications to Vega specifications, users may use Vega-Lite as the primary visualization tool and, if needed, transition to use the lower-level Vega for advanced use cases.

For more information, read our introduction article to Vega-Lite v2 on Medium, watch our OpenVis Conf talk about the new features in Vega-Lite v2, see the documentation and take a look at our example gallery. Follow us on Twitter at @vega_vis to stay informed about updates.

Example


  
    With Vega-Lite, we can start with a bar chart of the average monthly precipitation in Seattle, overlay a rule for the overall yearly average, and have it represent an interactive moving average for a dragged region. Next step
  

  
    
      
    
    
      
    
    
      
      
        
      
    
  
  
    
    
    
  


Additional Links


  Award winning research paper and video of our OpenVis Conf talk on the design of Vega-Lite
  The about page for the Vega project
  Listen to a Data Stories episode about Declarative Visualization with Vega-Lite and Altair

  
JSON schema specification for Vega-Lite (latest)
  Ask questions about Vega-Lite on Stack Overflow or Slack

  Fork our Observable Notebook.


Users

Vega-Lite is used by thousands of data enthusiasts, developers, journalists, data scientists, teachers, and researchers across many organizations. Here are some of them. Learn about integrations on our ecosystem page.


  
  
  
  
  
  
  
  
  
  
  
  
  


Team

The development of Vega-Lite is led by the alumni and members of the University of Washington Interactive Data Lab (UW IDL), including Kanit “Ham” Wongsuphasawat (now at Databricks), Dominik Moritz (now at CMU / Apple), Arvind Satyanarayan (now at MIT), and Jeffrey Heer (UW IDL).

Vega-Lite gets significant contributions from its community. Please see the contributors page for the full list of contributors.\nVega-Lite is a high-level grammar of interactive graphics. It provides a concise, declarative JSON syntax to create an expressive range of visualizations for data analysis and presentation.\nVega-Lite specifications describe visualizations as encoding mappings from data to properties of graphical marks (e.g., points or bars).
    The Vega-Lite compiler automatically produces visualization components including axes, legends, and scales.
    It determines default properties of these components based on a set of carefully designed rules.
    This approach allows Vega-Lite specifications to be concise for quick visualization authoring, while giving user control to override defaults and customize various parts of a visualization.
    As we also designed Vega-Lite to support data analysis, Vega-Lite supports both data transformations (e.g., aggregation, binning, filtering, sorting) and visual transformations (e.g., stacking and faceting).
    Moreover, Vega-Lite specifications can be composed into layered and multi-view displays, and made interactive with selections.
  
  
  Get startedLatest Version: 6.1.0
  Try online\nVega-Lite specifications describe visualizations as encoding mappings from data to properties of graphical marks (e.g., points or bars).
    The Vega-Lite compiler automatically produces visualization components including axes, legends, and scales.
    It determines default properties of these components based on a set of carefully designed rules.
    This approach allows Vega-Lite specifications to be concise for quick visualization authoring, while giving user control to override defaults and customize various parts of a visualization.
    As we also designed Vega-Lite to support data analysis, Vega-Lite supports both data transformations (e.g., aggregation, binning, filtering, sorting) and visual transformations (e.g., stacking and faceting).
    Moreover, Vega-Lite specifications can be composed into layered and multi-view displays, and made interactive with selections.
  
  
  Get startedLatest Version: 6.1.0
  Try online\nVega-Lite specifications describe visualizations as encoding mappings from data to properties of graphical marks (e.g., points or bars).
    The Vega-Lite compiler automatically produces visualization components including axes, legends, and scales.
    It determines default properties of these components based on a set of carefully designed rules.
    This approach allows Vega-Lite specifications to be concise for quick visualization authoring, while giving user control to override defaults and customize various parts of a visualization.
    As we also designed Vega-Lite to support data analysis, Vega-Lite supports both data transformations (e.g., aggregation, binning, filtering, sorting) and visual transformations (e.g., stacking and faceting).
    Moreover, Vega-Lite specifications can be composed into layered and multi-view displays, and made interactive with selections.\nGet startedLatest Version: 6.1.0
  Try online\nGet startedLatest Version: 6.1.0\nCompared to Vega, Vega-Lite provides a more concise and convenient form to author common visualizations. As Vega-Lite can compile its specifications to Vega specifications, users may use Vega-Lite as the primary visualization tool and, if needed, transition to use the lower-level Vega for advanced use cases.\nFor more information, read our introduction article to Vega-Lite v2 on Medium, watch our OpenVis Conf talk about the new features in Vega-Lite v2, see the documentation and take a look at our example gallery. Follow us on Twitter at @vega_vis to stay informed about updates.\nintroduction article to Vega-Lite v2 on Medium\nOpenVis Conf talk about the new features in Vega-Lite v2\nWith Vega-Lite, we can start with a bar chart of the average monthly precipitation in Seattle, overlay a rule for the overall yearly average, and have it represent an interactive moving average for a dragged region. Next step\nWith Vega-Lite, we can start with a bar chart of the average monthly precipitation in Seattle, overlay a rule for the overall yearly average, and have it represent an interactive moving average for a dragged region. Next step\nbar chart of the average monthly precipitation\noverlay a rule for the overall yearly average\nan interactive moving average for a dragged region\nAward winning research paper and video of our OpenVis Conf talk on the design of Vega-Lite\nvideo of our OpenVis Conf talk\nThe about page for the Vega project\nThe about page for the Vega project\nListen to a Data Stories episode about Declarative Visualization with Vega-Lite and Altair\nDeclarative Visualization with Vega-Lite and Altair\nJSON schema specification for Vega-Lite (latest)\nAsk questions about Vega-Lite on Stack Overflow or Slack\nFork our Observable Notebook.\nVega-Lite is used by thousands of data enthusiasts, developers, journalists, data scientists, teachers, and researchers across many organizations. Here are some of them. Learn about integrations on our ecosystem page.\nThe development of Vega-Lite is led by the alumni and members of the University of Washington Interactive Data Lab (UW IDL), including Kanit “Ham” Wongsuphasawat (now at Databricks), Dominik Moritz (now at CMU / Apple), Arvind Satyanarayan (now at MIT), and Jeffrey Heer (UW IDL).\nUniversity of Washington Interactive Data Lab\nKanit “Ham” Wongsuphasawat\nVega-Lite gets significant contributions from its community. Please see the contributors page for the full list of contributors.\nEdit this page and submit a pull request!\nEdit this page and submit a pull request!\n\n\nvega-lite-api
      

      Vega-Lite API 






A JavaScript API for creating Vega-Lite JSON specifications. Vega-Lite is a high-level grammar for visual analysis that generates complete Vega specifications.

With the Vega-Lite API, you can write JavaScript code like this:

vl.markBar().data('data/movies.json').encode(
  vl.x().fieldQ('IMDB_Rating').bin(true),
  vl.y().count()
)


To produce Vega-Lite JSON like this:

{
  "mark": "bar",
  "data": {"url": "data/movies.json"},
  "encoding": {
    "x": {
      "bin": true,
      "field": "IMDB_Rating",
      "type": "quantitative"
    },
    "y": {
      "aggregate": "count",
      "type": "quantitative"
    }
  }
}


To get started with the Vega-Lite API, see these Observable notebooks:


  Introduction to Vega-Lite
  Vega-Lite API
  Vega-Lite API Collection


Build Instructions

For a basic setup allowing you to build the API and run tests:


  Clone https://github.com/vega/vega-lite-api.
  Run yarn to install dependencies for all packages. If you don’t have yarn installed, see https://yarnpkg.com/en/docs/install.
  Once installation is complete, run yarn build to build the API generator and generate API source code in the src directory. Run yarn test to additionally run the test suite.


API Reference

See the Vega-Lite JavaScript API Reference.


      
      
        This site is open source. Improve this page.\nA JavaScript API for creating Vega-Lite JSON specifications. Vega-Lite is a high-level grammar for visual analysis that generates complete Vega specifications.\nWith the Vega-Lite API, you can write JavaScript code like this:\nvl.markBar().data('data/movies.json').encode(
  vl.x().fieldQ('IMDB_Rating').bin(true),
  vl.y().count()
)\nvl.markBar().data('data/movies.json').encode(
  vl.x().fieldQ('IMDB_Rating').bin(true),
  vl.y().count()
)\nTo produce Vega-Lite JSON like this:\n{
  "mark": "bar",
  "data": {"url": "data/movies.json"},
  "encoding": {
    "x": {
      "bin": true,
      "field": "IMDB_Rating",
      "type": "quantitative"
    },
    "y": {
      "aggregate": "count",
      "type": "quantitative"
    }
  }
}\n{
  "mark": "bar",
  "data": {"url": "data/movies.json"},
  "encoding": {
    "x": {
      "bin": true,
      "field": "IMDB_Rating",
      "type": "quantitative"
    },
    "y": {
      "aggregate": "count",
      "type": "quantitative"
    }
  }
}\nTo get started with the Vega-Lite API, see these Observable notebooks:\nIntroduction to Vega-Lite\nIntroduction to Vega-Lite\nVega-Lite API Collection\nVega-Lite API Collection\nFor a basic setup allowing you to build the API and run tests:\nClone https://github.com/vega/vega-lite-api.\nRun yarn to install dependencies for all packages. If you don’t have yarn installed, see https://yarnpkg.com/en/docs/install.\nOnce installation is complete, run yarn build to build the API generator and generate API source code in the src directory. Run yarn test to additionally run the test suite.\nSee the Vega-Lite JavaScript API Reference.\nVega-Lite JavaScript API Reference\nThis site is open source. Improve this page.\n\n\nVega
            
              Vega-Lite
              Altair
              Vega-Lite API
            
          
          
            
              Examples
              Tutorials
              Documentation
              Usage
              About
            
            
              GitHub
              Try Online
            
          
        
      

      
        

  
  
    Example Gallery
    
Bar Charts



  
  Bar Chart





  
  Stacked Bar Chart





  
  Grouped Bar Chart





  
  Nested Bar Chart





  
  Population Pyramid



Line & Area Charts



  
  Line Chart





  
  Area Chart





  
  Stacked Area Chart





  
  Horizon Graph





  
  Job Voyager



Circular Charts



  
  Pie Chart





  
  Donut Chart





  
  Donut Chart Labelled





  
  Radial Plot





  
  Radar Chart



Scatter Plots



  
  Scatter Plot





  
  Scatter Plot Null Values





  
  Connected Scatter Plot





  
  Error Bars





  
  Barley Trellis Plot





  
  Regression





  
  Loess Regression





  
  Labeled Scatter Plot



Distributions



  
  Top K Plot





  
  Top K Plot With Others





  
  Histogram





  
  Histogram Null Values





  
  Dot Plot





  
  Probability Density





  
  Box Plot





  
  Violin Plot





  
  Binned Scatter Plot





  
  Contour Plot





  
  Wheat Plot





  
  Quantile Quantile Plot





  
  Quantile Dot Plot





  
  Hypothetical Outcome Plots





  
  Time Units



Geographic Maps



  
  County Unemployment





  
  Dorling Cartogram





  
  World Map





  
  Earthquakes





  
  Projections





  
  Zoomable World Map





  
  Distortion Comparison





  
  Volcano Contours





  
  Wind Vectors





  
  Annual Precipitation



Tree Diagrams



  
  Tree Layout





  
  Radial Tree Layout





  
  Treemap





  
  Circle Packing





  
  Sunburst



Network Diagrams



  
  Edge Bundling





  
  Force Directed Layout





  
  Reorderable Matrix





  
  Arc Diagram





  
  Airport Connections



Other Chart Types



  
  Heatmap





  
  Density Heatmaps





  
  Parallel Coordinates





  
  Word Cloud





  
  Beeswarm Plot





  
  Calendar View





  
  Packed Bubble Chart



Custom Designs



  
  Budget Forecasts





  
  Wheat And Wages





  
  Falkensee Population





  
  Annual Temperature





  
  Weekly Temperature





  
  Flight Passengers





  
  Timelines





  
  U District Cuisine





  
  Clock





  
  Watch





  
  Warming Stripes





  
  Earthquakes Globe





  
  Serpentine Timeline



Interaction Techniques



  
  Crossfilter Flights





  
  Overview Plus Detail





  
  Brushing Scatter Plots





  
  Zoomable Scatter Plot





  
  Zoomable Binned Plot





  
  Global Development





  
  Interactive Legend





  
  Stock Index Chart





  
  Pi Monte Carlo





  
  Zoomable Circle Packing





  
  Table Scrollbar





  
  Bar Line Toggle





  
  Map With Tooltip





  
  Pacman





  
  Platformer\nVega
            
              Vega-Lite
              Altair
              Vega-Lite API\nVega-Lite
              Altair
              Vega-Lite API\nExamples
              Tutorials
              Documentation
              Usage
              About
            
            
              GitHub
              Try Online\nExamples
              Tutorials
              Documentation
              Usage
              About\nGitHub
              Try Online\nExample Gallery
    
Bar Charts



  
  Bar Chart





  
  Stacked Bar Chart





  
  Grouped Bar Chart





  
  Nested Bar Chart





  
  Population Pyramid



Line & Area Charts



  
  Line Chart





  
  Area Chart





  
  Stacked Area Chart





  
  Horizon Graph





  
  Job Voyager



Circular Charts



  
  Pie Chart





  
  Donut Chart





  
  Donut Chart Labelled





  
  Radial Plot





  
  Radar Chart



Scatter Plots



  
  Scatter Plot





  
  Scatter Plot Null Values





  
  Connected Scatter Plot





  
  Error Bars





  
  Barley Trellis Plot





  
  Regression





  
  Loess Regression





  
  Labeled Scatter Plot



Distributions



  
  Top K Plot





  
  Top K Plot With Others





  
  Histogram





  
  Histogram Null Values





  
  Dot Plot





  
  Probability Density





  
  Box Plot





  
  Violin Plot





  
  Binned Scatter Plot





  
  Contour Plot





  
  Wheat Plot





  
  Quantile Quantile Plot





  
  Quantile Dot Plot





  
  Hypothetical Outcome Plots





  
  Time Units



Geographic Maps



  
  County Unemployment





  
  Dorling Cartogram





  
  World Map





  
  Earthquakes





  
  Projections





  
  Zoomable World Map





  
  Distortion Comparison





  
  Volcano Contours





  
  Wind Vectors





  
  Annual Precipitation



Tree Diagrams



  
  Tree Layout





  
  Radial Tree Layout





  
  Treemap





  
  Circle Packing





  
  Sunburst



Network Diagrams



  
  Edge Bundling





  
  Force Directed Layout





  
  Reorderable Matrix





  
  Arc Diagram





  
  Airport Connections



Other Chart Types



  
  Heatmap





  
  Density Heatmaps





  
  Parallel Coordinates





  
  Word Cloud





  
  Beeswarm Plot





  
  Calendar View





  
  Packed Bubble Chart



Custom Designs



  
  Budget Forecasts





  
  Wheat And Wages





  
  Falkensee Population





  
  Annual Temperature





  
  Weekly Temperature





  
  Flight Passengers





  
  Timelines





  
  U District Cuisine





  
  Clock





  
  Watch





  
  Warming Stripes





  
  Earthquakes Globe





  
  Serpentine Timeline



Interaction Techniques



  
  Crossfilter Flights





  
  Overview Plus Detail





  
  Brushing Scatter Plots





  
  Zoomable Scatter Plot





  
  Zoomable Binned Plot





  
  Global Development





  
  Interactive Legend





  
  Stock Index Chart





  
  Pi Monte Carlo





  
  Zoomable Circle Packing





  
  Table Scrollbar





  
  Bar Line Toggle





  
  Map With Tooltip





  
  Pacman





  
  Platformer\nScatter Plot Null Values\nScatter Plot Null Values\nConnected Scatter Plot\nConnected Scatter Plot\nTop K Plot With Others\nTop K Plot With Others\nHistogram Null Values\nHistogram Null Values\nQuantile Quantile Plot\nQuantile Quantile Plot\nHypothetical Outcome Plots\nHypothetical Outcome Plots\nDistortion Comparison\nDistortion Comparison\nForce Directed Layout\nForce Directed Layout\nInteraction Techniques\nBrushing Scatter Plots\nBrushing Scatter Plots\nZoomable Scatter Plot\nZoomable Scatter Plot\nZoomable Circle Packing\nZoomable Circle Packing\n\n\nVega
            
              Vega-Lite
              Altair
              Vega-Lite API
            
          
          
            
              Examples
              Tutorials
              Documentation
              Usage
              About
            
            
              GitHub
              Try Online
            
          
        
      

      
        

  
  
    Tutorials
    Tutorials for learning how to use Vega.

Let’s Make a Bar Chart

Skill level: Beginner. Learn the basic elements of Vega by creating a bar chart with interactive tooltips.

A Guide to Guides: Axes & Legends

Skill level: Intermediate. Tour the various types of axes and legends in Vega, learn how to parameterize them and adjust their layout.

Mapping Airport Connections

Skill level: Intermediate. Learn more advanced Vega features – including mapping, data transformation, and interaction – by building an interactive map of direct routes among major U.S. airports.

How Vega Works

Skill level: Advanced. How a Vega JSON specification becomes an interactive view, covering parsing, dataflow processing, scenegraph construction, and rendering.\nVega
            
              Vega-Lite
              Altair
              Vega-Lite API\nVega-Lite
              Altair
              Vega-Lite API\nExamples
              Tutorials
              Documentation
              Usage
              About
            
            
              GitHub
              Try Online\nExamples
              Tutorials
              Documentation
              Usage
              About\nGitHub
              Try Online\nTutorials
    Tutorials for learning how to use Vega.

Let’s Make a Bar Chart

Skill level: Beginner. Learn the basic elements of Vega by creating a bar chart with interactive tooltips.

A Guide to Guides: Axes & Legends

Skill level: Intermediate. Tour the various types of axes and legends in Vega, learn how to parameterize them and adjust their layout.

Mapping Airport Connections

Skill level: Intermediate. Learn more advanced Vega features – including mapping, data transformation, and interaction – by building an interactive map of direct routes among major U.S. airports.

How Vega Works

Skill level: Advanced. How a Vega JSON specification becomes an interactive view, covering parsing, dataflow processing, scenegraph construction, and rendering.\nTutorials for learning how to use Vega.\nLet’s Make a Bar Chart\nLet’s Make a Bar Chart\nSkill level: Beginner. Learn the basic elements of Vega by creating a bar chart with interactive tooltips.\nA Guide to Guides: Axes & Legends\nA Guide to Guides: Axes & Legends\nSkill level: Intermediate. Tour the various types of axes and legends in Vega, learn how to parameterize them and adjust their layout.\nMapping Airport Connections\nMapping Airport Connections\nSkill level: Intermediate. Learn more advanced Vega features – including mapping, data transformation, and interaction – by building an interactive map of direct routes among major U.S. airports.\nSkill level: Advanced. How a Vega JSON specification becomes an interactive view, covering parsing, dataflow processing, scenegraph construction, and rendering.\n\n\nVega
            
              Vega-Lite
              Altair
              Vega-Lite API
            
          
          
            
              Examples
              Tutorials
              Documentation
              Usage
              About
            
            
              GitHub
              Try Online
            
          
        
      

      
        

  
  
    Usage
    Vega can be deployed for interactive visualizations within a web browser, or to render static PNG and SVG images server-side. This page describes the various means of deployment and use.

Usage Reference


  Web Deployment
    
      Import Vega JavaScript
      Using the Vega View API
      Using the Vega-Embed Module
      Supporting Internet Explorer
      Content Security Policy
    
  
  Command Line Utilities
  Server-Side Deployment


Web Deployment

To deploy Vega on the web, first import the requisite JavaScript libraries. Then, use the Vega View API or the convenient Vega-Embed helper module to parse Vega specifications and add interactive visualizations to a web page.

Try Vega with Vega-Embed online and publish your own chart by forking our example Block.

Import Vega JavaScript

To use Vega on a web page you first need to load the Vega JavaScript files. The simplest option is to import the complete Vega bundle.

<head>
  <script src="https://vega.github.io/vega/vega.min.js"></script>
</head>


Loading Vega from a CDN. While the example above loads files from the Vega web site, for production deployments you will likely want to serve your own files or use a content delivery network (CDN). Vega releases are hosted on jsDelivr:

<head>
  <script src="https://cdn.jsdelivr.net/npm/vega@5"></script>
</head>


Using Vega and D3 together. The full vega.js and vega.min.js files bundle up all dependencies, including d3 modules and topojson-client. If you plan to independently use d3.js on your page, you can use a smaller Vega bundle that excludes redundant d3 files. Import d3 first, then import the smaller vega-core.min.js file to reduce the total file size. If you plan to load TopoJSON data files, you’ll need to import the topojson-client package as well.

<head>
  <script src="https://cdn.jsdelivr.net/npm/d3@7"></script>
  <script src="https://cdn.jsdelivr.net/npm/topojson-client@3"></script>
  <script src="https://cdn.jsdelivr.net/npm/vega@5/build/vega-core.min.js"></script>
</head>


Using Vega with a bundler. If you use Vega with a bundler like rollup.js, you can import Vega as a module.

import * as vega from "vega";


Back to reference

Using the Vega-Embed Module

The Vega-Embed module provides a convenient method for adding either Vega or Vega-Lite visualizations to a web page. This module will take care of steps such as loading specification files from a URL and generating views with standard configuration options. In addition, you can include accompanying links to export images and view source. For more, see the Vega-Embed repository.

<head>
  <script src="https://cdn.jsdelivr.net/npm/vega@5"></script>
  <script src="https://cdn.jsdelivr.net/npm/vega-lite@5"></script>
  <script src="https://cdn.jsdelivr.net/npm/vega-embed@6"></script>
</head>
<body>
  <div id="view"></div>
  <script>
    vegaEmbed(
      '#view',
      'https://vega.github.io/vega/examples/bar-chart.vg.json'
    );
  </script>
</body>


Back to reference

Using the Vega View API

Vega’s View component takes a parsed specification and configuration options as input and sets up an interactive web component. The View API also provides methods for streaming data updates, exporting static images, and accessing internal data for debugging purposes. For more, see the View component documentation.

<head>
  <script src="https://cdn.jsdelivr.net/npm/vega@5"></script>
</head>
<body>
  <div id="view"></div>
  <script type="text/javascript">
    var view;

    fetch('https://vega.github.io/vega/examples/bar-chart.vg.json')
      .then(res => res.json())
      .then(spec => render(spec))
      .catch(err => console.error(err));

    function render(spec) {
      view = new vega.View(vega.parse(spec), {
        renderer:  'canvas',  // renderer (canvas or svg)
        container: '#view',   // parent DOM container
        hover:     true       // enable hover processing
      });
      return view.runAsync();
    }
  </script>
</body>


Vega visualizations will be added to a parent DOM container element. This element (either a DOM object or a unique CSS selector string) must be provided  as a View constructor option or an as argument to the View initialize method. Note: Any existing content within the parent container element will be removed upon view initialization.

Back to reference

Vega and Content Security Policy (CSP)

By default Vega is not compliant with standard Content Security Policy (CSP), as it uses the Function constructor to generate functions defined in the Vega expression language. However, Vega allows use of alternative expression evaluators that are CSP-compliant. For more, see the expression interpreter usage documentation.

Back to reference

Command Line Utilities

The vega-cli package includes three node.js-based command line utilities – vg2pdf, vg2png, and vg2svg – for rendering static visualization images. These commands render to PDF, PNG, or SVG files, respectively.


  vg2pdf: vg2pdf [options] [input_vega_json_file] [output_pdf_file]
  vg2png: vg2png [options] [input_vega_json_file] [output_png_file]
  vg2svg: vg2svg [options] [input_vega_json_file] [output_svg_file]


If no input Vega JSON file is given, the utilities will attempt to read the file from standard input. If no output file is given, the resulting PDF, PNG, or SVG data will be written to standard output, and so can be piped into other applications.

The programs also accept the following (optional) parameters:


  -b, –base - [String] A base directory to use for data and image loading. For web retrieval, use -b http://host/data/. For files, use -b data/ (relative path) or -b file:///dir/data/ (absolute path).
  -h, –header - [Flag] Includes XML header and DOCTYPE in SVG output (vg2svg only).
  -s, –scale - [Number] [Default:1] A resolution scale factor. For example, -s 2 results in a doubling of the output resolution. For PDF or SVG, scales the output coordinate space.
  -seed, - [Number] Seed for random number generation. Allows for consistent output over random values. Internally replaces Math.random with a linear congruential generator.
  -c, –config, - [String] Provide a Vega config object. A file path string to a JSON file or .js file that exports an object.
  -f, –format, - [String] Set the number format locale. A file path string to a JSON file or .js file that exports an object.
  -t, –timeFormat, - [String] Set data/time format locale. A file path string to a JSON file or .js file that exports an object.
  -l, –loglevel - [String] Level of log messages written to standard error output. One of error, warn (default), info, or debug.
  –help - [Flag] Print usage help to the console.


To install the command line utilities, you must install the vega-cli npm package. For example, yarn global add vega-cli or npm install -g vega-cli will install the utilities for global use. If you install the package locally, the commands are accessible via your node_modules folder (./node_modules/bin/vg2png). The command line utilities depend on the node-canvas package. See below for more information about Vega and node-canvas.

All errors and logging message will be written to standard error output (stderr). To create a log file, pipe the stderr output to the desired file. For example: vg2pdf ...arguments 2> vg2pdf.log.

Examples

In the vega package, you can run the following from the command line if vega-cli is installed.

Render the bar chart example to a PNG file:

vg2png test/specs-valid/bar.vg.json bar.png


Render the bar chart example to an SVG file, including XML headers:

vg2svg -h test/specs-valid/bar.vg.json bar.svg


Render the arc example as a PDF, piped to a file via standard output:

vg2pdf test/specs-valid/arc.vg.json > arc.pdf


Render the choropleth example to a PNG file. A base directory is specified for loading data files:

vg2png -b test test/specs-valid/choropleth.vg.json > choropleth.png


Render the bar chart example to a PNG file at double resolution:

vg2png -s 2 test/specs-valid/bar.vg.json bar.png


Back to reference

Server-Side Deployment using Node.js

To use Vega as a component within a larger project, first install it either directly (yarn add vega or npm install vega) or by including "vega" among the dependencies in your package.json file. In node.js JavaScript code, import Vega using require('vega'). Much like browser-based deployments, Node.js deployments leverage the Vega View API. However, server-side View instances should use the renderer type none and provide no DOM element to the initialize method.

To generate PNG images and accurately measure font metrics for text mark truncation, the node-canvas package must be installed. The vega package does not require node-canvas by default, so you must include it as an explicit dependency in your own project if you wish to use it. The vega-cli package, on the other hand, does include node-canvas as an explicit dependency.

Occasionally some system configurations may run into errors while installing node-canvas. Please consult the node-canvas documentation if you experience installation issues.

Example

var vega = require('vega');

// create a new view instance for a given Vega JSON spec
var view = new vega.View(vega.parse(spec), {renderer: 'none'});

// generate a static SVG image
view.toSVG()
  .then(function(svg) {
    // process svg string
  })
  .catch(function(err) { console.error(err); });

// generate a static PNG image
view.toCanvas()
  .then(function(canvas) {
    // process node-canvas instance
    // for example, generate a PNG stream to write
    var stream = canvas.createPNGStream();
  })
  .catch(function(err) { console.error(err); });


Back to reference\nVega
            
              Vega-Lite
              Altair
              Vega-Lite API\nVega-Lite
              Altair
              Vega-Lite API\nExamples
              Tutorials
              Documentation
              Usage
              About
            
            
              GitHub
              Try Online\nExamples
              Tutorials
              Documentation
              Usage
              About\nGitHub
              Try Online\nUsage
    Vega can be deployed for interactive visualizations within a web browser, or to render static PNG and SVG images server-side. This page describes the various means of deployment and use.

Usage Reference


  Web Deployment
    
      Import Vega JavaScript
      Using the Vega View API
      Using the Vega-Embed Module
      Supporting Internet Explorer
      Content Security Policy
    
  
  Command Line Utilities
  Server-Side Deployment


Web Deployment

To deploy Vega on the web, first import the requisite JavaScript libraries. Then, use the Vega View API or the convenient Vega-Embed helper module to parse Vega specifications and add interactive visualizations to a web page.

Try Vega with Vega-Embed online and publish your own chart by forking our example Block.

Import Vega JavaScript

To use Vega on a web page you first need to load the Vega JavaScript files. The simplest option is to import the complete Vega bundle.

<head>
  <script src="https://vega.github.io/vega/vega.min.js"></script>
</head>


Loading Vega from a CDN. While the example above loads files from the Vega web site, for production deployments you will likely want to serve your own files or use a content delivery network (CDN). Vega releases are hosted on jsDelivr:

<head>
  <script src="https://cdn.jsdelivr.net/npm/vega@5"></script>
</head>


Using Vega and D3 together. The full vega.js and vega.min.js files bundle up all dependencies, including d3 modules and topojson-client. If you plan to independently use d3.js on your page, you can use a smaller Vega bundle that excludes redundant d3 files. Import d3 first, then import the smaller vega-core.min.js file to reduce the total file size. If you plan to load TopoJSON data files, you’ll need to import the topojson-client package as well.

<head>
  <script src="https://cdn.jsdelivr.net/npm/d3@7"></script>
  <script src="https://cdn.jsdelivr.net/npm/topojson-client@3"></script>
  <script src="https://cdn.jsdelivr.net/npm/vega@5/build/vega-core.min.js"></script>
</head>


Using Vega with a bundler. If you use Vega with a bundler like rollup.js, you can import Vega as a module.

import * as vega from "vega";


Back to reference

Using the Vega-Embed Module

The Vega-Embed module provides a convenient method for adding either Vega or Vega-Lite visualizations to a web page. This module will take care of steps such as loading specification files from a URL and generating views with standard configuration options. In addition, you can include accompanying links to export images and view source. For more, see the Vega-Embed repository.

<head>
  <script src="https://cdn.jsdelivr.net/npm/vega@5"></script>
  <script src="https://cdn.jsdelivr.net/npm/vega-lite@5"></script>
  <script src="https://cdn.jsdelivr.net/npm/vega-embed@6"></script>
</head>
<body>
  <div id="view"></div>
  <script>
    vegaEmbed(
      '#view',
      'https://vega.github.io/vega/examples/bar-chart.vg.json'
    );
  </script>
</body>


Back to reference

Using the Vega View API

Vega’s View component takes a parsed specification and configuration options as input and sets up an interactive web component. The View API also provides methods for streaming data updates, exporting static images, and accessing internal data for debugging purposes. For more, see the View component documentation.

<head>
  <script src="https://cdn.jsdelivr.net/npm/vega@5"></script>
</head>
<body>
  <div id="view"></div>
  <script type="text/javascript">
    var view;

    fetch('https://vega.github.io/vega/examples/bar-chart.vg.json')
      .then(res => res.json())
      .then(spec => render(spec))
      .catch(err => console.error(err));

    function render(spec) {
      view = new vega.View(vega.parse(spec), {
        renderer:  'canvas',  // renderer (canvas or svg)
        container: '#view',   // parent DOM container
        hover:     true       // enable hover processing
      });
      return view.runAsync();
    }
  </script>
</body>


Vega visualizations will be added to a parent DOM container element. This element (either a DOM object or a unique CSS selector string) must be provided  as a View constructor option or an as argument to the View initialize method. Note: Any existing content within the parent container element will be removed upon view initialization.

Back to reference

Vega and Content Security Policy (CSP)

By default Vega is not compliant with standard Content Security Policy (CSP), as it uses the Function constructor to generate functions defined in the Vega expression language. However, Vega allows use of alternative expression evaluators that are CSP-compliant. For more, see the expression interpreter usage documentation.

Back to reference

Command Line Utilities

The vega-cli package includes three node.js-based command line utilities – vg2pdf, vg2png, and vg2svg – for rendering static visualization images. These commands render to PDF, PNG, or SVG files, respectively.


  vg2pdf: vg2pdf [options] [input_vega_json_file] [output_pdf_file]
  vg2png: vg2png [options] [input_vega_json_file] [output_png_file]
  vg2svg: vg2svg [options] [input_vega_json_file] [output_svg_file]


If no input Vega JSON file is given, the utilities will attempt to read the file from standard input. If no output file is given, the resulting PDF, PNG, or SVG data will be written to standard output, and so can be piped into other applications.

The programs also accept the following (optional) parameters:


  -b, –base - [String] A base directory to use for data and image loading. For web retrieval, use -b http://host/data/. For files, use -b data/ (relative path) or -b file:///dir/data/ (absolute path).
  -h, –header - [Flag] Includes XML header and DOCTYPE in SVG output (vg2svg only).
  -s, –scale - [Number] [Default:1] A resolution scale factor. For example, -s 2 results in a doubling of the output resolution. For PDF or SVG, scales the output coordinate space.
  -seed, - [Number] Seed for random number generation. Allows for consistent output over random values. Internally replaces Math.random with a linear congruential generator.
  -c, –config, - [String] Provide a Vega config object. A file path string to a JSON file or .js file that exports an object.
  -f, –format, - [String] Set the number format locale. A file path string to a JSON file or .js file that exports an object.
  -t, –timeFormat, - [String] Set data/time format locale. A file path string to a JSON file or .js file that exports an object.
  -l, –loglevel - [String] Level of log messages written to standard error output. One of error, warn (default), info, or debug.
  –help - [Flag] Print usage help to the console.


To install the command line utilities, you must install the vega-cli npm package. For example, yarn global add vega-cli or npm install -g vega-cli will install the utilities for global use. If you install the package locally, the commands are accessible via your node_modules folder (./node_modules/bin/vg2png). The command line utilities depend on the node-canvas package. See below for more information about Vega and node-canvas.

All errors and logging message will be written to standard error output (stderr). To create a log file, pipe the stderr output to the desired file. For example: vg2pdf ...arguments 2> vg2pdf.log.

Examples

In the vega package, you can run the following from the command line if vega-cli is installed.

Render the bar chart example to a PNG file:

vg2png test/specs-valid/bar.vg.json bar.png


Render the bar chart example to an SVG file, including XML headers:

vg2svg -h test/specs-valid/bar.vg.json bar.svg


Render the arc example as a PDF, piped to a file via standard output:

vg2pdf test/specs-valid/arc.vg.json > arc.pdf


Render the choropleth example to a PNG file. A base directory is specified for loading data files:

vg2png -b test test/specs-valid/choropleth.vg.json > choropleth.png


Render the bar chart example to a PNG file at double resolution:

vg2png -s 2 test/specs-valid/bar.vg.json bar.png


Back to reference

Server-Side Deployment using Node.js

To use Vega as a component within a larger project, first install it either directly (yarn add vega or npm install vega) or by including "vega" among the dependencies in your package.json file. In node.js JavaScript code, import Vega using require('vega'). Much like browser-based deployments, Node.js deployments leverage the Vega View API. However, server-side View instances should use the renderer type none and provide no DOM element to the initialize method.

To generate PNG images and accurately measure font metrics for text mark truncation, the node-canvas package must be installed. The vega package does not require node-canvas by default, so you must include it as an explicit dependency in your own project if you wish to use it. The vega-cli package, on the other hand, does include node-canvas as an explicit dependency.

Occasionally some system configurations may run into errors while installing node-canvas. Please consult the node-canvas documentation if you experience installation issues.

Example

var vega = require('vega');

// create a new view instance for a given Vega JSON spec
var view = new vega.View(vega.parse(spec), {renderer: 'none'});

// generate a static SVG image
view.toSVG()
  .then(function(svg) {
    // process svg string
  })
  .catch(function(err) { console.error(err); });

// generate a static PNG image
view.toCanvas()
  .then(function(canvas) {
    // process node-canvas instance
    // for example, generate a PNG stream to write
    var stream = canvas.createPNGStream();
  })
  .catch(function(err) { console.error(err); });


Back to reference\nVega can be deployed for interactive visualizations within a web browser, or to render static PNG and SVG images server-side. This page describes the various means of deployment and use.\nWeb Deployment
    
      Import Vega JavaScript
      Using the Vega View API
      Using the Vega-Embed Module
      Supporting Internet Explorer
      Content Security Policy\nImport Vega JavaScript\nImport Vega JavaScript\nUsing the Vega View API\nUsing the Vega View API\nUsing the Vega-Embed Module\nUsing the Vega-Embed Module\nSupporting Internet Explorer\nSupporting Internet Explorer\nContent Security Policy\nContent Security Policy\nCommand Line Utilities\nCommand Line Utilities\nServer-Side Deployment\nServer-Side Deployment\nTo deploy Vega on the web, first import the requisite JavaScript libraries. Then, use the Vega View API or the convenient Vega-Embed helper module to parse Vega specifications and add interactive visualizations to a web page.\nTry Vega with Vega-Embed online and publish your own chart by forking our example Block.\nImport Vega JavaScript\nTo use Vega on a web page you first need to load the Vega JavaScript files. The simplest option is to import the complete Vega bundle.\n<head>
  <script src="https://vega.github.io/vega/vega.min.js"></script>
</head>\n<head>
  <script src="https://vega.github.io/vega/vega.min.js"></script>
</head>\n"https://vega.github.io/vega/vega.min.js"\nLoading Vega from a CDN. While the example above loads files from the Vega web site, for production deployments you will likely want to serve your own files or use a content delivery network (CDN). Vega releases are hosted on jsDelivr:\ncontent delivery network (CDN)\n<head>
  <script src="https://cdn.jsdelivr.net/npm/vega@5"></script>
</head>\n<head>
  <script src="https://cdn.jsdelivr.net/npm/vega@5"></script>
</head>\n"https://cdn.jsdelivr.net/npm/vega@5"\nUsing Vega and D3 together. The full vega.js and vega.min.js files bundle up all dependencies, including d3 modules and topojson-client. If you plan to independently use d3.js on your page, you can use a smaller Vega bundle that excludes redundant d3 files. Import d3 first, then import the smaller vega-core.min.js file to reduce the total file size. If you plan to load TopoJSON data files, you’ll need to import the topojson-client package as well.\n<head>
  <script src="https://cdn.jsdelivr.net/npm/d3@7"></script>
  <script src="https://cdn.jsdelivr.net/npm/topojson-client@3"></script>
  <script src="https://cdn.jsdelivr.net/npm/vega@5/build/vega-core.min.js"></script>
</head>\n<head>
  <script src="https://cdn.jsdelivr.net/npm/d3@7"></script>
  <script src="https://cdn.jsdelivr.net/npm/topojson-client@3"></script>
  <script src="https://cdn.jsdelivr.net/npm/vega@5/build/vega-core.min.js"></script>
</head>\n"https://cdn.jsdelivr.net/npm/d3@7"\n"https://cdn.jsdelivr.net/npm/topojson-client@3"\n"https://cdn.jsdelivr.net/npm/vega@5/build/vega-core.min.js"\nUsing Vega with a bundler. If you use Vega with a bundler like rollup.js, you can import Vega as a module.\nimport * as vega from "vega";\nimport * as vega from "vega";\nUsing the Vega-Embed Module\nThe Vega-Embed module provides a convenient method for adding either Vega or Vega-Lite visualizations to a web page. This module will take care of steps such as loading specification files from a URL and generating views with standard configuration options. In addition, you can include accompanying links to export images and view source. For more, see the Vega-Embed repository.\nVega-Embed repository\n<head>
  <script src="https://cdn.jsdelivr.net/npm/vega@5"></script>
  <script src="https://cdn.jsdelivr.net/npm/vega-lite@5"></script>
  <script src="https://cdn.jsdelivr.net/npm/vega-embed@6"></script>
</head>
<body>
  <div id="view"></div>
  <script>
    vegaEmbed(
      '#view',
      'https://vega.github.io/vega/examples/bar-chart.vg.json'
    );
  </script>
</body>\n<head>
  <script src="https://cdn.jsdelivr.net/npm/vega@5"></script>
  <script src="https://cdn.jsdelivr.net/npm/vega-lite@5"></script>
  <script src="https://cdn.jsdelivr.net/npm/vega-embed@6"></script>
</head>
<body>
  <div id="view"></div>
  <script>
    vegaEmbed(
      '#view',
      'https://vega.github.io/vega/examples/bar-chart.vg.json'
    );
  </script>
</body>\n"https://cdn.jsdelivr.net/npm/vega@5"\n"https://cdn.jsdelivr.net/npm/vega-lite@5"\n"https://cdn.jsdelivr.net/npm/vega-embed@6"\nhttps://vega.github.io/vega/examples/bar-chart.vg.json\nUsing the Vega View API\nVega’s View component takes a parsed specification and configuration options as input and sets up an interactive web component. The View API also provides methods for streaming data updates, exporting static images, and accessing internal data for debugging purposes. For more, see the View component documentation.\n<head>
  <script src="https://cdn.jsdelivr.net/npm/vega@5"></script>
</head>
<body>
  <div id="view"></div>
  <script type="text/javascript">
    var view;

    fetch('https://vega.github.io/vega/examples/bar-chart.vg.json')
      .then(res => res.json())
      .then(spec => render(spec))
      .catch(err => console.error(err));

    function render(spec) {
      view = new vega.View(vega.parse(spec), {
        renderer:  'canvas',  // renderer (canvas or svg)
        container: '#view',   // parent DOM container
        hover:     true       // enable hover processing
      });
      return view.runAsync();
    }
  </script>
</body>\n<head>
  <script src="https://cdn.jsdelivr.net/npm/vega@5"></script>
</head>
<body>
  <div id="view"></div>
  <script type="text/javascript">
    var view;

    fetch('https://vega.github.io/vega/examples/bar-chart.vg.json')
      .then(res => res.json())
      .then(spec => render(spec))
      .catch(err => console.error(err));

    function render(spec) {
      view = new vega.View(vega.parse(spec), {
        renderer:  'canvas',  // renderer (canvas or svg)
        container: '#view',   // parent DOM container
        hover:     true       // enable hover processing
      });
      return view.runAsync();
    }
  </script>
</body>\n"https://cdn.jsdelivr.net/npm/vega@5"\nhttps://vega.github.io/vega/examples/bar-chart.vg.json\n// renderer (canvas or svg)\n// parent DOM container\n// enable hover processing\nVega visualizations will be added to a parent DOM container element. This element (either a DOM object or a unique CSS selector string) must be provided  as a View constructor option or an as argument to the View initialize method. Note: Any existing content within the parent container element will be removed upon view initialization.\nVega and Content Security Policy (CSP)\nBy default Vega is not compliant with standard Content Security Policy (CSP), as it uses the Function constructor to generate functions defined in the Vega expression language. However, Vega allows use of alternative expression evaluators that are CSP-compliant. For more, see the expression interpreter usage documentation.\nContent Security Policy (CSP)\nexpression interpreter\nCommand Line Utilities\nThe vega-cli package includes three node.js-based command line utilities – vg2pdf, vg2png, and vg2svg – for rendering static visualization images. These commands render to PDF, PNG, or SVG files, respectively.\nvg2pdf: vg2pdf [options] [input_vega_json_file] [output_pdf_file]\nvg2png: vg2png [options] [input_vega_json_file] [output_png_file]\nvg2svg: vg2svg [options] [input_vega_json_file] [output_svg_file]\nIf no input Vega JSON file is given, the utilities will attempt to read the file from standard input. If no output file is given, the resulting PDF, PNG, or SVG data will be written to standard output, and so can be piped into other applications.\nThe programs also accept the following (optional) parameters:\n-b, –base - [String] A base directory to use for data and image loading. For web retrieval, use -b http://host/data/. For files, use -b data/ (relative path) or -b file:///dir/data/ (absolute path).\n-h, –header - [Flag] Includes XML header and DOCTYPE in SVG output (vg2svg only).\n-s, –scale - [Number] [Default:1] A resolution scale factor. For example, -s 2 results in a doubling of the output resolution. For PDF or SVG, scales the output coordinate space.\n-seed, - [Number] Seed for random number generation. Allows for consistent output over random values. Internally replaces Math.random with a linear congruential generator.\nlinear congruential generator\n-c, –config, - [String] Provide a Vega config object. A file path string to a JSON file or .js file that exports an object.\n-f, –format, - [String] Set the number format locale. A file path string to a JSON file or .js file that exports an object.\n-t, –timeFormat, - [String] Set data/time format locale. A file path string to a JSON file or .js file that exports an object.\ndata/time format locale\n-l, –loglevel - [String] Level of log messages written to standard error output. One of error, warn (default), info, or debug.\n–help - [Flag] Print usage help to the console.\nTo install the command line utilities, you must install the vega-cli npm package. For example, yarn global add vega-cli or npm install -g vega-cli will install the utilities for global use. If you install the package locally, the commands are accessible via your node_modules folder (./node_modules/bin/vg2png). The command line utilities depend on the node-canvas package. See below for more information about Vega and node-canvas.\ninformation about Vega and node-canvas\nAll errors and logging message will be written to standard error output (stderr). To create a log file, pipe the stderr output to the desired file. For example: vg2pdf ...arguments 2> vg2pdf.log.\nIn the vega package, you can run the following from the command line if vega-cli is installed.\nRender the bar chart example to a PNG file:\nvg2png test/specs-valid/bar.vg.json bar.png\nvg2png test/specs-valid/bar.vg.json bar.png\nRender the bar chart example to an SVG file, including XML headers:\nvg2svg -h test/specs-valid/bar.vg.json bar.svg\nvg2svg -h test/specs-valid/bar.vg.json bar.svg\nRender the arc example as a PDF, piped to a file via standard output:\nvg2pdf test/specs-valid/arc.vg.json > arc.pdf\nvg2pdf test/specs-valid/arc.vg.json > arc.pdf\nRender the choropleth example to a PNG file. A base directory is specified for loading data files:\nvg2png -b test test/specs-valid/choropleth.vg.json > choropleth.png\nvg2png -b test test/specs-valid/choropleth.vg.json > choropleth.png\nRender the bar chart example to a PNG file at double resolution:\nvg2png -s 2 test/specs-valid/bar.vg.json bar.png\nvg2png -s 2 test/specs-valid/bar.vg.json bar.png\nServer-Side Deployment using Node.js\nTo use Vega as a component within a larger project, first install it either directly (yarn add vega or npm install vega) or by including "vega" among the dependencies in your package.json file. In node.js JavaScript code, import Vega using require('vega'). Much like browser-based deployments, Node.js deployments leverage the Vega View API. However, server-side View instances should use the renderer type none and provide no DOM element to the initialize method.\nTo generate PNG images and accurately measure font metrics for text mark truncation, the node-canvas package must be installed. The vega package does not require node-canvas by default, so you must include it as an explicit dependency in your own project if you wish to use it. The vega-cli package, on the other hand, does include node-canvas as an explicit dependency.\nOccasionally some system configurations may run into errors while installing node-canvas. Please consult the node-canvas documentation if you experience installation issues.\nnode-canvas documentation\nvar vega = require('vega');

// create a new view instance for a given Vega JSON spec
var view = new vega.View(vega.parse(spec), {renderer: 'none'});

// generate a static SVG image
view.toSVG()
  .then(function(svg) {
    // process svg string
  })
  .catch(function(err) { console.error(err); });

// generate a static PNG image
view.toCanvas()
  .then(function(canvas) {
    // process node-canvas instance
    // for example, generate a PNG stream to write
    var stream = canvas.createPNGStream();
  })
  .catch(function(err) { console.error(err); });\nvar vega = require('vega');

// create a new view instance for a given Vega JSON spec
var view = new vega.View(vega.parse(spec), {renderer: 'none'});

// generate a static SVG image
view.toSVG()
  .then(function(svg) {
    // process svg string
  })
  .catch(function(err) { console.error(err); });

// generate a static PNG image
view.toCanvas()
  .then(function(canvas) {
    // process node-canvas instance
    // for example, generate a PNG stream to write
    var stream = canvas.createPNGStream();
  })
  .catch(function(err) { console.error(err); });\n// create a new view instance for a given Vega JSON spec\n// generate a static SVG image\n// process svg string\n// generate a static PNG image\n// process node-canvas instance\n// for example, generate a PNG stream to write\n\n\nVega
            
              Vega-Lite
              Altair
              Vega-Lite API
            
          
          
            
              Examples
              Tutorials
              Documentation
              Usage
              About
            
            
              GitHub
              Try Online
            
          
        
      

      
        

  
  
    
      
      
        About
      
      
      
      
        Video
      
      
      
      
        Projects
      
      
      
      
        Research
      
      
      
      
        Vega and D3
      
      
      
      
        Code of Conduct
      
      
    
  
  
    About the Vega Project
    Over years working in data visualization, we’ve sought to build tools that help designers craft sophisticated graphics, including systems such as Prefuse, Protovis and D3.js. However, in the grand scheme of things, “artisanal” visualizations hand-coded by skilled designers are the exception, not the rule. The vast majority of the world’s visualizations instead are produced using end-user applications such as spreadsheets and business intelligence tools. While valuable, these tools often fall short of fully supporting the iterative, interactive process of data analysis. Improved tools could help a larger swath of people create effective visualizations and better understand their data.

The goal of the Vega project is to promote an ecosystem of usable and interoperable tools, supporting use cases ranging from exploratory data analysis to effective communication via custom visualization design.

This goal has led us to develop not a singular system, but rather a stack of tools for interactive data visualization. At the foundation of this stack is the Vega visualization grammar. Similar in spirit to how SQL provides a language for expressing database queries, Vega provides a declarative language for describing visualizations. Vega specifications include the data transformations and visual encoding rules needed to express a rich space of visualizations. Building on libraries such as D3, the Vega runtime parses specifications in a JSON format to produce interactive web-based graphics. One unique aspect of Vega is its support for declarative interaction design: instead of the “spaghetti code” of event handler callbacks, Vega treats user input (mouse movement, touch events, etc.) as first-class streaming data to drive reactive updates to a visualization.

While Vega is useful in its own right (for example, Vega is deployed on Wikipedia to define visualizations directly within wiki pages), our primary motivation is for Vega to serve as a foundation for higher-level tools. Vega provides a formal language and computational file format for representing and reasoning about visualizations. In other words, Vega provides a more convenient yet powerful means for writing programs that generate visualizations, ranging from interactive design tools to automatic chart recommendation tools. Vega provides a performant runtime and can serve as an “assembly language” for visualization, letting other tools focus on design questions rather than low-level implementation details.

Want to Learn More?


  
    
      Video
      Videos of presentations about Vega and related topics.
    
    
      Projects
      Other languages, tools and models built on Vega.
    
    
      Research
      Research publications from the Vega project.
    
    
      Vega and D3
      On the relationship between Vega and D3.
    
    
      Code of Conduct
      The Vega project is governed by a code of conduct to foster an inclusive community.\nVega
            
              Vega-Lite
              Altair
              Vega-Lite API\nVega-Lite
              Altair
              Vega-Lite API\nExamples
              Tutorials
              Documentation
              Usage
              About
            
            
              GitHub
              Try Online\nExamples
              Tutorials
              Documentation
              Usage
              About\nGitHub
              Try Online\nAbout
      
      
      
      
        Video
      
      
      
      
        Projects
      
      
      
      
        Research
      
      
      
      
        Vega and D3
      
      
      
      
        Code of Conduct
      
      
    
  
  
    About the Vega Project
    Over years working in data visualization, we’ve sought to build tools that help designers craft sophisticated graphics, including systems such as Prefuse, Protovis and D3.js. However, in the grand scheme of things, “artisanal” visualizations hand-coded by skilled designers are the exception, not the rule. The vast majority of the world’s visualizations instead are produced using end-user applications such as spreadsheets and business intelligence tools. While valuable, these tools often fall short of fully supporting the iterative, interactive process of data analysis. Improved tools could help a larger swath of people create effective visualizations and better understand their data.

The goal of the Vega project is to promote an ecosystem of usable and interoperable tools, supporting use cases ranging from exploratory data analysis to effective communication via custom visualization design.

This goal has led us to develop not a singular system, but rather a stack of tools for interactive data visualization. At the foundation of this stack is the Vega visualization grammar. Similar in spirit to how SQL provides a language for expressing database queries, Vega provides a declarative language for describing visualizations. Vega specifications include the data transformations and visual encoding rules needed to express a rich space of visualizations. Building on libraries such as D3, the Vega runtime parses specifications in a JSON format to produce interactive web-based graphics. One unique aspect of Vega is its support for declarative interaction design: instead of the “spaghetti code” of event handler callbacks, Vega treats user input (mouse movement, touch events, etc.) as first-class streaming data to drive reactive updates to a visualization.

While Vega is useful in its own right (for example, Vega is deployed on Wikipedia to define visualizations directly within wiki pages), our primary motivation is for Vega to serve as a foundation for higher-level tools. Vega provides a formal language and computational file format for representing and reasoning about visualizations. In other words, Vega provides a more convenient yet powerful means for writing programs that generate visualizations, ranging from interactive design tools to automatic chart recommendation tools. Vega provides a performant runtime and can serve as an “assembly language” for visualization, letting other tools focus on design questions rather than low-level implementation details.

Want to Learn More?


  
    
      Video
      Videos of presentations about Vega and related topics.
    
    
      Projects
      Other languages, tools and models built on Vega.
    
    
      Research
      Research publications from the Vega project.
    
    
      Vega and D3
      On the relationship between Vega and D3.
    
    
      Code of Conduct
      The Vega project is governed by a code of conduct to foster an inclusive community.\nAbout the Vega Project\nOver years working in data visualization, we’ve sought to build tools that help designers craft sophisticated graphics, including systems such as Prefuse, Protovis and D3.js. However, in the grand scheme of things, “artisanal” visualizations hand-coded by skilled designers are the exception, not the rule. The vast majority of the world’s visualizations instead are produced using end-user applications such as spreadsheets and business intelligence tools. While valuable, these tools often fall short of fully supporting the iterative, interactive process of data analysis. Improved tools could help a larger swath of people create effective visualizations and better understand their data.\nThe goal of the Vega project is to promote an ecosystem of usable and interoperable tools, supporting use cases ranging from exploratory data analysis to effective communication via custom visualization design.\nThis goal has led us to develop not a singular system, but rather a stack of tools for interactive data visualization. At the foundation of this stack is the Vega visualization grammar. Similar in spirit to how SQL provides a language for expressing database queries, Vega provides a declarative language for describing visualizations. Vega specifications include the data transformations and visual encoding rules needed to express a rich space of visualizations. Building on libraries such as D3, the Vega runtime parses specifications in a JSON format to produce interactive web-based graphics. One unique aspect of Vega is its support for declarative interaction design: instead of the “spaghetti code” of event handler callbacks, Vega treats user input (mouse movement, touch events, etc.) as first-class streaming data to drive reactive updates to a visualization.\nWhile Vega is useful in its own right (for example, Vega is deployed on Wikipedia to define visualizations directly within wiki pages), our primary motivation is for Vega to serve as a foundation for higher-level tools. Vega provides a formal language and computational file format for representing and reasoning about visualizations. In other words, Vega provides a more convenient yet powerful means for writing programs that generate visualizations, ranging from interactive design tools to automatic chart recommendation tools. Vega provides a performant runtime and can serve as an “assembly language” for visualization, letting other tools focus on design questions rather than low-level implementation details.\nVega is deployed on Wikipedia\nVideos of presentations about Vega and related topics.\nOther languages, tools and models built on Vega.\nResearch publications from the Vega project.\nOn the relationship between Vega and D3.\nThe Vega project is governed by a code of conduct to foster an inclusive community.\n\n\n\n\nVega
            
              Vega-Lite
              Altair
              Vega-Lite API
            
          
          
            
              Examples
              Tutorials
              Documentation
              Usage
              About
            
            
              GitHub
              Try Online
            
          
        
      

      
        

  
  
    Documentation
    The Vega visualization grammar provides basic building blocks for a wide variety of visualization designs. This page provides documentation of Vega JSON specifications and JavaScript API.

To start learning Vega, we recommend first working through the introductory Let’s Make A Bar Chart tutorial and exploring the example gallery, then digging into the documentation. These pages document Vega version 3.0 and later; if you are familiar with Vega 2.x, you might begin with the Vega 2 porting guide.

Specification Reference

A Vega specification is a JSON object that describes an interactive visualization design. A specification consists of basic properties (such as the width and height of the view) and definitions for the data to visualize, scales that map data values to visual values, axes and legends that visualize these scales, cartographic projections for drawing maps, graphical marks such as rectangles, lines, and symbols to visually represent data, and signals to process user input and modify the visualization in response.


  
    
      Specification
      Overview of a full Vega specification, including sizing and metadata.
    
    
      Config
      Configure defaults for visual encoding choices.
    
    
      Data
      Define, load, and parse data to visualize.
    
    
      Transforms
      Apply data transforms (filter, sort, aggregate, layout) prior to visualization.
    
    
      Triggers
      Modify data sets or mark properties in response to signal values.
    
    
      Projections
      Cartographic projections to map (longitude, latitude) data.
    
    
      Scales
      Map data values (numbers, strings) to visual properties (coordinates, colors, sizes).
    
    
      Schemes
      Color schemes that can be used as scale ranges.
    
    
      Axes
      Visualize scale mappings for spatial encodings using coordinate axes.
    
    
      Legends
      Visualize scale mappings for color, shape and size encodings.
    
    
      Title
      Specify a chart title for a visualization.
    
    
      Marks
      Visually encode data with graphical marks such as rectangles, lines, and symbols.
    
    
      Signals
      Dynamic variables that can drive interactive updates.
    
    
      Event Streams
      Define input event streams to specify interactions.
    
    
      Expressions
      Express custom calculations over data and signals.
    
    
      Layout
      Perform grid layout for a collection of group marks.
    
    
      Types
      Documentation of recurring parameter types.
    
  


Vega API Reference

Vega also provides a JavaScript runtime API, responsible for parsing JSON specifications to produce interactive views backed by a reactive dataflow graph of data processing operators. For more on deploying Vega, see the usage instructions.


  
    
      Parser
      Parse Vega JSON specifications to dataflow descriptions.
    
    
      View
      Create interactive views from dataflow descriptions.
    
    
      Locale
      Use number and date formats for a specific locale.
    
    
      Extensibility
      Extend Vega with new projections, scales, color schemes, or data transforms.
    
    
      Statistics
      Statistical methods used by Vega.
    
    
      Time
      Utility methods for date-time values.
    
    
      Util
      General JavaScript utilities.
    
    
      Debugging
      A guide to debugging Vega visualizations at runtime.\nVega
            
              Vega-Lite
              Altair
              Vega-Lite API\nVega-Lite
              Altair
              Vega-Lite API\nExamples
              Tutorials
              Documentation
              Usage
              About
            
            
              GitHub
              Try Online\nExamples
              Tutorials
              Documentation
              Usage
              About\nGitHub
              Try Online\nDocumentation
    The Vega visualization grammar provides basic building blocks for a wide variety of visualization designs. This page provides documentation of Vega JSON specifications and JavaScript API.

To start learning Vega, we recommend first working through the introductory Let’s Make A Bar Chart tutorial and exploring the example gallery, then digging into the documentation. These pages document Vega version 3.0 and later; if you are familiar with Vega 2.x, you might begin with the Vega 2 porting guide.

Specification Reference

A Vega specification is a JSON object that describes an interactive visualization design. A specification consists of basic properties (such as the width and height of the view) and definitions for the data to visualize, scales that map data values to visual values, axes and legends that visualize these scales, cartographic projections for drawing maps, graphical marks such as rectangles, lines, and symbols to visually represent data, and signals to process user input and modify the visualization in response.


  
    
      Specification
      Overview of a full Vega specification, including sizing and metadata.
    
    
      Config
      Configure defaults for visual encoding choices.
    
    
      Data
      Define, load, and parse data to visualize.
    
    
      Transforms
      Apply data transforms (filter, sort, aggregate, layout) prior to visualization.
    
    
      Triggers
      Modify data sets or mark properties in response to signal values.
    
    
      Projections
      Cartographic projections to map (longitude, latitude) data.
    
    
      Scales
      Map data values (numbers, strings) to visual properties (coordinates, colors, sizes).
    
    
      Schemes
      Color schemes that can be used as scale ranges.
    
    
      Axes
      Visualize scale mappings for spatial encodings using coordinate axes.
    
    
      Legends
      Visualize scale mappings for color, shape and size encodings.
    
    
      Title
      Specify a chart title for a visualization.
    
    
      Marks
      Visually encode data with graphical marks such as rectangles, lines, and symbols.
    
    
      Signals
      Dynamic variables that can drive interactive updates.
    
    
      Event Streams
      Define input event streams to specify interactions.
    
    
      Expressions
      Express custom calculations over data and signals.
    
    
      Layout
      Perform grid layout for a collection of group marks.
    
    
      Types
      Documentation of recurring parameter types.
    
  


Vega API Reference

Vega also provides a JavaScript runtime API, responsible for parsing JSON specifications to produce interactive views backed by a reactive dataflow graph of data processing operators. For more on deploying Vega, see the usage instructions.


  
    
      Parser
      Parse Vega JSON specifications to dataflow descriptions.
    
    
      View
      Create interactive views from dataflow descriptions.
    
    
      Locale
      Use number and date formats for a specific locale.
    
    
      Extensibility
      Extend Vega with new projections, scales, color schemes, or data transforms.
    
    
      Statistics
      Statistical methods used by Vega.
    
    
      Time
      Utility methods for date-time values.
    
    
      Util
      General JavaScript utilities.
    
    
      Debugging
      A guide to debugging Vega visualizations at runtime.\nThe Vega visualization grammar provides basic building blocks for a wide variety of visualization designs. This page provides documentation of Vega JSON specifications and JavaScript API.\nVega JSON specifications\nTo start learning Vega, we recommend first working through the introductory Let’s Make A Bar Chart tutorial and exploring the example gallery, then digging into the documentation. These pages document Vega version 3.0 and later; if you are familiar with Vega 2.x, you might begin with the Vega 2 porting guide.\nLet’s Make A Bar Chart tutorial\nSpecification Reference\nA Vega specification is a JSON object that describes an interactive visualization design. A specification consists of basic properties (such as the width and height of the view) and definitions for the data to visualize, scales that map data values to visual values, axes and legends that visualize these scales, cartographic projections for drawing maps, graphical marks such as rectangles, lines, and symbols to visually represent data, and signals to process user input and modify the visualization in response.\nOverview of a full Vega specification, including sizing and metadata.\nConfigure defaults for visual encoding choices.\nDefine, load, and parse data to visualize.\nApply data transforms (filter, sort, aggregate, layout) prior to visualization.\nModify data sets or mark properties in response to signal values.\nCartographic projections to map (longitude, latitude) data.\nMap data values (numbers, strings) to visual properties (coordinates, colors, sizes).\nColor schemes that can be used as scale ranges.\nVisualize scale mappings for spatial encodings using coordinate axes.\nVisualize scale mappings for color, shape and size encodings.\nSpecify a chart title for a visualization.\nVisually encode data with graphical marks such as rectangles, lines, and symbols.\nDynamic variables that can drive interactive updates.\nDefine input event streams to specify interactions.\nExpress custom calculations over data and signals.\nPerform grid layout for a collection of group marks.\nDocumentation of recurring parameter types.\nVega also provides a JavaScript runtime API, responsible for parsing JSON specifications to produce interactive views backed by a reactive dataflow graph of data processing operators. For more on deploying Vega, see the usage instructions.\nParse Vega JSON specifications to dataflow descriptions.\nCreate interactive views from dataflow descriptions.\nUse number and date formats for a specific locale.\nExtend Vega with new projections, scales, color schemes, or data transforms.\nStatistical methods used by Vega.\nUtility methods for date-time values.\nGeneral JavaScript utilities.\nA guide to debugging Vega visualizations at runtime.\n\n\nVega
            
              Vega-Lite
              Altair
              Vega-Lite API
            
          
          
            
              Examples
              Tutorials
              Documentation
              Usage
              About
            
            
              GitHub
              Try Online
            
          
        
      

      
        

  
  
    Documentation
    The Vega visualization grammar provides basic building blocks for a wide variety of visualization designs. This page provides documentation of Vega JSON specifications and JavaScript API.

To start learning Vega, we recommend first working through the introductory Let’s Make A Bar Chart tutorial and exploring the example gallery, then digging into the documentation. These pages document Vega version 3.0 and later; if you are familiar with Vega 2.x, you might begin with the Vega 2 porting guide.

Specification Reference

A Vega specification is a JSON object that describes an interactive visualization design. A specification consists of basic properties (such as the width and height of the view) and definitions for the data to visualize, scales that map data values to visual values, axes and legends that visualize these scales, cartographic projections for drawing maps, graphical marks such as rectangles, lines, and symbols to visually represent data, and signals to process user input and modify the visualization in response.


  
    
      Specification
      Overview of a full Vega specification, including sizing and metadata.
    
    
      Config
      Configure defaults for visual encoding choices.
    
    
      Data
      Define, load, and parse data to visualize.
    
    
      Transforms
      Apply data transforms (filter, sort, aggregate, layout) prior to visualization.
    
    
      Triggers
      Modify data sets or mark properties in response to signal values.
    
    
      Projections
      Cartographic projections to map (longitude, latitude) data.
    
    
      Scales
      Map data values (numbers, strings) to visual properties (coordinates, colors, sizes).
    
    
      Schemes
      Color schemes that can be used as scale ranges.
    
    
      Axes
      Visualize scale mappings for spatial encodings using coordinate axes.
    
    
      Legends
      Visualize scale mappings for color, shape and size encodings.
    
    
      Title
      Specify a chart title for a visualization.
    
    
      Marks
      Visually encode data with graphical marks such as rectangles, lines, and symbols.
    
    
      Signals
      Dynamic variables that can drive interactive updates.
    
    
      Event Streams
      Define input event streams to specify interactions.
    
    
      Expressions
      Express custom calculations over data and signals.
    
    
      Layout
      Perform grid layout for a collection of group marks.
    
    
      Types
      Documentation of recurring parameter types.
    
  


Vega API Reference

Vega also provides a JavaScript runtime API, responsible for parsing JSON specifications to produce interactive views backed by a reactive dataflow graph of data processing operators. For more on deploying Vega, see the usage instructions.


  
    
      Parser
      Parse Vega JSON specifications to dataflow descriptions.
    
    
      View
      Create interactive views from dataflow descriptions.
    
    
      Locale
      Use number and date formats for a specific locale.
    
    
      Extensibility
      Extend Vega with new projections, scales, color schemes, or data transforms.
    
    
      Statistics
      Statistical methods used by Vega.
    
    
      Time
      Utility methods for date-time values.
    
    
      Util
      General JavaScript utilities.
    
    
      Debugging
      A guide to debugging Vega visualizations at runtime.\nVega
            
              Vega-Lite
              Altair
              Vega-Lite API\nVega-Lite
              Altair
              Vega-Lite API\nExamples
              Tutorials
              Documentation
              Usage
              About
            
            
              GitHub
              Try Online\nExamples
              Tutorials
              Documentation
              Usage
              About\nGitHub
              Try Online\nDocumentation
    The Vega visualization grammar provides basic building blocks for a wide variety of visualization designs. This page provides documentation of Vega JSON specifications and JavaScript API.

To start learning Vega, we recommend first working through the introductory Let’s Make A Bar Chart tutorial and exploring the example gallery, then digging into the documentation. These pages document Vega version 3.0 and later; if you are familiar with Vega 2.x, you might begin with the Vega 2 porting guide.

Specification Reference

A Vega specification is a JSON object that describes an interactive visualization design. A specification consists of basic properties (such as the width and height of the view) and definitions for the data to visualize, scales that map data values to visual values, axes and legends that visualize these scales, cartographic projections for drawing maps, graphical marks such as rectangles, lines, and symbols to visually represent data, and signals to process user input and modify the visualization in response.


  
    
      Specification
      Overview of a full Vega specification, including sizing and metadata.
    
    
      Config
      Configure defaults for visual encoding choices.
    
    
      Data
      Define, load, and parse data to visualize.
    
    
      Transforms
      Apply data transforms (filter, sort, aggregate, layout) prior to visualization.
    
    
      Triggers
      Modify data sets or mark properties in response to signal values.
    
    
      Projections
      Cartographic projections to map (longitude, latitude) data.
    
    
      Scales
      Map data values (numbers, strings) to visual properties (coordinates, colors, sizes).
    
    
      Schemes
      Color schemes that can be used as scale ranges.
    
    
      Axes
      Visualize scale mappings for spatial encodings using coordinate axes.
    
    
      Legends
      Visualize scale mappings for color, shape and size encodings.
    
    
      Title
      Specify a chart title for a visualization.
    
    
      Marks
      Visually encode data with graphical marks such as rectangles, lines, and symbols.
    
    
      Signals
      Dynamic variables that can drive interactive updates.
    
    
      Event Streams
      Define input event streams to specify interactions.
    
    
      Expressions
      Express custom calculations over data and signals.
    
    
      Layout
      Perform grid layout for a collection of group marks.
    
    
      Types
      Documentation of recurring parameter types.
    
  


Vega API Reference

Vega also provides a JavaScript runtime API, responsible for parsing JSON specifications to produce interactive views backed by a reactive dataflow graph of data processing operators. For more on deploying Vega, see the usage instructions.


  
    
      Parser
      Parse Vega JSON specifications to dataflow descriptions.
    
    
      View
      Create interactive views from dataflow descriptions.
    
    
      Locale
      Use number and date formats for a specific locale.
    
    
      Extensibility
      Extend Vega with new projections, scales, color schemes, or data transforms.
    
    
      Statistics
      Statistical methods used by Vega.
    
    
      Time
      Utility methods for date-time values.
    
    
      Util
      General JavaScript utilities.
    
    
      Debugging
      A guide to debugging Vega visualizations at runtime.\nThe Vega visualization grammar provides basic building blocks for a wide variety of visualization designs. This page provides documentation of Vega JSON specifications and JavaScript API.\nVega JSON specifications\nTo start learning Vega, we recommend first working through the introductory Let’s Make A Bar Chart tutorial and exploring the example gallery, then digging into the documentation. These pages document Vega version 3.0 and later; if you are familiar with Vega 2.x, you might begin with the Vega 2 porting guide.\nLet’s Make A Bar Chart tutorial\nSpecification Reference\nA Vega specification is a JSON object that describes an interactive visualization design. A specification consists of basic properties (such as the width and height of the view) and definitions for the data to visualize, scales that map data values to visual values, axes and legends that visualize these scales, cartographic projections for drawing maps, graphical marks such as rectangles, lines, and symbols to visually represent data, and signals to process user input and modify the visualization in response.\nOverview of a full Vega specification, including sizing and metadata.\nConfigure defaults for visual encoding choices.\nDefine, load, and parse data to visualize.\nApply data transforms (filter, sort, aggregate, layout) prior to visualization.\nModify data sets or mark properties in response to signal values.\nCartographic projections to map (longitude, latitude) data.\nMap data values (numbers, strings) to visual properties (coordinates, colors, sizes).\nColor schemes that can be used as scale ranges.\nVisualize scale mappings for spatial encodings using coordinate axes.\nVisualize scale mappings for color, shape and size encodings.\nSpecify a chart title for a visualization.\nVisually encode data with graphical marks such as rectangles, lines, and symbols.\nDynamic variables that can drive interactive updates.\nDefine input event streams to specify interactions.\nExpress custom calculations over data and signals.\nPerform grid layout for a collection of group marks.\nDocumentation of recurring parameter types.\nVega also provides a JavaScript runtime API, responsible for parsing JSON specifications to produce interactive views backed by a reactive dataflow graph of data processing operators. For more on deploying Vega, see the usage instructions.\nParse Vega JSON specifications to dataflow descriptions.\nCreate interactive views from dataflow descriptions.\nUse number and date formats for a specific locale.\nExtend Vega with new projections, scales, color schemes, or data transforms.\nStatistical methods used by Vega.\nUtility methods for date-time values.\nGeneral JavaScript utilities.\nA guide to debugging Vega visualizations at runtime.\n\n\nVega
            
              Vega-Lite
              Altair
              Vega-Lite API
            
          
          
            
              Examples
              Tutorials
              Documentation
              Usage
              About
            
            
              GitHub
              Try Online
            
          
        
      

      
        

  
  
    Let's Make A Bar Chart Tutorial
    This tutorial introduces the basics of Vega. We’ll look at a bar chart with tooltips and deconstruct it into its component elements. After completing the tutorial, you should be ready to start exploring and modifying Vega visualizations.

Here is one of the most basic (but also most useful!) forms of visualization, the humble bar chart:


  
  View Source
  Export PNG
  Export SVG



Here is the Vega specification that defines this bar chart. First read through the full definition. We’ll then examine each part in turn.

{
  "$schema": "https://vega.github.io/schema/vega/v5.json",
  "width": 400,
  "height": 200,
  "padding": 5,

  "data": [
    {
      "name": "table",
      "values": [
        {"category": "A", "amount": 28},
        {"category": "B", "amount": 55},
        {"category": "C", "amount": 43},
        {"category": "D", "amount": 91},
        {"category": "E", "amount": 81},
        {"category": "F", "amount": 53},
        {"category": "G", "amount": 19},
        {"category": "H", "amount": 87}
      ]
    }
  ],

  "signals": [
    {
      "name": "tooltip",
      "value": {},
      "on": [
        {"events": "rect:mouseover", "update": "datum"},
        {"events": "rect:mouseout",  "update": "{}"}
      ]
    }
  ],

  "scales": [
    {
      "name": "xscale",
      "type": "band",
      "domain": {"data": "table", "field": "category"},
      "range": "width",
      "padding": 0.05,
      "round": true
    },
    {
      "name": "yscale",
      "domain": {"data": "table", "field": "amount"},
      "nice": true,
      "range": "height"
    }
  ],

  "axes": [
    { "orient": "bottom", "scale": "xscale" },
    { "orient": "left", "scale": "yscale" }
  ],

  "marks": [
    {
      "type": "rect",
      "from": {"data":"table"},
      "encode": {
        "enter": {
          "x": {"scale": "xscale", "field": "category"},
          "width": {"scale": "xscale", "band": 1},
          "y": {"scale": "yscale", "field": "amount"},
          "y2": {"scale": "yscale", "value": 0}
        },
        "update": {
          "fill": {"value": "steelblue"}
        },
        "hover": {
          "fill": {"value": "red"}
        }
      }
    },
    {
      "type": "text",
      "encode": {
        "enter": {
          "align": {"value": "center"},
          "baseline": {"value": "bottom"},
          "fill": {"value": "#333"}
        },
        "update": {
          "x": {"scale": "xscale", "signal": "tooltip.category", "band": 0.5},
          "y": {"scale": "yscale", "signal": "tooltip.amount", "offset": -2},
          "text": {"signal": "tooltip.amount"},
          "fillOpacity": [
            {"test": "isNaN(tooltip.amount)", "value": 0},
            {"value": 1}
          ]
        }
      }
    }
  ]
}



We’ll now walk through the visualization definition visiting each of these components:


  Visualization Size
  Data
  Scales
  Axes
  Marks
  Signals
  Next Steps


Visualization Size

The first set of top-level properties determine the size of the visualization:

  "width": 400,
  "height": 200,
  "padding": 5,
  "autosize": "pad",


The width and height values determine the size of the data rectangle: the area of the chart in which data is plotted. Additional components, such as axes and legends, may take up additional space.

The padding determines the margin between the chart content and the border of the view.

The autosize property determines how the final chart size is determined:


  "pad" (the default) introduces extra space to accommodate all visualized marks, including axes and legends. The data rectangle size is unchanged. If any marks are placed at extreme positions outside the data rectangle, the view component may become very large!
  "fit" tries to fit the entire chart (data rectangle, axes, legends, but not padding) within the provided width and height. Vega will shrink the data rectangle to accommodate axes and legends. In some cases clipping may occur, for instance if a legend is very tall.
  "none" disables automatic sizing. The total chart size is determined solely by the width and height plus padding. There are no modifications to accommodate axes, legends, etc.


For more details, see the top-level specification documentation.

Data

The data property is an array of data definitions. Each entry in the data array must be an object with a unique name for the data set. As shown here, data can be directly defined inline using the values property. In this example, we have an array of data objects with fields named category (a string label) and amount (a number).

  "data": [
    {
      "name": "table",
      "values": [
        {"category": "A", "amount": 28},
        {"category": "B", "amount": 55},
        {"category": "C", "amount": 43},
        {"category": "D", "amount": 91},
        {"category": "E", "amount": 81},
        {"category": "F", "amount": 53},
        {"category": "G", "amount": 19},
        {"category": "H", "amount": 87}
      ]
    }
  ],


In Vega specifications, data can be:


  loaded from the web by using the url property (including JSON and CSV files),
  derived from a previously defined data set using the source property, or
  left undefined and dynamically set when the visualization is constructed.


Only one of the values, url or source properties may be defined.

Data sets in Vega can be modified using a collection of transforms such as filtering, aggregation and layout operations. Transformations are specified using the transform property, which takes an array of transform definitions.

For more details, see the data and transform documentation.

Scales

Scale functions map data values to visual values, such as pixel positions or colors:

  "scales": [
    {
      "name": "xscale",
      "type": "band",
      "domain": {"data": "table", "field": "category"},
      "range": "width",
      "padding": 0.05,
      "round": true
    },
    {
      "name": "yscale",
      "domain": {"data": "table", "field": "amount"},
      "nice": true,
      "range": "height"
    }
  ],


Here we’ve defined two scales, one each for the X and Y axes. The X-axis uses an ordinal band scale, which maps a domain of ordered elements (in this case letters) to a visual range. The Y-axis uses a quantitative linear scale. A linear scale type is used by default, and so is not explicitly included in the yscale definition above.

Each scale definition should have a unique name. Though to be precise, scale definitions nested within group marks can repeat names to override previously defined scales – but that is a more advanced concept.

The range settings of "width" and "height" are conveniences provided by Vega, and in this case map to the arrays [0, 400] and [200, 0], as defined by the size of the visualization. Ranges can also be defined explicitly as arrays of values: two-element numerical arrays should be used for spatial mappings, longer arrays (e.g., of RGB hex values like "#ffa804") can be used as the range of ordinal scales to specify custom palettes.

The domain property determines the input domain for the scale. The domain can be defined directly as an array of values (a quantitative range or list of ordinal values) or determined dynamically from the data. In the example above, the domain consists of the minimum and maximum values of the amount field in the table data set. By default, quantitative scales automatically include the zero value. To disable this feature, include the property "zero": false in the scale definition.

The xscale definition also includes a fractional padding to add spacing between bars and a round parameter to make sure the bars snap to pixel boundaries. Notice that yscale includes the property "nice": true. This optional property tells Vega that the scale domain can be made “nice” so that it is more human-friendly and readable. For example, if the raw data domain is [0, 94.345] it is made “nicer” as [0, 100].

For more details, see the scales documentation.

Axes

Axes visualize scales using ticks and labels to help viewers interpret a chart.

  "axes": [
    { "orient": "bottom", "scale": "xscale" },
    { "orient": "left", "scale": "yscale" }
  ],


At minimum, an axis definition must specify the axis orientation and the scale to visualize. Here we add an X-axis at the bottom of the chart, and a Y-axis to the left of the chart.

Now let’s look at how we might further customize the axes:

  "axes": [
    { "orient": "bottom", "scale": "xscale" },
    { "orient": "right", "scale": "yscale", "tickCount": 5,"offset": 6 }
  ],


Here we’ve adjusted the Y-axis in multiple ways, resulting in the modified chart below. By setting "tickCount": 5, we’ve requested that the axis show roughly five tick marks, rather than the ten or so shown previously. By setting "orient": "right", we’ve requested that the axis be placed on the right side of the chart, rather than the previous left position. Finally, setting "offset": 6 adjusts the axis position, in this case moving it to the right by 6 pixels. Here’s the modified visualization:


  
  View Source
  Export PNG
  Export SVG



For more details, see the axes documentation.

Marks

Marks are the primary elements of a visualization: they are graphical primitives whose properties (such as position, size, shape, and color) can be used to visually encode data. Vega provides a set of marks that serve as building blocks that can be combined to form rich visualizations. Here, we simply use rectangles (rect marks) to construct a bar chart.

Every mark must have a type property, which determines which kind of mark (rect, area, line, symbol, etc.) to use. Next, we must specify the data to be visualized using the from property. In most cases, one simply needs to reference a named data set defined in the top-level data property. If no from property is provided, a single mark instance will be created.

  "marks": [
    {
      "type": "rect",
      "from": {"data":"table"},
      "encode": {
        "enter": {
          "x": {"scale": "xscale", "field": "category"},
          "width": {"scale": "xscale", "band": 1},
          "y": {"scale": "yscale", "field": "amount"},
          "y2": {"scale": "yscale", "value": 0}
        },
        "update": {
          "fill": {"value": "steelblue"}
        },
        "hover": {
          "fill": {"value": "red"}
        }
      }
    },


Visual mark properties, such as position and color, are specified using named encoding sets defined within the encode property. The standard encoding sets are the enter set (for properties that should be set when the mark is first created), the exit set (for property settings when a mark is about to be removed), the update set (to update settings upon changes), and the hover set (to set properties upon mouse hover). In the example above, the enter set is first evaluated, followed by the update set, to create the bar chart. Upon mouse over, the hover set is evaluated to color the hovered bar in red. When the mouse leaves a bar, the update set is evaluated again to return the bar to its original color. Note that if we omit the update set, a mouse hover would cause the bar to turn permanently red!

Now let’s take a closer look at the specific mark definitions in the enter set:

          "x": {"scale": "xscale", "field": "category"},
          "width": {"scale": "xscale", "band": 1},
          "y": {"scale": "yscale", "field": "amount"},
          "y2": {"scale": "yscale", "value": 0}


The first two properties (x and width) set the horizontal position and width of the bar. The x mark property (the leftmost edge of the bar) is set to the value obtained by applying the scale named "xscale" (defined in scales above) to the data field category.

The width property is set to a value provided by the band scale xscale. Band scales chop up a spatial range into a set of uniformly sized “bands”. Including "band": 1 retrieves the full size of the band for the scale. The 1 value indicates what fraction of the band size to include; using "band": 0.5 would use half of the band.

The second two properties (y and y2) determine the vertical position and height of the bars. Similar to x and width, one could use y and height properties. However, here it is easier to specify the bar heights using two end points: one for the top of the bar (y) and one for the bottom of the bar (y2). We hardwire the value 0 and pass it through the linear yscale to ensure that one edge of each bar is always at zero. It actually does not matter which of y or y2 is greater than the other; Vega will set the positions correctly. You can similarly use x and x2, which can be useful for creating visualizations such as horizontal bar charts and timelines.

In addition to standard graphical marks (rectangles, arcs, plotting symbols, etc), Vega also supports nested marks through the special group mark type. Groups are marks that can contain other marks, for example to create small multiple displays. Groups can also include custom scales and axes definitions that are specific to a group instance.

For more details, see the marks documentation.

Signals

Signals act as dynamic variables: expressions that are automatically reevaluated when other signal values change, or when input events occur. Each signal must have a unique name and an initial value; other properties define how the signal value can change.

Here we use a signal to define a tooltip interaction. In this example, the value of the tooltip signal changes in response to mouseover and mouseout events on rect marks. Every time these events occur, the corresponding expression is evaluated and set as the tooltip value. Thus, when the mouse pointer is moved over a rectangle mark, tooltip is equal to the mark’s backing datum; when the pointer is moved off the rectangle, tooltip is an empty object.

  "signals": [
    {
      "name": "tooltip",
      "value": {},
      "on": [
        {"events": "rect:mouseover", "update": "datum"},
        {"events": "rect:mouseout",  "update": "{}"}
      ]
    }
  ],


Our tooltip signal tracks the datum for the currently highlighted bar. We now use this signal to dynamically adjust the visual encoding rules of a text label:

{
  "marks": [
    ...,
    {
      "type": "text",
      "encode": {
        "enter": {
          "align": {"value": "center"},
          "baseline": {"value": "bottom"},
          "fill": {"value": "#333"}
        },
        "update": {
          "x": {"scale": "xscale", "signal": "tooltip.category", "band": 0.5},
          "y": {"scale": "yscale", "signal": "tooltip.amount", "offset": -2},
          "text": {"signal": "tooltip.amount"},
          "fillOpacity": [
            {"test": "isNaN(tooltip.amount)", "value": 0},
            {"value": 1}
          ]
        }
      }
    }
  ]


A single text mark instance serves as our tooltip text (note that the from property is omitted). The position and text values are drawn directly from the tooltip signal. To only show the tooltip text when the mouse pointer is over a rectangle, we set the fillOpacity using production rules: a chain of if-then-else rules for visual encoding. If tooltip is an empty object, the tooltip text is fully transparent since isNaN(tooltip.amount) is true, otherwise it is opaque.

Signals can be applied throughout a specification. For example, they can be used to specify the properties of transforms, scales and mark encodings. For more details, see the signals documentation.

Next Steps

We’ve now worked through a full Vega visualization! Next, we recommend experimenting with and modifying this example. Copy & paste the full specification above into the online Vega Editor or fork our example Block.


  Can you adjust the scales and axes?
  Can you change the chart from a vertical bar chart to a horizontal bar chart?
  Can you visualize a new data set with a similar structure?


You should then be ready to understand and modify other examples. Many of the more advanced examples include data transforms that organize data elements and perform layout. As you experiment with different examples, you may find it useful to refer to the documentation for each of the main specification components.\nVega
            
              Vega-Lite
              Altair
              Vega-Lite API\nVega-Lite
              Altair
              Vega-Lite API\nExamples
              Tutorials
              Documentation
              Usage
              About
            
            
              GitHub
              Try Online\nExamples
              Tutorials
              Documentation
              Usage
              About\nGitHub
              Try Online\nLet's Make A Bar Chart Tutorial
    This tutorial introduces the basics of Vega. We’ll look at a bar chart with tooltips and deconstruct it into its component elements. After completing the tutorial, you should be ready to start exploring and modifying Vega visualizations.

Here is one of the most basic (but also most useful!) forms of visualization, the humble bar chart:


  
  View Source
  Export PNG
  Export SVG



Here is the Vega specification that defines this bar chart. First read through the full definition. We’ll then examine each part in turn.

{
  "$schema": "https://vega.github.io/schema/vega/v5.json",
  "width": 400,
  "height": 200,
  "padding": 5,

  "data": [
    {
      "name": "table",
      "values": [
        {"category": "A", "amount": 28},
        {"category": "B", "amount": 55},
        {"category": "C", "amount": 43},
        {"category": "D", "amount": 91},
        {"category": "E", "amount": 81},
        {"category": "F", "amount": 53},
        {"category": "G", "amount": 19},
        {"category": "H", "amount": 87}
      ]
    }
  ],

  "signals": [
    {
      "name": "tooltip",
      "value": {},
      "on": [
        {"events": "rect:mouseover", "update": "datum"},
        {"events": "rect:mouseout",  "update": "{}"}
      ]
    }
  ],

  "scales": [
    {
      "name": "xscale",
      "type": "band",
      "domain": {"data": "table", "field": "category"},
      "range": "width",
      "padding": 0.05,
      "round": true
    },
    {
      "name": "yscale",
      "domain": {"data": "table", "field": "amount"},
      "nice": true,
      "range": "height"
    }
  ],

  "axes": [
    { "orient": "bottom", "scale": "xscale" },
    { "orient": "left", "scale": "yscale" }
  ],

  "marks": [
    {
      "type": "rect",
      "from": {"data":"table"},
      "encode": {
        "enter": {
          "x": {"scale": "xscale", "field": "category"},
          "width": {"scale": "xscale", "band": 1},
          "y": {"scale": "yscale", "field": "amount"},
          "y2": {"scale": "yscale", "value": 0}
        },
        "update": {
          "fill": {"value": "steelblue"}
        },
        "hover": {
          "fill": {"value": "red"}
        }
      }
    },
    {
      "type": "text",
      "encode": {
        "enter": {
          "align": {"value": "center"},
          "baseline": {"value": "bottom"},
          "fill": {"value": "#333"}
        },
        "update": {
          "x": {"scale": "xscale", "signal": "tooltip.category", "band": 0.5},
          "y": {"scale": "yscale", "signal": "tooltip.amount", "offset": -2},
          "text": {"signal": "tooltip.amount"},
          "fillOpacity": [
            {"test": "isNaN(tooltip.amount)", "value": 0},
            {"value": 1}
          ]
        }
      }
    }
  ]
}



We’ll now walk through the visualization definition visiting each of these components:


  Visualization Size
  Data
  Scales
  Axes
  Marks
  Signals
  Next Steps


Visualization Size

The first set of top-level properties determine the size of the visualization:

  "width": 400,
  "height": 200,
  "padding": 5,
  "autosize": "pad",


The width and height values determine the size of the data rectangle: the area of the chart in which data is plotted. Additional components, such as axes and legends, may take up additional space.

The padding determines the margin between the chart content and the border of the view.

The autosize property determines how the final chart size is determined:


  "pad" (the default) introduces extra space to accommodate all visualized marks, including axes and legends. The data rectangle size is unchanged. If any marks are placed at extreme positions outside the data rectangle, the view component may become very large!
  "fit" tries to fit the entire chart (data rectangle, axes, legends, but not padding) within the provided width and height. Vega will shrink the data rectangle to accommodate axes and legends. In some cases clipping may occur, for instance if a legend is very tall.
  "none" disables automatic sizing. The total chart size is determined solely by the width and height plus padding. There are no modifications to accommodate axes, legends, etc.


For more details, see the top-level specification documentation.

Data

The data property is an array of data definitions. Each entry in the data array must be an object with a unique name for the data set. As shown here, data can be directly defined inline using the values property. In this example, we have an array of data objects with fields named category (a string label) and amount (a number).

  "data": [
    {
      "name": "table",
      "values": [
        {"category": "A", "amount": 28},
        {"category": "B", "amount": 55},
        {"category": "C", "amount": 43},
        {"category": "D", "amount": 91},
        {"category": "E", "amount": 81},
        {"category": "F", "amount": 53},
        {"category": "G", "amount": 19},
        {"category": "H", "amount": 87}
      ]
    }
  ],


In Vega specifications, data can be:


  loaded from the web by using the url property (including JSON and CSV files),
  derived from a previously defined data set using the source property, or
  left undefined and dynamically set when the visualization is constructed.


Only one of the values, url or source properties may be defined.

Data sets in Vega can be modified using a collection of transforms such as filtering, aggregation and layout operations. Transformations are specified using the transform property, which takes an array of transform definitions.

For more details, see the data and transform documentation.

Scales

Scale functions map data values to visual values, such as pixel positions or colors:

  "scales": [
    {
      "name": "xscale",
      "type": "band",
      "domain": {"data": "table", "field": "category"},
      "range": "width",
      "padding": 0.05,
      "round": true
    },
    {
      "name": "yscale",
      "domain": {"data": "table", "field": "amount"},
      "nice": true,
      "range": "height"
    }
  ],


Here we’ve defined two scales, one each for the X and Y axes. The X-axis uses an ordinal band scale, which maps a domain of ordered elements (in this case letters) to a visual range. The Y-axis uses a quantitative linear scale. A linear scale type is used by default, and so is not explicitly included in the yscale definition above.

Each scale definition should have a unique name. Though to be precise, scale definitions nested within group marks can repeat names to override previously defined scales – but that is a more advanced concept.

The range settings of "width" and "height" are conveniences provided by Vega, and in this case map to the arrays [0, 400] and [200, 0], as defined by the size of the visualization. Ranges can also be defined explicitly as arrays of values: two-element numerical arrays should be used for spatial mappings, longer arrays (e.g., of RGB hex values like "#ffa804") can be used as the range of ordinal scales to specify custom palettes.

The domain property determines the input domain for the scale. The domain can be defined directly as an array of values (a quantitative range or list of ordinal values) or determined dynamically from the data. In the example above, the domain consists of the minimum and maximum values of the amount field in the table data set. By default, quantitative scales automatically include the zero value. To disable this feature, include the property "zero": false in the scale definition.

The xscale definition also includes a fractional padding to add spacing between bars and a round parameter to make sure the bars snap to pixel boundaries. Notice that yscale includes the property "nice": true. This optional property tells Vega that the scale domain can be made “nice” so that it is more human-friendly and readable. For example, if the raw data domain is [0, 94.345] it is made “nicer” as [0, 100].

For more details, see the scales documentation.

Axes

Axes visualize scales using ticks and labels to help viewers interpret a chart.

  "axes": [
    { "orient": "bottom", "scale": "xscale" },
    { "orient": "left", "scale": "yscale" }
  ],


At minimum, an axis definition must specify the axis orientation and the scale to visualize. Here we add an X-axis at the bottom of the chart, and a Y-axis to the left of the chart.

Now let’s look at how we might further customize the axes:

  "axes": [
    { "orient": "bottom", "scale": "xscale" },
    { "orient": "right", "scale": "yscale", "tickCount": 5,"offset": 6 }
  ],


Here we’ve adjusted the Y-axis in multiple ways, resulting in the modified chart below. By setting "tickCount": 5, we’ve requested that the axis show roughly five tick marks, rather than the ten or so shown previously. By setting "orient": "right", we’ve requested that the axis be placed on the right side of the chart, rather than the previous left position. Finally, setting "offset": 6 adjusts the axis position, in this case moving it to the right by 6 pixels. Here’s the modified visualization:


  
  View Source
  Export PNG
  Export SVG



For more details, see the axes documentation.

Marks

Marks are the primary elements of a visualization: they are graphical primitives whose properties (such as position, size, shape, and color) can be used to visually encode data. Vega provides a set of marks that serve as building blocks that can be combined to form rich visualizations. Here, we simply use rectangles (rect marks) to construct a bar chart.

Every mark must have a type property, which determines which kind of mark (rect, area, line, symbol, etc.) to use. Next, we must specify the data to be visualized using the from property. In most cases, one simply needs to reference a named data set defined in the top-level data property. If no from property is provided, a single mark instance will be created.

  "marks": [
    {
      "type": "rect",
      "from": {"data":"table"},
      "encode": {
        "enter": {
          "x": {"scale": "xscale", "field": "category"},
          "width": {"scale": "xscale", "band": 1},
          "y": {"scale": "yscale", "field": "amount"},
          "y2": {"scale": "yscale", "value": 0}
        },
        "update": {
          "fill": {"value": "steelblue"}
        },
        "hover": {
          "fill": {"value": "red"}
        }
      }
    },


Visual mark properties, such as position and color, are specified using named encoding sets defined within the encode property. The standard encoding sets are the enter set (for properties that should be set when the mark is first created), the exit set (for property settings when a mark is about to be removed), the update set (to update settings upon changes), and the hover set (to set properties upon mouse hover). In the example above, the enter set is first evaluated, followed by the update set, to create the bar chart. Upon mouse over, the hover set is evaluated to color the hovered bar in red. When the mouse leaves a bar, the update set is evaluated again to return the bar to its original color. Note that if we omit the update set, a mouse hover would cause the bar to turn permanently red!

Now let’s take a closer look at the specific mark definitions in the enter set:

          "x": {"scale": "xscale", "field": "category"},
          "width": {"scale": "xscale", "band": 1},
          "y": {"scale": "yscale", "field": "amount"},
          "y2": {"scale": "yscale", "value": 0}


The first two properties (x and width) set the horizontal position and width of the bar. The x mark property (the leftmost edge of the bar) is set to the value obtained by applying the scale named "xscale" (defined in scales above) to the data field category.

The width property is set to a value provided by the band scale xscale. Band scales chop up a spatial range into a set of uniformly sized “bands”. Including "band": 1 retrieves the full size of the band for the scale. The 1 value indicates what fraction of the band size to include; using "band": 0.5 would use half of the band.

The second two properties (y and y2) determine the vertical position and height of the bars. Similar to x and width, one could use y and height properties. However, here it is easier to specify the bar heights using two end points: one for the top of the bar (y) and one for the bottom of the bar (y2). We hardwire the value 0 and pass it through the linear yscale to ensure that one edge of each bar is always at zero. It actually does not matter which of y or y2 is greater than the other; Vega will set the positions correctly. You can similarly use x and x2, which can be useful for creating visualizations such as horizontal bar charts and timelines.

In addition to standard graphical marks (rectangles, arcs, plotting symbols, etc), Vega also supports nested marks through the special group mark type. Groups are marks that can contain other marks, for example to create small multiple displays. Groups can also include custom scales and axes definitions that are specific to a group instance.

For more details, see the marks documentation.

Signals

Signals act as dynamic variables: expressions that are automatically reevaluated when other signal values change, or when input events occur. Each signal must have a unique name and an initial value; other properties define how the signal value can change.

Here we use a signal to define a tooltip interaction. In this example, the value of the tooltip signal changes in response to mouseover and mouseout events on rect marks. Every time these events occur, the corresponding expression is evaluated and set as the tooltip value. Thus, when the mouse pointer is moved over a rectangle mark, tooltip is equal to the mark’s backing datum; when the pointer is moved off the rectangle, tooltip is an empty object.

  "signals": [
    {
      "name": "tooltip",
      "value": {},
      "on": [
        {"events": "rect:mouseover", "update": "datum"},
        {"events": "rect:mouseout",  "update": "{}"}
      ]
    }
  ],


Our tooltip signal tracks the datum for the currently highlighted bar. We now use this signal to dynamically adjust the visual encoding rules of a text label:

{
  "marks": [
    ...,
    {
      "type": "text",
      "encode": {
        "enter": {
          "align": {"value": "center"},
          "baseline": {"value": "bottom"},
          "fill": {"value": "#333"}
        },
        "update": {
          "x": {"scale": "xscale", "signal": "tooltip.category", "band": 0.5},
          "y": {"scale": "yscale", "signal": "tooltip.amount", "offset": -2},
          "text": {"signal": "tooltip.amount"},
          "fillOpacity": [
            {"test": "isNaN(tooltip.amount)", "value": 0},
            {"value": 1}
          ]
        }
      }
    }
  ]


A single text mark instance serves as our tooltip text (note that the from property is omitted). The position and text values are drawn directly from the tooltip signal. To only show the tooltip text when the mouse pointer is over a rectangle, we set the fillOpacity using production rules: a chain of if-then-else rules for visual encoding. If tooltip is an empty object, the tooltip text is fully transparent since isNaN(tooltip.amount) is true, otherwise it is opaque.

Signals can be applied throughout a specification. For example, they can be used to specify the properties of transforms, scales and mark encodings. For more details, see the signals documentation.

Next Steps

We’ve now worked through a full Vega visualization! Next, we recommend experimenting with and modifying this example. Copy & paste the full specification above into the online Vega Editor or fork our example Block.


  Can you adjust the scales and axes?
  Can you change the chart from a vertical bar chart to a horizontal bar chart?
  Can you visualize a new data set with a similar structure?


You should then be ready to understand and modify other examples. Many of the more advanced examples include data transforms that organize data elements and perform layout. As you experiment with different examples, you may find it useful to refer to the documentation for each of the main specification components.\nLet's Make A Bar Chart Tutorial\nThis tutorial introduces the basics of Vega. We’ll look at a bar chart with tooltips and deconstruct it into its component elements. After completing the tutorial, you should be ready to start exploring and modifying Vega visualizations.\nHere is one of the most basic (but also most useful!) forms of visualization, the humble bar chart:\nView Source
  Export PNG
  Export SVG\nHere is the Vega specification that defines this bar chart. First read through the full definition. We’ll then examine each part in turn.\n{
  "$schema": "https://vega.github.io/schema/vega/v5.json",
  "width": 400,
  "height": 200,
  "padding": 5,

  "data": [
    {
      "name": "table",
      "values": [
        {"category": "A", "amount": 28},
        {"category": "B", "amount": 55},
        {"category": "C", "amount": 43},
        {"category": "D", "amount": 91},
        {"category": "E", "amount": 81},
        {"category": "F", "amount": 53},
        {"category": "G", "amount": 19},
        {"category": "H", "amount": 87}
      ]
    }
  ],

  "signals": [
    {
      "name": "tooltip",
      "value": {},
      "on": [
        {"events": "rect:mouseover", "update": "datum"},
        {"events": "rect:mouseout",  "update": "{}"}
      ]
    }
  ],

  "scales": [
    {
      "name": "xscale",
      "type": "band",
      "domain": {"data": "table", "field": "category"},
      "range": "width",
      "padding": 0.05,
      "round": true
    },
    {
      "name": "yscale",
      "domain": {"data": "table", "field": "amount"},
      "nice": true,
      "range": "height"
    }
  ],

  "axes": [
    { "orient": "bottom", "scale": "xscale" },
    { "orient": "left", "scale": "yscale" }
  ],

  "marks": [
    {
      "type": "rect",
      "from": {"data":"table"},
      "encode": {
        "enter": {
          "x": {"scale": "xscale", "field": "category"},
          "width": {"scale": "xscale", "band": 1},
          "y": {"scale": "yscale", "field": "amount"},
          "y2": {"scale": "yscale", "value": 0}
        },
        "update": {
          "fill": {"value": "steelblue"}
        },
        "hover": {
          "fill": {"value": "red"}
        }
      }
    },
    {
      "type": "text",
      "encode": {
        "enter": {
          "align": {"value": "center"},
          "baseline": {"value": "bottom"},
          "fill": {"value": "#333"}
        },
        "update": {
          "x": {"scale": "xscale", "signal": "tooltip.category", "band": 0.5},
          "y": {"scale": "yscale", "signal": "tooltip.amount", "offset": -2},
          "text": {"signal": "tooltip.amount"},
          "fillOpacity": [
            {"test": "isNaN(tooltip.amount)", "value": 0},
            {"value": 1}
          ]
        }
      }
    }
  ]
}\n{
  "$schema": "https://vega.github.io/schema/vega/v5.json",
  "width": 400,
  "height": 200,
  "padding": 5,

  "data": [
    {
      "name": "table",
      "values": [
        {"category": "A", "amount": 28},
        {"category": "B", "amount": 55},
        {"category": "C", "amount": 43},
        {"category": "D", "amount": 91},
        {"category": "E", "amount": 81},
        {"category": "F", "amount": 53},
        {"category": "G", "amount": 19},
        {"category": "H", "amount": 87}
      ]
    }
  ],

  "signals": [
    {
      "name": "tooltip",
      "value": {},
      "on": [
        {"events": "rect:mouseover", "update": "datum"},
        {"events": "rect:mouseout",  "update": "{}"}
      ]
    }
  ],

  "scales": [
    {
      "name": "xscale",
      "type": "band",
      "domain": {"data": "table", "field": "category"},
      "range": "width",
      "padding": 0.05,
      "round": true
    },
    {
      "name": "yscale",
      "domain": {"data": "table", "field": "amount"},
      "nice": true,
      "range": "height"
    }
  ],

  "axes": [
    { "orient": "bottom", "scale": "xscale" },
    { "orient": "left", "scale": "yscale" }
  ],

  "marks": [
    {
      "type": "rect",
      "from": {"data":"table"},
      "encode": {
        "enter": {
          "x": {"scale": "xscale", "field": "category"},
          "width": {"scale": "xscale", "band": 1},
          "y": {"scale": "yscale", "field": "amount"},
          "y2": {"scale": "yscale", "value": 0}
        },
        "update": {
          "fill": {"value": "steelblue"}
        },
        "hover": {
          "fill": {"value": "red"}
        }
      }
    },
    {
      "type": "text",
      "encode": {
        "enter": {
          "align": {"value": "center"},
          "baseline": {"value": "bottom"},
          "fill": {"value": "#333"}
        },
        "update": {
          "x": {"scale": "xscale", "signal": "tooltip.category", "band": 0.5},
          "y": {"scale": "yscale", "signal": "tooltip.amount", "offset": -2},
          "text": {"signal": "tooltip.amount"},
          "fillOpacity": [
            {"test": "isNaN(tooltip.amount)", "value": 0},
            {"value": 1}
          ]
        }
      }
    }
  ]
}\n"https://vega.github.io/schema/vega/v5.json"\n"isNaN(tooltip.amount)"\nWe’ll now walk through the visualization definition visiting each of these components:\nThe first set of top-level properties determine the size of the visualization:\n"width": 400,
  "height": 200,
  "padding": 5,
  "autosize": "pad",\n"width": 400,
  "height": 200,
  "padding": 5,
  "autosize": "pad",\nThe width and height values determine the size of the data rectangle: the area of the chart in which data is plotted. Additional components, such as axes and legends, may take up additional space.\nThe padding determines the margin between the chart content and the border of the view.\nThe autosize property determines how the final chart size is determined:\n"pad" (the default) introduces extra space to accommodate all visualized marks, including axes and legends. The data rectangle size is unchanged. If any marks are placed at extreme positions outside the data rectangle, the view component may become very large!\n"fit" tries to fit the entire chart (data rectangle, axes, legends, but not padding) within the provided width and height. Vega will shrink the data rectangle to accommodate axes and legends. In some cases clipping may occur, for instance if a legend is very tall.\n"none" disables automatic sizing. The total chart size is determined solely by the width and height plus padding. There are no modifications to accommodate axes, legends, etc.\nFor more details, see the top-level specification documentation.\ntop-level specification\nThe data property is an array of data definitions. Each entry in the data array must be an object with a unique name for the data set. As shown here, data can be directly defined inline using the values property. In this example, we have an array of data objects with fields named category (a string label) and amount (a number).\n"data": [
    {
      "name": "table",
      "values": [
        {"category": "A", "amount": 28},
        {"category": "B", "amount": 55},
        {"category": "C", "amount": 43},
        {"category": "D", "amount": 91},
        {"category": "E", "amount": 81},
        {"category": "F", "amount": 53},
        {"category": "G", "amount": 19},
        {"category": "H", "amount": 87}
      ]
    }
  ],\n"data": [
    {
      "name": "table",
      "values": [
        {"category": "A", "amount": 28},
        {"category": "B", "amount": 55},
        {"category": "C", "amount": 43},
        {"category": "D", "amount": 91},
        {"category": "E", "amount": 81},
        {"category": "F", "amount": 53},
        {"category": "G", "amount": 19},
        {"category": "H", "amount": 87}
      ]
    }
  ],\nIn Vega specifications, data can be:\nloaded from the web by using the url property (including JSON and CSV files),\nderived from a previously defined data set using the source property, or\nleft undefined and dynamically set when the visualization is constructed.\nOnly one of the values, url or source properties may be defined.\nData sets in Vega can be modified using a collection of transforms such as filtering, aggregation and layout operations. Transformations are specified using the transform property, which takes an array of transform definitions.\nFor more details, see the data and transform documentation.\nScale functions map data values to visual values, such as pixel positions or colors:\n"scales": [
    {
      "name": "xscale",
      "type": "band",
      "domain": {"data": "table", "field": "category"},
      "range": "width",
      "padding": 0.05,
      "round": true
    },
    {
      "name": "yscale",
      "domain": {"data": "table", "field": "amount"},
      "nice": true,
      "range": "height"
    }
  ],\n"scales": [
    {
      "name": "xscale",
      "type": "band",
      "domain": {"data": "table", "field": "category"},
      "range": "width",
      "padding": 0.05,
      "round": true
    },
    {
      "name": "yscale",
      "domain": {"data": "table", "field": "amount"},
      "nice": true,
      "range": "height"
    }
  ],\nHere we’ve defined two scales, one each for the X and Y axes. The X-axis uses an ordinal band scale, which maps a domain of ordered elements (in this case letters) to a visual range. The Y-axis uses a quantitative linear scale. A linear scale type is used by default, and so is not explicitly included in the yscale definition above.\nEach scale definition should have a unique name. Though to be precise, scale definitions nested within group marks can repeat names to override previously defined scales – but that is a more advanced concept.\nThe range settings of "width" and "height" are conveniences provided by Vega, and in this case map to the arrays [0, 400] and [200, 0], as defined by the size of the visualization. Ranges can also be defined explicitly as arrays of values: two-element numerical arrays should be used for spatial mappings, longer arrays (e.g., of RGB hex values like "#ffa804") can be used as the range of ordinal scales to specify custom palettes.\nThe domain property determines the input domain for the scale. The domain can be defined directly as an array of values (a quantitative range or list of ordinal values) or determined dynamically from the data. In the example above, the domain consists of the minimum and maximum values of the amount field in the table data set. By default, quantitative scales automatically include the zero value. To disable this feature, include the property "zero": false in the scale definition.\nThe xscale definition also includes a fractional padding to add spacing between bars and a round parameter to make sure the bars snap to pixel boundaries. Notice that yscale includes the property "nice": true. This optional property tells Vega that the scale domain can be made “nice” so that it is more human-friendly and readable. For example, if the raw data domain is [0, 94.345] it is made “nicer” as [0, 100].\nFor more details, see the scales documentation.\nAxes visualize scales using ticks and labels to help viewers interpret a chart.\n"axes": [
    { "orient": "bottom", "scale": "xscale" },
    { "orient": "left", "scale": "yscale" }
  ],\n"axes": [
    { "orient": "bottom", "scale": "xscale" },
    { "orient": "left", "scale": "yscale" }
  ],\nAt minimum, an axis definition must specify the axis orientation and the scale to visualize. Here we add an X-axis at the bottom of the chart, and a Y-axis to the left of the chart.\nNow let’s look at how we might further customize the axes:\n"axes": [
    { "orient": "bottom", "scale": "xscale" },
    { "orient": "right", "scale": "yscale", "tickCount": 5,"offset": 6 }
  ],\n"axes": [
    { "orient": "bottom", "scale": "xscale" },
    { "orient": "right", "scale": "yscale", "tickCount": 5,"offset": 6 }
  ],\nHere we’ve adjusted the Y-axis in multiple ways, resulting in the modified chart below. By setting "tickCount": 5, we’ve requested that the axis show roughly five tick marks, rather than the ten or so shown previously. By setting "orient": "right", we’ve requested that the axis be placed on the right side of the chart, rather than the previous left position. Finally, setting "offset": 6 adjusts the axis position, in this case moving it to the right by 6 pixels. Here’s the modified visualization:\nView Source
  Export PNG
  Export SVG\nFor more details, see the axes documentation.\nMarks are the primary elements of a visualization: they are graphical primitives whose properties (such as position, size, shape, and color) can be used to visually encode data. Vega provides a set of marks that serve as building blocks that can be combined to form rich visualizations. Here, we simply use rectangles (rect marks) to construct a bar chart.\nEvery mark must have a type property, which determines which kind of mark (rect, area, line, symbol, etc.) to use. Next, we must specify the data to be visualized using the from property. In most cases, one simply needs to reference a named data set defined in the top-level data property. If no from property is provided, a single mark instance will be created.\n"marks": [
    {
      "type": "rect",
      "from": {"data":"table"},
      "encode": {
        "enter": {
          "x": {"scale": "xscale", "field": "category"},
          "width": {"scale": "xscale", "band": 1},
          "y": {"scale": "yscale", "field": "amount"},
          "y2": {"scale": "yscale", "value": 0}
        },
        "update": {
          "fill": {"value": "steelblue"}
        },
        "hover": {
          "fill": {"value": "red"}
        }
      }
    },\n"marks": [
    {
      "type": "rect",
      "from": {"data":"table"},
      "encode": {
        "enter": {
          "x": {"scale": "xscale", "field": "category"},
          "width": {"scale": "xscale", "band": 1},
          "y": {"scale": "yscale", "field": "amount"},
          "y2": {"scale": "yscale", "value": 0}
        },
        "update": {
          "fill": {"value": "steelblue"}
        },
        "hover": {
          "fill": {"value": "red"}
        }
      }
    },\nVisual mark properties, such as position and color, are specified using named encoding sets defined within the encode property. The standard encoding sets are the enter set (for properties that should be set when the mark is first created), the exit set (for property settings when a mark is about to be removed), the update set (to update settings upon changes), and the hover set (to set properties upon mouse hover). In the example above, the enter set is first evaluated, followed by the update set, to create the bar chart. Upon mouse over, the hover set is evaluated to color the hovered bar in red. When the mouse leaves a bar, the update set is evaluated again to return the bar to its original color. Note that if we omit the update set, a mouse hover would cause the bar to turn permanently red!\nNow let’s take a closer look at the specific mark definitions in the enter set:\n"x": {"scale": "xscale", "field": "category"},
          "width": {"scale": "xscale", "band": 1},
          "y": {"scale": "yscale", "field": "amount"},
          "y2": {"scale": "yscale", "value": 0}\n"x": {"scale": "xscale", "field": "category"},
          "width": {"scale": "xscale", "band": 1},
          "y": {"scale": "yscale", "field": "amount"},
          "y2": {"scale": "yscale", "value": 0}\nThe first two properties (x and width) set the horizontal position and width of the bar. The x mark property (the leftmost edge of the bar) is set to the value obtained by applying the scale named "xscale" (defined in scales above) to the data field category.\nThe width property is set to a value provided by the band scale xscale. Band scales chop up a spatial range into a set of uniformly sized “bands”. Including "band": 1 retrieves the full size of the band for the scale. The 1 value indicates what fraction of the band size to include; using "band": 0.5 would use half of the band.\nThe second two properties (y and y2) determine the vertical position and height of the bars. Similar to x and width, one could use y and height properties. However, here it is easier to specify the bar heights using two end points: one for the top of the bar (y) and one for the bottom of the bar (y2). We hardwire the value 0 and pass it through the linear yscale to ensure that one edge of each bar is always at zero. It actually does not matter which of y or y2 is greater than the other; Vega will set the positions correctly. You can similarly use x and x2, which can be useful for creating visualizations such as horizontal bar charts and timelines.\nIn addition to standard graphical marks (rectangles, arcs, plotting symbols, etc), Vega also supports nested marks through the special group mark type. Groups are marks that can contain other marks, for example to create small multiple displays. Groups can also include custom scales and axes definitions that are specific to a group instance.\nsmall multiple displays\nFor more details, see the marks documentation.\nSignals act as dynamic variables: expressions that are automatically reevaluated when other signal values change, or when input events occur. Each signal must have a unique name and an initial value; other properties define how the signal value can change.\nHere we use a signal to define a tooltip interaction. In this example, the value of the tooltip signal changes in response to mouseover and mouseout events on rect marks. Every time these events occur, the corresponding expression is evaluated and set as the tooltip value. Thus, when the mouse pointer is moved over a rectangle mark, tooltip is equal to the mark’s backing datum; when the pointer is moved off the rectangle, tooltip is an empty object.\n"signals": [
    {
      "name": "tooltip",
      "value": {},
      "on": [
        {"events": "rect:mouseover", "update": "datum"},
        {"events": "rect:mouseout",  "update": "{}"}
      ]
    }
  ],\n"signals": [
    {
      "name": "tooltip",
      "value": {},
      "on": [
        {"events": "rect:mouseover", "update": "datum"},
        {"events": "rect:mouseout",  "update": "{}"}
      ]
    }
  ],\nOur tooltip signal tracks the datum for the currently highlighted bar. We now use this signal to dynamically adjust the visual encoding rules of a text label:\n{
  "marks": [
    ...,
    {
      "type": "text",
      "encode": {
        "enter": {
          "align": {"value": "center"},
          "baseline": {"value": "bottom"},
          "fill": {"value": "#333"}
        },
        "update": {
          "x": {"scale": "xscale", "signal": "tooltip.category", "band": 0.5},
          "y": {"scale": "yscale", "signal": "tooltip.amount", "offset": -2},
          "text": {"signal": "tooltip.amount"},
          "fillOpacity": [
            {"test": "isNaN(tooltip.amount)", "value": 0},
            {"value": 1}
          ]
        }
      }
    }
  ]\n{
  "marks": [
    ...,
    {
      "type": "text",
      "encode": {
        "enter": {
          "align": {"value": "center"},
          "baseline": {"value": "bottom"},
          "fill": {"value": "#333"}
        },
        "update": {
          "x": {"scale": "xscale", "signal": "tooltip.category", "band": 0.5},
          "y": {"scale": "yscale", "signal": "tooltip.amount", "offset": -2},
          "text": {"signal": "tooltip.amount"},
          "fillOpacity": [
            {"test": "isNaN(tooltip.amount)", "value": 0},
            {"value": 1}
          ]
        }
      }
    }
  ]\n"isNaN(tooltip.amount)"\nA single text mark instance serves as our tooltip text (note that the from property is omitted). The position and text values are drawn directly from the tooltip signal. To only show the tooltip text when the mouse pointer is over a rectangle, we set the fillOpacity using production rules: a chain of if-then-else rules for visual encoding. If tooltip is an empty object, the tooltip text is fully transparent since isNaN(tooltip.amount) is true, otherwise it is opaque.\nSignals can be applied throughout a specification. For example, they can be used to specify the properties of transforms, scales and mark encodings. For more details, see the signals documentation.\nWe’ve now worked through a full Vega visualization! Next, we recommend experimenting with and modifying this example. Copy & paste the full specification above into the online Vega Editor or fork our example Block.\nCan you adjust the scales and axes?\nCan you change the chart from a vertical bar chart to a horizontal bar chart?\nCan you visualize a new data set with a similar structure?\nYou should then be ready to understand and modify other examples. Many of the more advanced examples include data transforms that organize data elements and perform layout. As you experiment with different examples, you may find it useful to refer to the documentation for each of the main specification components.\n\n\nVega
            
              Vega-Lite
              Altair
              Vega-Lite API
            
          
          
            
              Examples
              Tutorials
              Documentation
              Usage
              About
            
            
              GitHub
              Try Online
            
          
        
      

      
        

  
  
    Example Gallery
    
Bar Charts



  
  Bar Chart





  
  Stacked Bar Chart





  
  Grouped Bar Chart





  
  Nested Bar Chart





  
  Population Pyramid



Line & Area Charts



  
  Line Chart





  
  Area Chart





  
  Stacked Area Chart





  
  Horizon Graph





  
  Job Voyager



Circular Charts



  
  Pie Chart





  
  Donut Chart





  
  Donut Chart Labelled





  
  Radial Plot





  
  Radar Chart



Scatter Plots



  
  Scatter Plot





  
  Scatter Plot Null Values





  
  Connected Scatter Plot





  
  Error Bars





  
  Barley Trellis Plot





  
  Regression





  
  Loess Regression





  
  Labeled Scatter Plot



Distributions



  
  Top K Plot





  
  Top K Plot With Others





  
  Histogram





  
  Histogram Null Values





  
  Dot Plot





  
  Probability Density





  
  Box Plot





  
  Violin Plot





  
  Binned Scatter Plot





  
  Contour Plot





  
  Wheat Plot





  
  Quantile Quantile Plot





  
  Quantile Dot Plot





  
  Hypothetical Outcome Plots





  
  Time Units



Geographic Maps



  
  County Unemployment





  
  Dorling Cartogram





  
  World Map





  
  Earthquakes





  
  Projections





  
  Zoomable World Map





  
  Distortion Comparison





  
  Volcano Contours





  
  Wind Vectors





  
  Annual Precipitation



Tree Diagrams



  
  Tree Layout





  
  Radial Tree Layout





  
  Treemap





  
  Circle Packing





  
  Sunburst



Network Diagrams



  
  Edge Bundling





  
  Force Directed Layout





  
  Reorderable Matrix





  
  Arc Diagram





  
  Airport Connections



Other Chart Types



  
  Heatmap





  
  Density Heatmaps





  
  Parallel Coordinates





  
  Word Cloud





  
  Beeswarm Plot





  
  Calendar View





  
  Packed Bubble Chart



Custom Designs



  
  Budget Forecasts





  
  Wheat And Wages





  
  Falkensee Population





  
  Annual Temperature





  
  Weekly Temperature





  
  Flight Passengers





  
  Timelines





  
  U District Cuisine





  
  Clock





  
  Watch





  
  Warming Stripes





  
  Earthquakes Globe





  
  Serpentine Timeline



Interaction Techniques



  
  Crossfilter Flights





  
  Overview Plus Detail





  
  Brushing Scatter Plots





  
  Zoomable Scatter Plot





  
  Zoomable Binned Plot





  
  Global Development





  
  Interactive Legend





  
  Stock Index Chart





  
  Pi Monte Carlo





  
  Zoomable Circle Packing





  
  Table Scrollbar





  
  Bar Line Toggle





  
  Map With Tooltip





  
  Pacman





  
  Platformer\nVega
            
              Vega-Lite
              Altair
              Vega-Lite API\nVega-Lite
              Altair
              Vega-Lite API\nExamples
              Tutorials
              Documentation
              Usage
              About
            
            
              GitHub
              Try Online\nExamples
              Tutorials
              Documentation
              Usage
              About\nGitHub
              Try Online\nExample Gallery
    
Bar Charts



  
  Bar Chart





  
  Stacked Bar Chart





  
  Grouped Bar Chart





  
  Nested Bar Chart





  
  Population Pyramid



Line & Area Charts



  
  Line Chart





  
  Area Chart





  
  Stacked Area Chart





  
  Horizon Graph





  
  Job Voyager



Circular Charts



  
  Pie Chart





  
  Donut Chart





  
  Donut Chart Labelled





  
  Radial Plot





  
  Radar Chart



Scatter Plots



  
  Scatter Plot





  
  Scatter Plot Null Values





  
  Connected Scatter Plot





  
  Error Bars





  
  Barley Trellis Plot





  
  Regression





  
  Loess Regression





  
  Labeled Scatter Plot



Distributions



  
  Top K Plot





  
  Top K Plot With Others





  
  Histogram





  
  Histogram Null Values





  
  Dot Plot





  
  Probability Density





  
  Box Plot





  
  Violin Plot





  
  Binned Scatter Plot





  
  Contour Plot





  
  Wheat Plot





  
  Quantile Quantile Plot





  
  Quantile Dot Plot





  
  Hypothetical Outcome Plots





  
  Time Units



Geographic Maps



  
  County Unemployment





  
  Dorling Cartogram





  
  World Map





  
  Earthquakes





  
  Projections





  
  Zoomable World Map





  
  Distortion Comparison





  
  Volcano Contours





  
  Wind Vectors





  
  Annual Precipitation



Tree Diagrams



  
  Tree Layout





  
  Radial Tree Layout





  
  Treemap





  
  Circle Packing





  
  Sunburst



Network Diagrams



  
  Edge Bundling





  
  Force Directed Layout





  
  Reorderable Matrix





  
  Arc Diagram





  
  Airport Connections



Other Chart Types



  
  Heatmap





  
  Density Heatmaps





  
  Parallel Coordinates





  
  Word Cloud





  
  Beeswarm Plot





  
  Calendar View





  
  Packed Bubble Chart



Custom Designs



  
  Budget Forecasts





  
  Wheat And Wages





  
  Falkensee Population





  
  Annual Temperature





  
  Weekly Temperature





  
  Flight Passengers





  
  Timelines





  
  U District Cuisine





  
  Clock





  
  Watch





  
  Warming Stripes





  
  Earthquakes Globe





  
  Serpentine Timeline



Interaction Techniques



  
  Crossfilter Flights





  
  Overview Plus Detail





  
  Brushing Scatter Plots





  
  Zoomable Scatter Plot





  
  Zoomable Binned Plot





  
  Global Development





  
  Interactive Legend





  
  Stock Index Chart





  
  Pi Monte Carlo





  
  Zoomable Circle Packing





  
  Table Scrollbar





  
  Bar Line Toggle





  
  Map With Tooltip





  
  Pacman





  
  Platformer\nScatter Plot Null Values\nScatter Plot Null Values\nConnected Scatter Plot\nConnected Scatter Plot\nTop K Plot With Others\nTop K Plot With Others\nHistogram Null Values\nHistogram Null Values\nQuantile Quantile Plot\nQuantile Quantile Plot\nHypothetical Outcome Plots\nHypothetical Outcome Plots\nDistortion Comparison\nDistortion Comparison\nForce Directed Layout\nForce Directed Layout\nInteraction Techniques\nBrushing Scatter Plots\nBrushing Scatter Plots\nZoomable Scatter Plot\nZoomable Scatter Plot\nZoomable Circle Packing\nZoomable Circle Packing\n\n\nVega
            
              Vega-Lite
              Altair
              Vega-Lite API
            
          
          
            
              Examples
              Tutorials
              Documentation
              Usage
              About
            
            
              GitHub
              Try Online
            
          
        
      

      
        

  
  
    Porting Guide from Vega 2
    This document describes the various changes needed to port Vega 2.x specifications to more recent versions. It also introduces a subset of the new features that were introduced in Vega 3. While the listing below is intended to cover the most salient differences between these major versions, readers are also encouraged to dive in and study the example gallery.

Porting Guide Outline


  Marks and Visual Encoding
  Signals and Event Processing
  View Layout
  Axes and Legends
  Scales
  Data Transforms
  Geo Data
  Animation
  View API


Marks and Visual Encoding


  
    The "properties" block of visual encodings has been renamed "encode".
  
  
    The "signal" encoding directive now accepts anonymous signal expressions in addition to signal names. You can use these to directly write expressions for visual encodings. For example: {"signal": "datum.field * 2"}.
  
  
    The "template" encoding directive has been removed. Instead, use the "signal" directive with an expression to perform equivalent text processing.
  
  
    The "mult" and "offset" visual encoding properties now support recursive encoding directives, enabling greater control. For example, each can include a sub-encoding like so: "x": {"scale": "xscale", "field": "foo", "offset": {"scale": "oscale", "field": "bar"}}.
  
  
    The "band" property now accepts an interpolation fraction between 0 and 1 for placing elements within a scale band, and can now be used in conjunction with a field-based scale mapping. For example, the following encoding places an item at the midpoint of the appropriate scale band: {"scale": "xscale", "field": "foo", "band": 0.5}.
  
  
    The rule mark type now supports arbitrary line segments, and reliably draws a line from point "x", "y" to point "x2", "y2".
  
  
    Mark definitions no longer allow embedded data transforms (e.g., {"type": "rect", "from": {"data": "table, "transform": [...]}}). Instead, all derived data sources must now be defined within a "data" definition block. However, as of Vega 3, "data" blocks are no longer constrained to only the top-level of a spec: they can be defined within group marks as well! For example, this flexibility allows creation of derived data sets within a faceted group.
  
  
    The "facet" transform is no longer supported. Instead, a new "facet" directive can be applied within a mark "from" block to enable multiple forms of faceting support. Also, the "aggregate" transform can be used for grouping. For example, the barley.vg.json example facets a group mark like so:

    "from": {
  "facet": {
    "name": "sites",
    "data": "barley",
    "groupby": "site"
  }
},
    
    Child marks can visualize the faceted data by name: "from": {"data": "sites"}. The "facet" block also accepts the same parameters as an "aggregate" transform to apply when generating data elements for group mark items. In addition, Vega 3 now supports pre-faceted data, in which a data tuple may contain a nested a set of records. This oft-requested feature allows data to be grouped offline and passed directly to Vega, like so:

    "from": {
  "facet": {
    "name":  "facets",
    "data":  "input", // [{children: [...]}, {children: [...]}]
    "field": "children"
  }
},
    
    In this case, each datum in input will back a group mark item, and each corresponding group will contain the data tuples referenced by the "children" field.
  
  
    In addition to the "encode" (formerly "properties") blocks, mark definitions now support post-encoding transforms: data transforms that are run after the "encode" block, and which read and write scenegraph item properties directly. For example, one can run layout algorithms (force-directed layout, wordcloud layout, tree layout, etc.) to directly set the visual properties of items, rather than write them to an intermediate data tuple and then copy them over (as done in Vega 2). Only transforms that do not filter or generate new tuples can be used as post-encoding transforms. Here is an example excerpt from wordcloud.vg.json:

    "marks": [{
  "type": "text",
  "from": {"data": "table"},
  "encode": {...},
  "transform": [
    {
      "type": "wordcloud",
      "size": [800, 400],
      "text": {"field": "text"},
      ...
    }
  ]
}]
    
  
  
    Vega 3 added a new shape mark type. Shape marks are similar in functionality to path marks. However, while path marks require a materialized SVG path string, shape marks are generated procedurally by passing a path-rendering function to the renderer. This allows drawing of shapes without passing through the intermediate representation of a path string, which can considerably improve rendering time when using a canvas renderer. For SVG renderers, the shape type generates an SVG path string (but at render time, not visual encoding time) to include in the SVG DOM.
  
  
    Vega 3 added z-index support for changing the layering order of sibling elements. Z-index values are expected to be non-negative integers. All scenegraph items default to a zindex of zero. Higher values indicate elements that should be drawn on top of their sibling marks. Mark, axis and legend definitions accept a "zindex" property, and "zindex" can also be used as an individual visual encoding property (e.g., in a "hover" or "update" set). Z-index sorting is performed at the sibling-level only; for example, it can not be used to force a single item in one mark set to be drawn on top of items in another mark set.
  


Back to outline

Signals and Event Processing


  
    The signal "streams" property has been renamed "on". Within an event stream definition, the "type" parameter has been renamed "events", and the "expr" parameter has been renamed "update". For example, the signal definition {"name": "foo", "streams": [{"type": "rect:mousedown", "expr": "eventX()"}]}, should now be written as {"name": "foo", "on": [{"events": "rect:mousedown", "update": "x()"}]}.
  
  
    The "events" parameter of an event stream definition can either be a string containing an event selector description (as in Vega 2.x) or can use a structured JSON schema for expressing event selections.
  
  
    The eventItem, eventGroup, eventX, and eventY expression language functions have been replaced with the more concise item, group, x and y functions. Also, a new xy function returns the current pointer coordinate as an [x, y] array.
  
  
    Events are no longer consumed (e.g., subject to event.preventDefault()) by default. To have Vega consume an event (and thereby suppress event propagation and default browser behavior), include an exclamation mark at the end of an event name within an event selector (e.g., {"events": "window:mousemove!"}).
  
  
    The "verbose" flag has been renamed to "force", and must now be set on individual elements of the "on" array. For example, the signal definition {"name": "clickedPoint", "verbose": true, "streams": [{"type": "click", "expr": "datum.key"}]} should now be written as {"name": "clickedPoint", "on": [{"events": "click", "update": "datum.key", "force": true}]}.
  
  
    Instead of "init", the "value" and "update" properties can be used to initialize a signal using a literal value or expression, respectively.
  
  
    Signal definitions now support a "bind" property that binds signal values to automatically-generated HTML input widgets. This provides an additional means of creating interactive visualizations by adding external user controls. The syntax for "bind" definitions follows the earlier vega-embed model. See the airports.vg.json and map-bind.vg.json examples for more.
  
  
    The View API for event listeners has changed. The view.on and view.off methods are no longer defined. Either use view.addEventListener and view.removeEventListener for standard callbacks or use the new view.events method to work with EventStream instances instead.
  
  
    The View API for signal listeners has changed. Instead of view.onSignal and view.offSignal, use view.addSignalListener and view.removeSignalListener.
  


Back to outline

View Layout


  
    The Vega 2.x top-level "viewport" property has been removed. Instead, the same behavior can be specified directly by using width/height/overflow CSS directives on the DOM element container for the Vega view.
  
  
    The chart "width" and "height" are automatically bound to signals with the same name. The top-level "width" and "height" properties can be omitted from the definition and instead replaced by signal definitions whose "update" function dynamically sets the width and/or height value.
  
  Vega 3 added a new top-level "autosize" property to set the layout mode. The legal values are:
    
      "pad" (default) - The width/height values determine the data rectangle for plotting. Axes and legends use additional space, with extra padding added to accommodate those elements. This is akin to "padding": "auto" in Vega 2.
      "fit" - The width/height indicates the final size (minus any explicit padding). The actual width and height signals will be automatically resized to accommodate axes and legends within the given fit size. If elements are too large to fit in the given size, clipping may occur. This is akin to "padding": "strict" in Vega 2.
      "none” - No automatic adjustment of size is performed. The final size is strictly the sum of the width/height and any explicit padding. Clipping may occur.
    
  
  
    Vega 3 removed the "auto" and "strict" options for view "padding". Instead, "padding" now always defines a fixed padding margin around the visualization. If the "autosize" property is set to "pad", the padding values will be added to the results of the auto-size calculation.
  
  SVG rendering now supports some basic responsive resizing. Generated SVG output now includes a viewBox attribute. This allows you to resize the SVG element and have the resulting visualization content scale accordingly.


Back to outline

Axes and Legends


  
    Axes no longer have a type parameter. Instead, the orient parameter is now required. Instead of {"type": "x"} use {"orient": "bottom"}, and instead of {"type": "y"} use {"orient": "left"}.
  
  
    The "ticks" parameter for suggesting the approximate number of axis ticks has been renamed "tickCount".
  
  
    Custom visual properties for axes and legends now reside under an "encode" block and use "enter", "update", and "exit" sub-blocks. If unsure of which to use, a good default is to define an "update" block to ensure all properties are updated.
  
  
    In addition, the custom "encode" block for an axis or legend can include a boolean "interactive" value to control if specific axis or legend items should be subject to input events. For example, to enable interaction for legend symbols:

    "legends": [
  {
    "fill": "colorScale",
    "title": "Legend Title",
    "orient": "right",
    "encode": {
      "symbols": {
        "interactive": true,
        "hover": {...},
        "update": {...}
      }
    }
  }
]
    
  
  
    Legends now include an optional "type" property. By default, all legends use the "symbol" type, to create a discrete legend. For continuous color scales, the "gradient" type can be used to create a legend containing a continuous color ramp. See the legends.vg.json example for more.
  
  
    Axis now no longer has "layer" property. Instead, there is a "zindex" property (default 0). By default, axes should be drawn behind all chart elements. To put them in front, use "zindex": 1.
  
  
    The axis line previously stylable as "axis" is now referred to as the axis "domain". For example, use "domain": false to hide the axis line, or include a "domain" property in the "encode" block to style the axis line.
  
  
    Axis ticks, labels, gridlines, and domain can all be selectively enabled or disabled. Axis ticks, labels and domain are enabled by default, but can be disabled (for example, "tick": false, "label": false). Axis grid lines are disabled by default, but can be enabled ("grid": true). These toggles can be useful to achieve richer layering. For example, one might place an axis definition with only gridlines on a bottom layer, and add an axis definition with ticks and labels on a higher layer.
  
  
    By default, the axis gridline extent is determined by the settings of the signals "width" (for y-axis gridlines) or "height" (for x-axis gridlines). This is a change from Vega 2, where the group width/height was used. Vega 3 enables recursive signal definitions: named signal values can be overridden within sub-groups, allowing one to set appropriate width/height signal values in sub-plots. Alternatively, Vega 3 introduces a "gridScale" property which instead indicates a scale whose range should be used to determine the gridline extent. For example, if you have an x-axis scale named “xscale”, the y-axis gridline lengths can be set to match that scale by using "gridScale": "xscale".
  


Back to outline

Scales


  
    Following D3 4.0’s design, the "ordinal" scale type was been broken up into three different scale types: "ordinal" (for strict lookup tables), "band" (for spatial ordinal scales) and "point" (spatial ordinal scales with no padding, similar to {"point": true} in Vega 2).
  
  
    Vega 3 added D3 4.0+’s "sequential" scale type and corresponding color scales. Use the "scheme" property to set the range to a named color scale (e.g., "viridis", "plasma", or "magma"). To see the list of supported built-in schemes, or to add new custom schemes, see the scheme documentation.
  
  
    The "category10", "category20" and similar color palettes are no longer available as built-in range names. Instead, they are available using the scale "scheme" property, which can be specified instead of a scale range for "ordinal" and "sequential" scales. However, Vega 3 does support a built-in "category" short-hand for ordinal scale ranges, which can be re-defined as part of the theme configuration.
  
  
    Vega 3 added a new "index" scale type which maps an ordinal domain to a quantitative range (e.g., as supported by "linear" or "sequential" scales). This is particularly useful for creating ordered color ramps for ordinal data.
  
  
    Scale domains involving multiple data fields from the same table must now be listed under the "fields" property, not "field". For example, "domain": {"data": "table", "fields": ["fieldA", "fieldB"]}.
  


Back to outline

Data Transforms


  
    Vega 3 also introduced a number of new transforms, and modifications to previous transforms (including a dramatically improved "force" transform and improved hierarchical layout support). Web-based documentation is still forthcoming. However, most of these transforms are demonstrated in the example specifications included in this repo. In addition, the parameters accepted by each transform are documented via JSDoc comments in the source code. Please consult the appropriate Vega module repositories for further information.
  
  
    Vega 2.x transform "output" maps for determining output field names have been removed. Instead, the relevant transforms accept an "as" parameter that (depending on the transform type) takes either a single string or an ordered array of strings, each representing a desired output field name. See the documentation (including JSDoc source code comments) for individual transforms for more information.
  
  
    Similarly, the "formula" transform "field" parameter has been renamed "as".
  
  
    A number of transforms now have different default output field names. In most cases, this was done to make the values more easily serve as scenegraph item properties (for example, when using post-encoding transforms).
  
  
    For layout transforms such as "pie", "stack", and "bin", midpoint calculations (e.g., layout_mid) are no longer included as output. Instead, one can use a "signal" expression to calculate a midpoint. For example, to compute the midpoints after a stack transform: `“y”: {“scale”: “yscale”, “signal”: “0.5 * (datum.y0 + datum.y1)”}).
  
  
    The "aggregate" transform no longer uses a "summarize" block for defining aggregation operations. In Vega 3 onward, we instead use a flat set of (equal-length) arrays specifying the aggregation fields, operations and output field names:

    {
  "type": "aggregate",
  "groupby": ["category1", "category2"],
  "fields": ["measure1", "measure1", "measure2"],
  "ops": ["min", "max", "median"],
  "as": ["min1", "max1", "median2"]
}
    
  
  For the "bin" transform:
    
      The "max" and "min" parameters have been removed.  Instead, users can provide "extent", a two-element ([min, max]) array indicating the range of desired bin values.
      The "div" property has been renamed to "divide".
    
  
  
    The "filter" transform "test" parameter has been renamed "expr" for consistency with other transforms that take an expression parameter.
  
  
    For the "lookup" transform, the "on", "onKey" and "keys" parameters have been renamed "from", "key", and "fields".
  
  
    The "sort" transform has been removed. In Vega 2, the sort transform was actually a no-op that added a special annotation to the pulse passing through it, which was later used to sort tuples at the end of a transform pipeline. Vega 3 dropped this behavior. Instead, there are two options for achieving sorting in a visualization: (1) Use a "sort" directive as part of a scale "domain" definition, or (2) use a "collect" transform and provide "sort" parameter. This ensures that sorting occurs immediately at the point at which it is requested, not at an indeterminate point down stream in the dataflow. We recommend using option (1) if workable, and (2) otherwise.
  
  The "stack" transform "sortby" parameter has been renamed "sort".


Back to outline

Geo Data


  
    Cartographic projections are now defined in their own top-level block, similar to scales. Named projections are defined within an array under the projections property. Inline projection definitions for geo transforms are no longer allowed. Instead, geo transforms include a "projection" parameter which takes the name of a defined projection.
  
  
    The "geo" transform has been renamed "geopoint".
  
  
    A "graticule" transform has been added to generate reference lines for projections. To add graticules for a map, create a new “empty” data set definition (with no "url" or "source" properties), and include a "graticule" transform as the first entry in the data "transforms" array.
  
  
    In addition to the "geopath" transform, a "geoshape" transform has been added, which generates data for use with the new shape mark type. This mark type delays shape calculations until render time. Under canvas rendering, this can result in much faster draw times, as the projected geo-data does not need to be marshalled into an SVG path string.
  


Back to outline

Animation


  Animated transitions are not currently supported by Vega 3.0 and later. As a result, the "delay" and "ease" properties are no longer used.


Back to outline

View API


  
    The Vega View API has been updated and streamlined. To create a Vega visualization, the Vega spec must first be parsed, the resulting runtime specification can then be passed as an argument to the View constructor. Unlike Vega 2.x, this process does not require asynchronous callbacks. For example:

    var runtime = vega.parse(spec); // may throw an Error if parsing fails
var view = new vega.View(runtime)
  .logLevel(vega.Warn) // set view logging level
  .initialize(document.querySelector('#view')) // set parent DOM element
  .renderer('svg') // set render type (defaults to 'canvas')
  .hover() // enable hover event processing
  .run(); // update and render the view
    
  
  
    Instead of view.update, the view.run method now invokes dataflow pulse propagation and re-rendering.
  
  
    Instead of view.destroy, the view.finalize method should be called to prepare the view to be removed from a web page.
  
  
    The underlying View API and dataflow system have been extensively overhauled. A Vega View instance is now a direct subclass of a Vega Dataflow, and manages all reactive processing, streaming data input, and rendering. In addition to the View API Reference, comprehensive JSDoc comments are included in the source code of the vega-view and vega-dataflow repositories.
  


Back to outline\nVega
            
              Vega-Lite
              Altair
              Vega-Lite API\nVega-Lite
              Altair
              Vega-Lite API\nExamples
              Tutorials
              Documentation
              Usage
              About
            
            
              GitHub
              Try Online\nExamples
              Tutorials
              Documentation
              Usage
              About\nGitHub
              Try Online\nPorting Guide from Vega 2
    This document describes the various changes needed to port Vega 2.x specifications to more recent versions. It also introduces a subset of the new features that were introduced in Vega 3. While the listing below is intended to cover the most salient differences between these major versions, readers are also encouraged to dive in and study the example gallery.

Porting Guide Outline


  Marks and Visual Encoding
  Signals and Event Processing
  View Layout
  Axes and Legends
  Scales
  Data Transforms
  Geo Data
  Animation
  View API


Marks and Visual Encoding


  
    The "properties" block of visual encodings has been renamed "encode".
  
  
    The "signal" encoding directive now accepts anonymous signal expressions in addition to signal names. You can use these to directly write expressions for visual encodings. For example: {"signal": "datum.field * 2"}.
  
  
    The "template" encoding directive has been removed. Instead, use the "signal" directive with an expression to perform equivalent text processing.
  
  
    The "mult" and "offset" visual encoding properties now support recursive encoding directives, enabling greater control. For example, each can include a sub-encoding like so: "x": {"scale": "xscale", "field": "foo", "offset": {"scale": "oscale", "field": "bar"}}.
  
  
    The "band" property now accepts an interpolation fraction between 0 and 1 for placing elements within a scale band, and can now be used in conjunction with a field-based scale mapping. For example, the following encoding places an item at the midpoint of the appropriate scale band: {"scale": "xscale", "field": "foo", "band": 0.5}.
  
  
    The rule mark type now supports arbitrary line segments, and reliably draws a line from point "x", "y" to point "x2", "y2".
  
  
    Mark definitions no longer allow embedded data transforms (e.g., {"type": "rect", "from": {"data": "table, "transform": [...]}}). Instead, all derived data sources must now be defined within a "data" definition block. However, as of Vega 3, "data" blocks are no longer constrained to only the top-level of a spec: they can be defined within group marks as well! For example, this flexibility allows creation of derived data sets within a faceted group.
  
  
    The "facet" transform is no longer supported. Instead, a new "facet" directive can be applied within a mark "from" block to enable multiple forms of faceting support. Also, the "aggregate" transform can be used for grouping. For example, the barley.vg.json example facets a group mark like so:

    "from": {
  "facet": {
    "name": "sites",
    "data": "barley",
    "groupby": "site"
  }
},
    
    Child marks can visualize the faceted data by name: "from": {"data": "sites"}. The "facet" block also accepts the same parameters as an "aggregate" transform to apply when generating data elements for group mark items. In addition, Vega 3 now supports pre-faceted data, in which a data tuple may contain a nested a set of records. This oft-requested feature allows data to be grouped offline and passed directly to Vega, like so:

    "from": {
  "facet": {
    "name":  "facets",
    "data":  "input", // [{children: [...]}, {children: [...]}]
    "field": "children"
  }
},
    
    In this case, each datum in input will back a group mark item, and each corresponding group will contain the data tuples referenced by the "children" field.
  
  
    In addition to the "encode" (formerly "properties") blocks, mark definitions now support post-encoding transforms: data transforms that are run after the "encode" block, and which read and write scenegraph item properties directly. For example, one can run layout algorithms (force-directed layout, wordcloud layout, tree layout, etc.) to directly set the visual properties of items, rather than write them to an intermediate data tuple and then copy them over (as done in Vega 2). Only transforms that do not filter or generate new tuples can be used as post-encoding transforms. Here is an example excerpt from wordcloud.vg.json:

    "marks": [{
  "type": "text",
  "from": {"data": "table"},
  "encode": {...},
  "transform": [
    {
      "type": "wordcloud",
      "size": [800, 400],
      "text": {"field": "text"},
      ...
    }
  ]
}]
    
  
  
    Vega 3 added a new shape mark type. Shape marks are similar in functionality to path marks. However, while path marks require a materialized SVG path string, shape marks are generated procedurally by passing a path-rendering function to the renderer. This allows drawing of shapes without passing through the intermediate representation of a path string, which can considerably improve rendering time when using a canvas renderer. For SVG renderers, the shape type generates an SVG path string (but at render time, not visual encoding time) to include in the SVG DOM.
  
  
    Vega 3 added z-index support for changing the layering order of sibling elements. Z-index values are expected to be non-negative integers. All scenegraph items default to a zindex of zero. Higher values indicate elements that should be drawn on top of their sibling marks. Mark, axis and legend definitions accept a "zindex" property, and "zindex" can also be used as an individual visual encoding property (e.g., in a "hover" or "update" set). Z-index sorting is performed at the sibling-level only; for example, it can not be used to force a single item in one mark set to be drawn on top of items in another mark set.
  


Back to outline

Signals and Event Processing


  
    The signal "streams" property has been renamed "on". Within an event stream definition, the "type" parameter has been renamed "events", and the "expr" parameter has been renamed "update". For example, the signal definition {"name": "foo", "streams": [{"type": "rect:mousedown", "expr": "eventX()"}]}, should now be written as {"name": "foo", "on": [{"events": "rect:mousedown", "update": "x()"}]}.
  
  
    The "events" parameter of an event stream definition can either be a string containing an event selector description (as in Vega 2.x) or can use a structured JSON schema for expressing event selections.
  
  
    The eventItem, eventGroup, eventX, and eventY expression language functions have been replaced with the more concise item, group, x and y functions. Also, a new xy function returns the current pointer coordinate as an [x, y] array.
  
  
    Events are no longer consumed (e.g., subject to event.preventDefault()) by default. To have Vega consume an event (and thereby suppress event propagation and default browser behavior), include an exclamation mark at the end of an event name within an event selector (e.g., {"events": "window:mousemove!"}).
  
  
    The "verbose" flag has been renamed to "force", and must now be set on individual elements of the "on" array. For example, the signal definition {"name": "clickedPoint", "verbose": true, "streams": [{"type": "click", "expr": "datum.key"}]} should now be written as {"name": "clickedPoint", "on": [{"events": "click", "update": "datum.key", "force": true}]}.
  
  
    Instead of "init", the "value" and "update" properties can be used to initialize a signal using a literal value or expression, respectively.
  
  
    Signal definitions now support a "bind" property that binds signal values to automatically-generated HTML input widgets. This provides an additional means of creating interactive visualizations by adding external user controls. The syntax for "bind" definitions follows the earlier vega-embed model. See the airports.vg.json and map-bind.vg.json examples for more.
  
  
    The View API for event listeners has changed. The view.on and view.off methods are no longer defined. Either use view.addEventListener and view.removeEventListener for standard callbacks or use the new view.events method to work with EventStream instances instead.
  
  
    The View API for signal listeners has changed. Instead of view.onSignal and view.offSignal, use view.addSignalListener and view.removeSignalListener.
  


Back to outline

View Layout


  
    The Vega 2.x top-level "viewport" property has been removed. Instead, the same behavior can be specified directly by using width/height/overflow CSS directives on the DOM element container for the Vega view.
  
  
    The chart "width" and "height" are automatically bound to signals with the same name. The top-level "width" and "height" properties can be omitted from the definition and instead replaced by signal definitions whose "update" function dynamically sets the width and/or height value.
  
  Vega 3 added a new top-level "autosize" property to set the layout mode. The legal values are:
    
      "pad" (default) - The width/height values determine the data rectangle for plotting. Axes and legends use additional space, with extra padding added to accommodate those elements. This is akin to "padding": "auto" in Vega 2.
      "fit" - The width/height indicates the final size (minus any explicit padding). The actual width and height signals will be automatically resized to accommodate axes and legends within the given fit size. If elements are too large to fit in the given size, clipping may occur. This is akin to "padding": "strict" in Vega 2.
      "none” - No automatic adjustment of size is performed. The final size is strictly the sum of the width/height and any explicit padding. Clipping may occur.
    
  
  
    Vega 3 removed the "auto" and "strict" options for view "padding". Instead, "padding" now always defines a fixed padding margin around the visualization. If the "autosize" property is set to "pad", the padding values will be added to the results of the auto-size calculation.
  
  SVG rendering now supports some basic responsive resizing. Generated SVG output now includes a viewBox attribute. This allows you to resize the SVG element and have the resulting visualization content scale accordingly.


Back to outline

Axes and Legends


  
    Axes no longer have a type parameter. Instead, the orient parameter is now required. Instead of {"type": "x"} use {"orient": "bottom"}, and instead of {"type": "y"} use {"orient": "left"}.
  
  
    The "ticks" parameter for suggesting the approximate number of axis ticks has been renamed "tickCount".
  
  
    Custom visual properties for axes and legends now reside under an "encode" block and use "enter", "update", and "exit" sub-blocks. If unsure of which to use, a good default is to define an "update" block to ensure all properties are updated.
  
  
    In addition, the custom "encode" block for an axis or legend can include a boolean "interactive" value to control if specific axis or legend items should be subject to input events. For example, to enable interaction for legend symbols:

    "legends": [
  {
    "fill": "colorScale",
    "title": "Legend Title",
    "orient": "right",
    "encode": {
      "symbols": {
        "interactive": true,
        "hover": {...},
        "update": {...}
      }
    }
  }
]
    
  
  
    Legends now include an optional "type" property. By default, all legends use the "symbol" type, to create a discrete legend. For continuous color scales, the "gradient" type can be used to create a legend containing a continuous color ramp. See the legends.vg.json example for more.
  
  
    Axis now no longer has "layer" property. Instead, there is a "zindex" property (default 0). By default, axes should be drawn behind all chart elements. To put them in front, use "zindex": 1.
  
  
    The axis line previously stylable as "axis" is now referred to as the axis "domain". For example, use "domain": false to hide the axis line, or include a "domain" property in the "encode" block to style the axis line.
  
  
    Axis ticks, labels, gridlines, and domain can all be selectively enabled or disabled. Axis ticks, labels and domain are enabled by default, but can be disabled (for example, "tick": false, "label": false). Axis grid lines are disabled by default, but can be enabled ("grid": true). These toggles can be useful to achieve richer layering. For example, one might place an axis definition with only gridlines on a bottom layer, and add an axis definition with ticks and labels on a higher layer.
  
  
    By default, the axis gridline extent is determined by the settings of the signals "width" (for y-axis gridlines) or "height" (for x-axis gridlines). This is a change from Vega 2, where the group width/height was used. Vega 3 enables recursive signal definitions: named signal values can be overridden within sub-groups, allowing one to set appropriate width/height signal values in sub-plots. Alternatively, Vega 3 introduces a "gridScale" property which instead indicates a scale whose range should be used to determine the gridline extent. For example, if you have an x-axis scale named “xscale”, the y-axis gridline lengths can be set to match that scale by using "gridScale": "xscale".
  


Back to outline

Scales


  
    Following D3 4.0’s design, the "ordinal" scale type was been broken up into three different scale types: "ordinal" (for strict lookup tables), "band" (for spatial ordinal scales) and "point" (spatial ordinal scales with no padding, similar to {"point": true} in Vega 2).
  
  
    Vega 3 added D3 4.0+’s "sequential" scale type and corresponding color scales. Use the "scheme" property to set the range to a named color scale (e.g., "viridis", "plasma", or "magma"). To see the list of supported built-in schemes, or to add new custom schemes, see the scheme documentation.
  
  
    The "category10", "category20" and similar color palettes are no longer available as built-in range names. Instead, they are available using the scale "scheme" property, which can be specified instead of a scale range for "ordinal" and "sequential" scales. However, Vega 3 does support a built-in "category" short-hand for ordinal scale ranges, which can be re-defined as part of the theme configuration.
  
  
    Vega 3 added a new "index" scale type which maps an ordinal domain to a quantitative range (e.g., as supported by "linear" or "sequential" scales). This is particularly useful for creating ordered color ramps for ordinal data.
  
  
    Scale domains involving multiple data fields from the same table must now be listed under the "fields" property, not "field". For example, "domain": {"data": "table", "fields": ["fieldA", "fieldB"]}.
  


Back to outline

Data Transforms


  
    Vega 3 also introduced a number of new transforms, and modifications to previous transforms (including a dramatically improved "force" transform and improved hierarchical layout support). Web-based documentation is still forthcoming. However, most of these transforms are demonstrated in the example specifications included in this repo. In addition, the parameters accepted by each transform are documented via JSDoc comments in the source code. Please consult the appropriate Vega module repositories for further information.
  
  
    Vega 2.x transform "output" maps for determining output field names have been removed. Instead, the relevant transforms accept an "as" parameter that (depending on the transform type) takes either a single string or an ordered array of strings, each representing a desired output field name. See the documentation (including JSDoc source code comments) for individual transforms for more information.
  
  
    Similarly, the "formula" transform "field" parameter has been renamed "as".
  
  
    A number of transforms now have different default output field names. In most cases, this was done to make the values more easily serve as scenegraph item properties (for example, when using post-encoding transforms).
  
  
    For layout transforms such as "pie", "stack", and "bin", midpoint calculations (e.g., layout_mid) are no longer included as output. Instead, one can use a "signal" expression to calculate a midpoint. For example, to compute the midpoints after a stack transform: `“y”: {“scale”: “yscale”, “signal”: “0.5 * (datum.y0 + datum.y1)”}).
  
  
    The "aggregate" transform no longer uses a "summarize" block for defining aggregation operations. In Vega 3 onward, we instead use a flat set of (equal-length) arrays specifying the aggregation fields, operations and output field names:

    {
  "type": "aggregate",
  "groupby": ["category1", "category2"],
  "fields": ["measure1", "measure1", "measure2"],
  "ops": ["min", "max", "median"],
  "as": ["min1", "max1", "median2"]
}
    
  
  For the "bin" transform:
    
      The "max" and "min" parameters have been removed.  Instead, users can provide "extent", a two-element ([min, max]) array indicating the range of desired bin values.
      The "div" property has been renamed to "divide".
    
  
  
    The "filter" transform "test" parameter has been renamed "expr" for consistency with other transforms that take an expression parameter.
  
  
    For the "lookup" transform, the "on", "onKey" and "keys" parameters have been renamed "from", "key", and "fields".
  
  
    The "sort" transform has been removed. In Vega 2, the sort transform was actually a no-op that added a special annotation to the pulse passing through it, which was later used to sort tuples at the end of a transform pipeline. Vega 3 dropped this behavior. Instead, there are two options for achieving sorting in a visualization: (1) Use a "sort" directive as part of a scale "domain" definition, or (2) use a "collect" transform and provide "sort" parameter. This ensures that sorting occurs immediately at the point at which it is requested, not at an indeterminate point down stream in the dataflow. We recommend using option (1) if workable, and (2) otherwise.
  
  The "stack" transform "sortby" parameter has been renamed "sort".


Back to outline

Geo Data


  
    Cartographic projections are now defined in their own top-level block, similar to scales. Named projections are defined within an array under the projections property. Inline projection definitions for geo transforms are no longer allowed. Instead, geo transforms include a "projection" parameter which takes the name of a defined projection.
  
  
    The "geo" transform has been renamed "geopoint".
  
  
    A "graticule" transform has been added to generate reference lines for projections. To add graticules for a map, create a new “empty” data set definition (with no "url" or "source" properties), and include a "graticule" transform as the first entry in the data "transforms" array.
  
  
    In addition to the "geopath" transform, a "geoshape" transform has been added, which generates data for use with the new shape mark type. This mark type delays shape calculations until render time. Under canvas rendering, this can result in much faster draw times, as the projected geo-data does not need to be marshalled into an SVG path string.
  


Back to outline

Animation


  Animated transitions are not currently supported by Vega 3.0 and later. As a result, the "delay" and "ease" properties are no longer used.


Back to outline

View API


  
    The Vega View API has been updated and streamlined. To create a Vega visualization, the Vega spec must first be parsed, the resulting runtime specification can then be passed as an argument to the View constructor. Unlike Vega 2.x, this process does not require asynchronous callbacks. For example:

    var runtime = vega.parse(spec); // may throw an Error if parsing fails
var view = new vega.View(runtime)
  .logLevel(vega.Warn) // set view logging level
  .initialize(document.querySelector('#view')) // set parent DOM element
  .renderer('svg') // set render type (defaults to 'canvas')
  .hover() // enable hover event processing
  .run(); // update and render the view
    
  
  
    Instead of view.update, the view.run method now invokes dataflow pulse propagation and re-rendering.
  
  
    Instead of view.destroy, the view.finalize method should be called to prepare the view to be removed from a web page.
  
  
    The underlying View API and dataflow system have been extensively overhauled. A Vega View instance is now a direct subclass of a Vega Dataflow, and manages all reactive processing, streaming data input, and rendering. In addition to the View API Reference, comprehensive JSDoc comments are included in the source code of the vega-view and vega-dataflow repositories.
  


Back to outline\nPorting Guide from Vega 2\nThis document describes the various changes needed to port Vega 2.x specifications to more recent versions. It also introduces a subset of the new features that were introduced in Vega 3. While the listing below is intended to cover the most salient differences between these major versions, readers are also encouraged to dive in and study the example gallery.\nPorting Guide Outline\nMarks and Visual Encoding\nMarks and Visual Encoding\nSignals and Event Processing\nSignals and Event Processing\nMarks and Visual Encoding\nThe "properties" block of visual encodings has been renamed "encode".\nThe "properties" block of visual encodings has been renamed "encode".\nThe "signal" encoding directive now accepts anonymous signal expressions in addition to signal names. You can use these to directly write expressions for visual encodings. For example: {"signal": "datum.field * 2"}.\nThe "signal" encoding directive now accepts anonymous signal expressions in addition to signal names. You can use these to directly write expressions for visual encodings. For example: {"signal": "datum.field * 2"}.\nThe "template" encoding directive has been removed. Instead, use the "signal" directive with an expression to perform equivalent text processing.\nThe "template" encoding directive has been removed. Instead, use the "signal" directive with an expression to perform equivalent text processing.\nThe "mult" and "offset" visual encoding properties now support recursive encoding directives, enabling greater control. For example, each can include a sub-encoding like so: "x": {"scale": "xscale", "field": "foo", "offset": {"scale": "oscale", "field": "bar"}}.\nThe "mult" and "offset" visual encoding properties now support recursive encoding directives, enabling greater control. For example, each can include a sub-encoding like so: "x": {"scale": "xscale", "field": "foo", "offset": {"scale": "oscale", "field": "bar"}}.\nThe "band" property now accepts an interpolation fraction between 0 and 1 for placing elements within a scale band, and can now be used in conjunction with a field-based scale mapping. For example, the following encoding places an item at the midpoint of the appropriate scale band: {"scale": "xscale", "field": "foo", "band": 0.5}.\nThe "band" property now accepts an interpolation fraction between 0 and 1 for placing elements within a scale band, and can now be used in conjunction with a field-based scale mapping. For example, the following encoding places an item at the midpoint of the appropriate scale band: {"scale": "xscale", "field": "foo", "band": 0.5}.\nThe rule mark type now supports arbitrary line segments, and reliably draws a line from point "x", "y" to point "x2", "y2".\nThe rule mark type now supports arbitrary line segments, and reliably draws a line from point "x", "y" to point "x2", "y2".\nMark definitions no longer allow embedded data transforms (e.g., {"type": "rect", "from": {"data": "table, "transform": [...]}}). Instead, all derived data sources must now be defined within a "data" definition block. However, as of Vega 3, "data" blocks are no longer constrained to only the top-level of a spec: they can be defined within group marks as well! For example, this flexibility allows creation of derived data sets within a faceted group.\nMark definitions no longer allow embedded data transforms (e.g., {"type": "rect", "from": {"data": "table, "transform": [...]}}). Instead, all derived data sources must now be defined within a "data" definition block. However, as of Vega 3, "data" blocks are no longer constrained to only the top-level of a spec: they can be defined within group marks as well! For example, this flexibility allows creation of derived data sets within a faceted group.\nThe "facet" transform is no longer supported. Instead, a new "facet" directive can be applied within a mark "from" block to enable multiple forms of faceting support. Also, the "aggregate" transform can be used for grouping. For example, the barley.vg.json example facets a group mark like so:

    "from": {
  "facet": {
    "name": "sites",
    "data": "barley",
    "groupby": "site"
  }
},
    
    Child marks can visualize the faceted data by name: "from": {"data": "sites"}. The "facet" block also accepts the same parameters as an "aggregate" transform to apply when generating data elements for group mark items. In addition, Vega 3 now supports pre-faceted data, in which a data tuple may contain a nested a set of records. This oft-requested feature allows data to be grouped offline and passed directly to Vega, like so:

    "from": {
  "facet": {
    "name":  "facets",
    "data":  "input", // [{children: [...]}, {children: [...]}]
    "field": "children"
  }
},
    
    In this case, each datum in input will back a group mark item, and each corresponding group will contain the data tuples referenced by the "children" field.\nThe "facet" transform is no longer supported. Instead, a new "facet" directive can be applied within a mark "from" block to enable multiple forms of faceting support. Also, the "aggregate" transform can be used for grouping. For example, the barley.vg.json example facets a group mark like so:\n"from": {
  "facet": {
    "name": "sites",
    "data": "barley",
    "groupby": "site"
  }
},\n"from": {
  "facet": {
    "name": "sites",
    "data": "barley",
    "groupby": "site"
  }
},\nChild marks can visualize the faceted data by name: "from": {"data": "sites"}. The "facet" block also accepts the same parameters as an "aggregate" transform to apply when generating data elements for group mark items. In addition, Vega 3 now supports pre-faceted data, in which a data tuple may contain a nested a set of records. This oft-requested feature allows data to be grouped offline and passed directly to Vega, like so:\n"from": {
  "facet": {
    "name":  "facets",
    "data":  "input", // [{children: [...]}, {children: [...]}]
    "field": "children"
  }
},\n"from": {
  "facet": {
    "name":  "facets",
    "data":  "input", // [{children: [...]}, {children: [...]}]
    "field": "children"
  }
},\nIn this case, each datum in input will back a group mark item, and each corresponding group will contain the data tuples referenced by the "children" field.\nIn addition to the "encode" (formerly "properties") blocks, mark definitions now support post-encoding transforms: data transforms that are run after the "encode" block, and which read and write scenegraph item properties directly. For example, one can run layout algorithms (force-directed layout, wordcloud layout, tree layout, etc.) to directly set the visual properties of items, rather than write them to an intermediate data tuple and then copy them over (as done in Vega 2). Only transforms that do not filter or generate new tuples can be used as post-encoding transforms. Here is an example excerpt from wordcloud.vg.json:

    "marks": [{
  "type": "text",
  "from": {"data": "table"},
  "encode": {...},
  "transform": [
    {
      "type": "wordcloud",
      "size": [800, 400],
      "text": {"field": "text"},
      ...
    }
  ]
}]\nIn addition to the "encode" (formerly "properties") blocks, mark definitions now support post-encoding transforms: data transforms that are run after the "encode" block, and which read and write scenegraph item properties directly. For example, one can run layout algorithms (force-directed layout, wordcloud layout, tree layout, etc.) to directly set the visual properties of items, rather than write them to an intermediate data tuple and then copy them over (as done in Vega 2). Only transforms that do not filter or generate new tuples can be used as post-encoding transforms. Here is an example excerpt from wordcloud.vg.json:\n"marks": [{
  "type": "text",
  "from": {"data": "table"},
  "encode": {...},
  "transform": [
    {
      "type": "wordcloud",
      "size": [800, 400],
      "text": {"field": "text"},
      ...
    }
  ]
}]\n"marks": [{
  "type": "text",
  "from": {"data": "table"},
  "encode": {...},
  "transform": [
    {
      "type": "wordcloud",
      "size": [800, 400],
      "text": {"field": "text"},
      ...
    }
  ]
}]\nVega 3 added a new shape mark type. Shape marks are similar in functionality to path marks. However, while path marks require a materialized SVG path string, shape marks are generated procedurally by passing a path-rendering function to the renderer. This allows drawing of shapes without passing through the intermediate representation of a path string, which can considerably improve rendering time when using a canvas renderer. For SVG renderers, the shape type generates an SVG path string (but at render time, not visual encoding time) to include in the SVG DOM.\nVega 3 added a new shape mark type. Shape marks are similar in functionality to path marks. However, while path marks require a materialized SVG path string, shape marks are generated procedurally by passing a path-rendering function to the renderer. This allows drawing of shapes without passing through the intermediate representation of a path string, which can considerably improve rendering time when using a canvas renderer. For SVG renderers, the shape type generates an SVG path string (but at render time, not visual encoding time) to include in the SVG DOM.\nVega 3 added z-index support for changing the layering order of sibling elements. Z-index values are expected to be non-negative integers. All scenegraph items default to a zindex of zero. Higher values indicate elements that should be drawn on top of their sibling marks. Mark, axis and legend definitions accept a "zindex" property, and "zindex" can also be used as an individual visual encoding property (e.g., in a "hover" or "update" set). Z-index sorting is performed at the sibling-level only; for example, it can not be used to force a single item in one mark set to be drawn on top of items in another mark set.\nVega 3 added z-index support for changing the layering order of sibling elements. Z-index values are expected to be non-negative integers. All scenegraph items default to a zindex of zero. Higher values indicate elements that should be drawn on top of their sibling marks. Mark, axis and legend definitions accept a "zindex" property, and "zindex" can also be used as an individual visual encoding property (e.g., in a "hover" or "update" set). Z-index sorting is performed at the sibling-level only; for example, it can not be used to force a single item in one mark set to be drawn on top of items in another mark set.\nSignals and Event Processing\nThe signal "streams" property has been renamed "on". Within an event stream definition, the "type" parameter has been renamed "events", and the "expr" parameter has been renamed "update". For example, the signal definition {"name": "foo", "streams": [{"type": "rect:mousedown", "expr": "eventX()"}]}, should now be written as {"name": "foo", "on": [{"events": "rect:mousedown", "update": "x()"}]}.\nThe signal "streams" property has been renamed "on". Within an event stream definition, the "type" parameter has been renamed "events", and the "expr" parameter has been renamed "update". For example, the signal definition {"name": "foo", "streams": [{"type": "rect:mousedown", "expr": "eventX()"}]}, should now be written as {"name": "foo", "on": [{"events": "rect:mousedown", "update": "x()"}]}.\nThe "events" parameter of an event stream definition can either be a string containing an event selector description (as in Vega 2.x) or can use a structured JSON schema for expressing event selections.\nThe "events" parameter of an event stream definition can either be a string containing an event selector description (as in Vega 2.x) or can use a structured JSON schema for expressing event selections.\nThe eventItem, eventGroup, eventX, and eventY expression language functions have been replaced with the more concise item, group, x and y functions. Also, a new xy function returns the current pointer coordinate as an [x, y] array.\nThe eventItem, eventGroup, eventX, and eventY expression language functions have been replaced with the more concise item, group, x and y functions. Also, a new xy function returns the current pointer coordinate as an [x, y] array.\nEvents are no longer consumed (e.g., subject to event.preventDefault()) by default. To have Vega consume an event (and thereby suppress event propagation and default browser behavior), include an exclamation mark at the end of an event name within an event selector (e.g., {"events": "window:mousemove!"}).\nEvents are no longer consumed (e.g., subject to event.preventDefault()) by default. To have Vega consume an event (and thereby suppress event propagation and default browser behavior), include an exclamation mark at the end of an event name within an event selector (e.g., {"events": "window:mousemove!"}).\nThe "verbose" flag has been renamed to "force", and must now be set on individual elements of the "on" array. For example, the signal definition {"name": "clickedPoint", "verbose": true, "streams": [{"type": "click", "expr": "datum.key"}]} should now be written as {"name": "clickedPoint", "on": [{"events": "click", "update": "datum.key", "force": true}]}.\nThe "verbose" flag has been renamed to "force", and must now be set on individual elements of the "on" array. For example, the signal definition {"name": "clickedPoint", "verbose": true, "streams": [{"type": "click", "expr": "datum.key"}]} should now be written as {"name": "clickedPoint", "on": [{"events": "click", "update": "datum.key", "force": true}]}.\nInstead of "init", the "value" and "update" properties can be used to initialize a signal using a literal value or expression, respectively.\nInstead of "init", the "value" and "update" properties can be used to initialize a signal using a literal value or expression, respectively.\nSignal definitions now support a "bind" property that binds signal values to automatically-generated HTML input widgets. This provides an additional means of creating interactive visualizations by adding external user controls. The syntax for "bind" definitions follows the earlier vega-embed model. See the airports.vg.json and map-bind.vg.json examples for more.\nSignal definitions now support a "bind" property that binds signal values to automatically-generated HTML input widgets. This provides an additional means of creating interactive visualizations by adding external user controls. The syntax for "bind" definitions follows the earlier vega-embed model. See the airports.vg.json and map-bind.vg.json examples for more.\nThe View API for event listeners has changed. The view.on and view.off methods are no longer defined. Either use view.addEventListener and view.removeEventListener for standard callbacks or use the new view.events method to work with EventStream instances instead.\nThe View API for event listeners has changed. The view.on and view.off methods are no longer defined. Either use view.addEventListener and view.removeEventListener for standard callbacks or use the new view.events method to work with EventStream instances instead.\nview.addEventListener\nview.removeEventListener\nThe View API for signal listeners has changed. Instead of view.onSignal and view.offSignal, use view.addSignalListener and view.removeSignalListener.\nThe View API for signal listeners has changed. Instead of view.onSignal and view.offSignal, use view.addSignalListener and view.removeSignalListener.\nview.addSignalListener\nview.removeSignalListener\nThe Vega 2.x top-level "viewport" property has been removed. Instead, the same behavior can be specified directly by using width/height/overflow CSS directives on the DOM element container for the Vega view.\nThe Vega 2.x top-level "viewport" property has been removed. Instead, the same behavior can be specified directly by using width/height/overflow CSS directives on the DOM element container for the Vega view.\nThe chart "width" and "height" are automatically bound to signals with the same name. The top-level "width" and "height" properties can be omitted from the definition and instead replaced by signal definitions whose "update" function dynamically sets the width and/or height value.\nThe chart "width" and "height" are automatically bound to signals with the same name. The top-level "width" and "height" properties can be omitted from the definition and instead replaced by signal definitions whose "update" function dynamically sets the width and/or height value.\nVega 3 added a new top-level "autosize" property to set the layout mode. The legal values are:
    
      "pad" (default) - The width/height values determine the data rectangle for plotting. Axes and legends use additional space, with extra padding added to accommodate those elements. This is akin to "padding": "auto" in Vega 2.
      "fit" - The width/height indicates the final size (minus any explicit padding). The actual width and height signals will be automatically resized to accommodate axes and legends within the given fit size. If elements are too large to fit in the given size, clipping may occur. This is akin to "padding": "strict" in Vega 2.
      "none” - No automatic adjustment of size is performed. The final size is strictly the sum of the width/height and any explicit padding. Clipping may occur.\n"pad" (default) - The width/height values determine the data rectangle for plotting. Axes and legends use additional space, with extra padding added to accommodate those elements. This is akin to "padding": "auto" in Vega 2.\n"fit" - The width/height indicates the final size (minus any explicit padding). The actual width and height signals will be automatically resized to accommodate axes and legends within the given fit size. If elements are too large to fit in the given size, clipping may occur. This is akin to "padding": "strict" in Vega 2.\n"none” - No automatic adjustment of size is performed. The final size is strictly the sum of the width/height and any explicit padding. Clipping may occur.\nVega 3 removed the "auto" and "strict" options for view "padding". Instead, "padding" now always defines a fixed padding margin around the visualization. If the "autosize" property is set to "pad", the padding values will be added to the results of the auto-size calculation.\nVega 3 removed the "auto" and "strict" options for view "padding". Instead, "padding" now always defines a fixed padding margin around the visualization. If the "autosize" property is set to "pad", the padding values will be added to the results of the auto-size calculation.\nSVG rendering now supports some basic responsive resizing. Generated SVG output now includes a viewBox attribute. This allows you to resize the SVG element and have the resulting visualization content scale accordingly.\nAxes no longer have a type parameter. Instead, the orient parameter is now required. Instead of {"type": "x"} use {"orient": "bottom"}, and instead of {"type": "y"} use {"orient": "left"}.\nAxes no longer have a type parameter. Instead, the orient parameter is now required. Instead of {"type": "x"} use {"orient": "bottom"}, and instead of {"type": "y"} use {"orient": "left"}.\nThe "ticks" parameter for suggesting the approximate number of axis ticks has been renamed "tickCount".\nThe "ticks" parameter for suggesting the approximate number of axis ticks has been renamed "tickCount".\nCustom visual properties for axes and legends now reside under an "encode" block and use "enter", "update", and "exit" sub-blocks. If unsure of which to use, a good default is to define an "update" block to ensure all properties are updated.\nCustom visual properties for axes and legends now reside under an "encode" block and use "enter", "update", and "exit" sub-blocks. If unsure of which to use, a good default is to define an "update" block to ensure all properties are updated.\nIn addition, the custom "encode" block for an axis or legend can include a boolean "interactive" value to control if specific axis or legend items should be subject to input events. For example, to enable interaction for legend symbols:

    "legends": [
  {
    "fill": "colorScale",
    "title": "Legend Title",
    "orient": "right",
    "encode": {
      "symbols": {
        "interactive": true,
        "hover": {...},
        "update": {...}
      }
    }
  }
]\nIn addition, the custom "encode" block for an axis or legend can include a boolean "interactive" value to control if specific axis or legend items should be subject to input events. For example, to enable interaction for legend symbols:\n"legends": [
  {
    "fill": "colorScale",
    "title": "Legend Title",
    "orient": "right",
    "encode": {
      "symbols": {
        "interactive": true,
        "hover": {...},
        "update": {...}
      }
    }
  }
]\n"legends": [
  {
    "fill": "colorScale",
    "title": "Legend Title",
    "orient": "right",
    "encode": {
      "symbols": {
        "interactive": true,
        "hover": {...},
        "update": {...}
      }
    }
  }
]\nLegends now include an optional "type" property. By default, all legends use the "symbol" type, to create a discrete legend. For continuous color scales, the "gradient" type can be used to create a legend containing a continuous color ramp. See the legends.vg.json example for more.\nLegends now include an optional "type" property. By default, all legends use the "symbol" type, to create a discrete legend. For continuous color scales, the "gradient" type can be used to create a legend containing a continuous color ramp. See the legends.vg.json example for more.\nAxis now no longer has "layer" property. Instead, there is a "zindex" property (default 0). By default, axes should be drawn behind all chart elements. To put them in front, use "zindex": 1.\nAxis now no longer has "layer" property. Instead, there is a "zindex" property (default 0). By default, axes should be drawn behind all chart elements. To put them in front, use "zindex": 1.\nThe axis line previously stylable as "axis" is now referred to as the axis "domain". For example, use "domain": false to hide the axis line, or include a "domain" property in the "encode" block to style the axis line.\nThe axis line previously stylable as "axis" is now referred to as the axis "domain". For example, use "domain": false to hide the axis line, or include a "domain" property in the "encode" block to style the axis line.\nAxis ticks, labels, gridlines, and domain can all be selectively enabled or disabled. Axis ticks, labels and domain are enabled by default, but can be disabled (for example, "tick": false, "label": false). Axis grid lines are disabled by default, but can be enabled ("grid": true). These toggles can be useful to achieve richer layering. For example, one might place an axis definition with only gridlines on a bottom layer, and add an axis definition with ticks and labels on a higher layer.\nAxis ticks, labels, gridlines, and domain can all be selectively enabled or disabled. Axis ticks, labels and domain are enabled by default, but can be disabled (for example, "tick": false, "label": false). Axis grid lines are disabled by default, but can be enabled ("grid": true). These toggles can be useful to achieve richer layering. For example, one might place an axis definition with only gridlines on a bottom layer, and add an axis definition with ticks and labels on a higher layer.\nBy default, the axis gridline extent is determined by the settings of the signals "width" (for y-axis gridlines) or "height" (for x-axis gridlines). This is a change from Vega 2, where the group width/height was used. Vega 3 enables recursive signal definitions: named signal values can be overridden within sub-groups, allowing one to set appropriate width/height signal values in sub-plots. Alternatively, Vega 3 introduces a "gridScale" property which instead indicates a scale whose range should be used to determine the gridline extent. For example, if you have an x-axis scale named “xscale”, the y-axis gridline lengths can be set to match that scale by using "gridScale": "xscale".\nBy default, the axis gridline extent is determined by the settings of the signals "width" (for y-axis gridlines) or "height" (for x-axis gridlines). This is a change from Vega 2, where the group width/height was used. Vega 3 enables recursive signal definitions: named signal values can be overridden within sub-groups, allowing one to set appropriate width/height signal values in sub-plots. Alternatively, Vega 3 introduces a "gridScale" property which instead indicates a scale whose range should be used to determine the gridline extent. For example, if you have an x-axis scale named “xscale”, the y-axis gridline lengths can be set to match that scale by using "gridScale": "xscale".\nFollowing D3 4.0’s design, the "ordinal" scale type was been broken up into three different scale types: "ordinal" (for strict lookup tables), "band" (for spatial ordinal scales) and "point" (spatial ordinal scales with no padding, similar to {"point": true} in Vega 2).\nFollowing D3 4.0’s design, the "ordinal" scale type was been broken up into three different scale types: "ordinal" (for strict lookup tables), "band" (for spatial ordinal scales) and "point" (spatial ordinal scales with no padding, similar to {"point": true} in Vega 2).\nVega 3 added D3 4.0+’s "sequential" scale type and corresponding color scales. Use the "scheme" property to set the range to a named color scale (e.g., "viridis", "plasma", or "magma"). To see the list of supported built-in schemes, or to add new custom schemes, see the scheme documentation.\nVega 3 added D3 4.0+’s "sequential" scale type and corresponding color scales. Use the "scheme" property to set the range to a named color scale (e.g., "viridis", "plasma", or "magma"). To see the list of supported built-in schemes, or to add new custom schemes, see the scheme documentation.\nThe "category10", "category20" and similar color palettes are no longer available as built-in range names. Instead, they are available using the scale "scheme" property, which can be specified instead of a scale range for "ordinal" and "sequential" scales. However, Vega 3 does support a built-in "category" short-hand for ordinal scale ranges, which can be re-defined as part of the theme configuration.\nThe "category10", "category20" and similar color palettes are no longer available as built-in range names. Instead, they are available using the scale "scheme" property, which can be specified instead of a scale range for "ordinal" and "sequential" scales. However, Vega 3 does support a built-in "category" short-hand for ordinal scale ranges, which can be re-defined as part of the theme configuration.\nVega 3 added a new "index" scale type which maps an ordinal domain to a quantitative range (e.g., as supported by "linear" or "sequential" scales). This is particularly useful for creating ordered color ramps for ordinal data.\nVega 3 added a new "index" scale type which maps an ordinal domain to a quantitative range (e.g., as supported by "linear" or "sequential" scales). This is particularly useful for creating ordered color ramps for ordinal data.\nScale domains involving multiple data fields from the same table must now be listed under the "fields" property, not "field". For example, "domain": {"data": "table", "fields": ["fieldA", "fieldB"]}.\nScale domains involving multiple data fields from the same table must now be listed under the "fields" property, not "field". For example, "domain": {"data": "table", "fields": ["fieldA", "fieldB"]}.\nVega 3 also introduced a number of new transforms, and modifications to previous transforms (including a dramatically improved "force" transform and improved hierarchical layout support). Web-based documentation is still forthcoming. However, most of these transforms are demonstrated in the example specifications included in this repo. In addition, the parameters accepted by each transform are documented via JSDoc comments in the source code. Please consult the appropriate Vega module repositories for further information.\nVega 3 also introduced a number of new transforms, and modifications to previous transforms (including a dramatically improved "force" transform and improved hierarchical layout support). Web-based documentation is still forthcoming. However, most of these transforms are demonstrated in the example specifications included in this repo. In addition, the parameters accepted by each transform are documented via JSDoc comments in the source code. Please consult the appropriate Vega module repositories for further information.\nVega 2.x transform "output" maps for determining output field names have been removed. Instead, the relevant transforms accept an "as" parameter that (depending on the transform type) takes either a single string or an ordered array of strings, each representing a desired output field name. See the documentation (including JSDoc source code comments) for individual transforms for more information.\nVega 2.x transform "output" maps for determining output field names have been removed. Instead, the relevant transforms accept an "as" parameter that (depending on the transform type) takes either a single string or an ordered array of strings, each representing a desired output field name. See the documentation (including JSDoc source code comments) for individual transforms for more information.\nSimilarly, the "formula" transform "field" parameter has been renamed "as".\nSimilarly, the "formula" transform "field" parameter has been renamed "as".\nA number of transforms now have different default output field names. In most cases, this was done to make the values more easily serve as scenegraph item properties (for example, when using post-encoding transforms).\nA number of transforms now have different default output field names. In most cases, this was done to make the values more easily serve as scenegraph item properties (for example, when using post-encoding transforms).\nFor layout transforms such as "pie", "stack", and "bin", midpoint calculations (e.g., layout_mid) are no longer included as output. Instead, one can use a "signal" expression to calculate a midpoint. For example, to compute the midpoints after a stack transform: `“y”: {“scale”: “yscale”, “signal”: “0.5 * (datum.y0 + datum.y1)”}).\nFor layout transforms such as "pie", "stack", and "bin", midpoint calculations (e.g., layout_mid) are no longer included as output. Instead, one can use a "signal" expression to calculate a midpoint. For example, to compute the midpoints after a stack transform: `“y”: {“scale”: “yscale”, “signal”: “0.5 * (datum.y0 + datum.y1)”}).\nThe "aggregate" transform no longer uses a "summarize" block for defining aggregation operations. In Vega 3 onward, we instead use a flat set of (equal-length) arrays specifying the aggregation fields, operations and output field names:

    {
  "type": "aggregate",
  "groupby": ["category1", "category2"],
  "fields": ["measure1", "measure1", "measure2"],
  "ops": ["min", "max", "median"],
  "as": ["min1", "max1", "median2"]
}\nThe "aggregate" transform no longer uses a "summarize" block for defining aggregation operations. In Vega 3 onward, we instead use a flat set of (equal-length) arrays specifying the aggregation fields, operations and output field names:\n{
  "type": "aggregate",
  "groupby": ["category1", "category2"],
  "fields": ["measure1", "measure1", "measure2"],
  "ops": ["min", "max", "median"],
  "as": ["min1", "max1", "median2"]
}\n{
  "type": "aggregate",
  "groupby": ["category1", "category2"],
  "fields": ["measure1", "measure1", "measure2"],
  "ops": ["min", "max", "median"],
  "as": ["min1", "max1", "median2"]
}\nFor the "bin" transform:
    
      The "max" and "min" parameters have been removed.  Instead, users can provide "extent", a two-element ([min, max]) array indicating the range of desired bin values.
      The "div" property has been renamed to "divide".\nThe "max" and "min" parameters have been removed.  Instead, users can provide "extent", a two-element ([min, max]) array indicating the range of desired bin values.\nThe "div" property has been renamed to "divide".\nThe "filter" transform "test" parameter has been renamed "expr" for consistency with other transforms that take an expression parameter.\nThe "filter" transform "test" parameter has been renamed "expr" for consistency with other transforms that take an expression parameter.\nFor the "lookup" transform, the "on", "onKey" and "keys" parameters have been renamed "from", "key", and "fields".\nFor the "lookup" transform, the "on", "onKey" and "keys" parameters have been renamed "from", "key", and "fields".\nThe "sort" transform has been removed. In Vega 2, the sort transform was actually a no-op that added a special annotation to the pulse passing through it, which was later used to sort tuples at the end of a transform pipeline. Vega 3 dropped this behavior. Instead, there are two options for achieving sorting in a visualization: (1) Use a "sort" directive as part of a scale "domain" definition, or (2) use a "collect" transform and provide "sort" parameter. This ensures that sorting occurs immediately at the point at which it is requested, not at an indeterminate point down stream in the dataflow. We recommend using option (1) if workable, and (2) otherwise.\nThe "sort" transform has been removed. In Vega 2, the sort transform was actually a no-op that added a special annotation to the pulse passing through it, which was later used to sort tuples at the end of a transform pipeline. Vega 3 dropped this behavior. Instead, there are two options for achieving sorting in a visualization: (1) Use a "sort" directive as part of a scale "domain" definition, or (2) use a "collect" transform and provide "sort" parameter. This ensures that sorting occurs immediately at the point at which it is requested, not at an indeterminate point down stream in the dataflow. We recommend using option (1) if workable, and (2) otherwise.\nThe "stack" transform "sortby" parameter has been renamed "sort".\nCartographic projections are now defined in their own top-level block, similar to scales. Named projections are defined within an array under the projections property. Inline projection definitions for geo transforms are no longer allowed. Instead, geo transforms include a "projection" parameter which takes the name of a defined projection.\nCartographic projections are now defined in their own top-level block, similar to scales. Named projections are defined within an array under the projections property. Inline projection definitions for geo transforms are no longer allowed. Instead, geo transforms include a "projection" parameter which takes the name of a defined projection.\nThe "geo" transform has been renamed "geopoint".\nThe "geo" transform has been renamed "geopoint".\nA "graticule" transform has been added to generate reference lines for projections. To add graticules for a map, create a new “empty” data set definition (with no "url" or "source" properties), and include a "graticule" transform as the first entry in the data "transforms" array.\nA "graticule" transform has been added to generate reference lines for projections. To add graticules for a map, create a new “empty” data set definition (with no "url" or "source" properties), and include a "graticule" transform as the first entry in the data "transforms" array.\nIn addition to the "geopath" transform, a "geoshape" transform has been added, which generates data for use with the new shape mark type. This mark type delays shape calculations until render time. Under canvas rendering, this can result in much faster draw times, as the projected geo-data does not need to be marshalled into an SVG path string.\nIn addition to the "geopath" transform, a "geoshape" transform has been added, which generates data for use with the new shape mark type. This mark type delays shape calculations until render time. Under canvas rendering, this can result in much faster draw times, as the projected geo-data does not need to be marshalled into an SVG path string.\nAnimated transitions are not currently supported by Vega 3.0 and later. As a result, the "delay" and "ease" properties are no longer used.\nThe Vega View API has been updated and streamlined. To create a Vega visualization, the Vega spec must first be parsed, the resulting runtime specification can then be passed as an argument to the View constructor. Unlike Vega 2.x, this process does not require asynchronous callbacks. For example:

    var runtime = vega.parse(spec); // may throw an Error if parsing fails
var view = new vega.View(runtime)
  .logLevel(vega.Warn) // set view logging level
  .initialize(document.querySelector('#view')) // set parent DOM element
  .renderer('svg') // set render type (defaults to 'canvas')
  .hover() // enable hover event processing
  .run(); // update and render the view\nThe Vega View API has been updated and streamlined. To create a Vega visualization, the Vega spec must first be parsed, the resulting runtime specification can then be passed as an argument to the View constructor. Unlike Vega 2.x, this process does not require asynchronous callbacks. For example:\nvar runtime = vega.parse(spec); // may throw an Error if parsing fails
var view = new vega.View(runtime)
  .logLevel(vega.Warn) // set view logging level
  .initialize(document.querySelector('#view')) // set parent DOM element
  .renderer('svg') // set render type (defaults to 'canvas')
  .hover() // enable hover event processing
  .run(); // update and render the view\nvar runtime = vega.parse(spec); // may throw an Error if parsing fails
var view = new vega.View(runtime)
  .logLevel(vega.Warn) // set view logging level
  .initialize(document.querySelector('#view')) // set parent DOM element
  .renderer('svg') // set render type (defaults to 'canvas')
  .hover() // enable hover event processing
  .run(); // update and render the view\n// may throw an Error if parsing fails\n// set view logging level\n// set parent DOM element\n// set render type (defaults to 'canvas')\n// enable hover event processing\n// update and render the view\nInstead of view.update, the view.run method now invokes dataflow pulse propagation and re-rendering.\nInstead of view.update, the view.run method now invokes dataflow pulse propagation and re-rendering.\nInstead of view.destroy, the view.finalize method should be called to prepare the view to be removed from a web page.\nInstead of view.destroy, the view.finalize method should be called to prepare the view to be removed from a web page.\nThe underlying View API and dataflow system have been extensively overhauled. A Vega View instance is now a direct subclass of a Vega Dataflow, and manages all reactive processing, streaming data input, and rendering. In addition to the View API Reference, comprehensive JSDoc comments are included in the source code of the vega-view and vega-dataflow repositories.\nThe underlying View API and dataflow system have been extensively overhauled. A Vega View instance is now a direct subclass of a Vega Dataflow, and manages all reactive processing, streaming data input, and rendering. In addition to the View API Reference, comprehensive JSDoc comments are included in the source code of the vega-view and vega-dataflow repositories.\n\n\nVega
            
              Vega-Lite
              Altair
              Vega-Lite API
            
          
          
            
              Examples
              Tutorials
              Documentation
              Usage
              About
            
            
              GitHub
              Try Online
            
          
        
      

      
        

  
  
    
      
      
        Documentation
      
      
      
      
        Specification
      
      
      
      
        Config
      
      
      
      
        Data
      
      
      
      
        Transforms
      
      
      
      
        Triggers
      
      
      
      
        Projections
      
      
      
      
        Scales
      
      
      
      
        Schemes
      
      
      
      
        Axes
      
      
      
      
        Legends
      
      
      
      
        Title
      
      
      
      
        Marks
      
      
      
      
        Signals
      
      
      
      
        Event Streams
      
      
      
      
        Expressions
      
      
      
      
        Layout
      
      
      
      
        Types
      
      
    
  
  
    Specification
    A Vega specification defines an interactive visualization in JavaScript Object Notation (JSON).

Below is a basic outline of a Vega specification. Complete specifications include definitions for an appropriate subset of the data, scales, axes, marks, etc. properties.

{
  "$schema": "https://vega.github.io/schema/vega/v5.json",
  "description": "A specification outline example.",
  "width": 500,
  "height": 200,
  "padding": 5,
  "autosize": "pad",

  "signals": [],
  "data": [],
  "scales": [],
  "projections": [],
  "axes": [],
  "legends": [],
  "marks": []
}


Top-Level Specification Properties


  
    
      Property
      Type
      Description
    
  
  
    
      $schema
      URL
      The URL for the Vega schema.
    
    
      description
      String
      A text description of the visualization. In versions ≥ 5.10, the description determines the aria-label attribute for the container element of a Vega view.
    
    
      background
      Color | Signal
      The background color of the entire view (defaults to transparent). If signal-valued ≥ 5.10, the provided expression is used as the update property for the underlying background signal definition.
    
    
      width
      Number | Signal
      The width in pixels of the data rectangle. If signal-valued ≥ 5.10, the provided expression is used as the update property for the underlying width signal definition.
    
    
      height
      Number | Signal
      The height in pixels of the data rectangle. If signal-valued ≥ 5.10, the provided expression is used as the update property for the underlying height signal definition.
    
    
      padding
      Number | Object | Signal
      The padding in pixels to add around the visualization. If a number, specifies padding for all sides. If an object, the value should have the format {"left": 5, "top": 5, "right": 5, "bottom": 5}. Padding is applied after autosize layout completes. If signal-valued ≥ 5.10, the provided expression is used as the update property for the underlying padding signal definition, and should evaluate to either a padding object or number.
    
    
      autosize
      String | Autosize | Signal
      Sets how the visualization size should be determined. If a string, should be one of pad (default), fit, fit-x, fit-y, or none. Object values can additionally specify parameters for content sizing and automatic resizing. See the autosize section below for more. If signal-valued ≥ 5.10, the provided expression is used as the update property for the underlying autosize signal definition, and should evaluate to a complete autosize object.
    
    
      config
      Config
      Configuration settings with default values for marks, axes, and legends.
    
    
      signals
      Signal[ ]
      Signals are dynamic variables that parameterize a visualization.
    
    
      data
      Data[ ]
      Data set definitions and transforms define the data to load and how to process it.
    
    
      scales
      Scale[ ]
      Scales map data values (numbers, dates, categories, etc) to visual values (pixels, colors, sizes).
    
    
      projections
      Projection[ ]
      Cartographic projections map (longitude, latitude) pairs to projected (x, y) coordinates.
    
    
      axes
      Axis[ ]
      Coordinate axes visualize spatial scale mappings.
    
    
      legends
      Legend[ ]
      Legends visualize scale mappings for visual values such as color, shape and size.
    
    
      title
      Title
      Title text to describe a visualization.
    
    
      marks
      Mark[ ]
      Graphical marks visually encode data using geometric primitives such as rectangles, lines, and plotting symbols.
    
    
      encode
      Encode
      Encoding directives for the visual properties of the top-level group mark representing a chart’s data rectangle. For example, this can be used to set a background fill color for the plotting area, rather than the entire view.
    
    
      usermeta
      Object
      Optional metadata  that will be ignored by the Vega parser.
    
  


Autosize

Vega views can be sized (and resized) in various ways.
If an object, the value should have the format {"type": "pad", "resize": true}, where type is one of the autosize strings and resize is a boolean indicating if autosize layout should be re-calculated on every update.


  
    
      Name
      Type
      Description
    
  
  
    
      type
      String
      Required. The sizing format type. One of "pad" (default), "fit", "fit-x", "fit-y", or "none". See the autosize types documentation for descriptions of each.
    
    
      resize
      Boolean
      A boolean flag indicating if autosize layout should be re-calculated on every view update. The default (false) causes layout to be performed once upon initialization and in response to changes in the height and/or width signals (see here for more on sizing logic). Otherwise, the layout is kept stable. To externally force a resize, use the View.resize API method.
    
    
      contains
      String
      Determines how size calculation should be performed, one of content (default) or padding. The default setting (content) interprets the width and height settings as the data rectangle (plotting) dimensions, to which padding is then added. In contrast, the padding setting includes the padding within the view size calculations, such that the width and height settings indicate the total intended size of the view.
    
  


Autosize Types

The total size of a Vega visualization may be determined by multiple factors: specified width, height, and padding values, as well as content such as axes, legends, and titles. The support different use cases, Vega provides three different autosize types for determining the final size of a visualization view:


  none: No automatic sizing is performed. The total visualization size is determined solely by the provided width, height and padding values. For example, by default the total width is calculated as width + padding.left + padding.right. Any content lying outside this region will be clipped. If autosize.contains is set to "padding", the total width is instead simply width.
  pad: Automatically increase the size of the view such that all visualization content is visible. This is the default autosize setting, and ensures that axes, legends and other items outside the normal width and height are included. The total size will often exceed the specified width, height, and padding.
  fit: Automatically adjust the layout in an attempt to force the total visualization size to fit within the given width, height and padding values. This setting causes the plotting region to be made smaller in order to accommodate axes, legends and titles. As a result, the value of the width and height signals may be changed to modify the layout. Though effective for many plots, the fit method can not always ensure that all content remains visible. For example, if the axes and legends alone require more space than the specified width and height, some of the content will be clipped. Similar to none, by default the total width will be width + padding.left + padding.right, relative to the original, unmodified width value. If autosize.contains is set to "padding", the total width will instead be the original width.
  fit-x: Similar to fit, except that only the width (x-axis) is adjusted to fit the given dimensions. The view height is automatically sized as if set to pad. ≥ 3.1
  fit-y: Similar to fit, except that only the height (y-axis) is adjusted to fit the given dimensions. The view width is automatically sized as if set to pad. ≥ 3.1\nVega
            
              Vega-Lite
              Altair
              Vega-Lite API\nVega-Lite
              Altair
              Vega-Lite API\nExamples
              Tutorials
              Documentation
              Usage
              About
            
            
              GitHub
              Try Online\nExamples
              Tutorials
              Documentation
              Usage
              About\nGitHub
              Try Online\nDocumentation
      
      
      
      
        Specification
      
      
      
      
        Config
      
      
      
      
        Data
      
      
      
      
        Transforms
      
      
      
      
        Triggers
      
      
      
      
        Projections
      
      
      
      
        Scales
      
      
      
      
        Schemes
      
      
      
      
        Axes
      
      
      
      
        Legends
      
      
      
      
        Title
      
      
      
      
        Marks
      
      
      
      
        Signals
      
      
      
      
        Event Streams
      
      
      
      
        Expressions
      
      
      
      
        Layout
      
      
      
      
        Types
      
      
    
  
  
    Specification
    A Vega specification defines an interactive visualization in JavaScript Object Notation (JSON).

Below is a basic outline of a Vega specification. Complete specifications include definitions for an appropriate subset of the data, scales, axes, marks, etc. properties.

{
  "$schema": "https://vega.github.io/schema/vega/v5.json",
  "description": "A specification outline example.",
  "width": 500,
  "height": 200,
  "padding": 5,
  "autosize": "pad",

  "signals": [],
  "data": [],
  "scales": [],
  "projections": [],
  "axes": [],
  "legends": [],
  "marks": []
}


Top-Level Specification Properties


  
    
      Property
      Type
      Description
    
  
  
    
      $schema
      URL
      The URL for the Vega schema.
    
    
      description
      String
      A text description of the visualization. In versions ≥ 5.10, the description determines the aria-label attribute for the container element of a Vega view.
    
    
      background
      Color | Signal
      The background color of the entire view (defaults to transparent). If signal-valued ≥ 5.10, the provided expression is used as the update property for the underlying background signal definition.
    
    
      width
      Number | Signal
      The width in pixels of the data rectangle. If signal-valued ≥ 5.10, the provided expression is used as the update property for the underlying width signal definition.
    
    
      height
      Number | Signal
      The height in pixels of the data rectangle. If signal-valued ≥ 5.10, the provided expression is used as the update property for the underlying height signal definition.
    
    
      padding
      Number | Object | Signal
      The padding in pixels to add around the visualization. If a number, specifies padding for all sides. If an object, the value should have the format {"left": 5, "top": 5, "right": 5, "bottom": 5}. Padding is applied after autosize layout completes. If signal-valued ≥ 5.10, the provided expression is used as the update property for the underlying padding signal definition, and should evaluate to either a padding object or number.
    
    
      autosize
      String | Autosize | Signal
      Sets how the visualization size should be determined. If a string, should be one of pad (default), fit, fit-x, fit-y, or none. Object values can additionally specify parameters for content sizing and automatic resizing. See the autosize section below for more. If signal-valued ≥ 5.10, the provided expression is used as the update property for the underlying autosize signal definition, and should evaluate to a complete autosize object.
    
    
      config
      Config
      Configuration settings with default values for marks, axes, and legends.
    
    
      signals
      Signal[ ]
      Signals are dynamic variables that parameterize a visualization.
    
    
      data
      Data[ ]
      Data set definitions and transforms define the data to load and how to process it.
    
    
      scales
      Scale[ ]
      Scales map data values (numbers, dates, categories, etc) to visual values (pixels, colors, sizes).
    
    
      projections
      Projection[ ]
      Cartographic projections map (longitude, latitude) pairs to projected (x, y) coordinates.
    
    
      axes
      Axis[ ]
      Coordinate axes visualize spatial scale mappings.
    
    
      legends
      Legend[ ]
      Legends visualize scale mappings for visual values such as color, shape and size.
    
    
      title
      Title
      Title text to describe a visualization.
    
    
      marks
      Mark[ ]
      Graphical marks visually encode data using geometric primitives such as rectangles, lines, and plotting symbols.
    
    
      encode
      Encode
      Encoding directives for the visual properties of the top-level group mark representing a chart’s data rectangle. For example, this can be used to set a background fill color for the plotting area, rather than the entire view.
    
    
      usermeta
      Object
      Optional metadata  that will be ignored by the Vega parser.
    
  


Autosize

Vega views can be sized (and resized) in various ways.
If an object, the value should have the format {"type": "pad", "resize": true}, where type is one of the autosize strings and resize is a boolean indicating if autosize layout should be re-calculated on every update.


  
    
      Name
      Type
      Description
    
  
  
    
      type
      String
      Required. The sizing format type. One of "pad" (default), "fit", "fit-x", "fit-y", or "none". See the autosize types documentation for descriptions of each.
    
    
      resize
      Boolean
      A boolean flag indicating if autosize layout should be re-calculated on every view update. The default (false) causes layout to be performed once upon initialization and in response to changes in the height and/or width signals (see here for more on sizing logic). Otherwise, the layout is kept stable. To externally force a resize, use the View.resize API method.
    
    
      contains
      String
      Determines how size calculation should be performed, one of content (default) or padding. The default setting (content) interprets the width and height settings as the data rectangle (plotting) dimensions, to which padding is then added. In contrast, the padding setting includes the padding within the view size calculations, such that the width and height settings indicate the total intended size of the view.
    
  


Autosize Types

The total size of a Vega visualization may be determined by multiple factors: specified width, height, and padding values, as well as content such as axes, legends, and titles. The support different use cases, Vega provides three different autosize types for determining the final size of a visualization view:


  none: No automatic sizing is performed. The total visualization size is determined solely by the provided width, height and padding values. For example, by default the total width is calculated as width + padding.left + padding.right. Any content lying outside this region will be clipped. If autosize.contains is set to "padding", the total width is instead simply width.
  pad: Automatically increase the size of the view such that all visualization content is visible. This is the default autosize setting, and ensures that axes, legends and other items outside the normal width and height are included. The total size will often exceed the specified width, height, and padding.
  fit: Automatically adjust the layout in an attempt to force the total visualization size to fit within the given width, height and padding values. This setting causes the plotting region to be made smaller in order to accommodate axes, legends and titles. As a result, the value of the width and height signals may be changed to modify the layout. Though effective for many plots, the fit method can not always ensure that all content remains visible. For example, if the axes and legends alone require more space than the specified width and height, some of the content will be clipped. Similar to none, by default the total width will be width + padding.left + padding.right, relative to the original, unmodified width value. If autosize.contains is set to "padding", the total width will instead be the original width.
  fit-x: Similar to fit, except that only the width (x-axis) is adjusted to fit the given dimensions. The view height is automatically sized as if set to pad. ≥ 3.1
  fit-y: Similar to fit, except that only the height (y-axis) is adjusted to fit the given dimensions. The view width is automatically sized as if set to pad. ≥ 3.1\nA Vega specification defines an interactive visualization in JavaScript Object Notation (JSON).\nJavaScript Object Notation (JSON)\nBelow is a basic outline of a Vega specification. Complete specifications include definitions for an appropriate subset of the data, scales, axes, marks, etc. properties.\n{
  "$schema": "https://vega.github.io/schema/vega/v5.json",
  "description": "A specification outline example.",
  "width": 500,
  "height": 200,
  "padding": 5,
  "autosize": "pad",

  "signals": [],
  "data": [],
  "scales": [],
  "projections": [],
  "axes": [],
  "legends": [],
  "marks": []
}\n{
  "$schema": "https://vega.github.io/schema/vega/v5.json",
  "description": "A specification outline example.",
  "width": 500,
  "height": 200,
  "padding": 5,
  "autosize": "pad",

  "signals": [],
  "data": [],
  "scales": [],
  "projections": [],
  "axes": [],
  "legends": [],
  "marks": []
}\n"https://vega.github.io/schema/vega/v5.json"\n"A specification outline example."\nTop-Level Specification Properties\nThe URL for the Vega schema.\nA text description of the visualization. In versions ≥ 5.10, the description determines the aria-label attribute for the container element of a Vega view.\nThe background color of the entire view (defaults to transparent). If signal-valued ≥ 5.10, the provided expression is used as the update property for the underlying background signal definition.\nThe width in pixels of the data rectangle. If signal-valued ≥ 5.10, the provided expression is used as the update property for the underlying width signal definition.\nThe height in pixels of the data rectangle. If signal-valued ≥ 5.10, the provided expression is used as the update property for the underlying height signal definition.\nNumber | Object | Signal\nThe padding in pixels to add around the visualization. If a number, specifies padding for all sides. If an object, the value should have the format {"left": 5, "top": 5, "right": 5, "bottom": 5}. Padding is applied after autosize layout completes. If signal-valued ≥ 5.10, the provided expression is used as the update property for the underlying padding signal definition, and should evaluate to either a padding object or number.\nString | Autosize | Signal\nSets how the visualization size should be determined. If a string, should be one of pad (default), fit, fit-x, fit-y, or none. Object values can additionally specify parameters for content sizing and automatic resizing. See the autosize section below for more. If signal-valued ≥ 5.10, the provided expression is used as the update property for the underlying autosize signal definition, and should evaluate to a complete autosize object.\nConfiguration settings with default values for marks, axes, and legends.\nSignals are dynamic variables that parameterize a visualization.\nData set definitions and transforms define the data to load and how to process it.\nScales map data values (numbers, dates, categories, etc) to visual values (pixels, colors, sizes).\nCartographic projections map (longitude, latitude) pairs to projected (x, y) coordinates.\nCoordinate axes visualize spatial scale mappings.\nLegends visualize scale mappings for visual values such as color, shape and size.\nTitle text to describe a visualization.\nGraphical marks visually encode data using geometric primitives such as rectangles, lines, and plotting symbols.\nEncoding directives for the visual properties of the top-level group mark representing a chart’s data rectangle. For example, this can be used to set a background fill color for the plotting area, rather than the entire view.\nOptional metadata  that will be ignored by the Vega parser.\nVega views can be sized (and resized) in various ways.
If an object, the value should have the format {"type": "pad", "resize": true}, where type is one of the autosize strings and resize is a boolean indicating if autosize layout should be re-calculated on every update.\nRequired. The sizing format type. One of "pad" (default), "fit", "fit-x", "fit-y", or "none". See the autosize types documentation for descriptions of each.\nA boolean flag indicating if autosize layout should be re-calculated on every view update. The default (false) causes layout to be performed once upon initialization and in response to changes in the height and/or width signals (see here for more on sizing logic). Otherwise, the layout is kept stable. To externally force a resize, use the View.resize API method.\nDetermines how size calculation should be performed, one of content (default) or padding. The default setting (content) interprets the width and height settings as the data rectangle (plotting) dimensions, to which padding is then added. In contrast, the padding setting includes the padding within the view size calculations, such that the width and height settings indicate the total intended size of the view.\nThe total size of a Vega visualization may be determined by multiple factors: specified width, height, and padding values, as well as content such as axes, legends, and titles. The support different use cases, Vega provides three different autosize types for determining the final size of a visualization view:\nnone: No automatic sizing is performed. The total visualization size is determined solely by the provided width, height and padding values. For example, by default the total width is calculated as width + padding.left + padding.right. Any content lying outside this region will be clipped. If autosize.contains is set to "padding", the total width is instead simply width.\npad: Automatically increase the size of the view such that all visualization content is visible. This is the default autosize setting, and ensures that axes, legends and other items outside the normal width and height are included. The total size will often exceed the specified width, height, and padding.\nfit: Automatically adjust the layout in an attempt to force the total visualization size to fit within the given width, height and padding values. This setting causes the plotting region to be made smaller in order to accommodate axes, legends and titles. As a result, the value of the width and height signals may be changed to modify the layout. Though effective for many plots, the fit method can not always ensure that all content remains visible. For example, if the axes and legends alone require more space than the specified width and height, some of the content will be clipped. Similar to none, by default the total width will be width + padding.left + padding.right, relative to the original, unmodified width value. If autosize.contains is set to "padding", the total width will instead be the original width.\nfit-x: Similar to fit, except that only the width (x-axis) is adjusted to fit the given dimensions. The view height is automatically sized as if set to pad. ≥ 3.1\nfit-y: Similar to fit, except that only the height (y-axis) is adjusted to fit the given dimensions. The view width is automatically sized as if set to pad. ≥ 3.1\n\n\nVega
            
              Vega-Lite
              Altair
              Vega-Lite API
            
          
          
            
              Examples
              Tutorials
              Documentation
              Usage
              About
            
            
              GitHub
              Try Online
            
          
        
      

      
        

  
  
    
      
      
        Documentation
      
      
      
      
        Specification
      
      
      
      
        Config
      
      
      
      
        Data
      
      
      
      
        Transforms
      
      
      
      
        Triggers
      
      
      
      
        Projections
      
      
      
      
        Scales
      
      
      
      
        Schemes
      
      
      
      
        Axes
      
      
      
      
        Legends
      
      
      
      
        Title
      
      
      
      
        Marks
      
      
      
      
        Signals
      
      
      
      
        Event Streams
      
      
      
      
        Expressions
      
      
      
      
        Layout
      
      
      
      
        Types
      
      
    
  
  
    Data
    Data set definitions and transforms define the data to load and how to process it.

The basic data model used by Vega is tabular data, similar to a spreadsheet or database table. Individual data sets are assumed to contain a collection of records (or “rows”), which may contain any number of named data attributes (fields, or “columns”). Records are modeled using standard JavaScript objects.

If the input data is simply an array of primitive values, Vega maps each value to the data property of a new object. For example [5, 3, 8, 1] is loaded as:

[ {"data": 5}, {"data": 3}, {"data": 8}, {"data": 1} ]


Upon ingest, Vega also assigns each data object a unique id property, accessible via a custom Symbol. As a result, the id property is not accessible via a string key and is not enumerable, though you can observe the id value when inspecting data objects in a JavaScript console.

Data sets can be specified directly by defining data inline or providing a URL from which to load the data. Alternatively, data can be bound dynamically at runtime by using the View API to provide data when a chart is instantiated or issue streaming updates. Loading data from a URL will be subject to the policies of your runtime environment (e.g., cross-origin request rules).

Documentation Overview


  Data Properties
  Data Formats
  Examples


Data Properties

Properties for specifying a data set. At most one of the source, url, or values properties should be defined.


  
    
      Property
      Type
      Description
    
  
  
    
      name
      String
      Required. A unique name for the data set.
    
    
      format
      Format
      An object that specifies the format for parsing the data file or values. See the format reference for more.
    
    
      source
      String | String[ ]
      The name of one or more data sets to use as the source for this data set. The source property is useful in combination with a transform pipeline to derive new data. If string-valued, indicates the name of the source data set. If array-valued, specifies a collection of data source names that should be merged (unioned) together.
    
    
      url
      String
      A URL from which to load the data set. Use the format property to ensure the loaded data is correctly parsed. If the format property is not specified, the data is assumed to be in a row-oriented JSON format.
    
    
      values
      Any
      The full data set, included inline. The values property allows data to be included directly within the specification itself. While most commonly an array of objects, other data types (such as CSV strings) may be used, subject to the format settings.
    
    
      async
      Boolean
      ≥ 5.9 A boolean flag (default false) indicating if dynamic data loading or reformatting should occur asynchronously. If true, dataflow evaluation will complete, data loading will occur in the background, and the dataflow will be re-evaluated when loading is complete. If false, dataflow evaluation will block until loading is complete and then continue within the same evaluation cycle. The use of async can allow multiple dynamic datasets to be loaded simultaneously while still supporting interactivity. However, the use of async can cause datasets to remain empty while the rest of the dataflow is evaluated, potentially affecting downstream computation.
    
    
      on
      Trigger[ ]
      An array of updates to insert, remove, & toggle data values, or clear the data when trigger conditions are met. See the trigger reference for more.
    
    
      transform
      Transform[ ]
      An array of transforms to perform on the input data. The output of the transform pipeline then becomes the value of this data set. See the transform reference for more.
    
  


Dynamic Data Loading

≥ 4.2 For Vega version 4.2 and higher, the data url parameter and (when used with URL-loading) the format parameter may include signal references. This feature allows either the source url or one or more formatting parameters to be dynamically changed at runtime, causing the data to be reloaded. For example, a single spec might load a different dataset based on user input, or the data might be polled at a regular interval in conjunction with a timer event stream.

If no signals are used (the traditional configuration), external data sources are loaded immediately upon view construction and the first dataflow evaluation is delayed until data loading is complete. For dynamic loading, the dataflow must first be evaluated in order to determine the signal values, and then data can be loaded. As a result of this, downstream transforms and encodings may initially be evaluated with empty datasets: be sure any signal expressions behave appropriately with empty data, including downstream concerns such as empty scale domains.

Format

The format object describes the data format and additional parsing instructions.


  
    
      Name
      Type
      Description
    
  
  
    
      type
      String
      The data format type. The currently supported data formats are json (the default), csv (comma-separated values), tsv (tab-separated values), dsv (delimited text files), and topojson.
    
    
      parse
      String | Object
      If set to auto, perform automatic type inference to determine the desired data types. Alternatively, a parsing directive object can be provided for explicit data types. Each property of the object corresponds to a field name, and the value to the desired data type (one of "boolean", "date", "number" or "string"). For example, "parse": {"modified_on": "date"} parses the modified_on field in each input record as a Date value. Specific date formats can be provided (e.g., {"foo": "date:'%m%d%Y'"}), using the d3-time-format syntax. UTC date format parsing is supported similarly (e.g., {"foo": "utc:'%m%d%Y'"}).
    
  


json

Loads a JavaScript Object Notation (JSON) file. Assumes row-oriented data, where each row is an object with named attributes. This is the default file format, and so will be used if no format parameter is provided. If specified, the format parameter should have a type property of "json", and can also accept the following:


  
    
      Name
      Type
      Description
    
  
  
    
      property
      String
      The JSON property containing the desired data. This parameter can be used when the loaded JSON file may have surrounding structure or meta-data. For example "property": "values.features" is equivalent to retrieving json.values.features from the loaded JSON object.
    
    
      copy
      Boolean
      A boolean flag (default false) that indicates if input JSON data should be copied prior to use. This setting may be useful when providing as input pre-parsed JSON data (e.g., not loaded from a URL) that should not be modified.
    
  


csv

Load a comma-separated values (CSV) file.


  
    
      Name
      Type
      Description
    
  
  
    
      header
      String[ ]
      An array of field names to prepend to the data as a header row. A header should only be supplied if the input data does not already include one.
    
  


tsv

Load a tab-separated values (TSV) file.


  
    
      Name
      Type
      Description
    
  
  
    
      header
      String[ ]
      An array of field names to prepend to the data as a header row. A header should only be supplied if the input data does not already include one.
    
  


dsv

Load a delimited text file with a custom delimiter.


  
    
      Name
      Type
      Description
    
  
  
    
      delimiter
      String
      Required. The delimiter between records. The delimiter must be a single character (i.e., a single 16-bit code unit); so, ASCII delimiters are fine, but emoji delimiters are not.
    
    
      header
      String[ ]
      An array of field names to prepend to the data as a header row. A header should only be supplied if the input data does not already include one.
    
  


topojson

Load a JavaScript Object Notation (JSON) file using the TopoJSON format. The input file must contain valid TopoJSON data. The TopoJSON input is then converted into a GeoJSON format for use within Vega. There are two mutually exclusive properties that can be used to specify the conversion process:


  
    
      Name
      Type
      Description
    
  
  
    
      feature
      String
      The name of the TopoJSON object set to convert to a GeoJSON feature collection. For example, in a map of the world, there may be an object set named "countries". Using the feature property, we can extract this set and generate a GeoJSON feature object for each country.
    
    
      mesh
      String
      The name of the TopoJSON object set to convert to a mesh. Similar to the feature option, mesh extracts a named TopoJSON object set. Unlike the feature option, the corresponding geo data is returned as a single, unified mesh instance, not as individual GeoJSON features. Extracting a mesh is useful for more efficiently drawing borders or other geographic elements that you do not need to associate with specific regions such as individual countries, states or counties.
    
    
      filter
      String
      An optional filter to apply to an extracted mesh. If set to "interior", only interior region boundaries are included, filtering out exterior borders. If set to "exterior", only the exterior border is included, filtering out all internal boundaries. If null or unspecified (the default), no filtering is performed. This property applies to mesh extraction only, not feature extraction. ≥ 5.4
    
    
      property
      String
      The JSON property containing the desired data. Similar to type=json, this optional parameter can be used when the loaded TopoJSON data has surrounding structure or meta-data.
    
    
      copy
      Boolean
      A boolean flag (default false) that indicates if input JSON data should be copied prior to use. Similar to type=json, this setting may be useful when providing as input pre-parsed JSON data (e.g., not loaded from a URL) that should not be modified.
    
  


Examples

Here is an example defining data directly in a specification:

{"name": "table", "values": [12, 23, 47, 6, 52, 19]}


One can also load data from an external file (in this case, a JSON file):

{"name": "points", "url": "data/points.json"}


Or, one can simply declare the existence of a data set. The data can then be dynamically provided when the visualization is instantiated. See the View API documentation for more.

{"name": "table"}


Finally, one can draw from an existing data set and apply new data transforms. In this case, we create a new data set ("stats") by computing aggregate statistics for groups drawn from the source "table" data set:

{
  "name": "stats",
  "source": "table",
  "transform": [
    {
      "type": "aggregate",
      "groupby": ["x"],
      "ops": ["average", "sum", "min", "max"],
      "fields": ["y", "y", "y", "y"]
    }
  ]
}\nVega
            
              Vega-Lite
              Altair
              Vega-Lite API\nVega-Lite
              Altair
              Vega-Lite API\nExamples
              Tutorials
              Documentation
              Usage
              About
            
            
              GitHub
              Try Online\nExamples
              Tutorials
              Documentation
              Usage
              About\nGitHub
              Try Online\nDocumentation
      
      
      
      
        Specification
      
      
      
      
        Config
      
      
      
      
        Data
      
      
      
      
        Transforms
      
      
      
      
        Triggers
      
      
      
      
        Projections
      
      
      
      
        Scales
      
      
      
      
        Schemes
      
      
      
      
        Axes
      
      
      
      
        Legends
      
      
      
      
        Title
      
      
      
      
        Marks
      
      
      
      
        Signals
      
      
      
      
        Event Streams
      
      
      
      
        Expressions
      
      
      
      
        Layout
      
      
      
      
        Types
      
      
    
  
  
    Data
    Data set definitions and transforms define the data to load and how to process it.

The basic data model used by Vega is tabular data, similar to a spreadsheet or database table. Individual data sets are assumed to contain a collection of records (or “rows”), which may contain any number of named data attributes (fields, or “columns”). Records are modeled using standard JavaScript objects.

If the input data is simply an array of primitive values, Vega maps each value to the data property of a new object. For example [5, 3, 8, 1] is loaded as:

[ {"data": 5}, {"data": 3}, {"data": 8}, {"data": 1} ]


Upon ingest, Vega also assigns each data object a unique id property, accessible via a custom Symbol. As a result, the id property is not accessible via a string key and is not enumerable, though you can observe the id value when inspecting data objects in a JavaScript console.

Data sets can be specified directly by defining data inline or providing a URL from which to load the data. Alternatively, data can be bound dynamically at runtime by using the View API to provide data when a chart is instantiated or issue streaming updates. Loading data from a URL will be subject to the policies of your runtime environment (e.g., cross-origin request rules).

Documentation Overview


  Data Properties
  Data Formats
  Examples


Data Properties

Properties for specifying a data set. At most one of the source, url, or values properties should be defined.


  
    
      Property
      Type
      Description
    
  
  
    
      name
      String
      Required. A unique name for the data set.
    
    
      format
      Format
      An object that specifies the format for parsing the data file or values. See the format reference for more.
    
    
      source
      String | String[ ]
      The name of one or more data sets to use as the source for this data set. The source property is useful in combination with a transform pipeline to derive new data. If string-valued, indicates the name of the source data set. If array-valued, specifies a collection of data source names that should be merged (unioned) together.
    
    
      url
      String
      A URL from which to load the data set. Use the format property to ensure the loaded data is correctly parsed. If the format property is not specified, the data is assumed to be in a row-oriented JSON format.
    
    
      values
      Any
      The full data set, included inline. The values property allows data to be included directly within the specification itself. While most commonly an array of objects, other data types (such as CSV strings) may be used, subject to the format settings.
    
    
      async
      Boolean
      ≥ 5.9 A boolean flag (default false) indicating if dynamic data loading or reformatting should occur asynchronously. If true, dataflow evaluation will complete, data loading will occur in the background, and the dataflow will be re-evaluated when loading is complete. If false, dataflow evaluation will block until loading is complete and then continue within the same evaluation cycle. The use of async can allow multiple dynamic datasets to be loaded simultaneously while still supporting interactivity. However, the use of async can cause datasets to remain empty while the rest of the dataflow is evaluated, potentially affecting downstream computation.
    
    
      on
      Trigger[ ]
      An array of updates to insert, remove, & toggle data values, or clear the data when trigger conditions are met. See the trigger reference for more.
    
    
      transform
      Transform[ ]
      An array of transforms to perform on the input data. The output of the transform pipeline then becomes the value of this data set. See the transform reference for more.
    
  


Dynamic Data Loading

≥ 4.2 For Vega version 4.2 and higher, the data url parameter and (when used with URL-loading) the format parameter may include signal references. This feature allows either the source url or one or more formatting parameters to be dynamically changed at runtime, causing the data to be reloaded. For example, a single spec might load a different dataset based on user input, or the data might be polled at a regular interval in conjunction with a timer event stream.

If no signals are used (the traditional configuration), external data sources are loaded immediately upon view construction and the first dataflow evaluation is delayed until data loading is complete. For dynamic loading, the dataflow must first be evaluated in order to determine the signal values, and then data can be loaded. As a result of this, downstream transforms and encodings may initially be evaluated with empty datasets: be sure any signal expressions behave appropriately with empty data, including downstream concerns such as empty scale domains.

Format

The format object describes the data format and additional parsing instructions.


  
    
      Name
      Type
      Description
    
  
  
    
      type
      String
      The data format type. The currently supported data formats are json (the default), csv (comma-separated values), tsv (tab-separated values), dsv (delimited text files), and topojson.
    
    
      parse
      String | Object
      If set to auto, perform automatic type inference to determine the desired data types. Alternatively, a parsing directive object can be provided for explicit data types. Each property of the object corresponds to a field name, and the value to the desired data type (one of "boolean", "date", "number" or "string"). For example, "parse": {"modified_on": "date"} parses the modified_on field in each input record as a Date value. Specific date formats can be provided (e.g., {"foo": "date:'%m%d%Y'"}), using the d3-time-format syntax. UTC date format parsing is supported similarly (e.g., {"foo": "utc:'%m%d%Y'"}).
    
  


json

Loads a JavaScript Object Notation (JSON) file. Assumes row-oriented data, where each row is an object with named attributes. This is the default file format, and so will be used if no format parameter is provided. If specified, the format parameter should have a type property of "json", and can also accept the following:


  
    
      Name
      Type
      Description
    
  
  
    
      property
      String
      The JSON property containing the desired data. This parameter can be used when the loaded JSON file may have surrounding structure or meta-data. For example "property": "values.features" is equivalent to retrieving json.values.features from the loaded JSON object.
    
    
      copy
      Boolean
      A boolean flag (default false) that indicates if input JSON data should be copied prior to use. This setting may be useful when providing as input pre-parsed JSON data (e.g., not loaded from a URL) that should not be modified.
    
  


csv

Load a comma-separated values (CSV) file.


  
    
      Name
      Type
      Description
    
  
  
    
      header
      String[ ]
      An array of field names to prepend to the data as a header row. A header should only be supplied if the input data does not already include one.
    
  


tsv

Load a tab-separated values (TSV) file.


  
    
      Name
      Type
      Description
    
  
  
    
      header
      String[ ]
      An array of field names to prepend to the data as a header row. A header should only be supplied if the input data does not already include one.
    
  


dsv

Load a delimited text file with a custom delimiter.


  
    
      Name
      Type
      Description
    
  
  
    
      delimiter
      String
      Required. The delimiter between records. The delimiter must be a single character (i.e., a single 16-bit code unit); so, ASCII delimiters are fine, but emoji delimiters are not.
    
    
      header
      String[ ]
      An array of field names to prepend to the data as a header row. A header should only be supplied if the input data does not already include one.
    
  


topojson

Load a JavaScript Object Notation (JSON) file using the TopoJSON format. The input file must contain valid TopoJSON data. The TopoJSON input is then converted into a GeoJSON format for use within Vega. There are two mutually exclusive properties that can be used to specify the conversion process:


  
    
      Name
      Type
      Description
    
  
  
    
      feature
      String
      The name of the TopoJSON object set to convert to a GeoJSON feature collection. For example, in a map of the world, there may be an object set named "countries". Using the feature property, we can extract this set and generate a GeoJSON feature object for each country.
    
    
      mesh
      String
      The name of the TopoJSON object set to convert to a mesh. Similar to the feature option, mesh extracts a named TopoJSON object set. Unlike the feature option, the corresponding geo data is returned as a single, unified mesh instance, not as individual GeoJSON features. Extracting a mesh is useful for more efficiently drawing borders or other geographic elements that you do not need to associate with specific regions such as individual countries, states or counties.
    
    
      filter
      String
      An optional filter to apply to an extracted mesh. If set to "interior", only interior region boundaries are included, filtering out exterior borders. If set to "exterior", only the exterior border is included, filtering out all internal boundaries. If null or unspecified (the default), no filtering is performed. This property applies to mesh extraction only, not feature extraction. ≥ 5.4
    
    
      property
      String
      The JSON property containing the desired data. Similar to type=json, this optional parameter can be used when the loaded TopoJSON data has surrounding structure or meta-data.
    
    
      copy
      Boolean
      A boolean flag (default false) that indicates if input JSON data should be copied prior to use. Similar to type=json, this setting may be useful when providing as input pre-parsed JSON data (e.g., not loaded from a URL) that should not be modified.
    
  


Examples

Here is an example defining data directly in a specification:

{"name": "table", "values": [12, 23, 47, 6, 52, 19]}


One can also load data from an external file (in this case, a JSON file):

{"name": "points", "url": "data/points.json"}


Or, one can simply declare the existence of a data set. The data can then be dynamically provided when the visualization is instantiated. See the View API documentation for more.

{"name": "table"}


Finally, one can draw from an existing data set and apply new data transforms. In this case, we create a new data set ("stats") by computing aggregate statistics for groups drawn from the source "table" data set:

{
  "name": "stats",
  "source": "table",
  "transform": [
    {
      "type": "aggregate",
      "groupby": ["x"],
      "ops": ["average", "sum", "min", "max"],
      "fields": ["y", "y", "y", "y"]
    }
  ]
}\nData set definitions and transforms define the data to load and how to process it.\nThe basic data model used by Vega is tabular data, similar to a spreadsheet or database table. Individual data sets are assumed to contain a collection of records (or “rows”), which may contain any number of named data attributes (fields, or “columns”). Records are modeled using standard JavaScript objects.\nIf the input data is simply an array of primitive values, Vega maps each value to the data property of a new object. For example [5, 3, 8, 1] is loaded as:\n[ {"data": 5}, {"data": 3}, {"data": 8}, {"data": 1} ]\n[ {"data": 5}, {"data": 3}, {"data": 8}, {"data": 1} ]\nUpon ingest, Vega also assigns each data object a unique id property, accessible via a custom Symbol. As a result, the id property is not accessible via a string key and is not enumerable, though you can observe the id value when inspecting data objects in a JavaScript console.\nData sets can be specified directly by defining data inline or providing a URL from which to load the data. Alternatively, data can be bound dynamically at runtime by using the View API to provide data when a chart is instantiated or issue streaming updates. Loading data from a URL will be subject to the policies of your runtime environment (e.g., cross-origin request rules).\ncross-origin request rules\nDocumentation Overview\nProperties for specifying a data set. At most one of the source, url, or values properties should be defined.\nRequired. A unique name for the data set.\nAn object that specifies the format for parsing the data file or values. See the format reference for more.\nThe name of one or more data sets to use as the source for this data set. The source property is useful in combination with a transform pipeline to derive new data. If string-valued, indicates the name of the source data set. If array-valued, specifies a collection of data source names that should be merged (unioned) together.\nA URL from which to load the data set. Use the format property to ensure the loaded data is correctly parsed. If the format property is not specified, the data is assumed to be in a row-oriented JSON format.\nThe full data set, included inline. The values property allows data to be included directly within the specification itself. While most commonly an array of objects, other data types (such as CSV strings) may be used, subject to the format settings.\n≥ 5.9 A boolean flag (default false) indicating if dynamic data loading or reformatting should occur asynchronously. If true, dataflow evaluation will complete, data loading will occur in the background, and the dataflow will be re-evaluated when loading is complete. If false, dataflow evaluation will block until loading is complete and then continue within the same evaluation cycle. The use of async can allow multiple dynamic datasets to be loaded simultaneously while still supporting interactivity. However, the use of async can cause datasets to remain empty while the rest of the dataflow is evaluated, potentially affecting downstream computation.\nAn array of updates to insert, remove, & toggle data values, or clear the data when trigger conditions are met. See the trigger reference for more.\nAn array of transforms to perform on the input data. The output of the transform pipeline then becomes the value of this data set. See the transform reference for more.\n≥ 4.2 For Vega version 4.2 and higher, the data url parameter and (when used with URL-loading) the format parameter may include signal references. This feature allows either the source url or one or more formatting parameters to be dynamically changed at runtime, causing the data to be reloaded. For example, a single spec might load a different dataset based on user input, or the data might be polled at a regular interval in conjunction with a timer event stream.\nIf no signals are used (the traditional configuration), external data sources are loaded immediately upon view construction and the first dataflow evaluation is delayed until data loading is complete. For dynamic loading, the dataflow must first be evaluated in order to determine the signal values, and then data can be loaded. As a result of this, downstream transforms and encodings may initially be evaluated with empty datasets: be sure any signal expressions behave appropriately with empty data, including downstream concerns such as empty scale domains.\nThe format object describes the data format and additional parsing instructions.\nThe data format type. The currently supported data formats are json (the default), csv (comma-separated values), tsv (tab-separated values), dsv (delimited text files), and topojson.\nIf set to auto, perform automatic type inference to determine the desired data types. Alternatively, a parsing directive object can be provided for explicit data types. Each property of the object corresponds to a field name, and the value to the desired data type (one of "boolean", "date", "number" or "string"). For example, "parse": {"modified_on": "date"} parses the modified_on field in each input record as a Date value. Specific date formats can be provided (e.g., {"foo": "date:'%m%d%Y'"}), using the d3-time-format syntax. UTC date format parsing is supported similarly (e.g., {"foo": "utc:'%m%d%Y'"}).\nd3-time-format syntax\nLoads a JavaScript Object Notation (JSON) file. Assumes row-oriented data, where each row is an object with named attributes. This is the default file format, and so will be used if no format parameter is provided. If specified, the format parameter should have a type property of "json", and can also accept the following:\nThe JSON property containing the desired data. This parameter can be used when the loaded JSON file may have surrounding structure or meta-data. For example "property": "values.features" is equivalent to retrieving json.values.features from the loaded JSON object.\nA boolean flag (default false) that indicates if input JSON data should be copied prior to use. This setting may be useful when providing as input pre-parsed JSON data (e.g., not loaded from a URL) that should not be modified.\nLoad a comma-separated values (CSV) file.\nAn array of field names to prepend to the data as a header row. A header should only be supplied if the input data does not already include one.\nLoad a tab-separated values (TSV) file.\nAn array of field names to prepend to the data as a header row. A header should only be supplied if the input data does not already include one.\nLoad a delimited text file with a custom delimiter.\nRequired. The delimiter between records. The delimiter must be a single character (i.e., a single 16-bit code unit); so, ASCII delimiters are fine, but emoji delimiters are not.\nAn array of field names to prepend to the data as a header row. A header should only be supplied if the input data does not already include one.\nLoad a JavaScript Object Notation (JSON) file using the TopoJSON format. The input file must contain valid TopoJSON data. The TopoJSON input is then converted into a GeoJSON format for use within Vega. There are two mutually exclusive properties that can be used to specify the conversion process:\nThe name of the TopoJSON object set to convert to a GeoJSON feature collection. For example, in a map of the world, there may be an object set named "countries". Using the feature property, we can extract this set and generate a GeoJSON feature object for each country.\nThe name of the TopoJSON object set to convert to a mesh. Similar to the feature option, mesh extracts a named TopoJSON object set. Unlike the feature option, the corresponding geo data is returned as a single, unified mesh instance, not as individual GeoJSON features. Extracting a mesh is useful for more efficiently drawing borders or other geographic elements that you do not need to associate with specific regions such as individual countries, states or counties.\nAn optional filter to apply to an extracted mesh. If set to "interior", only interior region boundaries are included, filtering out exterior borders. If set to "exterior", only the exterior border is included, filtering out all internal boundaries. If null or unspecified (the default), no filtering is performed. This property applies to mesh extraction only, not feature extraction. ≥ 5.4\nThe JSON property containing the desired data. Similar to type=json, this optional parameter can be used when the loaded TopoJSON data has surrounding structure or meta-data.\nA boolean flag (default false) that indicates if input JSON data should be copied prior to use. Similar to type=json, this setting may be useful when providing as input pre-parsed JSON data (e.g., not loaded from a URL) that should not be modified.\nHere is an example defining data directly in a specification:\n{"name": "table", "values": [12, 23, 47, 6, 52, 19]}\n{"name": "table", "values": [12, 23, 47, 6, 52, 19]}\nOne can also load data from an external file (in this case, a JSON file):\n{"name": "points", "url": "data/points.json"}\n{"name": "points", "url": "data/points.json"}\nOr, one can simply declare the existence of a data set. The data can then be dynamically provided when the visualization is instantiated. See the View API documentation for more.\nFinally, one can draw from an existing data set and apply new data transforms. In this case, we create a new data set ("stats") by computing aggregate statistics for groups drawn from the source "table" data set:\n{
  "name": "stats",
  "source": "table",
  "transform": [
    {
      "type": "aggregate",
      "groupby": ["x"],
      "ops": ["average", "sum", "min", "max"],
      "fields": ["y", "y", "y", "y"]
    }
  ]
}\n{
  "name": "stats",
  "source": "table",
  "transform": [
    {
      "type": "aggregate",
      "groupby": ["x"],
      "ops": ["average", "sum", "min", "max"],
      "fields": ["y", "y", "y", "y"]
    }
  ]
}\n\n\nVega
            
              Vega-Lite
              Altair
              Vega-Lite API
            
          
          
            
              Examples
              Tutorials
              Documentation
              Usage
              About
            
            
              GitHub
              Try Online
            
          
        
      

      
        

  
  
    
      
      
        Documentation
      
      
      
      
        Specification
      
      
      
      
        Config
      
      
      
      
        Data
      
      
      
      
        Transforms
      
      
      
      
        Triggers
      
      
      
      
        Projections
      
      
      
      
        Scales
      
      
      
      
        Schemes
      
      
      
      
        Axes
      
      
      
      
        Legends
      
      
      
      
        Title
      
      
      
      
        Marks
      
      
      
      
        Signals
      
      
      
      
        Event Streams
      
      
      
      
        Expressions
      
      
      
      
        Layout
      
      
      
      
        Types
      
      
    
  
  
    Scales
    Scales map data values (numbers, dates, categories, etc.) to visual values (pixels, colors, sizes). Scales are a fundamental building block of data visualization, as they determine the nature of visual encodings. Vega includes a range of scales for both continuous and discrete input data, and supports mappings for position, shape, size and color encodings.

To visualize scales, Vega specifications may include axes or legends. For more about supported color encodings, see the color scheme reference. Internally, Vega uses the scales provided by the d3-scale library; for more background see Introducing d3-scale by Mike Bostock.

Documentation Overview


  Scale Properties
  Scale Types
  Scale Domains
  Scale Ranges


Scale Properties

Properties shared across scale types.


  
    
      Property
      Type
      Description
    
  
  
    
      name
      String
      Required. A unique name for the scale. Scales and projections share the same namespace; names must be unique across both.
    
    
      type
      String
      The type of scale (default linear). See the  scale type reference for more.
    
    
      domain
      Domain
      The domain of input data values for the scale. For quantitative data, this can take the form of a two-element array with minimum and maximum values. For ordinal or categorical data, this may be an array of valid input values. The domain may also be specified as a reference to a data source. See the scale domain reference for more.
    
    
      domainMax
      Number
      Sets the maximum value in the scale domain, overriding the domain property. The domainMax property is only intended for use with scales having continuous domains.
    
    
      domainMin
      Number
      Sets the minimum value in the scale domain, overriding the domain property. The domainMin property is only intended for use with scales having continuous domains.
    
    
      domainMid
      Number
      Inserts a single mid-point value into a two-element domain. The mid-point value must lie between the domain minimum and maximum values. This property can be useful for setting a midpoint for diverging color scales. The domainMid property is only intended for use with scales supporting continuous, piecewise domains.
    
    
      domainRaw
      Array
      An array of raw values that, if non-null, directly overrides the domain property. This is useful for supporting interactions such as panning or zooming a scale. The scale may be initially determined using a data-driven domain, then modified in response to user input by setting the rawDomain value.
    
    
      interpolate
      String | Object
      The interpolation method for range values. By default, continuous scales use a general interpolator for numbers, dates, strings and colors (in RGB space) is used. For color ranges, this property allows interpolation in alternative color spaces. Legal values include rgb, hsl, hsl-long, lab, hcl, hcl-long, cubehelix and cubehelix-long (‘-long’ variants use longer paths in polar coordinate spaces). If object-valued, this property accepts an object with a string-valued type property and an optional numeric gamma property applicable to rgb and cubehelix interpolators. For more, see the d3-interpolate documentation.
    
    
      range
      Range
      The range of the scale, representing the set of visual values. For numeric values, the range typically takes the form of a two-element array with minimum and maximum values. For ordinal or quantized data, the range may be an array of desired output values, which are mapped to elements in the specified domain. See the scale range reference for more.
    
    
      reverse
      Boolean
      A boolean flag (default false) that reverses the order of the scale range.
    
    
      round
      Boolean
      A boolean flag (default false) that rounds numeric output values to integers. Helpful for snapping to a pixel grid.
    
  


Scale Types


  Quantitative Scales
    
      linear
      log
      pow
      sqrt
      symlog
      time
      utc
      sequential
    
  
  Discrete Scales
    
      ordinal
      band
      point
    
  
  Discretizing Scales
    
      quantile
      quantize
      threshold
      bin-ordinal
    
  


Quantitative Scales

A quantitative scale maps a continuous domain (numbers or dates) to a continuous output range (pixel locations, sizes, colors). The available quantitative scale type values are linear, log, pow, sqrt, symlog, time and utc. All quantitative scales except for time and utc use a default domain of [0, 1] and default unit range [0, 1].

All quantitative scales support color-valued ranges, defined either as an array of color strings or as a scheme specification. If the domain includes two color values, a sequential color scale is used. If the domain includes three color values, a diverging color scale is used. For larger domain sizes, the domain and range should have the same number of values, over which piecewise interpolation will be applied.


  
    
      Property
      Type
      Description
    
  
  
    
      bins
      Bins
      ≥ 5.0 Bin boundaries over the scale domain, such as those computed by Vega’s bin transform. If provided, axes and legends will use the bin boundaries to inform the choice of axis tick marks and legend labels. This property can be either an explicit array of bin boundary values or a specification object, see the scale bins reference for more.
    
    
      clamp
      Boolean
      A boolean indicating if output values should be clamped to the range (default false). If clamping is disabled and the scale is passed a value outside the domain, the scale may return a value outside the range through extrapolation. If clamping is enabled, the output value of the scale is always within the scale’s range.
    
    
      padding
      Number
      Expands the scale domain to accommodate the specified number of pixels on each of the scale range. The scale range must represent pixels for this parameter to function as intended. Padding adjustment is performed prior to all other adjustments, including the effects of the zero, nice, domainMin, and domainMax properties.
    
    
      nice
      Boolean | Number | Signal
      Extends the domain so that it starts and ends on nice round values (default false). This method typically modifies the scale’s domain, and may only extend the bounds to the nearest round value. Nicing is useful if the domain is computed from data and may be irregular. For example, for a domain of [0.201479…, 0.996679…], a nice domain might be [0.2, 1.0]. Domain values set via domainMin and domainMax (but not domainRaw) are subject to nicing. Using a number value for this parameter (representing a desired tick count) allows greater control over the step size used to extend the bounds, guaranteeing that the returned ticks will exactly cover the domain.
    
    
      zero
      Boolean
      Boolean flag indicating if the scale domain should include zero. The default value is true for linear, sqrt and pow, and false otherwise.
    
  


Linear Scales

Linear scales (linear) are quantitative scales scales that preserve proportional differences. Each range value y can be expressed as a linear function of the domain value x: y = mx + b.

Logarithmic Scales

Log scales (log) are quantitative scales scales in which a logarithmic transform is applied to the input domain value before the output range value is computed. Log scales are particularly useful for plotting data that varies over multiple orders of magnitude. The mapping to the range value y can be expressed as a logarithmic function of the domain value x: y = m log(x) + b.

As log(0) = -∞, a log scale domain must be strictly-positive or strictly-negative; the domain must not include or cross zero. A log scale with a positive domain has a well-defined behavior for positive values, and a log scale with a negative domain has a well-defined behavior for negative values. (For a negative domain, input and output values are implicitly multiplied by -1.) The behavior of the scale is undefined if you run a negative value through a log scale with a positive domain or vice versa.


  
    
      Property
      Type
      Description
    
  
  
    
      base
      Number
      The base of the logarithm (default 10).
    
  


Power Scales

Power scales (pow) are quantitative scales scales that apply an exponential transform to the input domain value before the output range value is computed. Each range value y can be expressed as a polynomial function of the domain value x: y = mx^k + b, where k is the exponent value. Power scales also support negative domain values, in which case the input value and the resulting output value are multiplied by -1.


  
    
      Property
      Type
      Description
    
  
  
    
      exponent
      Number
      The exponent to use in the scale transform (default 1).
    
  


Square Root Scales

Square root (sqrt) scales are a convenient shorthand for power scales with an exponent of 0.5, indicating a square root transform.

Symmetric Log Scales ≥ 5.0

Symmetric log scales (symlog) are quantitative scales scales that provide scaling similar to log scales, but supports non-positive numbers. Symlog scales are particularly useful for plotting data that varies over multiple orders of magnitude but includes negative- or zero-valued data. For more, see “A bi-symmetric log transformation for wide-range data” by Webber for more.


  
    
      Property
      Type
      Description
    
  
  
    
      constant
      Number
      A constant determining the slope of the symlog function around zero (default 1).
    
  


Time and UTC Scales

Time scales (time and utc) are quantitative scales with a temporal domain: values in the input domain are assumed to be Date objects or timestamps. The time scale type uses the current local timezone setting. UTC scales (utc) instead use Coordinated Universal Time. Both time and utc scales use a default domain of [2000-01-01, 2000-01-02], and a default unit range [0, 1].


  
    
      Property
      Type
      Description
    
  
  
    
      nice
      String | Object | Number | Boolean
      If specified, modifies the scale domain to use a more human-friendly value range. For time and utc scale types, the nice value can additionally be a string indicating the desired time interval. Legal values are "millisecond", "second", "minute", "hour", "day", "week", "month", and "year". Alternatively, time and utc scales can accept an object-valued interval specifier of the form {"interval": "month", "step": 3}, which includes a desired number of interval steps. Here, the domain would snap to quarter (Jan, Apr, Jul, Oct) boundaries.
    
  


Sequential Scales (Deprecated)

Sequential scales (sequential) are similar to linear scales, but use a fixed interpolator to determine the output range. As of Vega 5.0, sequential scales are deprecated: specifications should now use a linear (or log, etc.) scale with a color-valued range, rather than  a sequential scale.


  
    
      Property
      Type
      Description
    
  
  
    
      clamp
      Boolean
      A boolean indicating if output values should be clamped to the range (default false). If clamping is disabled and the scale is passed a value outside the domain, the scale may return a value outside the range through extrapolation. If clamping is enabled, the output value of the scale is always within the scale’s range.
    
    
      domainMax
      Number
      Sets the maximum value in the scale domain, overriding the domain property.
    
    
      domainMin
      Number
      Sets the minimum value in the scale domain, overriding the domain property.
    
    
      domainMid
      Number
      Inserts a single mid-point value into a two-element domain. The mid-point value must lie between the domain minimum and maximum values. This property can be useful for setting a midpoint for diverging color scales.
    
    
      range
      Scheme | Color[ ]
      Required. The range value should either be a color scheme object or an array of color strings. If an array of colors is provided, the array will be used to create a continuous interpolator via linear interpolation in the RGB color space.
    
  


Back to scale type reference

Discrete Scales

Discrete scales map values from a discrete domain to a discrete range. In the case of band and point scales, the range is determined by discretizing a continuous numeric range.

Ordinal Scales

Ordinal scales (ordinal) have a discrete domain and range. For example, an ordinal scale might map a set of named categories to a set of colors, or to a set of shapes. Ordinal scales function as a “lookup table” from a domain value to a range value.

This example uses an ordinal scale for color-coded categories, with up to 20 unique colors:

{
  "scales": [
    {
      "name": "color",
      "type": "ordinal",
      "domain": {"data": "table", "field": "category"},
      "range": {"scheme": "category20"}
    }
  ]
}


Band Scales

Band scales (band) accept a discrete domain similar to ordinal scales, but map this domain to a continuous, numeric output range such as pixels. Discrete output values are automatically computed by the scale by dividing the continuous range into uniform bands. Band scales are typically used for bar charts with an ordinal or categorical dimension.

In addition to a standard numerical range value (such as [0, 500]), band scales can be given a fixed step size for each band. The actual range is then determined by both the step size and the cardinality (element count) of the input domain. The step size is specified by an object with a step property that provides the step size in pixels, for example "range": {"step": 20}.

This image from the d3-scale documentation illustrates how a band scale works:




  
    
      Property
      Type
      Description
    
  
  
    
      align
      Number
      The alignment of elements within the scale range. This value must lie in the range [0,1]. A value of 0.5 (default) indicates that the bands should be centered within the range. A value of 0 or 1 may be used to shift the bands to one side, say to position them adjacent to an axis. For more, see this explainer for D3 band align.
    
    
      domainImplicit
      Boolean
      A boolean flag (default false) indicating if an ordinal domain should be implicitly extended with new values. If false, the scale will return undefined for values not explicitly included in the domain. If true, new values will be appended to the domain and the matching range value will be returned.
    
    
      padding
      Number
      Sets paddingInner and paddingOuter to the same padding value (default 0). This value must lie in the range [0,1].
    
    
      paddingInner
      Number
      The inner padding (spacing) within each band step, as a fraction of the step size (default 0). This value must lie in the range [0,1].
    
    
      paddingOuter
      Number
      The outer padding (spacing) at the ends of the scale range, as a fraction of the step size (default 0). This value must lie in the range [0,1].
    
  


Point Scales

Point scales (point) are a variant of band scales where the internal band width is fixed to zero. Point scales are typically used for scatterplots with an ordinal or categorical dimension. Similar to band scales, point scale range values may be specified using either a numerical extent ([0, 500]) or a step size ({"step": 20}). As point scales do not have internal band widths (only step sizes between bands), they do not accept the paddingInner property.

This image from the d3-scale documentation illustrates how a point scale works:




  
    
      Property
      Type
      Description
    
  
  
    
      align
      Number
      The alignment of elements within the scale range. This value must lie in the range [0,1]. A value of 0.5 (default) indicates that the points should be centered within the range. A value of 0 or 1 may be used to shift the points to one side, say to position them adjacent to an axis.
    
    
      padding
      Number
      An alias for paddingOuter (default 0). This value must lie in the range [0,1].
    
    
      paddingOuter
      Number
      The outer padding (spacing) at the ends of the scale range, as a fraction of the step size (default 0). This value must lie in the range [0,1].
    
  


Back to scale type reference

Discretizing Scales

Discretizing scales break up a continuous domain into discrete segments, and then map values in each segment to a range value.

Quantile Scales

Quantile scales (quantile) map a sample of input domain values to a discrete range based on computed quantile boundaries. The domain is considered continuous and thus the scale will accept any reasonable input value; however, the domain is specified as a discrete set of sample values. The number of values in (i.e., the cardinality of) the output range determines the number of quantiles that will be computed from the domain. To compute the quantiles, the domain is sorted, and treated as a population of discrete values. The resulting quantile boundaries segment the domain into groups with roughly equal numbers of sample points per group.

Quantile scales are particularly useful for creating color or size encodings with a fixed number of output values. Using a discrete set of encoding levels (typically between 5-9 colors or sizes) sometimes supports more accurate perceptual comparison than a continuous range. For related functionality see quantize scales, which partition the domain into uniform domain extents, rather than groups with equal element counts. Quantile scales have the benefit of evenly distributing data points to encoded values. In contrast, quantize scales uniformly segment the input domain and provide no guarantee on how data points will be distributed among the output visual values.

This example color-codes quantile values in five groups, using colors sampled from a continuous color scheme:

{
  "name": "color",
  "scale": "quantile",
  "domain": {"data": "table", "field": "value"},
  "range": {"scheme": "plasma", "count": 5}
}


Quantize Scales

Quantize scales (quantize) are similar to linear scales, except they use a discrete rather than continuous range. The continuous input domain is divided into uniform segments based on the number of values in (i.e., the cardinality of) the output range. Each range value y can be expressed as a quantized linear function of the domain value x: y = m round(x) + b.

Quantize scales are particularly useful for creating color or size encodings with a fixed number of output values. Using a discrete set of encoding levels (typically between 5-9 colors or sizes) sometimes supports more accurate perceptual comparison than a continuous range. For related functionality see quantile scales, which partition the domain into groups with equal element counts, rather than uniform domain extents.


  
    
      Property
      Type
      Description
    
  
  
    
      nice
      Boolean | Number
      Extends the domain so that it starts and ends on nice round values (default false). This method typically modifies the scale’s domain, and may only extend the bounds to the nearest round value. Nicing is useful if the domain is computed from data and may be irregular. For example, for a domain of [0.201479…, 0.996679…], a nice domain might be [0.2, 1.0]. Domain values set via domainMin and domainMax (but not domainRaw) are subject to nicing. Using a number value for this parameter (representing a desired tick count) allows greater control over the step size used to extend the bounds, guaranteeing that the returned ticks will exactly cover the domain.
    
    
      zero
      Boolean
      Boolean flag indicating if the scale domain should include zero (default false).
    
  


This example color-codes a quantized domain using a 7-point color scheme:

{
  "name": "color",
  "scale": "quantize",
  "domain": {"data": "table", "field": "value"},
  "range": {"scheme": "blues", "count": 7}
}


Threshold Scales

Threshold scales (threshold) are similar to quantize scales, except they allow mapping of arbitrary subsets of the domain (not uniform segments) to discrete values in the range. The input domain is still continuous, and divided into slices based on a set of threshold values provided to the domain property. The range property must have N+1 elements, where N is the number of threshold boundaries provided in the domain.

Given the following scale definition,

{
  "name": "threshold",
  "type": "threshold",
  "domain": [0, 1],
  "range": ["red", "white", "blue"]
}


the scale will map domain values to color strings as follows:

-1   => "red"
0    => "white"
0.5  => "white"
1.0  => "blue"
1000 => "blue"


Bin-Ordinal Scales

Binned ordinal scales (bin-ordinal) are a special type of ordinal scale for use with data that has been subdivided into bins (for example, using Vega’s bin transform). The main benefit of using bin-ordinal scales is that they provide “bin-aware” routines for sampling values and generating labels for inclusion in legends. They are particularly useful for creating binned color encodings.

The domain values for a binned ordinal scale must be the set of all bin boundaries, from the minimum bin start to maximum bin end. Input domain values are discretized to the appropriate bin, which is then treated as a standard ordinal scale input. However, as the domain property only accepts an array of values, the bin-ordinal scale provides a bins property that also accepts a bin specification and can be used instead of an explicit domain property.


  
    
      Property
      Type
      Description
    
  
  
    
      bins
      Bins
      ≥ 5.0 Bin boundaries over the scale domain, such as those computed by Vega’s bin transform. This property can be either an explicit array of bin boundary values or a specification object, see the scale bins reference for more. If the domain property is not defined, bins will be used to determine the scale domain.
    
  


Here is an example of a bin-ordinal scale defined in conjunction with a bin transform:

{
  "data": [
    {
      "name": "input",
      "transform": [
        { "type": "extent", "field": "value", "signal": "extent" },
        { "type": "bin", "extent": {"signal": "extent"}, "signal": "bins" }
      ]
    }
  ],
  "scales": [
    {
      "name": "color",
      "type": "bin-ordinal",
      "bins": {"signal": "bins"},
      "range": {"scheme": "greens"}
    }
  ]
}


Back to scale type reference

Scale Bins

Bin boundaries can be provided to scales as either an explicit array of bin boundaries or as a bin specification object. The legal values are:


  A signal reference that resolves to either an array or bin specification object.
  An array literal of bin boundary values. For example, [0, 5, 10, 15, 20]. The array must include both starting and ending boundaries. The previous example uses five values to indicate a total of four bin intervals: [0-5), [5-10), [10-15), [15-20]. Array literals may include signal references as elements.
  A bin specification object that indicates the bin step size, and optionally the start and stop boundaries. The output value of a bin transform is a valid bin specification object.



  
    
      Property
      Type
      Description
    
  
  
    
      start
      Number
      The starting (lowest-valued) bin boundary. If not defined, the lowest value of the scale domain will be used.
    
    
      stop
      Number
      The stopping (highest-valued) bin boundary. If not defined, the highest value of the scale domain will be used.
    
    
      step
      Number
      Required. The step size defining the bin interval width.
    
  


Scale Domains

Scale domains can be specified in multiple ways:


  As an array literal of domain values. For example, [0, 500] or ['a', 'b', 'c']. Array literals may include signal references as elements.
  A signal reference that resolves to a domain value array. For example, {"signal": "myDomain"}.
  A data reference object that specifies field values in one or more data sets.


Basic Data Reference

A basic data reference indicates a data set, field name, and optional sorting for discrete scales:


  
    
      Property
      Type
      Description
    
  
  
    
      data
      String
      Required. The name of the data set containing domain values.
    
    
      field
      Field
      Required. The name of the data field (e.g., "price").
    
    
      sort
      Boolean | Sort
      If a boolean true value, sort the domain values in ascending order. If object-valued, sort the domain according to the provided sort parameters. Sorting is only supported for discrete scale types.
    
  


For example, "domain": {"data": "table", "field": "value"}, derives a scale domain from the value field of data objects in the table data set. If the scale type is quantitative or a quantize, the derived domain will be a two-element [min, max] array. If the scale type is discrete, the derived domain will be an array of all distinct values. If the scale type is quantile, all values will be used to compute quantile boundaries.

Multi-Field Data References

Scale domains can also be derived using values from multiple fields. Multiple fields from the same data set can be specified by replacing the field property with a fields property that takes an array of field names:


  
    
      Property
      Type
      Description
    
  
  
    
      data
      String
      Required. The name of the data set containing domain values.
    
    
      fields
      Field[ ]
      Required. The names of the data field (e.g., ["price", "cost"]).
    
    
      sort
      Boolean | Sort
      If a boolean true value, sort the domain values in ascending order. If object-valued, sort the domain according to the provided sort parameters. Sorting is only supported for discrete scale types.
    
  


More generally, scale domains may also use values pulled from different data sets. In this case, the domain object should have a fields property, which is an array of basic data references:


  
    
      Property
      Type
      Description
    
  
  
    
      fields
      DataRef[ ]
      Required. An array of basic data references indicating each data set and field value to include in the domain. In addition, array literals (e.g., [0, 100], ["a", "b", "c"]) may be included as elements of the fields array for inclusion in the domain determination.
    
    
      sort
      Boolean | Sort
      If a boolean true value, sort the domain values in ascending order. If object-valued, sort the domain according to the provided sort parameters. Sorting is only supported for discrete scale types.
    
  


Here is an example that constructs a domain using the fields price and cost drawn from two different data sets:

"domain": {
  "fields": [
    {"data": "table1", "field": "price"},
    {"data": "table2", "field": "cost"}
   ]
}


Sorting Domains

The sort property of a domain data reference can accept, in addition to a simple boolean, an object-valued sort definition:


  
    
      Property
      Type
      Description
    
  
  
    
      field
      Field
      The data field to sort by. If unspecified, defaults to the field specified in the outer data reference.
    
    
      op
      String
      An aggregate operation to perform on the field prior to sorting. Examples include count, mean and median. This property is required in cases where the sort field and the data reference field do not match. The input data objects will be aggregated, grouped by data reference field values. For a full list of operations, see the aggregate transform, and also see below for limitations with multi-field domains.
    
    
      order
      String
      The sort order. One of ascending (default) or descending.
    
  


This example sorts distinct category field values in descending order by the associated median of the value field:

{
  "domain": {
    "data": "table",
    "field": "category",
    "sort": {"op": "median", "field": "value", "order": "descending"}
  }
}


This example sorts a multi-field domain in descending order based on the counts of each of the domain values:

{
  "domain": {
    "data": "table",
    "fields": ["category1", "category2"],
    "sort": {"op": "count", "order": "descending"}
  }
}


Note: For multi-field domains, the sort field values may not be undefined across all input data sets, and will exhibit duplicate values when drawing multiple domain values from the same data set. To avoid inaccurate sorting, the only allowed sort op values for multi-domain scales are count, min, and max. Support for min and max is available in versions ≥ 5.5.

Scale Ranges

Scale ranges can be specified in multiple ways:


  As an array literal of range values. For example, [0, 500] or ['a', 'b', 'c']. Array literals may include signal references as elements.
  A signal reference that resolves to a range value array. For example, {"signal": "myRange"}.
  A color scheme reference for a color palette. For example, {"scheme": "blueorange"}.
  For ordinal scales only, a data reference for a set of distinct field values. For example, {"data": "table", "field": "value"}.
  For band and point scales only, a step size for each range band. For example, {"step": 20}.
  A string indicating a pre-defined scale range default. For example, "width", "symbol", or "diverging".


Scale Range Defaults

Scale ranges can also accept string literals that map to default values. Default values can be modified, and new named defaults can be added, by using custom config settings.


  
    
      Value
      Description
    
  
  
    
      "width"
      A spatial range determined by the value of the width signal.
    
    
      "height"
      A spatial range determined by the value of the height signal. The direction of the range (top-to-bottom or bottom-to-top) is automatically determined according to the scale type.
    
    
      "symbol"
      The default plotting symbol set to use for shape encodings.
    
    
      "category"
      The default categorical color scheme to use for nominal data.
    
    
      "diverging"
      The default diverging color scheme to use for quantitative data.
    
    
      "ordinal"
      The default sequential color scheme to use for ordinal data.
    
    
      "ramp"
      The default sequential color scheme to use for quantitative data.
    
    
      "heatmap"
      The default sequential color scheme to use for quantitative heatmaps.\nVega
            
              Vega-Lite
              Altair
              Vega-Lite API\nVega-Lite
              Altair
              Vega-Lite API\nExamples
              Tutorials
              Documentation
              Usage
              About
            
            
              GitHub
              Try Online\nExamples
              Tutorials
              Documentation
              Usage
              About\nGitHub
              Try Online\nDocumentation
      
      
      
      
        Specification
      
      
      
      
        Config
      
      
      
      
        Data
      
      
      
      
        Transforms
      
      
      
      
        Triggers
      
      
      
      
        Projections
      
      
      
      
        Scales
      
      
      
      
        Schemes
      
      
      
      
        Axes
      
      
      
      
        Legends
      
      
      
      
        Title
      
      
      
      
        Marks
      
      
      
      
        Signals
      
      
      
      
        Event Streams
      
      
      
      
        Expressions
      
      
      
      
        Layout
      
      
      
      
        Types
      
      
    
  
  
    Scales
    Scales map data values (numbers, dates, categories, etc.) to visual values (pixels, colors, sizes). Scales are a fundamental building block of data visualization, as they determine the nature of visual encodings. Vega includes a range of scales for both continuous and discrete input data, and supports mappings for position, shape, size and color encodings.

To visualize scales, Vega specifications may include axes or legends. For more about supported color encodings, see the color scheme reference. Internally, Vega uses the scales provided by the d3-scale library; for more background see Introducing d3-scale by Mike Bostock.

Documentation Overview


  Scale Properties
  Scale Types
  Scale Domains
  Scale Ranges


Scale Properties

Properties shared across scale types.


  
    
      Property
      Type
      Description
    
  
  
    
      name
      String
      Required. A unique name for the scale. Scales and projections share the same namespace; names must be unique across both.
    
    
      type
      String
      The type of scale (default linear). See the  scale type reference for more.
    
    
      domain
      Domain
      The domain of input data values for the scale. For quantitative data, this can take the form of a two-element array with minimum and maximum values. For ordinal or categorical data, this may be an array of valid input values. The domain may also be specified as a reference to a data source. See the scale domain reference for more.
    
    
      domainMax
      Number
      Sets the maximum value in the scale domain, overriding the domain property. The domainMax property is only intended for use with scales having continuous domains.
    
    
      domainMin
      Number
      Sets the minimum value in the scale domain, overriding the domain property. The domainMin property is only intended for use with scales having continuous domains.
    
    
      domainMid
      Number
      Inserts a single mid-point value into a two-element domain. The mid-point value must lie between the domain minimum and maximum values. This property can be useful for setting a midpoint for diverging color scales. The domainMid property is only intended for use with scales supporting continuous, piecewise domains.
    
    
      domainRaw
      Array
      An array of raw values that, if non-null, directly overrides the domain property. This is useful for supporting interactions such as panning or zooming a scale. The scale may be initially determined using a data-driven domain, then modified in response to user input by setting the rawDomain value.
    
    
      interpolate
      String | Object
      The interpolation method for range values. By default, continuous scales use a general interpolator for numbers, dates, strings and colors (in RGB space) is used. For color ranges, this property allows interpolation in alternative color spaces. Legal values include rgb, hsl, hsl-long, lab, hcl, hcl-long, cubehelix and cubehelix-long (‘-long’ variants use longer paths in polar coordinate spaces). If object-valued, this property accepts an object with a string-valued type property and an optional numeric gamma property applicable to rgb and cubehelix interpolators. For more, see the d3-interpolate documentation.
    
    
      range
      Range
      The range of the scale, representing the set of visual values. For numeric values, the range typically takes the form of a two-element array with minimum and maximum values. For ordinal or quantized data, the range may be an array of desired output values, which are mapped to elements in the specified domain. See the scale range reference for more.
    
    
      reverse
      Boolean
      A boolean flag (default false) that reverses the order of the scale range.
    
    
      round
      Boolean
      A boolean flag (default false) that rounds numeric output values to integers. Helpful for snapping to a pixel grid.
    
  


Scale Types


  Quantitative Scales
    
      linear
      log
      pow
      sqrt
      symlog
      time
      utc
      sequential
    
  
  Discrete Scales
    
      ordinal
      band
      point
    
  
  Discretizing Scales
    
      quantile
      quantize
      threshold
      bin-ordinal
    
  


Quantitative Scales

A quantitative scale maps a continuous domain (numbers or dates) to a continuous output range (pixel locations, sizes, colors). The available quantitative scale type values are linear, log, pow, sqrt, symlog, time and utc. All quantitative scales except for time and utc use a default domain of [0, 1] and default unit range [0, 1].

All quantitative scales support color-valued ranges, defined either as an array of color strings or as a scheme specification. If the domain includes two color values, a sequential color scale is used. If the domain includes three color values, a diverging color scale is used. For larger domain sizes, the domain and range should have the same number of values, over which piecewise interpolation will be applied.


  
    
      Property
      Type
      Description
    
  
  
    
      bins
      Bins
      ≥ 5.0 Bin boundaries over the scale domain, such as those computed by Vega’s bin transform. If provided, axes and legends will use the bin boundaries to inform the choice of axis tick marks and legend labels. This property can be either an explicit array of bin boundary values or a specification object, see the scale bins reference for more.
    
    
      clamp
      Boolean
      A boolean indicating if output values should be clamped to the range (default false). If clamping is disabled and the scale is passed a value outside the domain, the scale may return a value outside the range through extrapolation. If clamping is enabled, the output value of the scale is always within the scale’s range.
    
    
      padding
      Number
      Expands the scale domain to accommodate the specified number of pixels on each of the scale range. The scale range must represent pixels for this parameter to function as intended. Padding adjustment is performed prior to all other adjustments, including the effects of the zero, nice, domainMin, and domainMax properties.
    
    
      nice
      Boolean | Number | Signal
      Extends the domain so that it starts and ends on nice round values (default false). This method typically modifies the scale’s domain, and may only extend the bounds to the nearest round value. Nicing is useful if the domain is computed from data and may be irregular. For example, for a domain of [0.201479…, 0.996679…], a nice domain might be [0.2, 1.0]. Domain values set via domainMin and domainMax (but not domainRaw) are subject to nicing. Using a number value for this parameter (representing a desired tick count) allows greater control over the step size used to extend the bounds, guaranteeing that the returned ticks will exactly cover the domain.
    
    
      zero
      Boolean
      Boolean flag indicating if the scale domain should include zero. The default value is true for linear, sqrt and pow, and false otherwise.
    
  


Linear Scales

Linear scales (linear) are quantitative scales scales that preserve proportional differences. Each range value y can be expressed as a linear function of the domain value x: y = mx + b.

Logarithmic Scales

Log scales (log) are quantitative scales scales in which a logarithmic transform is applied to the input domain value before the output range value is computed. Log scales are particularly useful for plotting data that varies over multiple orders of magnitude. The mapping to the range value y can be expressed as a logarithmic function of the domain value x: y = m log(x) + b.

As log(0) = -∞, a log scale domain must be strictly-positive or strictly-negative; the domain must not include or cross zero. A log scale with a positive domain has a well-defined behavior for positive values, and a log scale with a negative domain has a well-defined behavior for negative values. (For a negative domain, input and output values are implicitly multiplied by -1.) The behavior of the scale is undefined if you run a negative value through a log scale with a positive domain or vice versa.


  
    
      Property
      Type
      Description
    
  
  
    
      base
      Number
      The base of the logarithm (default 10).
    
  


Power Scales

Power scales (pow) are quantitative scales scales that apply an exponential transform to the input domain value before the output range value is computed. Each range value y can be expressed as a polynomial function of the domain value x: y = mx^k + b, where k is the exponent value. Power scales also support negative domain values, in which case the input value and the resulting output value are multiplied by -1.


  
    
      Property
      Type
      Description
    
  
  
    
      exponent
      Number
      The exponent to use in the scale transform (default 1).
    
  


Square Root Scales

Square root (sqrt) scales are a convenient shorthand for power scales with an exponent of 0.5, indicating a square root transform.

Symmetric Log Scales ≥ 5.0

Symmetric log scales (symlog) are quantitative scales scales that provide scaling similar to log scales, but supports non-positive numbers. Symlog scales are particularly useful for plotting data that varies over multiple orders of magnitude but includes negative- or zero-valued data. For more, see “A bi-symmetric log transformation for wide-range data” by Webber for more.


  
    
      Property
      Type
      Description
    
  
  
    
      constant
      Number
      A constant determining the slope of the symlog function around zero (default 1).
    
  


Time and UTC Scales

Time scales (time and utc) are quantitative scales with a temporal domain: values in the input domain are assumed to be Date objects or timestamps. The time scale type uses the current local timezone setting. UTC scales (utc) instead use Coordinated Universal Time. Both time and utc scales use a default domain of [2000-01-01, 2000-01-02], and a default unit range [0, 1].


  
    
      Property
      Type
      Description
    
  
  
    
      nice
      String | Object | Number | Boolean
      If specified, modifies the scale domain to use a more human-friendly value range. For time and utc scale types, the nice value can additionally be a string indicating the desired time interval. Legal values are "millisecond", "second", "minute", "hour", "day", "week", "month", and "year". Alternatively, time and utc scales can accept an object-valued interval specifier of the form {"interval": "month", "step": 3}, which includes a desired number of interval steps. Here, the domain would snap to quarter (Jan, Apr, Jul, Oct) boundaries.
    
  


Sequential Scales (Deprecated)

Sequential scales (sequential) are similar to linear scales, but use a fixed interpolator to determine the output range. As of Vega 5.0, sequential scales are deprecated: specifications should now use a linear (or log, etc.) scale with a color-valued range, rather than  a sequential scale.


  
    
      Property
      Type
      Description
    
  
  
    
      clamp
      Boolean
      A boolean indicating if output values should be clamped to the range (default false). If clamping is disabled and the scale is passed a value outside the domain, the scale may return a value outside the range through extrapolation. If clamping is enabled, the output value of the scale is always within the scale’s range.
    
    
      domainMax
      Number
      Sets the maximum value in the scale domain, overriding the domain property.
    
    
      domainMin
      Number
      Sets the minimum value in the scale domain, overriding the domain property.
    
    
      domainMid
      Number
      Inserts a single mid-point value into a two-element domain. The mid-point value must lie between the domain minimum and maximum values. This property can be useful for setting a midpoint for diverging color scales.
    
    
      range
      Scheme | Color[ ]
      Required. The range value should either be a color scheme object or an array of color strings. If an array of colors is provided, the array will be used to create a continuous interpolator via linear interpolation in the RGB color space.
    
  


Back to scale type reference

Discrete Scales

Discrete scales map values from a discrete domain to a discrete range. In the case of band and point scales, the range is determined by discretizing a continuous numeric range.

Ordinal Scales

Ordinal scales (ordinal) have a discrete domain and range. For example, an ordinal scale might map a set of named categories to a set of colors, or to a set of shapes. Ordinal scales function as a “lookup table” from a domain value to a range value.

This example uses an ordinal scale for color-coded categories, with up to 20 unique colors:

{
  "scales": [
    {
      "name": "color",
      "type": "ordinal",
      "domain": {"data": "table", "field": "category"},
      "range": {"scheme": "category20"}
    }
  ]
}


Band Scales

Band scales (band) accept a discrete domain similar to ordinal scales, but map this domain to a continuous, numeric output range such as pixels. Discrete output values are automatically computed by the scale by dividing the continuous range into uniform bands. Band scales are typically used for bar charts with an ordinal or categorical dimension.

In addition to a standard numerical range value (such as [0, 500]), band scales can be given a fixed step size for each band. The actual range is then determined by both the step size and the cardinality (element count) of the input domain. The step size is specified by an object with a step property that provides the step size in pixels, for example "range": {"step": 20}.

This image from the d3-scale documentation illustrates how a band scale works:




  
    
      Property
      Type
      Description
    
  
  
    
      align
      Number
      The alignment of elements within the scale range. This value must lie in the range [0,1]. A value of 0.5 (default) indicates that the bands should be centered within the range. A value of 0 or 1 may be used to shift the bands to one side, say to position them adjacent to an axis. For more, see this explainer for D3 band align.
    
    
      domainImplicit
      Boolean
      A boolean flag (default false) indicating if an ordinal domain should be implicitly extended with new values. If false, the scale will return undefined for values not explicitly included in the domain. If true, new values will be appended to the domain and the matching range value will be returned.
    
    
      padding
      Number
      Sets paddingInner and paddingOuter to the same padding value (default 0). This value must lie in the range [0,1].
    
    
      paddingInner
      Number
      The inner padding (spacing) within each band step, as a fraction of the step size (default 0). This value must lie in the range [0,1].
    
    
      paddingOuter
      Number
      The outer padding (spacing) at the ends of the scale range, as a fraction of the step size (default 0). This value must lie in the range [0,1].
    
  


Point Scales

Point scales (point) are a variant of band scales where the internal band width is fixed to zero. Point scales are typically used for scatterplots with an ordinal or categorical dimension. Similar to band scales, point scale range values may be specified using either a numerical extent ([0, 500]) or a step size ({"step": 20}). As point scales do not have internal band widths (only step sizes between bands), they do not accept the paddingInner property.

This image from the d3-scale documentation illustrates how a point scale works:




  
    
      Property
      Type
      Description
    
  
  
    
      align
      Number
      The alignment of elements within the scale range. This value must lie in the range [0,1]. A value of 0.5 (default) indicates that the points should be centered within the range. A value of 0 or 1 may be used to shift the points to one side, say to position them adjacent to an axis.
    
    
      padding
      Number
      An alias for paddingOuter (default 0). This value must lie in the range [0,1].
    
    
      paddingOuter
      Number
      The outer padding (spacing) at the ends of the scale range, as a fraction of the step size (default 0). This value must lie in the range [0,1].
    
  


Back to scale type reference

Discretizing Scales

Discretizing scales break up a continuous domain into discrete segments, and then map values in each segment to a range value.

Quantile Scales

Quantile scales (quantile) map a sample of input domain values to a discrete range based on computed quantile boundaries. The domain is considered continuous and thus the scale will accept any reasonable input value; however, the domain is specified as a discrete set of sample values. The number of values in (i.e., the cardinality of) the output range determines the number of quantiles that will be computed from the domain. To compute the quantiles, the domain is sorted, and treated as a population of discrete values. The resulting quantile boundaries segment the domain into groups with roughly equal numbers of sample points per group.

Quantile scales are particularly useful for creating color or size encodings with a fixed number of output values. Using a discrete set of encoding levels (typically between 5-9 colors or sizes) sometimes supports more accurate perceptual comparison than a continuous range. For related functionality see quantize scales, which partition the domain into uniform domain extents, rather than groups with equal element counts. Quantile scales have the benefit of evenly distributing data points to encoded values. In contrast, quantize scales uniformly segment the input domain and provide no guarantee on how data points will be distributed among the output visual values.

This example color-codes quantile values in five groups, using colors sampled from a continuous color scheme:

{
  "name": "color",
  "scale": "quantile",
  "domain": {"data": "table", "field": "value"},
  "range": {"scheme": "plasma", "count": 5}
}


Quantize Scales

Quantize scales (quantize) are similar to linear scales, except they use a discrete rather than continuous range. The continuous input domain is divided into uniform segments based on the number of values in (i.e., the cardinality of) the output range. Each range value y can be expressed as a quantized linear function of the domain value x: y = m round(x) + b.

Quantize scales are particularly useful for creating color or size encodings with a fixed number of output values. Using a discrete set of encoding levels (typically between 5-9 colors or sizes) sometimes supports more accurate perceptual comparison than a continuous range. For related functionality see quantile scales, which partition the domain into groups with equal element counts, rather than uniform domain extents.


  
    
      Property
      Type
      Description
    
  
  
    
      nice
      Boolean | Number
      Extends the domain so that it starts and ends on nice round values (default false). This method typically modifies the scale’s domain, and may only extend the bounds to the nearest round value. Nicing is useful if the domain is computed from data and may be irregular. For example, for a domain of [0.201479…, 0.996679…], a nice domain might be [0.2, 1.0]. Domain values set via domainMin and domainMax (but not domainRaw) are subject to nicing. Using a number value for this parameter (representing a desired tick count) allows greater control over the step size used to extend the bounds, guaranteeing that the returned ticks will exactly cover the domain.
    
    
      zero
      Boolean
      Boolean flag indicating if the scale domain should include zero (default false).
    
  


This example color-codes a quantized domain using a 7-point color scheme:

{
  "name": "color",
  "scale": "quantize",
  "domain": {"data": "table", "field": "value"},
  "range": {"scheme": "blues", "count": 7}
}


Threshold Scales

Threshold scales (threshold) are similar to quantize scales, except they allow mapping of arbitrary subsets of the domain (not uniform segments) to discrete values in the range. The input domain is still continuous, and divided into slices based on a set of threshold values provided to the domain property. The range property must have N+1 elements, where N is the number of threshold boundaries provided in the domain.

Given the following scale definition,

{
  "name": "threshold",
  "type": "threshold",
  "domain": [0, 1],
  "range": ["red", "white", "blue"]
}


the scale will map domain values to color strings as follows:

-1   => "red"
0    => "white"
0.5  => "white"
1.0  => "blue"
1000 => "blue"


Bin-Ordinal Scales

Binned ordinal scales (bin-ordinal) are a special type of ordinal scale for use with data that has been subdivided into bins (for example, using Vega’s bin transform). The main benefit of using bin-ordinal scales is that they provide “bin-aware” routines for sampling values and generating labels for inclusion in legends. They are particularly useful for creating binned color encodings.

The domain values for a binned ordinal scale must be the set of all bin boundaries, from the minimum bin start to maximum bin end. Input domain values are discretized to the appropriate bin, which is then treated as a standard ordinal scale input. However, as the domain property only accepts an array of values, the bin-ordinal scale provides a bins property that also accepts a bin specification and can be used instead of an explicit domain property.


  
    
      Property
      Type
      Description
    
  
  
    
      bins
      Bins
      ≥ 5.0 Bin boundaries over the scale domain, such as those computed by Vega’s bin transform. This property can be either an explicit array of bin boundary values or a specification object, see the scale bins reference for more. If the domain property is not defined, bins will be used to determine the scale domain.
    
  


Here is an example of a bin-ordinal scale defined in conjunction with a bin transform:

{
  "data": [
    {
      "name": "input",
      "transform": [
        { "type": "extent", "field": "value", "signal": "extent" },
        { "type": "bin", "extent": {"signal": "extent"}, "signal": "bins" }
      ]
    }
  ],
  "scales": [
    {
      "name": "color",
      "type": "bin-ordinal",
      "bins": {"signal": "bins"},
      "range": {"scheme": "greens"}
    }
  ]
}


Back to scale type reference

Scale Bins

Bin boundaries can be provided to scales as either an explicit array of bin boundaries or as a bin specification object. The legal values are:


  A signal reference that resolves to either an array or bin specification object.
  An array literal of bin boundary values. For example, [0, 5, 10, 15, 20]. The array must include both starting and ending boundaries. The previous example uses five values to indicate a total of four bin intervals: [0-5), [5-10), [10-15), [15-20]. Array literals may include signal references as elements.
  A bin specification object that indicates the bin step size, and optionally the start and stop boundaries. The output value of a bin transform is a valid bin specification object.



  
    
      Property
      Type
      Description
    
  
  
    
      start
      Number
      The starting (lowest-valued) bin boundary. If not defined, the lowest value of the scale domain will be used.
    
    
      stop
      Number
      The stopping (highest-valued) bin boundary. If not defined, the highest value of the scale domain will be used.
    
    
      step
      Number
      Required. The step size defining the bin interval width.
    
  


Scale Domains

Scale domains can be specified in multiple ways:


  As an array literal of domain values. For example, [0, 500] or ['a', 'b', 'c']. Array literals may include signal references as elements.
  A signal reference that resolves to a domain value array. For example, {"signal": "myDomain"}.
  A data reference object that specifies field values in one or more data sets.


Basic Data Reference

A basic data reference indicates a data set, field name, and optional sorting for discrete scales:


  
    
      Property
      Type
      Description
    
  
  
    
      data
      String
      Required. The name of the data set containing domain values.
    
    
      field
      Field
      Required. The name of the data field (e.g., "price").
    
    
      sort
      Boolean | Sort
      If a boolean true value, sort the domain values in ascending order. If object-valued, sort the domain according to the provided sort parameters. Sorting is only supported for discrete scale types.
    
  


For example, "domain": {"data": "table", "field": "value"}, derives a scale domain from the value field of data objects in the table data set. If the scale type is quantitative or a quantize, the derived domain will be a two-element [min, max] array. If the scale type is discrete, the derived domain will be an array of all distinct values. If the scale type is quantile, all values will be used to compute quantile boundaries.

Multi-Field Data References

Scale domains can also be derived using values from multiple fields. Multiple fields from the same data set can be specified by replacing the field property with a fields property that takes an array of field names:


  
    
      Property
      Type
      Description
    
  
  
    
      data
      String
      Required. The name of the data set containing domain values.
    
    
      fields
      Field[ ]
      Required. The names of the data field (e.g., ["price", "cost"]).
    
    
      sort
      Boolean | Sort
      If a boolean true value, sort the domain values in ascending order. If object-valued, sort the domain according to the provided sort parameters. Sorting is only supported for discrete scale types.
    
  


More generally, scale domains may also use values pulled from different data sets. In this case, the domain object should have a fields property, which is an array of basic data references:


  
    
      Property
      Type
      Description
    
  
  
    
      fields
      DataRef[ ]
      Required. An array of basic data references indicating each data set and field value to include in the domain. In addition, array literals (e.g., [0, 100], ["a", "b", "c"]) may be included as elements of the fields array for inclusion in the domain determination.
    
    
      sort
      Boolean | Sort
      If a boolean true value, sort the domain values in ascending order. If object-valued, sort the domain according to the provided sort parameters. Sorting is only supported for discrete scale types.
    
  


Here is an example that constructs a domain using the fields price and cost drawn from two different data sets:

"domain": {
  "fields": [
    {"data": "table1", "field": "price"},
    {"data": "table2", "field": "cost"}
   ]
}


Sorting Domains

The sort property of a domain data reference can accept, in addition to a simple boolean, an object-valued sort definition:


  
    
      Property
      Type
      Description
    
  
  
    
      field
      Field
      The data field to sort by. If unspecified, defaults to the field specified in the outer data reference.
    
    
      op
      String
      An aggregate operation to perform on the field prior to sorting. Examples include count, mean and median. This property is required in cases where the sort field and the data reference field do not match. The input data objects will be aggregated, grouped by data reference field values. For a full list of operations, see the aggregate transform, and also see below for limitations with multi-field domains.
    
    
      order
      String
      The sort order. One of ascending (default) or descending.
    
  


This example sorts distinct category field values in descending order by the associated median of the value field:

{
  "domain": {
    "data": "table",
    "field": "category",
    "sort": {"op": "median", "field": "value", "order": "descending"}
  }
}


This example sorts a multi-field domain in descending order based on the counts of each of the domain values:

{
  "domain": {
    "data": "table",
    "fields": ["category1", "category2"],
    "sort": {"op": "count", "order": "descending"}
  }
}


Note: For multi-field domains, the sort field values may not be undefined across all input data sets, and will exhibit duplicate values when drawing multiple domain values from the same data set. To avoid inaccurate sorting, the only allowed sort op values for multi-domain scales are count, min, and max. Support for min and max is available in versions ≥ 5.5.

Scale Ranges

Scale ranges can be specified in multiple ways:


  As an array literal of range values. For example, [0, 500] or ['a', 'b', 'c']. Array literals may include signal references as elements.
  A signal reference that resolves to a range value array. For example, {"signal": "myRange"}.
  A color scheme reference for a color palette. For example, {"scheme": "blueorange"}.
  For ordinal scales only, a data reference for a set of distinct field values. For example, {"data": "table", "field": "value"}.
  For band and point scales only, a step size for each range band. For example, {"step": 20}.
  A string indicating a pre-defined scale range default. For example, "width", "symbol", or "diverging".


Scale Range Defaults

Scale ranges can also accept string literals that map to default values. Default values can be modified, and new named defaults can be added, by using custom config settings.


  
    
      Value
      Description
    
  
  
    
      "width"
      A spatial range determined by the value of the width signal.
    
    
      "height"
      A spatial range determined by the value of the height signal. The direction of the range (top-to-bottom or bottom-to-top) is automatically determined according to the scale type.
    
    
      "symbol"
      The default plotting symbol set to use for shape encodings.
    
    
      "category"
      The default categorical color scheme to use for nominal data.
    
    
      "diverging"
      The default diverging color scheme to use for quantitative data.
    
    
      "ordinal"
      The default sequential color scheme to use for ordinal data.
    
    
      "ramp"
      The default sequential color scheme to use for quantitative data.
    
    
      "heatmap"
      The default sequential color scheme to use for quantitative heatmaps.\nScales map data values (numbers, dates, categories, etc.) to visual values (pixels, colors, sizes). Scales are a fundamental building block of data visualization, as they determine the nature of visual encodings. Vega includes a range of scales for both continuous and discrete input data, and supports mappings for position, shape, size and color encodings.\nTo visualize scales, Vega specifications may include axes or legends. For more about supported color encodings, see the color scheme reference. Internally, Vega uses the scales provided by the d3-scale library; for more background see Introducing d3-scale by Mike Bostock.\ncolor scheme reference\nDocumentation Overview\nProperties shared across scale types.\nRequired. A unique name for the scale. Scales and projections share the same namespace; names must be unique across both.\nThe type of scale (default linear). See the  scale type reference for more.\nThe domain of input data values for the scale. For quantitative data, this can take the form of a two-element array with minimum and maximum values. For ordinal or categorical data, this may be an array of valid input values. The domain may also be specified as a reference to a data source. See the scale domain reference for more.\nscale domain reference\nSets the maximum value in the scale domain, overriding the domain property. The domainMax property is only intended for use with scales having continuous domains.\nSets the minimum value in the scale domain, overriding the domain property. The domainMin property is only intended for use with scales having continuous domains.\nInserts a single mid-point value into a two-element domain. The mid-point value must lie between the domain minimum and maximum values. This property can be useful for setting a midpoint for diverging color scales. The domainMid property is only intended for use with scales supporting continuous, piecewise domains.\ndiverging color scales\nAn array of raw values that, if non-null, directly overrides the domain property. This is useful for supporting interactions such as panning or zooming a scale. The scale may be initially determined using a data-driven domain, then modified in response to user input by setting the rawDomain value.\nThe interpolation method for range values. By default, continuous scales use a general interpolator for numbers, dates, strings and colors (in RGB space) is used. For color ranges, this property allows interpolation in alternative color spaces. Legal values include rgb, hsl, hsl-long, lab, hcl, hcl-long, cubehelix and cubehelix-long (‘-long’ variants use longer paths in polar coordinate spaces). If object-valued, this property accepts an object with a string-valued type property and an optional numeric gamma property applicable to rgb and cubehelix interpolators. For more, see the d3-interpolate documentation.\nd3-interpolate documentation\nThe range of the scale, representing the set of visual values. For numeric values, the range typically takes the form of a two-element array with minimum and maximum values. For ordinal or quantized data, the range may be an array of desired output values, which are mapped to elements in the specified domain. See the scale range reference for more.\nscale range reference\nA boolean flag (default false) that reverses the order of the scale range.\nA boolean flag (default false) that rounds numeric output values to integers. Helpful for snapping to a pixel grid.\nQuantitative Scales
    
      linear
      log
      pow
      sqrt
      symlog
      time
      utc
      sequential\nDiscrete Scales
    
      ordinal
      band
      point\nDiscretizing Scales
    
      quantile
      quantize
      threshold
      bin-ordinal\nA quantitative scale maps a continuous domain (numbers or dates) to a continuous output range (pixel locations, sizes, colors). The available quantitative scale type values are linear, log, pow, sqrt, symlog, time and utc. All quantitative scales except for time and utc use a default domain of [0, 1] and default unit range [0, 1].\nAll quantitative scales support color-valued ranges, defined either as an array of color strings or as a scheme specification. If the domain includes two color values, a sequential color scale is used. If the domain includes three color values, a diverging color scale is used. For larger domain sizes, the domain and range should have the same number of values, over which piecewise interpolation will be applied.\n≥ 5.0 Bin boundaries over the scale domain, such as those computed by Vega’s bin transform. If provided, axes and legends will use the bin boundaries to inform the choice of axis tick marks and legend labels. This property can be either an explicit array of bin boundary values or a specification object, see the scale bins reference for more.\nA boolean indicating if output values should be clamped to the range (default false). If clamping is disabled and the scale is passed a value outside the domain, the scale may return a value outside the range through extrapolation. If clamping is enabled, the output value of the scale is always within the scale’s range.\nExpands the scale domain to accommodate the specified number of pixels on each of the scale range. The scale range must represent pixels for this parameter to function as intended. Padding adjustment is performed prior to all other adjustments, including the effects of the zero, nice, domainMin, and domainMax properties.\nBoolean | Number | Signal\nExtends the domain so that it starts and ends on nice round values (default false). This method typically modifies the scale’s domain, and may only extend the bounds to the nearest round value. Nicing is useful if the domain is computed from data and may be irregular. For example, for a domain of [0.201479…, 0.996679…], a nice domain might be [0.2, 1.0]. Domain values set via domainMin and domainMax (but not domainRaw) are subject to nicing. Using a number value for this parameter (representing a desired tick count) allows greater control over the step size used to extend the bounds, guaranteeing that the returned ticks will exactly cover the domain.\nBoolean flag indicating if the scale domain should include zero. The default value is true for linear, sqrt and pow, and false otherwise.\nLinear scales (linear) are quantitative scales scales that preserve proportional differences. Each range value y can be expressed as a linear function of the domain value x: y = mx + b.\nLog scales (log) are quantitative scales scales in which a logarithmic transform is applied to the input domain value before the output range value is computed. Log scales are particularly useful for plotting data that varies over multiple orders of magnitude. The mapping to the range value y can be expressed as a logarithmic function of the domain value x: y = m log(x) + b.\nAs log(0) = -∞, a log scale domain must be strictly-positive or strictly-negative; the domain must not include or cross zero. A log scale with a positive domain has a well-defined behavior for positive values, and a log scale with a negative domain has a well-defined behavior for negative values. (For a negative domain, input and output values are implicitly multiplied by -1.) The behavior of the scale is undefined if you run a negative value through a log scale with a positive domain or vice versa.\nThe base of the logarithm (default 10).\nPower scales (pow) are quantitative scales scales that apply an exponential transform to the input domain value before the output range value is computed. Each range value y can be expressed as a polynomial function of the domain value x: y = mx^k + b, where k is the exponent value. Power scales also support negative domain values, in which case the input value and the resulting output value are multiplied by -1.\nThe exponent to use in the scale transform (default 1).\nSquare root (sqrt) scales are a convenient shorthand for power scales with an exponent of 0.5, indicating a square root transform.\nSymmetric Log Scales ≥ 5.0\nSymmetric log scales (symlog) are quantitative scales scales that provide scaling similar to log scales, but supports non-positive numbers. Symlog scales are particularly useful for plotting data that varies over multiple orders of magnitude but includes negative- or zero-valued data. For more, see “A bi-symmetric log transformation for wide-range data” by Webber for more.\n“A bi-symmetric log transformation for wide-range data”\nA constant determining the slope of the symlog function around zero (default 1).\nTime scales (time and utc) are quantitative scales with a temporal domain: values in the input domain are assumed to be Date objects or timestamps. The time scale type uses the current local timezone setting. UTC scales (utc) instead use Coordinated Universal Time. Both time and utc scales use a default domain of [2000-01-01, 2000-01-02], and a default unit range [0, 1].\nCoordinated Universal Time\nString | Object | Number | Boolean\nIf specified, modifies the scale domain to use a more human-friendly value range. For time and utc scale types, the nice value can additionally be a string indicating the desired time interval. Legal values are "millisecond", "second", "minute", "hour", "day", "week", "month", and "year". Alternatively, time and utc scales can accept an object-valued interval specifier of the form {"interval": "month", "step": 3}, which includes a desired number of interval steps. Here, the domain would snap to quarter (Jan, Apr, Jul, Oct) boundaries.\nSequential Scales (Deprecated)\nSequential scales (sequential) are similar to linear scales, but use a fixed interpolator to determine the output range. As of Vega 5.0, sequential scales are deprecated: specifications should now use a linear (or log, etc.) scale with a color-valued range, rather than  a sequential scale.\nA boolean indicating if output values should be clamped to the range (default false). If clamping is disabled and the scale is passed a value outside the domain, the scale may return a value outside the range through extrapolation. If clamping is enabled, the output value of the scale is always within the scale’s range.\nSets the maximum value in the scale domain, overriding the domain property.\nSets the minimum value in the scale domain, overriding the domain property.\nInserts a single mid-point value into a two-element domain. The mid-point value must lie between the domain minimum and maximum values. This property can be useful for setting a midpoint for diverging color scales.\ndiverging color scales\nRequired. The range value should either be a color scheme object or an array of color strings. If an array of colors is provided, the array will be used to create a continuous interpolator via linear interpolation in the RGB color space.\nBack to scale type reference\nBack to scale type reference\nDiscrete scales map values from a discrete domain to a discrete range. In the case of band and point scales, the range is determined by discretizing a continuous numeric range.\nOrdinal scales (ordinal) have a discrete domain and range. For example, an ordinal scale might map a set of named categories to a set of colors, or to a set of shapes. Ordinal scales function as a “lookup table” from a domain value to a range value.\nThis example uses an ordinal scale for color-coded categories, with up to 20 unique colors:\n{
  "scales": [
    {
      "name": "color",
      "type": "ordinal",
      "domain": {"data": "table", "field": "category"},
      "range": {"scheme": "category20"}
    }
  ]
}\n{
  "scales": [
    {
      "name": "color",
      "type": "ordinal",
      "domain": {"data": "table", "field": "category"},
      "range": {"scheme": "category20"}
    }
  ]
}\nBand scales (band) accept a discrete domain similar to ordinal scales, but map this domain to a continuous, numeric output range such as pixels. Discrete output values are automatically computed by the scale by dividing the continuous range into uniform bands. Band scales are typically used for bar charts with an ordinal or categorical dimension.\nIn addition to a standard numerical range value (such as [0, 500]), band scales can be given a fixed step size for each band. The actual range is then determined by both the step size and the cardinality (element count) of the input domain. The step size is specified by an object with a step property that provides the step size in pixels, for example "range": {"step": 20}.\nThis image from the d3-scale documentation illustrates how a band scale works:\nd3-scale documentation\nThe alignment of elements within the scale range. This value must lie in the range [0,1]. A value of 0.5 (default) indicates that the bands should be centered within the range. A value of 0 or 1 may be used to shift the bands to one side, say to position them adjacent to an axis. For more, see this explainer for D3 band align.\nthis explainer for D3 band align\nA boolean flag (default false) indicating if an ordinal domain should be implicitly extended with new values. If false, the scale will return undefined for values not explicitly included in the domain. If true, new values will be appended to the domain and the matching range value will be returned.\nSets paddingInner and paddingOuter to the same padding value (default 0). This value must lie in the range [0,1].\nThe inner padding (spacing) within each band step, as a fraction of the step size (default 0). This value must lie in the range [0,1].\nThe outer padding (spacing) at the ends of the scale range, as a fraction of the step size (default 0). This value must lie in the range [0,1].\nPoint scales (point) are a variant of band scales where the internal band width is fixed to zero. Point scales are typically used for scatterplots with an ordinal or categorical dimension. Similar to band scales, point scale range values may be specified using either a numerical extent ([0, 500]) or a step size ({"step": 20}). As point scales do not have internal band widths (only step sizes between bands), they do not accept the paddingInner property.\nThis image from the d3-scale documentation illustrates how a point scale works:\nd3-scale documentation\nThe alignment of elements within the scale range. This value must lie in the range [0,1]. A value of 0.5 (default) indicates that the points should be centered within the range. A value of 0 or 1 may be used to shift the points to one side, say to position them adjacent to an axis.\nAn alias for paddingOuter (default 0). This value must lie in the range [0,1].\nThe outer padding (spacing) at the ends of the scale range, as a fraction of the step size (default 0). This value must lie in the range [0,1].\nBack to scale type reference\nBack to scale type reference\nDiscretizing scales break up a continuous domain into discrete segments, and then map values in each segment to a range value.\nQuantile scales (quantile) map a sample of input domain values to a discrete range based on computed quantile boundaries. The domain is considered continuous and thus the scale will accept any reasonable input value; however, the domain is specified as a discrete set of sample values. The number of values in (i.e., the cardinality of) the output range determines the number of quantiles that will be computed from the domain. To compute the quantiles, the domain is sorted, and treated as a population of discrete values. The resulting quantile boundaries segment the domain into groups with roughly equal numbers of sample points per group.\nQuantile scales are particularly useful for creating color or size encodings with a fixed number of output values. Using a discrete set of encoding levels (typically between 5-9 colors or sizes) sometimes supports more accurate perceptual comparison than a continuous range. For related functionality see quantize scales, which partition the domain into uniform domain extents, rather than groups with equal element counts. Quantile scales have the benefit of evenly distributing data points to encoded values. In contrast, quantize scales uniformly segment the input domain and provide no guarantee on how data points will be distributed among the output visual values.\nThis example color-codes quantile values in five groups, using colors sampled from a continuous color scheme:\n{
  "name": "color",
  "scale": "quantile",
  "domain": {"data": "table", "field": "value"},
  "range": {"scheme": "plasma", "count": 5}
}\n{
  "name": "color",
  "scale": "quantile",
  "domain": {"data": "table", "field": "value"},
  "range": {"scheme": "plasma", "count": 5}
}\nQuantize scales (quantize) are similar to linear scales, except they use a discrete rather than continuous range. The continuous input domain is divided into uniform segments based on the number of values in (i.e., the cardinality of) the output range. Each range value y can be expressed as a quantized linear function of the domain value x: y = m round(x) + b.\nQuantize scales are particularly useful for creating color or size encodings with a fixed number of output values. Using a discrete set of encoding levels (typically between 5-9 colors or sizes) sometimes supports more accurate perceptual comparison than a continuous range. For related functionality see quantile scales, which partition the domain into groups with equal element counts, rather than uniform domain extents.\nExtends the domain so that it starts and ends on nice round values (default false). This method typically modifies the scale’s domain, and may only extend the bounds to the nearest round value. Nicing is useful if the domain is computed from data and may be irregular. For example, for a domain of [0.201479…, 0.996679…], a nice domain might be [0.2, 1.0]. Domain values set via domainMin and domainMax (but not domainRaw) are subject to nicing. Using a number value for this parameter (representing a desired tick count) allows greater control over the step size used to extend the bounds, guaranteeing that the returned ticks will exactly cover the domain.\nBoolean flag indicating if the scale domain should include zero (default false).\nThis example color-codes a quantized domain using a 7-point color scheme:\n{
  "name": "color",
  "scale": "quantize",
  "domain": {"data": "table", "field": "value"},
  "range": {"scheme": "blues", "count": 7}
}\n{
  "name": "color",
  "scale": "quantize",
  "domain": {"data": "table", "field": "value"},
  "range": {"scheme": "blues", "count": 7}
}\nThreshold scales (threshold) are similar to quantize scales, except they allow mapping of arbitrary subsets of the domain (not uniform segments) to discrete values in the range. The input domain is still continuous, and divided into slices based on a set of threshold values provided to the domain property. The range property must have N+1 elements, where N is the number of threshold boundaries provided in the domain.\nGiven the following scale definition,\n{
  "name": "threshold",
  "type": "threshold",
  "domain": [0, 1],
  "range": ["red", "white", "blue"]
}\n{
  "name": "threshold",
  "type": "threshold",
  "domain": [0, 1],
  "range": ["red", "white", "blue"]
}\nthe scale will map domain values to color strings as follows:\n-1   => "red"
0    => "white"
0.5  => "white"
1.0  => "blue"
1000 => "blue"\n-1   => "red"
0    => "white"
0.5  => "white"
1.0  => "blue"
1000 => "blue"\nBinned ordinal scales (bin-ordinal) are a special type of ordinal scale for use with data that has been subdivided into bins (for example, using Vega’s bin transform). The main benefit of using bin-ordinal scales is that they provide “bin-aware” routines for sampling values and generating labels for inclusion in legends. They are particularly useful for creating binned color encodings.\nThe domain values for a binned ordinal scale must be the set of all bin boundaries, from the minimum bin start to maximum bin end. Input domain values are discretized to the appropriate bin, which is then treated as a standard ordinal scale input. However, as the domain property only accepts an array of values, the bin-ordinal scale provides a bins property that also accepts a bin specification and can be used instead of an explicit domain property.\n≥ 5.0 Bin boundaries over the scale domain, such as those computed by Vega’s bin transform. This property can be either an explicit array of bin boundary values or a specification object, see the scale bins reference for more. If the domain property is not defined, bins will be used to determine the scale domain.\nHere is an example of a bin-ordinal scale defined in conjunction with a bin transform:\n{
  "data": [
    {
      "name": "input",
      "transform": [
        { "type": "extent", "field": "value", "signal": "extent" },
        { "type": "bin", "extent": {"signal": "extent"}, "signal": "bins" }
      ]
    }
  ],
  "scales": [
    {
      "name": "color",
      "type": "bin-ordinal",
      "bins": {"signal": "bins"},
      "range": {"scheme": "greens"}
    }
  ]
}\n{
  "data": [
    {
      "name": "input",
      "transform": [
        { "type": "extent", "field": "value", "signal": "extent" },
        { "type": "bin", "extent": {"signal": "extent"}, "signal": "bins" }
      ]
    }
  ],
  "scales": [
    {
      "name": "color",
      "type": "bin-ordinal",
      "bins": {"signal": "bins"},
      "range": {"scheme": "greens"}
    }
  ]
}\nBack to scale type reference\nBack to scale type reference\nBin boundaries can be provided to scales as either an explicit array of bin boundaries or as a bin specification object. The legal values are:\nA signal reference that resolves to either an array or bin specification object.\nAn array literal of bin boundary values. For example, [0, 5, 10, 15, 20]. The array must include both starting and ending boundaries. The previous example uses five values to indicate a total of four bin intervals: [0-5), [5-10), [10-15), [15-20]. Array literals may include signal references as elements.\nA bin specification object that indicates the bin step size, and optionally the start and stop boundaries. The output value of a bin transform is a valid bin specification object.\nThe starting (lowest-valued) bin boundary. If not defined, the lowest value of the scale domain will be used.\nThe stopping (highest-valued) bin boundary. If not defined, the highest value of the scale domain will be used.\nRequired. The step size defining the bin interval width.\nScale domains can be specified in multiple ways:\nAs an array literal of domain values. For example, [0, 500] or ['a', 'b', 'c']. Array literals may include signal references as elements.\nA signal reference that resolves to a domain value array. For example, {"signal": "myDomain"}.\nA data reference object that specifies field values in one or more data sets.\nA basic data reference indicates a data set, field name, and optional sorting for discrete scales:\nRequired. The name of the data set containing domain values.\nRequired. The name of the data field (e.g., "price").\nIf a boolean true value, sort the domain values in ascending order. If object-valued, sort the domain according to the provided sort parameters. Sorting is only supported for discrete scale types.\nFor example, "domain": {"data": "table", "field": "value"}, derives a scale domain from the value field of data objects in the table data set. If the scale type is quantitative or a quantize, the derived domain will be a two-element [min, max] array. If the scale type is discrete, the derived domain will be an array of all distinct values. If the scale type is quantile, all values will be used to compute quantile boundaries.\nMulti-Field Data References\nScale domains can also be derived using values from multiple fields. Multiple fields from the same data set can be specified by replacing the field property with a fields property that takes an array of field names:\nRequired. The name of the data set containing domain values.\nRequired. The names of the data field (e.g., ["price", "cost"]).\nIf a boolean true value, sort the domain values in ascending order. If object-valued, sort the domain according to the provided sort parameters. Sorting is only supported for discrete scale types.\nMore generally, scale domains may also use values pulled from different data sets. In this case, the domain object should have a fields property, which is an array of basic data references:\nRequired. An array of basic data references indicating each data set and field value to include in the domain. In addition, array literals (e.g., [0, 100], ["a", "b", "c"]) may be included as elements of the fields array for inclusion in the domain determination.\nIf a boolean true value, sort the domain values in ascending order. If object-valued, sort the domain according to the provided sort parameters. Sorting is only supported for discrete scale types.\nHere is an example that constructs a domain using the fields price and cost drawn from two different data sets:\n"domain": {
  "fields": [
    {"data": "table1", "field": "price"},
    {"data": "table2", "field": "cost"}
   ]
}\n"domain": {
  "fields": [
    {"data": "table1", "field": "price"},
    {"data": "table2", "field": "cost"}
   ]
}\nThe sort property of a domain data reference can accept, in addition to a simple boolean, an object-valued sort definition:\nThe data field to sort by. If unspecified, defaults to the field specified in the outer data reference.\nAn aggregate operation to perform on the field prior to sorting. Examples include count, mean and median. This property is required in cases where the sort field and the data reference field do not match. The input data objects will be aggregated, grouped by data reference field values. For a full list of operations, see the aggregate transform, and also see below for limitations with multi-field domains.\nThe sort order. One of ascending (default) or descending.\nThis example sorts distinct category field values in descending order by the associated median of the value field:\n{
  "domain": {
    "data": "table",
    "field": "category",
    "sort": {"op": "median", "field": "value", "order": "descending"}
  }
}\n{
  "domain": {
    "data": "table",
    "field": "category",
    "sort": {"op": "median", "field": "value", "order": "descending"}
  }
}\nThis example sorts a multi-field domain in descending order based on the counts of each of the domain values:\n{
  "domain": {
    "data": "table",
    "fields": ["category1", "category2"],
    "sort": {"op": "count", "order": "descending"}
  }
}\n{
  "domain": {
    "data": "table",
    "fields": ["category1", "category2"],
    "sort": {"op": "count", "order": "descending"}
  }
}\nNote: For multi-field domains, the sort field values may not be undefined across all input data sets, and will exhibit duplicate values when drawing multiple domain values from the same data set. To avoid inaccurate sorting, the only allowed sort op values for multi-domain scales are count, min, and max. Support for min and max is available in versions ≥ 5.5.\nScale ranges can be specified in multiple ways:\nAs an array literal of range values. For example, [0, 500] or ['a', 'b', 'c']. Array literals may include signal references as elements.\nA signal reference that resolves to a range value array. For example, {"signal": "myRange"}.\nA color scheme reference for a color palette. For example, {"scheme": "blueorange"}.\ncolor scheme reference\nFor ordinal scales only, a data reference for a set of distinct field values. For example, {"data": "table", "field": "value"}.\nFor band and point scales only, a step size for each range band. For example, {"step": 20}.\nA string indicating a pre-defined scale range default. For example, "width", "symbol", or "diverging".\nScale ranges can also accept string literals that map to default values. Default values can be modified, and new named defaults can be added, by using custom config settings.\nA spatial range determined by the value of the width signal.\nA spatial range determined by the value of the height signal. The direction of the range (top-to-bottom or bottom-to-top) is automatically determined according to the scale type.\nThe default plotting symbol set to use for shape encodings.\nThe default categorical color scheme to use for nominal data.\ncategorical color scheme\nThe default diverging color scheme to use for quantitative data.\ndiverging color scheme\nThe default sequential color scheme to use for ordinal data.\nsequential color scheme\nThe default sequential color scheme to use for quantitative data.\nsequential color scheme\nThe default sequential color scheme to use for quantitative heatmaps.\nsequential color scheme\n\n\nVega
            
              Vega-Lite
              Altair
              Vega-Lite API
            
          
          
            
              Examples
              Tutorials
              Documentation
              Usage
              About
            
            
              GitHub
              Try Online
            
          
        
      

      
        

  
  
    
      
      
        Documentation
      
      
      
      
        Specification
      
      
      
      
        Config
      
      
      
      
        Data
      
      
      
      
        Transforms
      
      
      
      
        Triggers
      
      
      
      
        Projections
      
      
      
      
        Scales
      
      
      
      
        Schemes
      
      
      
      
        Axes
      
      
      
      
        Legends
      
      
      
      
        Title
      
      
      
      
        Marks
      
      
      
      
        Signals
      
      
      
      
        Event Streams
      
      
      
      
        Expressions
      
      
      
      
        Layout
      
      
      
      
        Types
      
      
    
  
  
    Axes
    Axes visualize spatial scale mappings using ticks, grid lines and labels. Vega currently supports axes for Cartesian (rectangular) coordinates. Similar to scales, axes can be defined either at the top-level of the specification, or as part of a group mark.

Axis Properties

Properties for specifying a coordinate axis.


  
    
      Property
      Type
      Description
    
  
  
    
      scale
      String
      Required. The name of the scale backing the axis component.
    
    
      orient
      String
      Required. The orientation of the axis. See the axis orientation reference.
    
    
      bandPosition
      Number
      An interpolation fraction indicating where, for band scales, axis ticks should be positioned. A value of 0 places ticks at the left edge of their bands. A value of 0.5 places ticks in the middle of their bands.
    
    
      domain
      Boolean
      A boolean flag indicating if the domain (the axis baseline) should be included as part of the axis (default true).
    
    
      domainCap
      String
      The stroke cap for the axis domain line. One of "butt" (default), "round" or "square". ≥ 5.11
    
    
      domainColor
      Color
      Color of axis domain line.
    
    
      domainDash
      Number[ ]
      Stroke dash of axis domain lines (or [] for solid lines). ≥ 5.0
    
    
      domainDashOffset
      Number
      The pixel offset at which to start the domain dash array. ≥ 5.0
    
    
      domainOpacity
      Number
      Opacity of axis domain line. ≥ 4.1
    
    
      domainWidth
      Number
      Stroke width of axis domain line.
    
    
      encode      
      Object
      Optional mark encodings for custom axis styling. Supports encoding blocks for axis, ticks, grid, labels, title, and domain. See custom axis encodings.
    
    
      format
      String | TimeMultiFormat
      The format specifier pattern for axis labels. For numerical values, must be a legal d3-format specifier. For date-time values, must be a legal d3-time-format specifier or a TimeMultiFormat object.
    
    
      formatType
      String
      Specifies the type of format to use ("number", "time", "utc") for scales that do not have a strict domain data type. This property is useful for formatting date-time values for band or point scales. If specified, the format property must have a valid specifier pattern for the given type. Supported ≥ 5.1, UTC support ≥ 5.8.
    
    
      grid
      Boolean
      A boolean flag indicating if grid lines should be included as part of the axis (default false).
    
    
      gridCap
      String
      The stroke cap for axis grid lines. One of "butt" (default), "round" or "square". ≥ 5.11
    
    
      gridColor
      Color
      Color of axis grid lines.
    
    
      gridDash
      Number[ ]
      Stroke dash of axis grid lines (or [] for solid lines).
    
    
      gridDashOffset
      Number
      The pixel offset at which to start the grid dash array. ≥ 5.0
    
    
      gridOpacity
      Number
      Opacity of axis grid lines.
    
    
      gridScale
      String
      The name of the scale to use for including grid lines. By default grid lines are driven by the same scale as the ticks and labels.
    
    
      gridWidth
      Number
      Stroke width of axis grid lines.
    
    
      labels
      Boolean
      A boolean flag indicating if labels should be included as part of the axis (default true).
    
    
      labelAlign
      String
      Horizontal text alignment of axis tick labels, overriding the default setting for the current axis orientation.
    
    
      labelAngle
      Number
      Angle in degrees of axis tick labels.
    
    
      labelBaseline
      String
      Vertical text baseline of axis tick labels, overriding the default setting for the current axis orientation. One of alphabetic (default), top, middle, bottom, line-top, or line-bottom. The line-top and line-bottom values ≥ 5.10 operate similarly to top and bottom, but are calculated relative to the lineHeight rather than fontSize alone.
    
    
      labelBound
      Boolean | Number
      Indicates if labels should be hidden if they exceed the axis range. If false (the default) no bounds overlap analysis is performed. If true, labels will be hidden if they exceed the axis range by more than 1 pixel. If this property is a number, it specifies the pixel tolerance: the maximum amount by which a label bounding box may exceed the axis range.
    
    
      labelColor
      Color
      Text color of axis tick labels.
    
    
      labelFlush
      Boolean | Number
      Indicates if labels at the beginning or end of the axis should be aligned flush with the scale range. If a number, indicates a pixel distance threshold: labels with anchor coordinates within the threshold distance for an axis end-point will be flush-adjusted. If true, a default threshold of 1 pixel is used. Flush alignment for a horizontal axis will left-align labels near the beginning of the axis and right-align labels near the end. For vertical axes, bottom and top text baselines will be applied instead.
    
    
      labelFlushOffset
      Number
      Indicates the number of pixels by which to offset flush-adjusted labels (default 0). For example, a value of 2 will push flush-adjusted labels 2 pixels outward from the center of the axis. Offsets can help the labels better visually group with corresponding axis ticks.
    
    
      labelFont
      String
      Font name for axis tick labels.
    
    
      labelFontSize
      Number
      Font size of axis tick labels.
    
    
      labelFontStyle
      String
      Font style of axis tick labels (e.g., normal or italic). ≥ 5.0
    
    
      labelFontWeight
      String | Number
      Font weight of axis tick labels.
    
    
      labelLimit
      Number
      The maximum allowed length in pixels of axis tick labels.
    
    
      labelLineHeight
      Number
      Line height in pixels for multi-line label text or label text with "line-top" or "line-bottom" baseline. ≥ 5.10
    
    
      labelOffset
      Number
      Position offset in pixels to apply to labels, in addition to tickOffset. ≥ 5.10
    
    
      labelOpacity
      Number
      Opacity of axis tick labels. ≥ 4.1
    
    
      labelOverlap
      Boolean | String
      The strategy to use for resolving overlap of axis labels. If false (the default), no overlap reduction is attempted. If set to true or "parity", a strategy of removing every other label is used (this works well for standard linear axes). If set to "greedy", a linear scan of the labels is performed, removing any label that overlaps with the last visible label (this often works better for log-scaled axes).
    
    
      labelPadding
      Number
      The padding in pixels between labels and ticks.
    
    
      labelSeparation
      Number
      The minimum separation that must be between label bounding boxes for them to be considered non-overlapping (default 0). This property is ignored if labelOverlap resolution is not enabled. ≥ 5.0
    
    
      minExtent
      Number | Value
      The minimum extent in pixels that axis ticks and labels should use. This determines a minimum offset value for axis titles.
    
    
      maxExtent
      Number | Value
      The maximum extent in pixels that axis ticks and labels should use. This determines a maximum offset value for axis titles.
    
    
      offset
      Number | Value
      The orthogonal offset in pixels by which to displace the axis from its position along the edge of the chart.
    
    
      position
      Number | Value
      The anchor position of the axis in pixels (default 0). For x-axes with top or bottom orientation, this sets the axis group x coordinate. For y-axes with left or right orientation, this sets the axis group y coordinate.
    
    
      ticks
      Boolean
      A boolean flag indicating if ticks should be included as part of the axis (default true).
    
    
      tickBand
      String
      Indicates the type of tick style to use in conjunction with band scales. One of "center" (default) to center ticks in the middle of the band interval, or "extent" to place ticks at band extents (interval boundaries). If specified, this property may override the settings of bandPosition, tickExtra, and tickOffset. ≥ 5.8
    
    
      tickCap
      String
      The stroke cap for axis tick marks. One of "butt" (default), "round" or "square". ≥ 5.11
    
    
      tickColor
      Color
      Color of axis ticks.
    
    
      tickCount
      Number | String | Object
      A desired number of ticks, for axes visualizing quantitative scales. The resulting number may be different so that values are “nice” (multiples of 2, 5, 10) and lie within the underlying scale’s range. For scales of type time or utc, the tick count can instead be a time interval specifier. Legal string values are "millisecond", "second", "minute", "hour", "day", "week", "month", and "year". Alternatively, an object-valued interval specifier of the form {"interval": "month", "step": 3} includes a desired number of interval steps. Here, ticks are generated for each quarter (Jan, Apr, Jul, Oct) boundary.
    
    
      tickDash
      Number[ ]
      Stroke dash of axis tick marks (or [] for solid lines). ≥ 5.0
    
    
      tickDashOffset
      Number
      The pixel offset at which to start the tick mark dash array. ≥ 5.0
    
    
      tickMinStep
      Number
      The minimum desired step between axis ticks, in terms of scale domain values. For example, a value of 1 indicates that ticks should not be less than 1 unit apart. If tickMinStep is specified, the tickCount value will be adjusted, if necessary, to enforce the minimum step value. ≥ 5.0
    
    
      tickExtra
      Boolean
      Boolean flag indicating if an extra axis tick should be added for the initial position of the axis. This flag is useful for styling axes for band scales such that ticks are placed on band boundaries rather in the middle of a band. Use in conjunction with "bandPosition": 1 and an axis "padding" value of 0.
    
    
      tickOffset
      Number
      Position offset in pixels to apply to ticks, labels, and gridlines.
    
    
      tickOpacity
      Number
      Opacity of axis ticks. ≥ 4.1
    
    
      tickRound
      Boolean
      Boolean flag indicating if pixel position values should be rounded to the nearest integer.
    
    
      tickSize
      Number
      The length in pixels of axis ticks.
    
    
      tickWidth
      Number
      Width in pixels of axis ticks.
    
    
      title
      String | String[ ]
      A title for the axis (none by default). For versions ≥ 5.7, a string array specifies a title with multiple lines of text.
    
    
      titleAnchor
      String
      The anchor position for placing the axis title. One of "start", "middle", "end", or null (default, for automatic determination). For example, with an orient of "bottom" these anchor positions map to a left-, center-, or right-aligned title. The anchor point is determined relative to the axis scale range. ≥ 5.0
    
    
      titleAlign
      String
      Horizontal text alignment of the axis title. One of "left", "center", or "right". If specified, this value overrides automatic alignment based on the titleAnchor value.
    
    
      titleAngle
      Number
      Angle in degrees of the axis title.
    
    
      titleBaseline
      String
      Vertical text baseline of the axis title. One of alphabetic (default), top, middle, bottom, line-top, or line-bottom. The line-top and line-bottom values ≥ 5.10 operate similarly to top and bottom, but are calculated relative to the lineHeight rather than fontSize alone.
    
    
      titleColor
      Color
      Text color of the axis title.
    
    
      titleFont
      String
      Font name of the axis title.
    
    
      titleFontSize
      Number
      Font size of the axis title.
    
    
      titleFontStyle
      String
      Font style of the axis title (e.g., normal or italic). ≥ 5.0
    
    
      titleFontWeight
      String | Number
      Font weight of axis title.
    
    
      titleLimit
      Number
      The maximum allowed length in pixels of the axis title.
    
    
      titleLineHeight
      Number
      Line height in pixels for multi-line title text or title text with "line-top" or "line-bottom" baseline. ≥ 5.7
    
    
      titleOpacity
      Number
      Opacity of axis title. ≥ 4.1
    
    
      titlePadding
      Number | Value
      The padding in pixels between the axis labels and axis title.
    
    
      titleX
      Number
      Custom X position of the axis title relative to the axis group, overriding the standard layout.
    
    
      titleY
      Number
      Custom Y position of the axis title relative to the axis group, overriding the standard layout.
    
    
      translate
      Number
      Coordinate space translation offset for axis layout. By default, axes are translated by a 0.5 pixel offset for both the x and y coordinates in order to align stroked lines with the pixel grid. However, for vector graphics output these pixel-specific adjustments may be undesirable, in which case translate can be changed (for example, to zero). ≥ 5.8
    
    
      values
      Array
      Explicitly set the visible axis tick and label values. The array entries should be legal values in the backing scale domain.
    
    
      zindex
      Number
      The integer z-index indicating the layering of the axis group relative to other axis, mark, and legend groups. The default value is 0 and axes and grid lines are drawn behind any marks defined in the same specification level. Higher values (1) will cause axes and grid lines to be drawn on top of marks.
    
  


Accessibility Properties ≥ 5.11

Accessibility properties are used to determine ARIA (Accessible Rich Internet Applications) attributes when using Vega to render SVG output.


  
    
      Property
      Type
      Description
    
  
  
    
      aria
      Boolean
      A boolean flag (default true) indicating if ARIA attributes should be included (SVG output only). If false, the “aria-hidden” attribute will be set on the output SVG group, removing the axis from the ARIA accessibility tree.
    
    
      description
      String
      A text description of this axis for ARIA accessibility (SVG output only). If the aria property is true, for SVG output the “aria-label” attribute will be set to this description. If the description is unspecified it will be automatically generated.
    
  


Themes and Configuration

To create themes, new default values for many axis properties can be set using a config object.

Axis Orientation Reference

Valid settings for the axis orient parameter.


  
    
      Value
      Description
    
  
  
    
      left
      Place a y-axis along the left edge of the chart.
    
    
      right
      Place a y-axis along the right edge of the chart.
    
    
      top
      Place an x-axis along the top edge of the chart.
    
    
      bottom
      Place an x-axis along the bottom edge of the chart.
    
  


Custom Axis Encodings

Custom mark properties can be set for all axis elements using the encode parameter. The addressable elements are:


  axis for the axis group mark,
  ticks for tick rule marks,
  grid for gridline rule marks,
  labels for label text marks,
  title for the title text mark, and
  domain for the axis domain rule mark.


Each element accepts a set of visual encoding directives grouped into enter, update, exit, etc. objects as described in the Marks documentation. Mark properties can be styled using standard value references.

In addition, each encode block may include a string-valued name property to assign a unique name to the mark set, a boolean-valued interactive property to enable input event handling, and a string-valued (or array-valued) style property to apply default property values. Unless otherwise specified, title elements use a default style of "guide-title" and labels elements use a default style of "guide-label".

Each axis tick, grid line, and label instance is backed by a data object with the following fields, which may be accessed as part of a custom visual encoding rule.


  label - the string label
  value - the data value
  index - fractional tick index (0 for the first tick and 1 for the last tick)


The following example shows how to set custom colors, thickness, text angle, and fonts. The labels encoding block also make legend labels responsive to input events, and changes the text color on mouse hover.

"axes": [
  {
    "orient": "bottom",
    "scale": "x",
    "title": "X-Axis",
    "encode": {
      "ticks": {
        "update": {
          "stroke": {"value": "steelblue"}
        }
      },
      "labels": {
        "interactive": true,
        "update": {
          "text": {"signal": "format(datum.value, '+,')"},
          "fill": {"value": "steelblue"},
          "angle": {"value": 50},
          "fontSize": {"value": 14},
          "align": {"value": "left"},
          "baseline": {"value": "middle"},
          "dx": {"value": 3}
        },
        "hover": {
          "fill": {"value": "firebrick"}
        }
      },
      "title": {
        "update": {
          "fontSize": {"value": 16}
        }
      },
      "domain": {
        "update": {
          "stroke": {"value": "#333"},
          "strokeWidth": {"value": 1.5}
        }
      }
    }
  }
]


Custom text can be defined using the "text" property for labels. For example, one could define an ordinal scale that serves as a lookup table from axis values to axis label text.\nVega
            
              Vega-Lite
              Altair
              Vega-Lite API\nVega-Lite
              Altair
              Vega-Lite API\nExamples
              Tutorials
              Documentation
              Usage
              About
            
            
              GitHub
              Try Online\nExamples
              Tutorials
              Documentation
              Usage
              About\nGitHub
              Try Online\nDocumentation
      
      
      
      
        Specification
      
      
      
      
        Config
      
      
      
      
        Data
      
      
      
      
        Transforms
      
      
      
      
        Triggers
      
      
      
      
        Projections
      
      
      
      
        Scales
      
      
      
      
        Schemes
      
      
      
      
        Axes
      
      
      
      
        Legends
      
      
      
      
        Title
      
      
      
      
        Marks
      
      
      
      
        Signals
      
      
      
      
        Event Streams
      
      
      
      
        Expressions
      
      
      
      
        Layout
      
      
      
      
        Types
      
      
    
  
  
    Axes
    Axes visualize spatial scale mappings using ticks, grid lines and labels. Vega currently supports axes for Cartesian (rectangular) coordinates. Similar to scales, axes can be defined either at the top-level of the specification, or as part of a group mark.

Axis Properties

Properties for specifying a coordinate axis.


  
    
      Property
      Type
      Description
    
  
  
    
      scale
      String
      Required. The name of the scale backing the axis component.
    
    
      orient
      String
      Required. The orientation of the axis. See the axis orientation reference.
    
    
      bandPosition
      Number
      An interpolation fraction indicating where, for band scales, axis ticks should be positioned. A value of 0 places ticks at the left edge of their bands. A value of 0.5 places ticks in the middle of their bands.
    
    
      domain
      Boolean
      A boolean flag indicating if the domain (the axis baseline) should be included as part of the axis (default true).
    
    
      domainCap
      String
      The stroke cap for the axis domain line. One of "butt" (default), "round" or "square". ≥ 5.11
    
    
      domainColor
      Color
      Color of axis domain line.
    
    
      domainDash
      Number[ ]
      Stroke dash of axis domain lines (or [] for solid lines). ≥ 5.0
    
    
      domainDashOffset
      Number
      The pixel offset at which to start the domain dash array. ≥ 5.0
    
    
      domainOpacity
      Number
      Opacity of axis domain line. ≥ 4.1
    
    
      domainWidth
      Number
      Stroke width of axis domain line.
    
    
      encode      
      Object
      Optional mark encodings for custom axis styling. Supports encoding blocks for axis, ticks, grid, labels, title, and domain. See custom axis encodings.
    
    
      format
      String | TimeMultiFormat
      The format specifier pattern for axis labels. For numerical values, must be a legal d3-format specifier. For date-time values, must be a legal d3-time-format specifier or a TimeMultiFormat object.
    
    
      formatType
      String
      Specifies the type of format to use ("number", "time", "utc") for scales that do not have a strict domain data type. This property is useful for formatting date-time values for band or point scales. If specified, the format property must have a valid specifier pattern for the given type. Supported ≥ 5.1, UTC support ≥ 5.8.
    
    
      grid
      Boolean
      A boolean flag indicating if grid lines should be included as part of the axis (default false).
    
    
      gridCap
      String
      The stroke cap for axis grid lines. One of "butt" (default), "round" or "square". ≥ 5.11
    
    
      gridColor
      Color
      Color of axis grid lines.
    
    
      gridDash
      Number[ ]
      Stroke dash of axis grid lines (or [] for solid lines).
    
    
      gridDashOffset
      Number
      The pixel offset at which to start the grid dash array. ≥ 5.0
    
    
      gridOpacity
      Number
      Opacity of axis grid lines.
    
    
      gridScale
      String
      The name of the scale to use for including grid lines. By default grid lines are driven by the same scale as the ticks and labels.
    
    
      gridWidth
      Number
      Stroke width of axis grid lines.
    
    
      labels
      Boolean
      A boolean flag indicating if labels should be included as part of the axis (default true).
    
    
      labelAlign
      String
      Horizontal text alignment of axis tick labels, overriding the default setting for the current axis orientation.
    
    
      labelAngle
      Number
      Angle in degrees of axis tick labels.
    
    
      labelBaseline
      String
      Vertical text baseline of axis tick labels, overriding the default setting for the current axis orientation. One of alphabetic (default), top, middle, bottom, line-top, or line-bottom. The line-top and line-bottom values ≥ 5.10 operate similarly to top and bottom, but are calculated relative to the lineHeight rather than fontSize alone.
    
    
      labelBound
      Boolean | Number
      Indicates if labels should be hidden if they exceed the axis range. If false (the default) no bounds overlap analysis is performed. If true, labels will be hidden if they exceed the axis range by more than 1 pixel. If this property is a number, it specifies the pixel tolerance: the maximum amount by which a label bounding box may exceed the axis range.
    
    
      labelColor
      Color
      Text color of axis tick labels.
    
    
      labelFlush
      Boolean | Number
      Indicates if labels at the beginning or end of the axis should be aligned flush with the scale range. If a number, indicates a pixel distance threshold: labels with anchor coordinates within the threshold distance for an axis end-point will be flush-adjusted. If true, a default threshold of 1 pixel is used. Flush alignment for a horizontal axis will left-align labels near the beginning of the axis and right-align labels near the end. For vertical axes, bottom and top text baselines will be applied instead.
    
    
      labelFlushOffset
      Number
      Indicates the number of pixels by which to offset flush-adjusted labels (default 0). For example, a value of 2 will push flush-adjusted labels 2 pixels outward from the center of the axis. Offsets can help the labels better visually group with corresponding axis ticks.
    
    
      labelFont
      String
      Font name for axis tick labels.
    
    
      labelFontSize
      Number
      Font size of axis tick labels.
    
    
      labelFontStyle
      String
      Font style of axis tick labels (e.g., normal or italic). ≥ 5.0
    
    
      labelFontWeight
      String | Number
      Font weight of axis tick labels.
    
    
      labelLimit
      Number
      The maximum allowed length in pixels of axis tick labels.
    
    
      labelLineHeight
      Number
      Line height in pixels for multi-line label text or label text with "line-top" or "line-bottom" baseline. ≥ 5.10
    
    
      labelOffset
      Number
      Position offset in pixels to apply to labels, in addition to tickOffset. ≥ 5.10
    
    
      labelOpacity
      Number
      Opacity of axis tick labels. ≥ 4.1
    
    
      labelOverlap
      Boolean | String
      The strategy to use for resolving overlap of axis labels. If false (the default), no overlap reduction is attempted. If set to true or "parity", a strategy of removing every other label is used (this works well for standard linear axes). If set to "greedy", a linear scan of the labels is performed, removing any label that overlaps with the last visible label (this often works better for log-scaled axes).
    
    
      labelPadding
      Number
      The padding in pixels between labels and ticks.
    
    
      labelSeparation
      Number
      The minimum separation that must be between label bounding boxes for them to be considered non-overlapping (default 0). This property is ignored if labelOverlap resolution is not enabled. ≥ 5.0
    
    
      minExtent
      Number | Value
      The minimum extent in pixels that axis ticks and labels should use. This determines a minimum offset value for axis titles.
    
    
      maxExtent
      Number | Value
      The maximum extent in pixels that axis ticks and labels should use. This determines a maximum offset value for axis titles.
    
    
      offset
      Number | Value
      The orthogonal offset in pixels by which to displace the axis from its position along the edge of the chart.
    
    
      position
      Number | Value
      The anchor position of the axis in pixels (default 0). For x-axes with top or bottom orientation, this sets the axis group x coordinate. For y-axes with left or right orientation, this sets the axis group y coordinate.
    
    
      ticks
      Boolean
      A boolean flag indicating if ticks should be included as part of the axis (default true).
    
    
      tickBand
      String
      Indicates the type of tick style to use in conjunction with band scales. One of "center" (default) to center ticks in the middle of the band interval, or "extent" to place ticks at band extents (interval boundaries). If specified, this property may override the settings of bandPosition, tickExtra, and tickOffset. ≥ 5.8
    
    
      tickCap
      String
      The stroke cap for axis tick marks. One of "butt" (default), "round" or "square". ≥ 5.11
    
    
      tickColor
      Color
      Color of axis ticks.
    
    
      tickCount
      Number | String | Object
      A desired number of ticks, for axes visualizing quantitative scales. The resulting number may be different so that values are “nice” (multiples of 2, 5, 10) and lie within the underlying scale’s range. For scales of type time or utc, the tick count can instead be a time interval specifier. Legal string values are "millisecond", "second", "minute", "hour", "day", "week", "month", and "year". Alternatively, an object-valued interval specifier of the form {"interval": "month", "step": 3} includes a desired number of interval steps. Here, ticks are generated for each quarter (Jan, Apr, Jul, Oct) boundary.
    
    
      tickDash
      Number[ ]
      Stroke dash of axis tick marks (or [] for solid lines). ≥ 5.0
    
    
      tickDashOffset
      Number
      The pixel offset at which to start the tick mark dash array. ≥ 5.0
    
    
      tickMinStep
      Number
      The minimum desired step between axis ticks, in terms of scale domain values. For example, a value of 1 indicates that ticks should not be less than 1 unit apart. If tickMinStep is specified, the tickCount value will be adjusted, if necessary, to enforce the minimum step value. ≥ 5.0
    
    
      tickExtra
      Boolean
      Boolean flag indicating if an extra axis tick should be added for the initial position of the axis. This flag is useful for styling axes for band scales such that ticks are placed on band boundaries rather in the middle of a band. Use in conjunction with "bandPosition": 1 and an axis "padding" value of 0.
    
    
      tickOffset
      Number
      Position offset in pixels to apply to ticks, labels, and gridlines.
    
    
      tickOpacity
      Number
      Opacity of axis ticks. ≥ 4.1
    
    
      tickRound
      Boolean
      Boolean flag indicating if pixel position values should be rounded to the nearest integer.
    
    
      tickSize
      Number
      The length in pixels of axis ticks.
    
    
      tickWidth
      Number
      Width in pixels of axis ticks.
    
    
      title
      String | String[ ]
      A title for the axis (none by default). For versions ≥ 5.7, a string array specifies a title with multiple lines of text.
    
    
      titleAnchor
      String
      The anchor position for placing the axis title. One of "start", "middle", "end", or null (default, for automatic determination). For example, with an orient of "bottom" these anchor positions map to a left-, center-, or right-aligned title. The anchor point is determined relative to the axis scale range. ≥ 5.0
    
    
      titleAlign
      String
      Horizontal text alignment of the axis title. One of "left", "center", or "right". If specified, this value overrides automatic alignment based on the titleAnchor value.
    
    
      titleAngle
      Number
      Angle in degrees of the axis title.
    
    
      titleBaseline
      String
      Vertical text baseline of the axis title. One of alphabetic (default), top, middle, bottom, line-top, or line-bottom. The line-top and line-bottom values ≥ 5.10 operate similarly to top and bottom, but are calculated relative to the lineHeight rather than fontSize alone.
    
    
      titleColor
      Color
      Text color of the axis title.
    
    
      titleFont
      String
      Font name of the axis title.
    
    
      titleFontSize
      Number
      Font size of the axis title.
    
    
      titleFontStyle
      String
      Font style of the axis title (e.g., normal or italic). ≥ 5.0
    
    
      titleFontWeight
      String | Number
      Font weight of axis title.
    
    
      titleLimit
      Number
      The maximum allowed length in pixels of the axis title.
    
    
      titleLineHeight
      Number
      Line height in pixels for multi-line title text or title text with "line-top" or "line-bottom" baseline. ≥ 5.7
    
    
      titleOpacity
      Number
      Opacity of axis title. ≥ 4.1
    
    
      titlePadding
      Number | Value
      The padding in pixels between the axis labels and axis title.
    
    
      titleX
      Number
      Custom X position of the axis title relative to the axis group, overriding the standard layout.
    
    
      titleY
      Number
      Custom Y position of the axis title relative to the axis group, overriding the standard layout.
    
    
      translate
      Number
      Coordinate space translation offset for axis layout. By default, axes are translated by a 0.5 pixel offset for both the x and y coordinates in order to align stroked lines with the pixel grid. However, for vector graphics output these pixel-specific adjustments may be undesirable, in which case translate can be changed (for example, to zero). ≥ 5.8
    
    
      values
      Array
      Explicitly set the visible axis tick and label values. The array entries should be legal values in the backing scale domain.
    
    
      zindex
      Number
      The integer z-index indicating the layering of the axis group relative to other axis, mark, and legend groups. The default value is 0 and axes and grid lines are drawn behind any marks defined in the same specification level. Higher values (1) will cause axes and grid lines to be drawn on top of marks.
    
  


Accessibility Properties ≥ 5.11

Accessibility properties are used to determine ARIA (Accessible Rich Internet Applications) attributes when using Vega to render SVG output.


  
    
      Property
      Type
      Description
    
  
  
    
      aria
      Boolean
      A boolean flag (default true) indicating if ARIA attributes should be included (SVG output only). If false, the “aria-hidden” attribute will be set on the output SVG group, removing the axis from the ARIA accessibility tree.
    
    
      description
      String
      A text description of this axis for ARIA accessibility (SVG output only). If the aria property is true, for SVG output the “aria-label” attribute will be set to this description. If the description is unspecified it will be automatically generated.
    
  


Themes and Configuration

To create themes, new default values for many axis properties can be set using a config object.

Axis Orientation Reference

Valid settings for the axis orient parameter.


  
    
      Value
      Description
    
  
  
    
      left
      Place a y-axis along the left edge of the chart.
    
    
      right
      Place a y-axis along the right edge of the chart.
    
    
      top
      Place an x-axis along the top edge of the chart.
    
    
      bottom
      Place an x-axis along the bottom edge of the chart.
    
  


Custom Axis Encodings

Custom mark properties can be set for all axis elements using the encode parameter. The addressable elements are:


  axis for the axis group mark,
  ticks for tick rule marks,
  grid for gridline rule marks,
  labels for label text marks,
  title for the title text mark, and
  domain for the axis domain rule mark.


Each element accepts a set of visual encoding directives grouped into enter, update, exit, etc. objects as described in the Marks documentation. Mark properties can be styled using standard value references.

In addition, each encode block may include a string-valued name property to assign a unique name to the mark set, a boolean-valued interactive property to enable input event handling, and a string-valued (or array-valued) style property to apply default property values. Unless otherwise specified, title elements use a default style of "guide-title" and labels elements use a default style of "guide-label".

Each axis tick, grid line, and label instance is backed by a data object with the following fields, which may be accessed as part of a custom visual encoding rule.


  label - the string label
  value - the data value
  index - fractional tick index (0 for the first tick and 1 for the last tick)


The following example shows how to set custom colors, thickness, text angle, and fonts. The labels encoding block also make legend labels responsive to input events, and changes the text color on mouse hover.

"axes": [
  {
    "orient": "bottom",
    "scale": "x",
    "title": "X-Axis",
    "encode": {
      "ticks": {
        "update": {
          "stroke": {"value": "steelblue"}
        }
      },
      "labels": {
        "interactive": true,
        "update": {
          "text": {"signal": "format(datum.value, '+,')"},
          "fill": {"value": "steelblue"},
          "angle": {"value": 50},
          "fontSize": {"value": 14},
          "align": {"value": "left"},
          "baseline": {"value": "middle"},
          "dx": {"value": 3}
        },
        "hover": {
          "fill": {"value": "firebrick"}
        }
      },
      "title": {
        "update": {
          "fontSize": {"value": 16}
        }
      },
      "domain": {
        "update": {
          "stroke": {"value": "#333"},
          "strokeWidth": {"value": 1.5}
        }
      }
    }
  }
]


Custom text can be defined using the "text" property for labels. For example, one could define an ordinal scale that serves as a lookup table from axis values to axis label text.\nAxes visualize spatial scale mappings using ticks, grid lines and labels. Vega currently supports axes for Cartesian (rectangular) coordinates. Similar to scales, axes can be defined either at the top-level of the specification, or as part of a group mark.\nProperties for specifying a coordinate axis.\nRequired. The name of the scale backing the axis component.\nRequired. The orientation of the axis. See the axis orientation reference.\naxis orientation reference\nAn interpolation fraction indicating where, for band scales, axis ticks should be positioned. A value of 0 places ticks at the left edge of their bands. A value of 0.5 places ticks in the middle of their bands.\nA boolean flag indicating if the domain (the axis baseline) should be included as part of the axis (default true).\nThe stroke cap for the axis domain line. One of "butt" (default), "round" or "square". ≥ 5.11\nColor of axis domain line.\nStroke dash of axis domain lines (or [] for solid lines). ≥ 5.0\nThe pixel offset at which to start the domain dash array. ≥ 5.0\nOpacity of axis domain line. ≥ 4.1\nStroke width of axis domain line.\nOptional mark encodings for custom axis styling. Supports encoding blocks for axis, ticks, grid, labels, title, and domain. See custom axis encodings.\ncustom axis encodings\nString | TimeMultiFormat\nThe format specifier pattern for axis labels. For numerical values, must be a legal d3-format specifier. For date-time values, must be a legal d3-time-format specifier or a TimeMultiFormat object.\nTimeMultiFormat object\nSpecifies the type of format to use ("number", "time", "utc") for scales that do not have a strict domain data type. This property is useful for formatting date-time values for band or point scales. If specified, the format property must have a valid specifier pattern for the given type. Supported ≥ 5.1, UTC support ≥ 5.8.\nA boolean flag indicating if grid lines should be included as part of the axis (default false).\nThe stroke cap for axis grid lines. One of "butt" (default), "round" or "square". ≥ 5.11\nColor of axis grid lines.\nStroke dash of axis grid lines (or [] for solid lines).\nThe pixel offset at which to start the grid dash array. ≥ 5.0\nOpacity of axis grid lines.\nThe name of the scale to use for including grid lines. By default grid lines are driven by the same scale as the ticks and labels.\nStroke width of axis grid lines.\nA boolean flag indicating if labels should be included as part of the axis (default true).\nHorizontal text alignment of axis tick labels, overriding the default setting for the current axis orientation.\nAngle in degrees of axis tick labels.\nVertical text baseline of axis tick labels, overriding the default setting for the current axis orientation. One of alphabetic (default), top, middle, bottom, line-top, or line-bottom. The line-top and line-bottom values ≥ 5.10 operate similarly to top and bottom, but are calculated relative to the lineHeight rather than fontSize alone.\nIndicates if labels should be hidden if they exceed the axis range. If false (the default) no bounds overlap analysis is performed. If true, labels will be hidden if they exceed the axis range by more than 1 pixel. If this property is a number, it specifies the pixel tolerance: the maximum amount by which a label bounding box may exceed the axis range.\nText color of axis tick labels.\nIndicates if labels at the beginning or end of the axis should be aligned flush with the scale range. If a number, indicates a pixel distance threshold: labels with anchor coordinates within the threshold distance for an axis end-point will be flush-adjusted. If true, a default threshold of 1 pixel is used. Flush alignment for a horizontal axis will left-align labels near the beginning of the axis and right-align labels near the end. For vertical axes, bottom and top text baselines will be applied instead.\nIndicates the number of pixels by which to offset flush-adjusted labels (default 0). For example, a value of 2 will push flush-adjusted labels 2 pixels outward from the center of the axis. Offsets can help the labels better visually group with corresponding axis ticks.\nFont name for axis tick labels.\nFont size of axis tick labels.\nFont style of axis tick labels (e.g., normal or italic). ≥ 5.0\nFont weight of axis tick labels.\nThe maximum allowed length in pixels of axis tick labels.\nLine height in pixels for multi-line label text or label text with "line-top" or "line-bottom" baseline. ≥ 5.10\nPosition offset in pixels to apply to labels, in addition to tickOffset. ≥ 5.10\nOpacity of axis tick labels. ≥ 4.1\nThe strategy to use for resolving overlap of axis labels. If false (the default), no overlap reduction is attempted. If set to true or "parity", a strategy of removing every other label is used (this works well for standard linear axes). If set to "greedy", a linear scan of the labels is performed, removing any label that overlaps with the last visible label (this often works better for log-scaled axes).\nThe padding in pixels between labels and ticks.\nThe minimum separation that must be between label bounding boxes for them to be considered non-overlapping (default 0). This property is ignored if labelOverlap resolution is not enabled. ≥ 5.0\nThe minimum extent in pixels that axis ticks and labels should use. This determines a minimum offset value for axis titles.\nThe maximum extent in pixels that axis ticks and labels should use. This determines a maximum offset value for axis titles.\nThe orthogonal offset in pixels by which to displace the axis from its position along the edge of the chart.\nThe anchor position of the axis in pixels (default 0). For x-axes with top or bottom orientation, this sets the axis group x coordinate. For y-axes with left or right orientation, this sets the axis group y coordinate.\nA boolean flag indicating if ticks should be included as part of the axis (default true).\nIndicates the type of tick style to use in conjunction with band scales. One of "center" (default) to center ticks in the middle of the band interval, or "extent" to place ticks at band extents (interval boundaries). If specified, this property may override the settings of bandPosition, tickExtra, and tickOffset. ≥ 5.8\nThe stroke cap for axis tick marks. One of "butt" (default), "round" or "square". ≥ 5.11\nNumber | String | Object\nA desired number of ticks, for axes visualizing quantitative scales. The resulting number may be different so that values are “nice” (multiples of 2, 5, 10) and lie within the underlying scale’s range. For scales of type time or utc, the tick count can instead be a time interval specifier. Legal string values are "millisecond", "second", "minute", "hour", "day", "week", "month", and "year". Alternatively, an object-valued interval specifier of the form {"interval": "month", "step": 3} includes a desired number of interval steps. Here, ticks are generated for each quarter (Jan, Apr, Jul, Oct) boundary.\nStroke dash of axis tick marks (or [] for solid lines). ≥ 5.0\nThe pixel offset at which to start the tick mark dash array. ≥ 5.0\nThe minimum desired step between axis ticks, in terms of scale domain values. For example, a value of 1 indicates that ticks should not be less than 1 unit apart. If tickMinStep is specified, the tickCount value will be adjusted, if necessary, to enforce the minimum step value. ≥ 5.0\nBoolean flag indicating if an extra axis tick should be added for the initial position of the axis. This flag is useful for styling axes for band scales such that ticks are placed on band boundaries rather in the middle of a band. Use in conjunction with "bandPosition": 1 and an axis "padding" value of 0.\nPosition offset in pixels to apply to ticks, labels, and gridlines.\nOpacity of axis ticks. ≥ 4.1\nBoolean flag indicating if pixel position values should be rounded to the nearest integer.\nThe length in pixels of axis ticks.\nWidth in pixels of axis ticks.\nA title for the axis (none by default). For versions ≥ 5.7, a string array specifies a title with multiple lines of text.\nThe anchor position for placing the axis title. One of "start", "middle", "end", or null (default, for automatic determination). For example, with an orient of "bottom" these anchor positions map to a left-, center-, or right-aligned title. The anchor point is determined relative to the axis scale range. ≥ 5.0\nHorizontal text alignment of the axis title. One of "left", "center", or "right". If specified, this value overrides automatic alignment based on the titleAnchor value.\nAngle in degrees of the axis title.\nVertical text baseline of the axis title. One of alphabetic (default), top, middle, bottom, line-top, or line-bottom. The line-top and line-bottom values ≥ 5.10 operate similarly to top and bottom, but are calculated relative to the lineHeight rather than fontSize alone.\nText color of the axis title.\nFont name of the axis title.\nFont size of the axis title.\nFont style of the axis title (e.g., normal or italic). ≥ 5.0\nFont weight of axis title.\nThe maximum allowed length in pixels of the axis title.\nLine height in pixels for multi-line title text or title text with "line-top" or "line-bottom" baseline. ≥ 5.7\nOpacity of axis title. ≥ 4.1\nThe padding in pixels between the axis labels and axis title.\nCustom X position of the axis title relative to the axis group, overriding the standard layout.\nCustom Y position of the axis title relative to the axis group, overriding the standard layout.\nCoordinate space translation offset for axis layout. By default, axes are translated by a 0.5 pixel offset for both the x and y coordinates in order to align stroked lines with the pixel grid. However, for vector graphics output these pixel-specific adjustments may be undesirable, in which case translate can be changed (for example, to zero). ≥ 5.8\nExplicitly set the visible axis tick and label values. The array entries should be legal values in the backing scale domain.\nThe integer z-index indicating the layering of the axis group relative to other axis, mark, and legend groups. The default value is 0 and axes and grid lines are drawn behind any marks defined in the same specification level. Higher values (1) will cause axes and grid lines to be drawn on top of marks.\nAccessibility Properties ≥ 5.11\nAccessibility properties are used to determine ARIA (Accessible Rich Internet Applications) attributes when using Vega to render SVG output.\nARIA (Accessible Rich Internet Applications) attributes\nA boolean flag (default true) indicating if ARIA attributes should be included (SVG output only). If false, the “aria-hidden” attribute will be set on the output SVG group, removing the axis from the ARIA accessibility tree.\nA text description of this axis for ARIA accessibility (SVG output only). If the aria property is true, for SVG output the “aria-label” attribute will be set to this description. If the description is unspecified it will be automatically generated.\n“aria-label” attribute\nThemes and Configuration\nTo create themes, new default values for many axis properties can be set using a config object.\nAxis Orientation Reference\nValid settings for the axis orient parameter.\nPlace a y-axis along the left edge of the chart.\nPlace a y-axis along the right edge of the chart.\nPlace an x-axis along the top edge of the chart.\nPlace an x-axis along the bottom edge of the chart.\nCustom Axis Encodings\nCustom mark properties can be set for all axis elements using the encode parameter. The addressable elements are:\naxis for the axis group mark,\nticks for tick rule marks,\ngrid for gridline rule marks,\nlabels for label text marks,\ntitle for the title text mark, and\ndomain for the axis domain rule mark.\nEach element accepts a set of visual encoding directives grouped into enter, update, exit, etc. objects as described in the Marks documentation. Mark properties can be styled using standard value references.\nIn addition, each encode block may include a string-valued name property to assign a unique name to the mark set, a boolean-valued interactive property to enable input event handling, and a string-valued (or array-valued) style property to apply default property values. Unless otherwise specified, title elements use a default style of "guide-title" and labels elements use a default style of "guide-label".\nEach axis tick, grid line, and label instance is backed by a data object with the following fields, which may be accessed as part of a custom visual encoding rule.\nlabel - the string label\nvalue - the data value\nindex - fractional tick index (0 for the first tick and 1 for the last tick)\nThe following example shows how to set custom colors, thickness, text angle, and fonts. The labels encoding block also make legend labels responsive to input events, and changes the text color on mouse hover.\n"axes": [
  {
    "orient": "bottom",
    "scale": "x",
    "title": "X-Axis",
    "encode": {
      "ticks": {
        "update": {
          "stroke": {"value": "steelblue"}
        }
      },
      "labels": {
        "interactive": true,
        "update": {
          "text": {"signal": "format(datum.value, '+,')"},
          "fill": {"value": "steelblue"},
          "angle": {"value": 50},
          "fontSize": {"value": 14},
          "align": {"value": "left"},
          "baseline": {"value": "middle"},
          "dx": {"value": 3}
        },
        "hover": {
          "fill": {"value": "firebrick"}
        }
      },
      "title": {
        "update": {
          "fontSize": {"value": 16}
        }
      },
      "domain": {
        "update": {
          "stroke": {"value": "#333"},
          "strokeWidth": {"value": 1.5}
        }
      }
    }
  }
]\n"axes": [
  {
    "orient": "bottom",
    "scale": "x",
    "title": "X-Axis",
    "encode": {
      "ticks": {
        "update": {
          "stroke": {"value": "steelblue"}
        }
      },
      "labels": {
        "interactive": true,
        "update": {
          "text": {"signal": "format(datum.value, '+,')"},
          "fill": {"value": "steelblue"},
          "angle": {"value": 50},
          "fontSize": {"value": 14},
          "align": {"value": "left"},
          "baseline": {"value": "middle"},
          "dx": {"value": 3}
        },
        "hover": {
          "fill": {"value": "firebrick"}
        }
      },
      "title": {
        "update": {
          "fontSize": {"value": 16}
        }
      },
      "domain": {
        "update": {
          "stroke": {"value": "#333"},
          "strokeWidth": {"value": 1.5}
        }
      }
    }
  }
]\n"format(datum.value, '+,')"\nCustom text can be defined using the "text" property for labels. For example, one could define an ordinal scale that serves as a lookup table from axis values to axis label text.\n\n\nVega
            
              Vega-Lite
              Altair
              Vega-Lite API
            
          
          
            
              Examples
              Tutorials
              Documentation
              Usage
              About
            
            
              GitHub
              Try Online
            
          
        
      

      
        

  
  
    
      
      
        Documentation
      
      
      
      
        Specification
      
      
      
      
        Config
      
      
      
      
        Data
      
      
      
      
        Transforms
      
      
      
      
        Triggers
      
      
      
      
        Projections
      
      
      
      
        Scales
      
      
      
      
        Schemes
      
      
      
      
        Axes
      
      
      
      
        Legends
      
      
      
      
        Title
      
      
      
      
        Marks
      
      
      
      
        Signals
      
      
      
      
        Event Streams
      
      
      
      
        Expressions
      
      
      
      
        Layout
      
      
      
      
        Types
      
      
    
  
  
    Legends
    Legends visualize scale mappings for visual values such as color, shape and size. Similar to scales and axes, legends can be defined either at the top-level visualization, or within the scope of a group mark.

Legend Properties

Properties for specifying a legend. Legends accept one or more scales as parameters. At least one of the size, shape, fill, stroke, strokeDash, or opacity properties must be specified. If multiple scales are provided, they must share the same domain of input vales. Otherwise, the behavior of the legend is undefined.


  
    
      Property
      Type
      Description
    
  
  
    
      type
      String
      The type of legend to include. One of "symbol" for discrete symbol legends, "gradient" for a continuous color gradient, or "discrete" for a discrete color gradient. If gradient or discrete are used, only the fill or stroke scale parameters are considered. If unspecified, the type will be inferred based on the scale parameters used and their backing scale types.
    
    
      direction
      String
      The direction of the legend, one of "vertical" (default) or "horizontal".
    
    
      orient
      String
      The orientation of the legend, determining where the legend is placed relative to a chart’s data rectangle (default right). See the legend orientation reference.
    
    
      fill
      String
      The name of a scale that maps to a fill color.
    
    
      opacity
      String
      The name of a scale that maps to an opacity value.
    
    
      shape
      String
      The name of a scale that maps to a shape value.
    
    
      size
      String
      The name of a scale that maps to a size (area) value.
    
    
      stroke
      String
      The name of a scale that maps to a stroke color.
    
    
      strokeDash
      String
      The name of a scale that maps to a stroke dash value.
    
    
      strokeWidth
      String
      The name of a scale that maps to a stroke width value. ≥ 5.0
    
    
      encode
      Object
      Optional mark encodings for custom legend styling. Supports encoding blocks for legend, title, entries, labels, symbols and gradient. See custom legend encodings.
    
    
      format
      String | TimeMultiFormat
      The format specifier pattern for legend labels. For numerical values, must be a legal d3-format specifier. For date-time values, must be a legal d3-time-format specifier or a TimeMultiFormat object.
    
    
      formatType
      String
      Specifies the type of format to use ("number", "time", "utc") for scales that do not have a strict domain data type. This property is useful for formatting date-time values for ordinal scales. If specified, the format property must have a valid specifier pattern for the given type. Supported ≥ 5.1, UTC support ≥ 5.8.
    
    
      gridAlign
      String
      The alignment to apply to symbol legends rows and columns. The supported string values are all, each (the default), and none. For more information, see the grid layout documentation.
    
    
      clipHeight
      Number
      The height in pixels to clip symbol legend entries and limit their size. By default no clipping is performed.
    
    
      columns
      Number
      The number of columns in which to arrange symbol legend entries. A value of 0 or lower indicates a single row with one column per entry. The default is 0 for horizontal symbol legends and 1 for vertical symbol legends.
    
    
      columnPadding
      Number
      The horizontal padding in pixels between symbol legend entries.
    
    
      rowPadding
      Number
      The vertical padding in pixels between symbol legend entries.
    
    
      cornerRadius
      Number
      Corner radius for the full legend.
    
    
      fillColor
      Color
      Background fill color for the full legend.
    
    
      offset
      Number | Value
      The offset in pixels by which to displace the legend from the data rectangle and axes. If provided, this value will override any values specified in the legend config. If multiple offset values are specified for a collection of legends with the same orient value, the maximum offset will be used.
    
    
      padding
      Number | Value
      The padding between the border and content of the legend group.
    
    
      strokeColor
      Color
      Border stroke color for the full legend.
    
    
      gradientLength
      Number
      The length in pixels of the primary axis of a color gradient. This value corresponds to the height of a vertical gradient or the width of a horizontal gradient.
    
    
      gradientOpacity
      Number
      Opacity of the color gradient. ≥ 4.1
    
    
      gradientThickness
      Number
      The thickness in pixels of the color gradient. This value corresponds to the width of a vertical gradient or the height of a horizontal gradient.
    
    
      gradientStrokeColor
      Color
      Stroke color of the color gradient border.
    
    
      gradientStrokeWidth
      Number
      Stroke width of the color gradient border.
    
    
      labelAlign
      String
      Horizontal text alignment for legend labels.
    
    
      labelBaseline
      String
      Vertical text baseline for legend labels. One of alphabetic (default), top, middle, bottom, line-top, or line-bottom. The line-top and line-bottom values ≥ 5.10 operate similarly to top and bottom, but are calculated relative to the lineHeight rather than fontSize alone.
    
    
      labelColor
      Color
      Text color for legend labels.
    
    
      labelFont
      String
      Font name for legend labels.
    
    
      labelFontSize
      Number
      Font size in pixels for legend labels.
    
    
      labelFontStyle
      String
      Font style of legend labels (e.g., normal or italic). ≥ 5.0
    
    
      labelFontWeight
      String | Number
      Font weight of legend labels.
    
    
      labelLimit
      Number
      The maximum allowed length in pixels of legend labels.
    
    
      labelOffset
      Number
      Offset in pixels between legend labels their corresponding symbol or gradient.
    
    
      labelOpacity
      Number
      Opacity of legend labels. ≥ 4.1
    
    
      labelOverlap
      Boolean | String
      The strategy to use for resolving overlap of labels in gradient legends. If false, no overlap reduction is attempted. If set to true (default) or "parity", a strategy of removing every other label is used. If set to "greedy", a linear scan of the labels is performed, removing any label that overlaps with the last visible label.
    
    
      labelSeparation
      Number
      The minimum separation that must be between label bounding boxes for them to be considered non-overlapping (default 0). This property is ignored if labelOverlap resolution is not enabled. ≥ 5.0
    
    
      legendX
      Number
      The pixel x-coordinate of the legend group. Only applied if the orient value is "none". ≥ 5.4
    
    
      legendY
      Number
      The pixel y-coordinate of the legend group. Only applied if the orient value is "none". ≥ 5.4
    
    
      symbolDash
      Number[ ]
      Stroke dash of symbol outlines (or [] for solid lines). ≥ 5.0
    
    
      symbolDashOffset
      Number
      The pixel offset at which to start the symbol dash array. ≥ 5.0
    
    
      symbolFillColor
      Color
      Fill color for legend symbols.
    
    
      symbolLimit
      Number
      The maximum number of allowed entries for a symbol legend. If the number of entries exceeds the limit, entries will be dropped and replaced with an ellipsis. ≥ 5.7
    
    
      symbolOffset
      Number
      Horizontal pixel offset for legend symbols.
    
    
      symbolOpacity
      Number
      Opacity of legend symbols. ≥ 4.1
    
    
      symbolSize
      Number
      Default symbol area size (in pixels2).
    
    
      symbolStrokeColor
      Color
      Stroke color for legend symbols.
    
    
      symbolStrokeWidth
      Number
      Default legend symbol stroke width.
    
    
      symbolType
      String
      Default symbol mark shape type (such as "circle") for legend symbols.
    
    
      tickCount
      Number | String | Object
      The desired number of tick values for quantitative legends. For scales of type time or utc, the tick count can instead be a time interval specifier. Legal string values are "millisecond", "second", "minute", "hour", "day", "week", "month", and "year". Alternatively, an object-valued interval specifier of the form {"interval": "month", "step": 3} includes a desired number of interval steps. Here, ticks are generated for each quarter (Jan, Apr, Jul, Oct) boundary.
    
    
      tickMinStep
      Number
      The minimum desired step between tick values for quantitative legends, in terms of scale domain values. For example, a value of 1 indicates that ticks should not be less than 1 unit apart. If tickMinStep is specified, the tickCount value will be adjusted, if necessary, to enforce the minimum step value. ≥ 5.0
    
    
      title
      String | String[ ]
      The title for the legend (none by default). For versions ≥ 5.7, a string array specifies a title with multiple lines of text.
    
    
      titleAnchor
      String
      The anchor position for placing the legend title. One of "start", "middle", "end", or null (default, for automatic determination). For example, with a titleOrient of "top" these anchor positions map to a left-, center-, or right-aligned title relative to the legend contents. ≥ 5.0
    
    
      titleAlign
      String
      Horizontal text alignment of the legend title. One of "left", "center", or "right". If specified, this value overrides automatic alignment based on the titleOrient and titleAnchor values.
    
    
      titleBaseline
      String
      Vertical text baseline of the legend title. One of alphabetic (default), top, middle, bottom, line-top, or line-bottom. The line-top and line-bottom values ≥ 5.10 operate similarly to top and bottom, but are calculated relative to the lineHeight rather than fontSize alone. If specified, this value overrides the automatic baseline based on the titleOrient and titleAnchor values.
    
    
      titleColor
      Color
      Text color of the legend title.
    
    
      titleFont
      String
      Font name of the legend title.
    
    
      titleFontSize
      Number
      Font size in pixels of the legend title.
    
    
      titleFontStyle
      String
      Font style of the legend title (e.g., normal or italic). ≥ 5.0
    
    
      titleFontWeight
      String | Number
      Font weight of the legend title.
    
    
      titleLimit
      Number
      The maximum allowed length in pixels of the legend title.
    
    
      titleLineHeight
      Number
      Line height in pixels for multi-line title text or title text with "line-top" or "line-bottom" baseline. ≥ 5.7
    
    
      titleOpacity
      Number
      Opacity of the legend title. ≥ 4.1
    
    
      titleOrient
      String
      The orientation of the title legend, determining where it is placed relative to the legend contents. One of "top" (default), "left", "bottom", or "right". ≥ 5.0
    
    
      titlePadding
      Number | Value
      The padding between the legend title and entries.
    
    
      values
      Array
      Explicitly set the visible legend values. The array entries should be legal values in the backing scale domain.
    
    
      zindex
      Number
      The integer z-index indicating the layering of the legend group relative to other axis, mark, and legend groups. The default value is 0.
    
  


Accessibility Properties ≥ 5.11

Accessibility properties are used to determine ARIA (Accessible Rich Internet Applications) attributes when using Vega to render SVG output.


  
    
      Property
      Type
      Description
    
  
  
    
      aria
      Boolean
      A boolean flag (default true) indicating if ARIA attributes should be included (SVG output only). If false, the “aria-hidden” attribute will be set on the output SVG group, removing the legend from the ARIA accessibility tree.
    
    
      description
      String
      A text description of this legend for ARIA accessibility (SVG output only). If the aria property is true, for SVG output the “aria-label” attribute will be set to this description. If the description is unspecified it will be automatically generated.
    
  


Themes and Configuration

To create themes, new default values for legend properties can be set using a config object. The config object also supports customized layout behavior for collections of legends with the same orient value.

Legend Orientation Reference

Valid settings for the legend orient parameter.


  
    
      Value
      Description
    
  
  
    
      left
      Place the legend to the left of the chart.
    
    
      right
      Place the legend to the right of the chart.
    
    
      top
      Place the legend above the top of the chart.
    
    
      bottom
      Place the legend below the bottom of the chart.
    
    
      top-left
      Place the legend inside the upper left corner of the chart.
    
    
      top-right
      Place the legend inside the upper right corner of the chart.
    
    
      bottom-left
      Place the legend inside the lower left corner of the chart.
    
    
      bottom-right
      Place the legend inside the lower right corner of the chart.
    
    
      none
      Do not perform automatic layout. Allows custom layout by setting the legendX and legendY properties of the legend.
    
  


Multiple legends: If multiple legends have a left or right orientation, they will be vertically ordered by default. If multiple legends have a top or bottom orientation, they will be horizontally ordered by default. In all other cases, legends will be drawn on top of each other when placed in the same location. The multiple legend layout can be customized by setting the legend layout config.

Legend offset: In the case of left, right, top and bottom orientation, the offset parameter determines how far away the legend is placed from the rest of the chart. If the orientation is none, the offset parameter is ignored. For all other settings, the offset determines the distance the legend is moved inward from a corner of the data rectangle.

Custom Legend Encodings

Custom mark properties can be set for all legend elements using the encode parameter. The addressable elements are:


  legend for the legend group mark,
  title for the title text mark,
  labels for label text marks,
  symbols for legend symbol marks,
  entries for symbol legend group marks containing a symbol / label pair, and
  gradient for a gradient rect marks: one rect with gradient fill for continuous gradient legends, multiple rect marks with solid fill for discrete gradient legends.


Each element accepts a set of visual encoding directives grouped into enter, update, exit, etc. objects as described in the Marks documentation. Mark properties can be styled using standard value references.

In addition, each encode block may include a string-valued name property to assign a unique name to the mark set, a boolean-valued interactive property to enable input event handling, and a string-valued (or array-valued) style property to apply default property values. Unless otherwise specified, title elements use a default style of "guide-title" and labels elements use a default style of "guide-label".

Each legend symbol and label instance is backed by a data object with the following fields, which may be accessed as part of a custom visual encoding rule:


  index - an integer index
  label - the string label
  value - the data value
  size - the symbol size (for symbol legends only)


The following example shows how to set custom fonts and a border on a legend for a fill color encoding. The labels encoding block also make legend labels responsive to input events, and changes the text color on mouse hover.

"legends": [
  {
    "fill": "color",
    "encode": {
      "title": {
        "update": {
          "fontSize": {"value": 14}
        }
      },
      "labels": {
        "interactive": true,
        "update": {
          "fontSize": {"value": 12},
          "fill": {"value": "black"}
        },
        "hover": {
          "fill": {"value": "firebrick"}
        }
      },
      "symbols": {
        "update": {
          "stroke": {"value": "transparent"}
        }
      },
      "legend": {
        "update": {
          "stroke": {"value": "#ccc"},
          "strokeWidth": {"value": 1.5}
        }
      }
    }
  }
]


Custom text can be defined using the text property for labels. For example, one could define an ordinal scale that serves as a lookup table from a backing value to legend label text. Note: to perform custom positioning when orient is none, use the top-level legendX and legendY properties, do not use x and y properties within a custom encoding block.\nVega
            
              Vega-Lite
              Altair
              Vega-Lite API\nVega-Lite
              Altair
              Vega-Lite API\nExamples
              Tutorials
              Documentation
              Usage
              About
            
            
              GitHub
              Try Online\nExamples
              Tutorials
              Documentation
              Usage
              About\nGitHub
              Try Online\nDocumentation
      
      
      
      
        Specification
      
      
      
      
        Config
      
      
      
      
        Data
      
      
      
      
        Transforms
      
      
      
      
        Triggers
      
      
      
      
        Projections
      
      
      
      
        Scales
      
      
      
      
        Schemes
      
      
      
      
        Axes
      
      
      
      
        Legends
      
      
      
      
        Title
      
      
      
      
        Marks
      
      
      
      
        Signals
      
      
      
      
        Event Streams
      
      
      
      
        Expressions
      
      
      
      
        Layout
      
      
      
      
        Types
      
      
    
  
  
    Legends
    Legends visualize scale mappings for visual values such as color, shape and size. Similar to scales and axes, legends can be defined either at the top-level visualization, or within the scope of a group mark.

Legend Properties

Properties for specifying a legend. Legends accept one or more scales as parameters. At least one of the size, shape, fill, stroke, strokeDash, or opacity properties must be specified. If multiple scales are provided, they must share the same domain of input vales. Otherwise, the behavior of the legend is undefined.


  
    
      Property
      Type
      Description
    
  
  
    
      type
      String
      The type of legend to include. One of "symbol" for discrete symbol legends, "gradient" for a continuous color gradient, or "discrete" for a discrete color gradient. If gradient or discrete are used, only the fill or stroke scale parameters are considered. If unspecified, the type will be inferred based on the scale parameters used and their backing scale types.
    
    
      direction
      String
      The direction of the legend, one of "vertical" (default) or "horizontal".
    
    
      orient
      String
      The orientation of the legend, determining where the legend is placed relative to a chart’s data rectangle (default right). See the legend orientation reference.
    
    
      fill
      String
      The name of a scale that maps to a fill color.
    
    
      opacity
      String
      The name of a scale that maps to an opacity value.
    
    
      shape
      String
      The name of a scale that maps to a shape value.
    
    
      size
      String
      The name of a scale that maps to a size (area) value.
    
    
      stroke
      String
      The name of a scale that maps to a stroke color.
    
    
      strokeDash
      String
      The name of a scale that maps to a stroke dash value.
    
    
      strokeWidth
      String
      The name of a scale that maps to a stroke width value. ≥ 5.0
    
    
      encode
      Object
      Optional mark encodings for custom legend styling. Supports encoding blocks for legend, title, entries, labels, symbols and gradient. See custom legend encodings.
    
    
      format
      String | TimeMultiFormat
      The format specifier pattern for legend labels. For numerical values, must be a legal d3-format specifier. For date-time values, must be a legal d3-time-format specifier or a TimeMultiFormat object.
    
    
      formatType
      String
      Specifies the type of format to use ("number", "time", "utc") for scales that do not have a strict domain data type. This property is useful for formatting date-time values for ordinal scales. If specified, the format property must have a valid specifier pattern for the given type. Supported ≥ 5.1, UTC support ≥ 5.8.
    
    
      gridAlign
      String
      The alignment to apply to symbol legends rows and columns. The supported string values are all, each (the default), and none. For more information, see the grid layout documentation.
    
    
      clipHeight
      Number
      The height in pixels to clip symbol legend entries and limit their size. By default no clipping is performed.
    
    
      columns
      Number
      The number of columns in which to arrange symbol legend entries. A value of 0 or lower indicates a single row with one column per entry. The default is 0 for horizontal symbol legends and 1 for vertical symbol legends.
    
    
      columnPadding
      Number
      The horizontal padding in pixels between symbol legend entries.
    
    
      rowPadding
      Number
      The vertical padding in pixels between symbol legend entries.
    
    
      cornerRadius
      Number
      Corner radius for the full legend.
    
    
      fillColor
      Color
      Background fill color for the full legend.
    
    
      offset
      Number | Value
      The offset in pixels by which to displace the legend from the data rectangle and axes. If provided, this value will override any values specified in the legend config. If multiple offset values are specified for a collection of legends with the same orient value, the maximum offset will be used.
    
    
      padding
      Number | Value
      The padding between the border and content of the legend group.
    
    
      strokeColor
      Color
      Border stroke color for the full legend.
    
    
      gradientLength
      Number
      The length in pixels of the primary axis of a color gradient. This value corresponds to the height of a vertical gradient or the width of a horizontal gradient.
    
    
      gradientOpacity
      Number
      Opacity of the color gradient. ≥ 4.1
    
    
      gradientThickness
      Number
      The thickness in pixels of the color gradient. This value corresponds to the width of a vertical gradient or the height of a horizontal gradient.
    
    
      gradientStrokeColor
      Color
      Stroke color of the color gradient border.
    
    
      gradientStrokeWidth
      Number
      Stroke width of the color gradient border.
    
    
      labelAlign
      String
      Horizontal text alignment for legend labels.
    
    
      labelBaseline
      String
      Vertical text baseline for legend labels. One of alphabetic (default), top, middle, bottom, line-top, or line-bottom. The line-top and line-bottom values ≥ 5.10 operate similarly to top and bottom, but are calculated relative to the lineHeight rather than fontSize alone.
    
    
      labelColor
      Color
      Text color for legend labels.
    
    
      labelFont
      String
      Font name for legend labels.
    
    
      labelFontSize
      Number
      Font size in pixels for legend labels.
    
    
      labelFontStyle
      String
      Font style of legend labels (e.g., normal or italic). ≥ 5.0
    
    
      labelFontWeight
      String | Number
      Font weight of legend labels.
    
    
      labelLimit
      Number
      The maximum allowed length in pixels of legend labels.
    
    
      labelOffset
      Number
      Offset in pixels between legend labels their corresponding symbol or gradient.
    
    
      labelOpacity
      Number
      Opacity of legend labels. ≥ 4.1
    
    
      labelOverlap
      Boolean | String
      The strategy to use for resolving overlap of labels in gradient legends. If false, no overlap reduction is attempted. If set to true (default) or "parity", a strategy of removing every other label is used. If set to "greedy", a linear scan of the labels is performed, removing any label that overlaps with the last visible label.
    
    
      labelSeparation
      Number
      The minimum separation that must be between label bounding boxes for them to be considered non-overlapping (default 0). This property is ignored if labelOverlap resolution is not enabled. ≥ 5.0
    
    
      legendX
      Number
      The pixel x-coordinate of the legend group. Only applied if the orient value is "none". ≥ 5.4
    
    
      legendY
      Number
      The pixel y-coordinate of the legend group. Only applied if the orient value is "none". ≥ 5.4
    
    
      symbolDash
      Number[ ]
      Stroke dash of symbol outlines (or [] for solid lines). ≥ 5.0
    
    
      symbolDashOffset
      Number
      The pixel offset at which to start the symbol dash array. ≥ 5.0
    
    
      symbolFillColor
      Color
      Fill color for legend symbols.
    
    
      symbolLimit
      Number
      The maximum number of allowed entries for a symbol legend. If the number of entries exceeds the limit, entries will be dropped and replaced with an ellipsis. ≥ 5.7
    
    
      symbolOffset
      Number
      Horizontal pixel offset for legend symbols.
    
    
      symbolOpacity
      Number
      Opacity of legend symbols. ≥ 4.1
    
    
      symbolSize
      Number
      Default symbol area size (in pixels2).
    
    
      symbolStrokeColor
      Color
      Stroke color for legend symbols.
    
    
      symbolStrokeWidth
      Number
      Default legend symbol stroke width.
    
    
      symbolType
      String
      Default symbol mark shape type (such as "circle") for legend symbols.
    
    
      tickCount
      Number | String | Object
      The desired number of tick values for quantitative legends. For scales of type time or utc, the tick count can instead be a time interval specifier. Legal string values are "millisecond", "second", "minute", "hour", "day", "week", "month", and "year". Alternatively, an object-valued interval specifier of the form {"interval": "month", "step": 3} includes a desired number of interval steps. Here, ticks are generated for each quarter (Jan, Apr, Jul, Oct) boundary.
    
    
      tickMinStep
      Number
      The minimum desired step between tick values for quantitative legends, in terms of scale domain values. For example, a value of 1 indicates that ticks should not be less than 1 unit apart. If tickMinStep is specified, the tickCount value will be adjusted, if necessary, to enforce the minimum step value. ≥ 5.0
    
    
      title
      String | String[ ]
      The title for the legend (none by default). For versions ≥ 5.7, a string array specifies a title with multiple lines of text.
    
    
      titleAnchor
      String
      The anchor position for placing the legend title. One of "start", "middle", "end", or null (default, for automatic determination). For example, with a titleOrient of "top" these anchor positions map to a left-, center-, or right-aligned title relative to the legend contents. ≥ 5.0
    
    
      titleAlign
      String
      Horizontal text alignment of the legend title. One of "left", "center", or "right". If specified, this value overrides automatic alignment based on the titleOrient and titleAnchor values.
    
    
      titleBaseline
      String
      Vertical text baseline of the legend title. One of alphabetic (default), top, middle, bottom, line-top, or line-bottom. The line-top and line-bottom values ≥ 5.10 operate similarly to top and bottom, but are calculated relative to the lineHeight rather than fontSize alone. If specified, this value overrides the automatic baseline based on the titleOrient and titleAnchor values.
    
    
      titleColor
      Color
      Text color of the legend title.
    
    
      titleFont
      String
      Font name of the legend title.
    
    
      titleFontSize
      Number
      Font size in pixels of the legend title.
    
    
      titleFontStyle
      String
      Font style of the legend title (e.g., normal or italic). ≥ 5.0
    
    
      titleFontWeight
      String | Number
      Font weight of the legend title.
    
    
      titleLimit
      Number
      The maximum allowed length in pixels of the legend title.
    
    
      titleLineHeight
      Number
      Line height in pixels for multi-line title text or title text with "line-top" or "line-bottom" baseline. ≥ 5.7
    
    
      titleOpacity
      Number
      Opacity of the legend title. ≥ 4.1
    
    
      titleOrient
      String
      The orientation of the title legend, determining where it is placed relative to the legend contents. One of "top" (default), "left", "bottom", or "right". ≥ 5.0
    
    
      titlePadding
      Number | Value
      The padding between the legend title and entries.
    
    
      values
      Array
      Explicitly set the visible legend values. The array entries should be legal values in the backing scale domain.
    
    
      zindex
      Number
      The integer z-index indicating the layering of the legend group relative to other axis, mark, and legend groups. The default value is 0.
    
  


Accessibility Properties ≥ 5.11

Accessibility properties are used to determine ARIA (Accessible Rich Internet Applications) attributes when using Vega to render SVG output.


  
    
      Property
      Type
      Description
    
  
  
    
      aria
      Boolean
      A boolean flag (default true) indicating if ARIA attributes should be included (SVG output only). If false, the “aria-hidden” attribute will be set on the output SVG group, removing the legend from the ARIA accessibility tree.
    
    
      description
      String
      A text description of this legend for ARIA accessibility (SVG output only). If the aria property is true, for SVG output the “aria-label” attribute will be set to this description. If the description is unspecified it will be automatically generated.
    
  


Themes and Configuration

To create themes, new default values for legend properties can be set using a config object. The config object also supports customized layout behavior for collections of legends with the same orient value.

Legend Orientation Reference

Valid settings for the legend orient parameter.


  
    
      Value
      Description
    
  
  
    
      left
      Place the legend to the left of the chart.
    
    
      right
      Place the legend to the right of the chart.
    
    
      top
      Place the legend above the top of the chart.
    
    
      bottom
      Place the legend below the bottom of the chart.
    
    
      top-left
      Place the legend inside the upper left corner of the chart.
    
    
      top-right
      Place the legend inside the upper right corner of the chart.
    
    
      bottom-left
      Place the legend inside the lower left corner of the chart.
    
    
      bottom-right
      Place the legend inside the lower right corner of the chart.
    
    
      none
      Do not perform automatic layout. Allows custom layout by setting the legendX and legendY properties of the legend.
    
  


Multiple legends: If multiple legends have a left or right orientation, they will be vertically ordered by default. If multiple legends have a top or bottom orientation, they will be horizontally ordered by default. In all other cases, legends will be drawn on top of each other when placed in the same location. The multiple legend layout can be customized by setting the legend layout config.

Legend offset: In the case of left, right, top and bottom orientation, the offset parameter determines how far away the legend is placed from the rest of the chart. If the orientation is none, the offset parameter is ignored. For all other settings, the offset determines the distance the legend is moved inward from a corner of the data rectangle.

Custom Legend Encodings

Custom mark properties can be set for all legend elements using the encode parameter. The addressable elements are:


  legend for the legend group mark,
  title for the title text mark,
  labels for label text marks,
  symbols for legend symbol marks,
  entries for symbol legend group marks containing a symbol / label pair, and
  gradient for a gradient rect marks: one rect with gradient fill for continuous gradient legends, multiple rect marks with solid fill for discrete gradient legends.


Each element accepts a set of visual encoding directives grouped into enter, update, exit, etc. objects as described in the Marks documentation. Mark properties can be styled using standard value references.

In addition, each encode block may include a string-valued name property to assign a unique name to the mark set, a boolean-valued interactive property to enable input event handling, and a string-valued (or array-valued) style property to apply default property values. Unless otherwise specified, title elements use a default style of "guide-title" and labels elements use a default style of "guide-label".

Each legend symbol and label instance is backed by a data object with the following fields, which may be accessed as part of a custom visual encoding rule:


  index - an integer index
  label - the string label
  value - the data value
  size - the symbol size (for symbol legends only)


The following example shows how to set custom fonts and a border on a legend for a fill color encoding. The labels encoding block also make legend labels responsive to input events, and changes the text color on mouse hover.

"legends": [
  {
    "fill": "color",
    "encode": {
      "title": {
        "update": {
          "fontSize": {"value": 14}
        }
      },
      "labels": {
        "interactive": true,
        "update": {
          "fontSize": {"value": 12},
          "fill": {"value": "black"}
        },
        "hover": {
          "fill": {"value": "firebrick"}
        }
      },
      "symbols": {
        "update": {
          "stroke": {"value": "transparent"}
        }
      },
      "legend": {
        "update": {
          "stroke": {"value": "#ccc"},
          "strokeWidth": {"value": 1.5}
        }
      }
    }
  }
]


Custom text can be defined using the text property for labels. For example, one could define an ordinal scale that serves as a lookup table from a backing value to legend label text. Note: to perform custom positioning when orient is none, use the top-level legendX and legendY properties, do not use x and y properties within a custom encoding block.\nLegends visualize scale mappings for visual values such as color, shape and size. Similar to scales and axes, legends can be defined either at the top-level visualization, or within the scope of a group mark.\nProperties for specifying a legend. Legends accept one or more scales as parameters. At least one of the size, shape, fill, stroke, strokeDash, or opacity properties must be specified. If multiple scales are provided, they must share the same domain of input vales. Otherwise, the behavior of the legend is undefined.\nThe type of legend to include. One of "symbol" for discrete symbol legends, "gradient" for a continuous color gradient, or "discrete" for a discrete color gradient. If gradient or discrete are used, only the fill or stroke scale parameters are considered. If unspecified, the type will be inferred based on the scale parameters used and their backing scale types.\nThe direction of the legend, one of "vertical" (default) or "horizontal".\nThe orientation of the legend, determining where the legend is placed relative to a chart’s data rectangle (default right). See the legend orientation reference.\nlegend orientation reference\nThe name of a scale that maps to a fill color.\nThe name of a scale that maps to an opacity value.\nThe name of a scale that maps to a shape value.\nThe name of a scale that maps to a size (area) value.\nThe name of a scale that maps to a stroke color.\nThe name of a scale that maps to a stroke dash value.\nThe name of a scale that maps to a stroke width value. ≥ 5.0\nOptional mark encodings for custom legend styling. Supports encoding blocks for legend, title, entries, labels, symbols and gradient. See custom legend encodings.\ncustom legend encodings\nString | TimeMultiFormat\nThe format specifier pattern for legend labels. For numerical values, must be a legal d3-format specifier. For date-time values, must be a legal d3-time-format specifier or a TimeMultiFormat object.\nTimeMultiFormat object\nSpecifies the type of format to use ("number", "time", "utc") for scales that do not have a strict domain data type. This property is useful for formatting date-time values for ordinal scales. If specified, the format property must have a valid specifier pattern for the given type. Supported ≥ 5.1, UTC support ≥ 5.8.\nThe alignment to apply to symbol legends rows and columns. The supported string values are all, each (the default), and none. For more information, see the grid layout documentation.\ngrid layout documentation\nThe height in pixels to clip symbol legend entries and limit their size. By default no clipping is performed.\nThe number of columns in which to arrange symbol legend entries. A value of 0 or lower indicates a single row with one column per entry. The default is 0 for horizontal symbol legends and 1 for vertical symbol legends.\nThe horizontal padding in pixels between symbol legend entries.\nThe vertical padding in pixels between symbol legend entries.\nCorner radius for the full legend.\nBackground fill color for the full legend.\nThe offset in pixels by which to displace the legend from the data rectangle and axes. If provided, this value will override any values specified in the legend config. If multiple offset values are specified for a collection of legends with the same orient value, the maximum offset will be used.\nThe padding between the border and content of the legend group.\nBorder stroke color for the full legend.\nThe length in pixels of the primary axis of a color gradient. This value corresponds to the height of a vertical gradient or the width of a horizontal gradient.\nOpacity of the color gradient. ≥ 4.1\nThe thickness in pixels of the color gradient. This value corresponds to the width of a vertical gradient or the height of a horizontal gradient.\nStroke color of the color gradient border.\nStroke width of the color gradient border.\nHorizontal text alignment for legend labels.\nVertical text baseline for legend labels. One of alphabetic (default), top, middle, bottom, line-top, or line-bottom. The line-top and line-bottom values ≥ 5.10 operate similarly to top and bottom, but are calculated relative to the lineHeight rather than fontSize alone.\nText color for legend labels.\nFont name for legend labels.\nFont size in pixels for legend labels.\nFont style of legend labels (e.g., normal or italic). ≥ 5.0\nFont weight of legend labels.\nThe maximum allowed length in pixels of legend labels.\nOffset in pixels between legend labels their corresponding symbol or gradient.\nOpacity of legend labels. ≥ 4.1\nThe strategy to use for resolving overlap of labels in gradient legends. If false, no overlap reduction is attempted. If set to true (default) or "parity", a strategy of removing every other label is used. If set to "greedy", a linear scan of the labels is performed, removing any label that overlaps with the last visible label.\nThe minimum separation that must be between label bounding boxes for them to be considered non-overlapping (default 0). This property is ignored if labelOverlap resolution is not enabled. ≥ 5.0\nThe pixel x-coordinate of the legend group. Only applied if the orient value is "none". ≥ 5.4\nThe pixel y-coordinate of the legend group. Only applied if the orient value is "none". ≥ 5.4\nStroke dash of symbol outlines (or [] for solid lines). ≥ 5.0\nThe pixel offset at which to start the symbol dash array. ≥ 5.0\nFill color for legend symbols.\nThe maximum number of allowed entries for a symbol legend. If the number of entries exceeds the limit, entries will be dropped and replaced with an ellipsis. ≥ 5.7\nHorizontal pixel offset for legend symbols.\nOpacity of legend symbols. ≥ 4.1\nDefault symbol area size (in pixels2).\nStroke color for legend symbols.\nDefault legend symbol stroke width.\nDefault symbol mark shape type (such as "circle") for legend symbols.\nsymbol mark shape type\nNumber | String | Object\nThe desired number of tick values for quantitative legends. For scales of type time or utc, the tick count can instead be a time interval specifier. Legal string values are "millisecond", "second", "minute", "hour", "day", "week", "month", and "year". Alternatively, an object-valued interval specifier of the form {"interval": "month", "step": 3} includes a desired number of interval steps. Here, ticks are generated for each quarter (Jan, Apr, Jul, Oct) boundary.\nThe minimum desired step between tick values for quantitative legends, in terms of scale domain values. For example, a value of 1 indicates that ticks should not be less than 1 unit apart. If tickMinStep is specified, the tickCount value will be adjusted, if necessary, to enforce the minimum step value. ≥ 5.0\nThe title for the legend (none by default). For versions ≥ 5.7, a string array specifies a title with multiple lines of text.\nThe anchor position for placing the legend title. One of "start", "middle", "end", or null (default, for automatic determination). For example, with a titleOrient of "top" these anchor positions map to a left-, center-, or right-aligned title relative to the legend contents. ≥ 5.0\nHorizontal text alignment of the legend title. One of "left", "center", or "right". If specified, this value overrides automatic alignment based on the titleOrient and titleAnchor values.\nVertical text baseline of the legend title. One of alphabetic (default), top, middle, bottom, line-top, or line-bottom. The line-top and line-bottom values ≥ 5.10 operate similarly to top and bottom, but are calculated relative to the lineHeight rather than fontSize alone. If specified, this value overrides the automatic baseline based on the titleOrient and titleAnchor values.\nText color of the legend title.\nFont name of the legend title.\nFont size in pixels of the legend title.\nFont style of the legend title (e.g., normal or italic). ≥ 5.0\nFont weight of the legend title.\nThe maximum allowed length in pixels of the legend title.\nLine height in pixels for multi-line title text or title text with "line-top" or "line-bottom" baseline. ≥ 5.7\nOpacity of the legend title. ≥ 4.1\nThe orientation of the title legend, determining where it is placed relative to the legend contents. One of "top" (default), "left", "bottom", or "right". ≥ 5.0\nThe padding between the legend title and entries.\nExplicitly set the visible legend values. The array entries should be legal values in the backing scale domain.\nThe integer z-index indicating the layering of the legend group relative to other axis, mark, and legend groups. The default value is 0.\nAccessibility Properties ≥ 5.11\nAccessibility properties are used to determine ARIA (Accessible Rich Internet Applications) attributes when using Vega to render SVG output.\nARIA (Accessible Rich Internet Applications) attributes\nA boolean flag (default true) indicating if ARIA attributes should be included (SVG output only). If false, the “aria-hidden” attribute will be set on the output SVG group, removing the legend from the ARIA accessibility tree.\nA text description of this legend for ARIA accessibility (SVG output only). If the aria property is true, for SVG output the “aria-label” attribute will be set to this description. If the description is unspecified it will be automatically generated.\n“aria-label” attribute\nThemes and Configuration\nTo create themes, new default values for legend properties can be set using a config object. The config object also supports customized layout behavior for collections of legends with the same orient value.\nLegend Orientation Reference\nValid settings for the legend orient parameter.\nPlace the legend to the left of the chart.\nPlace the legend to the right of the chart.\nPlace the legend above the top of the chart.\nPlace the legend below the bottom of the chart.\nPlace the legend inside the upper left corner of the chart.\nPlace the legend inside the upper right corner of the chart.\nPlace the legend inside the lower left corner of the chart.\nPlace the legend inside the lower right corner of the chart.\nDo not perform automatic layout. Allows custom layout by setting the legendX and legendY properties of the legend.\nMultiple legends: If multiple legends have a left or right orientation, they will be vertically ordered by default. If multiple legends have a top or bottom orientation, they will be horizontally ordered by default. In all other cases, legends will be drawn on top of each other when placed in the same location. The multiple legend layout can be customized by setting the legend layout config.\nLegend offset: In the case of left, right, top and bottom orientation, the offset parameter determines how far away the legend is placed from the rest of the chart. If the orientation is none, the offset parameter is ignored. For all other settings, the offset determines the distance the legend is moved inward from a corner of the data rectangle.\nCustom Legend Encodings\nCustom mark properties can be set for all legend elements using the encode parameter. The addressable elements are:\nlegend for the legend group mark,\ntitle for the title text mark,\nlabels for label text marks,\nsymbols for legend symbol marks,\nentries for symbol legend group marks containing a symbol / label pair, and\ngradient for a gradient rect marks: one rect with gradient fill for continuous gradient legends, multiple rect marks with solid fill for discrete gradient legends.\nEach element accepts a set of visual encoding directives grouped into enter, update, exit, etc. objects as described in the Marks documentation. Mark properties can be styled using standard value references.\nIn addition, each encode block may include a string-valued name property to assign a unique name to the mark set, a boolean-valued interactive property to enable input event handling, and a string-valued (or array-valued) style property to apply default property values. Unless otherwise specified, title elements use a default style of "guide-title" and labels elements use a default style of "guide-label".\nEach legend symbol and label instance is backed by a data object with the following fields, which may be accessed as part of a custom visual encoding rule:\nindex - an integer index\nlabel - the string label\nvalue - the data value\nsize - the symbol size (for symbol legends only)\nThe following example shows how to set custom fonts and a border on a legend for a fill color encoding. The labels encoding block also make legend labels responsive to input events, and changes the text color on mouse hover.\n"legends": [
  {
    "fill": "color",
    "encode": {
      "title": {
        "update": {
          "fontSize": {"value": 14}
        }
      },
      "labels": {
        "interactive": true,
        "update": {
          "fontSize": {"value": 12},
          "fill": {"value": "black"}
        },
        "hover": {
          "fill": {"value": "firebrick"}
        }
      },
      "symbols": {
        "update": {
          "stroke": {"value": "transparent"}
        }
      },
      "legend": {
        "update": {
          "stroke": {"value": "#ccc"},
          "strokeWidth": {"value": 1.5}
        }
      }
    }
  }
]\n"legends": [
  {
    "fill": "color",
    "encode": {
      "title": {
        "update": {
          "fontSize": {"value": 14}
        }
      },
      "labels": {
        "interactive": true,
        "update": {
          "fontSize": {"value": 12},
          "fill": {"value": "black"}
        },
        "hover": {
          "fill": {"value": "firebrick"}
        }
      },
      "symbols": {
        "update": {
          "stroke": {"value": "transparent"}
        }
      },
      "legend": {
        "update": {
          "stroke": {"value": "#ccc"},
          "strokeWidth": {"value": 1.5}
        }
      }
    }
  }
]\nCustom text can be defined using the text property for labels. For example, one could define an ordinal scale that serves as a lookup table from a backing value to legend label text. Note: to perform custom positioning when orient is none, use the top-level legendX and legendY properties, do not use x and y properties within a custom encoding block.\n\n\nVega
            
              Vega-Lite
              Altair
              Vega-Lite API
            
          
          
            
              Examples
              Tutorials
              Documentation
              Usage
              About
            
            
              GitHub
              Try Online
            
          
        
      

      
        

  
  
    
      
      
        Documentation
      
      
      
      
        Specification
      
      
      
      
        Config
      
      
      
      
        Data
      
      
      
      
        Transforms
      
      
      
      
        Triggers
      
      
      
      
        Projections
      
      
      
      
        Scales
      
      
      
      
        Schemes
      
      
      
      
        Axes
      
      
      
      
        Legends
      
      
      
      
        Title
      
      
      
      
        Marks
      
      
      
      
        Signals
      
      
      
      
        Event Streams
      
      
      
      
        Expressions
      
      
      
      
        Layout
      
      
      
      
        Types
      
      
    
  
  
    Projections
    Cartographic projections map (longitude, latitude) pairs to projected (x, y) coordinates. Vega uses projections to layout both geographic points (such as locations on a map) for which longitude and latitude coordinates are part of the input data, and geographic regions (such as countries and states) represented using the GeoJSON format.


  
  View Source
  Export PNG
  Export SVG



Documentation Overview


  Projection Properties
  Projection Types
  Register Additional Projections


Projection Properties


  
    
      Property
      Type
      Description
    
  
  
    
      name
      String
      Required. A unique name for the projection. Projections and scales share the same namespace; names must be unique across both.
    
    
      type
      String
      The cartographic projection to use. The default is "mercator". This value is case-insensitive, for example "albers" and "Albers" indicate the same projection type.
    
    
      clipAngle
      Number
      The projection’s clipping circle radius, specified as an angle in degrees. If null, switches to antimeridian cutting rather than small-circle clipping.
    
    
      clipExtent
      Array
      The projection’s viewport clip extent, as a set of pixel bounds. The extent bounds are specified as an array [[x0, y0], [x1, y1]], where x0 is the left-side of the viewport, y0 is the top, x1 is the right and y1 is the bottom. If null, no viewport clipping is performed.
    
    
      scale
      Number
      The projection’s scale factor. The default scale is projection-specific. The scale factor corresponds linearly to the distance between projected points; however, scale factor values are not equivalent across projections.
    
    
      translate
      Number[ ]
      The projection’s translation offset as a two-element array [tx, ty]. If translate is not specified, returns the current translation offset which defaults to [480, 250]. The translation offset determines the pixel coordinates of the projection’s center. The default translation offset places (0°,0°) at the center of a 960×500 area.
    
    
      center
      Number[ ]
      The projection’s center, a two-element array of longitude and latitude in degrees. The default value is [0, 0].
    
    
      rotate
      Number[ ]
      The projection’s three-axis rotation angles. The value must be a two- or three-element array of numbers [lambda, phi, gamma] specifying the rotation angles in degrees about each spherical axis. (These correspond to yaw, pitch and roll.) The default value is [0, 0, 0].
    
    
      parallels
      Number[ ]
      For conic projections, the two standard parallels that define the map layout. The default depends on the specific conic projection used.
    
    
      pointRadius
      Number
      The default radius (in pixels) to use when drawing GeoJSON Point and MultiPoint geometries. This parameter sets a constant default value. To modify the point radius in response to data, see the corresponding parameter of the GeoPath and GeoShape transforms. The default value is 4.5.
    
    
      precision
      Number
      The threshold for the projection’s adaptive resampling in pixels. This value corresponds to the Douglas–Peucker distance. If precision is not specified, returns the projection’s current resampling precision which defaults to √0.5 ≅ 0.70710…
    
    
      fit
      Object | Array
      GeoJSON data to which the projection should attempt to automatically fit the translate and scale parameters. If object-valued, this parameter should be a GeoJSON Feature or FeatureCollection. If array-valued, each array member may be a GeoJSON Feature, FeatureCollection, or a sub-array of GeoJSON Features.
    
    
      extent
      Array[ ]
      Used in conjunction with fit, provides the pixel area to which the projection should be automatically fit. The extent bounds are specified as an array [[x0, y0], [x1, y1]], where x0 is the left side of the extent, y0 is the top, x1 is the right and y1 is the bottom.
    
    
      size
      Number[ ]
      Used in conjunction with fit, provides the width and height in pixels of the area to which the projection should be automatically fit. This parameter is equivalent to an extent of [[0,0], size].
    
  


In addition to the shared properties above, the following properties are supported for specific projection types in the d3-geo-projection library:
coefficient,
distance,
fraction,
lobes,
parallel,
radius,
ratio,
spacing,
tilt.

Alternative default values for any of the properties above can be set using a custom config object.

Projection Types

Vega includes all cartographic projections provided by the d3-geo library, as well as the mollweide projection.


  
    
      Type
      Description
    
  
  
    
      albers
      The Albers’ equal-area conic projection. This is a U.S.-centric configuration of "conicEqualArea".
    
    
      albersUsa
      A U.S.-centric composite with projections for the lower 48 states, Hawaii, and Alaska (scaled to 0.35 times the true relative area).
    
    
      azimuthalEqualArea
      The azimuthal equal-area projection.
    
    
      azimuthalEquidistant
      The azimuthal equidistant projection.
    
    
      conicConformal
      The conic conformal projection. The parallels default to [30°, 30°] resulting in flat top.
    
    
      conicEqualArea
      The Albers’ equal-area conic projection.
    
    
      conicEquidistant
      The conic equidistant projection.
    
    
      equalEarth
      The Equal Earth projection, by Bojan Šavrič et al., 2018.
    
    
      equirectangular
      The equirectangular (plate carrée) projection, akin to using longitude, latitude directly.
    
    
      gnomonic
      The gnomonic projection.
    
    
      identity
      The identity transform, which can be used to translate, scale, and clip planar geometry. Also supports additional boolean reflectX and reflectY parameters. ≥ 3.3
    
    
      mercator
      The spherical Mercator projection. Uses a default clipExtent such that the world is projected to a square, clipped to approximately ±85° latitude.
    
    
      mollweide
      An equal-area, pseudocylindrical map projection generally used for global maps of the world or night sky. ≥ 5.9
    
    
      naturalEarth1
      The Natural Earth projection is a pseudocylindrical projection designed by Tom Patterson. It is neither conformal nor equal-area, but appealing to the eye for small-scale maps of the whole world. ≥ 4.0
    
    
      orthographic
      The orthographic projection.
    
    
      stereographic
      The stereographic projection.
    
    
      transverseMercator
      The transverse spherical Mercator projection. Uses a default clipExtent such that the world is projected to a square, clipped to approximately ±85° latitude.
    
  


Register Additional Projections

Vega can be extended with additional projections, such as those found in the d3-geo-projection library.

To register all extended projections from d3-geo-projection with Vega, simply import the vega-projection-extended library:

<script src="https://cdn.jsdelivr.net/npm/vega-projection-extended@2"></script>


Alternatively, custom projections can be manually registered using the vega.projection method:

// Assumes d3-geo-projection is imported under the d3 variable.
// To register with Vega, provide a name and projection function.
vega.projection('winkel3', d3.geoWinkel3);

// Vega parser and runtime now support the 'winkel3' projection
var runtime = vega.parse({
  ...,
  "projections": [
    { "name": "proj", "type": "winkel3" }
  ],
  ...
});\nVega
            
              Vega-Lite
              Altair
              Vega-Lite API\nVega-Lite
              Altair
              Vega-Lite API\nExamples
              Tutorials
              Documentation
              Usage
              About
            
            
              GitHub
              Try Online\nExamples
              Tutorials
              Documentation
              Usage
              About\nGitHub
              Try Online\nDocumentation
      
      
      
      
        Specification
      
      
      
      
        Config
      
      
      
      
        Data
      
      
      
      
        Transforms
      
      
      
      
        Triggers
      
      
      
      
        Projections
      
      
      
      
        Scales
      
      
      
      
        Schemes
      
      
      
      
        Axes
      
      
      
      
        Legends
      
      
      
      
        Title
      
      
      
      
        Marks
      
      
      
      
        Signals
      
      
      
      
        Event Streams
      
      
      
      
        Expressions
      
      
      
      
        Layout
      
      
      
      
        Types
      
      
    
  
  
    Projections
    Cartographic projections map (longitude, latitude) pairs to projected (x, y) coordinates. Vega uses projections to layout both geographic points (such as locations on a map) for which longitude and latitude coordinates are part of the input data, and geographic regions (such as countries and states) represented using the GeoJSON format.


  
  View Source
  Export PNG
  Export SVG



Documentation Overview


  Projection Properties
  Projection Types
  Register Additional Projections


Projection Properties


  
    
      Property
      Type
      Description
    
  
  
    
      name
      String
      Required. A unique name for the projection. Projections and scales share the same namespace; names must be unique across both.
    
    
      type
      String
      The cartographic projection to use. The default is "mercator". This value is case-insensitive, for example "albers" and "Albers" indicate the same projection type.
    
    
      clipAngle
      Number
      The projection’s clipping circle radius, specified as an angle in degrees. If null, switches to antimeridian cutting rather than small-circle clipping.
    
    
      clipExtent
      Array
      The projection’s viewport clip extent, as a set of pixel bounds. The extent bounds are specified as an array [[x0, y0], [x1, y1]], where x0 is the left-side of the viewport, y0 is the top, x1 is the right and y1 is the bottom. If null, no viewport clipping is performed.
    
    
      scale
      Number
      The projection’s scale factor. The default scale is projection-specific. The scale factor corresponds linearly to the distance between projected points; however, scale factor values are not equivalent across projections.
    
    
      translate
      Number[ ]
      The projection’s translation offset as a two-element array [tx, ty]. If translate is not specified, returns the current translation offset which defaults to [480, 250]. The translation offset determines the pixel coordinates of the projection’s center. The default translation offset places (0°,0°) at the center of a 960×500 area.
    
    
      center
      Number[ ]
      The projection’s center, a two-element array of longitude and latitude in degrees. The default value is [0, 0].
    
    
      rotate
      Number[ ]
      The projection’s three-axis rotation angles. The value must be a two- or three-element array of numbers [lambda, phi, gamma] specifying the rotation angles in degrees about each spherical axis. (These correspond to yaw, pitch and roll.) The default value is [0, 0, 0].
    
    
      parallels
      Number[ ]
      For conic projections, the two standard parallels that define the map layout. The default depends on the specific conic projection used.
    
    
      pointRadius
      Number
      The default radius (in pixels) to use when drawing GeoJSON Point and MultiPoint geometries. This parameter sets a constant default value. To modify the point radius in response to data, see the corresponding parameter of the GeoPath and GeoShape transforms. The default value is 4.5.
    
    
      precision
      Number
      The threshold for the projection’s adaptive resampling in pixels. This value corresponds to the Douglas–Peucker distance. If precision is not specified, returns the projection’s current resampling precision which defaults to √0.5 ≅ 0.70710…
    
    
      fit
      Object | Array
      GeoJSON data to which the projection should attempt to automatically fit the translate and scale parameters. If object-valued, this parameter should be a GeoJSON Feature or FeatureCollection. If array-valued, each array member may be a GeoJSON Feature, FeatureCollection, or a sub-array of GeoJSON Features.
    
    
      extent
      Array[ ]
      Used in conjunction with fit, provides the pixel area to which the projection should be automatically fit. The extent bounds are specified as an array [[x0, y0], [x1, y1]], where x0 is the left side of the extent, y0 is the top, x1 is the right and y1 is the bottom.
    
    
      size
      Number[ ]
      Used in conjunction with fit, provides the width and height in pixels of the area to which the projection should be automatically fit. This parameter is equivalent to an extent of [[0,0], size].
    
  


In addition to the shared properties above, the following properties are supported for specific projection types in the d3-geo-projection library:
coefficient,
distance,
fraction,
lobes,
parallel,
radius,
ratio,
spacing,
tilt.

Alternative default values for any of the properties above can be set using a custom config object.

Projection Types

Vega includes all cartographic projections provided by the d3-geo library, as well as the mollweide projection.


  
    
      Type
      Description
    
  
  
    
      albers
      The Albers’ equal-area conic projection. This is a U.S.-centric configuration of "conicEqualArea".
    
    
      albersUsa
      A U.S.-centric composite with projections for the lower 48 states, Hawaii, and Alaska (scaled to 0.35 times the true relative area).
    
    
      azimuthalEqualArea
      The azimuthal equal-area projection.
    
    
      azimuthalEquidistant
      The azimuthal equidistant projection.
    
    
      conicConformal
      The conic conformal projection. The parallels default to [30°, 30°] resulting in flat top.
    
    
      conicEqualArea
      The Albers’ equal-area conic projection.
    
    
      conicEquidistant
      The conic equidistant projection.
    
    
      equalEarth
      The Equal Earth projection, by Bojan Šavrič et al., 2018.
    
    
      equirectangular
      The equirectangular (plate carrée) projection, akin to using longitude, latitude directly.
    
    
      gnomonic
      The gnomonic projection.
    
    
      identity
      The identity transform, which can be used to translate, scale, and clip planar geometry. Also supports additional boolean reflectX and reflectY parameters. ≥ 3.3
    
    
      mercator
      The spherical Mercator projection. Uses a default clipExtent such that the world is projected to a square, clipped to approximately ±85° latitude.
    
    
      mollweide
      An equal-area, pseudocylindrical map projection generally used for global maps of the world or night sky. ≥ 5.9
    
    
      naturalEarth1
      The Natural Earth projection is a pseudocylindrical projection designed by Tom Patterson. It is neither conformal nor equal-area, but appealing to the eye for small-scale maps of the whole world. ≥ 4.0
    
    
      orthographic
      The orthographic projection.
    
    
      stereographic
      The stereographic projection.
    
    
      transverseMercator
      The transverse spherical Mercator projection. Uses a default clipExtent such that the world is projected to a square, clipped to approximately ±85° latitude.
    
  


Register Additional Projections

Vega can be extended with additional projections, such as those found in the d3-geo-projection library.

To register all extended projections from d3-geo-projection with Vega, simply import the vega-projection-extended library:

<script src="https://cdn.jsdelivr.net/npm/vega-projection-extended@2"></script>


Alternatively, custom projections can be manually registered using the vega.projection method:

// Assumes d3-geo-projection is imported under the d3 variable.
// To register with Vega, provide a name and projection function.
vega.projection('winkel3', d3.geoWinkel3);

// Vega parser and runtime now support the 'winkel3' projection
var runtime = vega.parse({
  ...,
  "projections": [
    { "name": "proj", "type": "winkel3" }
  ],
  ...
});\nCartographic projections map (longitude, latitude) pairs to projected (x, y) coordinates. Vega uses projections to layout both geographic points (such as locations on a map) for which longitude and latitude coordinates are part of the input data, and geographic regions (such as countries and states) represented using the GeoJSON format.\nView Source
  Export PNG
  Export SVG\nDocumentation Overview\nProjection Properties\nProjection Properties\nRegister Additional Projections\nRegister Additional Projections\nProjection Properties\nRequired. A unique name for the projection. Projections and scales share the same namespace; names must be unique across both.\nThe cartographic projection to use. The default is "mercator". This value is case-insensitive, for example "albers" and "Albers" indicate the same projection type.\nThe projection’s clipping circle radius, specified as an angle in degrees. If null, switches to antimeridian cutting rather than small-circle clipping.\nThe projection’s viewport clip extent, as a set of pixel bounds. The extent bounds are specified as an array [[x0, y0], [x1, y1]], where x0 is the left-side of the viewport, y0 is the top, x1 is the right and y1 is the bottom. If null, no viewport clipping is performed.\nThe projection’s scale factor. The default scale is projection-specific. The scale factor corresponds linearly to the distance between projected points; however, scale factor values are not equivalent across projections.\nThe projection’s translation offset as a two-element array [tx, ty]. If translate is not specified, returns the current translation offset which defaults to [480, 250]. The translation offset determines the pixel coordinates of the projection’s center. The default translation offset places (0°,0°) at the center of a 960×500 area.\nThe projection’s center, a two-element array of longitude and latitude in degrees. The default value is [0, 0].\nThe projection’s three-axis rotation angles. The value must be a two- or three-element array of numbers [lambda, phi, gamma] specifying the rotation angles in degrees about each spherical axis. (These correspond to yaw, pitch and roll.) The default value is [0, 0, 0].\nFor conic projections, the two standard parallels that define the map layout. The default depends on the specific conic projection used.\ntwo standard parallels\nThe default radius (in pixels) to use when drawing GeoJSON Point and MultiPoint geometries. This parameter sets a constant default value. To modify the point radius in response to data, see the corresponding parameter of the GeoPath and GeoShape transforms. The default value is 4.5.\nThe threshold for the projection’s adaptive resampling in pixels. This value corresponds to the Douglas–Peucker distance. If precision is not specified, returns the projection’s current resampling precision which defaults to √0.5 ≅ 0.70710…\nGeoJSON data to which the projection should attempt to automatically fit the translate and scale parameters. If object-valued, this parameter should be a GeoJSON Feature or FeatureCollection. If array-valued, each array member may be a GeoJSON Feature, FeatureCollection, or a sub-array of GeoJSON Features.\nUsed in conjunction with fit, provides the pixel area to which the projection should be automatically fit. The extent bounds are specified as an array [[x0, y0], [x1, y1]], where x0 is the left side of the extent, y0 is the top, x1 is the right and y1 is the bottom.\nUsed in conjunction with fit, provides the width and height in pixels of the area to which the projection should be automatically fit. This parameter is equivalent to an extent of [[0,0], size].\nIn addition to the shared properties above, the following properties are supported for specific projection types in the d3-geo-projection library:
coefficient,
distance,
fraction,
lobes,
parallel,
radius,
ratio,
spacing,
tilt.\nAlternative default values for any of the properties above can be set using a custom config object.\nVega includes all cartographic projections provided by the d3-geo library, as well as the mollweide projection.\nThe Albers’ equal-area conic projection. This is a U.S.-centric configuration of "conicEqualArea".\nA U.S.-centric composite with projections for the lower 48 states, Hawaii, and Alaska (scaled to 0.35 times the true relative area).\nThe azimuthal equal-area projection.\nThe azimuthal equidistant projection.\nThe conic conformal projection. The parallels default to [30°, 30°] resulting in flat top.\nThe Albers’ equal-area conic projection.\nThe conic equidistant projection.\nThe Equal Earth projection, by Bojan Šavrič et al., 2018.\nThe equirectangular (plate carrée) projection, akin to using longitude, latitude directly.\nThe gnomonic projection.\nThe identity transform, which can be used to translate, scale, and clip planar geometry. Also supports additional boolean reflectX and reflectY parameters. ≥ 3.3\nThe spherical Mercator projection. Uses a default clipExtent such that the world is projected to a square, clipped to approximately ±85° latitude.\nAn equal-area, pseudocylindrical map projection generally used for global maps of the world or night sky. ≥ 5.9\nThe Natural Earth projection is a pseudocylindrical projection designed by Tom Patterson. It is neither conformal nor equal-area, but appealing to the eye for small-scale maps of the whole world. ≥ 4.0\nNatural Earth projection\nThe orthographic projection.\nThe stereographic projection.\nThe transverse spherical Mercator projection. Uses a default clipExtent such that the world is projected to a square, clipped to approximately ±85° latitude.\nRegister Additional Projections\nVega can be extended with additional projections, such as those found in the d3-geo-projection library.\nTo register all extended projections from d3-geo-projection with Vega, simply import the vega-projection-extended library:\nvega-projection-extended\n<script src="https://cdn.jsdelivr.net/npm/vega-projection-extended@2"></script>\n<script src="https://cdn.jsdelivr.net/npm/vega-projection-extended@2"></script>\n"https://cdn.jsdelivr.net/npm/vega-projection-extended@2"\nAlternatively, custom projections can be manually registered using the vega.projection method:\n// Assumes d3-geo-projection is imported under the d3 variable.
// To register with Vega, provide a name and projection function.
vega.projection('winkel3', d3.geoWinkel3);

// Vega parser and runtime now support the 'winkel3' projection
var runtime = vega.parse({
  ...,
  "projections": [
    { "name": "proj", "type": "winkel3" }
  ],
  ...
});\n// Assumes d3-geo-projection is imported under the d3 variable.
// To register with Vega, provide a name and projection function.
vega.projection('winkel3', d3.geoWinkel3);

// Vega parser and runtime now support the 'winkel3' projection
var runtime = vega.parse({
  ...,
  "projections": [
    { "name": "proj", "type": "winkel3" }
  ],
  ...
});\n// Assumes d3-geo-projection is imported under the d3 variable.\n// To register with Vega, provide a name and projection function.\n// Vega parser and runtime now support the 'winkel3' projection\n\n\nVega
            
              Vega-Lite
              Altair
              Vega-Lite API
            
          
          
            
              Examples
              Tutorials
              Documentation
              Usage
              About
            
            
              GitHub
              Try Online
            
          
        
      

      
        

  
  
    
      
      
        Documentation
      
      
      
      
        Specification
      
      
      
      
        Config
      
      
      
      
        Data
      
      
      
      
        Transforms
      
      
      
      
        Triggers
      
      
      
      
        Projections
      
      
      
      
        Scales
      
      
      
      
        Schemes
      
      
      
      
        Axes
      
      
      
      
        Legends
      
      
      
      
        Title
      
      
      
      
        Marks
      
      
      
        
        
          arc
        
        
        
          area
        
        
        
          group
        
        
        
          image
        
        
        
          line
        
        
        
          path
        
        
        
          rect
        
        
        
          rule
        
        
        
          shape
        
        
        
          symbol
        
        
        
          text
        
        
        
          trail
        
      
      
      
      
        Signals
      
      
      
      
        Event Streams
      
      
      
      
        Expressions
      
      
      
      
        Layout
      
      
      
      
        Types
      
      
    
  
  
    Marks
    Graphical marks visually encode data using geometric primitives such as rectangles, lines, and plotting symbols. Marks are the basic visual building block of a visualization, providing basic shapes whose properties can be set according to backing data. Mark property definitions may be simple constants or data fields, or scales can be used to map data values to visual values.

Supported Mark Types

The supported mark types are:


  arc - Circular arcs, including pie and donut slices.
  area - Filled areas with horizontal or vertical alignment.
  image - Images, including icons or photographs.
  group - Containers for other marks, useful for sub-plots.
  line - Stroked lines, often used for showing change over time.
  path - Arbitrary paths or polygons, defined using SVG path syntax.
  rect - Rectangles, as in bar charts and timelines.
  rule - Rules are line segments, often used for axis ticks and grid lines.
  shape - A special variant of path marks for faster drawing of cartographic maps.
  symbol - Plotting symbols, including circles, squares and other shapes.
  text - Text labels with configurable fonts, alignment and angle.
  trail - Lines that can change size based on underlying data.


Visual Encoding

Each mark supports a set of visual encoding properties that determine the position and appearance of mark instances. Typically one mark instance is generated per input data element; the exceptions are the line and area mark types, which represent multiple data elements as a single line or area shape.

A mark definition typically looks something like this:

{
  "type": "rect",
  "from": {"data": "table"},
  "encode": {
    "enter": {
      "y": {"scale": "yscale", "field": "value"},
      "y2": {"scale": "yscale", "value": 0},
      "fill": {"value": "steelblue"}
    },
    "update": {...},
    "exit": {...},
    "hover": {...}
  }
}


There are three primary property sets: enter, update, exit. The enter properties are evaluated when data is processed for the first time and a mark instance is newly added to a scene. The update properties are evaluated for all existing (non-exiting) mark instances. The exit properties are evaluated when the data backing a mark is removed, and so the mark is leaving the visual scene. To better understand how enter, update, and exit sets work, take a look at Mike Bostock’s Thinking with Joins.

In addition, an optional hover set determines visual properties when the mouse cursor hovers over a mark instance. Upon mouse out, the update set is applied.

There is also a special group mark type (group) that can contain other marks, as well as local data, signal, scale, axis and legend definitions. Groups can be used to create visualizations consisting of grouped or repeated elements; examples include stacked graphs (each stack is a separate group containing a series of data values) and small multiples displays (each plot is contained in its own group). See the Group Marks page for more.

Top-Level Mark Properties


  
    
      Property
      Type
      Description
    
  
  
    
      type
      String
      Required. The graphical mark type. Must be one of the supported mark types.
    
    
      clip
      Clip
      Indicates if the marks should be clipped to a specified shape (default false). If boolean-valued, the clipping region is the enclosing group’s width and height. If object-valued, should specify either an arbitrary SVG path string or a cartographic projection with which to clip to the sphere of the Earth.
    
    
      encode
      Encode
      An object containing a set of visual encoding rules for mark properties.
    
    
      from
      From
      An object describing the data this mark set should visualize. If undefined, a single element data set containing an empty object is assumed. The from property can either specify a data set to use (e.g., {"data": "table"}) or provide a faceting directive to subdivide a data set across a set of group marks.
    
    
      interactive
      Boolean
      A boolean flag (default true) indicating if the marks can serve as input event sources. If false, no mouse or touch events corresponding to the marks will be generated. This property can also take a Signal value to dynamically toggle interactive status.
    
    
      key
      Field
      A data field to use as a unique key for data binding. When a visualization’s data is updated, the key value will be used to match data elements to existing mark instances. Use a key field to enable object constancy for transitions over dynamic data.
    
    
      name
      String
      A unique name for the mark. This name can be used to refer to these marks within an event stream definition. SVG renderers will add this name value as a CSS class name on the enclosing SVG group (g) element containing the mark instances.
    
    
      on
      Trigger[ ]
      A set of triggers for modifying mark properties in response to signal changes.
    
    
      sort
      Compare
      A comparator for sorting mark items. The sort order will determine the default rendering order. The comparator is defined over generated scenegraph items and sorting is performed after encodings are computed, allowing items to be sorted by size or position. To sort by underlying data properties in addition to mark item properties, append the prefix datum. to a field name (e.g., {"field": "datum.field"}).
    
    
      transform
      Transform[ ]
      A set of post-encoding transforms, applied after any encode blocks, that operate directly on mark scenegraph items (not backing data objects). These can be useful for performing layout with transforms that can set x, y, width, height, etc. properties. Only data transforms that do not generate or filter data objects may be used.
    
    
      role
      String
      A metadata string indicating the role of the mark. SVG renderers will add this role value (prepended with the prefix role-) as a CSS class name on the enclosing SVG group (g) element containing the mark instances. Roles are used internally by Vega to guide layout. Do not set this property unless you know which layout effect you are trying to achieve.
    
    
      style
      String | String[ ]
      A string or array of strings indicating the name of custom styles to apply to the mark. A style is a named collection of mark property defaults defined within the configuration. These properties will be applied to the mark’s enter encoding set, with later styles overriding earlier styles. Any properties explicitly defined within the mark’s encode block will override a style default.
    
    
      zindex
      Number
      The integer z-index indicating the layering of this mark set relative to other marks, axes, or legends. The default value is 0; higher values (1) will cause this mark set to be drawn on top of other mark, axis, or legend definitions with lower z-index values. Note that this value applies to the all marks in a set, not individual mark items. To adjust the ordering of items within a set, use the zindex encoding channel.
    
  


Accessibility Properties ≥ 5.11

Accessibility properties are used to determine ARIA (Accessible Rich Internet Applications) attributes when using Vega to render SVG output. Vega will automatically generate ARIA “role” and “roleDescription” attributes for container SVG <g> elements for a set of mark items. The properties below can be used to disable ARIA attributes or add additional description text. In addition, individual mark items can have per-item ARIA attributes, defined within encoding channels.


  
    
      Property
      Type
      Description
    
  
  
    
      aria
      Boolean
      A boolean flag (default true) indicating if ARIA attributes should be included (SVG output only). If false, the “aria-hidden” attribute will be set on the output SVG group for the marks, removing the mark from the ARIA accessibility tree.
    
    
      description
      String
      A text description of this mark for ARIA accessibility (SVG output only). If the aria property is true, for SVG output the “aria-label” attribute will be set to this description.
    
  


Mark Clipping

The clip property limits the area in which a set of marks is visible. The default value (boolean false) disables clipping. A boolean true value clips the marks to the width and height of the enclosing group mark. The clip property also accepts a signal that evaluates to a boolean value.

An object specification can be used to define more sophisticated clipping regions. An object-valued clip must have either a path property (for arbitrary SVG paths) or a sphere property (to clip to the globe, relative to a geographic projection), but not both. Either property can be a signal value to enable dynamic clipping regions.


  
    
      Property
      Type
      Description
    
  
  
    
      path
      String | Signal
      An SVG path string describing the clipping region. The path is assumed to lie relative to the coordinate system of the enclosing group.
    
    
      sphere
      String | Signal
      The name of a cartographic projection with which to clip all marks to the projected sphere of the globe. This option is useful in conjunction with map projections that otherwise included projected content (such as graticule lines) outside the bounds of the globe.
    
  


Mark Data Sources (from)

The from property indicates the data source for a set of marks.


  
    
      Property
      Type
      Description
    
  
  
    
      data
      String
      The name of the data set to draw from.
    
    
      facet
      Facet
      An optional facet definition for partitioning data across multiple group marks. Only group mark definitions may use the facet directive.
    
  


Faceting

The facet directive splits up a data source among multiple group mark items. Each group mark is backed by an aggregate data value representing the entire group, and then instantiated with its own named data source that contains a local partition of the data. Facets can either be data-driven, in which partitions are determined by grouping data values according to specified attributes, or pre-faceted, such that a source data value already contains within it an array of sub-values.


  
    
      Property
      Type
      Description
    
  
  
    
      name
      String
      Required. The name of the generated facet data source. Marks defined with the faceted group mark can reference this data source to visualize the local data partition.
    
    
      data
      String
      Required. The name of the source data set from which the facet partitions are generated.
    
    
      field
      Field
      For pre-faceted data, the name of the data field containing an array of data values to use as the local partition. This property is required if using pre-faceted data.
    
    
      groupby
      Field | Field[ ]
      For data-driven facets, an array of field names by which to partition the data. This property is required if using data-driven facets.
    
    
      aggregate
      Object
      For data-driven facets, an optional object containing aggregate transform parameters for the aggregate data values generated for each facet group item. The supported parameters are fields, ops, as, and cross.
    
  


When generating data-driven facets, by default new aggregate data values are generated to serve as the data backing each group mark item. However, if both the data and facet properties are defined in the from object, pre-existing aggregate values will be pulled from the named data source. In such cases it is critical that the aggregate and facet groupby domains match. If they do not match, the behavior of the resulting visualization is undefined.

Reactive Geometry

Typically a "from": {"data": "..."} statement draws data from a backing data source defined within a "data" block. However, Vega can also use a set of marks as the backing data objects for a new set of marks — a feature referred to as reactive geometry. For example, one might add text marks to serve as labels, using computed x, y, width, or height values of the source marks to determine label placement.

To use a set of marks as a backing data source, the mark definition must include a unique name property. The marks can then be referenced as "from": {"data": "name"}.

Here is an example in which point marks serve as the backing data for a set of text marks:

{
  "marks": [
    {
      "name": "baseMarks",
      "type": "point",
      "from": {"data": "source"},
      "encode": {...}
    },
    {
      "type": "text",
      "from": {"data": "baseMarks"},
      "encode": {
        "update": {
          "x": {"field": "x", "offset": 4},
          "y": {"field": "y"},
          "text": {"field": "datum.label"}
        }
      }
    }
  ]
}


Mark Encoding Sets

All visual mark property definitions are specified as name-value pairs in a property set (such as update, enter, or exit). The name is simply the name of the visual property: individual mark types support standardized encoding channel names, but arbitrary names are also allowed, resulting in new named properties on output scenegraph items. The value of a property definition should be a value reference or production rule, as defined below.

The enter set is invoked when a mark item is first instantiated. Unless otherwise indicated, the update set is invoked whenever data or display properties update. The exit set is invoked when the data value backing a mark item is removed. If hover processing is requested on the Vega View instance, the hover set will be invoked upon mouse hover.

Custom encoding sets with arbitrary names are also allowed. To invoke a custom encoding set (e.g., instead of the update set), either pass the encoding set name to the Vega View run method or define a signal event handler with an "encode" directive.

Value References

A value reference specifies the value for a given mark property. The value may be a constant or drawn from a data object. In addition, the value may be run through a scale transform and further modified. Examples include:


  {"value": "left"} - Literal value
  {"field": "amount"} - Data field value
  {"scale": "yscale", "field": "amount"} - Scale-transformed data field value
  {"signal": "hypot(datum.a, datum.b)" - Signal expression value


For more, see the Value type documentation, including the specialized Color Value and Field Value types.

Production Rules

Visual properties can also be set by evaluating an “if-then-else” style chain of production rules. Rules consist of an array of value reference objects, each of which must contain an additional test property. The value of this property should be a predicate expression, that evaluates to true or false. The visual property is set to the value reference corresponding to the first predicate that evaluates to true within the rule.

A single value reference, without a test property, can be specified as the final element within the rule to serve as the “else” condition.
If no test properties evaluate to true, the property is set to this final (predicate-less) value reference. If no “else” condition is specified, the property value defaults to null.

For example, the following specification sets a mark’s fill colour using a production rule:

"fill": [
  {
    "test": "indata('selectedPoints', 'key', datum.key)",
    "scale": "c",
    "field": "species"
  },
  {"value": "grey"}
]


Here, if the ID of a particular data point is found in the selectedPoints data source, the fill color is determined by a scale transform. Otherwise, the mark instance is filled grey.\nVega
            
              Vega-Lite
              Altair
              Vega-Lite API\nVega-Lite
              Altair
              Vega-Lite API\nExamples
              Tutorials
              Documentation
              Usage
              About
            
            
              GitHub
              Try Online\nExamples
              Tutorials
              Documentation
              Usage
              About\nGitHub
              Try Online\nDocumentation
      
      
      
      
        Specification
      
      
      
      
        Config
      
      
      
      
        Data
      
      
      
      
        Transforms
      
      
      
      
        Triggers
      
      
      
      
        Projections
      
      
      
      
        Scales
      
      
      
      
        Schemes
      
      
      
      
        Axes
      
      
      
      
        Legends
      
      
      
      
        Title
      
      
      
      
        Marks
      
      
      
        
        
          arc
        
        
        
          area
        
        
        
          group
        
        
        
          image
        
        
        
          line
        
        
        
          path
        
        
        
          rect
        
        
        
          rule
        
        
        
          shape
        
        
        
          symbol
        
        
        
          text
        
        
        
          trail
        
      
      
      
      
        Signals
      
      
      
      
        Event Streams
      
      
      
      
        Expressions
      
      
      
      
        Layout
      
      
      
      
        Types
      
      
    
  
  
    Marks
    Graphical marks visually encode data using geometric primitives such as rectangles, lines, and plotting symbols. Marks are the basic visual building block of a visualization, providing basic shapes whose properties can be set according to backing data. Mark property definitions may be simple constants or data fields, or scales can be used to map data values to visual values.

Supported Mark Types

The supported mark types are:


  arc - Circular arcs, including pie and donut slices.
  area - Filled areas with horizontal or vertical alignment.
  image - Images, including icons or photographs.
  group - Containers for other marks, useful for sub-plots.
  line - Stroked lines, often used for showing change over time.
  path - Arbitrary paths or polygons, defined using SVG path syntax.
  rect - Rectangles, as in bar charts and timelines.
  rule - Rules are line segments, often used for axis ticks and grid lines.
  shape - A special variant of path marks for faster drawing of cartographic maps.
  symbol - Plotting symbols, including circles, squares and other shapes.
  text - Text labels with configurable fonts, alignment and angle.
  trail - Lines that can change size based on underlying data.


Visual Encoding

Each mark supports a set of visual encoding properties that determine the position and appearance of mark instances. Typically one mark instance is generated per input data element; the exceptions are the line and area mark types, which represent multiple data elements as a single line or area shape.

A mark definition typically looks something like this:

{
  "type": "rect",
  "from": {"data": "table"},
  "encode": {
    "enter": {
      "y": {"scale": "yscale", "field": "value"},
      "y2": {"scale": "yscale", "value": 0},
      "fill": {"value": "steelblue"}
    },
    "update": {...},
    "exit": {...},
    "hover": {...}
  }
}


There are three primary property sets: enter, update, exit. The enter properties are evaluated when data is processed for the first time and a mark instance is newly added to a scene. The update properties are evaluated for all existing (non-exiting) mark instances. The exit properties are evaluated when the data backing a mark is removed, and so the mark is leaving the visual scene. To better understand how enter, update, and exit sets work, take a look at Mike Bostock’s Thinking with Joins.

In addition, an optional hover set determines visual properties when the mouse cursor hovers over a mark instance. Upon mouse out, the update set is applied.

There is also a special group mark type (group) that can contain other marks, as well as local data, signal, scale, axis and legend definitions. Groups can be used to create visualizations consisting of grouped or repeated elements; examples include stacked graphs (each stack is a separate group containing a series of data values) and small multiples displays (each plot is contained in its own group). See the Group Marks page for more.

Top-Level Mark Properties


  
    
      Property
      Type
      Description
    
  
  
    
      type
      String
      Required. The graphical mark type. Must be one of the supported mark types.
    
    
      clip
      Clip
      Indicates if the marks should be clipped to a specified shape (default false). If boolean-valued, the clipping region is the enclosing group’s width and height. If object-valued, should specify either an arbitrary SVG path string or a cartographic projection with which to clip to the sphere of the Earth.
    
    
      encode
      Encode
      An object containing a set of visual encoding rules for mark properties.
    
    
      from
      From
      An object describing the data this mark set should visualize. If undefined, a single element data set containing an empty object is assumed. The from property can either specify a data set to use (e.g., {"data": "table"}) or provide a faceting directive to subdivide a data set across a set of group marks.
    
    
      interactive
      Boolean
      A boolean flag (default true) indicating if the marks can serve as input event sources. If false, no mouse or touch events corresponding to the marks will be generated. This property can also take a Signal value to dynamically toggle interactive status.
    
    
      key
      Field
      A data field to use as a unique key for data binding. When a visualization’s data is updated, the key value will be used to match data elements to existing mark instances. Use a key field to enable object constancy for transitions over dynamic data.
    
    
      name
      String
      A unique name for the mark. This name can be used to refer to these marks within an event stream definition. SVG renderers will add this name value as a CSS class name on the enclosing SVG group (g) element containing the mark instances.
    
    
      on
      Trigger[ ]
      A set of triggers for modifying mark properties in response to signal changes.
    
    
      sort
      Compare
      A comparator for sorting mark items. The sort order will determine the default rendering order. The comparator is defined over generated scenegraph items and sorting is performed after encodings are computed, allowing items to be sorted by size or position. To sort by underlying data properties in addition to mark item properties, append the prefix datum. to a field name (e.g., {"field": "datum.field"}).
    
    
      transform
      Transform[ ]
      A set of post-encoding transforms, applied after any encode blocks, that operate directly on mark scenegraph items (not backing data objects). These can be useful for performing layout with transforms that can set x, y, width, height, etc. properties. Only data transforms that do not generate or filter data objects may be used.
    
    
      role
      String
      A metadata string indicating the role of the mark. SVG renderers will add this role value (prepended with the prefix role-) as a CSS class name on the enclosing SVG group (g) element containing the mark instances. Roles are used internally by Vega to guide layout. Do not set this property unless you know which layout effect you are trying to achieve.
    
    
      style
      String | String[ ]
      A string or array of strings indicating the name of custom styles to apply to the mark. A style is a named collection of mark property defaults defined within the configuration. These properties will be applied to the mark’s enter encoding set, with later styles overriding earlier styles. Any properties explicitly defined within the mark’s encode block will override a style default.
    
    
      zindex
      Number
      The integer z-index indicating the layering of this mark set relative to other marks, axes, or legends. The default value is 0; higher values (1) will cause this mark set to be drawn on top of other mark, axis, or legend definitions with lower z-index values. Note that this value applies to the all marks in a set, not individual mark items. To adjust the ordering of items within a set, use the zindex encoding channel.
    
  


Accessibility Properties ≥ 5.11

Accessibility properties are used to determine ARIA (Accessible Rich Internet Applications) attributes when using Vega to render SVG output. Vega will automatically generate ARIA “role” and “roleDescription” attributes for container SVG <g> elements for a set of mark items. The properties below can be used to disable ARIA attributes or add additional description text. In addition, individual mark items can have per-item ARIA attributes, defined within encoding channels.


  
    
      Property
      Type
      Description
    
  
  
    
      aria
      Boolean
      A boolean flag (default true) indicating if ARIA attributes should be included (SVG output only). If false, the “aria-hidden” attribute will be set on the output SVG group for the marks, removing the mark from the ARIA accessibility tree.
    
    
      description
      String
      A text description of this mark for ARIA accessibility (SVG output only). If the aria property is true, for SVG output the “aria-label” attribute will be set to this description.
    
  


Mark Clipping

The clip property limits the area in which a set of marks is visible. The default value (boolean false) disables clipping. A boolean true value clips the marks to the width and height of the enclosing group mark. The clip property also accepts a signal that evaluates to a boolean value.

An object specification can be used to define more sophisticated clipping regions. An object-valued clip must have either a path property (for arbitrary SVG paths) or a sphere property (to clip to the globe, relative to a geographic projection), but not both. Either property can be a signal value to enable dynamic clipping regions.


  
    
      Property
      Type
      Description
    
  
  
    
      path
      String | Signal
      An SVG path string describing the clipping region. The path is assumed to lie relative to the coordinate system of the enclosing group.
    
    
      sphere
      String | Signal
      The name of a cartographic projection with which to clip all marks to the projected sphere of the globe. This option is useful in conjunction with map projections that otherwise included projected content (such as graticule lines) outside the bounds of the globe.
    
  


Mark Data Sources (from)

The from property indicates the data source for a set of marks.


  
    
      Property
      Type
      Description
    
  
  
    
      data
      String
      The name of the data set to draw from.
    
    
      facet
      Facet
      An optional facet definition for partitioning data across multiple group marks. Only group mark definitions may use the facet directive.
    
  


Faceting

The facet directive splits up a data source among multiple group mark items. Each group mark is backed by an aggregate data value representing the entire group, and then instantiated with its own named data source that contains a local partition of the data. Facets can either be data-driven, in which partitions are determined by grouping data values according to specified attributes, or pre-faceted, such that a source data value already contains within it an array of sub-values.


  
    
      Property
      Type
      Description
    
  
  
    
      name
      String
      Required. The name of the generated facet data source. Marks defined with the faceted group mark can reference this data source to visualize the local data partition.
    
    
      data
      String
      Required. The name of the source data set from which the facet partitions are generated.
    
    
      field
      Field
      For pre-faceted data, the name of the data field containing an array of data values to use as the local partition. This property is required if using pre-faceted data.
    
    
      groupby
      Field | Field[ ]
      For data-driven facets, an array of field names by which to partition the data. This property is required if using data-driven facets.
    
    
      aggregate
      Object
      For data-driven facets, an optional object containing aggregate transform parameters for the aggregate data values generated for each facet group item. The supported parameters are fields, ops, as, and cross.
    
  


When generating data-driven facets, by default new aggregate data values are generated to serve as the data backing each group mark item. However, if both the data and facet properties are defined in the from object, pre-existing aggregate values will be pulled from the named data source. In such cases it is critical that the aggregate and facet groupby domains match. If they do not match, the behavior of the resulting visualization is undefined.

Reactive Geometry

Typically a "from": {"data": "..."} statement draws data from a backing data source defined within a "data" block. However, Vega can also use a set of marks as the backing data objects for a new set of marks — a feature referred to as reactive geometry. For example, one might add text marks to serve as labels, using computed x, y, width, or height values of the source marks to determine label placement.

To use a set of marks as a backing data source, the mark definition must include a unique name property. The marks can then be referenced as "from": {"data": "name"}.

Here is an example in which point marks serve as the backing data for a set of text marks:

{
  "marks": [
    {
      "name": "baseMarks",
      "type": "point",
      "from": {"data": "source"},
      "encode": {...}
    },
    {
      "type": "text",
      "from": {"data": "baseMarks"},
      "encode": {
        "update": {
          "x": {"field": "x", "offset": 4},
          "y": {"field": "y"},
          "text": {"field": "datum.label"}
        }
      }
    }
  ]
}


Mark Encoding Sets

All visual mark property definitions are specified as name-value pairs in a property set (such as update, enter, or exit). The name is simply the name of the visual property: individual mark types support standardized encoding channel names, but arbitrary names are also allowed, resulting in new named properties on output scenegraph items. The value of a property definition should be a value reference or production rule, as defined below.

The enter set is invoked when a mark item is first instantiated. Unless otherwise indicated, the update set is invoked whenever data or display properties update. The exit set is invoked when the data value backing a mark item is removed. If hover processing is requested on the Vega View instance, the hover set will be invoked upon mouse hover.

Custom encoding sets with arbitrary names are also allowed. To invoke a custom encoding set (e.g., instead of the update set), either pass the encoding set name to the Vega View run method or define a signal event handler with an "encode" directive.

Value References

A value reference specifies the value for a given mark property. The value may be a constant or drawn from a data object. In addition, the value may be run through a scale transform and further modified. Examples include:


  {"value": "left"} - Literal value
  {"field": "amount"} - Data field value
  {"scale": "yscale", "field": "amount"} - Scale-transformed data field value
  {"signal": "hypot(datum.a, datum.b)" - Signal expression value


For more, see the Value type documentation, including the specialized Color Value and Field Value types.

Production Rules

Visual properties can also be set by evaluating an “if-then-else” style chain of production rules. Rules consist of an array of value reference objects, each of which must contain an additional test property. The value of this property should be a predicate expression, that evaluates to true or false. The visual property is set to the value reference corresponding to the first predicate that evaluates to true within the rule.

A single value reference, without a test property, can be specified as the final element within the rule to serve as the “else” condition.
If no test properties evaluate to true, the property is set to this final (predicate-less) value reference. If no “else” condition is specified, the property value defaults to null.

For example, the following specification sets a mark’s fill colour using a production rule:

"fill": [
  {
    "test": "indata('selectedPoints', 'key', datum.key)",
    "scale": "c",
    "field": "species"
  },
  {"value": "grey"}
]


Here, if the ID of a particular data point is found in the selectedPoints data source, the fill color is determined by a scale transform. Otherwise, the mark instance is filled grey.\nGraphical marks visually encode data using geometric primitives such as rectangles, lines, and plotting symbols. Marks are the basic visual building block of a visualization, providing basic shapes whose properties can be set according to backing data. Mark property definitions may be simple constants or data fields, or scales can be used to map data values to visual values.\nThe supported mark types are:\narc - Circular arcs, including pie and donut slices.\narea - Filled areas with horizontal or vertical alignment.\nimage - Images, including icons or photographs.\ngroup - Containers for other marks, useful for sub-plots.\nline - Stroked lines, often used for showing change over time.\npath - Arbitrary paths or polygons, defined using SVG path syntax.\nrect - Rectangles, as in bar charts and timelines.\nrule - Rules are line segments, often used for axis ticks and grid lines.\nshape - A special variant of path marks for faster drawing of cartographic maps.\nsymbol - Plotting symbols, including circles, squares and other shapes.\ntext - Text labels with configurable fonts, alignment and angle.\ntrail - Lines that can change size based on underlying data.\nEach mark supports a set of visual encoding properties that determine the position and appearance of mark instances. Typically one mark instance is generated per input data element; the exceptions are the line and area mark types, which represent multiple data elements as a single line or area shape.\nA mark definition typically looks something like this:\n{
  "type": "rect",
  "from": {"data": "table"},
  "encode": {
    "enter": {
      "y": {"scale": "yscale", "field": "value"},
      "y2": {"scale": "yscale", "value": 0},
      "fill": {"value": "steelblue"}
    },
    "update": {...},
    "exit": {...},
    "hover": {...}
  }
}\n{
  "type": "rect",
  "from": {"data": "table"},
  "encode": {
    "enter": {
      "y": {"scale": "yscale", "field": "value"},
      "y2": {"scale": "yscale", "value": 0},
      "fill": {"value": "steelblue"}
    },
    "update": {...},
    "exit": {...},
    "hover": {...}
  }
}\nThere are three primary property sets: enter, update, exit. The enter properties are evaluated when data is processed for the first time and a mark instance is newly added to a scene. The update properties are evaluated for all existing (non-exiting) mark instances. The exit properties are evaluated when the data backing a mark is removed, and so the mark is leaving the visual scene. To better understand how enter, update, and exit sets work, take a look at Mike Bostock’s Thinking with Joins.\nMike Bostock’s Thinking with Joins\nIn addition, an optional hover set determines visual properties when the mouse cursor hovers over a mark instance. Upon mouse out, the update set is applied.\nThere is also a special group mark type (group) that can contain other marks, as well as local data, signal, scale, axis and legend definitions. Groups can be used to create visualizations consisting of grouped or repeated elements; examples include stacked graphs (each stack is a separate group containing a series of data values) and small multiples displays (each plot is contained in its own group). See the Group Marks page for more.\nTop-Level Mark Properties\nRequired. The graphical mark type. Must be one of the supported mark types.\nIndicates if the marks should be clipped to a specified shape (default false). If boolean-valued, the clipping region is the enclosing group’s width and height. If object-valued, should specify either an arbitrary SVG path string or a cartographic projection with which to clip to the sphere of the Earth.\nAn object containing a set of visual encoding rules for mark properties.\nAn object describing the data this mark set should visualize. If undefined, a single element data set containing an empty object is assumed. The from property can either specify a data set to use (e.g., {"data": "table"}) or provide a faceting directive to subdivide a data set across a set of group marks.\nA boolean flag (default true) indicating if the marks can serve as input event sources. If false, no mouse or touch events corresponding to the marks will be generated. This property can also take a Signal value to dynamically toggle interactive status.\nA data field to use as a unique key for data binding. When a visualization’s data is updated, the key value will be used to match data elements to existing mark instances. Use a key field to enable object constancy for transitions over dynamic data.\nA unique name for the mark. This name can be used to refer to these marks within an event stream definition. SVG renderers will add this name value as a CSS class name on the enclosing SVG group (g) element containing the mark instances.\nevent stream definition\nA set of triggers for modifying mark properties in response to signal changes.\nA comparator for sorting mark items. The sort order will determine the default rendering order. The comparator is defined over generated scenegraph items and sorting is performed after encodings are computed, allowing items to be sorted by size or position. To sort by underlying data properties in addition to mark item properties, append the prefix datum. to a field name (e.g., {"field": "datum.field"}).\nA set of post-encoding transforms, applied after any encode blocks, that operate directly on mark scenegraph items (not backing data objects). These can be useful for performing layout with transforms that can set x, y, width, height, etc. properties. Only data transforms that do not generate or filter data objects may be used.\nA metadata string indicating the role of the mark. SVG renderers will add this role value (prepended with the prefix role-) as a CSS class name on the enclosing SVG group (g) element containing the mark instances. Roles are used internally by Vega to guide layout. Do not set this property unless you know which layout effect you are trying to achieve.\nA string or array of strings indicating the name of custom styles to apply to the mark. A style is a named collection of mark property defaults defined within the configuration. These properties will be applied to the mark’s enter encoding set, with later styles overriding earlier styles. Any properties explicitly defined within the mark’s encode block will override a style default.\nThe integer z-index indicating the layering of this mark set relative to other marks, axes, or legends. The default value is 0; higher values (1) will cause this mark set to be drawn on top of other mark, axis, or legend definitions with lower z-index values. Note that this value applies to the all marks in a set, not individual mark items. To adjust the ordering of items within a set, use the zindex encoding channel.\nAccessibility Properties ≥ 5.11\nAccessibility properties are used to determine ARIA (Accessible Rich Internet Applications) attributes when using Vega to render SVG output. Vega will automatically generate ARIA “role” and “roleDescription” attributes for container SVG <g> elements for a set of mark items. The properties below can be used to disable ARIA attributes or add additional description text. In addition, individual mark items can have per-item ARIA attributes, defined within encoding channels.\nARIA (Accessible Rich Internet Applications) attributes\nA boolean flag (default true) indicating if ARIA attributes should be included (SVG output only). If false, the “aria-hidden” attribute will be set on the output SVG group for the marks, removing the mark from the ARIA accessibility tree.\nA text description of this mark for ARIA accessibility (SVG output only). If the aria property is true, for SVG output the “aria-label” attribute will be set to this description.\n“aria-label” attribute\nThe clip property limits the area in which a set of marks is visible. The default value (boolean false) disables clipping. A boolean true value clips the marks to the width and height of the enclosing group mark. The clip property also accepts a signal that evaluates to a boolean value.\nAn object specification can be used to define more sophisticated clipping regions. An object-valued clip must have either a path property (for arbitrary SVG paths) or a sphere property (to clip to the globe, relative to a geographic projection), but not both. Either property can be a signal value to enable dynamic clipping regions.\nAn SVG path string describing the clipping region. The path is assumed to lie relative to the coordinate system of the enclosing group.\nThe name of a cartographic projection with which to clip all marks to the projected sphere of the globe. This option is useful in conjunction with map projections that otherwise included projected content (such as graticule lines) outside the bounds of the globe.\nMark Data Sources (from)\nThe from property indicates the data source for a set of marks.\nThe name of the data set to draw from.\nAn optional facet definition for partitioning data across multiple group marks. Only group mark definitions may use the facet directive.\nThe facet directive splits up a data source among multiple group mark items. Each group mark is backed by an aggregate data value representing the entire group, and then instantiated with its own named data source that contains a local partition of the data. Facets can either be data-driven, in which partitions are determined by grouping data values according to specified attributes, or pre-faceted, such that a source data value already contains within it an array of sub-values.\nRequired. The name of the generated facet data source. Marks defined with the faceted group mark can reference this data source to visualize the local data partition.\nRequired. The name of the source data set from which the facet partitions are generated.\nFor pre-faceted data, the name of the data field containing an array of data values to use as the local partition. This property is required if using pre-faceted data.\nFor data-driven facets, an array of field names by which to partition the data. This property is required if using data-driven facets.\nFor data-driven facets, an optional object containing aggregate transform parameters for the aggregate data values generated for each facet group item. The supported parameters are fields, ops, as, and cross.\naggregate transform parameters\nWhen generating data-driven facets, by default new aggregate data values are generated to serve as the data backing each group mark item. However, if both the data and facet properties are defined in the from object, pre-existing aggregate values will be pulled from the named data source. In such cases it is critical that the aggregate and facet groupby domains match. If they do not match, the behavior of the resulting visualization is undefined.\nTypically a "from": {"data": "..."} statement draws data from a backing data source defined within a "data" block. However, Vega can also use a set of marks as the backing data objects for a new set of marks — a feature referred to as reactive geometry. For example, one might add text marks to serve as labels, using computed x, y, width, or height values of the source marks to determine label placement.\nTo use a set of marks as a backing data source, the mark definition must include a unique name property. The marks can then be referenced as "from": {"data": "name"}.\nHere is an example in which point marks serve as the backing data for a set of text marks:\n{
  "marks": [
    {
      "name": "baseMarks",
      "type": "point",
      "from": {"data": "source"},
      "encode": {...}
    },
    {
      "type": "text",
      "from": {"data": "baseMarks"},
      "encode": {
        "update": {
          "x": {"field": "x", "offset": 4},
          "y": {"field": "y"},
          "text": {"field": "datum.label"}
        }
      }
    }
  ]
}\n{
  "marks": [
    {
      "name": "baseMarks",
      "type": "point",
      "from": {"data": "source"},
      "encode": {...}
    },
    {
      "type": "text",
      "from": {"data": "baseMarks"},
      "encode": {
        "update": {
          "x": {"field": "x", "offset": 4},
          "y": {"field": "y"},
          "text": {"field": "datum.label"}
        }
      }
    }
  ]
}\nAll visual mark property definitions are specified as name-value pairs in a property set (such as update, enter, or exit). The name is simply the name of the visual property: individual mark types support standardized encoding channel names, but arbitrary names are also allowed, resulting in new named properties on output scenegraph items. The value of a property definition should be a value reference or production rule, as defined below.\nThe enter set is invoked when a mark item is first instantiated. Unless otherwise indicated, the update set is invoked whenever data or display properties update. The exit set is invoked when the data value backing a mark item is removed. If hover processing is requested on the Vega View instance, the hover set will be invoked upon mouse hover.\nCustom encoding sets with arbitrary names are also allowed. To invoke a custom encoding set (e.g., instead of the update set), either pass the encoding set name to the Vega View run method or define a signal event handler with an "encode" directive.\nsignal event handler with an "encode" directive\nA value reference specifies the value for a given mark property. The value may be a constant or drawn from a data object. In addition, the value may be run through a scale transform and further modified. Examples include:\n{"value": "left"} - Literal value\n{"field": "amount"} - Data field value\n{"scale": "yscale", "field": "amount"} - Scale-transformed data field value\n{"signal": "hypot(datum.a, datum.b)" - Signal expression value\nFor more, see the Value type documentation, including the specialized Color Value and Field Value types.\nValue type documentation\nVisual properties can also be set by evaluating an “if-then-else” style chain of production rules. Rules consist of an array of value reference objects, each of which must contain an additional test property. The value of this property should be a predicate expression, that evaluates to true or false. The visual property is set to the value reference corresponding to the first predicate that evaluates to true within the rule.\nA single value reference, without a test property, can be specified as the final element within the rule to serve as the “else” condition.
If no test properties evaluate to true, the property is set to this final (predicate-less) value reference. If no “else” condition is specified, the property value defaults to null.\nFor example, the following specification sets a mark’s fill colour using a production rule:\n"fill": [
  {
    "test": "indata('selectedPoints', 'key', datum.key)",
    "scale": "c",
    "field": "species"
  },
  {"value": "grey"}
]\n"fill": [
  {
    "test": "indata('selectedPoints', 'key', datum.key)",
    "scale": "c",
    "field": "species"
  },
  {"value": "grey"}
]\n"indata('selectedPoints', 'key', datum.key)"\nHere, if the ID of a particular data point is found in the selectedPoints data source, the fill color is determined by a scale transform. Otherwise, the mark instance is filled grey.\n\n\nVega
            
              Vega-Lite
              Altair
              Vega-Lite API
            
          
          
            
              Examples
              Tutorials
              Documentation
              Usage
              About
            
            
              GitHub
              Try Online
            
          
        
      

      
        

  
  
    
      
      
        Documentation
      
      
      
      
        Specification
      
      
      
      
        Config
      
      
      
      
        Data
      
      
      
      
        Transforms
      
      
      
      
        Triggers
      
      
      
      
        Projections
      
      
      
      
        Scales
      
      
      
      
        Schemes
      
      
      
      
        Axes
      
      
      
      
        Legends
      
      
      
      
        Title
      
      
      
      
        Marks
      
      
      
      
        Signals
      
      
      
      
        Event Streams
      
      
      
      
        Expressions
      
      
      
      
        Layout
      
      
      
      
        Types
      
      
    
  
  
    Signals
    Signals are dynamic variables that parameterize a visualization and can drive interactive behaviors. Signals can be used throughout a Vega specification, for example to define a mark property or data transform parameter.

Signal values are reactive: they can update in response to input event streams, external API calls, or changes to upstream signals. Event streams capture and sequence input events, such as mousedown or touchmove. When an event occurs, signals with associated event handlers are re-evaluated in their specification order. Updated signal values then propagate to the rest of the specification, and the visualization is re-rendered automatically.

A signal definition, and its use in the rest of a specification, looks something like this:

{
  "signals": [
    {
      "name": "indexDate",
      "description": "A date value that updates in response to mousemove.",
      "update": "datetime(2005, 0, 1)",
      "on": [{"events": "mousemove", "update": "invert('xscale', x())"}]
    }
  ],
  "data": [
    { "name": "stocks", ... },
    {
      "name": "index",
      "source": "stocks",
      "transform": [
        {
          "type": "filter",
          "expr": "month(datum.date) === month(indexDate)"
        }
      ]
    }
  ],
  "scales": [
    { "name": "x", "type": "time", ... }
  ],
  "marks": [
    {
      "type": "rule",
      "encode": {
        "update": {
          "x": {"scale": "x", "signal": "indexDate"}
        }
      }
    }
  ]
}


Signal Properties

Signal definitions may use the following properties.


  
    
      Property
      Type
      Description
    
  
  
    
      name
      String
      Required. A unique name for the signal. Signal names should be valid JavaScript identifiers: they should contain only alphanumeric characters (or “$”, or “_”) and may not start with a digit. Reserved keywords that may not be used as signal names are "datum", "event", "item", and "parent".
    
    
      bind
      Bind
      Binds the signal to an external input element such as a slider, selection list or radio button group.
    
    
      description
      String
      A text description of the signal, useful for inline documentation.
    
    
      on
      Handler[ ]
      An array of event stream handlers for updating the signal value in response to input events.
    
    
      init
      Expression
      ≥ 4.4 An initialization expression for the value of the signal. This expression will be invoked once and only once. The init and update parameters are mutually exclusive and can not be used together.
    
    
      update
      Expression
      An update expression for the value of the signal. This expression may include other signals, in which case the signal will automatically update in response to upstream signal changes, so long as the react property is not false. The init and update parameters are mutually exclusive and can not be used together.
    
    
      react
      Boolean
      A boolean flag (default true) indicating if the update expression should be automatically re-evaluated when any upstream signal dependencies update. If false, the update expression will not register any dependencies on other signals, even for initialization.
    
    
      value
      Any
      The initial value of the signal (default undefined). This value is assigned prior to evaluating either the init or update expression.
    
  


Built-in signals

A few signal names are automatically processed and/or reserved:


  Signals for the specification width, height, padding, autosize, and (for version ≥ 5.10) background properties are automatically defined. Specifications may include definitions for these signals in the top-level signals array, in which case the definitions will be merged with any top-level specification property values, with precedence given to properties defined in the signals array.
  Group mark instances automatically include a parent signal bound to the data object for that group. Specifications may not define a signal named parent.
  The signal names datum, item, and event are reserved for top-level variables within expressions. Specifications may not define signals named datum, item or event.
  If you define a signal named cursor, its value will automatically drive the CSS mouse cursor for the Vega view. For more, see the cursor signal documentation below.


The cursor Signal

By default, Vega will style the mouse pointer when it is over a mark with a defined cursor property. However, in some interactive use cases, the cursor style should persist for the entire duration of an interaction (e.g., while dragging, regardless if the cursor remains over the item where the drag initiated). For more control, Vega provides a dedicated cursor signal. When the value of this signal is set, Vega uses it in lieu of any cursor properties set on marks. If the value is set to "default", Vega resumes using the mark-based cursor property.

Nested Signals

Signals can be defined either in the top-level scope of a specification or within a group mark definition. If a signal is defined within a nested group, it is accessible only within the scope of that group; any marks, axes, legends, etc. that reference the signal must be contained within the group. If a nested signal has the same name as a signal defined in an outer scope, the new signal will override the previously defined signal.

In addition to new signal definitions, nested group marks may contain signal updates that target a signal defined in an outer scope. The "push": "outer" property indicates that, rather than create a new signal, updates should explicitly target an existing signal. Nested signal updates may not include value or update properties. The supported properties for signal updates are:


  
    
      Property
      Type
      Description
    
  
  
    
      name
      String
      Required. The name of the signal to update.
    
    
      push
      String
      Required. To indicate an update to a signal defined in an outer scope, the push property must be set to "outer".
    
    
      description
      String
      A text description of the signal, useful for documentation.
    
    
      on
      Handler[ ]
      An array of event stream handlers for updating the signal value in response to input events.
    
  


Event Handlers

An event handler object includes an event stream definition indicating which events to respond to, and either an update expression for setting a new signal value, or an encode set for updating the mark being interacted with.


  
    
      Property
      Type
      Description
    
  
  
    
      events
      EventStream
      Required. The events to respond to.
    
    
      update
      Expression
      An expression that is evaluated when events occur, the result then becomes the new signal value. This property is required if encode is not specified.
    
    
      encode
      String
      The name of a mark property encoding set to re-evaluate for the mark item that was the source of the input event. This property is required if update is not specified.
    
    
      force
      Boolean
      A boolean flag (default false) indicating whether or not updates that do not change the signal value should propagate. For example, if set to true and an input stream update sets the signal to its current value, downstream signals will still be notified of an update.
    
  


This signal definition increments its value upon mouseover of rect items:

{
  "name": "count",
  "value": 0,
  "on": [
    {"events": "rect:mouseover", "update": "count + 1"}
  ]
}


This signal definition invokes a custom encoding set upon mousedown and mouseup on mark items. The mark definition must include properties named "select" and "release" under the mark "encode" property.

{
  "name": "clickEncode",
  "on": [
    {"events": "*:mousedown", "encode": "select"},
    {"events": "*:mouseup", "encode": "release"}
  ]
}


Input Element Binding

The bind property binds a signal to an input element defined outside of the visualization. Vega will generate new HTML form elements and set up a two-way binding: changes to the input element will update the signal, and vice versa. Vega includes dedicated support for checkbox (single boolean value), radio (group of radio buttons), select (drop-down menu), and range (slider) input types. Alternatively, Vega can also bind directly to externally-defined input elements.


  
    
      Property
      Type
      Description
    
  
  
    
      input
      String
      Required. The type of input element to use. The valid values are checkbox, radio, range, select, and any other legal HTML form input type.
    
    
      element
      String
      An optional CSS selector string indicating the parent element to which the input element should be added. By default, all input elements are added within the parent container of the Vega view.
    
    
      name
      String
      By default, the signal name is used to label input elements. This name property can be used to specify a custom label instead for the bound signal.
    
    
      debounce
      Number
      If defined, delays event handling until the specified milliseconds have elapsed since the last event was fired.
    
  


Radio and Select Input Properties


  
    
      Property
      Type
      Description
    
  
  
    
      options
      Array
      Required. An array of options to select from.
    
    
      labels
      String[ ]
      ≥ 5.9 An array of label strings to represent the options values. If unspecified, the options value will be coerced to a string and used as the label.
    
    
      name
      String
      By default, the signal name is used to label input elements. This name property can be used to specify a custom label instead for the bound signal.
    
    
      debounce
      Number
      If defined, delays event handling until the specified milliseconds have elapsed since the last event was fired.
    
  


Range Input Properties


  
    
      Property
      Type
      Description
    
  
  
    
      max
      Number
      For range inputs, sets the maximum slider value. Defaults to the larger of the signal value and 100.
    
    
      min
      Number
      For range inputs, sets the minimum slider value. Defaults to the smaller of the signal value and 0.
    
    
      step
      Number
      For range inputs, sets the minimum slider increment. If undefined, the step size will be automatically determined based on the min and max values.
    
    
      name
      String
      By default, the signal name is used to label input elements. This name property can be used to specify a custom label instead for the bound signal.
    
    
      debounce
      Number
      If defined, delays event handling until the specified milliseconds have elapsed since the last event was fired.
    
  


Other Input Types

In addition, any valid HTML input type may be used as the value of the input property. Examples include "text" (for single-line text entry), "color" (for a color picker), and "date" (for entering year, month and day).
In these cases, any extra properties defined (e.g., placeholder for "text" input) will be added as attributes of the generated HTML form element.

Binding Directly to External Elements

Rather than generate its own input elements, Vega also supports binding directly to an existing element defined externally. To do so, the input property must be undefined, and the element property must reference an existing, externally defined element.


  
    
      Property
      Type
      Description
    
  
  
    
      element
      String
      Required. An input element that exposes a value property and supports the EventTarget interface, or a CSS selector string to such an element. When the element updates and dispatches an event, the value property will be used as the new, bound signal value. When the signal updates independent of the element, the value property will be set to the signal value and a new event will be dispatched on the element.
    
    
      event
      String
      The event (default "input") to listen for to track changes on the external element.
    
    
      debounce
      Number
      If defined, delays event handling until the specified milliseconds have elapsed since the last event was fired.\nVega
            
              Vega-Lite
              Altair
              Vega-Lite API\nVega-Lite
              Altair
              Vega-Lite API\nExamples
              Tutorials
              Documentation
              Usage
              About
            
            
              GitHub
              Try Online\nExamples
              Tutorials
              Documentation
              Usage
              About\nGitHub
              Try Online\nDocumentation
      
      
      
      
        Specification
      
      
      
      
        Config
      
      
      
      
        Data
      
      
      
      
        Transforms
      
      
      
      
        Triggers
      
      
      
      
        Projections
      
      
      
      
        Scales
      
      
      
      
        Schemes
      
      
      
      
        Axes
      
      
      
      
        Legends
      
      
      
      
        Title
      
      
      
      
        Marks
      
      
      
      
        Signals
      
      
      
      
        Event Streams
      
      
      
      
        Expressions
      
      
      
      
        Layout
      
      
      
      
        Types
      
      
    
  
  
    Signals
    Signals are dynamic variables that parameterize a visualization and can drive interactive behaviors. Signals can be used throughout a Vega specification, for example to define a mark property or data transform parameter.

Signal values are reactive: they can update in response to input event streams, external API calls, or changes to upstream signals. Event streams capture and sequence input events, such as mousedown or touchmove. When an event occurs, signals with associated event handlers are re-evaluated in their specification order. Updated signal values then propagate to the rest of the specification, and the visualization is re-rendered automatically.

A signal definition, and its use in the rest of a specification, looks something like this:

{
  "signals": [
    {
      "name": "indexDate",
      "description": "A date value that updates in response to mousemove.",
      "update": "datetime(2005, 0, 1)",
      "on": [{"events": "mousemove", "update": "invert('xscale', x())"}]
    }
  ],
  "data": [
    { "name": "stocks", ... },
    {
      "name": "index",
      "source": "stocks",
      "transform": [
        {
          "type": "filter",
          "expr": "month(datum.date) === month(indexDate)"
        }
      ]
    }
  ],
  "scales": [
    { "name": "x", "type": "time", ... }
  ],
  "marks": [
    {
      "type": "rule",
      "encode": {
        "update": {
          "x": {"scale": "x", "signal": "indexDate"}
        }
      }
    }
  ]
}


Signal Properties

Signal definitions may use the following properties.


  
    
      Property
      Type
      Description
    
  
  
    
      name
      String
      Required. A unique name for the signal. Signal names should be valid JavaScript identifiers: they should contain only alphanumeric characters (or “$”, or “_”) and may not start with a digit. Reserved keywords that may not be used as signal names are "datum", "event", "item", and "parent".
    
    
      bind
      Bind
      Binds the signal to an external input element such as a slider, selection list or radio button group.
    
    
      description
      String
      A text description of the signal, useful for inline documentation.
    
    
      on
      Handler[ ]
      An array of event stream handlers for updating the signal value in response to input events.
    
    
      init
      Expression
      ≥ 4.4 An initialization expression for the value of the signal. This expression will be invoked once and only once. The init and update parameters are mutually exclusive and can not be used together.
    
    
      update
      Expression
      An update expression for the value of the signal. This expression may include other signals, in which case the signal will automatically update in response to upstream signal changes, so long as the react property is not false. The init and update parameters are mutually exclusive and can not be used together.
    
    
      react
      Boolean
      A boolean flag (default true) indicating if the update expression should be automatically re-evaluated when any upstream signal dependencies update. If false, the update expression will not register any dependencies on other signals, even for initialization.
    
    
      value
      Any
      The initial value of the signal (default undefined). This value is assigned prior to evaluating either the init or update expression.
    
  


Built-in signals

A few signal names are automatically processed and/or reserved:


  Signals for the specification width, height, padding, autosize, and (for version ≥ 5.10) background properties are automatically defined. Specifications may include definitions for these signals in the top-level signals array, in which case the definitions will be merged with any top-level specification property values, with precedence given to properties defined in the signals array.
  Group mark instances automatically include a parent signal bound to the data object for that group. Specifications may not define a signal named parent.
  The signal names datum, item, and event are reserved for top-level variables within expressions. Specifications may not define signals named datum, item or event.
  If you define a signal named cursor, its value will automatically drive the CSS mouse cursor for the Vega view. For more, see the cursor signal documentation below.


The cursor Signal

By default, Vega will style the mouse pointer when it is over a mark with a defined cursor property. However, in some interactive use cases, the cursor style should persist for the entire duration of an interaction (e.g., while dragging, regardless if the cursor remains over the item where the drag initiated). For more control, Vega provides a dedicated cursor signal. When the value of this signal is set, Vega uses it in lieu of any cursor properties set on marks. If the value is set to "default", Vega resumes using the mark-based cursor property.

Nested Signals

Signals can be defined either in the top-level scope of a specification or within a group mark definition. If a signal is defined within a nested group, it is accessible only within the scope of that group; any marks, axes, legends, etc. that reference the signal must be contained within the group. If a nested signal has the same name as a signal defined in an outer scope, the new signal will override the previously defined signal.

In addition to new signal definitions, nested group marks may contain signal updates that target a signal defined in an outer scope. The "push": "outer" property indicates that, rather than create a new signal, updates should explicitly target an existing signal. Nested signal updates may not include value or update properties. The supported properties for signal updates are:


  
    
      Property
      Type
      Description
    
  
  
    
      name
      String
      Required. The name of the signal to update.
    
    
      push
      String
      Required. To indicate an update to a signal defined in an outer scope, the push property must be set to "outer".
    
    
      description
      String
      A text description of the signal, useful for documentation.
    
    
      on
      Handler[ ]
      An array of event stream handlers for updating the signal value in response to input events.
    
  


Event Handlers

An event handler object includes an event stream definition indicating which events to respond to, and either an update expression for setting a new signal value, or an encode set for updating the mark being interacted with.


  
    
      Property
      Type
      Description
    
  
  
    
      events
      EventStream
      Required. The events to respond to.
    
    
      update
      Expression
      An expression that is evaluated when events occur, the result then becomes the new signal value. This property is required if encode is not specified.
    
    
      encode
      String
      The name of a mark property encoding set to re-evaluate for the mark item that was the source of the input event. This property is required if update is not specified.
    
    
      force
      Boolean
      A boolean flag (default false) indicating whether or not updates that do not change the signal value should propagate. For example, if set to true and an input stream update sets the signal to its current value, downstream signals will still be notified of an update.
    
  


This signal definition increments its value upon mouseover of rect items:

{
  "name": "count",
  "value": 0,
  "on": [
    {"events": "rect:mouseover", "update": "count + 1"}
  ]
}


This signal definition invokes a custom encoding set upon mousedown and mouseup on mark items. The mark definition must include properties named "select" and "release" under the mark "encode" property.

{
  "name": "clickEncode",
  "on": [
    {"events": "*:mousedown", "encode": "select"},
    {"events": "*:mouseup", "encode": "release"}
  ]
}


Input Element Binding

The bind property binds a signal to an input element defined outside of the visualization. Vega will generate new HTML form elements and set up a two-way binding: changes to the input element will update the signal, and vice versa. Vega includes dedicated support for checkbox (single boolean value), radio (group of radio buttons), select (drop-down menu), and range (slider) input types. Alternatively, Vega can also bind directly to externally-defined input elements.


  
    
      Property
      Type
      Description
    
  
  
    
      input
      String
      Required. The type of input element to use. The valid values are checkbox, radio, range, select, and any other legal HTML form input type.
    
    
      element
      String
      An optional CSS selector string indicating the parent element to which the input element should be added. By default, all input elements are added within the parent container of the Vega view.
    
    
      name
      String
      By default, the signal name is used to label input elements. This name property can be used to specify a custom label instead for the bound signal.
    
    
      debounce
      Number
      If defined, delays event handling until the specified milliseconds have elapsed since the last event was fired.
    
  


Radio and Select Input Properties


  
    
      Property
      Type
      Description
    
  
  
    
      options
      Array
      Required. An array of options to select from.
    
    
      labels
      String[ ]
      ≥ 5.9 An array of label strings to represent the options values. If unspecified, the options value will be coerced to a string and used as the label.
    
    
      name
      String
      By default, the signal name is used to label input elements. This name property can be used to specify a custom label instead for the bound signal.
    
    
      debounce
      Number
      If defined, delays event handling until the specified milliseconds have elapsed since the last event was fired.
    
  


Range Input Properties


  
    
      Property
      Type
      Description
    
  
  
    
      max
      Number
      For range inputs, sets the maximum slider value. Defaults to the larger of the signal value and 100.
    
    
      min
      Number
      For range inputs, sets the minimum slider value. Defaults to the smaller of the signal value and 0.
    
    
      step
      Number
      For range inputs, sets the minimum slider increment. If undefined, the step size will be automatically determined based on the min and max values.
    
    
      name
      String
      By default, the signal name is used to label input elements. This name property can be used to specify a custom label instead for the bound signal.
    
    
      debounce
      Number
      If defined, delays event handling until the specified milliseconds have elapsed since the last event was fired.
    
  


Other Input Types

In addition, any valid HTML input type may be used as the value of the input property. Examples include "text" (for single-line text entry), "color" (for a color picker), and "date" (for entering year, month and day).
In these cases, any extra properties defined (e.g., placeholder for "text" input) will be added as attributes of the generated HTML form element.

Binding Directly to External Elements

Rather than generate its own input elements, Vega also supports binding directly to an existing element defined externally. To do so, the input property must be undefined, and the element property must reference an existing, externally defined element.


  
    
      Property
      Type
      Description
    
  
  
    
      element
      String
      Required. An input element that exposes a value property and supports the EventTarget interface, or a CSS selector string to such an element. When the element updates and dispatches an event, the value property will be used as the new, bound signal value. When the signal updates independent of the element, the value property will be set to the signal value and a new event will be dispatched on the element.
    
    
      event
      String
      The event (default "input") to listen for to track changes on the external element.
    
    
      debounce
      Number
      If defined, delays event handling until the specified milliseconds have elapsed since the last event was fired.\nSignals are dynamic variables that parameterize a visualization and can drive interactive behaviors. Signals can be used throughout a Vega specification, for example to define a mark property or data transform parameter.\nSignal values are reactive: they can update in response to input event streams, external API calls, or changes to upstream signals. Event streams capture and sequence input events, such as mousedown or touchmove. When an event occurs, signals with associated event handlers are re-evaluated in their specification order. Updated signal values then propagate to the rest of the specification, and the visualization is re-rendered automatically.\nA signal definition, and its use in the rest of a specification, looks something like this:\n{
  "signals": [
    {
      "name": "indexDate",
      "description": "A date value that updates in response to mousemove.",
      "update": "datetime(2005, 0, 1)",
      "on": [{"events": "mousemove", "update": "invert('xscale', x())"}]
    }
  ],
  "data": [
    { "name": "stocks", ... },
    {
      "name": "index",
      "source": "stocks",
      "transform": [
        {
          "type": "filter",
          "expr": "month(datum.date) === month(indexDate)"
        }
      ]
    }
  ],
  "scales": [
    { "name": "x", "type": "time", ... }
  ],
  "marks": [
    {
      "type": "rule",
      "encode": {
        "update": {
          "x": {"scale": "x", "signal": "indexDate"}
        }
      }
    }
  ]
}\n{
  "signals": [
    {
      "name": "indexDate",
      "description": "A date value that updates in response to mousemove.",
      "update": "datetime(2005, 0, 1)",
      "on": [{"events": "mousemove", "update": "invert('xscale', x())"}]
    }
  ],
  "data": [
    { "name": "stocks", ... },
    {
      "name": "index",
      "source": "stocks",
      "transform": [
        {
          "type": "filter",
          "expr": "month(datum.date) === month(indexDate)"
        }
      ]
    }
  ],
  "scales": [
    { "name": "x", "type": "time", ... }
  ],
  "marks": [
    {
      "type": "rule",
      "encode": {
        "update": {
          "x": {"scale": "x", "signal": "indexDate"}
        }
      }
    }
  ]
}\n"A date value that updates in response to mousemove."\n"datetime(2005, 0, 1)"\n"invert('xscale', x())"\n"month(datum.date) === month(indexDate)"\nSignal definitions may use the following properties.\nRequired. A unique name for the signal. Signal names should be valid JavaScript identifiers: they should contain only alphanumeric characters (or “$”, or “_”) and may not start with a digit. Reserved keywords that may not be used as signal names are "datum", "event", "item", and "parent".\nJavaScript identifiers\nBinds the signal to an external input element such as a slider, selection list or radio button group.\nA text description of the signal, useful for inline documentation.\nAn array of event stream handlers for updating the signal value in response to input events.\nevent stream handlers\n≥ 4.4 An initialization expression for the value of the signal. This expression will be invoked once and only once. The init and update parameters are mutually exclusive and can not be used together.\nAn update expression for the value of the signal. This expression may include other signals, in which case the signal will automatically update in response to upstream signal changes, so long as the react property is not false. The init and update parameters are mutually exclusive and can not be used together.\nA boolean flag (default true) indicating if the update expression should be automatically re-evaluated when any upstream signal dependencies update. If false, the update expression will not register any dependencies on other signals, even for initialization.\nThe initial value of the signal (default undefined). This value is assigned prior to evaluating either the init or update expression.\nA few signal names are automatically processed and/or reserved:\nSignals for the specification width, height, padding, autosize, and (for version ≥ 5.10) background properties are automatically defined. Specifications may include definitions for these signals in the top-level signals array, in which case the definitions will be merged with any top-level specification property values, with precedence given to properties defined in the signals array.\nGroup mark instances automatically include a parent signal bound to the data object for that group. Specifications may not define a signal named parent.\nThe signal names datum, item, and event are reserved for top-level variables within expressions. Specifications may not define signals named datum, item or event.\nIf you define a signal named cursor, its value will automatically drive the CSS mouse cursor for the Vega view. For more, see the cursor signal documentation below.\ncursor signal documentation\nBy default, Vega will style the mouse pointer when it is over a mark with a defined cursor property. However, in some interactive use cases, the cursor style should persist for the entire duration of an interaction (e.g., while dragging, regardless if the cursor remains over the item where the drag initiated). For more control, Vega provides a dedicated cursor signal. When the value of this signal is set, Vega uses it in lieu of any cursor properties set on marks. If the value is set to "default", Vega resumes using the mark-based cursor property.\nSignals can be defined either in the top-level scope of a specification or within a group mark definition. If a signal is defined within a nested group, it is accessible only within the scope of that group; any marks, axes, legends, etc. that reference the signal must be contained within the group. If a nested signal has the same name as a signal defined in an outer scope, the new signal will override the previously defined signal.\nIn addition to new signal definitions, nested group marks may contain signal updates that target a signal defined in an outer scope. The "push": "outer" property indicates that, rather than create a new signal, updates should explicitly target an existing signal. Nested signal updates may not include value or update properties. The supported properties for signal updates are:\nRequired. The name of the signal to update.\nRequired. To indicate an update to a signal defined in an outer scope, the push property must be set to "outer".\nA text description of the signal, useful for documentation.\nAn array of event stream handlers for updating the signal value in response to input events.\nevent stream handlers\nAn event handler object includes an event stream definition indicating which events to respond to, and either an update expression for setting a new signal value, or an encode set for updating the mark being interacted with.\nRequired. The events to respond to.\nAn expression that is evaluated when events occur, the result then becomes the new signal value. This property is required if encode is not specified.\nThe name of a mark property encoding set to re-evaluate for the mark item that was the source of the input event. This property is required if update is not specified.\nA boolean flag (default false) indicating whether or not updates that do not change the signal value should propagate. For example, if set to true and an input stream update sets the signal to its current value, downstream signals will still be notified of an update.\nThis signal definition increments its value upon mouseover of rect items:\n{
  "name": "count",
  "value": 0,
  "on": [
    {"events": "rect:mouseover", "update": "count + 1"}
  ]
}\n{
  "name": "count",
  "value": 0,
  "on": [
    {"events": "rect:mouseover", "update": "count + 1"}
  ]
}\nThis signal definition invokes a custom encoding set upon mousedown and mouseup on mark items. The mark definition must include properties named "select" and "release" under the mark "encode" property.\n{
  "name": "clickEncode",
  "on": [
    {"events": "*:mousedown", "encode": "select"},
    {"events": "*:mouseup", "encode": "release"}
  ]
}\n{
  "name": "clickEncode",
  "on": [
    {"events": "*:mousedown", "encode": "select"},
    {"events": "*:mouseup", "encode": "release"}
  ]
}\nInput Element Binding\nThe bind property binds a signal to an input element defined outside of the visualization. Vega will generate new HTML form elements and set up a two-way binding: changes to the input element will update the signal, and vice versa. Vega includes dedicated support for checkbox (single boolean value), radio (group of radio buttons), select (drop-down menu), and range (slider) input types. Alternatively, Vega can also bind directly to externally-defined input elements.\nexternally-defined input elements\nRequired. The type of input element to use. The valid values are checkbox, radio, range, select, and any other legal HTML form input type.\nAn optional CSS selector string indicating the parent element to which the input element should be added. By default, all input elements are added within the parent container of the Vega view.\nBy default, the signal name is used to label input elements. This name property can be used to specify a custom label instead for the bound signal.\nIf defined, delays event handling until the specified milliseconds have elapsed since the last event was fired.\nRadio and Select Input Properties\nRequired. An array of options to select from.\n≥ 5.9 An array of label strings to represent the options values. If unspecified, the options value will be coerced to a string and used as the label.\nBy default, the signal name is used to label input elements. This name property can be used to specify a custom label instead for the bound signal.\nIf defined, delays event handling until the specified milliseconds have elapsed since the last event was fired.\nRange Input Properties\nFor range inputs, sets the maximum slider value. Defaults to the larger of the signal value and 100.\nFor range inputs, sets the minimum slider value. Defaults to the smaller of the signal value and 0.\nFor range inputs, sets the minimum slider increment. If undefined, the step size will be automatically determined based on the min and max values.\nBy default, the signal name is used to label input elements. This name property can be used to specify a custom label instead for the bound signal.\nIf defined, delays event handling until the specified milliseconds have elapsed since the last event was fired.\nIn addition, any valid HTML input type may be used as the value of the input property. Examples include "text" (for single-line text entry), "color" (for a color picker), and "date" (for entering year, month and day).
In these cases, any extra properties defined (e.g., placeholder for "text" input) will be added as attributes of the generated HTML form element.\nBinding Directly to External Elements\nRather than generate its own input elements, Vega also supports binding directly to an existing element defined externally. To do so, the input property must be undefined, and the element property must reference an existing, externally defined element.\nRequired. An input element that exposes a value property and supports the EventTarget interface, or a CSS selector string to such an element. When the element updates and dispatches an event, the value property will be used as the new, bound signal value. When the signal updates independent of the element, the value property will be set to the signal value and a new event will be dispatched on the element.\nThe event (default "input") to listen for to track changes on the external element.\nIf defined, delays event handling until the specified milliseconds have elapsed since the last event was fired.\n\n\nVega
            
              Vega-Lite
              Altair
              Vega-Lite API
            
          
          
            
              Examples
              Tutorials
              Documentation
              Usage
              About
            
            
              GitHub
              Try Online
            
          
        
      

      
        

  
  
    
      
      
        Documentation
      
      
      
      
        Specification
      
      
      
      
        Config
      
      
      
      
        Data
      
      
      
      
        Transforms
      
      
      
      
        Triggers
      
      
      
      
        Projections
      
      
      
      
        Scales
      
      
      
      
        Schemes
      
      
      
      
        Axes
      
      
      
      
        Legends
      
      
      
      
        Title
      
      
      
      
        Marks
      
      
      
      
        Signals
      
      
      
      
        Event Streams
      
      
      
      
        Expressions
      
      
      
      
        Layout
      
      
      
      
        Types
      
      
    
  
  
    Config
    A config object defines default visual values to set a visualization’s theme.

The Vega parser accepts a JSON configuration file that defines default settings for a variety of visual encoding choices. Different configuration files can be used to “theme” charts with a customized look and feel. A configuration file is simply a JSON object with a set of named properties, grouped by type. To provide a configuration file at parse-time, simply pass an additional parameter to the parse method:

var runtime = vega.parse(spec, config);


In addition, Vega JSON specifications may contain a single, top-level config property to override any configuration settings. Any configuration provided within the specification itself will take precedence over external configurations passed to the parser.

For example, this Vega spec includes light-gray axis grid lines by default:

{
  "width": 500,
  "height": 200,
  "config": {
    "axis": {
      "grid": true,
      "gridColor": "#dedede"
    }
  },
  ...
}


Config Reference


  View Properties
  Event Properties
  Mark Properties
  Style Properties
  Axis Properties
  Legend Properties
  Title Properties
  Projection Properties
  Scale Range Properties
  Signals


View Properties

Properties defined in the top-level scope of the configuration object.


  
    
      Property
      Type
      Description
    
  
  
    
      autosize
      String | Object | Signal
      Default automatic sizing setting. Valid string values are "pad", "fit" or "none". See the autosize documentation for more. Signal support available in versions ≥ 5.10.
    
    
      background
      Color | Signal
      Background color of the view component, or null for transparent. Signal support available in versions ≥ 5.10.
    
    
      description
      String
      The default text description for visualizations. The description determines the aria-label attribute for the container element of a Vega view. ≥ 5.10
    
    
      padding
      Number | Object | Signal
      The padding in pixels to add around the visualization. If a number, specifies padding for all sides. If an object, the value should have the format {"left": 5, "top": 5, "right": 5, "bottom": 5}. Signal support available in versions ≥ 5.10.
    
    
      width
      Number | Signal
      The width in pixels of the data rectangle. ≥ 5.10
    
    
      height
      Number | Signal
      The height in pixels of the data rectangle. ≥ 5.10
    
    
      group
      Object
      Default properties for the top-level group mark representing the data rectangle of a chart. Valid properties of this object are mark properties such as "fill", "stroke" and "strokeWidth".
    
    
      locale
      Object
      Locale definitions for string parsing and formatting of number and date values. The locale object should contain number and/or time properties with locale definitions. Locale definitions provided in the config block may be overridden by the View constructor locale option. ≥ 5.12
    
    
      lineBreak
      String | Signal
      A delimiter, such as a newline character, upon which to break text strings into multiple lines. This property provides a global default for text marks, which is overridden by mark or style config settings, and by the lineBreak mark encoding channel. If signal-valued, either string or regular expression (regexp) values are valid. ≥ 5.10
    
  


Usage

Set default view background and chart plotting area background colors:

{
  "background": "white",
  "group": {
    "fill": "#dedede"
  }
}


Set the number and time format locale to German:

{
  "locale": {
    "number": {
      "decimal": ",",
      "thousands": ".",
      "grouping": [3],
      "currency": ["", " €"]
    },
    "time": {
      "dateTime": "%A, der %e. %B %Y, %X",
      "date": "%d.%m.%Y",
      "time": "%H:%M:%S",
      "periods": ["AM", "PM"],
      "days": ["Sonntag", "Montag", "Dienstag", "Mittwoch", "Donnerstag", "Freitag", "Samstag"],
      "shortDays": ["So", "Mo", "Di", "Mi", "Do", "Fr", "Sa"],
      "months": ["Januar", "Februar", "März", "April", "Mai", "Juni", "Juli", "August", "September", "Oktober", "November", "Dezember"],
      "shortMonths": [ "Jan", "Feb", "Mrz", "Apr", "Mai", "Jun", "Jul", "Aug", "Sep", "Okt", "Nov", "Dez"]
    }
  }
}


Back to Top

 Event Properties

Properties for event handling configuration, defined within an "events" property block.


  
    
      Property
      Type
      Description
    
  
  
    
      bind
      String
      Configuration control for binding input DOM elements to signals. The available options are "any" (default, all bindings are allowed), "container" (use only the view container DOM element for all bindings, suppressing per-binding selectors), and "none" (suppresses all input bindings). ≥ 5.5
    
    
      defaults
      Object
      An object describing which events that originate within the Vega view should have their default behavior suppressed by invoking the event.preventDefault method. The defaults object should have a single property: either "prevent" (to indicate which events should have default behavior suppressed) or "allow" (to indicate only those events whose default behavior should be allowed). This property accepts either a boolean value (to prevent/allow all events) or an array of event type strings.
    
    
      globalCursor
      Boolean
      Configuration control for dynamic cursor setting. If false (default), the cursor is set for the Vega View element only. If true, the cursor is set globally for the entire document body. The default value of false avoids performance issues in browsers that recalculate styles in response to cursor changes. ≥ 5.13
    
    
      selector
      Boolean | String[ ]
      Configuration control for event listeners for external sources specified using a CSS selector. If a boolean value, true (default) permits selector event listeners, false disallows all selector events. If a string array, the entries specify a list of event types (such as "mousemove" or "wheel") to allow. ≥ 5.5
    
    
      timer
      Boolean
      Configuration control for event listeners for a "timer" source. One of true (default) to permit timer event listeners, or false to disallow timer events. ≥ 5.5
    
    
      view
      Boolean | String[ ]
      Configuration control for event listeners for the Vega "view" source. If a boolean value, true (default) permits view event listeners, false disallows all view events. If a string array, the entries specify a list of event types (such as "mousemove" or "wheel") to allow. ≥ 5.5
    
    
      window
      Boolean | String[ ]
      Configuration control for event listeners for the browser "window" source. If a boolean value, true (default) permits window event listeners, false disallows all window events. If a string array, the entries specify a list of event types (such as "mousemove" or "wheel") to allow. ≥ 5.5
    
  


Usage

To disable event listeners on external DOM elements specified by a CSS selector and permit only mousemove and mouseup events on the browser window object:

"events": {
  "selector": false,
  "window": ["mousemove", "mouseup"]
}


To prevent the default behavior for all events originating within a Vega view:

"events": {
  "defaults": {
    "prevent": true
  }
}


To prevent the default behavior for all events originating within a Vega view, except for wheel events:

"events": {
  "defaults": {
    "allow": ["wheel"]
  }
}


Back to Top

 Mark Properties

Properties defining default property values for each mark type. These properties are defined within blocks with names matching a valid mark type (e.g., "area", "line", "rect"). The valid properties within each block consist of the legal mark properties (e.g., "fill", "stroke", "size", "font"). Global defaults for all mark types can be set using the "mark" property.

Important limitations:

  Defaults for fill or stroke color will be applied only if neither "fill" nor "stroke" are defined in the Vega spec.
  Defaults set using the top-level "mark" property will be overridden by any defaults defined for more specific mark types (e.g., "rect"). Vega’s built-in configuration includes default fill or stroke colors for a number of specific mark types, and these will take precedence over new fill or stroke colors set only on the top-level "mark".


Usage

To set a default fill color and size for symbol marks:

{
  "symbol": {
    "fill": "steelblue",
    "size": 64
  }
}


To set a global opacity value for all mark types:

{
  "mark": {
    "opacity": 0.8
  }
}


Back to Top

Style Properties

In addition to the default mark properties above, default values can be further customized using named styles defined under the style block
in the config. Styles can then be invoked by including a style directive within a mark definition.

For example, to set a default shape and stroke width for symbol marks with a style named "square":

"style": {
  "square": {
    "shape": "square",
    "strokeWidth": 2
  }
}


In addition to custom style names, Vega includes the following built-in style names:

  guide-label: styles for axis and legend labels
  guide-title: styles for axis and legend titles
  group-title: styles for chart and header titles


Style settings take precedence over default mark settings, but are overridden by the axis, legend, and title properties described below.

Back to Top

Axis Properties

Properties defining default settings for axes. These properties are defined under the "axis" property in the config object, in which case the settings apply to all axes.

Additional property blocks can target more specific axis types based on the orientation ("axisX", "axisY", "axisLeft", "axisTop", etc.) or band scale type ("axisBand"). For example, properties defined under the "axisBand" property will only apply to axes visualizing "band" scales. If multiple axis config blocks apply to a single axis, type-based options take precedence over orientation-based options, which in turn take precedence over general options.


  
    
      Property
      Type
      Description
    
  
  
    
      bandPosition
      Number
      An interpolation fraction indicating where, for band scales, axis ticks should be positioned. A value of 0 places ticks at the left edge of their bands. A value of 0.5 places ticks in the middle of their bands.
    
    
      domain
      Boolean
      Boolean flag indicating if axis domain line should be included by default.
    
    
      domainCap
      String
      The stroke cap for the axis domain line. One of "butt" (default), "round" or "square". ≥ 5.11
    
    
      domainColor
      Color
      Color of axis domain line.
    
    
      domainDash
      Number[ ]
      Stroke dash of axis domain lines (or [] for solid lines). ≥ 5.0
    
    
      domainDashOffset
      Number
      The pixel offset at which to start the domain dash array. ≥ 5.0
    
    
      domainOpacity
      Number
      Opacity of axis domain line. ≥ 4.1
    
    
      domainWidth
      Number
      Stroke width of axis domain line.
    
    
      grid
      Boolean
      Boolean flag indicating if axis grid lines should be included by default.
    
    
      gridCap
      String
      The stroke cap for axis grid lines. One of "butt" (default), "round" or "square". ≥ 5.11
    
    
      gridColor
      Color
      Color of axis grid lines.
    
    
      gridDash
      Number[ ]
      Stroke dash of axis grid lines (or [] for solid lines).
    
    
      gridDashOffset
      Number
      The pixel offset at which to start the grid dash array. ≥ 5.0
    
    
      gridOpacity
      Number
      Opacity of axis grid lines.
    
    
      gridWidth
      Number
      Stroke width of axis grid lines.
    
    
      labels
      Boolean
      Boolean flag indicating if axis tick labels should be included by default.
    
    
      labelAlign
      String
      Horizontal text alignment of axis tick labels, overriding the default setting for the axis orientation.
    
    
      labelAngle
      Number
      Angle in degrees of axis tick labels.
    
    
      labelBaseline
      String
      Vertical text baseline of axis tick labels, overriding the default setting for the axis orientation.
    
    
      labelBound
      Boolean | Number
      Boolean flag or pixel tolerance value for removal of labels that exceed the axis range.
    
    
      labelColor
      Color
      Text color of axis tick labels.
    
    
      labelFlush
      Boolean | Number
      Boolean flag or pixel distance threshold value for performing a “flush” layout of axis labels. For an x-axis, flush alignment will left-align the left-most labels (if within the distance threshold from the axis start) and similarly right-align the right-most labels. If true, a pixel tolerance of 1 is used.
    
    
      labelFlushOffset
      Number
      Offset in pixels for flush-adjusted labels (default 0).
    
    
      labelFont
      String
      Font name for axis tick labels.
    
    
      labelFontSize
      Number
      Font size of axis tick labels.
    
    
      labelFontStyle
      String
      Font style of axis tick labels (e.g., normal or italic). ≥ 5.0
    
    
      labelFontWeight
      String | Number
      Font weight of axis tick labels.
    
    
      labelLimit
      Number
      The maximum allowed length in pixels of axis tick labels.
    
    
      labelLineHeight
      Number
      Line height in pixels for multi-line label text. ≥ 5.10
    
    
      labelOffset
      Number
      Position offset in pixels to apply to labels, in addition to tickOffset. ≥ 5.10
    
    
      labelOpacity
      Number
      Opacity of axis tick labels. ≥ 4.1
    
    
      labelOverlap
      Boolean | String
      The strategy to use for resolving overlap of axis labels. If false, no overlap reduction is attempted. If true or "parity", a strategy of removing every other label is used (this works well for standard linear axes). If "greedy", a linear scan of the labels is performed, removing any labels that overlaps with the last visible label (this often works better for log-scaled axes).
    
    
      labelSeparation
      Number
      The minimum separation that must be between label bounding boxes for them to be considered non-overlapping (default 0). This property is ignored if labelOverlap resolution is not enabled. ≥ 5.0
    
    
      labelPadding
      Number
      Padding in pixels between axis ticks and tick labels.
    
    
      maxExtent
      Number
      The maximum extent in pixels that axis ticks and labels should use. This determines a maximum offset value for axis titles.
    
    
      minExtent
      Number
      The minimum extent in pixels that axis ticks and labels should use. This determines a minimum offset value for axis titles.
    
    
      ticks
      Boolean
      Boolean flag indicating if axis tick marks should be included by default.
    
    
      tickBand
      String
      Indicates the type of tick style to use in conjunction with band scales. One of "center" (default) to center ticks in the middle of the band interval, or "extent" to place ticks at band extents (interval boundaries). If specified, this property may override the settings of bandPosition, tickExtra, and tickOffset. ≥ 5.8
    
    
      tickCap
      String
      The stroke cap for axis tick marks. One of "butt" (default), "round" or "square". ≥ 5.11
    
    
      tickColor
      Color
      Color of axis ticks.
    
    
      tickDash
      Number[ ]
      Stroke dash of axis tick marks (or [] for solid lines). ≥ 5.0
    
    
      tickDashOffset
      Number
      The pixel offset at which to start the tick mark dash array. ≥ 5.0
    
    
      tickExtra
      Boolean
      Boolean flag indicating if an extra axis tick should be added for the initial position of the axis. This flag is useful for styling axes for band scales such that ticks are placed on band boundaries rather in the middle of a band. Use in conjunction with "bandPosition": 1 and an axis "padding" value of 0.
    
    
      tickOffset
      Number
      Position offset in pixels to apply to ticks, labels, and gridlines.
    
    
      tickOpacity
      Number
      Opacity of axis ticks. ≥ 4.1
    
    
      tickRound
      Boolean
      Boolean flag indicating if pixel position values should be rounded to the nearest integer.
    
    
      tickSize
      Number
      Size, or length, in pixels of axis ticks.
    
    
      tickWidth
      Number
      Width in pixels of axis ticks.
    
    
      titleAlign
      String
      Horizontal text alignment of axis titles. One of "left", "center", or "right". If specified, this value overrides automatic alignment based on the titleAnchor value.
    
    
      titleAnchor
      String
      The anchor position for placing axis titles. One of "start", "middle", "end", or null (default, for automatic determination). For example, with an orient of "bottom" these anchor positions map to a left-, center-, or right-aligned title. The anchor point is determined relative to the axis scale range. ≥ 5.0
    
    
      titleAngle
      Number
      Angle in degrees of axis titles.
    
    
      titleBaseline
      String
      Vertical text baseline for axis titles.
    
    
      titleColor
      Color
      Text color of axis titles.
    
    
      titleFont
      String
      Font name for axis titles.
    
    
      titleFontSize
      Number
      Font size of axis titles.
    
    
      titleFontStyle
      String
      Font style of axis titles (e.g., normal or italic). ≥ 5.0
    
    
      titleFontWeight
      String | Number
      Font weight of axis titles.
    
    
      titleLimit
      Number
      The maximum allowed length in pixels of axis titles.
    
    
      titleLineHeight
      Number
      Line height in pixels for multi-line title text. ≥ 5.7
    
    
      titleOpacity
      Number
      Opacity of axis titles. ≥ 4.1
    
    
      titlePadding
      Number
      Padding in pixels between axis tick labels and titles.
    
    
      titleX
      Number
      X-coordinate of the axis title relative to the axis group.
    
    
      titleY
      Number
      Y-coordinate of the axis title relative to the axis group.
    
    
      translate
      Number
      Coordinate space translation offset for axis layout. By default, axes are translated by a 0.5 pixel offset for both the x and y coordinates, in order to align stroked lines with the pixel grid. However, for vector graphics output these pixel-specific adjustments may be undesirable, in which case translate can be changed (for example, to zero). ≥ 5.8
    
    
      zindex
      Number
      The integer z-index indicating the layering of the axis group relative to other axis, mark, and legend groups. With a value of 0 axes and grid lines are drawn behind any marks defined in the same specification level. Higher values (1) cause axes and grid lines to be drawn on top of marks. ≥ 5.11
    
  


Axis Accessibility Properties

Accessibility properties are used to determine ARIA (Accessible Rich Internet Applications) attributes when using Vega to render SVG output.


  
    
      Property
      Type
      Description
    
  
  
    
      aria
      Boolean
      A boolean flag (default true) indicating if ARIA attributes should be included (SVG output only). If false, the “aria-hidden” attribute will be set on the output SVG group, removing the axis from the ARIA accessibility tree. ≥ 5.11
    
    
      description
      String
      A text description of this axis for ARIA accessibility (SVG output only). If the aria property is true, for SVG output the “aria-label” attribute will be set to this description. If the description is unspecified it will be automatically generated. ≥ 5.11
    
  


Usage

This example sets the axis label color to dark gray for all axes, and rotates the labels for axes oriented along the bottom of a chart.

{
  "axis": {
    "labelColor": "#ccc"
  },
  "axisBottom": {
    "labelAngle": -90
  }
}


Back to Top

Legend Properties

Properties defining default settings for legends. These properties are defined under the "legend" property within the config object.


  
    
      Property
      Type
      Description
    
  
  
    
      clipHeight
      Number
      The height in pixels to clip symbol legend entries and limit their size.
    
    
      columns
      Number
      The number of columns in which to arrange symbol legend entries. A value of 0 or lower indicates a single row with one column per entry.
    
    
      columnPadding
      Number
      The horizontal padding in pixels between symbol legend entries.
    
    
      cornerRadius
      Number
      Corner radius for the full legend.
    
    
      fillColor
      Color
      Background fill color for the full legend.
    
    
      gradientDirection
      String
      The default direction ("horizontal" or "vertical") for gradient legends.
    
    
      gradientLength
      Number
      The length in pixels of the primary axis of a color gradient. This value corresponds to the height of a vertical gradient or the width of a horizontal gradient.
    
    
      gradientThickness
      Number
      The thickness in pixels of the color gradient. This value corresponds to the width of a vertical gradient or the height of a horizontal gradient.
    
    
      gradientWidth
      Number
      Deprecated, use gradientLength instead. If gradientLength is not defined, this value will be used instead.
    
    
      gradientHeight
      Number
      Deprecated, use gradientThickness instead. If gradientThickness is not defined, this value will be used instead.
    
    
      gradientStrokeColor
      Color
      Stroke color for color ramp gradient borders.
    
    
      gradientStrokeWidth
      Number
      Stroke width for color ramp gradient borders.
    
    
      gradientLabelLimit
      Number
      The maximum allowed length in pixels of color ramp gradient labels.
    
    
      gradientLabelOffset
      Number
      Vertical offset in pixels for color ramp gradient labels.
    
    
      gradientOpacity
      Number
      Opacity of color ramp gradient. ≥ 4.1
    
    
      gridAlign
      String
      The alignment to apply to symbol legends rows and columns. The supported string values are all, each (the default), and none. For more information, see the grid layout documentation.
    
    
      labelAlign
      String
      Horizontal text alignment of legend labels.
    
    
      labelBaseline
      String
      Vertical text baseline of legend labels.
    
    
      labelColor
      Color
      Text color of legend labels.
    
    
      labelFont
      String
      Font name of legend labels.
    
    
      labelFontSize
      Number
      Font size in pixels of legend labels.
    
    
      labelFontStyle
      String
      Font style of legend labels (e.g., normal or italic). ≥ 5.0
    
    
      labelFontWeight
      String | Number
      Font weight of legend labels.
    
    
      labelLimit
      Number
      The maximum allowed length in pixels of legend labels.
    
    
      labelOffset
      Number
      Horizontal offset in pixels between legend symbols and labels.
    
    
      labelOpacity
      Number
      Opacity of legend labels. ≥ 4.1
    
    
      labelOverlap
      Boolean | String
      The strategy to use for resolving overlap of labels in gradient legends. If false, no overlap reduction is attempted. If set to true (default) or "parity", a strategy of removing every other label is used. If set to "greedy", a linear scan of the labels is performed, removing any label that overlaps with the last visible label.
    
    
      labelSeparation
      Number
      The minimum separation that must be between label bounding boxes for them to be considered non-overlapping (default 0). This property is ignored if labelOverlap resolution is not enabled. ≥ 5.0
    
    
      layout
      Layout
      An object specifying layout parameters for positioning a collection of legends with the same orient value. ≥ 5.0
    
    
      legendX
      Number
      The pixel x-coordinate of the legend group. Only applied if the orient value is "none". ≥ 5.4
    
    
      legendY
      Number
      The pixel y-coordinate of the legend group. Only applied if the orient value is "none". ≥ 5.4
    
    
      offset
      Number
      Offset in pixels of the legend from the chart body. If specified, this value will override any values specified in the legend layout config.
    
    
      orient
      String
      Default legend orientation (e.g., "right" or "left").
    
    
      padding
      Number
      Padding in pixels between legend border and contents.
    
    
      rowPadding
      Number
      The vertical padding in pixels between symbol legend entries.
    
    
      strokeColor
      Color
      Border stroke color for the full legend.
    
    
      strokeDash
      Number[ ]
      Border stroke dash pattern for the full legend.
    
    
      strokeWidth
      Number
      Border stroke width for the full legend.
    
    
      symbolBaseFillColor
      Color
      Default fill color for legend symbols. Only applied if there is no "fill" scale color encoding for the legend.
    
    
      symbolBaseStrokeColor
      Color
      Default stroke color for legend symbols. Only applied if there is no "fill" scale color encoding for the legend.
    
    
      symbolDash
      Number[ ]
      Stroke dash of symbol outlines (or [] for solid lines). ≥ 5.0
    
    
      symbolDashOffset
      Number
      The pixel offset at which to start the symbol dash array. ≥ 5.0
    
    
      symbolDirection
      String
      The default direction ("horizontal" or "vertical") for symbol legends.
    
    
      symbolFillColor
      Color
      Fill color for legend symbols.
    
    
      symbolLimit
      Number
      The maximum number of allowed entries for a symbol legend. If the number of entries exceeds the limit, entries will be dropped and replaced with an ellipsis. ≥ 5.7
    
    
      symbolOffset
      Number
      Horizontal pixel offset for legend symbols.
    
    
      symbolOpacity
      Number
      Opacity of legend symbols. ≥ 4.1
    
    
      symbolSize
      Number
      Default symbol area size (in pixels2).
    
    
      symbolStrokeColor
      Color
      Stroke color for legend symbols.
    
    
      symbolStrokeWidth
      Number
      Default legend symbol stroke width.
    
    
      symbolType
      String
      Default shape type (such as "circle") for legend symbols.
    
    
      tickCount
      Number | String | Object
      The desired number of tick values for quantitative legends. For scales of type time or utc, the tick count can instead be a time interval specifier. Legal string values are "millisecond", "second", "minute", "hour", "day", "week", "month", and "year". Alternatively, an object-valued interval specifier of the form {"interval": "month", "step": 3} includes a desired number of interval steps. Here, ticks are generated for each quarter (Jan, Apr, Jul, Oct) boundary. ≥ 5.7
    
    
      titleAlign
      String
      Horizontal text alignment of legend titles. One of "left", "center", or "right". If specified, this value overrides automatic alignment based on the titleOrient and titleAnchor values.
    
    
      titleAnchor
      String
      The anchor position for placing legend titles. One of "start", "middle", "end", or null (default, for automatic determination). For example, with a titleOrient of "top" these anchor positions map to a left-, center-, or right-aligned title relative to the legend contents. ≥ 5.0
    
    
      titleBaseline
      String
      Vertical text baseline of legend titles. If specified, this value overrides the automatic baseline based on the titleOrient and titleAnchor values.
    
    
      titleColor
      Color
      Text color of legend titles.
    
    
      titleFont
      String
      Font name of legend titles.
    
    
      titleFontSize
      Number
      Font size in pixels of legend titles.
    
    
      titleFontStyle
      String
      Font style of legend titles (e.g., normal or italic). ≥ 5.0
    
    
      titleFontWeight
      String | Number
      Font weight for legend titles.
    
    
      titleLimit
      Number
      The maximum allowed length in pixels of legend titles.
    
    
      titleLineHeight
      Number
      Line height in pixels for multi-line title text. ≥ 5.7
    
    
      titleOpacity
      Number
      Opacity of legend titles. ≥ 4.1
    
    
      titleOrient
      String
      The orientation of title legends, determining where they are placed relative to legend contents. One of "top" (default), "left", "bottom", or "right". ≥ 5.0
    
    
      titlePadding
      Number
      Padding in pixels between the legend title and entries.
    
    
      zindex
      Number
      The integer z-index indicating the layering of the legend group relative to other axis, mark, and legend groups. ≥ 5.11
    
  


Legend Accessibility Properties

Accessibility properties are used to determine ARIA (Accessible Rich Internet Applications) attributes when using Vega to render SVG output.


  
    
      Property
      Type
      Description
    
  
  
    
      aria
      Boolean
      A boolean flag (default true) indicating if ARIA attributes should be included (SVG output only). If false, the “aria-hidden” attribute will be set on the output SVG group, removing the legend from the ARIA accessibility tree. ≥ 5.11
    
    
      description
      String
      A text description of this legend for ARIA accessibility (SVG output only). If the aria property is true, for SVG output the “aria-label” attribute will be set to this description. If the description is unspecified it will be automatically generated. ≥ 5.11
    
  


Legend Layout Properties ≥ 5.0

Collections of legends with the same orient value are positioned together, either vertically or horizontally in sequence. The legend layout property enables customization of how legends are organized within a Vega view. The layout property is an object value that may contain both top-level properties that apply to all legends and a set of orient-specific properties for customizing specific legend orientations.


  
    
      Property
      Type
      Description
    
  
  
    
      anchor
      String
      An anchor value determining the placement of the legends relative to the nearest axis. One of "start" (default), "middle", or "end". For example, for legends with orient "top", these values respectively correspond to anchoring the legends to the left edge, center, or right edge of the charting area. This property only applies to axes with an orient value of "left", "right", "top", or "bottom".
    
    
      bounds
      String
      The type of bounding box calculation to use for calculating legend extents. One of "flush" (the default, for using legend width and height values only) or "full" (to use the full bounding box, for example including border stroke widths).
    
    
      center
      Boolean
      A boolean flag (default false) indicating if legends should be centered within the respective layout area. For example, given a vertical direction, two legends will share a left edge by default. If center is true, the smaller legends will be centered in the space spanned by all the legends.
    
    
      direction
      String
      The direction in which subsequent legends should be spatially positioned. One of "horizontal" or "vertical".
    
    
      margin
      Number
      Margin, in pixels, to place between consecutive legends with the same orient value.
    
    
      offset
      Number
      Offset, in pixels, of the legend from the chart body.
    
  


In addition to these top-level properties, the legend layout may include sub-objects (containing the same properties listed above) for any of the legal legend orient values other than "none": "left", "right", "top", "bottom", "top-left", "top-right", "bottom-left", "bottom-right".

Note: The default configuration includes legend layout entries for "left" and "right" orientations. If you add custom layout parameters at the top-level, these will not override more specific configurations. If you want to modify the layout of "left"- or "right"-oriented legends, use a specific sub-object targeting those orientations.

Usage

This example gives every legend a 10 pixel padding and a light gray border:

{
  "legend": {
    "padding": 10,
    "legendStrokeColor": "#ccc",
    "legendStrokeWidth": 1
  }
}


This example customizes the layout of legends with orient value "bottom", stacking those legends vertically with 2 pixel margins, anchoring their x-positon to the middle of the chart area, and centering the legends within their layout area:

{
  "legend": {
    "layout": {
      "bottom": {
        "anchor": "middle",
        "direction": "vertical",
        "center": true,
        "margin": 2,
      }
    }
  }
}


Back to Top

Title Properties

Properties defining default settings for titles. These properties are defined under the "title" property within the config object.


  
    
      Property
      Type
      Description
    
  
  
    
      align
      String
      Horizontal text alignment of the title and subtitle. If specified, this value overrides automatic alignment based on the anchor value.
    
    
      anchor
      String
      Title and subtitle anchor position ("start", "middle", or "end").
    
    
      angle
      Number
      Angle in degrees of the title and subtitle text.
    
    
      baseline
      String
      Vertical text baseline of the title and subtitle.
    
    
      color
      Color
      Text color of the title text.
    
    
      dx
      Number
      Horizontal offset added to the title and subtitle x-coordinate. ≥ 5.2
    
    
      dy
      Number
      Vertical offset added to the title and subtitle y-coordinate. ≥ 5.2
    
    
      font
      String
      Font name of the title text.
    
    
      fontSize
      Number
      Font size in pixels of the title text.
    
    
      fontStyle
      String
      Font style of the title text (e.g., normal or italic). ≥ 5.0
    
    
      fontWeight
      String | Number
      Font weight for title text.
    
    
      frame
      String
      The reference frame for the anchor position, one of "bounds" (to anchor relative to the full bounding box) or "group" (to anchor relative to the group width or height).
    
    
      limit
      Number
      The maximum allowed length in pixels of title and subtitle text.
    
    
      lineHeight
      Number
      Line height in pixels for multi-line title text. ≥ 5.7
    
    
      offset
      Number
      Offset in pixels of the title from the chart body and axes.
    
    
      orient
      String
      Default title orientation ("top", "bottom", "left", or "right").
    
    
      subtitleColor
      Color
      Text color of the subtitle text. ≥ 5.7
    
    
      subtitleFont
      String
      Font name of the subtitle text. ≥ 5.7
    
    
      subtitleFontSize
      Number
      Font size in pixels of the subtitle text. ≥ 5.7
    
    
      subtitleFontStyle
      String
      Font style of the subtitle text (e.g., normal or italic). ≥ 5.7
    
    
      subtitleFontWeight
      String | Number
      Font weight for subtitle text. ≥ 5.7
    
    
      subtitleLineHeight
      Number
      Line height in pixels for multi-line subtitle text. ≥ 5.7
    
    
      subtitlePadding
      Number
      Padding in pixels between title and subtitle text. ≥ 5.7
    
    
      zindex
      Number
      The integer z-index indicating the layering of the title group relative to other axis, mark, and legend groups. ≥ 5.11
    
  


Title Accessibility Properties

Accessibility properties are used to determine ARIA (Accessible Rich Internet Applications) attributes when using Vega to render SVG output.


  
    
      Property
      Type
      Description
    
  
  
    
      aria
      Boolean
      A boolean flag (default true) indicating if ARIA attributes should be included (SVG output only). If false, the “aria-hidden” attribute will be set on the output SVG group, removing the title from the ARIA accessibility tree. ≥ 5.11
    
  


Usage

This example gives every title a 10 pixel offset and a font size of 18 pixels.

{
  "title": {
    "offset": 10,
    "fontSize": 18
  }
}


Back to Top

Projection Properties

Default properties to apply to cartographic projections, if not explicitly included in the input JSON specification. Any legal projection property may be included. These properties are defined under the "projection" property in the config object. A common use for this property is to set a default projection type.

Usage

This example sets the default projection type to be an "equalEarth" projection:

{
  "projection": {
    "type": "equalEarth"
  }
}


Back to Top

Scale Range Properties

Properties defining named range arrays that can be used within scale range definitions (such as {"type": "ordinal", "range": "category"}). These properties are defined under the "range" property in the config object.

Object-valued properties must be legal scale range definitions.


  
    
      Property
      Type
      Description
    
  
  
    
      category
      Scheme | Color[ ]
      Default color scheme for categorical data.
    
    
      diverging
      Scheme | Color[ ]
      Default color scheme for diverging quantitative ramps.
    
    
      heatmap
      Scheme | Color[ ]
      Default color scheme for quantitative heatmaps.
    
    
      ordinal
      Scheme | Color[ ]
      Default color scheme for rank-ordered data.
    
    
      ramp
      Scheme | Color[ ]
      Default color scheme for sequential quantitative ramps.
    
    
      symbol
      String[ ]
      Array of symbol names or paths for the default shape palette.
    
  


Usage

This example sets new default color palettes.

{
  "range": {
    "category": [
      "#5079a5",
      "#ef8e3b",
      "#dd565c",
      "#79b7b2",
      "#5da052",
      "#ecc853",
      "#ad7aa1",
      "#ef9ba7",
      "#9b7461",
      "#bab0ac"
    ],
    "ordinal": {"scheme": "greens"},
    "ramp": {"scheme": "purples"}
  }
}


Back to Top

Signal Definitions ≥ 5.5

Configuration files may also contain signal definitions for the top-level scope of a Vega specification. The syntax is identical to standard signal definitions: an array of named signal objects. Adding signal definitions to a configuration can be useful for defining style variables (colors, font sizes, etc.) that may be used elsewhere within either the config or a spec itself. Signals directly defined within a specification itself take precedence over those defined in the configuration.

Usage

To enable dynamic scaling of font sizes, one can define a signal that for a font size scale factor, then define other config entries relative to this value:

{
  "signals": [
    {"name": "fontSizeScale", "value": 1}
  ],
  "text": {
    "fontSize": {"signal": "11 * fontSizeScale"}
  }
}


Back to Top\nVega
            
              Vega-Lite
              Altair
              Vega-Lite API\nVega-Lite
              Altair
              Vega-Lite API\nExamples
              Tutorials
              Documentation
              Usage
              About
            
            
              GitHub
              Try Online\nExamples
              Tutorials
              Documentation
              Usage
              About\nGitHub
              Try Online\nDocumentation
      
      
      
      
        Specification
      
      
      
      
        Config
      
      
      
      
        Data
      
      
      
      
        Transforms
      
      
      
      
        Triggers
      
      
      
      
        Projections
      
      
      
      
        Scales
      
      
      
      
        Schemes
      
      
      
      
        Axes
      
      
      
      
        Legends
      
      
      
      
        Title
      
      
      
      
        Marks
      
      
      
      
        Signals
      
      
      
      
        Event Streams
      
      
      
      
        Expressions
      
      
      
      
        Layout
      
      
      
      
        Types
      
      
    
  
  
    Config
    A config object defines default visual values to set a visualization’s theme.

The Vega parser accepts a JSON configuration file that defines default settings for a variety of visual encoding choices. Different configuration files can be used to “theme” charts with a customized look and feel. A configuration file is simply a JSON object with a set of named properties, grouped by type. To provide a configuration file at parse-time, simply pass an additional parameter to the parse method:

var runtime = vega.parse(spec, config);


In addition, Vega JSON specifications may contain a single, top-level config property to override any configuration settings. Any configuration provided within the specification itself will take precedence over external configurations passed to the parser.

For example, this Vega spec includes light-gray axis grid lines by default:

{
  "width": 500,
  "height": 200,
  "config": {
    "axis": {
      "grid": true,
      "gridColor": "#dedede"
    }
  },
  ...
}


Config Reference


  View Properties
  Event Properties
  Mark Properties
  Style Properties
  Axis Properties
  Legend Properties
  Title Properties
  Projection Properties
  Scale Range Properties
  Signals


View Properties

Properties defined in the top-level scope of the configuration object.


  
    
      Property
      Type
      Description
    
  
  
    
      autosize
      String | Object | Signal
      Default automatic sizing setting. Valid string values are "pad", "fit" or "none". See the autosize documentation for more. Signal support available in versions ≥ 5.10.
    
    
      background
      Color | Signal
      Background color of the view component, or null for transparent. Signal support available in versions ≥ 5.10.
    
    
      description
      String
      The default text description for visualizations. The description determines the aria-label attribute for the container element of a Vega view. ≥ 5.10
    
    
      padding
      Number | Object | Signal
      The padding in pixels to add around the visualization. If a number, specifies padding for all sides. If an object, the value should have the format {"left": 5, "top": 5, "right": 5, "bottom": 5}. Signal support available in versions ≥ 5.10.
    
    
      width
      Number | Signal
      The width in pixels of the data rectangle. ≥ 5.10
    
    
      height
      Number | Signal
      The height in pixels of the data rectangle. ≥ 5.10
    
    
      group
      Object
      Default properties for the top-level group mark representing the data rectangle of a chart. Valid properties of this object are mark properties such as "fill", "stroke" and "strokeWidth".
    
    
      locale
      Object
      Locale definitions for string parsing and formatting of number and date values. The locale object should contain number and/or time properties with locale definitions. Locale definitions provided in the config block may be overridden by the View constructor locale option. ≥ 5.12
    
    
      lineBreak
      String | Signal
      A delimiter, such as a newline character, upon which to break text strings into multiple lines. This property provides a global default for text marks, which is overridden by mark or style config settings, and by the lineBreak mark encoding channel. If signal-valued, either string or regular expression (regexp) values are valid. ≥ 5.10
    
  


Usage

Set default view background and chart plotting area background colors:

{
  "background": "white",
  "group": {
    "fill": "#dedede"
  }
}


Set the number and time format locale to German:

{
  "locale": {
    "number": {
      "decimal": ",",
      "thousands": ".",
      "grouping": [3],
      "currency": ["", " €"]
    },
    "time": {
      "dateTime": "%A, der %e. %B %Y, %X",
      "date": "%d.%m.%Y",
      "time": "%H:%M:%S",
      "periods": ["AM", "PM"],
      "days": ["Sonntag", "Montag", "Dienstag", "Mittwoch", "Donnerstag", "Freitag", "Samstag"],
      "shortDays": ["So", "Mo", "Di", "Mi", "Do", "Fr", "Sa"],
      "months": ["Januar", "Februar", "März", "April", "Mai", "Juni", "Juli", "August", "September", "Oktober", "November", "Dezember"],
      "shortMonths": [ "Jan", "Feb", "Mrz", "Apr", "Mai", "Jun", "Jul", "Aug", "Sep", "Okt", "Nov", "Dez"]
    }
  }
}


Back to Top

 Event Properties

Properties for event handling configuration, defined within an "events" property block.


  
    
      Property
      Type
      Description
    
  
  
    
      bind
      String
      Configuration control for binding input DOM elements to signals. The available options are "any" (default, all bindings are allowed), "container" (use only the view container DOM element for all bindings, suppressing per-binding selectors), and "none" (suppresses all input bindings). ≥ 5.5
    
    
      defaults
      Object
      An object describing which events that originate within the Vega view should have their default behavior suppressed by invoking the event.preventDefault method. The defaults object should have a single property: either "prevent" (to indicate which events should have default behavior suppressed) or "allow" (to indicate only those events whose default behavior should be allowed). This property accepts either a boolean value (to prevent/allow all events) or an array of event type strings.
    
    
      globalCursor
      Boolean
      Configuration control for dynamic cursor setting. If false (default), the cursor is set for the Vega View element only. If true, the cursor is set globally for the entire document body. The default value of false avoids performance issues in browsers that recalculate styles in response to cursor changes. ≥ 5.13
    
    
      selector
      Boolean | String[ ]
      Configuration control for event listeners for external sources specified using a CSS selector. If a boolean value, true (default) permits selector event listeners, false disallows all selector events. If a string array, the entries specify a list of event types (such as "mousemove" or "wheel") to allow. ≥ 5.5
    
    
      timer
      Boolean
      Configuration control for event listeners for a "timer" source. One of true (default) to permit timer event listeners, or false to disallow timer events. ≥ 5.5
    
    
      view
      Boolean | String[ ]
      Configuration control for event listeners for the Vega "view" source. If a boolean value, true (default) permits view event listeners, false disallows all view events. If a string array, the entries specify a list of event types (such as "mousemove" or "wheel") to allow. ≥ 5.5
    
    
      window
      Boolean | String[ ]
      Configuration control for event listeners for the browser "window" source. If a boolean value, true (default) permits window event listeners, false disallows all window events. If a string array, the entries specify a list of event types (such as "mousemove" or "wheel") to allow. ≥ 5.5
    
  


Usage

To disable event listeners on external DOM elements specified by a CSS selector and permit only mousemove and mouseup events on the browser window object:

"events": {
  "selector": false,
  "window": ["mousemove", "mouseup"]
}


To prevent the default behavior for all events originating within a Vega view:

"events": {
  "defaults": {
    "prevent": true
  }
}


To prevent the default behavior for all events originating within a Vega view, except for wheel events:

"events": {
  "defaults": {
    "allow": ["wheel"]
  }
}


Back to Top

 Mark Properties

Properties defining default property values for each mark type. These properties are defined within blocks with names matching a valid mark type (e.g., "area", "line", "rect"). The valid properties within each block consist of the legal mark properties (e.g., "fill", "stroke", "size", "font"). Global defaults for all mark types can be set using the "mark" property.

Important limitations:

  Defaults for fill or stroke color will be applied only if neither "fill" nor "stroke" are defined in the Vega spec.
  Defaults set using the top-level "mark" property will be overridden by any defaults defined for more specific mark types (e.g., "rect"). Vega’s built-in configuration includes default fill or stroke colors for a number of specific mark types, and these will take precedence over new fill or stroke colors set only on the top-level "mark".


Usage

To set a default fill color and size for symbol marks:

{
  "symbol": {
    "fill": "steelblue",
    "size": 64
  }
}


To set a global opacity value for all mark types:

{
  "mark": {
    "opacity": 0.8
  }
}


Back to Top

Style Properties

In addition to the default mark properties above, default values can be further customized using named styles defined under the style block
in the config. Styles can then be invoked by including a style directive within a mark definition.

For example, to set a default shape and stroke width for symbol marks with a style named "square":

"style": {
  "square": {
    "shape": "square",
    "strokeWidth": 2
  }
}


In addition to custom style names, Vega includes the following built-in style names:

  guide-label: styles for axis and legend labels
  guide-title: styles for axis and legend titles
  group-title: styles for chart and header titles


Style settings take precedence over default mark settings, but are overridden by the axis, legend, and title properties described below.

Back to Top

Axis Properties

Properties defining default settings for axes. These properties are defined under the "axis" property in the config object, in which case the settings apply to all axes.

Additional property blocks can target more specific axis types based on the orientation ("axisX", "axisY", "axisLeft", "axisTop", etc.) or band scale type ("axisBand"). For example, properties defined under the "axisBand" property will only apply to axes visualizing "band" scales. If multiple axis config blocks apply to a single axis, type-based options take precedence over orientation-based options, which in turn take precedence over general options.


  
    
      Property
      Type
      Description
    
  
  
    
      bandPosition
      Number
      An interpolation fraction indicating where, for band scales, axis ticks should be positioned. A value of 0 places ticks at the left edge of their bands. A value of 0.5 places ticks in the middle of their bands.
    
    
      domain
      Boolean
      Boolean flag indicating if axis domain line should be included by default.
    
    
      domainCap
      String
      The stroke cap for the axis domain line. One of "butt" (default), "round" or "square". ≥ 5.11
    
    
      domainColor
      Color
      Color of axis domain line.
    
    
      domainDash
      Number[ ]
      Stroke dash of axis domain lines (or [] for solid lines). ≥ 5.0
    
    
      domainDashOffset
      Number
      The pixel offset at which to start the domain dash array. ≥ 5.0
    
    
      domainOpacity
      Number
      Opacity of axis domain line. ≥ 4.1
    
    
      domainWidth
      Number
      Stroke width of axis domain line.
    
    
      grid
      Boolean
      Boolean flag indicating if axis grid lines should be included by default.
    
    
      gridCap
      String
      The stroke cap for axis grid lines. One of "butt" (default), "round" or "square". ≥ 5.11
    
    
      gridColor
      Color
      Color of axis grid lines.
    
    
      gridDash
      Number[ ]
      Stroke dash of axis grid lines (or [] for solid lines).
    
    
      gridDashOffset
      Number
      The pixel offset at which to start the grid dash array. ≥ 5.0
    
    
      gridOpacity
      Number
      Opacity of axis grid lines.
    
    
      gridWidth
      Number
      Stroke width of axis grid lines.
    
    
      labels
      Boolean
      Boolean flag indicating if axis tick labels should be included by default.
    
    
      labelAlign
      String
      Horizontal text alignment of axis tick labels, overriding the default setting for the axis orientation.
    
    
      labelAngle
      Number
      Angle in degrees of axis tick labels.
    
    
      labelBaseline
      String
      Vertical text baseline of axis tick labels, overriding the default setting for the axis orientation.
    
    
      labelBound
      Boolean | Number
      Boolean flag or pixel tolerance value for removal of labels that exceed the axis range.
    
    
      labelColor
      Color
      Text color of axis tick labels.
    
    
      labelFlush
      Boolean | Number
      Boolean flag or pixel distance threshold value for performing a “flush” layout of axis labels. For an x-axis, flush alignment will left-align the left-most labels (if within the distance threshold from the axis start) and similarly right-align the right-most labels. If true, a pixel tolerance of 1 is used.
    
    
      labelFlushOffset
      Number
      Offset in pixels for flush-adjusted labels (default 0).
    
    
      labelFont
      String
      Font name for axis tick labels.
    
    
      labelFontSize
      Number
      Font size of axis tick labels.
    
    
      labelFontStyle
      String
      Font style of axis tick labels (e.g., normal or italic). ≥ 5.0
    
    
      labelFontWeight
      String | Number
      Font weight of axis tick labels.
    
    
      labelLimit
      Number
      The maximum allowed length in pixels of axis tick labels.
    
    
      labelLineHeight
      Number
      Line height in pixels for multi-line label text. ≥ 5.10
    
    
      labelOffset
      Number
      Position offset in pixels to apply to labels, in addition to tickOffset. ≥ 5.10
    
    
      labelOpacity
      Number
      Opacity of axis tick labels. ≥ 4.1
    
    
      labelOverlap
      Boolean | String
      The strategy to use for resolving overlap of axis labels. If false, no overlap reduction is attempted. If true or "parity", a strategy of removing every other label is used (this works well for standard linear axes). If "greedy", a linear scan of the labels is performed, removing any labels that overlaps with the last visible label (this often works better for log-scaled axes).
    
    
      labelSeparation
      Number
      The minimum separation that must be between label bounding boxes for them to be considered non-overlapping (default 0). This property is ignored if labelOverlap resolution is not enabled. ≥ 5.0
    
    
      labelPadding
      Number
      Padding in pixels between axis ticks and tick labels.
    
    
      maxExtent
      Number
      The maximum extent in pixels that axis ticks and labels should use. This determines a maximum offset value for axis titles.
    
    
      minExtent
      Number
      The minimum extent in pixels that axis ticks and labels should use. This determines a minimum offset value for axis titles.
    
    
      ticks
      Boolean
      Boolean flag indicating if axis tick marks should be included by default.
    
    
      tickBand
      String
      Indicates the type of tick style to use in conjunction with band scales. One of "center" (default) to center ticks in the middle of the band interval, or "extent" to place ticks at band extents (interval boundaries). If specified, this property may override the settings of bandPosition, tickExtra, and tickOffset. ≥ 5.8
    
    
      tickCap
      String
      The stroke cap for axis tick marks. One of "butt" (default), "round" or "square". ≥ 5.11
    
    
      tickColor
      Color
      Color of axis ticks.
    
    
      tickDash
      Number[ ]
      Stroke dash of axis tick marks (or [] for solid lines). ≥ 5.0
    
    
      tickDashOffset
      Number
      The pixel offset at which to start the tick mark dash array. ≥ 5.0
    
    
      tickExtra
      Boolean
      Boolean flag indicating if an extra axis tick should be added for the initial position of the axis. This flag is useful for styling axes for band scales such that ticks are placed on band boundaries rather in the middle of a band. Use in conjunction with "bandPosition": 1 and an axis "padding" value of 0.
    
    
      tickOffset
      Number
      Position offset in pixels to apply to ticks, labels, and gridlines.
    
    
      tickOpacity
      Number
      Opacity of axis ticks. ≥ 4.1
    
    
      tickRound
      Boolean
      Boolean flag indicating if pixel position values should be rounded to the nearest integer.
    
    
      tickSize
      Number
      Size, or length, in pixels of axis ticks.
    
    
      tickWidth
      Number
      Width in pixels of axis ticks.
    
    
      titleAlign
      String
      Horizontal text alignment of axis titles. One of "left", "center", or "right". If specified, this value overrides automatic alignment based on the titleAnchor value.
    
    
      titleAnchor
      String
      The anchor position for placing axis titles. One of "start", "middle", "end", or null (default, for automatic determination). For example, with an orient of "bottom" these anchor positions map to a left-, center-, or right-aligned title. The anchor point is determined relative to the axis scale range. ≥ 5.0
    
    
      titleAngle
      Number
      Angle in degrees of axis titles.
    
    
      titleBaseline
      String
      Vertical text baseline for axis titles.
    
    
      titleColor
      Color
      Text color of axis titles.
    
    
      titleFont
      String
      Font name for axis titles.
    
    
      titleFontSize
      Number
      Font size of axis titles.
    
    
      titleFontStyle
      String
      Font style of axis titles (e.g., normal or italic). ≥ 5.0
    
    
      titleFontWeight
      String | Number
      Font weight of axis titles.
    
    
      titleLimit
      Number
      The maximum allowed length in pixels of axis titles.
    
    
      titleLineHeight
      Number
      Line height in pixels for multi-line title text. ≥ 5.7
    
    
      titleOpacity
      Number
      Opacity of axis titles. ≥ 4.1
    
    
      titlePadding
      Number
      Padding in pixels between axis tick labels and titles.
    
    
      titleX
      Number
      X-coordinate of the axis title relative to the axis group.
    
    
      titleY
      Number
      Y-coordinate of the axis title relative to the axis group.
    
    
      translate
      Number
      Coordinate space translation offset for axis layout. By default, axes are translated by a 0.5 pixel offset for both the x and y coordinates, in order to align stroked lines with the pixel grid. However, for vector graphics output these pixel-specific adjustments may be undesirable, in which case translate can be changed (for example, to zero). ≥ 5.8
    
    
      zindex
      Number
      The integer z-index indicating the layering of the axis group relative to other axis, mark, and legend groups. With a value of 0 axes and grid lines are drawn behind any marks defined in the same specification level. Higher values (1) cause axes and grid lines to be drawn on top of marks. ≥ 5.11
    
  


Axis Accessibility Properties

Accessibility properties are used to determine ARIA (Accessible Rich Internet Applications) attributes when using Vega to render SVG output.


  
    
      Property
      Type
      Description
    
  
  
    
      aria
      Boolean
      A boolean flag (default true) indicating if ARIA attributes should be included (SVG output only). If false, the “aria-hidden” attribute will be set on the output SVG group, removing the axis from the ARIA accessibility tree. ≥ 5.11
    
    
      description
      String
      A text description of this axis for ARIA accessibility (SVG output only). If the aria property is true, for SVG output the “aria-label” attribute will be set to this description. If the description is unspecified it will be automatically generated. ≥ 5.11
    
  


Usage

This example sets the axis label color to dark gray for all axes, and rotates the labels for axes oriented along the bottom of a chart.

{
  "axis": {
    "labelColor": "#ccc"
  },
  "axisBottom": {
    "labelAngle": -90
  }
}


Back to Top

Legend Properties

Properties defining default settings for legends. These properties are defined under the "legend" property within the config object.


  
    
      Property
      Type
      Description
    
  
  
    
      clipHeight
      Number
      The height in pixels to clip symbol legend entries and limit their size.
    
    
      columns
      Number
      The number of columns in which to arrange symbol legend entries. A value of 0 or lower indicates a single row with one column per entry.
    
    
      columnPadding
      Number
      The horizontal padding in pixels between symbol legend entries.
    
    
      cornerRadius
      Number
      Corner radius for the full legend.
    
    
      fillColor
      Color
      Background fill color for the full legend.
    
    
      gradientDirection
      String
      The default direction ("horizontal" or "vertical") for gradient legends.
    
    
      gradientLength
      Number
      The length in pixels of the primary axis of a color gradient. This value corresponds to the height of a vertical gradient or the width of a horizontal gradient.
    
    
      gradientThickness
      Number
      The thickness in pixels of the color gradient. This value corresponds to the width of a vertical gradient or the height of a horizontal gradient.
    
    
      gradientWidth
      Number
      Deprecated, use gradientLength instead. If gradientLength is not defined, this value will be used instead.
    
    
      gradientHeight
      Number
      Deprecated, use gradientThickness instead. If gradientThickness is not defined, this value will be used instead.
    
    
      gradientStrokeColor
      Color
      Stroke color for color ramp gradient borders.
    
    
      gradientStrokeWidth
      Number
      Stroke width for color ramp gradient borders.
    
    
      gradientLabelLimit
      Number
      The maximum allowed length in pixels of color ramp gradient labels.
    
    
      gradientLabelOffset
      Number
      Vertical offset in pixels for color ramp gradient labels.
    
    
      gradientOpacity
      Number
      Opacity of color ramp gradient. ≥ 4.1
    
    
      gridAlign
      String
      The alignment to apply to symbol legends rows and columns. The supported string values are all, each (the default), and none. For more information, see the grid layout documentation.
    
    
      labelAlign
      String
      Horizontal text alignment of legend labels.
    
    
      labelBaseline
      String
      Vertical text baseline of legend labels.
    
    
      labelColor
      Color
      Text color of legend labels.
    
    
      labelFont
      String
      Font name of legend labels.
    
    
      labelFontSize
      Number
      Font size in pixels of legend labels.
    
    
      labelFontStyle
      String
      Font style of legend labels (e.g., normal or italic). ≥ 5.0
    
    
      labelFontWeight
      String | Number
      Font weight of legend labels.
    
    
      labelLimit
      Number
      The maximum allowed length in pixels of legend labels.
    
    
      labelOffset
      Number
      Horizontal offset in pixels between legend symbols and labels.
    
    
      labelOpacity
      Number
      Opacity of legend labels. ≥ 4.1
    
    
      labelOverlap
      Boolean | String
      The strategy to use for resolving overlap of labels in gradient legends. If false, no overlap reduction is attempted. If set to true (default) or "parity", a strategy of removing every other label is used. If set to "greedy", a linear scan of the labels is performed, removing any label that overlaps with the last visible label.
    
    
      labelSeparation
      Number
      The minimum separation that must be between label bounding boxes for them to be considered non-overlapping (default 0). This property is ignored if labelOverlap resolution is not enabled. ≥ 5.0
    
    
      layout
      Layout
      An object specifying layout parameters for positioning a collection of legends with the same orient value. ≥ 5.0
    
    
      legendX
      Number
      The pixel x-coordinate of the legend group. Only applied if the orient value is "none". ≥ 5.4
    
    
      legendY
      Number
      The pixel y-coordinate of the legend group. Only applied if the orient value is "none". ≥ 5.4
    
    
      offset
      Number
      Offset in pixels of the legend from the chart body. If specified, this value will override any values specified in the legend layout config.
    
    
      orient
      String
      Default legend orientation (e.g., "right" or "left").
    
    
      padding
      Number
      Padding in pixels between legend border and contents.
    
    
      rowPadding
      Number
      The vertical padding in pixels between symbol legend entries.
    
    
      strokeColor
      Color
      Border stroke color for the full legend.
    
    
      strokeDash
      Number[ ]
      Border stroke dash pattern for the full legend.
    
    
      strokeWidth
      Number
      Border stroke width for the full legend.
    
    
      symbolBaseFillColor
      Color
      Default fill color for legend symbols. Only applied if there is no "fill" scale color encoding for the legend.
    
    
      symbolBaseStrokeColor
      Color
      Default stroke color for legend symbols. Only applied if there is no "fill" scale color encoding for the legend.
    
    
      symbolDash
      Number[ ]
      Stroke dash of symbol outlines (or [] for solid lines). ≥ 5.0
    
    
      symbolDashOffset
      Number
      The pixel offset at which to start the symbol dash array. ≥ 5.0
    
    
      symbolDirection
      String
      The default direction ("horizontal" or "vertical") for symbol legends.
    
    
      symbolFillColor
      Color
      Fill color for legend symbols.
    
    
      symbolLimit
      Number
      The maximum number of allowed entries for a symbol legend. If the number of entries exceeds the limit, entries will be dropped and replaced with an ellipsis. ≥ 5.7
    
    
      symbolOffset
      Number
      Horizontal pixel offset for legend symbols.
    
    
      symbolOpacity
      Number
      Opacity of legend symbols. ≥ 4.1
    
    
      symbolSize
      Number
      Default symbol area size (in pixels2).
    
    
      symbolStrokeColor
      Color
      Stroke color for legend symbols.
    
    
      symbolStrokeWidth
      Number
      Default legend symbol stroke width.
    
    
      symbolType
      String
      Default shape type (such as "circle") for legend symbols.
    
    
      tickCount
      Number | String | Object
      The desired number of tick values for quantitative legends. For scales of type time or utc, the tick count can instead be a time interval specifier. Legal string values are "millisecond", "second", "minute", "hour", "day", "week", "month", and "year". Alternatively, an object-valued interval specifier of the form {"interval": "month", "step": 3} includes a desired number of interval steps. Here, ticks are generated for each quarter (Jan, Apr, Jul, Oct) boundary. ≥ 5.7
    
    
      titleAlign
      String
      Horizontal text alignment of legend titles. One of "left", "center", or "right". If specified, this value overrides automatic alignment based on the titleOrient and titleAnchor values.
    
    
      titleAnchor
      String
      The anchor position for placing legend titles. One of "start", "middle", "end", or null (default, for automatic determination). For example, with a titleOrient of "top" these anchor positions map to a left-, center-, or right-aligned title relative to the legend contents. ≥ 5.0
    
    
      titleBaseline
      String
      Vertical text baseline of legend titles. If specified, this value overrides the automatic baseline based on the titleOrient and titleAnchor values.
    
    
      titleColor
      Color
      Text color of legend titles.
    
    
      titleFont
      String
      Font name of legend titles.
    
    
      titleFontSize
      Number
      Font size in pixels of legend titles.
    
    
      titleFontStyle
      String
      Font style of legend titles (e.g., normal or italic). ≥ 5.0
    
    
      titleFontWeight
      String | Number
      Font weight for legend titles.
    
    
      titleLimit
      Number
      The maximum allowed length in pixels of legend titles.
    
    
      titleLineHeight
      Number
      Line height in pixels for multi-line title text. ≥ 5.7
    
    
      titleOpacity
      Number
      Opacity of legend titles. ≥ 4.1
    
    
      titleOrient
      String
      The orientation of title legends, determining where they are placed relative to legend contents. One of "top" (default), "left", "bottom", or "right". ≥ 5.0
    
    
      titlePadding
      Number
      Padding in pixels between the legend title and entries.
    
    
      zindex
      Number
      The integer z-index indicating the layering of the legend group relative to other axis, mark, and legend groups. ≥ 5.11
    
  


Legend Accessibility Properties

Accessibility properties are used to determine ARIA (Accessible Rich Internet Applications) attributes when using Vega to render SVG output.


  
    
      Property
      Type
      Description
    
  
  
    
      aria
      Boolean
      A boolean flag (default true) indicating if ARIA attributes should be included (SVG output only). If false, the “aria-hidden” attribute will be set on the output SVG group, removing the legend from the ARIA accessibility tree. ≥ 5.11
    
    
      description
      String
      A text description of this legend for ARIA accessibility (SVG output only). If the aria property is true, for SVG output the “aria-label” attribute will be set to this description. If the description is unspecified it will be automatically generated. ≥ 5.11
    
  


Legend Layout Properties ≥ 5.0

Collections of legends with the same orient value are positioned together, either vertically or horizontally in sequence. The legend layout property enables customization of how legends are organized within a Vega view. The layout property is an object value that may contain both top-level properties that apply to all legends and a set of orient-specific properties for customizing specific legend orientations.


  
    
      Property
      Type
      Description
    
  
  
    
      anchor
      String
      An anchor value determining the placement of the legends relative to the nearest axis. One of "start" (default), "middle", or "end". For example, for legends with orient "top", these values respectively correspond to anchoring the legends to the left edge, center, or right edge of the charting area. This property only applies to axes with an orient value of "left", "right", "top", or "bottom".
    
    
      bounds
      String
      The type of bounding box calculation to use for calculating legend extents. One of "flush" (the default, for using legend width and height values only) or "full" (to use the full bounding box, for example including border stroke widths).
    
    
      center
      Boolean
      A boolean flag (default false) indicating if legends should be centered within the respective layout area. For example, given a vertical direction, two legends will share a left edge by default. If center is true, the smaller legends will be centered in the space spanned by all the legends.
    
    
      direction
      String
      The direction in which subsequent legends should be spatially positioned. One of "horizontal" or "vertical".
    
    
      margin
      Number
      Margin, in pixels, to place between consecutive legends with the same orient value.
    
    
      offset
      Number
      Offset, in pixels, of the legend from the chart body.
    
  


In addition to these top-level properties, the legend layout may include sub-objects (containing the same properties listed above) for any of the legal legend orient values other than "none": "left", "right", "top", "bottom", "top-left", "top-right", "bottom-left", "bottom-right".

Note: The default configuration includes legend layout entries for "left" and "right" orientations. If you add custom layout parameters at the top-level, these will not override more specific configurations. If you want to modify the layout of "left"- or "right"-oriented legends, use a specific sub-object targeting those orientations.

Usage

This example gives every legend a 10 pixel padding and a light gray border:

{
  "legend": {
    "padding": 10,
    "legendStrokeColor": "#ccc",
    "legendStrokeWidth": 1
  }
}


This example customizes the layout of legends with orient value "bottom", stacking those legends vertically with 2 pixel margins, anchoring their x-positon to the middle of the chart area, and centering the legends within their layout area:

{
  "legend": {
    "layout": {
      "bottom": {
        "anchor": "middle",
        "direction": "vertical",
        "center": true,
        "margin": 2,
      }
    }
  }
}


Back to Top

Title Properties

Properties defining default settings for titles. These properties are defined under the "title" property within the config object.


  
    
      Property
      Type
      Description
    
  
  
    
      align
      String
      Horizontal text alignment of the title and subtitle. If specified, this value overrides automatic alignment based on the anchor value.
    
    
      anchor
      String
      Title and subtitle anchor position ("start", "middle", or "end").
    
    
      angle
      Number
      Angle in degrees of the title and subtitle text.
    
    
      baseline
      String
      Vertical text baseline of the title and subtitle.
    
    
      color
      Color
      Text color of the title text.
    
    
      dx
      Number
      Horizontal offset added to the title and subtitle x-coordinate. ≥ 5.2
    
    
      dy
      Number
      Vertical offset added to the title and subtitle y-coordinate. ≥ 5.2
    
    
      font
      String
      Font name of the title text.
    
    
      fontSize
      Number
      Font size in pixels of the title text.
    
    
      fontStyle
      String
      Font style of the title text (e.g., normal or italic). ≥ 5.0
    
    
      fontWeight
      String | Number
      Font weight for title text.
    
    
      frame
      String
      The reference frame for the anchor position, one of "bounds" (to anchor relative to the full bounding box) or "group" (to anchor relative to the group width or height).
    
    
      limit
      Number
      The maximum allowed length in pixels of title and subtitle text.
    
    
      lineHeight
      Number
      Line height in pixels for multi-line title text. ≥ 5.7
    
    
      offset
      Number
      Offset in pixels of the title from the chart body and axes.
    
    
      orient
      String
      Default title orientation ("top", "bottom", "left", or "right").
    
    
      subtitleColor
      Color
      Text color of the subtitle text. ≥ 5.7
    
    
      subtitleFont
      String
      Font name of the subtitle text. ≥ 5.7
    
    
      subtitleFontSize
      Number
      Font size in pixels of the subtitle text. ≥ 5.7
    
    
      subtitleFontStyle
      String
      Font style of the subtitle text (e.g., normal or italic). ≥ 5.7
    
    
      subtitleFontWeight
      String | Number
      Font weight for subtitle text. ≥ 5.7
    
    
      subtitleLineHeight
      Number
      Line height in pixels for multi-line subtitle text. ≥ 5.7
    
    
      subtitlePadding
      Number
      Padding in pixels between title and subtitle text. ≥ 5.7
    
    
      zindex
      Number
      The integer z-index indicating the layering of the title group relative to other axis, mark, and legend groups. ≥ 5.11
    
  


Title Accessibility Properties

Accessibility properties are used to determine ARIA (Accessible Rich Internet Applications) attributes when using Vega to render SVG output.


  
    
      Property
      Type
      Description
    
  
  
    
      aria
      Boolean
      A boolean flag (default true) indicating if ARIA attributes should be included (SVG output only). If false, the “aria-hidden” attribute will be set on the output SVG group, removing the title from the ARIA accessibility tree. ≥ 5.11
    
  


Usage

This example gives every title a 10 pixel offset and a font size of 18 pixels.

{
  "title": {
    "offset": 10,
    "fontSize": 18
  }
}


Back to Top

Projection Properties

Default properties to apply to cartographic projections, if not explicitly included in the input JSON specification. Any legal projection property may be included. These properties are defined under the "projection" property in the config object. A common use for this property is to set a default projection type.

Usage

This example sets the default projection type to be an "equalEarth" projection:

{
  "projection": {
    "type": "equalEarth"
  }
}


Back to Top

Scale Range Properties

Properties defining named range arrays that can be used within scale range definitions (such as {"type": "ordinal", "range": "category"}). These properties are defined under the "range" property in the config object.

Object-valued properties must be legal scale range definitions.


  
    
      Property
      Type
      Description
    
  
  
    
      category
      Scheme | Color[ ]
      Default color scheme for categorical data.
    
    
      diverging
      Scheme | Color[ ]
      Default color scheme for diverging quantitative ramps.
    
    
      heatmap
      Scheme | Color[ ]
      Default color scheme for quantitative heatmaps.
    
    
      ordinal
      Scheme | Color[ ]
      Default color scheme for rank-ordered data.
    
    
      ramp
      Scheme | Color[ ]
      Default color scheme for sequential quantitative ramps.
    
    
      symbol
      String[ ]
      Array of symbol names or paths for the default shape palette.
    
  


Usage

This example sets new default color palettes.

{
  "range": {
    "category": [
      "#5079a5",
      "#ef8e3b",
      "#dd565c",
      "#79b7b2",
      "#5da052",
      "#ecc853",
      "#ad7aa1",
      "#ef9ba7",
      "#9b7461",
      "#bab0ac"
    ],
    "ordinal": {"scheme": "greens"},
    "ramp": {"scheme": "purples"}
  }
}


Back to Top

Signal Definitions ≥ 5.5

Configuration files may also contain signal definitions for the top-level scope of a Vega specification. The syntax is identical to standard signal definitions: an array of named signal objects. Adding signal definitions to a configuration can be useful for defining style variables (colors, font sizes, etc.) that may be used elsewhere within either the config or a spec itself. Signals directly defined within a specification itself take precedence over those defined in the configuration.

Usage

To enable dynamic scaling of font sizes, one can define a signal that for a font size scale factor, then define other config entries relative to this value:

{
  "signals": [
    {"name": "fontSizeScale", "value": 1}
  ],
  "text": {
    "fontSize": {"signal": "11 * fontSizeScale"}
  }
}


Back to Top\nA config object defines default visual values to set a visualization’s theme.\nThe Vega parser accepts a JSON configuration file that defines default settings for a variety of visual encoding choices. Different configuration files can be used to “theme” charts with a customized look and feel. A configuration file is simply a JSON object with a set of named properties, grouped by type. To provide a configuration file at parse-time, simply pass an additional parameter to the parse method:\nvar runtime = vega.parse(spec, config);\nvar runtime = vega.parse(spec, config);\nIn addition, Vega JSON specifications may contain a single, top-level config property to override any configuration settings. Any configuration provided within the specification itself will take precedence over external configurations passed to the parser.\nFor example, this Vega spec includes light-gray axis grid lines by default:\n{
  "width": 500,
  "height": 200,
  "config": {
    "axis": {
      "grid": true,
      "gridColor": "#dedede"
    }
  },
  ...
}\n{
  "width": 500,
  "height": 200,
  "config": {
    "axis": {
      "grid": true,
      "gridColor": "#dedede"
    }
  },
  ...
}\nProjection Properties\nProjection Properties\nScale Range Properties\nScale Range Properties\nProperties defined in the top-level scope of the configuration object.\nString | Object | Signal\nDefault automatic sizing setting. Valid string values are "pad", "fit" or "none". See the autosize documentation for more. Signal support available in versions ≥ 5.10.\nautosize documentation\nBackground color of the view component, or null for transparent. Signal support available in versions ≥ 5.10.\nThe default text description for visualizations. The description determines the aria-label attribute for the container element of a Vega view. ≥ 5.10\nNumber | Object | Signal\nThe padding in pixels to add around the visualization. If a number, specifies padding for all sides. If an object, the value should have the format {"left": 5, "top": 5, "right": 5, "bottom": 5}. Signal support available in versions ≥ 5.10.\nThe width in pixels of the data rectangle. ≥ 5.10\nThe height in pixels of the data rectangle. ≥ 5.10\nDefault properties for the top-level group mark representing the data rectangle of a chart. Valid properties of this object are mark properties such as "fill", "stroke" and "strokeWidth".\nLocale definitions for string parsing and formatting of number and date values. The locale object should contain number and/or time properties with locale definitions. Locale definitions provided in the config block may be overridden by the View constructor locale option. ≥ 5.12\nA delimiter, such as a newline character, upon which to break text strings into multiple lines. This property provides a global default for text marks, which is overridden by mark or style config settings, and by the lineBreak mark encoding channel. If signal-valued, either string or regular expression (regexp) values are valid. ≥ 5.10\nSet default view background and chart plotting area background colors:\n{
  "background": "white",
  "group": {
    "fill": "#dedede"
  }
}\n{
  "background": "white",
  "group": {
    "fill": "#dedede"
  }
}\nSet the number and time format locale to German:\n{
  "locale": {
    "number": {
      "decimal": ",",
      "thousands": ".",
      "grouping": [3],
      "currency": ["", " €"]
    },
    "time": {
      "dateTime": "%A, der %e. %B %Y, %X",
      "date": "%d.%m.%Y",
      "time": "%H:%M:%S",
      "periods": ["AM", "PM"],
      "days": ["Sonntag", "Montag", "Dienstag", "Mittwoch", "Donnerstag", "Freitag", "Samstag"],
      "shortDays": ["So", "Mo", "Di", "Mi", "Do", "Fr", "Sa"],
      "months": ["Januar", "Februar", "März", "April", "Mai", "Juni", "Juli", "August", "September", "Oktober", "November", "Dezember"],
      "shortMonths": [ "Jan", "Feb", "Mrz", "Apr", "Mai", "Jun", "Jul", "Aug", "Sep", "Okt", "Nov", "Dez"]
    }
  }
}\n{
  "locale": {
    "number": {
      "decimal": ",",
      "thousands": ".",
      "grouping": [3],
      "currency": ["", " €"]
    },
    "time": {
      "dateTime": "%A, der %e. %B %Y, %X",
      "date": "%d.%m.%Y",
      "time": "%H:%M:%S",
      "periods": ["AM", "PM"],
      "days": ["Sonntag", "Montag", "Dienstag", "Mittwoch", "Donnerstag", "Freitag", "Samstag"],
      "shortDays": ["So", "Mo", "Di", "Mi", "Do", "Fr", "Sa"],
      "months": ["Januar", "Februar", "März", "April", "Mai", "Juni", "Juli", "August", "September", "Oktober", "November", "Dezember"],
      "shortMonths": [ "Jan", "Feb", "Mrz", "Apr", "Mai", "Jun", "Jul", "Aug", "Sep", "Okt", "Nov", "Dez"]
    }
  }
}\n"%A, der %e. %B %Y, %X"\nProperties for event handling configuration, defined within an "events" property block.\nConfiguration control for binding input DOM elements to signals. The available options are "any" (default, all bindings are allowed), "container" (use only the view container DOM element for all bindings, suppressing per-binding selectors), and "none" (suppresses all input bindings). ≥ 5.5\nAn object describing which events that originate within the Vega view should have their default behavior suppressed by invoking the event.preventDefault method. The defaults object should have a single property: either "prevent" (to indicate which events should have default behavior suppressed) or "allow" (to indicate only those events whose default behavior should be allowed). This property accepts either a boolean value (to prevent/allow all events) or an array of event type strings.\nConfiguration control for dynamic cursor setting. If false (default), the cursor is set for the Vega View element only. If true, the cursor is set globally for the entire document body. The default value of false avoids performance issues in browsers that recalculate styles in response to cursor changes. ≥ 5.13\nConfiguration control for event listeners for external sources specified using a CSS selector. If a boolean value, true (default) permits selector event listeners, false disallows all selector events. If a string array, the entries specify a list of event types (such as "mousemove" or "wheel") to allow. ≥ 5.5\nConfiguration control for event listeners for a "timer" source. One of true (default) to permit timer event listeners, or false to disallow timer events. ≥ 5.5\nConfiguration control for event listeners for the Vega "view" source. If a boolean value, true (default) permits view event listeners, false disallows all view events. If a string array, the entries specify a list of event types (such as "mousemove" or "wheel") to allow. ≥ 5.5\nConfiguration control for event listeners for the browser "window" source. If a boolean value, true (default) permits window event listeners, false disallows all window events. If a string array, the entries specify a list of event types (such as "mousemove" or "wheel") to allow. ≥ 5.5\nTo disable event listeners on external DOM elements specified by a CSS selector and permit only mousemove and mouseup events on the browser window object:\n"events": {
  "selector": false,
  "window": ["mousemove", "mouseup"]
}\n"events": {
  "selector": false,
  "window": ["mousemove", "mouseup"]
}\nTo prevent the default behavior for all events originating within a Vega view:\n"events": {
  "defaults": {
    "prevent": true
  }
}\n"events": {
  "defaults": {
    "prevent": true
  }
}\nTo prevent the default behavior for all events originating within a Vega view, except for wheel events:\n"events": {
  "defaults": {
    "allow": ["wheel"]
  }
}\n"events": {
  "defaults": {
    "allow": ["wheel"]
  }
}\nProperties defining default property values for each mark type. These properties are defined within blocks with names matching a valid mark type (e.g., "area", "line", "rect"). The valid properties within each block consist of the legal mark properties (e.g., "fill", "stroke", "size", "font"). Global defaults for all mark types can be set using the "mark" property.\nImportant limitations:\nDefaults for fill or stroke color will be applied only if neither "fill" nor "stroke" are defined in the Vega spec.\nDefaults set using the top-level "mark" property will be overridden by any defaults defined for more specific mark types (e.g., "rect"). Vega’s built-in configuration includes default fill or stroke colors for a number of specific mark types, and these will take precedence over new fill or stroke colors set only on the top-level "mark".\nTo set a default fill color and size for symbol marks:\n{
  "symbol": {
    "fill": "steelblue",
    "size": 64
  }
}\n{
  "symbol": {
    "fill": "steelblue",
    "size": 64
  }
}\nTo set a global opacity value for all mark types:\n{
  "mark": {
    "opacity": 0.8
  }
}\n{
  "mark": {
    "opacity": 0.8
  }
}\nIn addition to the default mark properties above, default values can be further customized using named styles defined under the style block
in the config. Styles can then be invoked by including a style directive within a mark definition.\nFor example, to set a default shape and stroke width for symbol marks with a style named "square":\n"style": {
  "square": {
    "shape": "square",
    "strokeWidth": 2
  }
}\n"style": {
  "square": {
    "shape": "square",
    "strokeWidth": 2
  }
}\nIn addition to custom style names, Vega includes the following built-in style names:\nguide-label: styles for axis and legend labels\nguide-title: styles for axis and legend titles\ngroup-title: styles for chart and header titles\nStyle settings take precedence over default mark settings, but are overridden by the axis, legend, and title properties described below.\nProperties defining default settings for axes. These properties are defined under the "axis" property in the config object, in which case the settings apply to all axes.\nAdditional property blocks can target more specific axis types based on the orientation ("axisX", "axisY", "axisLeft", "axisTop", etc.) or band scale type ("axisBand"). For example, properties defined under the "axisBand" property will only apply to axes visualizing "band" scales. If multiple axis config blocks apply to a single axis, type-based options take precedence over orientation-based options, which in turn take precedence over general options.\nAn interpolation fraction indicating where, for band scales, axis ticks should be positioned. A value of 0 places ticks at the left edge of their bands. A value of 0.5 places ticks in the middle of their bands.\nBoolean flag indicating if axis domain line should be included by default.\nThe stroke cap for the axis domain line. One of "butt" (default), "round" or "square". ≥ 5.11\nColor of axis domain line.\nStroke dash of axis domain lines (or [] for solid lines). ≥ 5.0\nThe pixel offset at which to start the domain dash array. ≥ 5.0\nOpacity of axis domain line. ≥ 4.1\nStroke width of axis domain line.\nBoolean flag indicating if axis grid lines should be included by default.\nThe stroke cap for axis grid lines. One of "butt" (default), "round" or "square". ≥ 5.11\nColor of axis grid lines.\nStroke dash of axis grid lines (or [] for solid lines).\nThe pixel offset at which to start the grid dash array. ≥ 5.0\nOpacity of axis grid lines.\nStroke width of axis grid lines.\nBoolean flag indicating if axis tick labels should be included by default.\nHorizontal text alignment of axis tick labels, overriding the default setting for the axis orientation.\nAngle in degrees of axis tick labels.\nVertical text baseline of axis tick labels, overriding the default setting for the axis orientation.\nBoolean flag or pixel tolerance value for removal of labels that exceed the axis range.\nText color of axis tick labels.\nBoolean flag or pixel distance threshold value for performing a “flush” layout of axis labels. For an x-axis, flush alignment will left-align the left-most labels (if within the distance threshold from the axis start) and similarly right-align the right-most labels. If true, a pixel tolerance of 1 is used.\nOffset in pixels for flush-adjusted labels (default 0).\nFont name for axis tick labels.\nFont size of axis tick labels.\nFont style of axis tick labels (e.g., normal or italic). ≥ 5.0\nFont weight of axis tick labels.\nThe maximum allowed length in pixels of axis tick labels.\nLine height in pixels for multi-line label text. ≥ 5.10\nPosition offset in pixels to apply to labels, in addition to tickOffset. ≥ 5.10\nOpacity of axis tick labels. ≥ 4.1\nThe strategy to use for resolving overlap of axis labels. If false, no overlap reduction is attempted. If true or "parity", a strategy of removing every other label is used (this works well for standard linear axes). If "greedy", a linear scan of the labels is performed, removing any labels that overlaps with the last visible label (this often works better for log-scaled axes).\nThe minimum separation that must be between label bounding boxes for them to be considered non-overlapping (default 0). This property is ignored if labelOverlap resolution is not enabled. ≥ 5.0\nPadding in pixels between axis ticks and tick labels.\nThe maximum extent in pixels that axis ticks and labels should use. This determines a maximum offset value for axis titles.\nThe minimum extent in pixels that axis ticks and labels should use. This determines a minimum offset value for axis titles.\nBoolean flag indicating if axis tick marks should be included by default.\nIndicates the type of tick style to use in conjunction with band scales. One of "center" (default) to center ticks in the middle of the band interval, or "extent" to place ticks at band extents (interval boundaries). If specified, this property may override the settings of bandPosition, tickExtra, and tickOffset. ≥ 5.8\nThe stroke cap for axis tick marks. One of "butt" (default), "round" or "square". ≥ 5.11\nStroke dash of axis tick marks (or [] for solid lines). ≥ 5.0\nThe pixel offset at which to start the tick mark dash array. ≥ 5.0\nBoolean flag indicating if an extra axis tick should be added for the initial position of the axis. This flag is useful for styling axes for band scales such that ticks are placed on band boundaries rather in the middle of a band. Use in conjunction with "bandPosition": 1 and an axis "padding" value of 0.\nPosition offset in pixels to apply to ticks, labels, and gridlines.\nOpacity of axis ticks. ≥ 4.1\nBoolean flag indicating if pixel position values should be rounded to the nearest integer.\nSize, or length, in pixels of axis ticks.\nWidth in pixels of axis ticks.\nHorizontal text alignment of axis titles. One of "left", "center", or "right". If specified, this value overrides automatic alignment based on the titleAnchor value.\nThe anchor position for placing axis titles. One of "start", "middle", "end", or null (default, for automatic determination). For example, with an orient of "bottom" these anchor positions map to a left-, center-, or right-aligned title. The anchor point is determined relative to the axis scale range. ≥ 5.0\nAngle in degrees of axis titles.\nVertical text baseline for axis titles.\nText color of axis titles.\nFont name for axis titles.\nFont size of axis titles.\nFont style of axis titles (e.g., normal or italic). ≥ 5.0\nFont weight of axis titles.\nThe maximum allowed length in pixels of axis titles.\nLine height in pixels for multi-line title text. ≥ 5.7\nOpacity of axis titles. ≥ 4.1\nPadding in pixels between axis tick labels and titles.\nX-coordinate of the axis title relative to the axis group.\nY-coordinate of the axis title relative to the axis group.\nCoordinate space translation offset for axis layout. By default, axes are translated by a 0.5 pixel offset for both the x and y coordinates, in order to align stroked lines with the pixel grid. However, for vector graphics output these pixel-specific adjustments may be undesirable, in which case translate can be changed (for example, to zero). ≥ 5.8\nThe integer z-index indicating the layering of the axis group relative to other axis, mark, and legend groups. With a value of 0 axes and grid lines are drawn behind any marks defined in the same specification level. Higher values (1) cause axes and grid lines to be drawn on top of marks. ≥ 5.11\nAxis Accessibility Properties\nAccessibility properties are used to determine ARIA (Accessible Rich Internet Applications) attributes when using Vega to render SVG output.\nARIA (Accessible Rich Internet Applications) attributes\nA boolean flag (default true) indicating if ARIA attributes should be included (SVG output only). If false, the “aria-hidden” attribute will be set on the output SVG group, removing the axis from the ARIA accessibility tree. ≥ 5.11\nA text description of this axis for ARIA accessibility (SVG output only). If the aria property is true, for SVG output the “aria-label” attribute will be set to this description. If the description is unspecified it will be automatically generated. ≥ 5.11\n“aria-label” attribute\nThis example sets the axis label color to dark gray for all axes, and rotates the labels for axes oriented along the bottom of a chart.\n{
  "axis": {
    "labelColor": "#ccc"
  },
  "axisBottom": {
    "labelAngle": -90
  }
}\n{
  "axis": {
    "labelColor": "#ccc"
  },
  "axisBottom": {
    "labelAngle": -90
  }
}\nProperties defining default settings for legends. These properties are defined under the "legend" property within the config object.\nThe height in pixels to clip symbol legend entries and limit their size.\nThe number of columns in which to arrange symbol legend entries. A value of 0 or lower indicates a single row with one column per entry.\nThe horizontal padding in pixels between symbol legend entries.\nCorner radius for the full legend.\nBackground fill color for the full legend.\nThe default direction ("horizontal" or "vertical") for gradient legends.\nThe length in pixels of the primary axis of a color gradient. This value corresponds to the height of a vertical gradient or the width of a horizontal gradient.\nThe thickness in pixels of the color gradient. This value corresponds to the width of a vertical gradient or the height of a horizontal gradient.\nDeprecated, use gradientLength instead. If gradientLength is not defined, this value will be used instead.\nDeprecated, use gradientThickness instead. If gradientThickness is not defined, this value will be used instead.\nStroke color for color ramp gradient borders.\nStroke width for color ramp gradient borders.\nThe maximum allowed length in pixels of color ramp gradient labels.\nVertical offset in pixels for color ramp gradient labels.\nOpacity of color ramp gradient. ≥ 4.1\nThe alignment to apply to symbol legends rows and columns. The supported string values are all, each (the default), and none. For more information, see the grid layout documentation.\ngrid layout documentation\nHorizontal text alignment of legend labels.\nVertical text baseline of legend labels.\nText color of legend labels.\nFont name of legend labels.\nFont size in pixels of legend labels.\nFont style of legend labels (e.g., normal or italic). ≥ 5.0\nFont weight of legend labels.\nThe maximum allowed length in pixels of legend labels.\nHorizontal offset in pixels between legend symbols and labels.\nOpacity of legend labels. ≥ 4.1\nThe strategy to use for resolving overlap of labels in gradient legends. If false, no overlap reduction is attempted. If set to true (default) or "parity", a strategy of removing every other label is used. If set to "greedy", a linear scan of the labels is performed, removing any label that overlaps with the last visible label.\nThe minimum separation that must be between label bounding boxes for them to be considered non-overlapping (default 0). This property is ignored if labelOverlap resolution is not enabled. ≥ 5.0\nAn object specifying layout parameters for positioning a collection of legends with the same orient value. ≥ 5.0\nThe pixel x-coordinate of the legend group. Only applied if the orient value is "none". ≥ 5.4\nThe pixel y-coordinate of the legend group. Only applied if the orient value is "none". ≥ 5.4\nOffset in pixels of the legend from the chart body. If specified, this value will override any values specified in the legend layout config.\nDefault legend orientation (e.g., "right" or "left").\nPadding in pixels between legend border and contents.\nThe vertical padding in pixels between symbol legend entries.\nBorder stroke color for the full legend.\nBorder stroke dash pattern for the full legend.\nBorder stroke width for the full legend.\nDefault fill color for legend symbols. Only applied if there is no "fill" scale color encoding for the legend.\nsymbolBaseStrokeColor\nDefault stroke color for legend symbols. Only applied if there is no "fill" scale color encoding for the legend.\nStroke dash of symbol outlines (or [] for solid lines). ≥ 5.0\nThe pixel offset at which to start the symbol dash array. ≥ 5.0\nThe default direction ("horizontal" or "vertical") for symbol legends.\nFill color for legend symbols.\nThe maximum number of allowed entries for a symbol legend. If the number of entries exceeds the limit, entries will be dropped and replaced with an ellipsis. ≥ 5.7\nHorizontal pixel offset for legend symbols.\nOpacity of legend symbols. ≥ 4.1\nDefault symbol area size (in pixels2).\nStroke color for legend symbols.\nDefault legend symbol stroke width.\nDefault shape type (such as "circle") for legend symbols.\nNumber | String | Object\nThe desired number of tick values for quantitative legends. For scales of type time or utc, the tick count can instead be a time interval specifier. Legal string values are "millisecond", "second", "minute", "hour", "day", "week", "month", and "year". Alternatively, an object-valued interval specifier of the form {"interval": "month", "step": 3} includes a desired number of interval steps. Here, ticks are generated for each quarter (Jan, Apr, Jul, Oct) boundary. ≥ 5.7\nHorizontal text alignment of legend titles. One of "left", "center", or "right". If specified, this value overrides automatic alignment based on the titleOrient and titleAnchor values.\nThe anchor position for placing legend titles. One of "start", "middle", "end", or null (default, for automatic determination). For example, with a titleOrient of "top" these anchor positions map to a left-, center-, or right-aligned title relative to the legend contents. ≥ 5.0\nVertical text baseline of legend titles. If specified, this value overrides the automatic baseline based on the titleOrient and titleAnchor values.\nText color of legend titles.\nFont name of legend titles.\nFont size in pixels of legend titles.\nFont style of legend titles (e.g., normal or italic). ≥ 5.0\nFont weight for legend titles.\nThe maximum allowed length in pixels of legend titles.\nLine height in pixels for multi-line title text. ≥ 5.7\nOpacity of legend titles. ≥ 4.1\nThe orientation of title legends, determining where they are placed relative to legend contents. One of "top" (default), "left", "bottom", or "right". ≥ 5.0\nPadding in pixels between the legend title and entries.\nThe integer z-index indicating the layering of the legend group relative to other axis, mark, and legend groups. ≥ 5.11\nLegend Accessibility Properties\nAccessibility properties are used to determine ARIA (Accessible Rich Internet Applications) attributes when using Vega to render SVG output.\nARIA (Accessible Rich Internet Applications) attributes\nA boolean flag (default true) indicating if ARIA attributes should be included (SVG output only). If false, the “aria-hidden” attribute will be set on the output SVG group, removing the legend from the ARIA accessibility tree. ≥ 5.11\nA text description of this legend for ARIA accessibility (SVG output only). If the aria property is true, for SVG output the “aria-label” attribute will be set to this description. If the description is unspecified it will be automatically generated. ≥ 5.11\n“aria-label” attribute\nLegend Layout Properties ≥ 5.0\nCollections of legends with the same orient value are positioned together, either vertically or horizontally in sequence. The legend layout property enables customization of how legends are organized within a Vega view. The layout property is an object value that may contain both top-level properties that apply to all legends and a set of orient-specific properties for customizing specific legend orientations.\nAn anchor value determining the placement of the legends relative to the nearest axis. One of "start" (default), "middle", or "end". For example, for legends with orient "top", these values respectively correspond to anchoring the legends to the left edge, center, or right edge of the charting area. This property only applies to axes with an orient value of "left", "right", "top", or "bottom".\nThe type of bounding box calculation to use for calculating legend extents. One of "flush" (the default, for using legend width and height values only) or "full" (to use the full bounding box, for example including border stroke widths).\nA boolean flag (default false) indicating if legends should be centered within the respective layout area. For example, given a vertical direction, two legends will share a left edge by default. If center is true, the smaller legends will be centered in the space spanned by all the legends.\nThe direction in which subsequent legends should be spatially positioned. One of "horizontal" or "vertical".\nMargin, in pixels, to place between consecutive legends with the same orient value.\nOffset, in pixels, of the legend from the chart body.\nIn addition to these top-level properties, the legend layout may include sub-objects (containing the same properties listed above) for any of the legal legend orient values other than "none": "left", "right", "top", "bottom", "top-left", "top-right", "bottom-left", "bottom-right".\nNote: The default configuration includes legend layout entries for "left" and "right" orientations. If you add custom layout parameters at the top-level, these will not override more specific configurations. If you want to modify the layout of "left"- or "right"-oriented legends, use a specific sub-object targeting those orientations.\ndefault configuration\nThis example gives every legend a 10 pixel padding and a light gray border:\n{
  "legend": {
    "padding": 10,
    "legendStrokeColor": "#ccc",
    "legendStrokeWidth": 1
  }
}\n{
  "legend": {
    "padding": 10,
    "legendStrokeColor": "#ccc",
    "legendStrokeWidth": 1
  }
}\nThis example customizes the layout of legends with orient value "bottom", stacking those legends vertically with 2 pixel margins, anchoring their x-positon to the middle of the chart area, and centering the legends within their layout area:\n{
  "legend": {
    "layout": {
      "bottom": {
        "anchor": "middle",
        "direction": "vertical",
        "center": true,
        "margin": 2,
      }
    }
  }
}\n{
  "legend": {
    "layout": {
      "bottom": {
        "anchor": "middle",
        "direction": "vertical",
        "center": true,
        "margin": 2,
      }
    }
  }
}\nProperties defining default settings for titles. These properties are defined under the "title" property within the config object.\nHorizontal text alignment of the title and subtitle. If specified, this value overrides automatic alignment based on the anchor value.\nTitle and subtitle anchor position ("start", "middle", or "end").\nAngle in degrees of the title and subtitle text.\nVertical text baseline of the title and subtitle.\nText color of the title text.\nHorizontal offset added to the title and subtitle x-coordinate. ≥ 5.2\nVertical offset added to the title and subtitle y-coordinate. ≥ 5.2\nFont name of the title text.\nFont size in pixels of the title text.\nFont style of the title text (e.g., normal or italic). ≥ 5.0\nFont weight for title text.\nThe reference frame for the anchor position, one of "bounds" (to anchor relative to the full bounding box) or "group" (to anchor relative to the group width or height).\nThe maximum allowed length in pixels of title and subtitle text.\nLine height in pixels for multi-line title text. ≥ 5.7\nOffset in pixels of the title from the chart body and axes.\nDefault title orientation ("top", "bottom", "left", or "right").\nText color of the subtitle text. ≥ 5.7\nFont name of the subtitle text. ≥ 5.7\nFont size in pixels of the subtitle text. ≥ 5.7\nFont style of the subtitle text (e.g., normal or italic). ≥ 5.7\nFont weight for subtitle text. ≥ 5.7\nLine height in pixels for multi-line subtitle text. ≥ 5.7\nPadding in pixels between title and subtitle text. ≥ 5.7\nThe integer z-index indicating the layering of the title group relative to other axis, mark, and legend groups. ≥ 5.11\nTitle Accessibility Properties\nAccessibility properties are used to determine ARIA (Accessible Rich Internet Applications) attributes when using Vega to render SVG output.\nARIA (Accessible Rich Internet Applications) attributes\nA boolean flag (default true) indicating if ARIA attributes should be included (SVG output only). If false, the “aria-hidden” attribute will be set on the output SVG group, removing the title from the ARIA accessibility tree. ≥ 5.11\nThis example gives every title a 10 pixel offset and a font size of 18 pixels.\n{
  "title": {
    "offset": 10,
    "fontSize": 18
  }
}\n{
  "title": {
    "offset": 10,
    "fontSize": 18
  }
}\nProjection Properties\nDefault properties to apply to cartographic projections, if not explicitly included in the input JSON specification. Any legal projection property may be included. These properties are defined under the "projection" property in the config object. A common use for this property is to set a default projection type.\ncartographic projections\nThis example sets the default projection type to be an "equalEarth" projection:\n{
  "projection": {
    "type": "equalEarth"
  }
}\n{
  "projection": {
    "type": "equalEarth"
  }
}\nScale Range Properties\nProperties defining named range arrays that can be used within scale range definitions (such as {"type": "ordinal", "range": "category"}). These properties are defined under the "range" property in the config object.\nObject-valued properties must be legal scale range definitions.\nDefault color scheme for categorical data.\nDefault color scheme for diverging quantitative ramps.\nDefault color scheme for quantitative heatmaps.\nDefault color scheme for rank-ordered data.\nDefault color scheme for sequential quantitative ramps.\nArray of symbol names or paths for the default shape palette.\nThis example sets new default color palettes.\n{
  "range": {
    "category": [
      "#5079a5",
      "#ef8e3b",
      "#dd565c",
      "#79b7b2",
      "#5da052",
      "#ecc853",
      "#ad7aa1",
      "#ef9ba7",
      "#9b7461",
      "#bab0ac"
    ],
    "ordinal": {"scheme": "greens"},
    "ramp": {"scheme": "purples"}
  }
}\n{
  "range": {
    "category": [
      "#5079a5",
      "#ef8e3b",
      "#dd565c",
      "#79b7b2",
      "#5da052",
      "#ecc853",
      "#ad7aa1",
      "#ef9ba7",
      "#9b7461",
      "#bab0ac"
    ],
    "ordinal": {"scheme": "greens"},
    "ramp": {"scheme": "purples"}
  }
}\nSignal Definitions ≥ 5.5\nConfiguration files may also contain signal definitions for the top-level scope of a Vega specification. The syntax is identical to standard signal definitions: an array of named signal objects. Adding signal definitions to a configuration can be useful for defining style variables (colors, font sizes, etc.) that may be used elsewhere within either the config or a spec itself. Signals directly defined within a specification itself take precedence over those defined in the configuration.\nstandard signal definitions\nTo enable dynamic scaling of font sizes, one can define a signal that for a font size scale factor, then define other config entries relative to this value:\n{
  "signals": [
    {"name": "fontSizeScale", "value": 1}
  ],
  "text": {
    "fontSize": {"signal": "11 * fontSizeScale"}
  }
}\n{
  "signals": [
    {"name": "fontSizeScale", "value": 1}
  ],
  "text": {
    "fontSize": {"signal": "11 * fontSizeScale"}
  }
}\n\n\nVega
            
              Vega-Lite
              Altair
              Vega-Lite API
            
          
          
            
              Examples
              Tutorials
              Documentation
              Usage
              About
            
            
              GitHub
              Try Online
            
          
        
      

      
        

  
  
    
      
      
        Documentation
      
      
      
      
        Specification
      
      
      
      
        Config
      
      
      
      
        Data
      
      
      
      
        Transforms
      
      
      
        
        
          aggregate
        
        
        
          bin
        
        
        
          collect
        
        
        
          countpattern
        
        
        
          contour
        
        
        
          cross
        
        
        
          crossfilter
        
        
        
          density
        
        
        
          dotbin
        
        
        
          extent
        
        
        
          filter
        
        
        
          flatten
        
        
        
          fold
        
        
        
          force
        
        
        
          formula
        
        
        
          geojson
        
        
        
          geopath
        
        
        
          geopoint
        
        
        
          geoshape
        
        
        
          graticule
        
        
        
          heatmap
        
        
        
          identifier
        
        
        
          impute
        
        
        
          isocontour
        
        
        
          joinaggregate
        
        
        
          kde
        
        
        
          kde2d
        
        
        
          label
        
        
        
          linkpath
        
        
        
          loess
        
        
        
          lookup
        
        
        
          nest
        
        
        
          pack
        
        
        
          partition
        
        
        
          pie
        
        
        
          pivot
        
        
        
          project
        
        
        
          quantile
        
        
        
          regression
        
        
        
          resolvefilter
        
        
        
          sample
        
        
        
          sequence
        
        
        
          stack
        
        
        
          stratify
        
        
        
          timeunit
        
        
        
          tree
        
        
        
          treelinks
        
        
        
          treemap
        
        
        
          voronoi
        
        
        
          window
        
        
        
          wordcloud
        
      
      
      
      
        Triggers
      
      
      
      
        Projections
      
      
      
      
        Scales
      
      
      
      
        Schemes
      
      
      
      
        Axes
      
      
      
      
        Legends
      
      
      
      
        Title
      
      
      
      
        Marks
      
      
      
      
        Signals
      
      
      
      
        Event Streams
      
      
      
      
        Expressions
      
      
      
      
        Layout
      
      
      
      
        Types
      
      
    
  
  
    Transforms
    Transforms process a data stream to filter data, calculate new fields, or derive new data streams. Transforms are typically specified within the transform array of a data definition. In addition, transforms that do not filter or generate new data objects can be used within the transform array of a mark definition to specify post-encoding transforms.

The following example defines a new data set with transforms to filter values and then compute a stacked layout (e.g., for a stacked bar chart):

{
  "data": [
    {
      "name": "table",
      "transform": [
        { "type": "filter", "expr": "datum.value > 5" },
        { "type": "stack", "field": "value", "groupby": ["category"] }
      ]
    }
  ]
}


All transforms require a type property, specifying the name of the transform. Transforms that produce a value as a side-effect (in particular, the bin, extent, and crossfilter transforms) can include a signal property to specify a unique signal name to which to bind the transform’s state value.

Basic Transforms

Transforms for processing streams of data objects.


  aggregate - Group and summarize a data stream.
  bin - Discretize numeric values into uniform bins.
  collect - Collect and sort all data objects in a stream.
  countpattern - Count the frequency of patterns in text strings.
  cross - Perform a cross-product of a data stream with itself.
  density - Generate values drawn from a probability distribution.
  dotbin - Perform density binning for dot plot construction. ≥ 5.7
  extent - Compute minimum and maximum values over a data stream.
  filter - Filter a data stream using a predicate expression.
  flatten - Map array-typed fields to data objects, one per array entry. ≥ 3.1
  fold - Collapse selected data fields into key and value properties.
  formula - Extend data objects with derived fields using a formula expression.
  identifier - Assign unique key values to data objects.
  kde - Estimate smoothed densities for numeric values. ≥ 5.4
  impute - Perform imputation of missing values.
  joinaggregate - Extend data objects with calculated aggregate values.
  loess - Fit a smoothed trend line using local regression. ≥ 5.4
  lookup - Extend data objects by looking up key values on another stream.
  pivot - Pivot unique values to new aggregate fields. ≥ 3.2
  project - Generate derived data objects with a selected set of fields.
  quantile - Calculate sample quantile values over an input data stream. ≥ 5.7
  regression - Fit regression models to smooth and predict values. ≥ 5.4
  sample - Randomly sample data objects in a stream.
  sequence - Generate a new stream containing a sequence of numeric values.
  timeunit - Discretize date-time values into time unit bins. ≥ 5.8
  window - Calculate over ordered groups, including ranking and running totals.


Geographic and Spatial Transforms

Transforms for modeling spatial data, cartographic projection, and geographic guides.


  contour - Deprecated. Model a spatial distribution using discrete levels.
  geojson - Consolidate geographic data into a GeoJSON feature collection.
  geopath - Map GeoJSON features to SVG path strings.
  geopoint - Map (longitude, latitude) coordinates to (x, y) points.
  geoshape - Map GeoJSON features to a shape instance for procedural drawing.
  graticule - Generate a reference grid for cartographic maps.
  heatmap - Generate heatmap images for raster grid data. ≥ 5.8
  isocontour - Generate level set contours for raster grid data. ≥ 5.8
  kde2d - Estimate 2D densities as output raster grids. ≥ 5.8


Layout Transforms

Transforms for calculating spatial coordinates to achieve various layouts.


  force - Compute a force-directed layout via physical simulation.
  label - Compute text position and opacity to label a chart. ≥ 5.16
  linkpath - Route visual links between node elements.
  pie - Compute angular layout for pie and donut charts.
  stack - Compute stacked layouts for groups of values.
  voronoi - Compute a Voronoi diagram for a set of points.
  wordcloud - Compute a word cloud layout of text strings.


Hierarchy Transforms

Transforms for processing hierarchy (tree) data and performing tree layout.


  nest - Generate a tree structure by grouping objects by field values.
  stratify - Generate a tree structure using explicit key values.
  treelinks - Generate link data objects for a tree structure.
  pack - Tree layout based on circular enclosure.
  partition - Tree layout based on spatial adjacency of nodes.
  tree - Tree layout for a node-link diagram.
  treemap - Tree layout based on recursive rectangular subdivision.


Cross-Filter Transforms

Transforms for supporting fast incremental filtering of multi-dimensional data.


  crossfilter - Maintain a filter mask for multiple dimensional queries.
  resolvefilter - Resolve crossfilter output to generate filtered data streams.


Custom Transforms

In addition to the above, custom transformations can also be added to Vega as part of its Extensibility API.
See the Transformations section of the API documentation.\nVega
            
              Vega-Lite
              Altair
              Vega-Lite API\nVega-Lite
              Altair
              Vega-Lite API\nExamples
              Tutorials
              Documentation
              Usage
              About
            
            
              GitHub
              Try Online\nExamples
              Tutorials
              Documentation
              Usage
              About\nGitHub
              Try Online\nDocumentation
      
      
      
      
        Specification
      
      
      
      
        Config
      
      
      
      
        Data
      
      
      
      
        Transforms
      
      
      
        
        
          aggregate
        
        
        
          bin
        
        
        
          collect
        
        
        
          countpattern
        
        
        
          contour
        
        
        
          cross
        
        
        
          crossfilter
        
        
        
          density
        
        
        
          dotbin
        
        
        
          extent
        
        
        
          filter
        
        
        
          flatten
        
        
        
          fold
        
        
        
          force
        
        
        
          formula
        
        
        
          geojson
        
        
        
          geopath
        
        
        
          geopoint
        
        
        
          geoshape
        
        
        
          graticule
        
        
        
          heatmap
        
        
        
          identifier
        
        
        
          impute
        
        
        
          isocontour
        
        
        
          joinaggregate
        
        
        
          kde
        
        
        
          kde2d
        
        
        
          label
        
        
        
          linkpath
        
        
        
          loess
        
        
        
          lookup
        
        
        
          nest
        
        
        
          pack
        
        
        
          partition
        
        
        
          pie
        
        
        
          pivot
        
        
        
          project
        
        
        
          quantile
        
        
        
          regression
        
        
        
          resolvefilter
        
        
        
          sample
        
        
        
          sequence
        
        
        
          stack
        
        
        
          stratify
        
        
        
          timeunit
        
        
        
          tree
        
        
        
          treelinks
        
        
        
          treemap
        
        
        
          voronoi
        
        
        
          window
        
        
        
          wordcloud
        
      
      
      
      
        Triggers
      
      
      
      
        Projections
      
      
      
      
        Scales
      
      
      
      
        Schemes
      
      
      
      
        Axes
      
      
      
      
        Legends
      
      
      
      
        Title
      
      
      
      
        Marks
      
      
      
      
        Signals
      
      
      
      
        Event Streams
      
      
      
      
        Expressions
      
      
      
      
        Layout
      
      
      
      
        Types
      
      
    
  
  
    Transforms
    Transforms process a data stream to filter data, calculate new fields, or derive new data streams. Transforms are typically specified within the transform array of a data definition. In addition, transforms that do not filter or generate new data objects can be used within the transform array of a mark definition to specify post-encoding transforms.

The following example defines a new data set with transforms to filter values and then compute a stacked layout (e.g., for a stacked bar chart):

{
  "data": [
    {
      "name": "table",
      "transform": [
        { "type": "filter", "expr": "datum.value > 5" },
        { "type": "stack", "field": "value", "groupby": ["category"] }
      ]
    }
  ]
}


All transforms require a type property, specifying the name of the transform. Transforms that produce a value as a side-effect (in particular, the bin, extent, and crossfilter transforms) can include a signal property to specify a unique signal name to which to bind the transform’s state value.

Basic Transforms

Transforms for processing streams of data objects.


  aggregate - Group and summarize a data stream.
  bin - Discretize numeric values into uniform bins.
  collect - Collect and sort all data objects in a stream.
  countpattern - Count the frequency of patterns in text strings.
  cross - Perform a cross-product of a data stream with itself.
  density - Generate values drawn from a probability distribution.
  dotbin - Perform density binning for dot plot construction. ≥ 5.7
  extent - Compute minimum and maximum values over a data stream.
  filter - Filter a data stream using a predicate expression.
  flatten - Map array-typed fields to data objects, one per array entry. ≥ 3.1
  fold - Collapse selected data fields into key and value properties.
  formula - Extend data objects with derived fields using a formula expression.
  identifier - Assign unique key values to data objects.
  kde - Estimate smoothed densities for numeric values. ≥ 5.4
  impute - Perform imputation of missing values.
  joinaggregate - Extend data objects with calculated aggregate values.
  loess - Fit a smoothed trend line using local regression. ≥ 5.4
  lookup - Extend data objects by looking up key values on another stream.
  pivot - Pivot unique values to new aggregate fields. ≥ 3.2
  project - Generate derived data objects with a selected set of fields.
  quantile - Calculate sample quantile values over an input data stream. ≥ 5.7
  regression - Fit regression models to smooth and predict values. ≥ 5.4
  sample - Randomly sample data objects in a stream.
  sequence - Generate a new stream containing a sequence of numeric values.
  timeunit - Discretize date-time values into time unit bins. ≥ 5.8
  window - Calculate over ordered groups, including ranking and running totals.


Geographic and Spatial Transforms

Transforms for modeling spatial data, cartographic projection, and geographic guides.


  contour - Deprecated. Model a spatial distribution using discrete levels.
  geojson - Consolidate geographic data into a GeoJSON feature collection.
  geopath - Map GeoJSON features to SVG path strings.
  geopoint - Map (longitude, latitude) coordinates to (x, y) points.
  geoshape - Map GeoJSON features to a shape instance for procedural drawing.
  graticule - Generate a reference grid for cartographic maps.
  heatmap - Generate heatmap images for raster grid data. ≥ 5.8
  isocontour - Generate level set contours for raster grid data. ≥ 5.8
  kde2d - Estimate 2D densities as output raster grids. ≥ 5.8


Layout Transforms

Transforms for calculating spatial coordinates to achieve various layouts.


  force - Compute a force-directed layout via physical simulation.
  label - Compute text position and opacity to label a chart. ≥ 5.16
  linkpath - Route visual links between node elements.
  pie - Compute angular layout for pie and donut charts.
  stack - Compute stacked layouts for groups of values.
  voronoi - Compute a Voronoi diagram for a set of points.
  wordcloud - Compute a word cloud layout of text strings.


Hierarchy Transforms

Transforms for processing hierarchy (tree) data and performing tree layout.


  nest - Generate a tree structure by grouping objects by field values.
  stratify - Generate a tree structure using explicit key values.
  treelinks - Generate link data objects for a tree structure.
  pack - Tree layout based on circular enclosure.
  partition - Tree layout based on spatial adjacency of nodes.
  tree - Tree layout for a node-link diagram.
  treemap - Tree layout based on recursive rectangular subdivision.


Cross-Filter Transforms

Transforms for supporting fast incremental filtering of multi-dimensional data.


  crossfilter - Maintain a filter mask for multiple dimensional queries.
  resolvefilter - Resolve crossfilter output to generate filtered data streams.


Custom Transforms

In addition to the above, custom transformations can also be added to Vega as part of its Extensibility API.
See the Transformations section of the API documentation.\nTransforms process a data stream to filter data, calculate new fields, or derive new data streams. Transforms are typically specified within the transform array of a data definition. In addition, transforms that do not filter or generate new data objects can be used within the transform array of a mark definition to specify post-encoding transforms.\nThe following example defines a new data set with transforms to filter values and then compute a stacked layout (e.g., for a stacked bar chart):\n{
  "data": [
    {
      "name": "table",
      "transform": [
        { "type": "filter", "expr": "datum.value > 5" },
        { "type": "stack", "field": "value", "groupby": ["category"] }
      ]
    }
  ]
}\n{
  "data": [
    {
      "name": "table",
      "transform": [
        { "type": "filter", "expr": "datum.value > 5" },
        { "type": "stack", "field": "value", "groupby": ["category"] }
      ]
    }
  ]
}\nAll transforms require a type property, specifying the name of the transform. Transforms that produce a value as a side-effect (in particular, the bin, extent, and crossfilter transforms) can include a signal property to specify a unique signal name to which to bind the transform’s state value.\nTransforms for processing streams of data objects.\naggregate - Group and summarize a data stream.\nbin - Discretize numeric values into uniform bins.\ncollect - Collect and sort all data objects in a stream.\ncountpattern - Count the frequency of patterns in text strings.\ncross - Perform a cross-product of a data stream with itself.\ndensity - Generate values drawn from a probability distribution.\ndotbin - Perform density binning for dot plot construction. ≥ 5.7\nextent - Compute minimum and maximum values over a data stream.\nfilter - Filter a data stream using a predicate expression.\nflatten - Map array-typed fields to data objects, one per array entry. ≥ 3.1\nfold - Collapse selected data fields into key and value properties.\nformula - Extend data objects with derived fields using a formula expression.\nidentifier - Assign unique key values to data objects.\nkde - Estimate smoothed densities for numeric values. ≥ 5.4\nimpute - Perform imputation of missing values.\njoinaggregate - Extend data objects with calculated aggregate values.\nloess - Fit a smoothed trend line using local regression. ≥ 5.4\nlookup - Extend data objects by looking up key values on another stream.\npivot - Pivot unique values to new aggregate fields. ≥ 3.2\nproject - Generate derived data objects with a selected set of fields.\nquantile - Calculate sample quantile values over an input data stream. ≥ 5.7\nregression - Fit regression models to smooth and predict values. ≥ 5.4\nsample - Randomly sample data objects in a stream.\nsequence - Generate a new stream containing a sequence of numeric values.\ntimeunit - Discretize date-time values into time unit bins. ≥ 5.8\nwindow - Calculate over ordered groups, including ranking and running totals.\nGeographic and Spatial Transforms\nTransforms for modeling spatial data, cartographic projection, and geographic guides.\ncontour - Deprecated. Model a spatial distribution using discrete levels.\ngeojson - Consolidate geographic data into a GeoJSON feature collection.\ngeopath - Map GeoJSON features to SVG path strings.\ngeopoint - Map (longitude, latitude) coordinates to (x, y) points.\ngeoshape - Map GeoJSON features to a shape instance for procedural drawing.\ngraticule - Generate a reference grid for cartographic maps.\nheatmap - Generate heatmap images for raster grid data. ≥ 5.8\nisocontour - Generate level set contours for raster grid data. ≥ 5.8\nkde2d - Estimate 2D densities as output raster grids. ≥ 5.8\nTransforms for calculating spatial coordinates to achieve various layouts.\nforce - Compute a force-directed layout via physical simulation.\nlabel - Compute text position and opacity to label a chart. ≥ 5.16\nlinkpath - Route visual links between node elements.\npie - Compute angular layout for pie and donut charts.\nstack - Compute stacked layouts for groups of values.\nvoronoi - Compute a Voronoi diagram for a set of points.\nwordcloud - Compute a word cloud layout of text strings.\nTransforms for processing hierarchy (tree) data and performing tree layout.\nnest - Generate a tree structure by grouping objects by field values.\nstratify - Generate a tree structure using explicit key values.\ntreelinks - Generate link data objects for a tree structure.\npack - Tree layout based on circular enclosure.\npartition - Tree layout based on spatial adjacency of nodes.\ntree - Tree layout for a node-link diagram.\ntreemap - Tree layout based on recursive rectangular subdivision.\nCross-Filter Transforms\nTransforms for supporting fast incremental filtering of multi-dimensional data.\ncrossfilter - Maintain a filter mask for multiple dimensional queries.\nresolvefilter - Resolve crossfilter output to generate filtered data streams.\nIn addition to the above, custom transformations can also be added to Vega as part of its Extensibility API.
See the Transformations section of the API documentation.\n\n\nVega
            
              Vega-Lite
              Altair
              Vega-Lite API
            
          
          
            
              Examples
              Tutorials
              Documentation
              Usage
              About
            
            
              GitHub
              Try Online
            
          
        
      

      
        

  
  
    
      
      
        Documentation
      
      
      
      
        Specification
      
      
      
      
        Config
      
      
      
      
        Data
      
      
      
      
        Transforms
      
      
      
      
        Triggers
      
      
      
      
        Projections
      
      
      
      
        Scales
      
      
      
      
        Schemes
      
      
      
      
        Axes
      
      
      
      
        Legends
      
      
      
      
        Title
      
      
      
      
        Marks
      
      
      
      
        Signals
      
      
      
      
        Event Streams
      
      
      
      
        Expressions
      
      
      
      
        Layout
      
      
      
      
        Types
      
      
    
  
  
    Triggers
    Triggers enable dynamic updates to data sets or mark items when specific conditions are met. When a trigger expression – typically referencing one or more signals – evaluates to a truthy value, one or more data updates (insert, remove, toggle and/or modify) are applied.

Triggers can either be used to update data objects within a data set, or to update the properties (modify only) of mark items within a mark definition. Please note that triggers are not supported for derived data sets; any triggers defined on a derived data set will have no effect.

Trigger Object Properties


  
    
      Property
      Type
      Description
    
  
  
    
      trigger
      Expression
      Required. An expression defining the trigger condition. When this expression is evaluated and returns a truthy value, the trigger condition is met and data updates are applied.
    
    
      insert
      Expression
      An expression that evaluates to data objects to insert. Insert operations are only applicable to data sets, not marks.
    
    
      remove
      Expression | Boolean
      An expression that indicates which data objects to remove. If boolean true, indicates that all existing data objects should be removed. If an existing data object or array of data objects, those objects are removed. Otherwise, an object-valued expression result is treated as a predicate specification: all data objects with property values matching those of the input object should be removed. Remove operations are only applicable to data sets, not marks.
    
    
      toggle
      Expression
      An expression that indicates which data objects to toggle. The expresion result is treated as a predicate specification: all data objects with property values matching those of the input object should be toggled. Toggled objects are inserted or removed depending on whether they are already in the data set. Toggle operations are only applicable to data sets, not marks.
    
    
      modify
      Expression
      An expression that evaluates to data objects to modify. The expression result should consist of one or more data objects that already exist in the data stream. Modify operations are applicable to both data sets and marks. If modify is specified, the values property must be specified as well.
    
    
      values
      Expression
      An expression that evaluates to an object of name-value pairs, indicating the field values that should be updated for the data objects returned by the modify expression.
    
  


Usage

Update a data set of selected items based on shift-click interactions. The signal shift indicates if the shift key is pressed during a click event, and the signal clicked references a data object corresponding to a clicked mark item. (Note the signal definitions are not shown in these examples.) If a click event occurs and the shift key is not pressed, all selected items are removed. If a mark item is clicked without the shift key, its data object is added to the data set. If a mark item is clicked while the shift key is pressed, its data object is toggled.

"data": [
  ...
  {
    "name": "selected",
    "on": [
      {"trigger": "!shift", "remove": true},
      {"trigger": "!shift && clicked", "insert": "clicked"},
      {"trigger": "shift && clicked", "toggle": "clicked"}
    ]
  }
]


Set the fx and fy properties on mark items referenced by the dragged signal to the current mouse position:

{
  "type": "symbol",
  "from": {"data": "nodes"},
  "encode": {...},
  "on": [
    {
      "trigger": "dragged",
      "modify":  "dragged",
      "values":  "{fx: x(), fy: y()}"
    }
  ]
}\nVega
            
              Vega-Lite
              Altair
              Vega-Lite API\nVega-Lite
              Altair
              Vega-Lite API\nExamples
              Tutorials
              Documentation
              Usage
              About
            
            
              GitHub
              Try Online\nExamples
              Tutorials
              Documentation
              Usage
              About\nGitHub
              Try Online\nDocumentation
      
      
      
      
        Specification
      
      
      
      
        Config
      
      
      
      
        Data
      
      
      
      
        Transforms
      
      
      
      
        Triggers
      
      
      
      
        Projections
      
      
      
      
        Scales
      
      
      
      
        Schemes
      
      
      
      
        Axes
      
      
      
      
        Legends
      
      
      
      
        Title
      
      
      
      
        Marks
      
      
      
      
        Signals
      
      
      
      
        Event Streams
      
      
      
      
        Expressions
      
      
      
      
        Layout
      
      
      
      
        Types
      
      
    
  
  
    Triggers
    Triggers enable dynamic updates to data sets or mark items when specific conditions are met. When a trigger expression – typically referencing one or more signals – evaluates to a truthy value, one or more data updates (insert, remove, toggle and/or modify) are applied.

Triggers can either be used to update data objects within a data set, or to update the properties (modify only) of mark items within a mark definition. Please note that triggers are not supported for derived data sets; any triggers defined on a derived data set will have no effect.

Trigger Object Properties


  
    
      Property
      Type
      Description
    
  
  
    
      trigger
      Expression
      Required. An expression defining the trigger condition. When this expression is evaluated and returns a truthy value, the trigger condition is met and data updates are applied.
    
    
      insert
      Expression
      An expression that evaluates to data objects to insert. Insert operations are only applicable to data sets, not marks.
    
    
      remove
      Expression | Boolean
      An expression that indicates which data objects to remove. If boolean true, indicates that all existing data objects should be removed. If an existing data object or array of data objects, those objects are removed. Otherwise, an object-valued expression result is treated as a predicate specification: all data objects with property values matching those of the input object should be removed. Remove operations are only applicable to data sets, not marks.
    
    
      toggle
      Expression
      An expression that indicates which data objects to toggle. The expresion result is treated as a predicate specification: all data objects with property values matching those of the input object should be toggled. Toggled objects are inserted or removed depending on whether they are already in the data set. Toggle operations are only applicable to data sets, not marks.
    
    
      modify
      Expression
      An expression that evaluates to data objects to modify. The expression result should consist of one or more data objects that already exist in the data stream. Modify operations are applicable to both data sets and marks. If modify is specified, the values property must be specified as well.
    
    
      values
      Expression
      An expression that evaluates to an object of name-value pairs, indicating the field values that should be updated for the data objects returned by the modify expression.
    
  


Usage

Update a data set of selected items based on shift-click interactions. The signal shift indicates if the shift key is pressed during a click event, and the signal clicked references a data object corresponding to a clicked mark item. (Note the signal definitions are not shown in these examples.) If a click event occurs and the shift key is not pressed, all selected items are removed. If a mark item is clicked without the shift key, its data object is added to the data set. If a mark item is clicked while the shift key is pressed, its data object is toggled.

"data": [
  ...
  {
    "name": "selected",
    "on": [
      {"trigger": "!shift", "remove": true},
      {"trigger": "!shift && clicked", "insert": "clicked"},
      {"trigger": "shift && clicked", "toggle": "clicked"}
    ]
  }
]


Set the fx and fy properties on mark items referenced by the dragged signal to the current mouse position:

{
  "type": "symbol",
  "from": {"data": "nodes"},
  "encode": {...},
  "on": [
    {
      "trigger": "dragged",
      "modify":  "dragged",
      "values":  "{fx: x(), fy: y()}"
    }
  ]
}\nTriggers enable dynamic updates to data sets or mark items when specific conditions are met. When a trigger expression – typically referencing one or more signals – evaluates to a truthy value, one or more data updates (insert, remove, toggle and/or modify) are applied.\nTriggers can either be used to update data objects within a data set, or to update the properties (modify only) of mark items within a mark definition. Please note that triggers are not supported for derived data sets; any triggers defined on a derived data set will have no effect.\nTrigger Object Properties\nRequired. An expression defining the trigger condition. When this expression is evaluated and returns a truthy value, the trigger condition is met and data updates are applied.\nAn expression that evaluates to data objects to insert. Insert operations are only applicable to data sets, not marks.\nAn expression that indicates which data objects to remove. If boolean true, indicates that all existing data objects should be removed. If an existing data object or array of data objects, those objects are removed. Otherwise, an object-valued expression result is treated as a predicate specification: all data objects with property values matching those of the input object should be removed. Remove operations are only applicable to data sets, not marks.\nAn expression that indicates which data objects to toggle. The expresion result is treated as a predicate specification: all data objects with property values matching those of the input object should be toggled. Toggled objects are inserted or removed depending on whether they are already in the data set. Toggle operations are only applicable to data sets, not marks.\nAn expression that evaluates to data objects to modify. The expression result should consist of one or more data objects that already exist in the data stream. Modify operations are applicable to both data sets and marks. If modify is specified, the values property must be specified as well.\nAn expression that evaluates to an object of name-value pairs, indicating the field values that should be updated for the data objects returned by the modify expression.\nUpdate a data set of selected items based on shift-click interactions. The signal shift indicates if the shift key is pressed during a click event, and the signal clicked references a data object corresponding to a clicked mark item. (Note the signal definitions are not shown in these examples.) If a click event occurs and the shift key is not pressed, all selected items are removed. If a mark item is clicked without the shift key, its data object is added to the data set. If a mark item is clicked while the shift key is pressed, its data object is toggled.\n"data": [
  ...
  {
    "name": "selected",
    "on": [
      {"trigger": "!shift", "remove": true},
      {"trigger": "!shift && clicked", "insert": "clicked"},
      {"trigger": "shift && clicked", "toggle": "clicked"}
    ]
  }
]\n"data": [
  ...
  {
    "name": "selected",
    "on": [
      {"trigger": "!shift", "remove": true},
      {"trigger": "!shift && clicked", "insert": "clicked"},
      {"trigger": "shift && clicked", "toggle": "clicked"}
    ]
  }
]\nSet the fx and fy properties on mark items referenced by the dragged signal to the current mouse position:\n{
  "type": "symbol",
  "from": {"data": "nodes"},
  "encode": {...},
  "on": [
    {
      "trigger": "dragged",
      "modify":  "dragged",
      "values":  "{fx: x(), fy: y()}"
    }
  ]
}\n{
  "type": "symbol",
  "from": {"data": "nodes"},
  "encode": {...},
  "on": [
    {
      "trigger": "dragged",
      "modify":  "dragged",
      "values":  "{fx: x(), fy: y()}"
    }
  ]
}\n\n\nVega
            
              Vega-Lite
              Altair
              Vega-Lite API
            
          
          
            
              Examples
              Tutorials
              Documentation
              Usage
              About
            
            
              GitHub
              Try Online
            
          
        
      

      
        

  
  
    
      
      
        Documentation
      
      
      
      
        Specification
      
      
      
      
        Config
      
      
      
      
        Data
      
      
      
      
        Transforms
      
      
      
      
        Triggers
      
      
      
      
        Projections
      
      
      
      
        Scales
      
      
      
      
        Schemes
      
      
      
      
        Axes
      
      
      
      
        Legends
      
      
      
      
        Title
      
      
      
      
        Marks
      
      
      
      
        Signals
      
      
      
      
        Event Streams
      
      
      
      
        Expressions
      
      
      
      
        Layout
      
      
      
      
        Types
      
      
    
  
  
    Color Schemes
    Color schemes provide a set of named color palettes for both discrete and continuous color encodings. Vega provides a collection of perceptually-motivated color schemes, many of which were originally created by Cynthia Brewer and the ColorBrewer project, or by Maureen Stone of Tableau Software. To view and set default color schemes, see the Config documentation.

Discrete color schemes may be used directly with scales that have discrete (or discretizing) domains, such as ordinal, quantize, and quantile scales. Continuous color schemes can be used directly with continuous scales (such as linear, log, and sqrt scales), and – by specifying a scheme count property – can also be used to generate discrete color schemes.

Scheme Properties

Properties supported by color scheme definitions. These objects can be assigned to a scale’s range property. If a scale definition includes the property "reverse": true, the color scheme order will be flipped.


  
    
      Property
      Type
      Description
    
  
  
    
      scheme
      String | Color[ ]
      Required. The name of the color scheme to use or an array of color values. See the scheme reference below for named schemes. For Vega 5.0 and higher, if a color array is provided, the colors will be interpolated to form a new scheme; use the scale interpolate property to set the interpolation type (defaults to linear RGB interpolation).
    
    
      count
      Number
      The number of colors to use in the scheme. This property can be useful for scale types such as quantile and quantize, which use the length of the scale range to determine the number of discrete bins for the scale domain.
    
    
      extent
      Number[ ]
      For continuous schemes only, determines the extent of the color range to use. For example [0.2, 1] will rescale the color scheme such that color values in the range [0, 0.2) are excluded from the scheme.  Starting the extent array with the higher number will reverse the scheme order.  For example, [1, 0] is the reverse of [0, 1].
    
  


Registering Additional Schemes

Vega can be extended with additional color schemes using the vega.scheme method. New schemes must be a valid color array or interpolator. For example:

// Register a discrete color scheme named "basic" that can then be used in Vega specs
vega.scheme('basic', ['#f00', '#0f0', '#00f', '#ff0', '#f0f', '#0ff']);


// Register a custom continuous interpolation scheme

// Define an interpolator function that maps from [0,1] to colors
function grey(f) {
  var g = Math.max(0, Math.min(255, Math.round(255 * f))) + '';
  return 'rgb(' + g + ', ' + g + ', ' + g + ')';
}

// Register the interpolator. Now the scheme "mygrey" can be used in Vega specs
vega.scheme("mygrey", grey);


Scheme Reference


  Categorical
  Sequential Single-Hue
  Sequential Multi-Hue
  Diverging
  Cyclical




Categorical Schemes

Categorical color schemes can be used to encode discrete data values, each representing a distinct category.


# accent

  
  
  
  
  
  
  
  




# category10

  
  
  
  
  
  
  
  
  
  




# category20

  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  




# category20b

  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  




# category20c

  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  




#observable10

  
  
  
  
  
  
  
  
  
  




# dark2

  
  
  
  
  
  
  
  




# paired

  
  
  
  
  
  
  
  
  
  
  
  




# pastel1

  
  
  
  
  
  
  
  
  




# pastel2

  
  
  
  
  
  
  
  




# set1

  
  
  
  
  
  
  
  
  




# set2

  
  
  
  
  
  
  
  




# set3

  
  
  
  
  
  
  
  
  
  
  
  




# tableau10

  
  
  
  
  
  
  
  
  
  




# tableau20

  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  



Sequential Single-Hue Schemes

Sequential color schemes can be used to encode quantitative values. These color ramps are designed to encode increasing numeric values. Hover over a scheme and click the “View Discrete” link to toggle display of discretized palettes suitable for quantile, quantize, threshold, or ordinal scales.


# blues View Discrete



  1
  


  2
  
  


  3
  
  
  


  4
  
  
  
  


  5
  
  
  
  
  


  6
  
  
  
  
  
  


  7
  
  
  
  
  
  
  


  8
  
  
  
  
  
  
  
  


  9
  
  
  
  
  
  
  
  
  





# tealblues ≥ 5.0 View Discrete



  1
  


  2
  
  


  3
  
  
  


  4
  
  
  
  


  5
  
  
  
  
  


  6
  
  
  
  
  
  


  7
  
  
  
  
  
  
  


  8
  
  
  
  
  
  
  
  


  9
  
  
  
  
  
  
  
  
  





# teals ≥ 5.0 View Discrete



  1
  


  2
  
  


  3
  
  
  


  4
  
  
  
  


  5
  
  
  
  
  


  6
  
  
  
  
  
  


  7
  
  
  
  
  
  
  


  8
  
  
  
  
  
  
  
  


  9
  
  
  
  
  
  
  
  
  





# greens View Discrete



  1
  


  2
  
  


  3
  
  
  


  4
  
  
  
  


  5
  
  
  
  
  


  6
  
  
  
  
  
  


  7
  
  
  
  
  
  
  


  8
  
  
  
  
  
  
  
  


  9
  
  
  
  
  
  
  
  
  





# browns ≥ 5.0 View Discrete



  1
  


  2
  
  


  3
  
  
  


  4
  
  
  
  


  5
  
  
  
  
  


  6
  
  
  
  
  
  


  7
  
  
  
  
  
  
  


  8
  
  
  
  
  
  
  
  


  9
  
  
  
  
  
  
  
  
  





# oranges View Discrete



  1
  


  2
  
  


  3
  
  
  


  4
  
  
  
  


  5
  
  
  
  
  


  6
  
  
  
  
  
  


  7
  
  
  
  
  
  
  


  8
  
  
  
  
  
  
  
  


  9
  
  
  
  
  
  
  
  
  





# reds View Discrete



  1
  


  2
  
  


  3
  
  
  


  4
  
  
  
  


  5
  
  
  
  
  


  6
  
  
  
  
  
  


  7
  
  
  
  
  
  
  


  8
  
  
  
  
  
  
  
  


  9
  
  
  
  
  
  
  
  
  





# purples View Discrete



  1
  


  2
  
  


  3
  
  
  


  4
  
  
  
  


  5
  
  
  
  
  


  6
  
  
  
  
  
  


  7
  
  
  
  
  
  
  


  8
  
  
  
  
  
  
  
  


  9
  
  
  
  
  
  
  
  
  





# warmgreys ≥ 5.0 View Discrete



  1
  


  2
  
  


  3
  
  
  


  4
  
  
  
  


  5
  
  
  
  
  


  6
  
  
  
  
  
  


  7
  
  
  
  
  
  
  


  8
  
  
  
  
  
  
  
  


  9
  
  
  
  
  
  
  
  
  





# greys View Discrete



  1
  


  2
  
  


  3
  
  
  


  4
  
  
  
  


  5
  
  
  
  
  


  6
  
  
  
  
  
  


  7
  
  
  
  
  
  
  


  8
  
  
  
  
  
  
  
  


  9
  
  
  
  
  
  
  
  
  




Sequential Multi-Hue Schemes

Sequential color schemes can be used to encode quantitative values. These color ramps are designed to encode increasing numeric values, but use additional hues for more color discrimination, which may be useful for visualizations such as heatmaps. However, beware that using multiple hues may cause viewers to inaccurately see the data range as grouped into color-coded clusters. Hover over a scheme and click the “View Discrete” link to toggle display of discretized palettes suitable for quantile, quantize, threshold, or ordinal scales.


# viridis View Discrete



  1
  


  2
  
  


  3
  
  
  


  4
  
  
  
  


  5
  
  
  
  
  


  6
  
  
  
  
  
  


  7
  
  
  
  
  
  
  


  8
  
  
  
  
  
  
  
  


  9
  
  
  
  
  
  
  
  
  





# magma View Discrete



  1
  


  2
  
  


  3
  
  
  


  4
  
  
  
  


  5
  
  
  
  
  


  6
  
  
  
  
  
  


  7
  
  
  
  
  
  
  


  8
  
  
  
  
  
  
  
  


  9
  
  
  
  
  
  
  
  
  





# inferno View Discrete



  1
  


  2
  
  


  3
  
  
  


  4
  
  
  
  


  5
  
  
  
  
  


  6
  
  
  
  
  
  


  7
  
  
  
  
  
  
  


  8
  
  
  
  
  
  
  
  


  9
  
  
  
  
  
  
  
  
  





# plasma View Discrete



  1
  


  2
  
  


  3
  
  
  


  4
  
  
  
  


  5
  
  
  
  
  


  6
  
  
  
  
  
  


  7
  
  
  
  
  
  
  


  8
  
  
  
  
  
  
  
  


  9
  
  
  
  
  
  
  
  
  





# cividis ≥ 5.15 View Discrete



  1
  


  2
  
  


  3
  
  
  


  4
  
  
  
  


  5
  
  
  
  
  


  6
  
  
  
  
  
  


  7
  
  
  
  
  
  
  


  8
  
  
  
  
  
  
  
  


  9
  
  
  
  
  
  
  
  
  





# turbo ≥ 5.15 View Discrete



  1
  


  2
  
  


  3
  
  
  


  4
  
  
  
  


  5
  
  
  
  
  


  6
  
  
  
  
  
  


  7
  
  
  
  
  
  
  


  8
  
  
  
  
  
  
  
  


  9
  
  
  
  
  
  
  
  
  





# bluegreen View Discrete



  1
  


  2
  
  


  3
  
  
  


  4
  
  
  
  


  5
  
  
  
  
  


  6
  
  
  
  
  
  


  7
  
  
  
  
  
  
  


  8
  
  
  
  
  
  
  
  


  9
  
  
  
  
  
  
  
  
  





# bluepurple View Discrete



  1
  


  2
  
  


  3
  
  
  


  4
  
  
  
  


  5
  
  
  
  
  


  6
  
  
  
  
  
  


  7
  
  
  
  
  
  
  


  8
  
  
  
  
  
  
  
  


  9
  
  
  
  
  
  
  
  
  





# goldgreen ≥ 5.0 View Discrete



  1
  


  2
  
  


  3
  
  
  


  4
  
  
  
  


  5
  
  
  
  
  


  6
  
  
  
  
  
  


  7
  
  
  
  
  
  
  


  8
  
  
  
  
  
  
  
  


  9
  
  
  
  
  
  
  
  
  





# goldorange ≥ 5.0 View Discrete



  1
  


  2
  
  


  3
  
  
  


  4
  
  
  
  


  5
  
  
  
  
  


  6
  
  
  
  
  
  


  7
  
  
  
  
  
  
  


  8
  
  
  
  
  
  
  
  


  9
  
  
  
  
  
  
  
  
  





# goldred ≥ 5.0 View Discrete



  1
  


  2
  
  


  3
  
  
  


  4
  
  
  
  


  5
  
  
  
  
  


  6
  
  
  
  
  
  


  7
  
  
  
  
  
  
  


  8
  
  
  
  
  
  
  
  


  9
  
  
  
  
  
  
  
  
  





# greenblue View Discrete



  1
  


  2
  
  


  3
  
  
  


  4
  
  
  
  


  5
  
  
  
  
  


  6
  
  
  
  
  
  


  7
  
  
  
  
  
  
  


  8
  
  
  
  
  
  
  
  


  9
  
  
  
  
  
  
  
  
  





# orangered View Discrete



  1
  


  2
  
  


  3
  
  
  


  4
  
  
  
  


  5
  
  
  
  
  


  6
  
  
  
  
  
  


  7
  
  
  
  
  
  
  


  8
  
  
  
  
  
  
  
  


  9
  
  
  
  
  
  
  
  
  





# purplebluegreen View Discrete



  1
  


  2
  
  


  3
  
  
  


  4
  
  
  
  


  5
  
  
  
  
  


  6
  
  
  
  
  
  


  7
  
  
  
  
  
  
  


  8
  
  
  
  
  
  
  
  


  9
  
  
  
  
  
  
  
  
  





# purpleblue View Discrete



  1
  


  2
  
  


  3
  
  
  


  4
  
  
  
  


  5
  
  
  
  
  


  6
  
  
  
  
  
  


  7
  
  
  
  
  
  
  


  8
  
  
  
  
  
  
  
  


  9
  
  
  
  
  
  
  
  
  





# purplered View Discrete



  1
  


  2
  
  


  3
  
  
  


  4
  
  
  
  


  5
  
  
  
  
  


  6
  
  
  
  
  
  


  7
  
  
  
  
  
  
  


  8
  
  
  
  
  
  
  
  


  9
  
  
  
  
  
  
  
  
  





# redpurple View Discrete



  1
  


  2
  
  


  3
  
  
  


  4
  
  
  
  


  5
  
  
  
  
  


  6
  
  
  
  
  
  


  7
  
  
  
  
  
  
  


  8
  
  
  
  
  
  
  
  


  9
  
  
  
  
  
  
  
  
  





# yellowgreenblue View Discrete



  1
  


  2
  
  


  3
  
  
  


  4
  
  
  
  


  5
  
  
  
  
  


  6
  
  
  
  
  
  


  7
  
  
  
  
  
  
  


  8
  
  
  
  
  
  
  
  


  9
  
  
  
  
  
  
  
  
  





# yellowgreen View Discrete



  1
  


  2
  
  


  3
  
  
  


  4
  
  
  
  


  5
  
  
  
  
  


  6
  
  
  
  
  
  


  7
  
  
  
  
  
  
  


  8
  
  
  
  
  
  
  
  


  9
  
  
  
  
  
  
  
  
  





# yelloworangebrown View Discrete



  1
  


  2
  
  


  3
  
  
  


  4
  
  
  
  


  5
  
  
  
  
  


  6
  
  
  
  
  
  


  7
  
  
  
  
  
  
  


  8
  
  
  
  
  
  
  
  


  9
  
  
  
  
  
  
  
  
  





# yelloworangered View Discrete



  1
  


  2
  
  


  3
  
  
  


  4
  
  
  
  


  5
  
  
  
  
  


  6
  
  
  
  
  
  


  7
  
  
  
  
  
  
  


  8
  
  
  
  
  
  
  
  


  9
  
  
  
  
  
  
  
  
  




For Dark Backgrounds


# darkblue ≥ 5.0 View Discrete



  1
  


  2
  
  


  3
  
  
  


  4
  
  
  
  


  5
  
  
  
  
  


  6
  
  
  
  
  
  


  7
  
  
  
  
  
  
  


  8
  
  
  
  
  
  
  
  


  9
  
  
  
  
  
  
  
  
  





# darkgold ≥ 5.0 View Discrete



  1
  


  2
  
  


  3
  
  
  


  4
  
  
  
  


  5
  
  
  
  
  


  6
  
  
  
  
  
  


  7
  
  
  
  
  
  
  


  8
  
  
  
  
  
  
  
  


  9
  
  
  
  
  
  
  
  
  





# darkgreen ≥ 5.0 View Discrete



  1
  


  2
  
  


  3
  
  
  


  4
  
  
  
  


  5
  
  
  
  
  


  6
  
  
  
  
  
  


  7
  
  
  
  
  
  
  


  8
  
  
  
  
  
  
  
  


  9
  
  
  
  
  
  
  
  
  





# darkmulti ≥ 5.0 View Discrete



  1
  


  2
  
  


  3
  
  
  


  4
  
  
  
  


  5
  
  
  
  
  


  6
  
  
  
  
  
  


  7
  
  
  
  
  
  
  


  8
  
  
  
  
  
  
  
  


  9
  
  
  
  
  
  
  
  
  





# darkred ≥ 5.0 View Discrete



  1
  


  2
  
  


  3
  
  
  


  4
  
  
  
  


  5
  
  
  
  
  


  6
  
  
  
  
  
  


  7
  
  
  
  
  
  
  


  8
  
  
  
  
  
  
  
  


  9
  
  
  
  
  
  
  
  
  




For Light Backgrounds


# lightgreyred ≥ 5.0 View Discrete



  1
  


  2
  
  


  3
  
  
  


  4
  
  
  
  


  5
  
  
  
  
  


  6
  
  
  
  
  
  


  7
  
  
  
  
  
  
  


  8
  
  
  
  
  
  
  
  


  9
  
  
  
  
  
  
  
  
  





# lightgreyteal ≥ 5.0 View Discrete



  1
  


  2
  
  


  3
  
  
  


  4
  
  
  
  


  5
  
  
  
  
  


  6
  
  
  
  
  
  


  7
  
  
  
  
  
  
  


  8
  
  
  
  
  
  
  
  


  9
  
  
  
  
  
  
  
  
  





# lightmulti ≥ 5.0 View Discrete



  1
  


  2
  
  


  3
  
  
  


  4
  
  
  
  


  5
  
  
  
  
  


  6
  
  
  
  
  
  


  7
  
  
  
  
  
  
  


  8
  
  
  
  
  
  
  
  


  9
  
  
  
  
  
  
  
  
  





# lightorange ≥ 5.0 View Discrete



  1
  


  2
  
  


  3
  
  
  


  4
  
  
  
  


  5
  
  
  
  
  


  6
  
  
  
  
  
  


  7
  
  
  
  
  
  
  


  8
  
  
  
  
  
  
  
  


  9
  
  
  
  
  
  
  
  
  





# lighttealblue ≥ 5.0 View Discrete



  1
  


  2
  
  


  3
  
  
  


  4
  
  
  
  


  5
  
  
  
  
  


  6
  
  
  
  
  
  


  7
  
  
  
  
  
  
  


  8
  
  
  
  
  
  
  
  


  9
  
  
  
  
  
  
  
  
  




Diverging Schemes

Diverging color schemes can be used to encode quantitative values with a meaningful mid-point, such as zero or the average value. Color ramps with different hues diverge with increasing saturation to highlight the values below and above the mid-point. Hover over a scheme and click the “View Discrete” link to toggle display of discretized palettes suitable for quantile, quantize, threshold, or ordinal scales.


# blueorange View Discrete



  1
     
  


  2
    
  
  
  


  3
    
  
  
  


  4
   
  
  
  
  
  


  5
   
  
  
  
  
  


  6
  
  
  
  
  
  
  
  


  7
  
  
  
  
  
  
  
  


  8
  
  
  
  
  
  
  
  
  


  9
  
  
  
  
  
  
  
  
  





# brownbluegreen View Discrete



  1
     
  


  2
    
  
  
  


  3
    
  
  
  


  4
   
  
  
  
  
  


  5
   
  
  
  
  
  


  6
  
  
  
  
  
  
  
  


  7
  
  
  
  
  
  
  
  


  8
  
  
  
  
  
  
  
  
  


  9
  
  
  
  
  
  
  
  
  





# purplegreen View Discrete



  1
     
  


  2
    
  
  
  


  3
    
  
  
  


  4
   
  
  
  
  
  


  5
   
  
  
  
  
  


  6
  
  
  
  
  
  
  
  


  7
  
  
  
  
  
  
  
  


  8
  
  
  
  
  
  
  
  
  


  9
  
  
  
  
  
  
  
  
  





# pinkyellowgreen View Discrete



  1
     
  


  2
    
  
  
  


  3
    
  
  
  


  4
   
  
  
  
  
  


  5
   
  
  
  
  
  


  6
  
  
  
  
  
  
  
  


  7
  
  
  
  
  
  
  
  


  8
  
  
  
  
  
  
  
  
  


  9
  
  
  
  
  
  
  
  
  





# purpleorange View Discrete



  1
     
  


  2
    
  
  
  


  3
    
  
  
  


  4
   
  
  
  
  
  


  5
   
  
  
  
  
  


  6
  
  
  
  
  
  
  
  


  7
  
  
  
  
  
  
  
  


  8
  
  
  
  
  
  
  
  
  


  9
  
  
  
  
  
  
  
  
  





# redblue View Discrete



  1
     
  


  2
    
  
  
  


  3
    
  
  
  


  4
   
  
  
  
  
  


  5
   
  
  
  
  
  


  6
  
  
  
  
  
  
  
  


  7
  
  
  
  
  
  
  
  


  8
  
  
  
  
  
  
  
  
  


  9
  
  
  
  
  
  
  
  
  





# redgrey View Discrete



  1
     
  


  2
    
  
  
  


  3
    
  
  
  


  4
   
  
  
  
  
  


  5
   
  
  
  
  
  


  6
  
  
  
  
  
  
  
  


  7
  
  
  
  
  
  
  
  


  8
  
  
  
  
  
  
  
  
  


  9
  
  
  
  
  
  
  
  
  





# redyellowblue View Discrete



  1
     
  


  2
    
  
  
  


  3
    
  
  
  


  4
   
  
  
  
  
  


  5
   
  
  
  
  
  


  6
  
  
  
  
  
  
  
  


  7
  
  
  
  
  
  
  
  


  8
  
  
  
  
  
  
  
  
  


  9
  
  
  
  
  
  
  
  
  





# redyellowgreen View Discrete



  1
     
  


  2
    
  
  
  


  3
    
  
  
  


  4
   
  
  
  
  
  


  5
   
  
  
  
  
  


  6
  
  
  
  
  
  
  
  


  7
  
  
  
  
  
  
  
  


  8
  
  
  
  
  
  
  
  
  


  9
  
  
  
  
  
  
  
  
  





# spectral View Discrete



  1
     
  


  2
    
  
  
  


  3
    
  
  
  


  4
   
  
  
  
  
  


  5
   
  
  
  
  
  


  6
  
  
  
  
  
  
  
  


  7
  
  
  
  
  
  
  
  


  8
  
  
  
  
  
  
  
  
  


  9
  
  
  
  
  
  
  
  
  




Cyclical Schemes

Cyclical color schemes may be used to highlight periodic patterns in continuous data. However, these schemes are not well suited to accurately convey value differences.


# rainbow ≥ 4.0




# sinebow ≥ 4.0\nVega
            
              Vega-Lite
              Altair
              Vega-Lite API\nVega-Lite
              Altair
              Vega-Lite API\nExamples
              Tutorials
              Documentation
              Usage
              About
            
            
              GitHub
              Try Online\nExamples
              Tutorials
              Documentation
              Usage
              About\nGitHub
              Try Online\nDocumentation
      
      
      
      
        Specification
      
      
      
      
        Config
      
      
      
      
        Data
      
      
      
      
        Transforms
      
      
      
      
        Triggers
      
      
      
      
        Projections
      
      
      
      
        Scales
      
      
      
      
        Schemes
      
      
      
      
        Axes
      
      
      
      
        Legends
      
      
      
      
        Title
      
      
      
      
        Marks
      
      
      
      
        Signals
      
      
      
      
        Event Streams
      
      
      
      
        Expressions
      
      
      
      
        Layout
      
      
      
      
        Types
      
      
    
  
  
    Color Schemes
    Color schemes provide a set of named color palettes for both discrete and continuous color encodings. Vega provides a collection of perceptually-motivated color schemes, many of which were originally created by Cynthia Brewer and the ColorBrewer project, or by Maureen Stone of Tableau Software. To view and set default color schemes, see the Config documentation.

Discrete color schemes may be used directly with scales that have discrete (or discretizing) domains, such as ordinal, quantize, and quantile scales. Continuous color schemes can be used directly with continuous scales (such as linear, log, and sqrt scales), and – by specifying a scheme count property – can also be used to generate discrete color schemes.

Scheme Properties

Properties supported by color scheme definitions. These objects can be assigned to a scale’s range property. If a scale definition includes the property "reverse": true, the color scheme order will be flipped.


  
    
      Property
      Type
      Description
    
  
  
    
      scheme
      String | Color[ ]
      Required. The name of the color scheme to use or an array of color values. See the scheme reference below for named schemes. For Vega 5.0 and higher, if a color array is provided, the colors will be interpolated to form a new scheme; use the scale interpolate property to set the interpolation type (defaults to linear RGB interpolation).
    
    
      count
      Number
      The number of colors to use in the scheme. This property can be useful for scale types such as quantile and quantize, which use the length of the scale range to determine the number of discrete bins for the scale domain.
    
    
      extent
      Number[ ]
      For continuous schemes only, determines the extent of the color range to use. For example [0.2, 1] will rescale the color scheme such that color values in the range [0, 0.2) are excluded from the scheme.  Starting the extent array with the higher number will reverse the scheme order.  For example, [1, 0] is the reverse of [0, 1].
    
  


Registering Additional Schemes

Vega can be extended with additional color schemes using the vega.scheme method. New schemes must be a valid color array or interpolator. For example:

// Register a discrete color scheme named "basic" that can then be used in Vega specs
vega.scheme('basic', ['#f00', '#0f0', '#00f', '#ff0', '#f0f', '#0ff']);


// Register a custom continuous interpolation scheme

// Define an interpolator function that maps from [0,1] to colors
function grey(f) {
  var g = Math.max(0, Math.min(255, Math.round(255 * f))) + '';
  return 'rgb(' + g + ', ' + g + ', ' + g + ')';
}

// Register the interpolator. Now the scheme "mygrey" can be used in Vega specs
vega.scheme("mygrey", grey);


Scheme Reference


  Categorical
  Sequential Single-Hue
  Sequential Multi-Hue
  Diverging
  Cyclical




Categorical Schemes

Categorical color schemes can be used to encode discrete data values, each representing a distinct category.


# accent

  
  
  
  
  
  
  
  




# category10

  
  
  
  
  
  
  
  
  
  




# category20

  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  




# category20b

  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  




# category20c

  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  




#observable10

  
  
  
  
  
  
  
  
  
  




# dark2

  
  
  
  
  
  
  
  




# paired

  
  
  
  
  
  
  
  
  
  
  
  




# pastel1

  
  
  
  
  
  
  
  
  




# pastel2

  
  
  
  
  
  
  
  




# set1

  
  
  
  
  
  
  
  
  




# set2

  
  
  
  
  
  
  
  




# set3

  
  
  
  
  
  
  
  
  
  
  
  




# tableau10

  
  
  
  
  
  
  
  
  
  




# tableau20

  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  



Sequential Single-Hue Schemes

Sequential color schemes can be used to encode quantitative values. These color ramps are designed to encode increasing numeric values. Hover over a scheme and click the “View Discrete” link to toggle display of discretized palettes suitable for quantile, quantize, threshold, or ordinal scales.


# blues View Discrete



  1
  


  2
  
  


  3
  
  
  


  4
  
  
  
  


  5
  
  
  
  
  


  6
  
  
  
  
  
  


  7
  
  
  
  
  
  
  


  8
  
  
  
  
  
  
  
  


  9
  
  
  
  
  
  
  
  
  





# tealblues ≥ 5.0 View Discrete



  1
  


  2
  
  


  3
  
  
  


  4
  
  
  
  


  5
  
  
  
  
  


  6
  
  
  
  
  
  


  7
  
  
  
  
  
  
  


  8
  
  
  
  
  
  
  
  


  9
  
  
  
  
  
  
  
  
  





# teals ≥ 5.0 View Discrete



  1
  


  2
  
  


  3
  
  
  


  4
  
  
  
  


  5
  
  
  
  
  


  6
  
  
  
  
  
  


  7
  
  
  
  
  
  
  


  8
  
  
  
  
  
  
  
  


  9
  
  
  
  
  
  
  
  
  





# greens View Discrete



  1
  


  2
  
  


  3
  
  
  


  4
  
  
  
  


  5
  
  
  
  
  


  6
  
  
  
  
  
  


  7
  
  
  
  
  
  
  


  8
  
  
  
  
  
  
  
  


  9
  
  
  
  
  
  
  
  
  





# browns ≥ 5.0 View Discrete



  1
  


  2
  
  


  3
  
  
  


  4
  
  
  
  


  5
  
  
  
  
  


  6
  
  
  
  
  
  


  7
  
  
  
  
  
  
  


  8
  
  
  
  
  
  
  
  


  9
  
  
  
  
  
  
  
  
  





# oranges View Discrete



  1
  


  2
  
  


  3
  
  
  


  4
  
  
  
  


  5
  
  
  
  
  


  6
  
  
  
  
  
  


  7
  
  
  
  
  
  
  


  8
  
  
  
  
  
  
  
  


  9
  
  
  
  
  
  
  
  
  





# reds View Discrete



  1
  


  2
  
  


  3
  
  
  


  4
  
  
  
  


  5
  
  
  
  
  


  6
  
  
  
  
  
  


  7
  
  
  
  
  
  
  


  8
  
  
  
  
  
  
  
  


  9
  
  
  
  
  
  
  
  
  





# purples View Discrete



  1
  


  2
  
  


  3
  
  
  


  4
  
  
  
  


  5
  
  
  
  
  


  6
  
  
  
  
  
  


  7
  
  
  
  
  
  
  


  8
  
  
  
  
  
  
  
  


  9
  
  
  
  
  
  
  
  
  





# warmgreys ≥ 5.0 View Discrete



  1
  


  2
  
  


  3
  
  
  


  4
  
  
  
  


  5
  
  
  
  
  


  6
  
  
  
  
  
  


  7
  
  
  
  
  
  
  


  8
  
  
  
  
  
  
  
  


  9
  
  
  
  
  
  
  
  
  





# greys View Discrete



  1
  


  2
  
  


  3
  
  
  


  4
  
  
  
  


  5
  
  
  
  
  


  6
  
  
  
  
  
  


  7
  
  
  
  
  
  
  


  8
  
  
  
  
  
  
  
  


  9
  
  
  
  
  
  
  
  
  




Sequential Multi-Hue Schemes

Sequential color schemes can be used to encode quantitative values. These color ramps are designed to encode increasing numeric values, but use additional hues for more color discrimination, which may be useful for visualizations such as heatmaps. However, beware that using multiple hues may cause viewers to inaccurately see the data range as grouped into color-coded clusters. Hover over a scheme and click the “View Discrete” link to toggle display of discretized palettes suitable for quantile, quantize, threshold, or ordinal scales.


# viridis View Discrete



  1
  


  2
  
  


  3
  
  
  


  4
  
  
  
  


  5
  
  
  
  
  


  6
  
  
  
  
  
  


  7
  
  
  
  
  
  
  


  8
  
  
  
  
  
  
  
  


  9
  
  
  
  
  
  
  
  
  





# magma View Discrete



  1
  


  2
  
  


  3
  
  
  


  4
  
  
  
  


  5
  
  
  
  
  


  6
  
  
  
  
  
  


  7
  
  
  
  
  
  
  


  8
  
  
  
  
  
  
  
  


  9
  
  
  
  
  
  
  
  
  





# inferno View Discrete



  1
  


  2
  
  


  3
  
  
  


  4
  
  
  
  


  5
  
  
  
  
  


  6
  
  
  
  
  
  


  7
  
  
  
  
  
  
  


  8
  
  
  
  
  
  
  
  


  9
  
  
  
  
  
  
  
  
  





# plasma View Discrete



  1
  


  2
  
  


  3
  
  
  


  4
  
  
  
  


  5
  
  
  
  
  


  6
  
  
  
  
  
  


  7
  
  
  
  
  
  
  


  8
  
  
  
  
  
  
  
  


  9
  
  
  
  
  
  
  
  
  





# cividis ≥ 5.15 View Discrete



  1
  


  2
  
  


  3
  
  
  


  4
  
  
  
  


  5
  
  
  
  
  


  6
  
  
  
  
  
  


  7
  
  
  
  
  
  
  


  8
  
  
  
  
  
  
  
  


  9
  
  
  
  
  
  
  
  
  





# turbo ≥ 5.15 View Discrete



  1
  


  2
  
  


  3
  
  
  


  4
  
  
  
  


  5
  
  
  
  
  


  6
  
  
  
  
  
  


  7
  
  
  
  
  
  
  


  8
  
  
  
  
  
  
  
  


  9
  
  
  
  
  
  
  
  
  





# bluegreen View Discrete



  1
  


  2
  
  


  3
  
  
  


  4
  
  
  
  


  5
  
  
  
  
  


  6
  
  
  
  
  
  


  7
  
  
  
  
  
  
  


  8
  
  
  
  
  
  
  
  


  9
  
  
  
  
  
  
  
  
  





# bluepurple View Discrete



  1
  


  2
  
  


  3
  
  
  


  4
  
  
  
  


  5
  
  
  
  
  


  6
  
  
  
  
  
  


  7
  
  
  
  
  
  
  


  8
  
  
  
  
  
  
  
  


  9
  
  
  
  
  
  
  
  
  





# goldgreen ≥ 5.0 View Discrete



  1
  


  2
  
  


  3
  
  
  


  4
  
  
  
  


  5
  
  
  
  
  


  6
  
  
  
  
  
  


  7
  
  
  
  
  
  
  


  8
  
  
  
  
  
  
  
  


  9
  
  
  
  
  
  
  
  
  





# goldorange ≥ 5.0 View Discrete



  1
  


  2
  
  


  3
  
  
  


  4
  
  
  
  


  5
  
  
  
  
  


  6
  
  
  
  
  
  


  7
  
  
  
  
  
  
  


  8
  
  
  
  
  
  
  
  


  9
  
  
  
  
  
  
  
  
  





# goldred ≥ 5.0 View Discrete



  1
  


  2
  
  


  3
  
  
  


  4
  
  
  
  


  5
  
  
  
  
  


  6
  
  
  
  
  
  


  7
  
  
  
  
  
  
  


  8
  
  
  
  
  
  
  
  


  9
  
  
  
  
  
  
  
  
  





# greenblue View Discrete



  1
  


  2
  
  


  3
  
  
  


  4
  
  
  
  


  5
  
  
  
  
  


  6
  
  
  
  
  
  


  7
  
  
  
  
  
  
  


  8
  
  
  
  
  
  
  
  


  9
  
  
  
  
  
  
  
  
  





# orangered View Discrete



  1
  


  2
  
  


  3
  
  
  


  4
  
  
  
  


  5
  
  
  
  
  


  6
  
  
  
  
  
  


  7
  
  
  
  
  
  
  


  8
  
  
  
  
  
  
  
  


  9
  
  
  
  
  
  
  
  
  





# purplebluegreen View Discrete



  1
  


  2
  
  


  3
  
  
  


  4
  
  
  
  


  5
  
  
  
  
  


  6
  
  
  
  
  
  


  7
  
  
  
  
  
  
  


  8
  
  
  
  
  
  
  
  


  9
  
  
  
  
  
  
  
  
  





# purpleblue View Discrete



  1
  


  2
  
  


  3
  
  
  


  4
  
  
  
  


  5
  
  
  
  
  


  6
  
  
  
  
  
  


  7
  
  
  
  
  
  
  


  8
  
  
  
  
  
  
  
  


  9
  
  
  
  
  
  
  
  
  





# purplered View Discrete



  1
  


  2
  
  


  3
  
  
  


  4
  
  
  
  


  5
  
  
  
  
  


  6
  
  
  
  
  
  


  7
  
  
  
  
  
  
  


  8
  
  
  
  
  
  
  
  


  9
  
  
  
  
  
  
  
  
  





# redpurple View Discrete



  1
  


  2
  
  


  3
  
  
  


  4
  
  
  
  


  5
  
  
  
  
  


  6
  
  
  
  
  
  


  7
  
  
  
  
  
  
  


  8
  
  
  
  
  
  
  
  


  9
  
  
  
  
  
  
  
  
  





# yellowgreenblue View Discrete



  1
  


  2
  
  


  3
  
  
  


  4
  
  
  
  


  5
  
  
  
  
  


  6
  
  
  
  
  
  


  7
  
  
  
  
  
  
  


  8
  
  
  
  
  
  
  
  


  9
  
  
  
  
  
  
  
  
  





# yellowgreen View Discrete



  1
  


  2
  
  


  3
  
  
  


  4
  
  
  
  


  5
  
  
  
  
  


  6
  
  
  
  
  
  


  7
  
  
  
  
  
  
  


  8
  
  
  
  
  
  
  
  


  9
  
  
  
  
  
  
  
  
  





# yelloworangebrown View Discrete



  1
  


  2
  
  


  3
  
  
  


  4
  
  
  
  


  5
  
  
  
  
  


  6
  
  
  
  
  
  


  7
  
  
  
  
  
  
  


  8
  
  
  
  
  
  
  
  


  9
  
  
  
  
  
  
  
  
  





# yelloworangered View Discrete



  1
  


  2
  
  


  3
  
  
  


  4
  
  
  
  


  5
  
  
  
  
  


  6
  
  
  
  
  
  


  7
  
  
  
  
  
  
  


  8
  
  
  
  
  
  
  
  


  9
  
  
  
  
  
  
  
  
  




For Dark Backgrounds


# darkblue ≥ 5.0 View Discrete



  1
  


  2
  
  


  3
  
  
  


  4
  
  
  
  


  5
  
  
  
  
  


  6
  
  
  
  
  
  


  7
  
  
  
  
  
  
  


  8
  
  
  
  
  
  
  
  


  9
  
  
  
  
  
  
  
  
  





# darkgold ≥ 5.0 View Discrete



  1
  


  2
  
  


  3
  
  
  


  4
  
  
  
  


  5
  
  
  
  
  


  6
  
  
  
  
  
  


  7
  
  
  
  
  
  
  


  8
  
  
  
  
  
  
  
  


  9
  
  
  
  
  
  
  
  
  





# darkgreen ≥ 5.0 View Discrete



  1
  


  2
  
  


  3
  
  
  


  4
  
  
  
  


  5
  
  
  
  
  


  6
  
  
  
  
  
  


  7
  
  
  
  
  
  
  


  8
  
  
  
  
  
  
  
  


  9
  
  
  
  
  
  
  
  
  





# darkmulti ≥ 5.0 View Discrete



  1
  


  2
  
  


  3
  
  
  


  4
  
  
  
  


  5
  
  
  
  
  


  6
  
  
  
  
  
  


  7
  
  
  
  
  
  
  


  8
  
  
  
  
  
  
  
  


  9
  
  
  
  
  
  
  
  
  





# darkred ≥ 5.0 View Discrete



  1
  


  2
  
  


  3
  
  
  


  4
  
  
  
  


  5
  
  
  
  
  


  6
  
  
  
  
  
  


  7
  
  
  
  
  
  
  


  8
  
  
  
  
  
  
  
  


  9
  
  
  
  
  
  
  
  
  




For Light Backgrounds


# lightgreyred ≥ 5.0 View Discrete



  1
  


  2
  
  


  3
  
  
  


  4
  
  
  
  


  5
  
  
  
  
  


  6
  
  
  
  
  
  


  7
  
  
  
  
  
  
  


  8
  
  
  
  
  
  
  
  


  9
  
  
  
  
  
  
  
  
  





# lightgreyteal ≥ 5.0 View Discrete



  1
  


  2
  
  


  3
  
  
  


  4
  
  
  
  


  5
  
  
  
  
  


  6
  
  
  
  
  
  


  7
  
  
  
  
  
  
  


  8
  
  
  
  
  
  
  
  


  9
  
  
  
  
  
  
  
  
  





# lightmulti ≥ 5.0 View Discrete



  1
  


  2
  
  


  3
  
  
  


  4
  
  
  
  


  5
  
  
  
  
  


  6
  
  
  
  
  
  


  7
  
  
  
  
  
  
  


  8
  
  
  
  
  
  
  
  


  9
  
  
  
  
  
  
  
  
  





# lightorange ≥ 5.0 View Discrete



  1
  


  2
  
  


  3
  
  
  


  4
  
  
  
  


  5
  
  
  
  
  


  6
  
  
  
  
  
  


  7
  
  
  
  
  
  
  


  8
  
  
  
  
  
  
  
  


  9
  
  
  
  
  
  
  
  
  





# lighttealblue ≥ 5.0 View Discrete



  1
  


  2
  
  


  3
  
  
  


  4
  
  
  
  


  5
  
  
  
  
  


  6
  
  
  
  
  
  


  7
  
  
  
  
  
  
  


  8
  
  
  
  
  
  
  
  


  9
  
  
  
  
  
  
  
  
  




Diverging Schemes

Diverging color schemes can be used to encode quantitative values with a meaningful mid-point, such as zero or the average value. Color ramps with different hues diverge with increasing saturation to highlight the values below and above the mid-point. Hover over a scheme and click the “View Discrete” link to toggle display of discretized palettes suitable for quantile, quantize, threshold, or ordinal scales.


# blueorange View Discrete



  1
     
  


  2
    
  
  
  


  3
    
  
  
  


  4
   
  
  
  
  
  


  5
   
  
  
  
  
  


  6
  
  
  
  
  
  
  
  


  7
  
  
  
  
  
  
  
  


  8
  
  
  
  
  
  
  
  
  


  9
  
  
  
  
  
  
  
  
  





# brownbluegreen View Discrete



  1
     
  


  2
    
  
  
  


  3
    
  
  
  


  4
   
  
  
  
  
  


  5
   
  
  
  
  
  


  6
  
  
  
  
  
  
  
  


  7
  
  
  
  
  
  
  
  


  8
  
  
  
  
  
  
  
  
  


  9
  
  
  
  
  
  
  
  
  





# purplegreen View Discrete



  1
     
  


  2
    
  
  
  


  3
    
  
  
  


  4
   
  
  
  
  
  


  5
   
  
  
  
  
  


  6
  
  
  
  
  
  
  
  


  7
  
  
  
  
  
  
  
  


  8
  
  
  
  
  
  
  
  
  


  9
  
  
  
  
  
  
  
  
  





# pinkyellowgreen View Discrete



  1
     
  


  2
    
  
  
  


  3
    
  
  
  


  4
   
  
  
  
  
  


  5
   
  
  
  
  
  


  6
  
  
  
  
  
  
  
  


  7
  
  
  
  
  
  
  
  


  8
  
  
  
  
  
  
  
  
  


  9
  
  
  
  
  
  
  
  
  





# purpleorange View Discrete



  1
     
  


  2
    
  
  
  


  3
    
  
  
  


  4
   
  
  
  
  
  


  5
   
  
  
  
  
  


  6
  
  
  
  
  
  
  
  


  7
  
  
  
  
  
  
  
  


  8
  
  
  
  
  
  
  
  
  


  9
  
  
  
  
  
  
  
  
  





# redblue View Discrete



  1
     
  


  2
    
  
  
  


  3
    
  
  
  


  4
   
  
  
  
  
  


  5
   
  
  
  
  
  


  6
  
  
  
  
  
  
  
  


  7
  
  
  
  
  
  
  
  


  8
  
  
  
  
  
  
  
  
  


  9
  
  
  
  
  
  
  
  
  





# redgrey View Discrete



  1
     
  


  2
    
  
  
  


  3
    
  
  
  


  4
   
  
  
  
  
  


  5
   
  
  
  
  
  


  6
  
  
  
  
  
  
  
  


  7
  
  
  
  
  
  
  
  


  8
  
  
  
  
  
  
  
  
  


  9
  
  
  
  
  
  
  
  
  





# redyellowblue View Discrete



  1
     
  


  2
    
  
  
  


  3
    
  
  
  


  4
   
  
  
  
  
  


  5
   
  
  
  
  
  


  6
  
  
  
  
  
  
  
  


  7
  
  
  
  
  
  
  
  


  8
  
  
  
  
  
  
  
  
  


  9
  
  
  
  
  
  
  
  
  





# redyellowgreen View Discrete



  1
     
  


  2
    
  
  
  


  3
    
  
  
  


  4
   
  
  
  
  
  


  5
   
  
  
  
  
  


  6
  
  
  
  
  
  
  
  


  7
  
  
  
  
  
  
  
  


  8
  
  
  
  
  
  
  
  
  


  9
  
  
  
  
  
  
  
  
  





# spectral View Discrete



  1
     
  


  2
    
  
  
  


  3
    
  
  
  


  4
   
  
  
  
  
  


  5
   
  
  
  
  
  


  6
  
  
  
  
  
  
  
  


  7
  
  
  
  
  
  
  
  


  8
  
  
  
  
  
  
  
  
  


  9
  
  
  
  
  
  
  
  
  




Cyclical Schemes

Cyclical color schemes may be used to highlight periodic patterns in continuous data. However, these schemes are not well suited to accurately convey value differences.


# rainbow ≥ 4.0




# sinebow ≥ 4.0\nColor schemes provide a set of named color palettes for both discrete and continuous color encodings. Vega provides a collection of perceptually-motivated color schemes, many of which were originally created by Cynthia Brewer and the ColorBrewer project, or by Maureen Stone of Tableau Software. To view and set default color schemes, see the Config documentation.\nDiscrete color schemes may be used directly with scales that have discrete (or discretizing) domains, such as ordinal, quantize, and quantile scales. Continuous color schemes can be used directly with continuous scales (such as linear, log, and sqrt scales), and – by specifying a scheme count property – can also be used to generate discrete color schemes.\nProperties supported by color scheme definitions. These objects can be assigned to a scale’s range property. If a scale definition includes the property "reverse": true, the color scheme order will be flipped.\nRequired. The name of the color scheme to use or an array of color values. See the scheme reference below for named schemes. For Vega 5.0 and higher, if a color array is provided, the colors will be interpolated to form a new scheme; use the scale interpolate property to set the interpolation type (defaults to linear RGB interpolation).\nThe number of colors to use in the scheme. This property can be useful for scale types such as quantile and quantize, which use the length of the scale range to determine the number of discrete bins for the scale domain.\nFor continuous schemes only, determines the extent of the color range to use. For example [0.2, 1] will rescale the color scheme such that color values in the range [0, 0.2) are excluded from the scheme.  Starting the extent array with the higher number will reverse the scheme order.  For example, [1, 0] is the reverse of [0, 1].\nRegistering Additional Schemes\nVega can be extended with additional color schemes using the vega.scheme method. New schemes must be a valid color array or interpolator. For example:\n// Register a discrete color scheme named "basic" that can then be used in Vega specs
vega.scheme('basic', ['#f00', '#0f0', '#00f', '#ff0', '#f0f', '#0ff']);\n// Register a discrete color scheme named "basic" that can then be used in Vega specs
vega.scheme('basic', ['#f00', '#0f0', '#00f', '#ff0', '#f0f', '#0ff']);\n// Register a discrete color scheme named "basic" that can then be used in Vega specs\n// Register a custom continuous interpolation scheme

// Define an interpolator function that maps from [0,1] to colors
function grey(f) {
  var g = Math.max(0, Math.min(255, Math.round(255 * f))) + '';
  return 'rgb(' + g + ', ' + g + ', ' + g + ')';
}

// Register the interpolator. Now the scheme "mygrey" can be used in Vega specs
vega.scheme("mygrey", grey);\n// Register a custom continuous interpolation scheme

// Define an interpolator function that maps from [0,1] to colors
function grey(f) {
  var g = Math.max(0, Math.min(255, Math.round(255 * f))) + '';
  return 'rgb(' + g + ', ' + g + ', ' + g + ')';
}

// Register the interpolator. Now the scheme "mygrey" can be used in Vega specs
vega.scheme("mygrey", grey);\n// Register a custom continuous interpolation scheme\n// Define an interpolator function that maps from [0,1] to colors\n// Register the interpolator. Now the scheme "mygrey" can be used in Vega specs\nSequential Single-Hue\nSequential Single-Hue\nCategorical color schemes can be used to encode discrete data values, each representing a distinct category.\nSequential Single-Hue Schemes\nSequential color schemes can be used to encode quantitative values. These color ramps are designed to encode increasing numeric values. Hover over a scheme and click the “View Discrete” link to toggle display of discretized palettes suitable for quantile, quantize, threshold, or ordinal scales.\n# blues View Discrete



  1
  


  2
  
  


  3
  
  
  


  4
  
  
  
  


  5
  
  
  
  
  


  6
  
  
  
  
  
  


  7
  
  
  
  
  
  
  


  8
  
  
  
  
  
  
  
  


  9\n1
  


  2
  
  


  3
  
  
  


  4
  
  
  
  


  5
  
  
  
  
  


  6
  
  
  
  
  
  


  7
  
  
  
  
  
  
  


  8
  
  
  
  
  
  
  
  


  9\n# tealblues ≥ 5.0 View Discrete



  1
  


  2
  
  


  3
  
  
  


  4
  
  
  
  


  5
  
  
  
  
  


  6
  
  
  
  
  
  


  7
  
  
  
  
  
  
  


  8
  
  
  
  
  
  
  
  


  9\n1
  


  2
  
  


  3
  
  
  


  4
  
  
  
  


  5
  
  
  
  
  


  6
  
  
  
  
  
  


  7
  
  
  
  
  
  
  


  8
  
  
  
  
  
  
  
  


  9\n# teals ≥ 5.0 View Discrete



  1
  


  2
  
  


  3
  
  
  


  4
  
  
  
  


  5
  
  
  
  
  


  6
  
  
  
  
  
  


  7
  
  
  
  
  
  
  


  8
  
  
  
  
  
  
  
  


  9\n1
  


  2
  
  


  3
  
  
  


  4
  
  
  
  


  5
  
  
  
  
  


  6
  
  
  
  
  
  


  7
  
  
  
  
  
  
  


  8
  
  
  
  
  
  
  
  


  9\n# greens View Discrete



  1
  


  2
  
  


  3
  
  
  


  4
  
  
  
  


  5
  
  
  
  
  


  6
  
  
  
  
  
  


  7
  
  
  
  
  
  
  


  8
  
  
  
  
  
  
  
  


  9\n1
  


  2
  
  


  3
  
  
  


  4
  
  
  
  


  5
  
  
  
  
  


  6
  
  
  
  
  
  


  7
  
  
  
  
  
  
  


  8
  
  
  
  
  
  
  
  


  9\n# browns ≥ 5.0 View Discrete



  1
  


  2
  
  


  3
  
  
  


  4
  
  
  
  


  5
  
  
  
  
  


  6
  
  
  
  
  
  


  7
  
  
  
  
  
  
  


  8
  
  
  
  
  
  
  
  


  9\n1
  


  2
  
  


  3
  
  
  


  4
  
  
  
  


  5
  
  
  
  
  


  6
  
  
  
  
  
  


  7
  
  
  
  
  
  
  


  8
  
  
  
  
  
  
  
  


  9\n# oranges View Discrete



  1
  


  2
  
  


  3
  
  
  


  4
  
  
  
  


  5
  
  
  
  
  


  6
  
  
  
  
  
  


  7
  
  
  
  
  
  
  


  8
  
  
  
  
  
  
  
  


  9\n1
  


  2
  
  


  3
  
  
  


  4
  
  
  
  


  5
  
  
  
  
  


  6
  
  
  
  
  
  


  7
  
  
  
  
  
  
  


  8
  
  
  
  
  
  
  
  


  9\n# reds View Discrete



  1
  


  2
  
  


  3
  
  
  


  4
  
  
  
  


  5
  
  
  
  
  


  6
  
  
  
  
  
  


  7
  
  
  
  
  
  
  


  8
  
  
  
  
  
  
  
  


  9\n1
  


  2
  
  


  3
  
  
  


  4
  
  
  
  


  5
  
  
  
  
  


  6
  
  
  
  
  
  


  7
  
  
  
  
  
  
  


  8
  
  
  
  
  
  
  
  


  9\n# purples View Discrete



  1
  


  2
  
  


  3
  
  
  


  4
  
  
  
  


  5
  
  
  
  
  


  6
  
  
  
  
  
  


  7
  
  
  
  
  
  
  


  8
  
  
  
  
  
  
  
  


  9\n1
  


  2
  
  


  3
  
  
  


  4
  
  
  
  


  5
  
  
  
  
  


  6
  
  
  
  
  
  


  7
  
  
  
  
  
  
  


  8
  
  
  
  
  
  
  
  


  9\n# warmgreys ≥ 5.0 View Discrete



  1
  


  2
  
  


  3
  
  
  


  4
  
  
  
  


  5
  
  
  
  
  


  6
  
  
  
  
  
  


  7
  
  
  
  
  
  
  


  8
  
  
  
  
  
  
  
  


  9\n1
  


  2
  
  


  3
  
  
  


  4
  
  
  
  


  5
  
  
  
  
  


  6
  
  
  
  
  
  


  7
  
  
  
  
  
  
  


  8
  
  
  
  
  
  
  
  


  9\n# greys View Discrete



  1
  


  2
  
  


  3
  
  
  


  4
  
  
  
  


  5
  
  
  
  
  


  6
  
  
  
  
  
  


  7
  
  
  
  
  
  
  


  8
  
  
  
  
  
  
  
  


  9\n1
  


  2
  
  


  3
  
  
  


  4
  
  
  
  


  5
  
  
  
  
  


  6
  
  
  
  
  
  


  7
  
  
  
  
  
  
  


  8
  
  
  
  
  
  
  
  


  9\nSequential Multi-Hue Schemes\nSequential color schemes can be used to encode quantitative values. These color ramps are designed to encode increasing numeric values, but use additional hues for more color discrimination, which may be useful for visualizations such as heatmaps. However, beware that using multiple hues may cause viewers to inaccurately see the data range as grouped into color-coded clusters. Hover over a scheme and click the “View Discrete” link to toggle display of discretized palettes suitable for quantile, quantize, threshold, or ordinal scales.\n# viridis View Discrete



  1
  


  2
  
  


  3
  
  
  


  4
  
  
  
  


  5
  
  
  
  
  


  6
  
  
  
  
  
  


  7
  
  
  
  
  
  
  


  8
  
  
  
  
  
  
  
  


  9\n1
  


  2
  
  


  3
  
  
  


  4
  
  
  
  


  5
  
  
  
  
  


  6
  
  
  
  
  
  


  7
  
  
  
  
  
  
  


  8
  
  
  
  
  
  
  
  


  9\n# magma View Discrete



  1
  


  2
  
  


  3
  
  
  


  4
  
  
  
  


  5
  
  
  
  
  


  6
  
  
  
  
  
  


  7
  
  
  
  
  
  
  


  8
  
  
  
  
  
  
  
  


  9\n1
  


  2
  
  


  3
  
  
  


  4
  
  
  
  


  5
  
  
  
  
  


  6
  
  
  
  
  
  


  7
  
  
  
  
  
  
  


  8
  
  
  
  
  
  
  
  


  9\n# inferno View Discrete



  1
  


  2
  
  


  3
  
  
  


  4
  
  
  
  


  5
  
  
  
  
  


  6
  
  
  
  
  
  


  7
  
  
  
  
  
  
  


  8
  
  
  
  
  
  
  
  


  9\n1
  


  2
  
  


  3
  
  
  


  4
  
  
  
  


  5
  
  
  
  
  


  6
  
  
  
  
  
  


  7
  
  
  
  
  
  
  


  8
  
  
  
  
  
  
  
  


  9\n# plasma View Discrete



  1
  


  2
  
  


  3
  
  
  


  4
  
  
  
  


  5
  
  
  
  
  


  6
  
  
  
  
  
  


  7
  
  
  
  
  
  
  


  8
  
  
  
  
  
  
  
  


  9\n1
  


  2
  
  


  3
  
  
  


  4
  
  
  
  


  5
  
  
  
  
  


  6
  
  
  
  
  
  


  7
  
  
  
  
  
  
  


  8
  
  
  
  
  
  
  
  


  9\n# cividis ≥ 5.15 View Discrete



  1
  


  2
  
  


  3
  
  
  


  4
  
  
  
  


  5
  
  
  
  
  


  6
  
  
  
  
  
  


  7
  
  
  
  
  
  
  


  8
  
  
  
  
  
  
  
  


  9\n1
  


  2
  
  


  3
  
  
  


  4
  
  
  
  


  5
  
  
  
  
  


  6
  
  
  
  
  
  


  7
  
  
  
  
  
  
  


  8
  
  
  
  
  
  
  
  


  9\n# turbo ≥ 5.15 View Discrete



  1
  


  2
  
  


  3
  
  
  


  4
  
  
  
  


  5
  
  
  
  
  


  6
  
  
  
  
  
  


  7
  
  
  
  
  
  
  


  8
  
  
  
  
  
  
  
  


  9\n1
  


  2
  
  


  3
  
  
  


  4
  
  
  
  


  5
  
  
  
  
  


  6
  
  
  
  
  
  


  7
  
  
  
  
  
  
  


  8
  
  
  
  
  
  
  
  


  9\n# bluegreen View Discrete



  1
  


  2
  
  


  3
  
  
  


  4
  
  
  
  


  5
  
  
  
  
  


  6
  
  
  
  
  
  


  7
  
  
  
  
  
  
  


  8
  
  
  
  
  
  
  
  


  9\n1
  


  2
  
  


  3
  
  
  


  4
  
  
  
  


  5
  
  
  
  
  


  6
  
  
  
  
  
  


  7
  
  
  
  
  
  
  


  8
  
  
  
  
  
  
  
  


  9\n# bluepurple View Discrete



  1
  


  2
  
  


  3
  
  
  


  4
  
  
  
  


  5
  
  
  
  
  


  6
  
  
  
  
  
  


  7
  
  
  
  
  
  
  


  8
  
  
  
  
  
  
  
  


  9\n1
  


  2
  
  


  3
  
  
  


  4
  
  
  
  


  5
  
  
  
  
  


  6
  
  
  
  
  
  


  7
  
  
  
  
  
  
  


  8
  
  
  
  
  
  
  
  


  9\n# goldgreen ≥ 5.0 View Discrete



  1
  


  2
  
  


  3
  
  
  


  4
  
  
  
  


  5
  
  
  
  
  


  6
  
  
  
  
  
  


  7
  
  
  
  
  
  
  


  8
  
  
  
  
  
  
  
  


  9\n1
  


  2
  
  


  3
  
  
  


  4
  
  
  
  


  5
  
  
  
  
  


  6
  
  
  
  
  
  


  7
  
  
  
  
  
  
  


  8
  
  
  
  
  
  
  
  


  9\n# goldorange ≥ 5.0 View Discrete



  1
  


  2
  
  


  3
  
  
  


  4
  
  
  
  


  5
  
  
  
  
  


  6
  
  
  
  
  
  


  7
  
  
  
  
  
  
  


  8
  
  
  
  
  
  
  
  


  9\n1
  


  2
  
  


  3
  
  
  


  4
  
  
  
  


  5
  
  
  
  
  


  6
  
  
  
  
  
  


  7
  
  
  
  
  
  
  


  8
  
  
  
  
  
  
  
  


  9\n# goldred ≥ 5.0 View Discrete



  1
  


  2
  
  


  3
  
  
  


  4
  
  
  
  


  5
  
  
  
  
  


  6
  
  
  
  
  
  


  7
  
  
  
  
  
  
  


  8
  
  
  
  
  
  
  
  


  9\n1
  


  2
  
  


  3
  
  
  


  4
  
  
  
  


  5
  
  
  
  
  


  6
  
  
  
  
  
  


  7
  
  
  
  
  
  
  


  8
  
  
  
  
  
  
  
  


  9\n# greenblue View Discrete



  1
  


  2
  
  


  3
  
  
  


  4
  
  
  
  


  5
  
  
  
  
  


  6
  
  
  
  
  
  


  7
  
  
  
  
  
  
  


  8
  
  
  
  
  
  
  
  


  9\n1
  


  2
  
  


  3
  
  
  


  4
  
  
  
  


  5
  
  
  
  
  


  6
  
  
  
  
  
  


  7
  
  
  
  
  
  
  


  8
  
  
  
  
  
  
  
  


  9\n# orangered View Discrete



  1
  


  2
  
  


  3
  
  
  


  4
  
  
  
  


  5
  
  
  
  
  


  6
  
  
  
  
  
  


  7
  
  
  
  
  
  
  


  8
  
  
  
  
  
  
  
  


  9\n1
  


  2
  
  


  3
  
  
  


  4
  
  
  
  


  5
  
  
  
  
  


  6
  
  
  
  
  
  


  7
  
  
  
  
  
  
  


  8
  
  
  
  
  
  
  
  


  9\n# purplebluegreen View Discrete



  1
  


  2
  
  


  3
  
  
  


  4
  
  
  
  


  5
  
  
  
  
  


  6
  
  
  
  
  
  


  7
  
  
  
  
  
  
  


  8
  
  
  
  
  
  
  
  


  9\n1
  


  2
  
  


  3
  
  
  


  4
  
  
  
  


  5
  
  
  
  
  


  6
  
  
  
  
  
  


  7
  
  
  
  
  
  
  


  8
  
  
  
  
  
  
  
  


  9\n# purpleblue View Discrete



  1
  


  2
  
  


  3
  
  
  


  4
  
  
  
  


  5
  
  
  
  
  


  6
  
  
  
  
  
  


  7
  
  
  
  
  
  
  


  8
  
  
  
  
  
  
  
  


  9\n1
  


  2
  
  


  3
  
  
  


  4
  
  
  
  


  5
  
  
  
  
  


  6
  
  
  
  
  
  


  7
  
  
  
  
  
  
  


  8
  
  
  
  
  
  
  
  


  9\n# purplered View Discrete



  1
  


  2
  
  


  3
  
  
  


  4
  
  
  
  


  5
  
  
  
  
  


  6
  
  
  
  
  
  


  7
  
  
  
  
  
  
  


  8
  
  
  
  
  
  
  
  


  9\n1
  


  2
  
  


  3
  
  
  


  4
  
  
  
  


  5
  
  
  
  
  


  6
  
  
  
  
  
  


  7
  
  
  
  
  
  
  


  8
  
  
  
  
  
  
  
  


  9\n# redpurple View Discrete



  1
  


  2
  
  


  3
  
  
  


  4
  
  
  
  


  5
  
  
  
  
  


  6
  
  
  
  
  
  


  7
  
  
  
  
  
  
  


  8
  
  
  
  
  
  
  
  


  9\n1
  


  2
  
  


  3
  
  
  


  4
  
  
  
  


  5
  
  
  
  
  


  6
  
  
  
  
  
  


  7
  
  
  
  
  
  
  


  8
  
  
  
  
  
  
  
  


  9\n# yellowgreenblue View Discrete



  1
  


  2
  
  


  3
  
  
  


  4
  
  
  
  


  5
  
  
  
  
  


  6
  
  
  
  
  
  


  7
  
  
  
  
  
  
  


  8
  
  
  
  
  
  
  
  


  9\n1
  


  2
  
  


  3
  
  
  


  4
  
  
  
  


  5
  
  
  
  
  


  6
  
  
  
  
  
  


  7
  
  
  
  
  
  
  


  8
  
  
  
  
  
  
  
  


  9\n# yellowgreen View Discrete



  1
  


  2
  
  


  3
  
  
  


  4
  
  
  
  


  5
  
  
  
  
  


  6
  
  
  
  
  
  


  7
  
  
  
  
  
  
  


  8
  
  
  
  
  
  
  
  


  9\n1
  


  2
  
  


  3
  
  
  


  4
  
  
  
  


  5
  
  
  
  
  


  6
  
  
  
  
  
  


  7
  
  
  
  
  
  
  


  8
  
  
  
  
  
  
  
  


  9\n# yelloworangebrown View Discrete



  1
  


  2
  
  


  3
  
  
  


  4
  
  
  
  


  5
  
  
  
  
  


  6
  
  
  
  
  
  


  7
  
  
  
  
  
  
  


  8
  
  
  
  
  
  
  
  


  9\n1
  


  2
  
  


  3
  
  
  


  4
  
  
  
  


  5
  
  
  
  
  


  6
  
  
  
  
  
  


  7
  
  
  
  
  
  
  


  8
  
  
  
  
  
  
  
  


  9\n# yelloworangered View Discrete



  1
  


  2
  
  


  3
  
  
  


  4
  
  
  
  


  5
  
  
  
  
  


  6
  
  
  
  
  
  


  7
  
  
  
  
  
  
  


  8
  
  
  
  
  
  
  
  


  9\n1
  


  2
  
  


  3
  
  
  


  4
  
  
  
  


  5
  
  
  
  
  


  6
  
  
  
  
  
  


  7
  
  
  
  
  
  
  


  8
  
  
  
  
  
  
  
  


  9\n# darkblue ≥ 5.0 View Discrete



  1
  


  2
  
  


  3
  
  
  


  4
  
  
  
  


  5
  
  
  
  
  


  6
  
  
  
  
  
  


  7
  
  
  
  
  
  
  


  8
  
  
  
  
  
  
  
  


  9\n1
  


  2
  
  


  3
  
  
  


  4
  
  
  
  


  5
  
  
  
  
  


  6
  
  
  
  
  
  


  7
  
  
  
  
  
  
  


  8
  
  
  
  
  
  
  
  


  9\n# darkgold ≥ 5.0 View Discrete



  1
  


  2
  
  


  3
  
  
  


  4
  
  
  
  


  5
  
  
  
  
  


  6
  
  
  
  
  
  


  7
  
  
  
  
  
  
  


  8
  
  
  
  
  
  
  
  


  9\n1
  


  2
  
  


  3
  
  
  


  4
  
  
  
  


  5
  
  
  
  
  


  6
  
  
  
  
  
  


  7
  
  
  
  
  
  
  


  8
  
  
  
  
  
  
  
  


  9\n# darkgreen ≥ 5.0 View Discrete



  1
  


  2
  
  


  3
  
  
  


  4
  
  
  
  


  5
  
  
  
  
  


  6
  
  
  
  
  
  


  7
  
  
  
  
  
  
  


  8
  
  
  
  
  
  
  
  


  9\n1
  


  2
  
  


  3
  
  
  


  4
  
  
  
  


  5
  
  
  
  
  


  6
  
  
  
  
  
  


  7
  
  
  
  
  
  
  


  8
  
  
  
  
  
  
  
  


  9\n# darkmulti ≥ 5.0 View Discrete



  1
  


  2
  
  


  3
  
  
  


  4
  
  
  
  


  5
  
  
  
  
  


  6
  
  
  
  
  
  


  7
  
  
  
  
  
  
  


  8
  
  
  
  
  
  
  
  


  9\n1
  


  2
  
  


  3
  
  
  


  4
  
  
  
  


  5
  
  
  
  
  


  6
  
  
  
  
  
  


  7
  
  
  
  
  
  
  


  8
  
  
  
  
  
  
  
  


  9\n# darkred ≥ 5.0 View Discrete



  1
  


  2
  
  


  3
  
  
  


  4
  
  
  
  


  5
  
  
  
  
  


  6
  
  
  
  
  
  


  7
  
  
  
  
  
  
  


  8
  
  
  
  
  
  
  
  


  9\n1
  


  2
  
  


  3
  
  
  


  4
  
  
  
  


  5
  
  
  
  
  


  6
  
  
  
  
  
  


  7
  
  
  
  
  
  
  


  8
  
  
  
  
  
  
  
  


  9\nFor Light Backgrounds\n# lightgreyred ≥ 5.0 View Discrete



  1
  


  2
  
  


  3
  
  
  


  4
  
  
  
  


  5
  
  
  
  
  


  6
  
  
  
  
  
  


  7
  
  
  
  
  
  
  


  8
  
  
  
  
  
  
  
  


  9\n1
  


  2
  
  


  3
  
  
  


  4
  
  
  
  


  5
  
  
  
  
  


  6
  
  
  
  
  
  


  7
  
  
  
  
  
  
  


  8
  
  
  
  
  
  
  
  


  9\n# lightgreyteal ≥ 5.0 View Discrete



  1
  


  2
  
  


  3
  
  
  


  4
  
  
  
  


  5
  
  
  
  
  


  6
  
  
  
  
  
  


  7
  
  
  
  
  
  
  


  8
  
  
  
  
  
  
  
  


  9\n1
  


  2
  
  


  3
  
  
  


  4
  
  
  
  


  5
  
  
  
  
  


  6
  
  
  
  
  
  


  7
  
  
  
  
  
  
  


  8
  
  
  
  
  
  
  
  


  9\n# lightmulti ≥ 5.0 View Discrete



  1
  


  2
  
  


  3
  
  
  


  4
  
  
  
  


  5
  
  
  
  
  


  6
  
  
  
  
  
  


  7
  
  
  
  
  
  
  


  8
  
  
  
  
  
  
  
  


  9\n1
  


  2
  
  


  3
  
  
  


  4
  
  
  
  


  5
  
  
  
  
  


  6
  
  
  
  
  
  


  7
  
  
  
  
  
  
  


  8
  
  
  
  
  
  
  
  


  9\n# lightorange ≥ 5.0 View Discrete



  1
  


  2
  
  


  3
  
  
  


  4
  
  
  
  


  5
  
  
  
  
  


  6
  
  
  
  
  
  


  7
  
  
  
  
  
  
  


  8
  
  
  
  
  
  
  
  


  9\n1
  


  2
  
  


  3
  
  
  


  4
  
  
  
  


  5
  
  
  
  
  


  6
  
  
  
  
  
  


  7
  
  
  
  
  
  
  


  8
  
  
  
  
  
  
  
  


  9\n# lighttealblue ≥ 5.0 View Discrete



  1
  


  2
  
  


  3
  
  
  


  4
  
  
  
  


  5
  
  
  
  
  


  6
  
  
  
  
  
  


  7
  
  
  
  
  
  
  


  8
  
  
  
  
  
  
  
  


  9\n1
  


  2
  
  


  3
  
  
  


  4
  
  
  
  


  5
  
  
  
  
  


  6
  
  
  
  
  
  


  7
  
  
  
  
  
  
  


  8
  
  
  
  
  
  
  
  


  9\nDiverging color schemes can be used to encode quantitative values with a meaningful mid-point, such as zero or the average value. Color ramps with different hues diverge with increasing saturation to highlight the values below and above the mid-point. Hover over a scheme and click the “View Discrete” link to toggle display of discretized palettes suitable for quantile, quantize, threshold, or ordinal scales.\n# blueorange View Discrete



  1
     
  


  2
    
  
  
  


  3
    
  
  
  


  4
   
  
  
  
  
  


  5
   
  
  
  
  
  


  6
  
  
  
  
  
  
  
  


  7
  
  
  
  
  
  
  
  


  8
  
  
  
  
  
  
  
  
  


  9\n1
     
  


  2
    
  
  
  


  3
    
  
  
  


  4
   
  
  
  
  
  


  5
   
  
  
  
  
  


  6
  
  
  
  
  
  
  
  


  7
  
  
  
  
  
  
  
  


  8
  
  
  
  
  
  
  
  
  


  9\n# brownbluegreen View Discrete



  1
     
  


  2
    
  
  
  


  3
    
  
  
  


  4
   
  
  
  
  
  


  5
   
  
  
  
  
  


  6
  
  
  
  
  
  
  
  


  7
  
  
  
  
  
  
  
  


  8
  
  
  
  
  
  
  
  
  


  9\n1
     
  


  2
    
  
  
  


  3
    
  
  
  


  4
   
  
  
  
  
  


  5
   
  
  
  
  
  


  6
  
  
  
  
  
  
  
  


  7
  
  
  
  
  
  
  
  


  8
  
  
  
  
  
  
  
  
  


  9\n# purplegreen View Discrete



  1
     
  


  2
    
  
  
  


  3
    
  
  
  


  4
   
  
  
  
  
  


  5
   
  
  
  
  
  


  6
  
  
  
  
  
  
  
  


  7
  
  
  
  
  
  
  
  


  8
  
  
  
  
  
  
  
  
  


  9\n1
     
  


  2
    
  
  
  


  3
    
  
  
  


  4
   
  
  
  
  
  


  5
   
  
  
  
  
  


  6
  
  
  
  
  
  
  
  


  7
  
  
  
  
  
  
  
  


  8
  
  
  
  
  
  
  
  
  


  9\n# pinkyellowgreen View Discrete



  1
     
  


  2
    
  
  
  


  3
    
  
  
  


  4
   
  
  
  
  
  


  5
   
  
  
  
  
  


  6
  
  
  
  
  
  
  
  


  7
  
  
  
  
  
  
  
  


  8
  
  
  
  
  
  
  
  
  


  9\n1
     
  


  2
    
  
  
  


  3
    
  
  
  


  4
   
  
  
  
  
  


  5
   
  
  
  
  
  


  6
  
  
  
  
  
  
  
  


  7
  
  
  
  
  
  
  
  


  8
  
  
  
  
  
  
  
  
  


  9\n# purpleorange View Discrete



  1
     
  


  2
    
  
  
  


  3
    
  
  
  


  4
   
  
  
  
  
  


  5
   
  
  
  
  
  


  6
  
  
  
  
  
  
  
  


  7
  
  
  
  
  
  
  
  


  8
  
  
  
  
  
  
  
  
  


  9\n1
     
  


  2
    
  
  
  


  3
    
  
  
  


  4
   
  
  
  
  
  


  5
   
  
  
  
  
  


  6
  
  
  
  
  
  
  
  


  7
  
  
  
  
  
  
  
  


  8
  
  
  
  
  
  
  
  
  


  9\n# redblue View Discrete



  1
     
  


  2
    
  
  
  


  3
    
  
  
  


  4
   
  
  
  
  
  


  5
   
  
  
  
  
  


  6
  
  
  
  
  
  
  
  


  7
  
  
  
  
  
  
  
  


  8
  
  
  
  
  
  
  
  
  


  9\n1
     
  


  2
    
  
  
  


  3
    
  
  
  


  4
   
  
  
  
  
  


  5
   
  
  
  
  
  


  6
  
  
  
  
  
  
  
  


  7
  
  
  
  
  
  
  
  


  8
  
  
  
  
  
  
  
  
  


  9\n# redgrey View Discrete



  1
     
  


  2
    
  
  
  


  3
    
  
  
  


  4
   
  
  
  
  
  


  5
   
  
  
  
  
  


  6
  
  
  
  
  
  
  
  


  7
  
  
  
  
  
  
  
  


  8
  
  
  
  
  
  
  
  
  


  9\n1
     
  


  2
    
  
  
  


  3
    
  
  
  


  4
   
  
  
  
  
  


  5
   
  
  
  
  
  


  6
  
  
  
  
  
  
  
  


  7
  
  
  
  
  
  
  
  


  8
  
  
  
  
  
  
  
  
  


  9\n# redyellowblue View Discrete



  1
     
  


  2
    
  
  
  


  3
    
  
  
  


  4
   
  
  
  
  
  


  5
   
  
  
  
  
  


  6
  
  
  
  
  
  
  
  


  7
  
  
  
  
  
  
  
  


  8
  
  
  
  
  
  
  
  
  


  9\n1
     
  


  2
    
  
  
  


  3
    
  
  
  


  4
   
  
  
  
  
  


  5
   
  
  
  
  
  


  6
  
  
  
  
  
  
  
  


  7
  
  
  
  
  
  
  
  


  8
  
  
  
  
  
  
  
  
  


  9\n# redyellowgreen View Discrete



  1
     
  


  2
    
  
  
  


  3
    
  
  
  


  4
   
  
  
  
  
  


  5
   
  
  
  
  
  


  6
  
  
  
  
  
  
  
  


  7
  
  
  
  
  
  
  
  


  8
  
  
  
  
  
  
  
  
  


  9\n1
     
  


  2
    
  
  
  


  3
    
  
  
  


  4
   
  
  
  
  
  


  5
   
  
  
  
  
  


  6
  
  
  
  
  
  
  
  


  7
  
  
  
  
  
  
  
  


  8
  
  
  
  
  
  
  
  
  


  9\n# spectral View Discrete



  1
     
  


  2
    
  
  
  


  3
    
  
  
  


  4
   
  
  
  
  
  


  5
   
  
  
  
  
  


  6
  
  
  
  
  
  
  
  


  7
  
  
  
  
  
  
  
  


  8
  
  
  
  
  
  
  
  
  


  9\n1
     
  


  2
    
  
  
  


  3
    
  
  
  


  4
   
  
  
  
  
  


  5
   
  
  
  
  
  


  6
  
  
  
  
  
  
  
  


  7
  
  
  
  
  
  
  
  


  8
  
  
  
  
  
  
  
  
  


  9\nCyclical color schemes may be used to highlight periodic patterns in continuous data. However, these schemes are not well suited to accurately convey value differences.\n\n\nVega
            
              Vega-Lite
              Altair
              Vega-Lite API
            
          
          
            
              Examples
              Tutorials
              Documentation
              Usage
              About
            
            
              GitHub
              Try Online
            
          
        
      

      
        

  
  
    
      
      
        Documentation
      
      
      
      
        Specification
      
      
      
      
        Config
      
      
      
      
        Data
      
      
      
      
        Transforms
      
      
      
      
        Triggers
      
      
      
      
        Projections
      
      
      
      
        Scales
      
      
      
      
        Schemes
      
      
      
      
        Axes
      
      
      
      
        Legends
      
      
      
      
        Title
      
      
      
      
        Marks
      
      
      
      
        Signals
      
      
      
      
        Event Streams
      
      
      
      
        Expressions
      
      
      
      
        Layout
      
      
      
      
        Types
      
      
    
  
  
    Title
    The title directive adds a descriptive title to a chart. Similar to scales, axes, and legends, a title can be defined at the top-level of a specification or as part of a group mark.

Title Properties

Properties for specifying a title.


  
    
      Property
      Type
      Description
    
  
  
    
      text
      String | String[ ]
      Required. The title text. For versions ≥ 5.7, a string array specifies multiple lines of text.
    
    
      orient
      String
      The orientation of the title and subtitle relative to the chart. One of top (the default), bottom, left, or right.
    
    
      align
      String
      Horizontal text alignment of the title and subtitle. If specified, this value overrides automatic alignment based on the anchor value.
    
    
      anchor
      String
      The anchor position for placing the title and subtitle. One of start, middle (the default), or end. For example, with an orientation of top these anchor positions map to a left-, center-, or right-aligned title.
    
    
      angle
      Number
      Angle in degrees of the title and subtitle text.
    
    
      baseline
      String
      Vertical baseline of the title and subtitle text. One of alphabetic (default), top, middle, bottom, line-top, or line-bottom. The line-top and line-bottom values ≥ 5.10 operate similarly to top and bottom, but are calculated relative to the lineHeight rather than fontSize alone.
    
    
      color
      Color
      Text color of the title text.
    
    
      dx
      Number
      Horizontal offset added to the title and subtitle x-coordinate. ≥ 5.2
    
    
      dy
      Number
      Vertical offset added to the title and subtitle y-coordinate. ≥ 5.2
    
    
      encode
      Object
      Optional mark encodings for custom title styling. In versions ≥ 5.7, supports encoding blocks for group, title, and subtitle. See custom title encodings. The earlier support using a flat encoding block for the title text only is now deprecated; please use nested encoding blocks instead.
    
    
      font
      String
      Font name of the title text.
    
    
      fontSize
      Number
      Font size in pixels of the title text.
    
    
      fontStyle
      String
      Font style of the title text (e.g., normal or italic). ≥ 5.0
    
    
      fontWeight
      String | Number
      Font weight of the title text.
    
    
      frame
      String
      The reference frame for the anchor position, one of "bounds" (the default, to anchor relative to the full bounding box) or "group" (to anchor relative to the group width or height).
    
    
      interactive
      Boolean
      A boolean flag indicating if the title element should respond to input events such as mouse hover. Deprecated: use a custom encode block instead.
    
    
      limit
      Number
      The maximum allowed length in pixels of title and subtitle text.
    
    
      lineHeight
      Number
      Line height in pixels for multi-line title text or title text with "line-top" or "line-bottom" baseline. ≥ 5.7
    
    
      name
      String
      A mark name property to apply to the title text mark. Deprecated: use a custom encode block instead.
    
    
      offset
      Number | Value
      The orthogonal offset in pixels by which to displace the title from its position along the edge of the chart.
    
    
      style
      String | String[ ]
      A mark style property to apply to the title text mark. If not specified, a default style of "group-title" is applied. Deprecated: use a custom encode block instead.
    
    
      subtitle
      String | String[ ]
      Optional subtitle text, placed beneath the primary text. A string array specifies multiple lines of text. ≥ 5.7
    
    
      subtitleColor
      Color
      Text color of the subtitle text. ≥ 5.7
    
    
      subtitleFont
      String
      Font name of the subtitle text. ≥ 5.7
    
    
      subtitleFontSize
      Number
      Font size in pixels of the subtitle text. ≥ 5.7
    
    
      subtitleFontStyle
      String
      Font style of the subtitle text (e.g., normal or italic). ≥ 5.7
    
    
      subtitleFontWeight
      String | Number
      Font weight of the subtitle text. ≥ 5.7
    
    
      subtitleLineHeight
      Number
      Line height in pixels for multi-line subtitle text. ≥ 5.7
    
    
      subtitlePadding
      Number
      Padding in pixels between title and subtitle text. ≥ 5.7
    
    
      zindex
      Number
      The integer z-index indicating the layering of the title group relative to other axis, mark, and legend groups. The default value is 0.
    
  


Accessibility Properties ≥ 5.11

Accessibility properties are used to determine ARIA (Accessible Rich Internet Applications) attributes when using Vega to render SVG output.


  
    
      Property
      Type
      Description
    
  
  
    
      aria
      Boolean
      A boolean flag (default true) indicating if ARIA attributes should be included (SVG output only). If false, the “aria-hidden” attribute will be set on the output SVG group, removing the title from the ARIA accessibility tree.
    
  


Themes and Configuration

To create themes, new default values for many title properties can be set using a config object.

Custom Title Encodings

In addition to the customization parameters above, mark properties can be set for all title elements using the encode parameter. The addressable elements are:


  group for the title group mark,
  title for the title text mark, and
  subtitle for the subtitle text mark.


Each element accepts a set of visual encoding directives grouped into enter, update, exit, etc. objects as described in the Marks documentation. Mark properties can be styled using standard value references.

In addition, each encode block may include a string-valued name property to assign a unique name to the mark set, a boolean-valued interactive property to enable input event handling, and a string-valued (or array-valued) style property to apply default property values. Unless otherwise specified, title elements use a default style of "group-title" and subtitle elements use a default style of "group-subtitle".

The following example shows how to set custom color and font properties for title and subtitle text marks, and enable interactivity for the subtitle text:

"title": {
  "text": "Title Text",
  "subtitle": "Subtitle Text",
  "encode": {
    "title": {
      "enter": {
        "fill": {"value": "purple"}
      }
    },
    "subtitle": {
      "interactive": true,
      "update": {
        "fontStyle": {"value": "italic"}
      },
      "hover": {
        "fontStyle": {"value": "normal"}
      }
    }
  }
}\nVega
            
              Vega-Lite
              Altair
              Vega-Lite API\nVega-Lite
              Altair
              Vega-Lite API\nExamples
              Tutorials
              Documentation
              Usage
              About
            
            
              GitHub
              Try Online\nExamples
              Tutorials
              Documentation
              Usage
              About\nGitHub
              Try Online\nDocumentation
      
      
      
      
        Specification
      
      
      
      
        Config
      
      
      
      
        Data
      
      
      
      
        Transforms
      
      
      
      
        Triggers
      
      
      
      
        Projections
      
      
      
      
        Scales
      
      
      
      
        Schemes
      
      
      
      
        Axes
      
      
      
      
        Legends
      
      
      
      
        Title
      
      
      
      
        Marks
      
      
      
      
        Signals
      
      
      
      
        Event Streams
      
      
      
      
        Expressions
      
      
      
      
        Layout
      
      
      
      
        Types
      
      
    
  
  
    Title
    The title directive adds a descriptive title to a chart. Similar to scales, axes, and legends, a title can be defined at the top-level of a specification or as part of a group mark.

Title Properties

Properties for specifying a title.


  
    
      Property
      Type
      Description
    
  
  
    
      text
      String | String[ ]
      Required. The title text. For versions ≥ 5.7, a string array specifies multiple lines of text.
    
    
      orient
      String
      The orientation of the title and subtitle relative to the chart. One of top (the default), bottom, left, or right.
    
    
      align
      String
      Horizontal text alignment of the title and subtitle. If specified, this value overrides automatic alignment based on the anchor value.
    
    
      anchor
      String
      The anchor position for placing the title and subtitle. One of start, middle (the default), or end. For example, with an orientation of top these anchor positions map to a left-, center-, or right-aligned title.
    
    
      angle
      Number
      Angle in degrees of the title and subtitle text.
    
    
      baseline
      String
      Vertical baseline of the title and subtitle text. One of alphabetic (default), top, middle, bottom, line-top, or line-bottom. The line-top and line-bottom values ≥ 5.10 operate similarly to top and bottom, but are calculated relative to the lineHeight rather than fontSize alone.
    
    
      color
      Color
      Text color of the title text.
    
    
      dx
      Number
      Horizontal offset added to the title and subtitle x-coordinate. ≥ 5.2
    
    
      dy
      Number
      Vertical offset added to the title and subtitle y-coordinate. ≥ 5.2
    
    
      encode
      Object
      Optional mark encodings for custom title styling. In versions ≥ 5.7, supports encoding blocks for group, title, and subtitle. See custom title encodings. The earlier support using a flat encoding block for the title text only is now deprecated; please use nested encoding blocks instead.
    
    
      font
      String
      Font name of the title text.
    
    
      fontSize
      Number
      Font size in pixels of the title text.
    
    
      fontStyle
      String
      Font style of the title text (e.g., normal or italic). ≥ 5.0
    
    
      fontWeight
      String | Number
      Font weight of the title text.
    
    
      frame
      String
      The reference frame for the anchor position, one of "bounds" (the default, to anchor relative to the full bounding box) or "group" (to anchor relative to the group width or height).
    
    
      interactive
      Boolean
      A boolean flag indicating if the title element should respond to input events such as mouse hover. Deprecated: use a custom encode block instead.
    
    
      limit
      Number
      The maximum allowed length in pixels of title and subtitle text.
    
    
      lineHeight
      Number
      Line height in pixels for multi-line title text or title text with "line-top" or "line-bottom" baseline. ≥ 5.7
    
    
      name
      String
      A mark name property to apply to the title text mark. Deprecated: use a custom encode block instead.
    
    
      offset
      Number | Value
      The orthogonal offset in pixels by which to displace the title from its position along the edge of the chart.
    
    
      style
      String | String[ ]
      A mark style property to apply to the title text mark. If not specified, a default style of "group-title" is applied. Deprecated: use a custom encode block instead.
    
    
      subtitle
      String | String[ ]
      Optional subtitle text, placed beneath the primary text. A string array specifies multiple lines of text. ≥ 5.7
    
    
      subtitleColor
      Color
      Text color of the subtitle text. ≥ 5.7
    
    
      subtitleFont
      String
      Font name of the subtitle text. ≥ 5.7
    
    
      subtitleFontSize
      Number
      Font size in pixels of the subtitle text. ≥ 5.7
    
    
      subtitleFontStyle
      String
      Font style of the subtitle text (e.g., normal or italic). ≥ 5.7
    
    
      subtitleFontWeight
      String | Number
      Font weight of the subtitle text. ≥ 5.7
    
    
      subtitleLineHeight
      Number
      Line height in pixels for multi-line subtitle text. ≥ 5.7
    
    
      subtitlePadding
      Number
      Padding in pixels between title and subtitle text. ≥ 5.7
    
    
      zindex
      Number
      The integer z-index indicating the layering of the title group relative to other axis, mark, and legend groups. The default value is 0.
    
  


Accessibility Properties ≥ 5.11

Accessibility properties are used to determine ARIA (Accessible Rich Internet Applications) attributes when using Vega to render SVG output.


  
    
      Property
      Type
      Description
    
  
  
    
      aria
      Boolean
      A boolean flag (default true) indicating if ARIA attributes should be included (SVG output only). If false, the “aria-hidden” attribute will be set on the output SVG group, removing the title from the ARIA accessibility tree.
    
  


Themes and Configuration

To create themes, new default values for many title properties can be set using a config object.

Custom Title Encodings

In addition to the customization parameters above, mark properties can be set for all title elements using the encode parameter. The addressable elements are:


  group for the title group mark,
  title for the title text mark, and
  subtitle for the subtitle text mark.


Each element accepts a set of visual encoding directives grouped into enter, update, exit, etc. objects as described in the Marks documentation. Mark properties can be styled using standard value references.

In addition, each encode block may include a string-valued name property to assign a unique name to the mark set, a boolean-valued interactive property to enable input event handling, and a string-valued (or array-valued) style property to apply default property values. Unless otherwise specified, title elements use a default style of "group-title" and subtitle elements use a default style of "group-subtitle".

The following example shows how to set custom color and font properties for title and subtitle text marks, and enable interactivity for the subtitle text:

"title": {
  "text": "Title Text",
  "subtitle": "Subtitle Text",
  "encode": {
    "title": {
      "enter": {
        "fill": {"value": "purple"}
      }
    },
    "subtitle": {
      "interactive": true,
      "update": {
        "fontStyle": {"value": "italic"}
      },
      "hover": {
        "fontStyle": {"value": "normal"}
      }
    }
  }
}\nThe title directive adds a descriptive title to a chart. Similar to scales, axes, and legends, a title can be defined at the top-level of a specification or as part of a group mark.\nProperties for specifying a title.\nRequired. The title text. For versions ≥ 5.7, a string array specifies multiple lines of text.\nThe orientation of the title and subtitle relative to the chart. One of top (the default), bottom, left, or right.\nHorizontal text alignment of the title and subtitle. If specified, this value overrides automatic alignment based on the anchor value.\nThe anchor position for placing the title and subtitle. One of start, middle (the default), or end. For example, with an orientation of top these anchor positions map to a left-, center-, or right-aligned title.\nAngle in degrees of the title and subtitle text.\nVertical baseline of the title and subtitle text. One of alphabetic (default), top, middle, bottom, line-top, or line-bottom. The line-top and line-bottom values ≥ 5.10 operate similarly to top and bottom, but are calculated relative to the lineHeight rather than fontSize alone.\nText color of the title text.\nHorizontal offset added to the title and subtitle x-coordinate. ≥ 5.2\nVertical offset added to the title and subtitle y-coordinate. ≥ 5.2\nOptional mark encodings for custom title styling. In versions ≥ 5.7, supports encoding blocks for group, title, and subtitle. See custom title encodings. The earlier support using a flat encoding block for the title text only is now deprecated; please use nested encoding blocks instead.\ncustom title encodings\nFont name of the title text.\nFont size in pixels of the title text.\nFont style of the title text (e.g., normal or italic). ≥ 5.0\nFont weight of the title text.\nThe reference frame for the anchor position, one of "bounds" (the default, to anchor relative to the full bounding box) or "group" (to anchor relative to the group width or height).\nA boolean flag indicating if the title element should respond to input events such as mouse hover. Deprecated: use a custom encode block instead.\nThe maximum allowed length in pixels of title and subtitle text.\nLine height in pixels for multi-line title text or title text with "line-top" or "line-bottom" baseline. ≥ 5.7\nA mark name property to apply to the title text mark. Deprecated: use a custom encode block instead.\nThe orthogonal offset in pixels by which to displace the title from its position along the edge of the chart.\nA mark style property to apply to the title text mark. If not specified, a default style of "group-title" is applied. Deprecated: use a custom encode block instead.\nOptional subtitle text, placed beneath the primary text. A string array specifies multiple lines of text. ≥ 5.7\nText color of the subtitle text. ≥ 5.7\nFont name of the subtitle text. ≥ 5.7\nFont size in pixels of the subtitle text. ≥ 5.7\nFont style of the subtitle text (e.g., normal or italic). ≥ 5.7\nFont weight of the subtitle text. ≥ 5.7\nLine height in pixels for multi-line subtitle text. ≥ 5.7\nPadding in pixels between title and subtitle text. ≥ 5.7\nThe integer z-index indicating the layering of the title group relative to other axis, mark, and legend groups. The default value is 0.\nAccessibility Properties ≥ 5.11\nAccessibility properties are used to determine ARIA (Accessible Rich Internet Applications) attributes when using Vega to render SVG output.\nARIA (Accessible Rich Internet Applications) attributes\nA boolean flag (default true) indicating if ARIA attributes should be included (SVG output only). If false, the “aria-hidden” attribute will be set on the output SVG group, removing the title from the ARIA accessibility tree.\nThemes and Configuration\nTo create themes, new default values for many title properties can be set using a config object.\nCustom Title Encodings\nIn addition to the customization parameters above, mark properties can be set for all title elements using the encode parameter. The addressable elements are:\ngroup for the title group mark,\ntitle for the title text mark, and\nsubtitle for the subtitle text mark.\nEach element accepts a set of visual encoding directives grouped into enter, update, exit, etc. objects as described in the Marks documentation. Mark properties can be styled using standard value references.\nIn addition, each encode block may include a string-valued name property to assign a unique name to the mark set, a boolean-valued interactive property to enable input event handling, and a string-valued (or array-valued) style property to apply default property values. Unless otherwise specified, title elements use a default style of "group-title" and subtitle elements use a default style of "group-subtitle".\nThe following example shows how to set custom color and font properties for title and subtitle text marks, and enable interactivity for the subtitle text:\n"title": {
  "text": "Title Text",
  "subtitle": "Subtitle Text",
  "encode": {
    "title": {
      "enter": {
        "fill": {"value": "purple"}
      }
    },
    "subtitle": {
      "interactive": true,
      "update": {
        "fontStyle": {"value": "italic"}
      },
      "hover": {
        "fontStyle": {"value": "normal"}
      }
    }
  }
}\n"title": {
  "text": "Title Text",
  "subtitle": "Subtitle Text",
  "encode": {
    "title": {
      "enter": {
        "fill": {"value": "purple"}
      }
    },
    "subtitle": {
      "interactive": true,
      "update": {
        "fontStyle": {"value": "italic"}
      },
      "hover": {
        "fontStyle": {"value": "normal"}
      }
    }
  }
}\n\n\nVega
            
              Vega-Lite
              Altair
              Vega-Lite API
            
          
          
            
              Examples
              Tutorials
              Documentation
              Usage
              About
            
            
              GitHub
              Try Online
            
          
        
      

      
        

  
  
    
      
      
        Documentation
      
      
      
      
        Specification
      
      
      
      
        Config
      
      
      
      
        Data
      
      
      
      
        Transforms
      
      
      
      
        Triggers
      
      
      
      
        Projections
      
      
      
      
        Scales
      
      
      
      
        Schemes
      
      
      
      
        Axes
      
      
      
      
        Legends
      
      
      
      
        Title
      
      
      
      
        Marks
      
      
      
      
        Signals
      
      
      
      
        Event Streams
      
      
      
      
        Expressions
      
      
      
      
        Layout
      
      
      
      
        Types
      
      
    
  
  
    Event Streams
    Event streams are the primary means of modeling user input to enable dynamic, interactive visualizations. Event streams capture a sequence of input events such as mouse click, touch movement, timer ticks, or signal updates. When events that match a stream definition occur, they cause any corresponding signal event handlers to evaluate, potentially updating a signal value.

{
  "name": "signalName",
  "on": [
    {
      "events": <<event-stream-definition>>,
      "update": ...
    }
  ]
}


An event stream definition can be specified in multiple ways:


  Event stream objects indicate which events to capture.
  Event stream selectors string provide a convenient shorthand for event stream objects. For example, "rect:mouseover", "click[event.shiftKey]", or "timer{1000}".
  Signal references capture signal updates. For example, {"signal": "name"}.
  Scale references capture scale updates. For example, {"scale": "xscale"}.
  An array of multiple event stream objects, signal references, or scale references to capture.


Supported Event Types

The supported DOM event types for mark items are:


  click
  dblclick
  dragenter
  dragleave
  dragover
  keydown
  keypress
  keyup
  mousedown
  mousemove
  mouseout
  mouseover
  mouseup
  mousewheel
  touchend
  touchmove
  touchstart
  wheel


Other event types supported by the browser (e.g., resize events on the window object) may be captured from DOM elements on the same web page as the Vega visualization. The list above applies only to mark items contained within the Vega view’s scenegraph.

In addition, Vega supports a timer event, which fires a new event at a specified time interval (in milliseconds) determined by the event stream throttle property. ≥ 4.0

Event Stream Objects

A basic event stream consists of an event source and type:


  
    
      Property
      Type
      Description
    
  
  
    
      source
      String
      The input event source. For event streams defined in the top-level scope of a Vega specification, this property defaults to "view", which monitors all input events in the current Vega view component (including those targeting the containing Canvas or SVG component itself). For event streams defined within nested scopes, this property defaults to "scope", which limits consideration to only events originating within the group in which the event stream is defined. Othe legal values include "window" for the browser window object, or a CSS selector string indicating external DOM elements. The source property is ignored if the event type is "timer".
    
    
      type
      String
      Required. The event type to monitor (e.g., "click", "keydown", "timer"). For more, see the supported event types list.
    
  


Any event stream object may also include the following properties for filtering or modifying an event stream:


  
    
      Property
      Type
      Description
    
  
  
    
      between
      EventStream[ ]
      A two-element array of event stream objects, indicating sentinel starting and ending events. Only events that occur between these two events will be captured.
    
    
      consume
      Boolean
      A boolean flag (default false) indicating if this stream should consume the event by invoking event.preventDefault(). To control event consumption more globally, see the event handling configuration.
    
    
      filter
      Expression | Expression[ ]
      One or more filter expressions, each of which must evaluate to a truthy value in order for the event to be captured. These expressions may not reference signal values, only event properties.
    
    
      debounce
      Number
      The minimum time to wait between event occurrence and processing. If a new event arrives during a debouncing window, the debounce timer will restart and only the new event will be captured.
    
    
      markname
      String
      The unique name of a mark set for which to monitor input events. Events originating from other marks will be ignored.
    
    
      marktype
      String
      The type or marks (arc, rect, etc.) to monitor for input events. Events originating from other mark types will be ignored.
    
    
      throttle
      Number
      The minimum time in milliseconds between captured events (default 0). New events that arrive within the throttling window will be ignored. For timer events, this property determines the interval between timer ticks.
    
  


For example, to capture click events on rect marks:

{"type": "click", "marktype": "rect"}


To capture resize events on the browser window:

{"source": "window", "type": "resize"}


To capture mousedown events on image marks if the control key is pressed and the left mouse button is used:

{
  "type": "mousedown",
  "marktype": "image",
  "filter": ["event.ctrlKey", "event.button === 0"]
}


To capture mousemove events that occur between mousedown and mouseup events:

{
  "type": "mousemove",
  "between": [
    {"type": "mousedown"},
    {"type": "mouseup"}
  ]
}


To capture timer tick events every 2 seconds (2000 milliseconds):

{
  "type": "timer",
  "throttle": 2000
}


Derived Event Streams

In addition to basic streams, an event stream object can serve as input for a derived event stream.


  
    
      Property
      Type
      Description
    
  
  
    
      stream
      EventStream
      Required. An input event stream to modify with additional parameters.
    
  


For example:

{
  "stream": {"marktype": "rect", "type": "click"},
  "filter": "event.shiftKey",
  "debounce": 500
}


Merged Event Streams

A set of event streams can also be merged together.


  
    
      Property
      Type
      Description
    
  
  
    
      merge
      EventStream[ ]
      Required. An array of event streams to merge into a single stream.
    
  


For example:

{
  "merge": [
    {"marktype": "symbol", "type": "mousedown"},
    {"marktype": "symbol", "type": "touchstart"}
  ]
}


Event Stream Selectors

An event selector is a convenient shorthand, inspired by CSS selectors, for defining an event stream of interest.

Basic Selectors

A basic selector specifies an event type, an optional event source, and optional filter expressions.

The general form of a basic selector (using a regexp-style syntax) is:

(source:)?type([filter])*({throttle(,debounce)?})?

The source property supports the following options:


  If undefined, uses the default source property (either view or scope) as described in the source property documentation.
  A valid mark type. For example, arc, image, or rect.
  A mark name prepended by @. For example, @cell. Matching items must have the name property specified in their mark definition.
  The string *, indicating any mark type, but excluding the view component itself.
  The string view or scope, indicating event scopes as described in the source property documentation.
  The string window, indicating the browser window object.
  If none of the above, source will be interpreted as a CSS selector string indicating DOM elements to monitor.


The type property must be one of the supported event types. To indicate that an input event should be consumed (i.e., that event.preventDefault() is called), include an exclamation point (!) at the end of the event type.

One or more filter expressions can be included as bracket-delimited ([]) expressions. If multiple filters are provided, they will be combined into a single filter via boolean “and”. Filter expressions may not make reference to any signals, only to the event object itself.

To throttle or debounce an event stream, add timing information in milliseconds within curly braces ({}) at the end of a selector.

Here are some examples of basic event selectors:

mousedown           // capture all mousedown events, regardless of source
*:mousedown         // mousedown events on marks, but not the view itself
rect:mousedown      // mousedown events on any rect marks
@foo:mousedown      // mousedown events on marks named 'foo'
symbol:mousedown!   // capture and consume mousedown events on symbol marks
window:mousemove    // capture mousemove events from the browser window
mousemove{100}      // throttle the stream by 100 ms
mousemove{100, 200} // also debounce the stream by 200 ms
mousemove{0, 200}   // debounce by 200 ms, but do not throttle
timer{1000}         // capture a timer tick every 1000 ms
mousemove[event.buttons] // mousemove events with any mouse button pressed
click[event.shiftKey]    // click events with the shift key pressed


Merge Selectors

To merge event streams, simply use multiple selectors separated by commas.

selector1, selector2, ...

For example, to capture both mousedown and touchstart events on path marks:

path:mousedown, path:touchstart

Between Filters

To capture events that occur between two other events, use a bracket notation.

[startSelector, stopSelector] > selector

Between filters are particularly useful to capture streams of drag events:

[rect:mousedown, window:mouseup] > window:mousemove

This example initiates a drag upon mousedown on a rect mark, then tracks the drag using events on the browser window. Using the window as the event source lets the drag continue if the mouse pointer leaves the initial rect mark or the view component.

Signal References

Event stream definitions can be signal references:

"on": [
  {
    "events": {"signal": "foo"},
    "update": "..."
  }
]


In this case, an update will be triggered whenever the signal foo changes. Signal references can be combined with event stream objects by providing an array to the events property:

"on": [
  {
    "events": [{"signal": "foo"}, {"type": "click", "marktype": "rect"}],
    "update": "..."
  }
]


Scale References

Event stream definitions can also monitor changes to scales:

"on": [
  {
    "events": {"scale": "xscale"},
    "update": "..."
  }
]


Here, an update is triggered whenever the scale xscale is modified. Scale references can be combined with signal references and event stream objects by providing an array to the events property:

"on": [
  {
    "events": [{"scale": "xscale"}, {"signal": "foo"}],
    "update": "..."
  }
]\nVega
            
              Vega-Lite
              Altair
              Vega-Lite API\nVega-Lite
              Altair
              Vega-Lite API\nExamples
              Tutorials
              Documentation
              Usage
              About
            
            
              GitHub
              Try Online\nExamples
              Tutorials
              Documentation
              Usage
              About\nGitHub
              Try Online\nDocumentation
      
      
      
      
        Specification
      
      
      
      
        Config
      
      
      
      
        Data
      
      
      
      
        Transforms
      
      
      
      
        Triggers
      
      
      
      
        Projections
      
      
      
      
        Scales
      
      
      
      
        Schemes
      
      
      
      
        Axes
      
      
      
      
        Legends
      
      
      
      
        Title
      
      
      
      
        Marks
      
      
      
      
        Signals
      
      
      
      
        Event Streams
      
      
      
      
        Expressions
      
      
      
      
        Layout
      
      
      
      
        Types
      
      
    
  
  
    Event Streams
    Event streams are the primary means of modeling user input to enable dynamic, interactive visualizations. Event streams capture a sequence of input events such as mouse click, touch movement, timer ticks, or signal updates. When events that match a stream definition occur, they cause any corresponding signal event handlers to evaluate, potentially updating a signal value.

{
  "name": "signalName",
  "on": [
    {
      "events": <<event-stream-definition>>,
      "update": ...
    }
  ]
}


An event stream definition can be specified in multiple ways:


  Event stream objects indicate which events to capture.
  Event stream selectors string provide a convenient shorthand for event stream objects. For example, "rect:mouseover", "click[event.shiftKey]", or "timer{1000}".
  Signal references capture signal updates. For example, {"signal": "name"}.
  Scale references capture scale updates. For example, {"scale": "xscale"}.
  An array of multiple event stream objects, signal references, or scale references to capture.


Supported Event Types

The supported DOM event types for mark items are:


  click
  dblclick
  dragenter
  dragleave
  dragover
  keydown
  keypress
  keyup
  mousedown
  mousemove
  mouseout
  mouseover
  mouseup
  mousewheel
  touchend
  touchmove
  touchstart
  wheel


Other event types supported by the browser (e.g., resize events on the window object) may be captured from DOM elements on the same web page as the Vega visualization. The list above applies only to mark items contained within the Vega view’s scenegraph.

In addition, Vega supports a timer event, which fires a new event at a specified time interval (in milliseconds) determined by the event stream throttle property. ≥ 4.0

Event Stream Objects

A basic event stream consists of an event source and type:


  
    
      Property
      Type
      Description
    
  
  
    
      source
      String
      The input event source. For event streams defined in the top-level scope of a Vega specification, this property defaults to "view", which monitors all input events in the current Vega view component (including those targeting the containing Canvas or SVG component itself). For event streams defined within nested scopes, this property defaults to "scope", which limits consideration to only events originating within the group in which the event stream is defined. Othe legal values include "window" for the browser window object, or a CSS selector string indicating external DOM elements. The source property is ignored if the event type is "timer".
    
    
      type
      String
      Required. The event type to monitor (e.g., "click", "keydown", "timer"). For more, see the supported event types list.
    
  


Any event stream object may also include the following properties for filtering or modifying an event stream:


  
    
      Property
      Type
      Description
    
  
  
    
      between
      EventStream[ ]
      A two-element array of event stream objects, indicating sentinel starting and ending events. Only events that occur between these two events will be captured.
    
    
      consume
      Boolean
      A boolean flag (default false) indicating if this stream should consume the event by invoking event.preventDefault(). To control event consumption more globally, see the event handling configuration.
    
    
      filter
      Expression | Expression[ ]
      One or more filter expressions, each of which must evaluate to a truthy value in order for the event to be captured. These expressions may not reference signal values, only event properties.
    
    
      debounce
      Number
      The minimum time to wait between event occurrence and processing. If a new event arrives during a debouncing window, the debounce timer will restart and only the new event will be captured.
    
    
      markname
      String
      The unique name of a mark set for which to monitor input events. Events originating from other marks will be ignored.
    
    
      marktype
      String
      The type or marks (arc, rect, etc.) to monitor for input events. Events originating from other mark types will be ignored.
    
    
      throttle
      Number
      The minimum time in milliseconds between captured events (default 0). New events that arrive within the throttling window will be ignored. For timer events, this property determines the interval between timer ticks.
    
  


For example, to capture click events on rect marks:

{"type": "click", "marktype": "rect"}


To capture resize events on the browser window:

{"source": "window", "type": "resize"}


To capture mousedown events on image marks if the control key is pressed and the left mouse button is used:

{
  "type": "mousedown",
  "marktype": "image",
  "filter": ["event.ctrlKey", "event.button === 0"]
}


To capture mousemove events that occur between mousedown and mouseup events:

{
  "type": "mousemove",
  "between": [
    {"type": "mousedown"},
    {"type": "mouseup"}
  ]
}


To capture timer tick events every 2 seconds (2000 milliseconds):

{
  "type": "timer",
  "throttle": 2000
}


Derived Event Streams

In addition to basic streams, an event stream object can serve as input for a derived event stream.


  
    
      Property
      Type
      Description
    
  
  
    
      stream
      EventStream
      Required. An input event stream to modify with additional parameters.
    
  


For example:

{
  "stream": {"marktype": "rect", "type": "click"},
  "filter": "event.shiftKey",
  "debounce": 500
}


Merged Event Streams

A set of event streams can also be merged together.


  
    
      Property
      Type
      Description
    
  
  
    
      merge
      EventStream[ ]
      Required. An array of event streams to merge into a single stream.
    
  


For example:

{
  "merge": [
    {"marktype": "symbol", "type": "mousedown"},
    {"marktype": "symbol", "type": "touchstart"}
  ]
}


Event Stream Selectors

An event selector is a convenient shorthand, inspired by CSS selectors, for defining an event stream of interest.

Basic Selectors

A basic selector specifies an event type, an optional event source, and optional filter expressions.

The general form of a basic selector (using a regexp-style syntax) is:

(source:)?type([filter])*({throttle(,debounce)?})?

The source property supports the following options:


  If undefined, uses the default source property (either view or scope) as described in the source property documentation.
  A valid mark type. For example, arc, image, or rect.
  A mark name prepended by @. For example, @cell. Matching items must have the name property specified in their mark definition.
  The string *, indicating any mark type, but excluding the view component itself.
  The string view or scope, indicating event scopes as described in the source property documentation.
  The string window, indicating the browser window object.
  If none of the above, source will be interpreted as a CSS selector string indicating DOM elements to monitor.


The type property must be one of the supported event types. To indicate that an input event should be consumed (i.e., that event.preventDefault() is called), include an exclamation point (!) at the end of the event type.

One or more filter expressions can be included as bracket-delimited ([]) expressions. If multiple filters are provided, they will be combined into a single filter via boolean “and”. Filter expressions may not make reference to any signals, only to the event object itself.

To throttle or debounce an event stream, add timing information in milliseconds within curly braces ({}) at the end of a selector.

Here are some examples of basic event selectors:

mousedown           // capture all mousedown events, regardless of source
*:mousedown         // mousedown events on marks, but not the view itself
rect:mousedown      // mousedown events on any rect marks
@foo:mousedown      // mousedown events on marks named 'foo'
symbol:mousedown!   // capture and consume mousedown events on symbol marks
window:mousemove    // capture mousemove events from the browser window
mousemove{100}      // throttle the stream by 100 ms
mousemove{100, 200} // also debounce the stream by 200 ms
mousemove{0, 200}   // debounce by 200 ms, but do not throttle
timer{1000}         // capture a timer tick every 1000 ms
mousemove[event.buttons] // mousemove events with any mouse button pressed
click[event.shiftKey]    // click events with the shift key pressed


Merge Selectors

To merge event streams, simply use multiple selectors separated by commas.

selector1, selector2, ...

For example, to capture both mousedown and touchstart events on path marks:

path:mousedown, path:touchstart

Between Filters

To capture events that occur between two other events, use a bracket notation.

[startSelector, stopSelector] > selector

Between filters are particularly useful to capture streams of drag events:

[rect:mousedown, window:mouseup] > window:mousemove

This example initiates a drag upon mousedown on a rect mark, then tracks the drag using events on the browser window. Using the window as the event source lets the drag continue if the mouse pointer leaves the initial rect mark or the view component.

Signal References

Event stream definitions can be signal references:

"on": [
  {
    "events": {"signal": "foo"},
    "update": "..."
  }
]


In this case, an update will be triggered whenever the signal foo changes. Signal references can be combined with event stream objects by providing an array to the events property:

"on": [
  {
    "events": [{"signal": "foo"}, {"type": "click", "marktype": "rect"}],
    "update": "..."
  }
]


Scale References

Event stream definitions can also monitor changes to scales:

"on": [
  {
    "events": {"scale": "xscale"},
    "update": "..."
  }
]


Here, an update is triggered whenever the scale xscale is modified. Scale references can be combined with signal references and event stream objects by providing an array to the events property:

"on": [
  {
    "events": [{"scale": "xscale"}, {"signal": "foo"}],
    "update": "..."
  }
]\nEvent streams are the primary means of modeling user input to enable dynamic, interactive visualizations. Event streams capture a sequence of input events such as mouse click, touch movement, timer ticks, or signal updates. When events that match a stream definition occur, they cause any corresponding signal event handlers to evaluate, potentially updating a signal value.\nsignal event handlers\n{
  "name": "signalName",
  "on": [
    {
      "events": <<event-stream-definition>>,
      "update": ...
    }
  ]
}\n{
  "name": "signalName",
  "on": [
    {
      "events": <<event-stream-definition>>,
      "update": ...
    }
  ]
}\n<<event-stream-definition>>\nAn event stream definition can be specified in multiple ways:\nEvent stream objects indicate which events to capture.\nEvent stream selectors string provide a convenient shorthand for event stream objects. For example, "rect:mouseover", "click[event.shiftKey]", or "timer{1000}".\nEvent stream selectors\nSignal references capture signal updates. For example, {"signal": "name"}.\nScale references capture scale updates. For example, {"scale": "xscale"}.\nAn array of multiple event stream objects, signal references, or scale references to capture.\nSupported Event Types\nThe supported DOM event types for mark items are:\nOther event types supported by the browser (e.g., resize events on the window object) may be captured from DOM elements on the same web page as the Vega visualization. The list above applies only to mark items contained within the Vega view’s scenegraph.\nIn addition, Vega supports a timer event, which fires a new event at a specified time interval (in milliseconds) determined by the event stream throttle property. ≥ 4.0\nA basic event stream consists of an event source and type:\nThe input event source. For event streams defined in the top-level scope of a Vega specification, this property defaults to "view", which monitors all input events in the current Vega view component (including those targeting the containing Canvas or SVG component itself). For event streams defined within nested scopes, this property defaults to "scope", which limits consideration to only events originating within the group in which the event stream is defined. Othe legal values include "window" for the browser window object, or a CSS selector string indicating external DOM elements. The source property is ignored if the event type is "timer".\nRequired. The event type to monitor (e.g., "click", "keydown", "timer"). For more, see the supported event types list.\nsupported event types list\nAny event stream object may also include the following properties for filtering or modifying an event stream:\nA two-element array of event stream objects, indicating sentinel starting and ending events. Only events that occur between these two events will be captured.\nA boolean flag (default false) indicating if this stream should consume the event by invoking event.preventDefault(). To control event consumption more globally, see the event handling configuration.\nevent.preventDefault()\nevent handling configuration\nExpression | Expression[ ]\nOne or more filter expressions, each of which must evaluate to a truthy value in order for the event to be captured. These expressions may not reference signal values, only event properties.\nThe minimum time to wait between event occurrence and processing. If a new event arrives during a debouncing window, the debounce timer will restart and only the new event will be captured.\nThe unique name of a mark set for which to monitor input events. Events originating from other marks will be ignored.\nThe type or marks (arc, rect, etc.) to monitor for input events. Events originating from other mark types will be ignored.\nThe minimum time in milliseconds between captured events (default 0). New events that arrive within the throttling window will be ignored. For timer events, this property determines the interval between timer ticks.\nFor example, to capture click events on rect marks:\n{"type": "click", "marktype": "rect"}\n{"type": "click", "marktype": "rect"}\nTo capture resize events on the browser window:\n{"source": "window", "type": "resize"}\n{"source": "window", "type": "resize"}\nTo capture mousedown events on image marks if the control key is pressed and the left mouse button is used:\n{
  "type": "mousedown",
  "marktype": "image",
  "filter": ["event.ctrlKey", "event.button === 0"]
}\n{
  "type": "mousedown",
  "marktype": "image",
  "filter": ["event.ctrlKey", "event.button === 0"]
}\nTo capture mousemove events that occur between mousedown and mouseup events:\n{
  "type": "mousemove",
  "between": [
    {"type": "mousedown"},
    {"type": "mouseup"}
  ]
}\n{
  "type": "mousemove",
  "between": [
    {"type": "mousedown"},
    {"type": "mouseup"}
  ]
}\nTo capture timer tick events every 2 seconds (2000 milliseconds):\n{
  "type": "timer",
  "throttle": 2000
}\n{
  "type": "timer",
  "throttle": 2000
}\nDerived Event Streams\nIn addition to basic streams, an event stream object can serve as input for a derived event stream.\nRequired. An input event stream to modify with additional parameters.\n{
  "stream": {"marktype": "rect", "type": "click"},
  "filter": "event.shiftKey",
  "debounce": 500
}\n{
  "stream": {"marktype": "rect", "type": "click"},
  "filter": "event.shiftKey",
  "debounce": 500
}\nA set of event streams can also be merged together.\nRequired. An array of event streams to merge into a single stream.\n{
  "merge": [
    {"marktype": "symbol", "type": "mousedown"},
    {"marktype": "symbol", "type": "touchstart"}
  ]
}\n{
  "merge": [
    {"marktype": "symbol", "type": "mousedown"},
    {"marktype": "symbol", "type": "touchstart"}
  ]
}\nEvent Stream Selectors\nAn event selector is a convenient shorthand, inspired by CSS selectors, for defining an event stream of interest.\nA basic selector specifies an event type, an optional event source, and optional filter expressions.\nThe general form of a basic selector (using a regexp-style syntax) is:\n(source:)?type([filter])*({throttle(,debounce)?})?\nThe source property supports the following options:\nIf undefined, uses the default source property (either view or scope) as described in the source property documentation.\nsource property documentation\nA valid mark type. For example, arc, image, or rect.\nA mark name prepended by @. For example, @cell. Matching items must have the name property specified in their mark definition.\nThe string *, indicating any mark type, but excluding the view component itself.\nThe string view or scope, indicating event scopes as described in the source property documentation.\nsource property documentation\nThe string window, indicating the browser window object.\nbrowser window object\nIf none of the above, source will be interpreted as a CSS selector string indicating DOM elements to monitor.\nThe type property must be one of the supported event types. To indicate that an input event should be consumed (i.e., that event.preventDefault() is called), include an exclamation point (!) at the end of the event type.\nsupported event types\nevent.preventDefault()\nOne or more filter expressions can be included as bracket-delimited ([]) expressions. If multiple filters are provided, they will be combined into a single filter via boolean “and”. Filter expressions may not make reference to any signals, only to the event object itself.\nTo throttle or debounce an event stream, add timing information in milliseconds within curly braces ({}) at the end of a selector.\nHere are some examples of basic event selectors:\nmousedown           // capture all mousedown events, regardless of source
*:mousedown         // mousedown events on marks, but not the view itself
rect:mousedown      // mousedown events on any rect marks
@foo:mousedown      // mousedown events on marks named 'foo'
symbol:mousedown!   // capture and consume mousedown events on symbol marks
window:mousemove    // capture mousemove events from the browser window
mousemove{100}      // throttle the stream by 100 ms
mousemove{100, 200} // also debounce the stream by 200 ms
mousemove{0, 200}   // debounce by 200 ms, but do not throttle
timer{1000}         // capture a timer tick every 1000 ms
mousemove[event.buttons] // mousemove events with any mouse button pressed
click[event.shiftKey]    // click events with the shift key pressed\nmousedown           // capture all mousedown events, regardless of source
*:mousedown         // mousedown events on marks, but not the view itself
rect:mousedown      // mousedown events on any rect marks
@foo:mousedown      // mousedown events on marks named 'foo'
symbol:mousedown!   // capture and consume mousedown events on symbol marks
window:mousemove    // capture mousemove events from the browser window
mousemove{100}      // throttle the stream by 100 ms
mousemove{100, 200} // also debounce the stream by 200 ms
mousemove{0, 200}   // debounce by 200 ms, but do not throttle
timer{1000}         // capture a timer tick every 1000 ms
mousemove[event.buttons] // mousemove events with any mouse button pressed
click[event.shiftKey]    // click events with the shift key pressed\nTo merge event streams, simply use multiple selectors separated by commas.\nselector1, selector2, ...\nFor example, to capture both mousedown and touchstart events on path marks:\npath:mousedown, path:touchstart\nTo capture events that occur between two other events, use a bracket notation.\n[startSelector, stopSelector] > selector\nBetween filters are particularly useful to capture streams of drag events:\n[rect:mousedown, window:mouseup] > window:mousemove\nThis example initiates a drag upon mousedown on a rect mark, then tracks the drag using events on the browser window. Using the window as the event source lets the drag continue if the mouse pointer leaves the initial rect mark or the view component.\nEvent stream definitions can be signal references:\n"on": [
  {
    "events": {"signal": "foo"},
    "update": "..."
  }
]\n"on": [
  {
    "events": {"signal": "foo"},
    "update": "..."
  }
]\nIn this case, an update will be triggered whenever the signal foo changes. Signal references can be combined with event stream objects by providing an array to the events property:\n"on": [
  {
    "events": [{"signal": "foo"}, {"type": "click", "marktype": "rect"}],
    "update": "..."
  }
]\n"on": [
  {
    "events": [{"signal": "foo"}, {"type": "click", "marktype": "rect"}],
    "update": "..."
  }
]\nEvent stream definitions can also monitor changes to scales:\n"on": [
  {
    "events": {"scale": "xscale"},
    "update": "..."
  }
]\n"on": [
  {
    "events": {"scale": "xscale"},
    "update": "..."
  }
]\nHere, an update is triggered whenever the scale xscale is modified. Scale references can be combined with signal references and event stream objects by providing an array to the events property:\n"on": [
  {
    "events": [{"scale": "xscale"}, {"signal": "foo"}],
    "update": "..."
  }
]\n"on": [
  {
    "events": [{"scale": "xscale"}, {"signal": "foo"}],
    "update": "..."
  }
]\n\n\nVega
            
              Vega-Lite
              Altair
              Vega-Lite API
            
          
          
            
              Examples
              Tutorials
              Documentation
              Usage
              About
            
            
              GitHub
              Try Online
            
          
        
      

      
        

  
  
    
      
      
        Documentation
      
      
      
      
        Specification
      
      
      
      
        Config
      
      
      
      
        Data
      
      
      
      
        Transforms
      
      
      
      
        Triggers
      
      
      
      
        Projections
      
      
      
      
        Scales
      
      
      
      
        Schemes
      
      
      
      
        Axes
      
      
      
      
        Legends
      
      
      
      
        Title
      
      
      
      
        Marks
      
      
      
      
        Signals
      
      
      
      
        Event Streams
      
      
      
      
        Expressions
      
      
      
      
        Layout
      
      
      
      
        Types
      
      
    
  
  
    Expressions
    To enable custom calculations, Vega includes its own expression language for writing basic formulas. For example, these expressions are used by the filter and formula transforms to modify data, and within signal definitions to calculate updated values in response to user input.

The expression language is a restricted subset of JavaScript. All basic arithmetic, logical and property access expressions are supported, as are boolean, number, string, object ({}) and array ([]) literals.  Ternary operators (ifTest ? thenValue : elseValue) and a special if(test, thenValue, elseValue) function are supported.

To keep the expression language simple, secure and free of unwanted side effects, the following elements are not allowed: assignment operators (=, += etc), pre/postfix updates (++), new expressions, and most control flow statements (for, while, switch, etc). In addition, function calls involving nested properties (foo.bar()) are not allowed. Instead, the expression language supports a collection of functions defined in the top-level scope.

This page documents the expression language. If you are interested in implementation aspects, the bulk of the expression language – including parsing, code generation, and some of the constant and function definitions – is provided by the vega-expression module.

Expression Language Reference


  Bound Variables
  Constants
  Type Checking Functions
  Type Coercion Functions
  Control Flow Functions
  Math Functions
  Statistical Functions
  Date-Time Functions
  Array Functions
  String Functions
  Object Functions
  Formatting Functions
  Regular Expression Functions
  Color Functions
  Event Functions
  Data Functions
  Scale & Projection Functions
  Geographic Functions
  Tree (Hierarchy) Functions
  Browser Functions
  Logging Functions


Bound Variables

The expression language includes a number of automatically-bound named variables.

#
datum

The current input data object, available within data transform and event handler expressions. To lookup object properties, use normal JavaScript syntax: datum.value or datum['My Value'].

#
event

If the expression is being invoked in response to an event, an event variable is defined. This variable consists of a standard JavaScript DOM event, providing access to bound properties of the event, such as event.metaKey or event.keyCode.

#
signal names

Any in-scope signal value can be referenced directly by name. For example, if you have defined a signal named hover within your Vega specification, you can refer to it directly within an expression (e.g., hover.value). Similarly, to lookup an object property whose name is bound to the signal property_name, you could use datum[property_name].

Back to Top

Constants

Constant values that can be referenced by name within expressions.

#
NaN
Not a number. Same as the JavaScript literal NaN.

#
E
The transcendental number e. Same as JavaScript’s Math.E.

#
LN2
The natural log of 2. Same as JavaScript’s Math.LN2.

#
LN10
The natural log of 10. Same as JavaScript’s Math.LN10.

#
LOG2E
The base 2 logarithm of e. Same as JavaScript’s Math.LOG2E.

#
LOG10E
The base 10 logarithm e. Same as JavaScript’s Math.LOG10E.

#
MAX_VALUE
The largest positive numeric value. Same as JavaScript’s Number.MAX_VALUE.

#
MIN_VALUE
The smallest positive numeric value. Same as JavaScript’s Number.MIN_VALUE.

#
PI
The transcendental number π. Same as JavaScript’s Math.PI.

#
SQRT1_2
The square root of 0.5. Same as JavaScript’s Math.SQRT1_2.

#
SQRT2
The square root of 2. Same as JavaScript’s Math.SQRT2.

Back to Top

Type Checking Functions

Predicate functions for checking value types.

#
isArray(value)
Returns true if value is an array, false otherwise.

#
isBoolean(value)
Returns true if value is a boolean (true or false), false otherwise.

#
isDate(value)
Returns true if value is a Date object, false otherwise. This method will return false for timestamp numbers or date-formatted strings; it recognizes Date objects only.

#
isDefined(value) ≥ 5.4
Returns true if value is a defined value, false if value equals undefined. This method will return true for null and NaN values.

#
isNumber(value)
Returns true if value is a number, false otherwise. NaN and Infinity are considered numbers.

#
isObject(value)
Returns true if value is an object (including arrays and Dates), false otherwise.

#
isRegExp(value)
Returns true if value is a RegExp (regular expression) object, false otherwise.

#
isString(value)
Returns true if value is a string, false otherwise.

#
isValid(value) ≥ 5.4
Returns true if value is not null, undefined, or NaN, false otherwise.

Back to Top

Type Coercion Functions

Functions for coercing values to a desired type.

#
toBoolean(value)
Coerces the input value to a string. Null values and empty strings are mapped to null.

#
toDate(value)
Coerces the input value to a Date instance. Null values and empty strings are mapped to null. If an optional parser function is provided, it is used to perform date parsing, otherwise Date.parse is used. Be aware that Date.parse has different implementations across browsers!

#
toNumber(value)
Coerces the input value to a number. Null values and empty strings are mapped to null.

#
toString(value)
Coerces the input value to a string. Null values and empty strings are mapped to null.

Control Flow Functions

#
if(test, thenValue, elseValue)
If test is truthy, returns thenValue. Otherwise, returns elseValue. The if function is equivalent to the ternary operator a ? b : c.

Back to Top

Math Functions

Basic mathematical functions.

#
isNaN(value)
Returns true if value is not a number. Same as JavaScript’s Number.isNaN.

#
isFinite(value)
Returns true if value is a finite number. Same as JavaScript’s Number.isFinite.

#
abs(value)
Returns the absolute value of value. Same as JavaScript’s Math.abs.

#
acos(value)
Trigonometric arccosine. Same as JavaScript’s Math.acos.

#
asin(value)
Trigonometric arcsine. Same as JavaScript’s Math.asin.

#
atan(value)
Trigonometric arctangent. Same as JavaScript’s Math.atan.

#
atan2(dy, dx)
Returns the arctangent of dy / dx. Same as JavaScript’s Math.atan2.

#
ceil(value)
Rounds value to the nearest integer of equal or greater value. Same as JavaScript’s Math.ceil.

#
clamp(value, min, max)
Restricts value to be between the specified min and max.

#
cos(value)
Trigonometric cosine. Same as JavaScript’s Math.cos.

#
exp(exponent)
Returns the value of e raised to the provided exponent. Same as JavaScript’s Math.exp.

#
floor(value)
Rounds value to the nearest integer of equal or lower value. Same as JavaScript’s Math.floor.

#
hypot(value)
Returns the square root of the sum of squares of its arguments. Same as JavaScript’s Math.hypot.

#
log(value)
Returns the natural logarithm of value. Same as JavaScript’s Math.log.

#
max(value1, value2, …)
Returns the maximum argument value. Same as JavaScript’s Math.max.

#
min(value1, value2, …)
Returns the minimum argument value. Same as JavaScript’s Math.min.

#
pow(value, exponent)
Returns value raised to the given exponent. Same as JavaScript’s Math.pow.

#
random()
Returns a pseudo-random number in the range [0,1). Same as JavaScript’s Math.random.

#
round(value)
Rounds value to the nearest integer. Same as JavaScript’s Math.round.

#
sin(value)
Trigonometric sine. Same as JavaScript’s Math.sin.

#
sqrt(value)
Square root function. Same as JavaScript’s Math.sqrt.

#
tan(value)
Trigonometric tangent. Same as JavaScript’s Math.tan.

Back to Top

Statistical Functions

Methods for sampling and calculating values for probability distributions.

#
sampleNormal([mean, stdev]) ≥ 5.7
Returns a sample from a univariate normal (Gaussian) probability distribution with specified mean and standard deviation stdev. If unspecified, the mean defaults to 0 and the standard deviation defaults to 1.

#
cumulativeNormal(value[, mean, stdev]) ≥ 5.7
Returns the value of the cumulative distribution function at the given input domain value for a normal distribution with specified mean and standard deviation stdev. If unspecified, the mean defaults to 0 and the standard deviation defaults to 1.

#
densityNormal(value[, mean, stdev]) ≥ 5.7
Returns the value of the probability density function at the given input domain value, for a normal distribution with specified mean and standard deviation stdev. If unspecified, the mean defaults to 0 and the standard deviation defaults to 1.

#
quantileNormal(probability[, mean, stdev]) ≥ 5.7
Returns the quantile value (the inverse of the cumulative distribution function) for the given input probability, for a normal distribution with specified mean and standard deviation stdev. If unspecified, the mean defaults to 0 and the standard deviation defaults to 1.

#
sampleLogNormal([mean, stdev]) ≥ 5.7
Returns a sample from a univariate log-normal probability distribution with specified log mean and log standard deviation stdev. If unspecified, the log mean defaults to 0 and the log standard deviation defaults to 1.

#
cumulativeLogNormal(value[, mean, stdev]) ≥ 5.7
Returns the value of the cumulative distribution function at the given input domain value for a log-normal distribution with specified log mean and log standard deviation stdev. If unspecified, the log mean defaults to 0 and the log standard deviation defaults to 1.

#
densityLogNormal(value[, mean, stdev]) ≥ 5.7
Returns the value of the probability density function at the given input domain value, for a log-normal distribution with specified log mean and log standard deviation stdev. If unspecified, the log mean defaults to 0 and the log standard deviation defaults to 1.

#
quantileLogNormal(probability[, mean, stdev]) ≥ 5.7
Returns the quantile value (the inverse of the cumulative distribution function) for the given input probability, for a log-normal distribution with specified log mean and log standard deviation stdev. If unspecified, the log mean defaults to 0 and the log standard deviation defaults to 1.

#
sampleUniform([min, max]) ≥ 5.7
Returns a sample from a univariate continuous uniform probability distribution over the interval [min, max). If unspecified, min defaults to 0 and max defaults to 1. If only one argument is provided, it is interpreted as the max value.

#
cumulativeUniform(value[, min, max]) ≥ 5.7
Returns the value of the cumulative distribution function at the given input domain value for a uniform distribution over the interval [min, max). If unspecified, min defaults to 0 and max defaults to 1. If only one argument is provided, it is interpreted as the max value.

#
densityUniform(value[, min, max]) ≥ 5.7
Returns the value of the probability density function at the given input domain value,  for a uniform distribution over the interval [min, max). If unspecified, min defaults to 0 and max defaults to 1. If only one argument is provided, it is interpreted as the max value.

#
quantileUniform(probability[, min, max]) ≥ 5.7
Returns the quantile value (the inverse of the cumulative distribution function) for the given input probability,  for a uniform distribution over the interval [min, max). If unspecified, min defaults to 0 and max defaults to 1. If only one argument is provided, it is interpreted as the max value.

Back to Top

Date-Time Functions

Functions for working with date-time values.

#
now()
Returns the timestamp for the current time.

#
datetime(year, month[, day, hour, min, sec, millisec])
Returns a new Date instance. The month is 0-based, such that 1 represents February.

#
date(datetime)
Returns the day of the month for the given datetime value, in local time.

#
day(datetime)
Returns the day of the week for the given datetime value, in local time.

#
dayofyear(datetime) ≥ 5.11
Returns the one-based day of the year for the given datetime value, in local time.

#
year(datetime)
Returns the year for the given datetime value, in local time.

#
quarter(datetime)
Returns the quarter of the year (0-3) for the given datetime value, in local time.

#
month(datetime)
Returns the (zero-based) month for the given datetime value, in local time.

#
week(date) ≥ 5.11
Returns the week number of the year for the given datetime, in local time. This function assumes Sunday-based weeks. Days before the first Sunday of the year are considered to be in week 0, the first Sunday of the year is the start of week 1, the second Sunday week 2, etc..

#
hours(datetime)
Returns the hours component for the given datetime value, in local time.

#
minutes(datetime)
Returns the minutes component for the given datetime value, in local time.

#
seconds(datetime)
Returns the seconds component for the given datetime value, in local time.

#
milliseconds(datetime)
Returns the milliseconds component for the given datetime value, in local time.

#
time(datetime)
Returns the epoch-based timestamp for the given datetime value.

#
timezoneoffset(datetime)
Returns the timezone offset from the local timezone to UTC for the given datetime value.

#
timeOffset(unit, date[, step]) ≥ 5.8
Returns a new Date instance that offsets the given date by the specified time unit in the local timezone. The optional step argument indicates the number of time unit steps to offset by (default 1).

#
timeSequence(unit, start, stop[, step]) ≥ 5.8
Returns an array of Date instances from start (inclusive) to stop (exclusive), with each entry separated by the given time unit in the local timezone. The optional step argument indicates the number of time unit steps to take between each sequence entry (default 1).

#
utc(year, month[, day, hour, min, sec, millisec])
Returns a timestamp for the given UTC date. The month is 0-based, such that 1 represents February.

#
utcdate(datetime)
Returns the day of the month for the given datetime value, in UTC time.

#
utcday(datetime)
Returns the day of the week for the given datetime value, in UTC time.

#
utcdayofyear(datetime) ≥ 5.11
Returns the one-based day of the year for the given datetime value, in UTC time.

#
utcyear(datetime)
Returns the year for the given datetime value, in UTC time.

#
utcquarter(datetime)
Returns the quarter of the year (0-3) for the given datetime value, in UTC time.

#
utcmonth(datetime)
Returns the (zero-based) month for the given datetime value, in UTC time.

#
utcweek(date) ≥ 5.11
Returns the week number of the year for the given datetime, in UTC time. This function assumes Sunday-based weeks. Days before the first Sunday of the year are considered to be in week 0, the first Sunday of the year is the start of week 1, the second Sunday week 2, etc..

#
utchours(datetime)
Returns the hours component for the given datetime value, in UTC time.

#
utcminutes(datetime)
Returns the minutes component for the given datetime value, in UTC time.

#
utcseconds(datetime)
Returns the seconds component for the given datetime value, in UTC time.

#
utcmilliseconds(datetime)
Returns the milliseconds component for the given datetime value, in UTC time.

#
utcOffset(unit, date[, step]) ≥ 5.8
Returns a new Date instance that offsets the given date by the specified time unit in UTC time. The optional step argument indicates the number of time unit steps to offset by (default 1).

#
utcSequence(unit, start, stop[, step]) ≥ 5.8
Returns an array of Date instances from start (inclusive) to stop (exclusive), with each entry separated by the given time unit in UTC time. The optional step argument indicates the number of time unit steps to take between each sequence entry (default 1).

Back to Top

Array Functions

Functions for working with arrays of values.

#
extent(array) ≥ 4.0
Returns a new [min, max] array with the minimum and maximum values of the input array, ignoring null, undefined, and NaN values.

#
clampRange(range, min, max)
Clamps a two-element range array in a span-preserving manner. If the span of the input range is less than (max - min) and an endpoint exceeds either the min or max value, the range is translated such that the span is preserved and one endpoint touches the boundary of the [min, max] range. If the span exceeds (max - min), the range [min, max] is returned.

#
indexof(array, value)
Returns the first index of value in the input array.

#
inrange(value, range)
Tests whether value lies within (or is equal to either) the first and last values of the range array.

#
join(array[, separator]) ≥ 5.3
Returns a new string by concatenating all of the elements of the input array, separated by commas or a specified separator string.

#
lastindexof(array, value)
Returns the last index of value in the input array.

#
length(array)
Returns the length of the input array.

#
lerp(array, fraction)
Returns the linearly interpolated value between the first and last entries in the array for the provided interpolation fraction (typically between 0 and 1). For example, lerp([0, 50], 0.5) returns 25.

#
peek(array)
Returns the last element in the input array. Similar to the built-in Array.pop method, except that it does not remove the last element. This method is a convenient shorthand for array[array.length - 1].

#
pluck(array, field) ≥ 5.19
Retrieves the value for the specified field from a given array of objects. The input field string may include nested properties (e.g., foo.bar.bz).

#
reverse(array) ≥ 5.3
Returns a new array with elements in a reverse order of the input array. The first array element becomes the last, and the last array element becomes the first.

#
sequence([start, ]stop[, step])
Returns an array containing an arithmetic sequence of numbers. If step is omitted, it defaults to 1. If start is omitted, it defaults to 0. The stop value is exclusive; it is not included in the result. If step is positive, the last element is the largest start + i * step less than stop; if step is negative, the last element is the smallest start + i * step greater than stop. If the returned array would contain an infinite number of values, an empty range is returned. The arguments are not required to be integers.

#
slice(array, start[, end])
Returns a section of array between the start and end indices. If the end argument is negative, it is treated as an offset from the end of the array (length(array) + end).

#
sort(array)≥ 5.31
Sorts the array in natural order using ascending from Vega Utils.

#
span(array)
Returns the span of array: the difference between the last and first elements, or array[array.length-1] - array[0].

Back to Top

String Functions

Functions for modifying text strings.

#
indexof(string, substring)
Returns the first index of substring in the input string.

#
lastindexof(string, substring)
Returns the last index of substring in the input string.

#
length(string)
Returns the length of the input string.

#
lower(string)
Transforms string to lower-case letters.

#
pad(string, length[, character, align])
Pads a string value with repeated instances of a character up to a specified length. If character is not specified, a space (‘ ‘) is used. By default, padding is added to the end of a string. An optional align parameter specifies if padding should be added to the 'left' (beginning), 'center', or 'right' (end) of the input string.

#
parseFloat(string)
Parses the input string to a floating-point value. Same as JavaScript’s parseFloat.

#
parseInt(string)
Parses the input string to an integer value. Same as JavaScript’s parseInt.

#
replace(string, pattern, replacement)
Returns a new string with some or all matches of pattern replaced by a replacement string. The pattern can be a string or a regular expression. If pattern is a string, only the first instance will be replaced. Same as JavaScript’s String.replace.

#
slice(string, start[, end])
Returns a section of string between the start and end indices. If the end argument is negative, it is treated as an offset from the end of the string (length(string) + end).

#
split(string, separator[, limit]) ≥ 4.3
Returns an array of tokens created by splitting the input string according to a provided separator pattern. The result can optionally be constrained to return at most limit tokens.

#
substring(string, start[, end])
Returns a section of string between the start and end indices.

#
trim(string) ≥ 5.3
Returns a trimmed string with preceding and trailing whitespace removed.

#
truncate(string, length[, align, ellipsis])
Truncates an input string to a target length. The optional align argument indicates what part of the string should be truncated: 'left' (the beginning), 'center', or 'right' (the end). By default, the 'right' end of the string is truncated. The optional ellipsis argument indicates the string to use to indicate truncated content; by default the ellipsis character … (\u2026) is used.

#
upper(string)
Transforms string to upper-case letters.

#
btoa(string) ≥ 5.32.0
Creates a Base64-encoded ASCII string. Same as JavaScript’s Window.btoa().

#
atob(string) ≥ 5.32.0
Decodes an ASCII string that was encoded with Base64. Same as JavaScript’s Window.atob().

Back to Top

Object Functions

Functions for manipulating object instances.

#
merge(object1[, object2, …]) ≥ 4.0
Merges the input objects object1, object2, etc into a new output object. Inputs are visited in sequential order, such that key values from later arguments can overwrite those from earlier arguments. Example: merge({a:1, b:2}, {a:3}) -> {a:3, b:2}.

Back to Top

Formatting Functions

Functions for formatting number and datetime values as strings.

#
dayFormat(day)
Formats a (0-6) weekday number as a full week day name, according to the current locale. For example: dayFormat(0) -> "Sunday".

#
dayAbbrevFormat(day)
Formats a (0-6) weekday number as an abbreviated week day name, according to the current locale. For example: dayAbbrevFormat(0) -> "Sun".

#
format(value, specifier)
Formats a numeric value as a string. The specifier must be a valid d3-format specifier (e.g., format(value, ',.2f').
Null values are formatted as "null".

#
monthFormat(month)
Formats a (zero-based) month number as a full month name, according to the current locale. For example: monthFormat(0) -> "January".

#
monthAbbrevFormat(month)
Formats a (zero-based) month number as an abbreviated month name, according to the current locale. For example: monthAbbrevFormat(0) -> "Jan".

#
timeUnitSpecifier(units[, specifiers]) ≥ 5.8
Returns a time format specifier string for the given time units. The optional specifiers object provides a set of specifier sub-strings for customizing the format; for more, see the timeUnitSpecifier API documentation. The resulting specifier string can then be used as input to the timeFormat or utcFormat functions, or as the format parameter of an axis or legend. For example: timeFormat(date, timeUnitSpecifier('year')) or timeFormat(date, timeUnitSpecifier(['hours', 'minutes'])).

#
timeFormat(value, specifier)
Formats a datetime value (either a Date object or timestamp) as a string, according to the local time. The specifier must be a valid d3-time-format specifier or TimeMultiFormat object ≥ 5.8. For example: timeFormat(timestamp, '%A').
Null values are formatted as "null".

#
timeParse(string, specifier)
Parses a string value to a Date object, according to the local time. The specifier must be a valid d3-time-format specifier. For example: timeParse('June 30, 2015', '%B %d, %Y').

#
utcFormat(value, specifier)
Formats a datetime value (either a Date object or timestamp) as a string, according to UTC time. The specifier must be a valid d3-time-format specifier or TimeMultiFormat object ≥ 5.8. For example: utcFormat(timestamp, '%A').
Null values are formatted as "null".

#
utcParse(value, specifier)
Parses a string value to a Date object, according to UTC time. The specifier must be a valid d3-time-format specifier. For example: utcParse('June 30, 2015', '%B %d, %Y').

Back to Top

RegExp Functions

Functions for creating and applying regular expressions.

#
regexp(pattern[, flags]) -
Creates a regular expression instance from an input pattern string and optional flags. Same as JavaScript’s RegExp.

#
test(regexp[, string]) -
Evaluates a regular expression regexp against the input string, returning true if the string matches the pattern, false otherwise. For example: test(/\\d{3}/, "32-21-9483") -> true.

Back to Top

Color Functions

Functions for representing colors in various color spaces. Color functions return objects that, when coerced to a string, map to valid CSS RGB colors.

#
rgb(r, g, b[, opacity]) |
rgb(specifier)
Constructs a new RGB color. If r, g and b are specified, these represent the channel values of the returned color; an opacity may also be specified. If a CSS Color Module Level 3 specifier string is specified, it is parsed and then converted to the RGB color space. Uses d3-color’s rgb function.

#
hsl(h, s, l[, opacity]) |
hsl(specifier)
Constructs a new HSL color. If h, s and l are specified, these represent the channel values of the returned color; an opacity may also be specified. If a CSS Color Module Level 3 specifier string is specified, it is parsed and then converted to the HSL color space. Uses d3-color’s hsl function.

#
lab(l, a, b[, opacity]) |
lab(specifier)
Constructs a new CIE LAB color. If l, a and b are specified, these represent the channel values of the returned color; an opacity may also be specified. If a CSS Color Module Level 3 specifier string is specified, it is parsed and then converted to the LAB color space. Uses d3-color’s lab function.

#
hcl(h, c, l[, opacity]) |
hcl(specifier)
Constructs a new HCL (hue, chroma, luminance) color. If h, c and l are specified, these represent the channel values of the returned color; an opacity may also be specified. If a CSS Color Module Level 3 specifier string is specified, it is parsed and then converted to the HCL color space. Uses d3-color’s hcl function.

#
luminance(specifier) ≥ 5.7
Returns the luminance for the given color specifier (compatible with d3-color’s rgb function). The luminance is calculated according to the W3C Web Content Accessibility Guidelines.

#
contrast(specifier1, specifier2) ≥ 5.7
Returns the contrast ratio between the input color specifiers as a float between 1 and 21. The contrast is calculated according to the W3C Web Content Accessibility Guidelines.

Back to Top

Event Functions

Functions for processing input event data. These functions are only legal in expressions evaluated in response to an event (for example a signal event handler). Invoking these functions elsewhere can result in errors.

#
item()
Returns the current scenegraph item that is the target of the event.

#
group([name])
Returns the scenegraph group mark item in which the current event has occurred. If no arguments are provided, the immediate parent group is returned. If a group name is provided, the matching ancestor group item is returned.

#
xy([item])
Returns the x- and y-coordinates for the current event as a two-element array. If no arguments are provided, the top-level coordinate space of the view is used. If a scenegraph item (or string group name) is provided, the coordinate space of the group item is used.

#
x([item])
Returns the x coordinate for the current event. If no arguments are provided, the top-level coordinate space of the view is used. If a scenegraph item (or string group name) is provided, the coordinate space of the group item is used.

#
y([item])
Returns the y coordinate for the current event. If no arguments are provided, the top-level coordinate space of the view is used. If a scenegraph item (or string group name) is provided, the coordinate space of the group item is used.

#
pinchDistance(event)
Returns the pixel distance between the first two touch points of a multi-touch event.

#
pinchAngle(event)
Returns the angle of the line connecting the first two touch points of a multi-touch event.

#
inScope(item)
Returns true if the given scenegraph item is a descendant of the group mark in which the event handler was defined, false otherwise.

Back to Top

Data Functions

Functions for accessing Vega data sets.

#
data(name)
Returns the array of data objects for the Vega data set with the given name. If the data set is not found, returns an empty array.

#
indata(name, field, value)
Tests if the data set with a given name contains a datum with a field value that matches the input value. For example: indata('table', 'category', value).

Back to Top

Scale and Projection Functions

Functions for working with Vega scale transforms and cartographic projections.

#
scale(name, value[, group])
Applies the named scale transform (or projection) to the specified value. The optional group argument takes a scenegraph group mark item to indicate the specific scope in which to look up the scale or projection.

#
invert(name, value[, group])
Inverts the named scale transform (or projection) for the specified value. The optional group argument takes a scenegraph group mark item to indicate the specific scope in which to look up the scale or projection.

#
copy(name[, group])
Returns a copy (a new cloned instance) of the named scale transform of projection, or undefined if no scale or projection is found. The optional group argument takes a scenegraph group mark item to indicate the specific scope in which to look up the scale or projection.

#
domain(name[, group])
Returns the scale domain array for the named scale transform, or an empty array if the scale is not found. The optional group argument takes a scenegraph group mark item to indicate the specific scope in which to look up the scale.

#
range(name[, group])
Returns the scale range array for the named scale transform, or an empty array if the scale is not found. The optional group argument takes a scenegraph group mark item to indicate the specific scope in which to look up the scale.

#
bandwidth(name[, group])
Returns the current band width for the named band scale transform, or zero if the scale is not found or is not a band scale. The optional group argument takes a scenegraph group mark item to indicate the specific scope in which to look up the scale.

#
bandspace(count[, paddingInner, paddingOuter])
Returns the number of steps needed within a band scale, based on the count of domain elements and the inner and outer padding values. While normally calculated within the scale itself, this function can be helpful for determining the size of a chart’s layout.

#
gradient(scale, p0, p1[, count])
Returns a linear color gradient for the scale (whose range must be a continuous color scheme) and starting and ending points p0 and p1, each an [x, y] array. The points p0 and p1 should be expressed in normalized coordinates in the domain [0, 1], relative to the bounds of the item being colored. If unspecified, p0 defaults to [0, 0] and p1 defaults to [1, 0], for a horizontal gradient that spans the full bounds of an item. The optional count argument indicates a desired target number of sample points to take from the color scale.

#
panLinear(domain, delta)
Given a linear scale domain array with numeric or datetime values, returns a new two-element domain array that is the result of panning the domain by a fractional delta. The delta value represents fractional units of the scale range; for example, 0.5 indicates panning the scale domain to the right by half the scale range.

#
panLog(domain, delta)
Given a log scale domain array with numeric or datetime values, returns a new two-element domain array that is the result of panning the domain by a fractional delta. The delta value represents fractional units of the scale range; for example, 0.5 indicates panning the scale domain to the right by half the scale range.

#
panPow(domain, delta, exponent)
Given a power scale domain array with numeric or datetime values and the given exponent, returns a new two-element domain array that is the result of panning the domain by a fractional delta. The delta value represents fractional units of the scale range; for example, 0.5 indicates panning the scale domain to the right by half the scale range.

#
panSymlog(domain, delta, constant)
Given a symmetric log scale domain array with numeric or datetime values parameterized by the given constant, returns a new two-element domain array that is the result of panning the domain by a fractional delta. The delta value represents fractional units of the scale range; for example, 0.5 indicates panning the scale domain to the right by half the scale range.

#
zoomLinear(domain, anchor, scaleFactor)
Given a linear scale domain array with numeric or datetime values, returns a new two-element domain array that is the result of zooming the domain by a scaleFactor, centered at the provided fractional anchor. The anchor value represents the zoom position in terms of fractional units of the scale range; for example, 0.5 indicates a zoom centered on the mid-point of the scale range.

#
zoomLog(domain, anchor, scaleFactor)
Given a log scale domain array with numeric or datetime values, returns a new two-element domain array that is the result of zooming the domain by a scaleFactor, centered at the provided fractional anchor. The anchor value represents the zoom position in terms of fractional units of the scale range; for example, 0.5 indicates a zoom centered on the mid-point of the scale range.

#
zoomPow(domain, anchor, scaleFactor, exponent)
Given a power scale domain array with numeric or datetime values and the given exponent, returns a new two-element domain array that is the result of zooming the domain by a scaleFactor, centered at the provided fractional anchor. The anchor value represents the zoom position in terms of fractional units of the scale range; for example, 0.5 indicates a zoom centered on the mid-point of the scale range.

#
zoomSymlog(domain, anchor, scaleFactor, constant)
Given a symmetric log scale domain array with numeric or datetime values parameterized by the given constant, returns a new two-element domain array that is the result of zooming the domain by a scaleFactor, centered at the provided fractional anchor. The anchor value represents the zoom position in terms of fractional units of the scale range; for example, 0.5 indicates a zoom centered on the mid-point of the scale range.

Back to Top

Geographic Functions

Functions for analyzing geographic regions represented as GeoJSON features.

#
geoArea(projection, feature[, group])
Returns the projected planar area (typically in square pixels) of a GeoJSON feature according to the named projection. If the projection argument is null, computes the spherical area in steradians using unprojected longitude, latitude coordinates. The optional group argument takes a scenegraph group mark item to indicate the specific scope in which to look up the projection. Uses d3-geo’s geoArea and path.area methods.

#
geoBounds(projection, feature[, group])
Returns the projected planar bounding box (typically in pixels) for the specified GeoJSON feature, according to the named projection. The bounding box is represented by a two-dimensional array: [[x₀, y₀], [x₁, y₁]], where x₀ is the minimum x-coordinate, y₀ is the minimum y-coordinate, x₁ is the maximum x-coordinate, and y₁ is the maximum y-coordinate. If the projection argument is null, computes the spherical bounding box using unprojected longitude, latitude coordinates. The optional group argument takes a scenegraph group mark item to indicate the specific scope in which to look up the projection. Uses d3-geo’s geoBounds and path.bounds methods.

#
geoCentroid(projection, feature[, group])
Returns the projected planar centroid (typically in pixels) for the specified GeoJSON feature, according to the named projection. If the projection argument is null, computes the spherical centroid using unprojected longitude, latitude coordinates. The optional group argument takes a scenegraph group mark item to indicate the specific scope in which to look up the projection. Uses d3-geo’s geoCentroid and path.centroid methods.

#
geoScale(projection[, group])
Returns the scale value for the named projection. The optional group argument takes a scenegraph group mark item to indicate the specific scope in which to look up the projection.

Back to Top

Tree (Hierarchy) Functions

Functions for processing hierarchy data sets constructed with the stratify or nest transforms.

#
treePath(name, source, target)
For the hierarchy data set with the given name, returns the shortest path through from the source node id to the target node id. The path starts at the source node, ascends to the least common ancestor of the source node and the target node, and then descends to the target node.

#
treeAncestors(name, node)
For the hierarchy data set with the given name, returns the array of ancestors nodes, starting with the input node, then followed by each parent up to the root.

Back to Top

Browser Functions

Functions for accessing web browser facilities.

#
containerSize()
Returns the current CSS box size ([el.clientWidth, el.clientHeight]) of the parent DOM element that contains the Vega view. If there is no container element, returns [undefined, undefined].

#
screen()
Returns the window.screen object, or {} if Vega is not running in a browser environment.

#
windowSize()
Returns the current window size ([window.innerWidth, window.innerHeight]) or [undefined, undefined] if Vega is not running in a browser environment.

Back to Top

Logging Functions

Logging functions for writing messages to the console. These can be helpful when debugging expressions.

#
warn(value1[, value2, …])
Logs a warning message and returns the last argument. For the message to appear in the console, the visualization view must have the appropriate logging level set.

#
info(value1[, value2, …])
Logs an informative message and returns the last argument. For the message to appear in the console, the visualization view must have the appropriate logging level set.

#
debug(value1[, value2, …])
Logs a debugging message and returns the last argument. For the message to appear in the console, the visualization view must have the appropriate logging level set.

Back to Top\nVega
            
              Vega-Lite
              Altair
              Vega-Lite API\nVega-Lite
              Altair
              Vega-Lite API\nExamples
              Tutorials
              Documentation
              Usage
              About
            
            
              GitHub
              Try Online\nExamples
              Tutorials
              Documentation
              Usage
              About\nGitHub
              Try Online\nDocumentation
      
      
      
      
        Specification
      
      
      
      
        Config
      
      
      
      
        Data
      
      
      
      
        Transforms
      
      
      
      
        Triggers
      
      
      
      
        Projections
      
      
      
      
        Scales
      
      
      
      
        Schemes
      
      
      
      
        Axes
      
      
      
      
        Legends
      
      
      
      
        Title
      
      
      
      
        Marks
      
      
      
      
        Signals
      
      
      
      
        Event Streams
      
      
      
      
        Expressions
      
      
      
      
        Layout
      
      
      
      
        Types
      
      
    
  
  
    Expressions
    To enable custom calculations, Vega includes its own expression language for writing basic formulas. For example, these expressions are used by the filter and formula transforms to modify data, and within signal definitions to calculate updated values in response to user input.

The expression language is a restricted subset of JavaScript. All basic arithmetic, logical and property access expressions are supported, as are boolean, number, string, object ({}) and array ([]) literals.  Ternary operators (ifTest ? thenValue : elseValue) and a special if(test, thenValue, elseValue) function are supported.

To keep the expression language simple, secure and free of unwanted side effects, the following elements are not allowed: assignment operators (=, += etc), pre/postfix updates (++), new expressions, and most control flow statements (for, while, switch, etc). In addition, function calls involving nested properties (foo.bar()) are not allowed. Instead, the expression language supports a collection of functions defined in the top-level scope.

This page documents the expression language. If you are interested in implementation aspects, the bulk of the expression language – including parsing, code generation, and some of the constant and function definitions – is provided by the vega-expression module.

Expression Language Reference


  Bound Variables
  Constants
  Type Checking Functions
  Type Coercion Functions
  Control Flow Functions
  Math Functions
  Statistical Functions
  Date-Time Functions
  Array Functions
  String Functions
  Object Functions
  Formatting Functions
  Regular Expression Functions
  Color Functions
  Event Functions
  Data Functions
  Scale & Projection Functions
  Geographic Functions
  Tree (Hierarchy) Functions
  Browser Functions
  Logging Functions


Bound Variables

The expression language includes a number of automatically-bound named variables.

#
datum

The current input data object, available within data transform and event handler expressions. To lookup object properties, use normal JavaScript syntax: datum.value or datum['My Value'].

#
event

If the expression is being invoked in response to an event, an event variable is defined. This variable consists of a standard JavaScript DOM event, providing access to bound properties of the event, such as event.metaKey or event.keyCode.

#
signal names

Any in-scope signal value can be referenced directly by name. For example, if you have defined a signal named hover within your Vega specification, you can refer to it directly within an expression (e.g., hover.value). Similarly, to lookup an object property whose name is bound to the signal property_name, you could use datum[property_name].

Back to Top

Constants

Constant values that can be referenced by name within expressions.

#
NaN
Not a number. Same as the JavaScript literal NaN.

#
E
The transcendental number e. Same as JavaScript’s Math.E.

#
LN2
The natural log of 2. Same as JavaScript’s Math.LN2.

#
LN10
The natural log of 10. Same as JavaScript’s Math.LN10.

#
LOG2E
The base 2 logarithm of e. Same as JavaScript’s Math.LOG2E.

#
LOG10E
The base 10 logarithm e. Same as JavaScript’s Math.LOG10E.

#
MAX_VALUE
The largest positive numeric value. Same as JavaScript’s Number.MAX_VALUE.

#
MIN_VALUE
The smallest positive numeric value. Same as JavaScript’s Number.MIN_VALUE.

#
PI
The transcendental number π. Same as JavaScript’s Math.PI.

#
SQRT1_2
The square root of 0.5. Same as JavaScript’s Math.SQRT1_2.

#
SQRT2
The square root of 2. Same as JavaScript’s Math.SQRT2.

Back to Top

Type Checking Functions

Predicate functions for checking value types.

#
isArray(value)
Returns true if value is an array, false otherwise.

#
isBoolean(value)
Returns true if value is a boolean (true or false), false otherwise.

#
isDate(value)
Returns true if value is a Date object, false otherwise. This method will return false for timestamp numbers or date-formatted strings; it recognizes Date objects only.

#
isDefined(value) ≥ 5.4
Returns true if value is a defined value, false if value equals undefined. This method will return true for null and NaN values.

#
isNumber(value)
Returns true if value is a number, false otherwise. NaN and Infinity are considered numbers.

#
isObject(value)
Returns true if value is an object (including arrays and Dates), false otherwise.

#
isRegExp(value)
Returns true if value is a RegExp (regular expression) object, false otherwise.

#
isString(value)
Returns true if value is a string, false otherwise.

#
isValid(value) ≥ 5.4
Returns true if value is not null, undefined, or NaN, false otherwise.

Back to Top

Type Coercion Functions

Functions for coercing values to a desired type.

#
toBoolean(value)
Coerces the input value to a string. Null values and empty strings are mapped to null.

#
toDate(value)
Coerces the input value to a Date instance. Null values and empty strings are mapped to null. If an optional parser function is provided, it is used to perform date parsing, otherwise Date.parse is used. Be aware that Date.parse has different implementations across browsers!

#
toNumber(value)
Coerces the input value to a number. Null values and empty strings are mapped to null.

#
toString(value)
Coerces the input value to a string. Null values and empty strings are mapped to null.

Control Flow Functions

#
if(test, thenValue, elseValue)
If test is truthy, returns thenValue. Otherwise, returns elseValue. The if function is equivalent to the ternary operator a ? b : c.

Back to Top

Math Functions

Basic mathematical functions.

#
isNaN(value)
Returns true if value is not a number. Same as JavaScript’s Number.isNaN.

#
isFinite(value)
Returns true if value is a finite number. Same as JavaScript’s Number.isFinite.

#
abs(value)
Returns the absolute value of value. Same as JavaScript’s Math.abs.

#
acos(value)
Trigonometric arccosine. Same as JavaScript’s Math.acos.

#
asin(value)
Trigonometric arcsine. Same as JavaScript’s Math.asin.

#
atan(value)
Trigonometric arctangent. Same as JavaScript’s Math.atan.

#
atan2(dy, dx)
Returns the arctangent of dy / dx. Same as JavaScript’s Math.atan2.

#
ceil(value)
Rounds value to the nearest integer of equal or greater value. Same as JavaScript’s Math.ceil.

#
clamp(value, min, max)
Restricts value to be between the specified min and max.

#
cos(value)
Trigonometric cosine. Same as JavaScript’s Math.cos.

#
exp(exponent)
Returns the value of e raised to the provided exponent. Same as JavaScript’s Math.exp.

#
floor(value)
Rounds value to the nearest integer of equal or lower value. Same as JavaScript’s Math.floor.

#
hypot(value)
Returns the square root of the sum of squares of its arguments. Same as JavaScript’s Math.hypot.

#
log(value)
Returns the natural logarithm of value. Same as JavaScript’s Math.log.

#
max(value1, value2, …)
Returns the maximum argument value. Same as JavaScript’s Math.max.

#
min(value1, value2, …)
Returns the minimum argument value. Same as JavaScript’s Math.min.

#
pow(value, exponent)
Returns value raised to the given exponent. Same as JavaScript’s Math.pow.

#
random()
Returns a pseudo-random number in the range [0,1). Same as JavaScript’s Math.random.

#
round(value)
Rounds value to the nearest integer. Same as JavaScript’s Math.round.

#
sin(value)
Trigonometric sine. Same as JavaScript’s Math.sin.

#
sqrt(value)
Square root function. Same as JavaScript’s Math.sqrt.

#
tan(value)
Trigonometric tangent. Same as JavaScript’s Math.tan.

Back to Top

Statistical Functions

Methods for sampling and calculating values for probability distributions.

#
sampleNormal([mean, stdev]) ≥ 5.7
Returns a sample from a univariate normal (Gaussian) probability distribution with specified mean and standard deviation stdev. If unspecified, the mean defaults to 0 and the standard deviation defaults to 1.

#
cumulativeNormal(value[, mean, stdev]) ≥ 5.7
Returns the value of the cumulative distribution function at the given input domain value for a normal distribution with specified mean and standard deviation stdev. If unspecified, the mean defaults to 0 and the standard deviation defaults to 1.

#
densityNormal(value[, mean, stdev]) ≥ 5.7
Returns the value of the probability density function at the given input domain value, for a normal distribution with specified mean and standard deviation stdev. If unspecified, the mean defaults to 0 and the standard deviation defaults to 1.

#
quantileNormal(probability[, mean, stdev]) ≥ 5.7
Returns the quantile value (the inverse of the cumulative distribution function) for the given input probability, for a normal distribution with specified mean and standard deviation stdev. If unspecified, the mean defaults to 0 and the standard deviation defaults to 1.

#
sampleLogNormal([mean, stdev]) ≥ 5.7
Returns a sample from a univariate log-normal probability distribution with specified log mean and log standard deviation stdev. If unspecified, the log mean defaults to 0 and the log standard deviation defaults to 1.

#
cumulativeLogNormal(value[, mean, stdev]) ≥ 5.7
Returns the value of the cumulative distribution function at the given input domain value for a log-normal distribution with specified log mean and log standard deviation stdev. If unspecified, the log mean defaults to 0 and the log standard deviation defaults to 1.

#
densityLogNormal(value[, mean, stdev]) ≥ 5.7
Returns the value of the probability density function at the given input domain value, for a log-normal distribution with specified log mean and log standard deviation stdev. If unspecified, the log mean defaults to 0 and the log standard deviation defaults to 1.

#
quantileLogNormal(probability[, mean, stdev]) ≥ 5.7
Returns the quantile value (the inverse of the cumulative distribution function) for the given input probability, for a log-normal distribution with specified log mean and log standard deviation stdev. If unspecified, the log mean defaults to 0 and the log standard deviation defaults to 1.

#
sampleUniform([min, max]) ≥ 5.7
Returns a sample from a univariate continuous uniform probability distribution over the interval [min, max). If unspecified, min defaults to 0 and max defaults to 1. If only one argument is provided, it is interpreted as the max value.

#
cumulativeUniform(value[, min, max]) ≥ 5.7
Returns the value of the cumulative distribution function at the given input domain value for a uniform distribution over the interval [min, max). If unspecified, min defaults to 0 and max defaults to 1. If only one argument is provided, it is interpreted as the max value.

#
densityUniform(value[, min, max]) ≥ 5.7
Returns the value of the probability density function at the given input domain value,  for a uniform distribution over the interval [min, max). If unspecified, min defaults to 0 and max defaults to 1. If only one argument is provided, it is interpreted as the max value.

#
quantileUniform(probability[, min, max]) ≥ 5.7
Returns the quantile value (the inverse of the cumulative distribution function) for the given input probability,  for a uniform distribution over the interval [min, max). If unspecified, min defaults to 0 and max defaults to 1. If only one argument is provided, it is interpreted as the max value.

Back to Top

Date-Time Functions

Functions for working with date-time values.

#
now()
Returns the timestamp for the current time.

#
datetime(year, month[, day, hour, min, sec, millisec])
Returns a new Date instance. The month is 0-based, such that 1 represents February.

#
date(datetime)
Returns the day of the month for the given datetime value, in local time.

#
day(datetime)
Returns the day of the week for the given datetime value, in local time.

#
dayofyear(datetime) ≥ 5.11
Returns the one-based day of the year for the given datetime value, in local time.

#
year(datetime)
Returns the year for the given datetime value, in local time.

#
quarter(datetime)
Returns the quarter of the year (0-3) for the given datetime value, in local time.

#
month(datetime)
Returns the (zero-based) month for the given datetime value, in local time.

#
week(date) ≥ 5.11
Returns the week number of the year for the given datetime, in local time. This function assumes Sunday-based weeks. Days before the first Sunday of the year are considered to be in week 0, the first Sunday of the year is the start of week 1, the second Sunday week 2, etc..

#
hours(datetime)
Returns the hours component for the given datetime value, in local time.

#
minutes(datetime)
Returns the minutes component for the given datetime value, in local time.

#
seconds(datetime)
Returns the seconds component for the given datetime value, in local time.

#
milliseconds(datetime)
Returns the milliseconds component for the given datetime value, in local time.

#
time(datetime)
Returns the epoch-based timestamp for the given datetime value.

#
timezoneoffset(datetime)
Returns the timezone offset from the local timezone to UTC for the given datetime value.

#
timeOffset(unit, date[, step]) ≥ 5.8
Returns a new Date instance that offsets the given date by the specified time unit in the local timezone. The optional step argument indicates the number of time unit steps to offset by (default 1).

#
timeSequence(unit, start, stop[, step]) ≥ 5.8
Returns an array of Date instances from start (inclusive) to stop (exclusive), with each entry separated by the given time unit in the local timezone. The optional step argument indicates the number of time unit steps to take between each sequence entry (default 1).

#
utc(year, month[, day, hour, min, sec, millisec])
Returns a timestamp for the given UTC date. The month is 0-based, such that 1 represents February.

#
utcdate(datetime)
Returns the day of the month for the given datetime value, in UTC time.

#
utcday(datetime)
Returns the day of the week for the given datetime value, in UTC time.

#
utcdayofyear(datetime) ≥ 5.11
Returns the one-based day of the year for the given datetime value, in UTC time.

#
utcyear(datetime)
Returns the year for the given datetime value, in UTC time.

#
utcquarter(datetime)
Returns the quarter of the year (0-3) for the given datetime value, in UTC time.

#
utcmonth(datetime)
Returns the (zero-based) month for the given datetime value, in UTC time.

#
utcweek(date) ≥ 5.11
Returns the week number of the year for the given datetime, in UTC time. This function assumes Sunday-based weeks. Days before the first Sunday of the year are considered to be in week 0, the first Sunday of the year is the start of week 1, the second Sunday week 2, etc..

#
utchours(datetime)
Returns the hours component for the given datetime value, in UTC time.

#
utcminutes(datetime)
Returns the minutes component for the given datetime value, in UTC time.

#
utcseconds(datetime)
Returns the seconds component for the given datetime value, in UTC time.

#
utcmilliseconds(datetime)
Returns the milliseconds component for the given datetime value, in UTC time.

#
utcOffset(unit, date[, step]) ≥ 5.8
Returns a new Date instance that offsets the given date by the specified time unit in UTC time. The optional step argument indicates the number of time unit steps to offset by (default 1).

#
utcSequence(unit, start, stop[, step]) ≥ 5.8
Returns an array of Date instances from start (inclusive) to stop (exclusive), with each entry separated by the given time unit in UTC time. The optional step argument indicates the number of time unit steps to take between each sequence entry (default 1).

Back to Top

Array Functions

Functions for working with arrays of values.

#
extent(array) ≥ 4.0
Returns a new [min, max] array with the minimum and maximum values of the input array, ignoring null, undefined, and NaN values.

#
clampRange(range, min, max)
Clamps a two-element range array in a span-preserving manner. If the span of the input range is less than (max - min) and an endpoint exceeds either the min or max value, the range is translated such that the span is preserved and one endpoint touches the boundary of the [min, max] range. If the span exceeds (max - min), the range [min, max] is returned.

#
indexof(array, value)
Returns the first index of value in the input array.

#
inrange(value, range)
Tests whether value lies within (or is equal to either) the first and last values of the range array.

#
join(array[, separator]) ≥ 5.3
Returns a new string by concatenating all of the elements of the input array, separated by commas or a specified separator string.

#
lastindexof(array, value)
Returns the last index of value in the input array.

#
length(array)
Returns the length of the input array.

#
lerp(array, fraction)
Returns the linearly interpolated value between the first and last entries in the array for the provided interpolation fraction (typically between 0 and 1). For example, lerp([0, 50], 0.5) returns 25.

#
peek(array)
Returns the last element in the input array. Similar to the built-in Array.pop method, except that it does not remove the last element. This method is a convenient shorthand for array[array.length - 1].

#
pluck(array, field) ≥ 5.19
Retrieves the value for the specified field from a given array of objects. The input field string may include nested properties (e.g., foo.bar.bz).

#
reverse(array) ≥ 5.3
Returns a new array with elements in a reverse order of the input array. The first array element becomes the last, and the last array element becomes the first.

#
sequence([start, ]stop[, step])
Returns an array containing an arithmetic sequence of numbers. If step is omitted, it defaults to 1. If start is omitted, it defaults to 0. The stop value is exclusive; it is not included in the result. If step is positive, the last element is the largest start + i * step less than stop; if step is negative, the last element is the smallest start + i * step greater than stop. If the returned array would contain an infinite number of values, an empty range is returned. The arguments are not required to be integers.

#
slice(array, start[, end])
Returns a section of array between the start and end indices. If the end argument is negative, it is treated as an offset from the end of the array (length(array) + end).

#
sort(array)≥ 5.31
Sorts the array in natural order using ascending from Vega Utils.

#
span(array)
Returns the span of array: the difference between the last and first elements, or array[array.length-1] - array[0].

Back to Top

String Functions

Functions for modifying text strings.

#
indexof(string, substring)
Returns the first index of substring in the input string.

#
lastindexof(string, substring)
Returns the last index of substring in the input string.

#
length(string)
Returns the length of the input string.

#
lower(string)
Transforms string to lower-case letters.

#
pad(string, length[, character, align])
Pads a string value with repeated instances of a character up to a specified length. If character is not specified, a space (‘ ‘) is used. By default, padding is added to the end of a string. An optional align parameter specifies if padding should be added to the 'left' (beginning), 'center', or 'right' (end) of the input string.

#
parseFloat(string)
Parses the input string to a floating-point value. Same as JavaScript’s parseFloat.

#
parseInt(string)
Parses the input string to an integer value. Same as JavaScript’s parseInt.

#
replace(string, pattern, replacement)
Returns a new string with some or all matches of pattern replaced by a replacement string. The pattern can be a string or a regular expression. If pattern is a string, only the first instance will be replaced. Same as JavaScript’s String.replace.

#
slice(string, start[, end])
Returns a section of string between the start and end indices. If the end argument is negative, it is treated as an offset from the end of the string (length(string) + end).

#
split(string, separator[, limit]) ≥ 4.3
Returns an array of tokens created by splitting the input string according to a provided separator pattern. The result can optionally be constrained to return at most limit tokens.

#
substring(string, start[, end])
Returns a section of string between the start and end indices.

#
trim(string) ≥ 5.3
Returns a trimmed string with preceding and trailing whitespace removed.

#
truncate(string, length[, align, ellipsis])
Truncates an input string to a target length. The optional align argument indicates what part of the string should be truncated: 'left' (the beginning), 'center', or 'right' (the end). By default, the 'right' end of the string is truncated. The optional ellipsis argument indicates the string to use to indicate truncated content; by default the ellipsis character … (\u2026) is used.

#
upper(string)
Transforms string to upper-case letters.

#
btoa(string) ≥ 5.32.0
Creates a Base64-encoded ASCII string. Same as JavaScript’s Window.btoa().

#
atob(string) ≥ 5.32.0
Decodes an ASCII string that was encoded with Base64. Same as JavaScript’s Window.atob().

Back to Top

Object Functions

Functions for manipulating object instances.

#
merge(object1[, object2, …]) ≥ 4.0
Merges the input objects object1, object2, etc into a new output object. Inputs are visited in sequential order, such that key values from later arguments can overwrite those from earlier arguments. Example: merge({a:1, b:2}, {a:3}) -> {a:3, b:2}.

Back to Top

Formatting Functions

Functions for formatting number and datetime values as strings.

#
dayFormat(day)
Formats a (0-6) weekday number as a full week day name, according to the current locale. For example: dayFormat(0) -> "Sunday".

#
dayAbbrevFormat(day)
Formats a (0-6) weekday number as an abbreviated week day name, according to the current locale. For example: dayAbbrevFormat(0) -> "Sun".

#
format(value, specifier)
Formats a numeric value as a string. The specifier must be a valid d3-format specifier (e.g., format(value, ',.2f').
Null values are formatted as "null".

#
monthFormat(month)
Formats a (zero-based) month number as a full month name, according to the current locale. For example: monthFormat(0) -> "January".

#
monthAbbrevFormat(month)
Formats a (zero-based) month number as an abbreviated month name, according to the current locale. For example: monthAbbrevFormat(0) -> "Jan".

#
timeUnitSpecifier(units[, specifiers]) ≥ 5.8
Returns a time format specifier string for the given time units. The optional specifiers object provides a set of specifier sub-strings for customizing the format; for more, see the timeUnitSpecifier API documentation. The resulting specifier string can then be used as input to the timeFormat or utcFormat functions, or as the format parameter of an axis or legend. For example: timeFormat(date, timeUnitSpecifier('year')) or timeFormat(date, timeUnitSpecifier(['hours', 'minutes'])).

#
timeFormat(value, specifier)
Formats a datetime value (either a Date object or timestamp) as a string, according to the local time. The specifier must be a valid d3-time-format specifier or TimeMultiFormat object ≥ 5.8. For example: timeFormat(timestamp, '%A').
Null values are formatted as "null".

#
timeParse(string, specifier)
Parses a string value to a Date object, according to the local time. The specifier must be a valid d3-time-format specifier. For example: timeParse('June 30, 2015', '%B %d, %Y').

#
utcFormat(value, specifier)
Formats a datetime value (either a Date object or timestamp) as a string, according to UTC time. The specifier must be a valid d3-time-format specifier or TimeMultiFormat object ≥ 5.8. For example: utcFormat(timestamp, '%A').
Null values are formatted as "null".

#
utcParse(value, specifier)
Parses a string value to a Date object, according to UTC time. The specifier must be a valid d3-time-format specifier. For example: utcParse('June 30, 2015', '%B %d, %Y').

Back to Top

RegExp Functions

Functions for creating and applying regular expressions.

#
regexp(pattern[, flags]) -
Creates a regular expression instance from an input pattern string and optional flags. Same as JavaScript’s RegExp.

#
test(regexp[, string]) -
Evaluates a regular expression regexp against the input string, returning true if the string matches the pattern, false otherwise. For example: test(/\\d{3}/, "32-21-9483") -> true.

Back to Top

Color Functions

Functions for representing colors in various color spaces. Color functions return objects that, when coerced to a string, map to valid CSS RGB colors.

#
rgb(r, g, b[, opacity]) |
rgb(specifier)
Constructs a new RGB color. If r, g and b are specified, these represent the channel values of the returned color; an opacity may also be specified. If a CSS Color Module Level 3 specifier string is specified, it is parsed and then converted to the RGB color space. Uses d3-color’s rgb function.

#
hsl(h, s, l[, opacity]) |
hsl(specifier)
Constructs a new HSL color. If h, s and l are specified, these represent the channel values of the returned color; an opacity may also be specified. If a CSS Color Module Level 3 specifier string is specified, it is parsed and then converted to the HSL color space. Uses d3-color’s hsl function.

#
lab(l, a, b[, opacity]) |
lab(specifier)
Constructs a new CIE LAB color. If l, a and b are specified, these represent the channel values of the returned color; an opacity may also be specified. If a CSS Color Module Level 3 specifier string is specified, it is parsed and then converted to the LAB color space. Uses d3-color’s lab function.

#
hcl(h, c, l[, opacity]) |
hcl(specifier)
Constructs a new HCL (hue, chroma, luminance) color. If h, c and l are specified, these represent the channel values of the returned color; an opacity may also be specified. If a CSS Color Module Level 3 specifier string is specified, it is parsed and then converted to the HCL color space. Uses d3-color’s hcl function.

#
luminance(specifier) ≥ 5.7
Returns the luminance for the given color specifier (compatible with d3-color’s rgb function). The luminance is calculated according to the W3C Web Content Accessibility Guidelines.

#
contrast(specifier1, specifier2) ≥ 5.7
Returns the contrast ratio between the input color specifiers as a float between 1 and 21. The contrast is calculated according to the W3C Web Content Accessibility Guidelines.

Back to Top

Event Functions

Functions for processing input event data. These functions are only legal in expressions evaluated in response to an event (for example a signal event handler). Invoking these functions elsewhere can result in errors.

#
item()
Returns the current scenegraph item that is the target of the event.

#
group([name])
Returns the scenegraph group mark item in which the current event has occurred. If no arguments are provided, the immediate parent group is returned. If a group name is provided, the matching ancestor group item is returned.

#
xy([item])
Returns the x- and y-coordinates for the current event as a two-element array. If no arguments are provided, the top-level coordinate space of the view is used. If a scenegraph item (or string group name) is provided, the coordinate space of the group item is used.

#
x([item])
Returns the x coordinate for the current event. If no arguments are provided, the top-level coordinate space of the view is used. If a scenegraph item (or string group name) is provided, the coordinate space of the group item is used.

#
y([item])
Returns the y coordinate for the current event. If no arguments are provided, the top-level coordinate space of the view is used. If a scenegraph item (or string group name) is provided, the coordinate space of the group item is used.

#
pinchDistance(event)
Returns the pixel distance between the first two touch points of a multi-touch event.

#
pinchAngle(event)
Returns the angle of the line connecting the first two touch points of a multi-touch event.

#
inScope(item)
Returns true if the given scenegraph item is a descendant of the group mark in which the event handler was defined, false otherwise.

Back to Top

Data Functions

Functions for accessing Vega data sets.

#
data(name)
Returns the array of data objects for the Vega data set with the given name. If the data set is not found, returns an empty array.

#
indata(name, field, value)
Tests if the data set with a given name contains a datum with a field value that matches the input value. For example: indata('table', 'category', value).

Back to Top

Scale and Projection Functions

Functions for working with Vega scale transforms and cartographic projections.

#
scale(name, value[, group])
Applies the named scale transform (or projection) to the specified value. The optional group argument takes a scenegraph group mark item to indicate the specific scope in which to look up the scale or projection.

#
invert(name, value[, group])
Inverts the named scale transform (or projection) for the specified value. The optional group argument takes a scenegraph group mark item to indicate the specific scope in which to look up the scale or projection.

#
copy(name[, group])
Returns a copy (a new cloned instance) of the named scale transform of projection, or undefined if no scale or projection is found. The optional group argument takes a scenegraph group mark item to indicate the specific scope in which to look up the scale or projection.

#
domain(name[, group])
Returns the scale domain array for the named scale transform, or an empty array if the scale is not found. The optional group argument takes a scenegraph group mark item to indicate the specific scope in which to look up the scale.

#
range(name[, group])
Returns the scale range array for the named scale transform, or an empty array if the scale is not found. The optional group argument takes a scenegraph group mark item to indicate the specific scope in which to look up the scale.

#
bandwidth(name[, group])
Returns the current band width for the named band scale transform, or zero if the scale is not found or is not a band scale. The optional group argument takes a scenegraph group mark item to indicate the specific scope in which to look up the scale.

#
bandspace(count[, paddingInner, paddingOuter])
Returns the number of steps needed within a band scale, based on the count of domain elements and the inner and outer padding values. While normally calculated within the scale itself, this function can be helpful for determining the size of a chart’s layout.

#
gradient(scale, p0, p1[, count])
Returns a linear color gradient for the scale (whose range must be a continuous color scheme) and starting and ending points p0 and p1, each an [x, y] array. The points p0 and p1 should be expressed in normalized coordinates in the domain [0, 1], relative to the bounds of the item being colored. If unspecified, p0 defaults to [0, 0] and p1 defaults to [1, 0], for a horizontal gradient that spans the full bounds of an item. The optional count argument indicates a desired target number of sample points to take from the color scale.

#
panLinear(domain, delta)
Given a linear scale domain array with numeric or datetime values, returns a new two-element domain array that is the result of panning the domain by a fractional delta. The delta value represents fractional units of the scale range; for example, 0.5 indicates panning the scale domain to the right by half the scale range.

#
panLog(domain, delta)
Given a log scale domain array with numeric or datetime values, returns a new two-element domain array that is the result of panning the domain by a fractional delta. The delta value represents fractional units of the scale range; for example, 0.5 indicates panning the scale domain to the right by half the scale range.

#
panPow(domain, delta, exponent)
Given a power scale domain array with numeric or datetime values and the given exponent, returns a new two-element domain array that is the result of panning the domain by a fractional delta. The delta value represents fractional units of the scale range; for example, 0.5 indicates panning the scale domain to the right by half the scale range.

#
panSymlog(domain, delta, constant)
Given a symmetric log scale domain array with numeric or datetime values parameterized by the given constant, returns a new two-element domain array that is the result of panning the domain by a fractional delta. The delta value represents fractional units of the scale range; for example, 0.5 indicates panning the scale domain to the right by half the scale range.

#
zoomLinear(domain, anchor, scaleFactor)
Given a linear scale domain array with numeric or datetime values, returns a new two-element domain array that is the result of zooming the domain by a scaleFactor, centered at the provided fractional anchor. The anchor value represents the zoom position in terms of fractional units of the scale range; for example, 0.5 indicates a zoom centered on the mid-point of the scale range.

#
zoomLog(domain, anchor, scaleFactor)
Given a log scale domain array with numeric or datetime values, returns a new two-element domain array that is the result of zooming the domain by a scaleFactor, centered at the provided fractional anchor. The anchor value represents the zoom position in terms of fractional units of the scale range; for example, 0.5 indicates a zoom centered on the mid-point of the scale range.

#
zoomPow(domain, anchor, scaleFactor, exponent)
Given a power scale domain array with numeric or datetime values and the given exponent, returns a new two-element domain array that is the result of zooming the domain by a scaleFactor, centered at the provided fractional anchor. The anchor value represents the zoom position in terms of fractional units of the scale range; for example, 0.5 indicates a zoom centered on the mid-point of the scale range.

#
zoomSymlog(domain, anchor, scaleFactor, constant)
Given a symmetric log scale domain array with numeric or datetime values parameterized by the given constant, returns a new two-element domain array that is the result of zooming the domain by a scaleFactor, centered at the provided fractional anchor. The anchor value represents the zoom position in terms of fractional units of the scale range; for example, 0.5 indicates a zoom centered on the mid-point of the scale range.

Back to Top

Geographic Functions

Functions for analyzing geographic regions represented as GeoJSON features.

#
geoArea(projection, feature[, group])
Returns the projected planar area (typically in square pixels) of a GeoJSON feature according to the named projection. If the projection argument is null, computes the spherical area in steradians using unprojected longitude, latitude coordinates. The optional group argument takes a scenegraph group mark item to indicate the specific scope in which to look up the projection. Uses d3-geo’s geoArea and path.area methods.

#
geoBounds(projection, feature[, group])
Returns the projected planar bounding box (typically in pixels) for the specified GeoJSON feature, according to the named projection. The bounding box is represented by a two-dimensional array: [[x₀, y₀], [x₁, y₁]], where x₀ is the minimum x-coordinate, y₀ is the minimum y-coordinate, x₁ is the maximum x-coordinate, and y₁ is the maximum y-coordinate. If the projection argument is null, computes the spherical bounding box using unprojected longitude, latitude coordinates. The optional group argument takes a scenegraph group mark item to indicate the specific scope in which to look up the projection. Uses d3-geo’s geoBounds and path.bounds methods.

#
geoCentroid(projection, feature[, group])
Returns the projected planar centroid (typically in pixels) for the specified GeoJSON feature, according to the named projection. If the projection argument is null, computes the spherical centroid using unprojected longitude, latitude coordinates. The optional group argument takes a scenegraph group mark item to indicate the specific scope in which to look up the projection. Uses d3-geo’s geoCentroid and path.centroid methods.

#
geoScale(projection[, group])
Returns the scale value for the named projection. The optional group argument takes a scenegraph group mark item to indicate the specific scope in which to look up the projection.

Back to Top

Tree (Hierarchy) Functions

Functions for processing hierarchy data sets constructed with the stratify or nest transforms.

#
treePath(name, source, target)
For the hierarchy data set with the given name, returns the shortest path through from the source node id to the target node id. The path starts at the source node, ascends to the least common ancestor of the source node and the target node, and then descends to the target node.

#
treeAncestors(name, node)
For the hierarchy data set with the given name, returns the array of ancestors nodes, starting with the input node, then followed by each parent up to the root.

Back to Top

Browser Functions

Functions for accessing web browser facilities.

#
containerSize()
Returns the current CSS box size ([el.clientWidth, el.clientHeight]) of the parent DOM element that contains the Vega view. If there is no container element, returns [undefined, undefined].

#
screen()
Returns the window.screen object, or {} if Vega is not running in a browser environment.

#
windowSize()
Returns the current window size ([window.innerWidth, window.innerHeight]) or [undefined, undefined] if Vega is not running in a browser environment.

Back to Top

Logging Functions

Logging functions for writing messages to the console. These can be helpful when debugging expressions.

#
warn(value1[, value2, …])
Logs a warning message and returns the last argument. For the message to appear in the console, the visualization view must have the appropriate logging level set.

#
info(value1[, value2, …])
Logs an informative message and returns the last argument. For the message to appear in the console, the visualization view must have the appropriate logging level set.

#
debug(value1[, value2, …])
Logs a debugging message and returns the last argument. For the message to appear in the console, the visualization view must have the appropriate logging level set.

Back to Top\nTo enable custom calculations, Vega includes its own expression language for writing basic formulas. For example, these expressions are used by the filter and formula transforms to modify data, and within signal definitions to calculate updated values in response to user input.\nThe expression language is a restricted subset of JavaScript. All basic arithmetic, logical and property access expressions are supported, as are boolean, number, string, object ({}) and array ([]) literals.  Ternary operators (ifTest ? thenValue : elseValue) and a special if(test, thenValue, elseValue) function are supported.\nTo keep the expression language simple, secure and free of unwanted side effects, the following elements are not allowed: assignment operators (=, += etc), pre/postfix updates (++), new expressions, and most control flow statements (for, while, switch, etc). In addition, function calls involving nested properties (foo.bar()) are not allowed. Instead, the expression language supports a collection of functions defined in the top-level scope.\nThis page documents the expression language. If you are interested in implementation aspects, the bulk of the expression language – including parsing, code generation, and some of the constant and function definitions – is provided by the vega-expression module.\nvega-expression module\nExpression Language Reference\nType Checking Functions\nType Checking Functions\nType Coercion Functions\nType Coercion Functions\nControl Flow Functions\nControl Flow Functions\nStatistical Functions\nStatistical Functions\nRegular Expression Functions\nRegular Expression Functions\nScale & Projection Functions\nScale & Projection Functions\nTree (Hierarchy) Functions\nTree (Hierarchy) Functions\nThe expression language includes a number of automatically-bound named variables.\nThe current input data object, available within data transform and event handler expressions. To lookup object properties, use normal JavaScript syntax: datum.value or datum['My Value'].\nIf the expression is being invoked in response to an event, an event variable is defined. This variable consists of a standard JavaScript DOM event, providing access to bound properties of the event, such as event.metaKey or event.keyCode.\nAny in-scope signal value can be referenced directly by name. For example, if you have defined a signal named hover within your Vega specification, you can refer to it directly within an expression (e.g., hover.value). Similarly, to lookup an object property whose name is bound to the signal property_name, you could use datum[property_name].\nConstant values that can be referenced by name within expressions.\n#
NaN
Not a number. Same as the JavaScript literal NaN.\n#
E
The transcendental number e. Same as JavaScript’s Math.E.\n#
LN2
The natural log of 2. Same as JavaScript’s Math.LN2.\n#
LN10
The natural log of 10. Same as JavaScript’s Math.LN10.\n#
LOG2E
The base 2 logarithm of e. Same as JavaScript’s Math.LOG2E.\n#
LOG10E
The base 10 logarithm e. Same as JavaScript’s Math.LOG10E.\n#
MAX_VALUE
The largest positive numeric value. Same as JavaScript’s Number.MAX_VALUE.\n#
MIN_VALUE
The smallest positive numeric value. Same as JavaScript’s Number.MIN_VALUE.\n#
PI
The transcendental number π. Same as JavaScript’s Math.PI.\n#
SQRT1_2
The square root of 0.5. Same as JavaScript’s Math.SQRT1_2.\n#
SQRT2
The square root of 2. Same as JavaScript’s Math.SQRT2.\nType Checking Functions\nPredicate functions for checking value types.\n#
isArray(value)
Returns true if value is an array, false otherwise.\n#
isBoolean(value)
Returns true if value is a boolean (true or false), false otherwise.\n#
isDate(value)
Returns true if value is a Date object, false otherwise. This method will return false for timestamp numbers or date-formatted strings; it recognizes Date objects only.\n#
isDefined(value) ≥ 5.4
Returns true if value is a defined value, false if value equals undefined. This method will return true for null and NaN values.\n#
isNumber(value)
Returns true if value is a number, false otherwise. NaN and Infinity are considered numbers.\n#
isObject(value)
Returns true if value is an object (including arrays and Dates), false otherwise.\n#
isRegExp(value)
Returns true if value is a RegExp (regular expression) object, false otherwise.\n#
isString(value)
Returns true if value is a string, false otherwise.\n#
isValid(value) ≥ 5.4
Returns true if value is not null, undefined, or NaN, false otherwise.\nType Coercion Functions\nFunctions for coercing values to a desired type.\n#
toBoolean(value)
Coerces the input value to a string. Null values and empty strings are mapped to null.\n#
toDate(value)
Coerces the input value to a Date instance. Null values and empty strings are mapped to null. If an optional parser function is provided, it is used to perform date parsing, otherwise Date.parse is used. Be aware that Date.parse has different implementations across browsers!\n#
toNumber(value)
Coerces the input value to a number. Null values and empty strings are mapped to null.\n#
toString(value)
Coerces the input value to a string. Null values and empty strings are mapped to null.\nControl Flow Functions\n#
if(test, thenValue, elseValue)
If test is truthy, returns thenValue. Otherwise, returns elseValue. The if function is equivalent to the ternary operator a ? b : c.\nBasic mathematical functions.\n#
isNaN(value)
Returns true if value is not a number. Same as JavaScript’s Number.isNaN.\n#
isFinite(value)
Returns true if value is a finite number. Same as JavaScript’s Number.isFinite.\n#
abs(value)
Returns the absolute value of value. Same as JavaScript’s Math.abs.\n#
acos(value)
Trigonometric arccosine. Same as JavaScript’s Math.acos.\n#
asin(value)
Trigonometric arcsine. Same as JavaScript’s Math.asin.\n#
atan(value)
Trigonometric arctangent. Same as JavaScript’s Math.atan.\n#
atan2(dy, dx)
Returns the arctangent of dy / dx. Same as JavaScript’s Math.atan2.\n#
ceil(value)
Rounds value to the nearest integer of equal or greater value. Same as JavaScript’s Math.ceil.\n#
clamp(value, min, max)
Restricts value to be between the specified min and max.\n#
cos(value)
Trigonometric cosine. Same as JavaScript’s Math.cos.\n#
exp(exponent)
Returns the value of e raised to the provided exponent. Same as JavaScript’s Math.exp.\n#
floor(value)
Rounds value to the nearest integer of equal or lower value. Same as JavaScript’s Math.floor.\n#
hypot(value)
Returns the square root of the sum of squares of its arguments. Same as JavaScript’s Math.hypot.\n#
log(value)
Returns the natural logarithm of value. Same as JavaScript’s Math.log.\n#
max(value1, value2, …)
Returns the maximum argument value. Same as JavaScript’s Math.max.\n#
min(value1, value2, …)
Returns the minimum argument value. Same as JavaScript’s Math.min.\n#
pow(value, exponent)
Returns value raised to the given exponent. Same as JavaScript’s Math.pow.\n#
random()
Returns a pseudo-random number in the range [0,1). Same as JavaScript’s Math.random.\n#
round(value)
Rounds value to the nearest integer. Same as JavaScript’s Math.round.\n#
sin(value)
Trigonometric sine. Same as JavaScript’s Math.sin.\n#
sqrt(value)
Square root function. Same as JavaScript’s Math.sqrt.\n#
tan(value)
Trigonometric tangent. Same as JavaScript’s Math.tan.\nStatistical Functions\nMethods for sampling and calculating values for probability distributions.\n#
sampleNormal([mean, stdev]) ≥ 5.7
Returns a sample from a univariate normal (Gaussian) probability distribution with specified mean and standard deviation stdev. If unspecified, the mean defaults to 0 and the standard deviation defaults to 1.\nnormal (Gaussian) probability distribution\n#
cumulativeNormal(value[, mean, stdev]) ≥ 5.7
Returns the value of the cumulative distribution function at the given input domain value for a normal distribution with specified mean and standard deviation stdev. If unspecified, the mean defaults to 0 and the standard deviation defaults to 1.\ncumulative distribution function\n#
densityNormal(value[, mean, stdev]) ≥ 5.7
Returns the value of the probability density function at the given input domain value, for a normal distribution with specified mean and standard deviation stdev. If unspecified, the mean defaults to 0 and the standard deviation defaults to 1.\nprobability density function\n#
quantileNormal(probability[, mean, stdev]) ≥ 5.7
Returns the quantile value (the inverse of the cumulative distribution function) for the given input probability, for a normal distribution with specified mean and standard deviation stdev. If unspecified, the mean defaults to 0 and the standard deviation defaults to 1.\ncumulative distribution function\n#
sampleLogNormal([mean, stdev]) ≥ 5.7
Returns a sample from a univariate log-normal probability distribution with specified log mean and log standard deviation stdev. If unspecified, the log mean defaults to 0 and the log standard deviation defaults to 1.\nlog-normal probability distribution\n#
cumulativeLogNormal(value[, mean, stdev]) ≥ 5.7
Returns the value of the cumulative distribution function at the given input domain value for a log-normal distribution with specified log mean and log standard deviation stdev. If unspecified, the log mean defaults to 0 and the log standard deviation defaults to 1.\ncumulative distribution function\n#
densityLogNormal(value[, mean, stdev]) ≥ 5.7
Returns the value of the probability density function at the given input domain value, for a log-normal distribution with specified log mean and log standard deviation stdev. If unspecified, the log mean defaults to 0 and the log standard deviation defaults to 1.\nprobability density function\n#
quantileLogNormal(probability[, mean, stdev]) ≥ 5.7
Returns the quantile value (the inverse of the cumulative distribution function) for the given input probability, for a log-normal distribution with specified log mean and log standard deviation stdev. If unspecified, the log mean defaults to 0 and the log standard deviation defaults to 1.\ncumulative distribution function\n#
sampleUniform([min, max]) ≥ 5.7
Returns a sample from a univariate continuous uniform probability distribution over the interval [min, max). If unspecified, min defaults to 0 and max defaults to 1. If only one argument is provided, it is interpreted as the max value.\ncontinuous uniform probability distribution\n#
cumulativeUniform(value[, min, max]) ≥ 5.7
Returns the value of the cumulative distribution function at the given input domain value for a uniform distribution over the interval [min, max). If unspecified, min defaults to 0 and max defaults to 1. If only one argument is provided, it is interpreted as the max value.\ncumulative distribution function\n#
densityUniform(value[, min, max]) ≥ 5.7
Returns the value of the probability density function at the given input domain value,  for a uniform distribution over the interval [min, max). If unspecified, min defaults to 0 and max defaults to 1. If only one argument is provided, it is interpreted as the max value.\nprobability density function\n#
quantileUniform(probability[, min, max]) ≥ 5.7
Returns the quantile value (the inverse of the cumulative distribution function) for the given input probability,  for a uniform distribution over the interval [min, max). If unspecified, min defaults to 0 and max defaults to 1. If only one argument is provided, it is interpreted as the max value.\ncumulative distribution function\nFunctions for working with date-time values.\n#
now()
Returns the timestamp for the current time.\n#
datetime(year, month[, day, hour, min, sec, millisec])
Returns a new Date instance. The month is 0-based, such that 1 represents February.\n#
date(datetime)
Returns the day of the month for the given datetime value, in local time.\n#
day(datetime)
Returns the day of the week for the given datetime value, in local time.\n#
dayofyear(datetime) ≥ 5.11
Returns the one-based day of the year for the given datetime value, in local time.\n#
year(datetime)
Returns the year for the given datetime value, in local time.\n#
quarter(datetime)
Returns the quarter of the year (0-3) for the given datetime value, in local time.\n#
month(datetime)
Returns the (zero-based) month for the given datetime value, in local time.\n#
week(date) ≥ 5.11
Returns the week number of the year for the given datetime, in local time. This function assumes Sunday-based weeks. Days before the first Sunday of the year are considered to be in week 0, the first Sunday of the year is the start of week 1, the second Sunday week 2, etc..\n#
hours(datetime)
Returns the hours component for the given datetime value, in local time.\n#
minutes(datetime)
Returns the minutes component for the given datetime value, in local time.\n#
seconds(datetime)
Returns the seconds component for the given datetime value, in local time.\n#
milliseconds(datetime)
Returns the milliseconds component for the given datetime value, in local time.\n#
time(datetime)
Returns the epoch-based timestamp for the given datetime value.\n#
timezoneoffset(datetime)
Returns the timezone offset from the local timezone to UTC for the given datetime value.\n#
timeOffset(unit, date[, step]) ≥ 5.8
Returns a new Date instance that offsets the given date by the specified time unit in the local timezone. The optional step argument indicates the number of time unit steps to offset by (default 1).\n#
timeSequence(unit, start, stop[, step]) ≥ 5.8
Returns an array of Date instances from start (inclusive) to stop (exclusive), with each entry separated by the given time unit in the local timezone. The optional step argument indicates the number of time unit steps to take between each sequence entry (default 1).\n#
utc(year, month[, day, hour, min, sec, millisec])
Returns a timestamp for the given UTC date. The month is 0-based, such that 1 represents February.\n#
utcdate(datetime)
Returns the day of the month for the given datetime value, in UTC time.\n#
utcday(datetime)
Returns the day of the week for the given datetime value, in UTC time.\n#
utcdayofyear(datetime) ≥ 5.11
Returns the one-based day of the year for the given datetime value, in UTC time.\n#
utcyear(datetime)
Returns the year for the given datetime value, in UTC time.\n#
utcquarter(datetime)
Returns the quarter of the year (0-3) for the given datetime value, in UTC time.\n#
utcmonth(datetime)
Returns the (zero-based) month for the given datetime value, in UTC time.\n#
utcweek(date) ≥ 5.11
Returns the week number of the year for the given datetime, in UTC time. This function assumes Sunday-based weeks. Days before the first Sunday of the year are considered to be in week 0, the first Sunday of the year is the start of week 1, the second Sunday week 2, etc..\n#
utchours(datetime)
Returns the hours component for the given datetime value, in UTC time.\n#
utcminutes(datetime)
Returns the minutes component for the given datetime value, in UTC time.\n#
utcseconds(datetime)
Returns the seconds component for the given datetime value, in UTC time.\n#
utcmilliseconds(datetime)
Returns the milliseconds component for the given datetime value, in UTC time.\n#
utcOffset(unit, date[, step]) ≥ 5.8
Returns a new Date instance that offsets the given date by the specified time unit in UTC time. The optional step argument indicates the number of time unit steps to offset by (default 1).\n#
utcSequence(unit, start, stop[, step]) ≥ 5.8
Returns an array of Date instances from start (inclusive) to stop (exclusive), with each entry separated by the given time unit in UTC time. The optional step argument indicates the number of time unit steps to take between each sequence entry (default 1).\nFunctions for working with arrays of values.\n#
extent(array) ≥ 4.0
Returns a new [min, max] array with the minimum and maximum values of the input array, ignoring null, undefined, and NaN values.\n#
clampRange(range, min, max)
Clamps a two-element range array in a span-preserving manner. If the span of the input range is less than (max - min) and an endpoint exceeds either the min or max value, the range is translated such that the span is preserved and one endpoint touches the boundary of the [min, max] range. If the span exceeds (max - min), the range [min, max] is returned.\n#
indexof(array, value)
Returns the first index of value in the input array.\n#
inrange(value, range)
Tests whether value lies within (or is equal to either) the first and last values of the range array.\n#
join(array[, separator]) ≥ 5.3
Returns a new string by concatenating all of the elements of the input array, separated by commas or a specified separator string.\n#
lastindexof(array, value)
Returns the last index of value in the input array.\n#
length(array)
Returns the length of the input array.\n#
lerp(array, fraction)
Returns the linearly interpolated value between the first and last entries in the array for the provided interpolation fraction (typically between 0 and 1). For example, lerp([0, 50], 0.5) returns 25.\n#
peek(array)
Returns the last element in the input array. Similar to the built-in Array.pop method, except that it does not remove the last element. This method is a convenient shorthand for array[array.length - 1].\n#
pluck(array, field) ≥ 5.19
Retrieves the value for the specified field from a given array of objects. The input field string may include nested properties (e.g., foo.bar.bz).\n#
reverse(array) ≥ 5.3
Returns a new array with elements in a reverse order of the input array. The first array element becomes the last, and the last array element becomes the first.\n#
sequence([start, ]stop[, step])
Returns an array containing an arithmetic sequence of numbers. If step is omitted, it defaults to 1. If start is omitted, it defaults to 0. The stop value is exclusive; it is not included in the result. If step is positive, the last element is the largest start + i * step less than stop; if step is negative, the last element is the smallest start + i * step greater than stop. If the returned array would contain an infinite number of values, an empty range is returned. The arguments are not required to be integers.\n#
slice(array, start[, end])
Returns a section of array between the start and end indices. If the end argument is negative, it is treated as an offset from the end of the array (length(array) + end).\n#
sort(array)≥ 5.31
Sorts the array in natural order using ascending from Vega Utils.\nascending from Vega Utils\n#
span(array)
Returns the span of array: the difference between the last and first elements, or array[array.length-1] - array[0].\nFunctions for modifying text strings.\n#
indexof(string, substring)
Returns the first index of substring in the input string.\n#
lastindexof(string, substring)
Returns the last index of substring in the input string.\n#
length(string)
Returns the length of the input string.\n#
lower(string)
Transforms string to lower-case letters.\n#
pad(string, length[, character, align])
Pads a string value with repeated instances of a character up to a specified length. If character is not specified, a space (‘ ‘) is used. By default, padding is added to the end of a string. An optional align parameter specifies if padding should be added to the 'left' (beginning), 'center', or 'right' (end) of the input string.\n#
parseFloat(string)
Parses the input string to a floating-point value. Same as JavaScript’s parseFloat.\n#
parseInt(string)
Parses the input string to an integer value. Same as JavaScript’s parseInt.\n#
replace(string, pattern, replacement)
Returns a new string with some or all matches of pattern replaced by a replacement string. The pattern can be a string or a regular expression. If pattern is a string, only the first instance will be replaced. Same as JavaScript’s String.replace.\nJavaScript’s String.replace\n#
slice(string, start[, end])
Returns a section of string between the start and end indices. If the end argument is negative, it is treated as an offset from the end of the string (length(string) + end).\n#
split(string, separator[, limit]) ≥ 4.3
Returns an array of tokens created by splitting the input string according to a provided separator pattern. The result can optionally be constrained to return at most limit tokens.\n#
substring(string, start[, end])
Returns a section of string between the start and end indices.\n#
trim(string) ≥ 5.3
Returns a trimmed string with preceding and trailing whitespace removed.\n#
truncate(string, length[, align, ellipsis])
Truncates an input string to a target length. The optional align argument indicates what part of the string should be truncated: 'left' (the beginning), 'center', or 'right' (the end). By default, the 'right' end of the string is truncated. The optional ellipsis argument indicates the string to use to indicate truncated content; by default the ellipsis character … (\u2026) is used.\n#
upper(string)
Transforms string to upper-case letters.\n#
btoa(string) ≥ 5.32.0
Creates a Base64-encoded ASCII string. Same as JavaScript’s Window.btoa().\n#
atob(string) ≥ 5.32.0
Decodes an ASCII string that was encoded with Base64. Same as JavaScript’s Window.atob().\nFunctions for manipulating object instances.\n#
merge(object1[, object2, …]) ≥ 4.0
Merges the input objects object1, object2, etc into a new output object. Inputs are visited in sequential order, such that key values from later arguments can overwrite those from earlier arguments. Example: merge({a:1, b:2}, {a:3}) -> {a:3, b:2}.\nFunctions for formatting number and datetime values as strings.\n#
dayFormat(day)
Formats a (0-6) weekday number as a full week day name, according to the current locale. For example: dayFormat(0) -> "Sunday".\n#
dayAbbrevFormat(day)
Formats a (0-6) weekday number as an abbreviated week day name, according to the current locale. For example: dayAbbrevFormat(0) -> "Sun".\n#
format(value, specifier)
Formats a numeric value as a string. The specifier must be a valid d3-format specifier (e.g., format(value, ',.2f').
Null values are formatted as "null".\n#
monthFormat(month)
Formats a (zero-based) month number as a full month name, according to the current locale. For example: monthFormat(0) -> "January".\n#
monthAbbrevFormat(month)
Formats a (zero-based) month number as an abbreviated month name, according to the current locale. For example: monthAbbrevFormat(0) -> "Jan".\n#
timeUnitSpecifier(units[, specifiers]) ≥ 5.8
Returns a time format specifier string for the given time units. The optional specifiers object provides a set of specifier sub-strings for customizing the format; for more, see the timeUnitSpecifier API documentation. The resulting specifier string can then be used as input to the timeFormat or utcFormat functions, or as the format parameter of an axis or legend. For example: timeFormat(date, timeUnitSpecifier('year')) or timeFormat(date, timeUnitSpecifier(['hours', 'minutes'])).\ntimeUnitSpecifier API documentation\n#
timeFormat(value, specifier)
Formats a datetime value (either a Date object or timestamp) as a string, according to the local time. The specifier must be a valid d3-time-format specifier or TimeMultiFormat object ≥ 5.8. For example: timeFormat(timestamp, '%A').
Null values are formatted as "null".\nd3-time-format specifier\nTimeMultiFormat object\n#
timeParse(string, specifier)
Parses a string value to a Date object, according to the local time. The specifier must be a valid d3-time-format specifier. For example: timeParse('June 30, 2015', '%B %d, %Y').\nd3-time-format specifier\n#
utcFormat(value, specifier)
Formats a datetime value (either a Date object or timestamp) as a string, according to UTC time. The specifier must be a valid d3-time-format specifier or TimeMultiFormat object ≥ 5.8. For example: utcFormat(timestamp, '%A').
Null values are formatted as "null".\nd3-time-format specifier\nTimeMultiFormat object\n#
utcParse(value, specifier)
Parses a string value to a Date object, according to UTC time. The specifier must be a valid d3-time-format specifier. For example: utcParse('June 30, 2015', '%B %d, %Y').\nd3-time-format specifier\nFunctions for creating and applying regular expressions.\n#
regexp(pattern[, flags]) -
Creates a regular expression instance from an input pattern string and optional flags. Same as JavaScript’s RegExp.\n#
test(regexp[, string]) -
Evaluates a regular expression regexp against the input string, returning true if the string matches the pattern, false otherwise. For example: test(/\\d{3}/, "32-21-9483") -> true.\nFunctions for representing colors in various color spaces. Color functions return objects that, when coerced to a string, map to valid CSS RGB colors.\n#
rgb(r, g, b[, opacity]) |
rgb(specifier)
Constructs a new RGB color. If r, g and b are specified, these represent the channel values of the returned color; an opacity may also be specified. If a CSS Color Module Level 3 specifier string is specified, it is parsed and then converted to the RGB color space. Uses d3-color’s rgb function.\nd3-color’s rgb function\n#
hsl(h, s, l[, opacity]) |
hsl(specifier)
Constructs a new HSL color. If h, s and l are specified, these represent the channel values of the returned color; an opacity may also be specified. If a CSS Color Module Level 3 specifier string is specified, it is parsed and then converted to the HSL color space. Uses d3-color’s hsl function.\nd3-color’s hsl function\n#
lab(l, a, b[, opacity]) |
lab(specifier)
Constructs a new CIE LAB color. If l, a and b are specified, these represent the channel values of the returned color; an opacity may also be specified. If a CSS Color Module Level 3 specifier string is specified, it is parsed and then converted to the LAB color space. Uses d3-color’s lab function.\nd3-color’s lab function\n#
hcl(h, c, l[, opacity]) |
hcl(specifier)
Constructs a new HCL (hue, chroma, luminance) color. If h, c and l are specified, these represent the channel values of the returned color; an opacity may also be specified. If a CSS Color Module Level 3 specifier string is specified, it is parsed and then converted to the HCL color space. Uses d3-color’s hcl function.\nd3-color’s hcl function\n#
luminance(specifier) ≥ 5.7
Returns the luminance for the given color specifier (compatible with d3-color’s rgb function). The luminance is calculated according to the W3C Web Content Accessibility Guidelines.\nd3-color’s rgb function\nW3C Web Content Accessibility Guidelines\n#
contrast(specifier1, specifier2) ≥ 5.7
Returns the contrast ratio between the input color specifiers as a float between 1 and 21. The contrast is calculated according to the W3C Web Content Accessibility Guidelines.\nW3C Web Content Accessibility Guidelines\nFunctions for processing input event data. These functions are only legal in expressions evaluated in response to an event (for example a signal event handler). Invoking these functions elsewhere can result in errors.\n#
item()
Returns the current scenegraph item that is the target of the event.\n#
group([name])
Returns the scenegraph group mark item in which the current event has occurred. If no arguments are provided, the immediate parent group is returned. If a group name is provided, the matching ancestor group item is returned.\n#
xy([item])
Returns the x- and y-coordinates for the current event as a two-element array. If no arguments are provided, the top-level coordinate space of the view is used. If a scenegraph item (or string group name) is provided, the coordinate space of the group item is used.\n#
x([item])
Returns the x coordinate for the current event. If no arguments are provided, the top-level coordinate space of the view is used. If a scenegraph item (or string group name) is provided, the coordinate space of the group item is used.\n#
y([item])
Returns the y coordinate for the current event. If no arguments are provided, the top-level coordinate space of the view is used. If a scenegraph item (or string group name) is provided, the coordinate space of the group item is used.\n#
pinchDistance(event)
Returns the pixel distance between the first two touch points of a multi-touch event.\n#
pinchAngle(event)
Returns the angle of the line connecting the first two touch points of a multi-touch event.\n#
inScope(item)
Returns true if the given scenegraph item is a descendant of the group mark in which the event handler was defined, false otherwise.\nFunctions for accessing Vega data sets.\n#
data(name)
Returns the array of data objects for the Vega data set with the given name. If the data set is not found, returns an empty array.\n#
indata(name, field, value)
Tests if the data set with a given name contains a datum with a field value that matches the input value. For example: indata('table', 'category', value).\nScale and Projection Functions\nFunctions for working with Vega scale transforms and cartographic projections.\n#
scale(name, value[, group])
Applies the named scale transform (or projection) to the specified value. The optional group argument takes a scenegraph group mark item to indicate the specific scope in which to look up the scale or projection.\n#
invert(name, value[, group])
Inverts the named scale transform (or projection) for the specified value. The optional group argument takes a scenegraph group mark item to indicate the specific scope in which to look up the scale or projection.\n#
copy(name[, group])
Returns a copy (a new cloned instance) of the named scale transform of projection, or undefined if no scale or projection is found. The optional group argument takes a scenegraph group mark item to indicate the specific scope in which to look up the scale or projection.\n#
domain(name[, group])
Returns the scale domain array for the named scale transform, or an empty array if the scale is not found. The optional group argument takes a scenegraph group mark item to indicate the specific scope in which to look up the scale.\n#
range(name[, group])
Returns the scale range array for the named scale transform, or an empty array if the scale is not found. The optional group argument takes a scenegraph group mark item to indicate the specific scope in which to look up the scale.\n#
bandwidth(name[, group])
Returns the current band width for the named band scale transform, or zero if the scale is not found or is not a band scale. The optional group argument takes a scenegraph group mark item to indicate the specific scope in which to look up the scale.\n#
bandspace(count[, paddingInner, paddingOuter])
Returns the number of steps needed within a band scale, based on the count of domain elements and the inner and outer padding values. While normally calculated within the scale itself, this function can be helpful for determining the size of a chart’s layout.\n#
gradient(scale, p0, p1[, count])
Returns a linear color gradient for the scale (whose range must be a continuous color scheme) and starting and ending points p0 and p1, each an [x, y] array. The points p0 and p1 should be expressed in normalized coordinates in the domain [0, 1], relative to the bounds of the item being colored. If unspecified, p0 defaults to [0, 0] and p1 defaults to [1, 0], for a horizontal gradient that spans the full bounds of an item. The optional count argument indicates a desired target number of sample points to take from the color scale.\ncontinuous color scheme\n#
panLinear(domain, delta)
Given a linear scale domain array with numeric or datetime values, returns a new two-element domain array that is the result of panning the domain by a fractional delta. The delta value represents fractional units of the scale range; for example, 0.5 indicates panning the scale domain to the right by half the scale range.\n#
panLog(domain, delta)
Given a log scale domain array with numeric or datetime values, returns a new two-element domain array that is the result of panning the domain by a fractional delta. The delta value represents fractional units of the scale range; for example, 0.5 indicates panning the scale domain to the right by half the scale range.\n#
panPow(domain, delta, exponent)
Given a power scale domain array with numeric or datetime values and the given exponent, returns a new two-element domain array that is the result of panning the domain by a fractional delta. The delta value represents fractional units of the scale range; for example, 0.5 indicates panning the scale domain to the right by half the scale range.\n#
panSymlog(domain, delta, constant)
Given a symmetric log scale domain array with numeric or datetime values parameterized by the given constant, returns a new two-element domain array that is the result of panning the domain by a fractional delta. The delta value represents fractional units of the scale range; for example, 0.5 indicates panning the scale domain to the right by half the scale range.\n#
zoomLinear(domain, anchor, scaleFactor)
Given a linear scale domain array with numeric or datetime values, returns a new two-element domain array that is the result of zooming the domain by a scaleFactor, centered at the provided fractional anchor. The anchor value represents the zoom position in terms of fractional units of the scale range; for example, 0.5 indicates a zoom centered on the mid-point of the scale range.\n#
zoomLog(domain, anchor, scaleFactor)
Given a log scale domain array with numeric or datetime values, returns a new two-element domain array that is the result of zooming the domain by a scaleFactor, centered at the provided fractional anchor. The anchor value represents the zoom position in terms of fractional units of the scale range; for example, 0.5 indicates a zoom centered on the mid-point of the scale range.\n#
zoomPow(domain, anchor, scaleFactor, exponent)
Given a power scale domain array with numeric or datetime values and the given exponent, returns a new two-element domain array that is the result of zooming the domain by a scaleFactor, centered at the provided fractional anchor. The anchor value represents the zoom position in terms of fractional units of the scale range; for example, 0.5 indicates a zoom centered on the mid-point of the scale range.\n#
zoomSymlog(domain, anchor, scaleFactor, constant)
Given a symmetric log scale domain array with numeric or datetime values parameterized by the given constant, returns a new two-element domain array that is the result of zooming the domain by a scaleFactor, centered at the provided fractional anchor. The anchor value represents the zoom position in terms of fractional units of the scale range; for example, 0.5 indicates a zoom centered on the mid-point of the scale range.\nFunctions for analyzing geographic regions represented as GeoJSON features.\n#
geoArea(projection, feature[, group])
Returns the projected planar area (typically in square pixels) of a GeoJSON feature according to the named projection. If the projection argument is null, computes the spherical area in steradians using unprojected longitude, latitude coordinates. The optional group argument takes a scenegraph group mark item to indicate the specific scope in which to look up the projection. Uses d3-geo’s geoArea and path.area methods.\n#
geoBounds(projection, feature[, group])
Returns the projected planar bounding box (typically in pixels) for the specified GeoJSON feature, according to the named projection. The bounding box is represented by a two-dimensional array: [[x₀, y₀], [x₁, y₁]], where x₀ is the minimum x-coordinate, y₀ is the minimum y-coordinate, x₁ is the maximum x-coordinate, and y₁ is the maximum y-coordinate. If the projection argument is null, computes the spherical bounding box using unprojected longitude, latitude coordinates. The optional group argument takes a scenegraph group mark item to indicate the specific scope in which to look up the projection. Uses d3-geo’s geoBounds and path.bounds methods.\n#
geoCentroid(projection, feature[, group])
Returns the projected planar centroid (typically in pixels) for the specified GeoJSON feature, according to the named projection. If the projection argument is null, computes the spherical centroid using unprojected longitude, latitude coordinates. The optional group argument takes a scenegraph group mark item to indicate the specific scope in which to look up the projection. Uses d3-geo’s geoCentroid and path.centroid methods.\n#
geoScale(projection[, group])
Returns the scale value for the named projection. The optional group argument takes a scenegraph group mark item to indicate the specific scope in which to look up the projection.\nTree (Hierarchy) Functions\nFunctions for processing hierarchy data sets constructed with the stratify or nest transforms.\n#
treePath(name, source, target)
For the hierarchy data set with the given name, returns the shortest path through from the source node id to the target node id. The path starts at the source node, ascends to the least common ancestor of the source node and the target node, and then descends to the target node.\n#
treeAncestors(name, node)
For the hierarchy data set with the given name, returns the array of ancestors nodes, starting with the input node, then followed by each parent up to the root.\nFunctions for accessing web browser facilities.\n#
containerSize()
Returns the current CSS box size ([el.clientWidth, el.clientHeight]) of the parent DOM element that contains the Vega view. If there is no container element, returns [undefined, undefined].\n#
screen()
Returns the window.screen object, or {} if Vega is not running in a browser environment.\n#
windowSize()
Returns the current window size ([window.innerWidth, window.innerHeight]) or [undefined, undefined] if Vega is not running in a browser environment.\nLogging functions for writing messages to the console. These can be helpful when debugging expressions.\n#
warn(value1[, value2, …])
Logs a warning message and returns the last argument. For the message to appear in the console, the visualization view must have the appropriate logging level set.\n#
info(value1[, value2, …])
Logs an informative message and returns the last argument. For the message to appear in the console, the visualization view must have the appropriate logging level set.\n#
debug(value1[, value2, …])
Logs a debugging message and returns the last argument. For the message to appear in the console, the visualization view must have the appropriate logging level set.\n\n\nVega
            
              Vega-Lite
              Altair
              Vega-Lite API
            
          
          
            
              Examples
              Tutorials
              Documentation
              Usage
              About
            
            
              GitHub
              Try Online
            
          
        
      

      
        

  
  
    
      
      
        Documentation
      
      
      
      
        Specification
      
      
      
      
        Config
      
      
      
      
        Data
      
      
      
      
        Transforms
      
      
      
      
        Triggers
      
      
      
      
        Projections
      
      
      
      
        Scales
      
      
      
      
        Schemes
      
      
      
      
        Axes
      
      
      
      
        Legends
      
      
      
      
        Title
      
      
      
      
        Marks
      
      
      
      
        Signals
      
      
      
      
        Event Streams
      
      
      
      
        Expressions
      
      
      
      
        Layout
      
      
      
      
        Types
      
      
    
  
  
    Layout
    A layout positions a collection of group marks within a grid, simplifying the composition of small multiples and coordinated multiple view displays. When applied at the top-level of a specification or within a group mark, all immediate children group marks will be collected and positioned according to the layout specification. The layout engine supports flow layout as well as column, row, and grid-aligned layouts.

The layout engine also supports inclusion of header and footer cells for both rows and columns, as well as row title and column title cells. To indicate headers, footers and titles, the specifications for these groups must include a role property set to one of column-header, column-footer, column-title, row-header, row-footer, or row-title. The number of header, footer, or title elements should match the number of rows or columns in the table. If there are fewer elements, some cells will be left empty. If there are too many elements, the additional elements will be ignored and a warning will be logged.

The order of groups within the layout depends on both specification order (across group mark definitions) and internal mark ordering (for multiple group instances within a single group mark definition). The order that group mark definitions appear in the specification determines their order in the layout. Within a single group mark specification with multiple group instances, the internal ordering of the group items determines both their rendering order and their order in the layout. The internal order can be modified using the sort directive.

Layout Properties

Properties for specifying a grid layout of contained group marks.


  
    
      Property
      Type
      Description
    
  
  
    
      align
      String | Object
      The alignment to apply to grid rows and columns. The supported string values are all, each, and none (the default). If set to none, a flow layout will be used, in which adjacent plots are simply placed one after the other. If set to each, elements will be  aligned into a clean grid structure, but each row or column may be of variable size. If set to all, elements will be aligned and each row or column will be sized identically based on the maximum observed size. String values for this property will be applied to both grid rows and columns. Alternatively, an object value of the form {"row": string, "column": string} can be used to supply different alignments for rows and columns.
    
    
      bounds
      String
      The bounds calculation method to use for determining the extent of a sub-plot. One of full (the default) or flush. If set to full, the entire calculated bounds (including axes, title, and legend) will be used. If set to flush, only the specified width and height values for the group mark will be used. The flush setting can be useful when attempting to place sub-plots without axes or legends into a uniform grid structure.
    
    
      center
      Boolean | Object
      Boolean flag indicating if group items should be centered relative to their respective rows or columns. An object value of the form {"row": boolean, "column": boolean} can be used to supply different centering values for rows and columns. By default no centering is performed.
    
    
      columns
      Number
      The number of columns to include in the layout. If unspecified, an infinite number of columns (a single row) will be assumed.
    
    
      padding
      Number | Object
      The padding in pixels to add between elements within a row or column. An object value of the form {"row": number, "column": number} can be used to supply different padding values for rows and columns.
    
    
      offset
      Number | Object
      The orthogonal offset in pixels by which to displace grid header, footer, and title cells from their position along the edge of the grid (default 0). A number value applies to all header, footer, and title elements. An object value can be used to supply different values for each element; the supported properties are columnHeader, columnFooter, columnTitle, rowHeader, rowFooter, and rowTitle.
    
    
      headerBand
      Number | Object
      A band positioning parameter in the interval [0,1] indicating where in a cell a header should be placed. For a column header, 0 maps to the left edge of the header cell and 1 to right edge. A number value applies to both row and column headers. An object value of the form {"row": number, "column": number} can be used to supply different values for row and column headers. The default value is null, indicating the header is positioned using the x (for columns) or y (for rows) coordinate of the nearest grid content cell.
    
    
      footerBand
      Number | Object
      A band positioning parameter in the interval [0,1] indicating where in a cell a footer should be placed. For a column footer, 0 maps to the left edge of the footer cell and 1 to right edge. A number value applies to both row and column footers. An object value of the form {"row": number, "column": number} can be used to supply different values for row and column footers. The default value is null, indicating the footer is positioned using the x (for columns) or y (for rows) coordinate of the nearest grid content cell.
    
    
      titleAnchor
      String | Object
      An anchor position for specifying which side of the grid a title should be placed. One of "start" (the default) for placing row titles on the left and column titles on the top, or "end" for placing row titles on the right and column titles on the bottom. A string value applies to both row and column titles. An object value of the form {"row": string, "column": string} can be used to supply different values for row and column titles.
    
    
      titleBand
      Number | Object
      A band positioning parameter in the interval [0,1] indicating where in a cell a title should be placed. For a column title, 0 maps to the left edge of the title cell and 1 to right edge. The default value is 0.5, indicating a centered position. A number value applies to both row and column titles. An object value of the form {"row": number, "column": number} can be used to supply different values for row and column titles.\nVega
            
              Vega-Lite
              Altair
              Vega-Lite API\nVega-Lite
              Altair
              Vega-Lite API\nExamples
              Tutorials
              Documentation
              Usage
              About
            
            
              GitHub
              Try Online\nExamples
              Tutorials
              Documentation
              Usage
              About\nGitHub
              Try Online\nDocumentation
      
      
      
      
        Specification
      
      
      
      
        Config
      
      
      
      
        Data
      
      
      
      
        Transforms
      
      
      
      
        Triggers
      
      
      
      
        Projections
      
      
      
      
        Scales
      
      
      
      
        Schemes
      
      
      
      
        Axes
      
      
      
      
        Legends
      
      
      
      
        Title
      
      
      
      
        Marks
      
      
      
      
        Signals
      
      
      
      
        Event Streams
      
      
      
      
        Expressions
      
      
      
      
        Layout
      
      
      
      
        Types
      
      
    
  
  
    Layout
    A layout positions a collection of group marks within a grid, simplifying the composition of small multiples and coordinated multiple view displays. When applied at the top-level of a specification or within a group mark, all immediate children group marks will be collected and positioned according to the layout specification. The layout engine supports flow layout as well as column, row, and grid-aligned layouts.

The layout engine also supports inclusion of header and footer cells for both rows and columns, as well as row title and column title cells. To indicate headers, footers and titles, the specifications for these groups must include a role property set to one of column-header, column-footer, column-title, row-header, row-footer, or row-title. The number of header, footer, or title elements should match the number of rows or columns in the table. If there are fewer elements, some cells will be left empty. If there are too many elements, the additional elements will be ignored and a warning will be logged.

The order of groups within the layout depends on both specification order (across group mark definitions) and internal mark ordering (for multiple group instances within a single group mark definition). The order that group mark definitions appear in the specification determines their order in the layout. Within a single group mark specification with multiple group instances, the internal ordering of the group items determines both their rendering order and their order in the layout. The internal order can be modified using the sort directive.

Layout Properties

Properties for specifying a grid layout of contained group marks.


  
    
      Property
      Type
      Description
    
  
  
    
      align
      String | Object
      The alignment to apply to grid rows and columns. The supported string values are all, each, and none (the default). If set to none, a flow layout will be used, in which adjacent plots are simply placed one after the other. If set to each, elements will be  aligned into a clean grid structure, but each row or column may be of variable size. If set to all, elements will be aligned and each row or column will be sized identically based on the maximum observed size. String values for this property will be applied to both grid rows and columns. Alternatively, an object value of the form {"row": string, "column": string} can be used to supply different alignments for rows and columns.
    
    
      bounds
      String
      The bounds calculation method to use for determining the extent of a sub-plot. One of full (the default) or flush. If set to full, the entire calculated bounds (including axes, title, and legend) will be used. If set to flush, only the specified width and height values for the group mark will be used. The flush setting can be useful when attempting to place sub-plots without axes or legends into a uniform grid structure.
    
    
      center
      Boolean | Object
      Boolean flag indicating if group items should be centered relative to their respective rows or columns. An object value of the form {"row": boolean, "column": boolean} can be used to supply different centering values for rows and columns. By default no centering is performed.
    
    
      columns
      Number
      The number of columns to include in the layout. If unspecified, an infinite number of columns (a single row) will be assumed.
    
    
      padding
      Number | Object
      The padding in pixels to add between elements within a row or column. An object value of the form {"row": number, "column": number} can be used to supply different padding values for rows and columns.
    
    
      offset
      Number | Object
      The orthogonal offset in pixels by which to displace grid header, footer, and title cells from their position along the edge of the grid (default 0). A number value applies to all header, footer, and title elements. An object value can be used to supply different values for each element; the supported properties are columnHeader, columnFooter, columnTitle, rowHeader, rowFooter, and rowTitle.
    
    
      headerBand
      Number | Object
      A band positioning parameter in the interval [0,1] indicating where in a cell a header should be placed. For a column header, 0 maps to the left edge of the header cell and 1 to right edge. A number value applies to both row and column headers. An object value of the form {"row": number, "column": number} can be used to supply different values for row and column headers. The default value is null, indicating the header is positioned using the x (for columns) or y (for rows) coordinate of the nearest grid content cell.
    
    
      footerBand
      Number | Object
      A band positioning parameter in the interval [0,1] indicating where in a cell a footer should be placed. For a column footer, 0 maps to the left edge of the footer cell and 1 to right edge. A number value applies to both row and column footers. An object value of the form {"row": number, "column": number} can be used to supply different values for row and column footers. The default value is null, indicating the footer is positioned using the x (for columns) or y (for rows) coordinate of the nearest grid content cell.
    
    
      titleAnchor
      String | Object
      An anchor position for specifying which side of the grid a title should be placed. One of "start" (the default) for placing row titles on the left and column titles on the top, or "end" for placing row titles on the right and column titles on the bottom. A string value applies to both row and column titles. An object value of the form {"row": string, "column": string} can be used to supply different values for row and column titles.
    
    
      titleBand
      Number | Object
      A band positioning parameter in the interval [0,1] indicating where in a cell a title should be placed. For a column title, 0 maps to the left edge of the title cell and 1 to right edge. The default value is 0.5, indicating a centered position. A number value applies to both row and column titles. An object value of the form {"row": number, "column": number} can be used to supply different values for row and column titles.\nA layout positions a collection of group marks within a grid, simplifying the composition of small multiples and coordinated multiple view displays. When applied at the top-level of a specification or within a group mark, all immediate children group marks will be collected and positioned according to the layout specification. The layout engine supports flow layout as well as column, row, and grid-aligned layouts.\nThe layout engine also supports inclusion of header and footer cells for both rows and columns, as well as row title and column title cells. To indicate headers, footers and titles, the specifications for these groups must include a role property set to one of column-header, column-footer, column-title, row-header, row-footer, or row-title. The number of header, footer, or title elements should match the number of rows or columns in the table. If there are fewer elements, some cells will be left empty. If there are too many elements, the additional elements will be ignored and a warning will be logged.\nThe order of groups within the layout depends on both specification order (across group mark definitions) and internal mark ordering (for multiple group instances within a single group mark definition). The order that group mark definitions appear in the specification determines their order in the layout. Within a single group mark specification with multiple group instances, the internal ordering of the group items determines both their rendering order and their order in the layout. The internal order can be modified using the sort directive.\nProperties for specifying a grid layout of contained group marks.\nThe alignment to apply to grid rows and columns. The supported string values are all, each, and none (the default). If set to none, a flow layout will be used, in which adjacent plots are simply placed one after the other. If set to each, elements will be  aligned into a clean grid structure, but each row or column may be of variable size. If set to all, elements will be aligned and each row or column will be sized identically based on the maximum observed size. String values for this property will be applied to both grid rows and columns. Alternatively, an object value of the form {"row": string, "column": string} can be used to supply different alignments for rows and columns.\nThe bounds calculation method to use for determining the extent of a sub-plot. One of full (the default) or flush. If set to full, the entire calculated bounds (including axes, title, and legend) will be used. If set to flush, only the specified width and height values for the group mark will be used. The flush setting can be useful when attempting to place sub-plots without axes or legends into a uniform grid structure.\nBoolean flag indicating if group items should be centered relative to their respective rows or columns. An object value of the form {"row": boolean, "column": boolean} can be used to supply different centering values for rows and columns. By default no centering is performed.\nThe number of columns to include in the layout. If unspecified, an infinite number of columns (a single row) will be assumed.\nThe padding in pixels to add between elements within a row or column. An object value of the form {"row": number, "column": number} can be used to supply different padding values for rows and columns.\nThe orthogonal offset in pixels by which to displace grid header, footer, and title cells from their position along the edge of the grid (default 0). A number value applies to all header, footer, and title elements. An object value can be used to supply different values for each element; the supported properties are columnHeader, columnFooter, columnTitle, rowHeader, rowFooter, and rowTitle.\nA band positioning parameter in the interval [0,1] indicating where in a cell a header should be placed. For a column header, 0 maps to the left edge of the header cell and 1 to right edge. A number value applies to both row and column headers. An object value of the form {"row": number, "column": number} can be used to supply different values for row and column headers. The default value is null, indicating the header is positioned using the x (for columns) or y (for rows) coordinate of the nearest grid content cell.\nA band positioning parameter in the interval [0,1] indicating where in a cell a footer should be placed. For a column footer, 0 maps to the left edge of the footer cell and 1 to right edge. A number value applies to both row and column footers. An object value of the form {"row": number, "column": number} can be used to supply different values for row and column footers. The default value is null, indicating the footer is positioned using the x (for columns) or y (for rows) coordinate of the nearest grid content cell.\nAn anchor position for specifying which side of the grid a title should be placed. One of "start" (the default) for placing row titles on the left and column titles on the top, or "end" for placing row titles on the right and column titles on the bottom. A string value applies to both row and column titles. An object value of the form {"row": string, "column": string} can be used to supply different values for row and column titles.\nA band positioning parameter in the interval [0,1] indicating where in a cell a title should be placed. For a column title, 0 maps to the left edge of the title cell and 1 to right edge. The default value is 0.5, indicating a centered position. A number value applies to both row and column titles. An object value of the form {"row": number, "column": number} can be used to supply different values for row and column titles.\n\n\nVega
            
              Vega-Lite
              Altair
              Vega-Lite API
            
          
          
            
              Examples
              Tutorials
              Documentation
              Usage
              About
            
            
              GitHub
              Try Online
            
          
        
      

      
        

  
  
    
      
      
        Documentation
      
      
      
      
        Specification
      
      
      
      
        Config
      
      
      
      
        Data
      
      
      
      
        Transforms
      
      
      
      
        Triggers
      
      
      
      
        Projections
      
      
      
      
        Scales
      
      
      
      
        Schemes
      
      
      
      
        Axes
      
      
      
      
        Legends
      
      
      
      
        Title
      
      
      
      
        Marks
      
      
      
      
        Signals
      
      
      
      
        Event Streams
      
      
      
      
        Expressions
      
      
      
      
        Layout
      
      
      
      
        Types
      
      
    
  
  
    Parameter Types
    Reference documentation for common parameter types expected by Vega specification properties.

Parameter Type Reference


  Any
  Array
  Boolean
  Color
  Date
  Gradient
  Number
  Object
  String
  URL
  Data
  Field
  Signal
  Compare
  Expr
  Value
  ColorValue
  FieldValue
  GradientValue
  TimeMultiFormat


Literal Values

#
Any or *

Accepts any literal value, including a string, number, boolean, or null.

#
Array or Type[ ]

Accepts array values. For example: [], [1, 2, 3], ["foo", "bar"]. If individual array items must adhere to a specific type, bracket notation – such as Number[ ] or String[ ] – is used to indicate the item type.

In most cases, arrays may also have signal references as items. For example: [{"signal": "width"}, {"signal": "height"}].

#
Boolean

Accepts boolean values. For example: true, false.

#
Color

Accepts a valid CSS color string. For example: #f304d3, #ccc, rgb(253, 12, 134), steelblue.

#
Date

A valid JavaScript Date object or timestamp. As JSON does not support date values natively, within a Vega specification a date-time value can be expressed either as a numeric timestamp (the number of milliseconds since the UNIX epoch, as produced by the Date.getTime() method) or using a signal expression (such as {"signal": "datetime(2001, 2, 3)"}).

#
Gradient ≥ 5.4

Accepts an object that specifies a gradient color pattern. To define a linear gradient based on a color scale, use a GradientValue instead.

For example:

{
  "gradient": "linear",
  "stops": [
    {"offset": 0.0, "color": "red"},
    {"offset": 0.5, "color": "white"},
    {"offset": 1.0, "color": "blue"}
  ]
}


#
Linear Gradient

A linear gradient interpolates colors along a line, from a starting point to an ending point. By default a linear gradient runs horizontally, from left to right. Use the x1, y1, x2, and y2 properties to configure the gradient direction. All coordinates are defined in a normalized [0, 1] coordinate space, relative to the bounding box of the item being colored.


  
    
      Name
      Type
      Description
    
  
  
    
      gradient
      String
      Required. The type of gradient. Use "linear" for a linear gradient.
    
    
      x1
      Number
      The starting x-coordinate, in normalized [0, 1] coordinates, of the linear gradient (default 0).
    
    
      y1
      Number
      The starting y-coordinate, in normalized [0, 1] coordinates, of the linear gradient (default 0).
    
    
      x2
      Number
      The ending x-coordinate, in normalized [0, 1] coordinates, of the linear gradient (default 1).
    
    
      y2
      Number
      The ending y-coordinate, in normalized [0, 1] coordinates, of the linear gradient (default 0).
    
    
      stops
      GradientStop[ ]
      Required. An array of gradient stops defining the gradient color sequence.
    
  


#
Radial Gradient

A radial gradient interpolates colors between two circles, from an inner circle boundary to an outer circle boundary. By default a radial gradient runs from the center point of the coordinate system (zero radius inner circle), out to the maximum extent (0.5 radius outer circle). Use the x1, y1, x2, and y2 properties to configure the inner and outer circle center points, and use the r1 and r2 properties to configure the circle radii. All coordinates are defined in a normalized [0, 1] coordinate space, relative to the bounding box of the item being colored. A value of 1 corresponds to the maximum extent of the bounding box (width or height, whichever is larger).


  
    
      Name
      Type
      Description
    
  
  
    
      gradient
      String
      Required. The type of gradient. Use "radial" for a radial gradient.
    
    
      x1
      Number
      The x-coordinate, in normalized [0, 1] coordinates, for the center of the inner circle for the gradient (default 0.5).
    
    
      y1
      Number
      The y-coordinate, in normalized [0, 1] coordinates, for the center of the inner circle for the gradient (default 0.5).
    
    
      r1
      Number
      The radius length, in normalized [0, 1] coordinates, of the inner circle for the gradient (default 0).
    
    
      x2
      Number
      The x-coordinate, in normalized [0, 1] coordinates, for the center of the outer circle for the gradient (default 0.5).
    
    
      y2
      Number
      The y-coordinate, in normalized [0, 1] coordinates, for the center of the outer circle for the gradient (default 0.5).
    
    
      r2
      Number
      The radius length, in normalized [0, 1] coordinates, of the outer circle for the gradient (default 0.5).
    
    
      stops
      GradientStop[ ]
      Required. An array of gradient stops defining the gradient color sequence.
    
  


#
Gradient Stop

A gradient stop consists of a Color value and an offset progress fraction.


  
    
      Name
      Type
      Description
    
  
  
    
      offset
      Number
      Required. The offset fraction for the color stop, indicating its position within the gradient.
    
    
      color
      Color
      Required. The color value at this point in the gradient.
    
  


#
Number

Accepts number values. For example: 1, 3.14, 1e5.

#
Object

Accepts object literals. For example: {"left":5, "right":30, "top":5, "bottom":50}. The valid object property names and types will vary across parameters; read the individual parameter descriptions for more information.

#
String

Accepts string values. For example: "bold", "step-before", "".

#
URL

Accepts a valid URL string linking to external site or resource. For example: "data/stocks.csv", "images/logo.png", "https://vega.github.io/".

Back to top

Data and Signal Types

#
Data

Accepts a string indicating the name of a data set. For example: "table", "nodes".

Back to top

#
Field

Accepts a string indicating the name of a data field. For example: "amount", "source.x", "target['x']".

Alternatively, accepts an object with a string-valued field parameter. For example: {"field": "amount"}, {"field": "source.x"}. In addition, the as parameter can be used to specify a different output name for a field. For example: {"field": "inputName", "as": "outputName"}.

Valid JavaScript object access paths using either dot (.) or bracket (foo['bar']) notation will be converted into lookups on nested objects. To specify field names that contain dots but are not nested lookups, escape the dot inline ("my\\.field") or enclose the field name in brackets ("[my.field]").

Back to top

#
Signal

Accepts an object with a reference to a signal value or expression. The signal property of the object must be either a valid signal name string or an expression string indicating a derived value. For example: {"signal": "width"}, {"signal": "width / 2"}.

Back to top

#
Compare

Accepts an object providing a comparator definition for sorting. Comparator objects may have two properties – field and order – indicating the data fields to sort by and the desired sort order for each field. Each property can take either a single string value (to sort by one field) or an array of string values (to sort by multiple fields).

The order property is optional. If defined, order values must be one of "ascending" (lowest-to-highest) or "descending" (highest-to-lowest). If order is not defined, or for cases where there are fewer order entries than field entries, ascending order is used by default.

A single field comparator:

{"field": "amount", "order": "ascending"}


A multi-field comparator:

{
  "field": ["amount", "date"],
  "order": ["descending", "ascending"]
}


Comparators can not be specified using a single signal instance. However, the individual field and order properties can use signals:

{
  "field": {"signal": "sortField"},
  "order": {"signal": "sortOrder"}
}


If a sort field is null, that field and any corresponding order entries will be ignored, just as if the entry did not exist.

Back to top

#
Expr

Accepts an object defining an expression to apply to each data object. Some transforms (for example the wordcloud transform) have parameters that can take a static string or number value or perform a lookup operation for each datum.

There are two valid forms of expression-typed values: field references and expr references.

A field reference results in a field lookup, identical to field-typed parameters:

{
  "type": "wordcloud",
  ...
  "rotate": {"field": "angle"} // per-datum lookup of the "angle" field
}


An expr reference provides an expression string that should be evaluated once per datum:

{
  "type": "wordcloud",
  ...
  "rotate": {"expr": "datum.minAngle + round(90*random() - 45)"} // evaluate once per-datum
}


Unlike signal references that are evaluated once per parameter, expr references behave like anonymous (or lambda) functions that are evaluated independently per data object.  Note that both signal and expr references will re-run if an upstream dependency changes.

Both field and expr references may include an as property that indicates the output field name to use.

Back to top

#
Value

Accepts an object defining a value reference, typically used for visual encoding. A value reference consists of a base value, plus optional scale transformation and modification.

Base Value

The base value must be specified using one of the following properties:


  
    
      Name
      Type
      Description
    
  
  
    
      signal
      String
      A signal name or expression.
    
    
      color
      ColorValue
      Specifies a color using value references for each color channel. See the color value documentation.
    
    
      field
      FieldValue
      A data field name or descriptor. See the field value documentation.
    
    
      value
      Any
      A constant value. Legal values include numbers, booleans, strings, colors, and gradients.
    
  


These properties are listed here in precedence order. For example, if signal is defined, any color, field or value properties will be ignored. In addition, the base value may be left undefined in the case of certain scale values, or to indicate a null value.

Scale Transforms

Once a base value is established, a scale lookup may be performed. The available scale-related properties are:


  
    
      Name
      Type
      Description
    
  
  
    
      scale
      String | FieldValue
      The name of a scale transform to apply. If this parameter is an object, it indicates a field value from which to dynamically lookup the scale name. For example {"datum": "s"} will use the value of field s on the current data object as the scale name, whereas {"parent": "t"} will use the value of field t on the parent group’s data object as the scale name.
    
    
      band
      Number
      If specified, returns the band width of the scale, multiplied by the given number. This parameter applies only to band scales. For example, {"band": 1} indicates the full band width, while {"band": 0.5} indicates half the band width. If the base value is defined, the multiplied band width is added to the output of the scale transform. For example, {"field": "a", "scale": "s", "band": 0.5} translates to scale(datum.a) + 0.5 * scale.bandwidth().
    
  


Value Modifiers

After any scale transformations are applied, the resulting value can be further modified using the following properties. The basic formula of a value reference is: pow(scale(baseValue), exponent) * mult + offset. Value modifiers are intended for use only with numeric values.


  
    
      Name
      Type
      Description
    
  
  
    
      exponent
      Number | Value
      Raise the value to a given exponent, equivalent to pow(value, exponent). If specified, exponentiation is applied immediately after any scale transformation.
    
    
      mult
      Number | Value
      A multiplier for the value, equivalent to mult * value. Multipliers are applied after any scale transformation or exponentiation.
    
    
      offset
      Number | Value
      An additive offset for the final value, equivalent to value + offset. Offsets are added after any scale transformation, exponentiation or multipliers.
    
    
      round
      Boolean
      Indicates if the final value should be rounded (default false). Rounding is performed after all other modifiers. If true, equivalent to round(value).
    
  


Examples


  {"value": 5} - The constant value 5.
  {"field": "price"} - The value of price, for the current datum.
  {"field": "index", "mult": 20} - The value of index for the current datum, multiplied by 20.
  {"scale": "x", "value": 0} - The result of running the value 0 through the scale named x.
  {"scale": "y", "field": "price"} - The result of running price for the current datum through the scale named y.
  {"scale": "x", "band": 1} - The range band width of the band scale x. Note that the scale must be of type “band”!
  {"scale": "x", "band": 1, "offset": -1} - The range band width of the band scale x, reduced (negative offset) by one pixel.


Back to top

#
ColorValue

Accepts an object that defines a custom color using value references for each color channel in a chosen color space. The color space is automatically inferred from the channel names used.

Typically color values are specified as a single value indicating an RGB color. However, sometimes a designer may wish to target specific color fields or use a different color space. In the following example, we can set the red and blue channels of an RGB color as constants, and determine the green channel from a scale transform.

{
  "fill": {
    "color": {
      "r": {"value": 255},
      "g": {"scale": "green", "field": "g"},
      "b": {"value": 0}
    }
  }
}


Vega supports the following color spaces:


  
    
      Name
      Description
    
  
  
    
      RGB
      Red, green, and blue channels defined with properties "r", "g", and "b".
    
    
      HSL
      Hue, saturation, and lightness channels defined with properties "h", "s", and "l".
    
    
      LAB
      Luminance, A (green-red contrast), and B (blue-yellow contrast) channels defined with properties "l", "a", and "b". LAB is a perceptual color space with distances based on human color judgments.
    
    
      HCL
      Hue, chroma, and luminance channels defined with properties "h", "c", and "l". HCL color space is a simple transform of LAB that uses polar coordinates for the AB plane.
    
  


Back to top

#
FieldValue

Accepts a string or an object indicating a data field value. If string-valued, the given data field name is used. If object-valued, the following properties may be used:


  
    
      Property
      Type
      Description
    
  
  
    
      signal
      String
      Evaluate the signal name or expression, and use the result as the field name to lookup.
    
    
      datum
      FieldValue
      Perform a lookup on the current data object using the given field name. This is similar to simply providing a string value.
    
    
      group
      FieldValue
      Use a property of the enclosing group mark instance as the value (e.g., "field": {"group": "width"} or "field": {"group": "height"}).
    
    
      parent
      FieldValue
      Use a field of the enclosing group mark’s data object as the value (e.g., "field": {"parent": "fieldInParentData"}.
    
  


These properties can be arbitrarily nested in order to perform indirect field lookups. For example, {"parent": {"datum": "f"}} will first retrieve the value of the f field on the current mark’s data object. This value will then be used as the property name to lookup on the enclosing parent group mark’s data object.

In addition, group and parent references may include an optional level property to access grandparents and other ancestors. For example, {"parent": "f", "level": 2} will use the value of the f field of the grandparent’s datum. By default, level = 1, indicating the immediate parent scope.

Back to top

#
GradientValue

Defines a linear gradient based on a scale range to determine colors for a fill or stroke encoding channel. To define a gradient directly, without reference to a scale, assign a Gradient definition as an encoding’s value property.


  
    
      Property
      Type
      Description
    
  
  
    
      gradient
      String | FieldValue
      Required. The name of a scale whose range is a continuous color scheme.
    
    
      start
      Number[ ]
      The starting coordinate for the gradient as an [x, y] array within a normalized [0, 1] coordinate system. This coordinate is relative to the bounds of the item being colored. Defaults to [0, 0].
    
    
      stop
      Number[ ]
      The stopping coordinate for the gradient as an [x, y] array within a normalized [0, 1] coordinate system. This coordinate is relative to the bounds of the item being colored. Defaults to [1, 0], for a horizontal gradient that spans the full bounds of an item.
    
    
      count
      Number
      A suggested target number of sample points to take from the color scale.
    
  


Example

{
  "encode": {
    "fill": {
      "gradient": "colorScale",
      "start": [0, 1],
      "stop": [0, 0],
      "count": 10
    }
  }
}


Back to top

#
TimeMultiFormat

An object defining custom multi-format specifications for date-time values. This object must be a legal input to the timeFormat API method:


  Object keys must be valid time units (e.g., year, month, etc).
  Object values must be valid d3-time-format specifier strings.


These values, in conjunction with defaults for unspecified units, will then be used to create a dynamic formatting function that uses different formats depending on the granularity of the input date (e.g., if the date lies on a year, month, date, hour, etc. boundary). For more information, see the timeFormat API documentation.

Back to top\nVega
            
              Vega-Lite
              Altair
              Vega-Lite API\nVega-Lite
              Altair
              Vega-Lite API\nExamples
              Tutorials
              Documentation
              Usage
              About
            
            
              GitHub
              Try Online\nExamples
              Tutorials
              Documentation
              Usage
              About\nGitHub
              Try Online\nDocumentation
      
      
      
      
        Specification
      
      
      
      
        Config
      
      
      
      
        Data
      
      
      
      
        Transforms
      
      
      
      
        Triggers
      
      
      
      
        Projections
      
      
      
      
        Scales
      
      
      
      
        Schemes
      
      
      
      
        Axes
      
      
      
      
        Legends
      
      
      
      
        Title
      
      
      
      
        Marks
      
      
      
      
        Signals
      
      
      
      
        Event Streams
      
      
      
      
        Expressions
      
      
      
      
        Layout
      
      
      
      
        Types
      
      
    
  
  
    Parameter Types
    Reference documentation for common parameter types expected by Vega specification properties.

Parameter Type Reference


  Any
  Array
  Boolean
  Color
  Date
  Gradient
  Number
  Object
  String
  URL
  Data
  Field
  Signal
  Compare
  Expr
  Value
  ColorValue
  FieldValue
  GradientValue
  TimeMultiFormat


Literal Values

#
Any or *

Accepts any literal value, including a string, number, boolean, or null.

#
Array or Type[ ]

Accepts array values. For example: [], [1, 2, 3], ["foo", "bar"]. If individual array items must adhere to a specific type, bracket notation – such as Number[ ] or String[ ] – is used to indicate the item type.

In most cases, arrays may also have signal references as items. For example: [{"signal": "width"}, {"signal": "height"}].

#
Boolean

Accepts boolean values. For example: true, false.

#
Color

Accepts a valid CSS color string. For example: #f304d3, #ccc, rgb(253, 12, 134), steelblue.

#
Date

A valid JavaScript Date object or timestamp. As JSON does not support date values natively, within a Vega specification a date-time value can be expressed either as a numeric timestamp (the number of milliseconds since the UNIX epoch, as produced by the Date.getTime() method) or using a signal expression (such as {"signal": "datetime(2001, 2, 3)"}).

#
Gradient ≥ 5.4

Accepts an object that specifies a gradient color pattern. To define a linear gradient based on a color scale, use a GradientValue instead.

For example:

{
  "gradient": "linear",
  "stops": [
    {"offset": 0.0, "color": "red"},
    {"offset": 0.5, "color": "white"},
    {"offset": 1.0, "color": "blue"}
  ]
}


#
Linear Gradient

A linear gradient interpolates colors along a line, from a starting point to an ending point. By default a linear gradient runs horizontally, from left to right. Use the x1, y1, x2, and y2 properties to configure the gradient direction. All coordinates are defined in a normalized [0, 1] coordinate space, relative to the bounding box of the item being colored.


  
    
      Name
      Type
      Description
    
  
  
    
      gradient
      String
      Required. The type of gradient. Use "linear" for a linear gradient.
    
    
      x1
      Number
      The starting x-coordinate, in normalized [0, 1] coordinates, of the linear gradient (default 0).
    
    
      y1
      Number
      The starting y-coordinate, in normalized [0, 1] coordinates, of the linear gradient (default 0).
    
    
      x2
      Number
      The ending x-coordinate, in normalized [0, 1] coordinates, of the linear gradient (default 1).
    
    
      y2
      Number
      The ending y-coordinate, in normalized [0, 1] coordinates, of the linear gradient (default 0).
    
    
      stops
      GradientStop[ ]
      Required. An array of gradient stops defining the gradient color sequence.
    
  


#
Radial Gradient

A radial gradient interpolates colors between two circles, from an inner circle boundary to an outer circle boundary. By default a radial gradient runs from the center point of the coordinate system (zero radius inner circle), out to the maximum extent (0.5 radius outer circle). Use the x1, y1, x2, and y2 properties to configure the inner and outer circle center points, and use the r1 and r2 properties to configure the circle radii. All coordinates are defined in a normalized [0, 1] coordinate space, relative to the bounding box of the item being colored. A value of 1 corresponds to the maximum extent of the bounding box (width or height, whichever is larger).


  
    
      Name
      Type
      Description
    
  
  
    
      gradient
      String
      Required. The type of gradient. Use "radial" for a radial gradient.
    
    
      x1
      Number
      The x-coordinate, in normalized [0, 1] coordinates, for the center of the inner circle for the gradient (default 0.5).
    
    
      y1
      Number
      The y-coordinate, in normalized [0, 1] coordinates, for the center of the inner circle for the gradient (default 0.5).
    
    
      r1
      Number
      The radius length, in normalized [0, 1] coordinates, of the inner circle for the gradient (default 0).
    
    
      x2
      Number
      The x-coordinate, in normalized [0, 1] coordinates, for the center of the outer circle for the gradient (default 0.5).
    
    
      y2
      Number
      The y-coordinate, in normalized [0, 1] coordinates, for the center of the outer circle for the gradient (default 0.5).
    
    
      r2
      Number
      The radius length, in normalized [0, 1] coordinates, of the outer circle for the gradient (default 0.5).
    
    
      stops
      GradientStop[ ]
      Required. An array of gradient stops defining the gradient color sequence.
    
  


#
Gradient Stop

A gradient stop consists of a Color value and an offset progress fraction.


  
    
      Name
      Type
      Description
    
  
  
    
      offset
      Number
      Required. The offset fraction for the color stop, indicating its position within the gradient.
    
    
      color
      Color
      Required. The color value at this point in the gradient.
    
  


#
Number

Accepts number values. For example: 1, 3.14, 1e5.

#
Object

Accepts object literals. For example: {"left":5, "right":30, "top":5, "bottom":50}. The valid object property names and types will vary across parameters; read the individual parameter descriptions for more information.

#
String

Accepts string values. For example: "bold", "step-before", "".

#
URL

Accepts a valid URL string linking to external site or resource. For example: "data/stocks.csv", "images/logo.png", "https://vega.github.io/".

Back to top

Data and Signal Types

#
Data

Accepts a string indicating the name of a data set. For example: "table", "nodes".

Back to top

#
Field

Accepts a string indicating the name of a data field. For example: "amount", "source.x", "target['x']".

Alternatively, accepts an object with a string-valued field parameter. For example: {"field": "amount"}, {"field": "source.x"}. In addition, the as parameter can be used to specify a different output name for a field. For example: {"field": "inputName", "as": "outputName"}.

Valid JavaScript object access paths using either dot (.) or bracket (foo['bar']) notation will be converted into lookups on nested objects. To specify field names that contain dots but are not nested lookups, escape the dot inline ("my\\.field") or enclose the field name in brackets ("[my.field]").

Back to top

#
Signal

Accepts an object with a reference to a signal value or expression. The signal property of the object must be either a valid signal name string or an expression string indicating a derived value. For example: {"signal": "width"}, {"signal": "width / 2"}.

Back to top

#
Compare

Accepts an object providing a comparator definition for sorting. Comparator objects may have two properties – field and order – indicating the data fields to sort by and the desired sort order for each field. Each property can take either a single string value (to sort by one field) or an array of string values (to sort by multiple fields).

The order property is optional. If defined, order values must be one of "ascending" (lowest-to-highest) or "descending" (highest-to-lowest). If order is not defined, or for cases where there are fewer order entries than field entries, ascending order is used by default.

A single field comparator:

{"field": "amount", "order": "ascending"}


A multi-field comparator:

{
  "field": ["amount", "date"],
  "order": ["descending", "ascending"]
}


Comparators can not be specified using a single signal instance. However, the individual field and order properties can use signals:

{
  "field": {"signal": "sortField"},
  "order": {"signal": "sortOrder"}
}


If a sort field is null, that field and any corresponding order entries will be ignored, just as if the entry did not exist.

Back to top

#
Expr

Accepts an object defining an expression to apply to each data object. Some transforms (for example the wordcloud transform) have parameters that can take a static string or number value or perform a lookup operation for each datum.

There are two valid forms of expression-typed values: field references and expr references.

A field reference results in a field lookup, identical to field-typed parameters:

{
  "type": "wordcloud",
  ...
  "rotate": {"field": "angle"} // per-datum lookup of the "angle" field
}


An expr reference provides an expression string that should be evaluated once per datum:

{
  "type": "wordcloud",
  ...
  "rotate": {"expr": "datum.minAngle + round(90*random() - 45)"} // evaluate once per-datum
}


Unlike signal references that are evaluated once per parameter, expr references behave like anonymous (or lambda) functions that are evaluated independently per data object.  Note that both signal and expr references will re-run if an upstream dependency changes.

Both field and expr references may include an as property that indicates the output field name to use.

Back to top

#
Value

Accepts an object defining a value reference, typically used for visual encoding. A value reference consists of a base value, plus optional scale transformation and modification.

Base Value

The base value must be specified using one of the following properties:


  
    
      Name
      Type
      Description
    
  
  
    
      signal
      String
      A signal name or expression.
    
    
      color
      ColorValue
      Specifies a color using value references for each color channel. See the color value documentation.
    
    
      field
      FieldValue
      A data field name or descriptor. See the field value documentation.
    
    
      value
      Any
      A constant value. Legal values include numbers, booleans, strings, colors, and gradients.
    
  


These properties are listed here in precedence order. For example, if signal is defined, any color, field or value properties will be ignored. In addition, the base value may be left undefined in the case of certain scale values, or to indicate a null value.

Scale Transforms

Once a base value is established, a scale lookup may be performed. The available scale-related properties are:


  
    
      Name
      Type
      Description
    
  
  
    
      scale
      String | FieldValue
      The name of a scale transform to apply. If this parameter is an object, it indicates a field value from which to dynamically lookup the scale name. For example {"datum": "s"} will use the value of field s on the current data object as the scale name, whereas {"parent": "t"} will use the value of field t on the parent group’s data object as the scale name.
    
    
      band
      Number
      If specified, returns the band width of the scale, multiplied by the given number. This parameter applies only to band scales. For example, {"band": 1} indicates the full band width, while {"band": 0.5} indicates half the band width. If the base value is defined, the multiplied band width is added to the output of the scale transform. For example, {"field": "a", "scale": "s", "band": 0.5} translates to scale(datum.a) + 0.5 * scale.bandwidth().
    
  


Value Modifiers

After any scale transformations are applied, the resulting value can be further modified using the following properties. The basic formula of a value reference is: pow(scale(baseValue), exponent) * mult + offset. Value modifiers are intended for use only with numeric values.


  
    
      Name
      Type
      Description
    
  
  
    
      exponent
      Number | Value
      Raise the value to a given exponent, equivalent to pow(value, exponent). If specified, exponentiation is applied immediately after any scale transformation.
    
    
      mult
      Number | Value
      A multiplier for the value, equivalent to mult * value. Multipliers are applied after any scale transformation or exponentiation.
    
    
      offset
      Number | Value
      An additive offset for the final value, equivalent to value + offset. Offsets are added after any scale transformation, exponentiation or multipliers.
    
    
      round
      Boolean
      Indicates if the final value should be rounded (default false). Rounding is performed after all other modifiers. If true, equivalent to round(value).
    
  


Examples


  {"value": 5} - The constant value 5.
  {"field": "price"} - The value of price, for the current datum.
  {"field": "index", "mult": 20} - The value of index for the current datum, multiplied by 20.
  {"scale": "x", "value": 0} - The result of running the value 0 through the scale named x.
  {"scale": "y", "field": "price"} - The result of running price for the current datum through the scale named y.
  {"scale": "x", "band": 1} - The range band width of the band scale x. Note that the scale must be of type “band”!
  {"scale": "x", "band": 1, "offset": -1} - The range band width of the band scale x, reduced (negative offset) by one pixel.


Back to top

#
ColorValue

Accepts an object that defines a custom color using value references for each color channel in a chosen color space. The color space is automatically inferred from the channel names used.

Typically color values are specified as a single value indicating an RGB color. However, sometimes a designer may wish to target specific color fields or use a different color space. In the following example, we can set the red and blue channels of an RGB color as constants, and determine the green channel from a scale transform.

{
  "fill": {
    "color": {
      "r": {"value": 255},
      "g": {"scale": "green", "field": "g"},
      "b": {"value": 0}
    }
  }
}


Vega supports the following color spaces:


  
    
      Name
      Description
    
  
  
    
      RGB
      Red, green, and blue channels defined with properties "r", "g", and "b".
    
    
      HSL
      Hue, saturation, and lightness channels defined with properties "h", "s", and "l".
    
    
      LAB
      Luminance, A (green-red contrast), and B (blue-yellow contrast) channels defined with properties "l", "a", and "b". LAB is a perceptual color space with distances based on human color judgments.
    
    
      HCL
      Hue, chroma, and luminance channels defined with properties "h", "c", and "l". HCL color space is a simple transform of LAB that uses polar coordinates for the AB plane.
    
  


Back to top

#
FieldValue

Accepts a string or an object indicating a data field value. If string-valued, the given data field name is used. If object-valued, the following properties may be used:


  
    
      Property
      Type
      Description
    
  
  
    
      signal
      String
      Evaluate the signal name or expression, and use the result as the field name to lookup.
    
    
      datum
      FieldValue
      Perform a lookup on the current data object using the given field name. This is similar to simply providing a string value.
    
    
      group
      FieldValue
      Use a property of the enclosing group mark instance as the value (e.g., "field": {"group": "width"} or "field": {"group": "height"}).
    
    
      parent
      FieldValue
      Use a field of the enclosing group mark’s data object as the value (e.g., "field": {"parent": "fieldInParentData"}.
    
  


These properties can be arbitrarily nested in order to perform indirect field lookups. For example, {"parent": {"datum": "f"}} will first retrieve the value of the f field on the current mark’s data object. This value will then be used as the property name to lookup on the enclosing parent group mark’s data object.

In addition, group and parent references may include an optional level property to access grandparents and other ancestors. For example, {"parent": "f", "level": 2} will use the value of the f field of the grandparent’s datum. By default, level = 1, indicating the immediate parent scope.

Back to top

#
GradientValue

Defines a linear gradient based on a scale range to determine colors for a fill or stroke encoding channel. To define a gradient directly, without reference to a scale, assign a Gradient definition as an encoding’s value property.


  
    
      Property
      Type
      Description
    
  
  
    
      gradient
      String | FieldValue
      Required. The name of a scale whose range is a continuous color scheme.
    
    
      start
      Number[ ]
      The starting coordinate for the gradient as an [x, y] array within a normalized [0, 1] coordinate system. This coordinate is relative to the bounds of the item being colored. Defaults to [0, 0].
    
    
      stop
      Number[ ]
      The stopping coordinate for the gradient as an [x, y] array within a normalized [0, 1] coordinate system. This coordinate is relative to the bounds of the item being colored. Defaults to [1, 0], for a horizontal gradient that spans the full bounds of an item.
    
    
      count
      Number
      A suggested target number of sample points to take from the color scale.
    
  


Example

{
  "encode": {
    "fill": {
      "gradient": "colorScale",
      "start": [0, 1],
      "stop": [0, 0],
      "count": 10
    }
  }
}


Back to top

#
TimeMultiFormat

An object defining custom multi-format specifications for date-time values. This object must be a legal input to the timeFormat API method:


  Object keys must be valid time units (e.g., year, month, etc).
  Object values must be valid d3-time-format specifier strings.


These values, in conjunction with defaults for unspecified units, will then be used to create a dynamic formatting function that uses different formats depending on the granularity of the input date (e.g., if the date lies on a year, month, date, hour, etc. boundary). For more information, see the timeFormat API documentation.

Back to top\nReference documentation for common parameter types expected by Vega specification properties.\nParameter Type Reference\nAccepts any literal value, including a string, number, boolean, or null.\nAccepts array values. For example: [], [1, 2, 3], ["foo", "bar"]. If individual array items must adhere to a specific type, bracket notation – such as Number[ ] or String[ ] – is used to indicate the item type.\nIn most cases, arrays may also have signal references as items. For example: [{"signal": "width"}, {"signal": "height"}].\nAccepts boolean values. For example: true, false.\nAccepts a valid CSS color string. For example: #f304d3, #ccc, rgb(253, 12, 134), steelblue.\nA valid JavaScript Date object or timestamp. As JSON does not support date values natively, within a Vega specification a date-time value can be expressed either as a numeric timestamp (the number of milliseconds since the UNIX epoch, as produced by the Date.getTime() method) or using a signal expression (such as {"signal": "datetime(2001, 2, 3)"}).\nAccepts an object that specifies a gradient color pattern. To define a linear gradient based on a color scale, use a GradientValue instead.\n{
  "gradient": "linear",
  "stops": [
    {"offset": 0.0, "color": "red"},
    {"offset": 0.5, "color": "white"},
    {"offset": 1.0, "color": "blue"}
  ]
}\n{
  "gradient": "linear",
  "stops": [
    {"offset": 0.0, "color": "red"},
    {"offset": 0.5, "color": "white"},
    {"offset": 1.0, "color": "blue"}
  ]
}\nA linear gradient interpolates colors along a line, from a starting point to an ending point. By default a linear gradient runs horizontally, from left to right. Use the x1, y1, x2, and y2 properties to configure the gradient direction. All coordinates are defined in a normalized [0, 1] coordinate space, relative to the bounding box of the item being colored.\nRequired. The type of gradient. Use "linear" for a linear gradient.\nThe starting x-coordinate, in normalized [0, 1] coordinates, of the linear gradient (default 0).\nThe starting y-coordinate, in normalized [0, 1] coordinates, of the linear gradient (default 0).\nThe ending x-coordinate, in normalized [0, 1] coordinates, of the linear gradient (default 1).\nThe ending y-coordinate, in normalized [0, 1] coordinates, of the linear gradient (default 0).\nRequired. An array of gradient stops defining the gradient color sequence.\nA radial gradient interpolates colors between two circles, from an inner circle boundary to an outer circle boundary. By default a radial gradient runs from the center point of the coordinate system (zero radius inner circle), out to the maximum extent (0.5 radius outer circle). Use the x1, y1, x2, and y2 properties to configure the inner and outer circle center points, and use the r1 and r2 properties to configure the circle radii. All coordinates are defined in a normalized [0, 1] coordinate space, relative to the bounding box of the item being colored. A value of 1 corresponds to the maximum extent of the bounding box (width or height, whichever is larger).\nRequired. The type of gradient. Use "radial" for a radial gradient.\nThe x-coordinate, in normalized [0, 1] coordinates, for the center of the inner circle for the gradient (default 0.5).\nThe y-coordinate, in normalized [0, 1] coordinates, for the center of the inner circle for the gradient (default 0.5).\nThe radius length, in normalized [0, 1] coordinates, of the inner circle for the gradient (default 0).\nThe x-coordinate, in normalized [0, 1] coordinates, for the center of the outer circle for the gradient (default 0.5).\nThe y-coordinate, in normalized [0, 1] coordinates, for the center of the outer circle for the gradient (default 0.5).\nThe radius length, in normalized [0, 1] coordinates, of the outer circle for the gradient (default 0.5).\nRequired. An array of gradient stops defining the gradient color sequence.\nA gradient stop consists of a Color value and an offset progress fraction.\nRequired. The offset fraction for the color stop, indicating its position within the gradient.\nRequired. The color value at this point in the gradient.\nAccepts number values. For example: 1, 3.14, 1e5.\nAccepts object literals. For example: {"left":5, "right":30, "top":5, "bottom":50}. The valid object property names and types will vary across parameters; read the individual parameter descriptions for more information.\nAccepts string values. For example: "bold", "step-before", "".\nAccepts a valid URL string linking to external site or resource. For example: "data/stocks.csv", "images/logo.png", "https://vega.github.io/".\nData and Signal Types\nAccepts a string indicating the name of a data set. For example: "table", "nodes".\nAccepts a string indicating the name of a data field. For example: "amount", "source.x", "target['x']".\nAlternatively, accepts an object with a string-valued field parameter. For example: {"field": "amount"}, {"field": "source.x"}. In addition, the as parameter can be used to specify a different output name for a field. For example: {"field": "inputName", "as": "outputName"}.\nValid JavaScript object access paths using either dot (.) or bracket (foo['bar']) notation will be converted into lookups on nested objects. To specify field names that contain dots but are not nested lookups, escape the dot inline ("my\\.field") or enclose the field name in brackets ("[my.field]").\nAccepts an object with a reference to a signal value or expression. The signal property of the object must be either a valid signal name string or an expression string indicating a derived value. For example: {"signal": "width"}, {"signal": "width / 2"}.\nAccepts an object providing a comparator definition for sorting. Comparator objects may have two properties – field and order – indicating the data fields to sort by and the desired sort order for each field. Each property can take either a single string value (to sort by one field) or an array of string values (to sort by multiple fields).\nThe order property is optional. If defined, order values must be one of "ascending" (lowest-to-highest) or "descending" (highest-to-lowest). If order is not defined, or for cases where there are fewer order entries than field entries, ascending order is used by default.\nA single field comparator:\n{"field": "amount", "order": "ascending"}\n{"field": "amount", "order": "ascending"}\nA multi-field comparator:\n{
  "field": ["amount", "date"],
  "order": ["descending", "ascending"]
}\n{
  "field": ["amount", "date"],
  "order": ["descending", "ascending"]
}\nComparators can not be specified using a single signal instance. However, the individual field and order properties can use signals:\n{
  "field": {"signal": "sortField"},
  "order": {"signal": "sortOrder"}
}\n{
  "field": {"signal": "sortField"},
  "order": {"signal": "sortOrder"}
}\nIf a sort field is null, that field and any corresponding order entries will be ignored, just as if the entry did not exist.\nAccepts an object defining an expression to apply to each data object. Some transforms (for example the wordcloud transform) have parameters that can take a static string or number value or perform a lookup operation for each datum.\nThere are two valid forms of expression-typed values: field references and expr references.\nA field reference results in a field lookup, identical to field-typed parameters:\nfield-typed parameters\n{
  "type": "wordcloud",
  ...
  "rotate": {"field": "angle"} // per-datum lookup of the "angle" field
}\n{
  "type": "wordcloud",
  ...
  "rotate": {"field": "angle"} // per-datum lookup of the "angle" field
}\nAn expr reference provides an expression string that should be evaluated once per datum:\n{
  "type": "wordcloud",
  ...
  "rotate": {"expr": "datum.minAngle + round(90*random() - 45)"} // evaluate once per-datum
}\n{
  "type": "wordcloud",
  ...
  "rotate": {"expr": "datum.minAngle + round(90*random() - 45)"} // evaluate once per-datum
}\n"datum.minAngle + round(90*random() - 45)"\nUnlike signal references that are evaluated once per parameter, expr references behave like anonymous (or lambda) functions that are evaluated independently per data object.  Note that both signal and expr references will re-run if an upstream dependency changes.\nanonymous (or lambda) functions\nBoth field and expr references may include an as property that indicates the output field name to use.\nAccepts an object defining a value reference, typically used for visual encoding. A value reference consists of a base value, plus optional scale transformation and modification.\nThe base value must be specified using one of the following properties:\nA signal name or expression.\nSpecifies a color using value references for each color channel. See the color value documentation.\nA data field name or descriptor. See the field value documentation.\nA constant value. Legal values include numbers, booleans, strings, colors, and gradients.\nThese properties are listed here in precedence order. For example, if signal is defined, any color, field or value properties will be ignored. In addition, the base value may be left undefined in the case of certain scale values, or to indicate a null value.\nOnce a base value is established, a scale lookup may be performed. The available scale-related properties are:\nThe name of a scale transform to apply. If this parameter is an object, it indicates a field value from which to dynamically lookup the scale name. For example {"datum": "s"} will use the value of field s on the current data object as the scale name, whereas {"parent": "t"} will use the value of field t on the parent group’s data object as the scale name.\nIf specified, returns the band width of the scale, multiplied by the given number. This parameter applies only to band scales. For example, {"band": 1} indicates the full band width, while {"band": 0.5} indicates half the band width. If the base value is defined, the multiplied band width is added to the output of the scale transform. For example, {"field": "a", "scale": "s", "band": 0.5} translates to scale(datum.a) + 0.5 * scale.bandwidth().\nAfter any scale transformations are applied, the resulting value can be further modified using the following properties. The basic formula of a value reference is: pow(scale(baseValue), exponent) * mult + offset. Value modifiers are intended for use only with numeric values.\nRaise the value to a given exponent, equivalent to pow(value, exponent). If specified, exponentiation is applied immediately after any scale transformation.\nA multiplier for the value, equivalent to mult * value. Multipliers are applied after any scale transformation or exponentiation.\nAn additive offset for the final value, equivalent to value + offset. Offsets are added after any scale transformation, exponentiation or multipliers.\nIndicates if the final value should be rounded (default false). Rounding is performed after all other modifiers. If true, equivalent to round(value).\n{"value": 5} - The constant value 5.\n{"field": "price"} - The value of price, for the current datum.\n{"field": "index", "mult": 20} - The value of index for the current datum, multiplied by 20.\n{"scale": "x", "value": 0} - The result of running the value 0 through the scale named x.\n{"scale": "y", "field": "price"} - The result of running price for the current datum through the scale named y.\n{"scale": "x", "band": 1} - The range band width of the band scale x. Note that the scale must be of type “band”!\n{"scale": "x", "band": 1, "offset": -1} - The range band width of the band scale x, reduced (negative offset) by one pixel.\nAccepts an object that defines a custom color using value references for each color channel in a chosen color space. The color space is automatically inferred from the channel names used.\nTypically color values are specified as a single value indicating an RGB color. However, sometimes a designer may wish to target specific color fields or use a different color space. In the following example, we can set the red and blue channels of an RGB color as constants, and determine the green channel from a scale transform.\n{
  "fill": {
    "color": {
      "r": {"value": 255},
      "g": {"scale": "green", "field": "g"},
      "b": {"value": 0}
    }
  }
}\n{
  "fill": {
    "color": {
      "r": {"value": 255},
      "g": {"scale": "green", "field": "g"},
      "b": {"value": 0}
    }
  }
}\nVega supports the following color spaces:\nRed, green, and blue channels defined with properties "r", "g", and "b".\nHue, saturation, and lightness channels defined with properties "h", "s", and "l".\nLuminance, A (green-red contrast), and B (blue-yellow contrast) channels defined with properties "l", "a", and "b". LAB is a perceptual color space with distances based on human color judgments.\nHue, chroma, and luminance channels defined with properties "h", "c", and "l". HCL color space is a simple transform of LAB that uses polar coordinates for the AB plane.\nAccepts a string or an object indicating a data field value. If string-valued, the given data field name is used. If object-valued, the following properties may be used:\nEvaluate the signal name or expression, and use the result as the field name to lookup.\nPerform a lookup on the current data object using the given field name. This is similar to simply providing a string value.\nUse a property of the enclosing group mark instance as the value (e.g., "field": {"group": "width"} or "field": {"group": "height"}).\nUse a field of the enclosing group mark’s data object as the value (e.g., "field": {"parent": "fieldInParentData"}.\nThese properties can be arbitrarily nested in order to perform indirect field lookups. For example, {"parent": {"datum": "f"}} will first retrieve the value of the f field on the current mark’s data object. This value will then be used as the property name to lookup on the enclosing parent group mark’s data object.\nIn addition, group and parent references may include an optional level property to access grandparents and other ancestors. For example, {"parent": "f", "level": 2} will use the value of the f field of the grandparent’s datum. By default, level = 1, indicating the immediate parent scope.\nDefines a linear gradient based on a scale range to determine colors for a fill or stroke encoding channel. To define a gradient directly, without reference to a scale, assign a Gradient definition as an encoding’s value property.\nRequired. The name of a scale whose range is a continuous color scheme.\ncontinuous color scheme\nThe starting coordinate for the gradient as an [x, y] array within a normalized [0, 1] coordinate system. This coordinate is relative to the bounds of the item being colored. Defaults to [0, 0].\nThe stopping coordinate for the gradient as an [x, y] array within a normalized [0, 1] coordinate system. This coordinate is relative to the bounds of the item being colored. Defaults to [1, 0], for a horizontal gradient that spans the full bounds of an item.\nA suggested target number of sample points to take from the color scale.\n{
  "encode": {
    "fill": {
      "gradient": "colorScale",
      "start": [0, 1],
      "stop": [0, 0],
      "count": 10
    }
  }
}\n{
  "encode": {
    "fill": {
      "gradient": "colorScale",
      "start": [0, 1],
      "stop": [0, 0],
      "count": 10
    }
  }
}\nAn object defining custom multi-format specifications for date-time values. This object must be a legal input to the timeFormat API method:\ntimeFormat API method\nObject keys must be valid time units (e.g., year, month, etc).\nObject values must be valid d3-time-format specifier strings.\nThese values, in conjunction with defaults for unspecified units, will then be used to create a dynamic formatting function that uses different formats depending on the granularity of the input date (e.g., if the date lies on a year, month, date, hour, etc. boundary). For more information, see the timeFormat API documentation.\ntimeFormat API documentation\n\n\nVega
            
              Vega-Lite
              Altair
              Vega-Lite API
            
          
          
            
              Examples
              Tutorials
              Documentation
              Usage
              About
            
            
              GitHub
              Try Online
            
          
        
      

      
        

  
  
    Usage
    Vega can be deployed for interactive visualizations within a web browser, or to render static PNG and SVG images server-side. This page describes the various means of deployment and use.

Usage Reference


  Web Deployment
    
      Import Vega JavaScript
      Using the Vega View API
      Using the Vega-Embed Module
      Supporting Internet Explorer
      Content Security Policy
    
  
  Command Line Utilities
  Server-Side Deployment


Web Deployment

To deploy Vega on the web, first import the requisite JavaScript libraries. Then, use the Vega View API or the convenient Vega-Embed helper module to parse Vega specifications and add interactive visualizations to a web page.

Try Vega with Vega-Embed online and publish your own chart by forking our example Block.

Import Vega JavaScript

To use Vega on a web page you first need to load the Vega JavaScript files. The simplest option is to import the complete Vega bundle.

<head>
  <script src="https://vega.github.io/vega/vega.min.js"></script>
</head>


Loading Vega from a CDN. While the example above loads files from the Vega web site, for production deployments you will likely want to serve your own files or use a content delivery network (CDN). Vega releases are hosted on jsDelivr:

<head>
  <script src="https://cdn.jsdelivr.net/npm/vega@5"></script>
</head>


Using Vega and D3 together. The full vega.js and vega.min.js files bundle up all dependencies, including d3 modules and topojson-client. If you plan to independently use d3.js on your page, you can use a smaller Vega bundle that excludes redundant d3 files. Import d3 first, then import the smaller vega-core.min.js file to reduce the total file size. If you plan to load TopoJSON data files, you’ll need to import the topojson-client package as well.

<head>
  <script src="https://cdn.jsdelivr.net/npm/d3@7"></script>
  <script src="https://cdn.jsdelivr.net/npm/topojson-client@3"></script>
  <script src="https://cdn.jsdelivr.net/npm/vega@5/build/vega-core.min.js"></script>
</head>


Using Vega with a bundler. If you use Vega with a bundler like rollup.js, you can import Vega as a module.

import * as vega from "vega";


Back to reference

Using the Vega-Embed Module

The Vega-Embed module provides a convenient method for adding either Vega or Vega-Lite visualizations to a web page. This module will take care of steps such as loading specification files from a URL and generating views with standard configuration options. In addition, you can include accompanying links to export images and view source. For more, see the Vega-Embed repository.

<head>
  <script src="https://cdn.jsdelivr.net/npm/vega@5"></script>
  <script src="https://cdn.jsdelivr.net/npm/vega-lite@5"></script>
  <script src="https://cdn.jsdelivr.net/npm/vega-embed@6"></script>
</head>
<body>
  <div id="view"></div>
  <script>
    vegaEmbed(
      '#view',
      'https://vega.github.io/vega/examples/bar-chart.vg.json'
    );
  </script>
</body>


Back to reference

Using the Vega View API

Vega’s View component takes a parsed specification and configuration options as input and sets up an interactive web component. The View API also provides methods for streaming data updates, exporting static images, and accessing internal data for debugging purposes. For more, see the View component documentation.

<head>
  <script src="https://cdn.jsdelivr.net/npm/vega@5"></script>
</head>
<body>
  <div id="view"></div>
  <script type="text/javascript">
    var view;

    fetch('https://vega.github.io/vega/examples/bar-chart.vg.json')
      .then(res => res.json())
      .then(spec => render(spec))
      .catch(err => console.error(err));

    function render(spec) {
      view = new vega.View(vega.parse(spec), {
        renderer:  'canvas',  // renderer (canvas or svg)
        container: '#view',   // parent DOM container
        hover:     true       // enable hover processing
      });
      return view.runAsync();
    }
  </script>
</body>


Vega visualizations will be added to a parent DOM container element. This element (either a DOM object or a unique CSS selector string) must be provided  as a View constructor option or an as argument to the View initialize method. Note: Any existing content within the parent container element will be removed upon view initialization.

Back to reference

Vega and Content Security Policy (CSP)

By default Vega is not compliant with standard Content Security Policy (CSP), as it uses the Function constructor to generate functions defined in the Vega expression language. However, Vega allows use of alternative expression evaluators that are CSP-compliant. For more, see the expression interpreter usage documentation.

Back to reference

Command Line Utilities

The vega-cli package includes three node.js-based command line utilities – vg2pdf, vg2png, and vg2svg – for rendering static visualization images. These commands render to PDF, PNG, or SVG files, respectively.


  vg2pdf: vg2pdf [options] [input_vega_json_file] [output_pdf_file]
  vg2png: vg2png [options] [input_vega_json_file] [output_png_file]
  vg2svg: vg2svg [options] [input_vega_json_file] [output_svg_file]


If no input Vega JSON file is given, the utilities will attempt to read the file from standard input. If no output file is given, the resulting PDF, PNG, or SVG data will be written to standard output, and so can be piped into other applications.

The programs also accept the following (optional) parameters:


  -b, –base - [String] A base directory to use for data and image loading. For web retrieval, use -b http://host/data/. For files, use -b data/ (relative path) or -b file:///dir/data/ (absolute path).
  -h, –header - [Flag] Includes XML header and DOCTYPE in SVG output (vg2svg only).
  -s, –scale - [Number] [Default:1] A resolution scale factor. For example, -s 2 results in a doubling of the output resolution. For PDF or SVG, scales the output coordinate space.
  -seed, - [Number] Seed for random number generation. Allows for consistent output over random values. Internally replaces Math.random with a linear congruential generator.
  -c, –config, - [String] Provide a Vega config object. A file path string to a JSON file or .js file that exports an object.
  -f, –format, - [String] Set the number format locale. A file path string to a JSON file or .js file that exports an object.
  -t, –timeFormat, - [String] Set data/time format locale. A file path string to a JSON file or .js file that exports an object.
  -l, –loglevel - [String] Level of log messages written to standard error output. One of error, warn (default), info, or debug.
  –help - [Flag] Print usage help to the console.


To install the command line utilities, you must install the vega-cli npm package. For example, yarn global add vega-cli or npm install -g vega-cli will install the utilities for global use. If you install the package locally, the commands are accessible via your node_modules folder (./node_modules/bin/vg2png). The command line utilities depend on the node-canvas package. See below for more information about Vega and node-canvas.

All errors and logging message will be written to standard error output (stderr). To create a log file, pipe the stderr output to the desired file. For example: vg2pdf ...arguments 2> vg2pdf.log.

Examples

In the vega package, you can run the following from the command line if vega-cli is installed.

Render the bar chart example to a PNG file:

vg2png test/specs-valid/bar.vg.json bar.png


Render the bar chart example to an SVG file, including XML headers:

vg2svg -h test/specs-valid/bar.vg.json bar.svg


Render the arc example as a PDF, piped to a file via standard output:

vg2pdf test/specs-valid/arc.vg.json > arc.pdf


Render the choropleth example to a PNG file. A base directory is specified for loading data files:

vg2png -b test test/specs-valid/choropleth.vg.json > choropleth.png


Render the bar chart example to a PNG file at double resolution:

vg2png -s 2 test/specs-valid/bar.vg.json bar.png


Back to reference

Server-Side Deployment using Node.js

To use Vega as a component within a larger project, first install it either directly (yarn add vega or npm install vega) or by including "vega" among the dependencies in your package.json file. In node.js JavaScript code, import Vega using require('vega'). Much like browser-based deployments, Node.js deployments leverage the Vega View API. However, server-side View instances should use the renderer type none and provide no DOM element to the initialize method.

To generate PNG images and accurately measure font metrics for text mark truncation, the node-canvas package must be installed. The vega package does not require node-canvas by default, so you must include it as an explicit dependency in your own project if you wish to use it. The vega-cli package, on the other hand, does include node-canvas as an explicit dependency.

Occasionally some system configurations may run into errors while installing node-canvas. Please consult the node-canvas documentation if you experience installation issues.

Example

var vega = require('vega');

// create a new view instance for a given Vega JSON spec
var view = new vega.View(vega.parse(spec), {renderer: 'none'});

// generate a static SVG image
view.toSVG()
  .then(function(svg) {
    // process svg string
  })
  .catch(function(err) { console.error(err); });

// generate a static PNG image
view.toCanvas()
  .then(function(canvas) {
    // process node-canvas instance
    // for example, generate a PNG stream to write
    var stream = canvas.createPNGStream();
  })
  .catch(function(err) { console.error(err); });


Back to reference\nVega
            
              Vega-Lite
              Altair
              Vega-Lite API\nVega-Lite
              Altair
              Vega-Lite API\nExamples
              Tutorials
              Documentation
              Usage
              About
            
            
              GitHub
              Try Online\nExamples
              Tutorials
              Documentation
              Usage
              About\nGitHub
              Try Online\nUsage
    Vega can be deployed for interactive visualizations within a web browser, or to render static PNG and SVG images server-side. This page describes the various means of deployment and use.

Usage Reference


  Web Deployment
    
      Import Vega JavaScript
      Using the Vega View API
      Using the Vega-Embed Module
      Supporting Internet Explorer
      Content Security Policy
    
  
  Command Line Utilities
  Server-Side Deployment


Web Deployment

To deploy Vega on the web, first import the requisite JavaScript libraries. Then, use the Vega View API or the convenient Vega-Embed helper module to parse Vega specifications and add interactive visualizations to a web page.

Try Vega with Vega-Embed online and publish your own chart by forking our example Block.

Import Vega JavaScript

To use Vega on a web page you first need to load the Vega JavaScript files. The simplest option is to import the complete Vega bundle.

<head>
  <script src="https://vega.github.io/vega/vega.min.js"></script>
</head>


Loading Vega from a CDN. While the example above loads files from the Vega web site, for production deployments you will likely want to serve your own files or use a content delivery network (CDN). Vega releases are hosted on jsDelivr:

<head>
  <script src="https://cdn.jsdelivr.net/npm/vega@5"></script>
</head>


Using Vega and D3 together. The full vega.js and vega.min.js files bundle up all dependencies, including d3 modules and topojson-client. If you plan to independently use d3.js on your page, you can use a smaller Vega bundle that excludes redundant d3 files. Import d3 first, then import the smaller vega-core.min.js file to reduce the total file size. If you plan to load TopoJSON data files, you’ll need to import the topojson-client package as well.

<head>
  <script src="https://cdn.jsdelivr.net/npm/d3@7"></script>
  <script src="https://cdn.jsdelivr.net/npm/topojson-client@3"></script>
  <script src="https://cdn.jsdelivr.net/npm/vega@5/build/vega-core.min.js"></script>
</head>


Using Vega with a bundler. If you use Vega with a bundler like rollup.js, you can import Vega as a module.

import * as vega from "vega";


Back to reference

Using the Vega-Embed Module

The Vega-Embed module provides a convenient method for adding either Vega or Vega-Lite visualizations to a web page. This module will take care of steps such as loading specification files from a URL and generating views with standard configuration options. In addition, you can include accompanying links to export images and view source. For more, see the Vega-Embed repository.

<head>
  <script src="https://cdn.jsdelivr.net/npm/vega@5"></script>
  <script src="https://cdn.jsdelivr.net/npm/vega-lite@5"></script>
  <script src="https://cdn.jsdelivr.net/npm/vega-embed@6"></script>
</head>
<body>
  <div id="view"></div>
  <script>
    vegaEmbed(
      '#view',
      'https://vega.github.io/vega/examples/bar-chart.vg.json'
    );
  </script>
</body>


Back to reference

Using the Vega View API

Vega’s View component takes a parsed specification and configuration options as input and sets up an interactive web component. The View API also provides methods for streaming data updates, exporting static images, and accessing internal data for debugging purposes. For more, see the View component documentation.

<head>
  <script src="https://cdn.jsdelivr.net/npm/vega@5"></script>
</head>
<body>
  <div id="view"></div>
  <script type="text/javascript">
    var view;

    fetch('https://vega.github.io/vega/examples/bar-chart.vg.json')
      .then(res => res.json())
      .then(spec => render(spec))
      .catch(err => console.error(err));

    function render(spec) {
      view = new vega.View(vega.parse(spec), {
        renderer:  'canvas',  // renderer (canvas or svg)
        container: '#view',   // parent DOM container
        hover:     true       // enable hover processing
      });
      return view.runAsync();
    }
  </script>
</body>


Vega visualizations will be added to a parent DOM container element. This element (either a DOM object or a unique CSS selector string) must be provided  as a View constructor option or an as argument to the View initialize method. Note: Any existing content within the parent container element will be removed upon view initialization.

Back to reference

Vega and Content Security Policy (CSP)

By default Vega is not compliant with standard Content Security Policy (CSP), as it uses the Function constructor to generate functions defined in the Vega expression language. However, Vega allows use of alternative expression evaluators that are CSP-compliant. For more, see the expression interpreter usage documentation.

Back to reference

Command Line Utilities

The vega-cli package includes three node.js-based command line utilities – vg2pdf, vg2png, and vg2svg – for rendering static visualization images. These commands render to PDF, PNG, or SVG files, respectively.


  vg2pdf: vg2pdf [options] [input_vega_json_file] [output_pdf_file]
  vg2png: vg2png [options] [input_vega_json_file] [output_png_file]
  vg2svg: vg2svg [options] [input_vega_json_file] [output_svg_file]


If no input Vega JSON file is given, the utilities will attempt to read the file from standard input. If no output file is given, the resulting PDF, PNG, or SVG data will be written to standard output, and so can be piped into other applications.

The programs also accept the following (optional) parameters:


  -b, –base - [String] A base directory to use for data and image loading. For web retrieval, use -b http://host/data/. For files, use -b data/ (relative path) or -b file:///dir/data/ (absolute path).
  -h, –header - [Flag] Includes XML header and DOCTYPE in SVG output (vg2svg only).
  -s, –scale - [Number] [Default:1] A resolution scale factor. For example, -s 2 results in a doubling of the output resolution. For PDF or SVG, scales the output coordinate space.
  -seed, - [Number] Seed for random number generation. Allows for consistent output over random values. Internally replaces Math.random with a linear congruential generator.
  -c, –config, - [String] Provide a Vega config object. A file path string to a JSON file or .js file that exports an object.
  -f, –format, - [String] Set the number format locale. A file path string to a JSON file or .js file that exports an object.
  -t, –timeFormat, - [String] Set data/time format locale. A file path string to a JSON file or .js file that exports an object.
  -l, –loglevel - [String] Level of log messages written to standard error output. One of error, warn (default), info, or debug.
  –help - [Flag] Print usage help to the console.


To install the command line utilities, you must install the vega-cli npm package. For example, yarn global add vega-cli or npm install -g vega-cli will install the utilities for global use. If you install the package locally, the commands are accessible via your node_modules folder (./node_modules/bin/vg2png). The command line utilities depend on the node-canvas package. See below for more information about Vega and node-canvas.

All errors and logging message will be written to standard error output (stderr). To create a log file, pipe the stderr output to the desired file. For example: vg2pdf ...arguments 2> vg2pdf.log.

Examples

In the vega package, you can run the following from the command line if vega-cli is installed.

Render the bar chart example to a PNG file:

vg2png test/specs-valid/bar.vg.json bar.png


Render the bar chart example to an SVG file, including XML headers:

vg2svg -h test/specs-valid/bar.vg.json bar.svg


Render the arc example as a PDF, piped to a file via standard output:

vg2pdf test/specs-valid/arc.vg.json > arc.pdf


Render the choropleth example to a PNG file. A base directory is specified for loading data files:

vg2png -b test test/specs-valid/choropleth.vg.json > choropleth.png


Render the bar chart example to a PNG file at double resolution:

vg2png -s 2 test/specs-valid/bar.vg.json bar.png


Back to reference

Server-Side Deployment using Node.js

To use Vega as a component within a larger project, first install it either directly (yarn add vega or npm install vega) or by including "vega" among the dependencies in your package.json file. In node.js JavaScript code, import Vega using require('vega'). Much like browser-based deployments, Node.js deployments leverage the Vega View API. However, server-side View instances should use the renderer type none and provide no DOM element to the initialize method.

To generate PNG images and accurately measure font metrics for text mark truncation, the node-canvas package must be installed. The vega package does not require node-canvas by default, so you must include it as an explicit dependency in your own project if you wish to use it. The vega-cli package, on the other hand, does include node-canvas as an explicit dependency.

Occasionally some system configurations may run into errors while installing node-canvas. Please consult the node-canvas documentation if you experience installation issues.

Example

var vega = require('vega');

// create a new view instance for a given Vega JSON spec
var view = new vega.View(vega.parse(spec), {renderer: 'none'});

// generate a static SVG image
view.toSVG()
  .then(function(svg) {
    // process svg string
  })
  .catch(function(err) { console.error(err); });

// generate a static PNG image
view.toCanvas()
  .then(function(canvas) {
    // process node-canvas instance
    // for example, generate a PNG stream to write
    var stream = canvas.createPNGStream();
  })
  .catch(function(err) { console.error(err); });


Back to reference\nVega can be deployed for interactive visualizations within a web browser, or to render static PNG and SVG images server-side. This page describes the various means of deployment and use.\nWeb Deployment
    
      Import Vega JavaScript
      Using the Vega View API
      Using the Vega-Embed Module
      Supporting Internet Explorer
      Content Security Policy\nImport Vega JavaScript\nImport Vega JavaScript\nUsing the Vega View API\nUsing the Vega View API\nUsing the Vega-Embed Module\nUsing the Vega-Embed Module\nSupporting Internet Explorer\nSupporting Internet Explorer\nContent Security Policy\nContent Security Policy\nCommand Line Utilities\nCommand Line Utilities\nServer-Side Deployment\nServer-Side Deployment\nTo deploy Vega on the web, first import the requisite JavaScript libraries. Then, use the Vega View API or the convenient Vega-Embed helper module to parse Vega specifications and add interactive visualizations to a web page.\nTry Vega with Vega-Embed online and publish your own chart by forking our example Block.\nImport Vega JavaScript\nTo use Vega on a web page you first need to load the Vega JavaScript files. The simplest option is to import the complete Vega bundle.\n<head>
  <script src="https://vega.github.io/vega/vega.min.js"></script>
</head>\n<head>
  <script src="https://vega.github.io/vega/vega.min.js"></script>
</head>\n"https://vega.github.io/vega/vega.min.js"\nLoading Vega from a CDN. While the example above loads files from the Vega web site, for production deployments you will likely want to serve your own files or use a content delivery network (CDN). Vega releases are hosted on jsDelivr:\ncontent delivery network (CDN)\n<head>
  <script src="https://cdn.jsdelivr.net/npm/vega@5"></script>
</head>\n<head>
  <script src="https://cdn.jsdelivr.net/npm/vega@5"></script>
</head>\n"https://cdn.jsdelivr.net/npm/vega@5"\nUsing Vega and D3 together. The full vega.js and vega.min.js files bundle up all dependencies, including d3 modules and topojson-client. If you plan to independently use d3.js on your page, you can use a smaller Vega bundle that excludes redundant d3 files. Import d3 first, then import the smaller vega-core.min.js file to reduce the total file size. If you plan to load TopoJSON data files, you’ll need to import the topojson-client package as well.\n<head>
  <script src="https://cdn.jsdelivr.net/npm/d3@7"></script>
  <script src="https://cdn.jsdelivr.net/npm/topojson-client@3"></script>
  <script src="https://cdn.jsdelivr.net/npm/vega@5/build/vega-core.min.js"></script>
</head>\n<head>
  <script src="https://cdn.jsdelivr.net/npm/d3@7"></script>
  <script src="https://cdn.jsdelivr.net/npm/topojson-client@3"></script>
  <script src="https://cdn.jsdelivr.net/npm/vega@5/build/vega-core.min.js"></script>
</head>\n"https://cdn.jsdelivr.net/npm/d3@7"\n"https://cdn.jsdelivr.net/npm/topojson-client@3"\n"https://cdn.jsdelivr.net/npm/vega@5/build/vega-core.min.js"\nUsing Vega with a bundler. If you use Vega with a bundler like rollup.js, you can import Vega as a module.\nimport * as vega from "vega";\nimport * as vega from "vega";\nUsing the Vega-Embed Module\nThe Vega-Embed module provides a convenient method for adding either Vega or Vega-Lite visualizations to a web page. This module will take care of steps such as loading specification files from a URL and generating views with standard configuration options. In addition, you can include accompanying links to export images and view source. For more, see the Vega-Embed repository.\nVega-Embed repository\n<head>
  <script src="https://cdn.jsdelivr.net/npm/vega@5"></script>
  <script src="https://cdn.jsdelivr.net/npm/vega-lite@5"></script>
  <script src="https://cdn.jsdelivr.net/npm/vega-embed@6"></script>
</head>
<body>
  <div id="view"></div>
  <script>
    vegaEmbed(
      '#view',
      'https://vega.github.io/vega/examples/bar-chart.vg.json'
    );
  </script>
</body>\n<head>
  <script src="https://cdn.jsdelivr.net/npm/vega@5"></script>
  <script src="https://cdn.jsdelivr.net/npm/vega-lite@5"></script>
  <script src="https://cdn.jsdelivr.net/npm/vega-embed@6"></script>
</head>
<body>
  <div id="view"></div>
  <script>
    vegaEmbed(
      '#view',
      'https://vega.github.io/vega/examples/bar-chart.vg.json'
    );
  </script>
</body>\n"https://cdn.jsdelivr.net/npm/vega@5"\n"https://cdn.jsdelivr.net/npm/vega-lite@5"\n"https://cdn.jsdelivr.net/npm/vega-embed@6"\nhttps://vega.github.io/vega/examples/bar-chart.vg.json\nUsing the Vega View API\nVega’s View component takes a parsed specification and configuration options as input and sets up an interactive web component. The View API also provides methods for streaming data updates, exporting static images, and accessing internal data for debugging purposes. For more, see the View component documentation.\n<head>
  <script src="https://cdn.jsdelivr.net/npm/vega@5"></script>
</head>
<body>
  <div id="view"></div>
  <script type="text/javascript">
    var view;

    fetch('https://vega.github.io/vega/examples/bar-chart.vg.json')
      .then(res => res.json())
      .then(spec => render(spec))
      .catch(err => console.error(err));

    function render(spec) {
      view = new vega.View(vega.parse(spec), {
        renderer:  'canvas',  // renderer (canvas or svg)
        container: '#view',   // parent DOM container
        hover:     true       // enable hover processing
      });
      return view.runAsync();
    }
  </script>
</body>\n<head>
  <script src="https://cdn.jsdelivr.net/npm/vega@5"></script>
</head>
<body>
  <div id="view"></div>
  <script type="text/javascript">
    var view;

    fetch('https://vega.github.io/vega/examples/bar-chart.vg.json')
      .then(res => res.json())
      .then(spec => render(spec))
      .catch(err => console.error(err));

    function render(spec) {
      view = new vega.View(vega.parse(spec), {
        renderer:  'canvas',  // renderer (canvas or svg)
        container: '#view',   // parent DOM container
        hover:     true       // enable hover processing
      });
      return view.runAsync();
    }
  </script>
</body>\n"https://cdn.jsdelivr.net/npm/vega@5"\nhttps://vega.github.io/vega/examples/bar-chart.vg.json\n// renderer (canvas or svg)\n// parent DOM container\n// enable hover processing\nVega visualizations will be added to a parent DOM container element. This element (either a DOM object or a unique CSS selector string) must be provided  as a View constructor option or an as argument to the View initialize method. Note: Any existing content within the parent container element will be removed upon view initialization.\nVega and Content Security Policy (CSP)\nBy default Vega is not compliant with standard Content Security Policy (CSP), as it uses the Function constructor to generate functions defined in the Vega expression language. However, Vega allows use of alternative expression evaluators that are CSP-compliant. For more, see the expression interpreter usage documentation.\nContent Security Policy (CSP)\nexpression interpreter\nCommand Line Utilities\nThe vega-cli package includes three node.js-based command line utilities – vg2pdf, vg2png, and vg2svg – for rendering static visualization images. These commands render to PDF, PNG, or SVG files, respectively.\nvg2pdf: vg2pdf [options] [input_vega_json_file] [output_pdf_file]\nvg2png: vg2png [options] [input_vega_json_file] [output_png_file]\nvg2svg: vg2svg [options] [input_vega_json_file] [output_svg_file]\nIf no input Vega JSON file is given, the utilities will attempt to read the file from standard input. If no output file is given, the resulting PDF, PNG, or SVG data will be written to standard output, and so can be piped into other applications.\nThe programs also accept the following (optional) parameters:\n-b, –base - [String] A base directory to use for data and image loading. For web retrieval, use -b http://host/data/. For files, use -b data/ (relative path) or -b file:///dir/data/ (absolute path).\n-h, –header - [Flag] Includes XML header and DOCTYPE in SVG output (vg2svg only).\n-s, –scale - [Number] [Default:1] A resolution scale factor. For example, -s 2 results in a doubling of the output resolution. For PDF or SVG, scales the output coordinate space.\n-seed, - [Number] Seed for random number generation. Allows for consistent output over random values. Internally replaces Math.random with a linear congruential generator.\nlinear congruential generator\n-c, –config, - [String] Provide a Vega config object. A file path string to a JSON file or .js file that exports an object.\n-f, –format, - [String] Set the number format locale. A file path string to a JSON file or .js file that exports an object.\n-t, –timeFormat, - [String] Set data/time format locale. A file path string to a JSON file or .js file that exports an object.\ndata/time format locale\n-l, –loglevel - [String] Level of log messages written to standard error output. One of error, warn (default), info, or debug.\n–help - [Flag] Print usage help to the console.\nTo install the command line utilities, you must install the vega-cli npm package. For example, yarn global add vega-cli or npm install -g vega-cli will install the utilities for global use. If you install the package locally, the commands are accessible via your node_modules folder (./node_modules/bin/vg2png). The command line utilities depend on the node-canvas package. See below for more information about Vega and node-canvas.\ninformation about Vega and node-canvas\nAll errors and logging message will be written to standard error output (stderr). To create a log file, pipe the stderr output to the desired file. For example: vg2pdf ...arguments 2> vg2pdf.log.\nIn the vega package, you can run the following from the command line if vega-cli is installed.\nRender the bar chart example to a PNG file:\nvg2png test/specs-valid/bar.vg.json bar.png\nvg2png test/specs-valid/bar.vg.json bar.png\nRender the bar chart example to an SVG file, including XML headers:\nvg2svg -h test/specs-valid/bar.vg.json bar.svg\nvg2svg -h test/specs-valid/bar.vg.json bar.svg\nRender the arc example as a PDF, piped to a file via standard output:\nvg2pdf test/specs-valid/arc.vg.json > arc.pdf\nvg2pdf test/specs-valid/arc.vg.json > arc.pdf\nRender the choropleth example to a PNG file. A base directory is specified for loading data files:\nvg2png -b test test/specs-valid/choropleth.vg.json > choropleth.png\nvg2png -b test test/specs-valid/choropleth.vg.json > choropleth.png\nRender the bar chart example to a PNG file at double resolution:\nvg2png -s 2 test/specs-valid/bar.vg.json bar.png\nvg2png -s 2 test/specs-valid/bar.vg.json bar.png\nServer-Side Deployment using Node.js\nTo use Vega as a component within a larger project, first install it either directly (yarn add vega or npm install vega) or by including "vega" among the dependencies in your package.json file. In node.js JavaScript code, import Vega using require('vega'). Much like browser-based deployments, Node.js deployments leverage the Vega View API. However, server-side View instances should use the renderer type none and provide no DOM element to the initialize method.\nTo generate PNG images and accurately measure font metrics for text mark truncation, the node-canvas package must be installed. The vega package does not require node-canvas by default, so you must include it as an explicit dependency in your own project if you wish to use it. The vega-cli package, on the other hand, does include node-canvas as an explicit dependency.\nOccasionally some system configurations may run into errors while installing node-canvas. Please consult the node-canvas documentation if you experience installation issues.\nnode-canvas documentation\nvar vega = require('vega');

// create a new view instance for a given Vega JSON spec
var view = new vega.View(vega.parse(spec), {renderer: 'none'});

// generate a static SVG image
view.toSVG()
  .then(function(svg) {
    // process svg string
  })
  .catch(function(err) { console.error(err); });

// generate a static PNG image
view.toCanvas()
  .then(function(canvas) {
    // process node-canvas instance
    // for example, generate a PNG stream to write
    var stream = canvas.createPNGStream();
  })
  .catch(function(err) { console.error(err); });\nvar vega = require('vega');

// create a new view instance for a given Vega JSON spec
var view = new vega.View(vega.parse(spec), {renderer: 'none'});

// generate a static SVG image
view.toSVG()
  .then(function(svg) {
    // process svg string
  })
  .catch(function(err) { console.error(err); });

// generate a static PNG image
view.toCanvas()
  .then(function(canvas) {
    // process node-canvas instance
    // for example, generate a PNG stream to write
    var stream = canvas.createPNGStream();
  })
  .catch(function(err) { console.error(err); });\n// create a new view instance for a given Vega JSON spec\n// generate a static SVG image\n// process svg string\n// generate a static PNG image\n// process node-canvas instance\n// for example, generate a PNG stream to write\n\n\nVega
            
              Vega-Lite
              Altair
              Vega-Lite API
            
          
          
            
              Examples
              Tutorials
              Documentation
              Usage
              About
            
            
              GitHub
              Try Online
            
          
        
      

      
        

  
  
    
      
      
        Documentation
      
      
      
      
        Parser
      
      
      
      
        View
      
      
      
      
        Locale
      
      
      
      
        Extensibility
      
      
      
      
        Statistics
      
      
      
      
        Time
      
      
      
      
        Util
      
      
      
      
        Debugging
      
      
    
  
  
    Parser API
    The Vega parser accepts a Vega JSON specification as input and generates a runtime dataflow description as output.

Parser API Reference

#
vega.parse(specification[, config, options])
<>

Parses a Vega JSON specification as input and produces a reactive dataflow graph description for a visualization. The output description uses the JSON format of the vega-runtime module. To create a visualization, use the runtime dataflow description as the input to a Vega View instance.

The optional config object provides visual encoding defaults for marks, scales, axes and legends. Different configuration settings can be used to change choices of layout, color, type faces, font sizes and more to realize different chart themes. If this value is null, the standard configuration is used. If non-null, the provided configuration will be merged with the default settings, with the input taking precedence.

In addition to passing configuration options to this parse method, Vega JSON specifications may also include a top-level "config" block specifying configuration properties. Configuration options defined within a Vega JSON file take precedence over those provided to the parse method.

The options object can modfity the parser configuration. The supported options are:


  ast: A boolean flag (default false) that indicates if abstract syntax trees (ASTs) for Vega expressions should be included in the parser output. By default only generated JavaScript code fragments are included. This option allows third parties to swap out Vega’s code generation for an alternative expression evaluator, such as the one provided by the vega-interpreter package. ≥ 5.12\nVega
            
              Vega-Lite
              Altair
              Vega-Lite API\nVega-Lite
              Altair
              Vega-Lite API\nExamples
              Tutorials
              Documentation
              Usage
              About
            
            
              GitHub
              Try Online\nExamples
              Tutorials
              Documentation
              Usage
              About\nGitHub
              Try Online\nDocumentation
      
      
      
      
        Parser
      
      
      
      
        View
      
      
      
      
        Locale
      
      
      
      
        Extensibility
      
      
      
      
        Statistics
      
      
      
      
        Time
      
      
      
      
        Util
      
      
      
      
        Debugging
      
      
    
  
  
    Parser API
    The Vega parser accepts a Vega JSON specification as input and generates a runtime dataflow description as output.

Parser API Reference

#
vega.parse(specification[, config, options])
<>

Parses a Vega JSON specification as input and produces a reactive dataflow graph description for a visualization. The output description uses the JSON format of the vega-runtime module. To create a visualization, use the runtime dataflow description as the input to a Vega View instance.

The optional config object provides visual encoding defaults for marks, scales, axes and legends. Different configuration settings can be used to change choices of layout, color, type faces, font sizes and more to realize different chart themes. If this value is null, the standard configuration is used. If non-null, the provided configuration will be merged with the default settings, with the input taking precedence.

In addition to passing configuration options to this parse method, Vega JSON specifications may also include a top-level "config" block specifying configuration properties. Configuration options defined within a Vega JSON file take precedence over those provided to the parse method.

The options object can modfity the parser configuration. The supported options are:


  ast: A boolean flag (default false) that indicates if abstract syntax trees (ASTs) for Vega expressions should be included in the parser output. By default only generated JavaScript code fragments are included. This option allows third parties to swap out Vega’s code generation for an alternative expression evaluator, such as the one provided by the vega-interpreter package. ≥ 5.12\nThe Vega parser accepts a Vega JSON specification as input and generates a runtime dataflow description as output.\n#
vega.parse(specification[, config, options])
<>\nParses a Vega JSON specification as input and produces a reactive dataflow graph description for a visualization. The output description uses the JSON format of the vega-runtime module. To create a visualization, use the runtime dataflow description as the input to a Vega View instance.\nVega JSON specification\nThe optional config object provides visual encoding defaults for marks, scales, axes and legends. Different configuration settings can be used to change choices of layout, color, type faces, font sizes and more to realize different chart themes. If this value is null, the standard configuration is used. If non-null, the provided configuration will be merged with the default settings, with the input taking precedence.\nIn addition to passing configuration options to this parse method, Vega JSON specifications may also include a top-level "config" block specifying configuration properties. Configuration options defined within a Vega JSON file take precedence over those provided to the parse method.\nThe options object can modfity the parser configuration. The supported options are:\nast: A boolean flag (default false) that indicates if abstract syntax trees (ASTs) for Vega expressions should be included in the parser output. By default only generated JavaScript code fragments are included. This option allows third parties to swap out Vega’s code generation for an alternative expression evaluator, such as the one provided by the vega-interpreter package. ≥ 5.12\nvega-interpreter package\n\n\nVega
            
              Vega-Lite
              Altair
              Vega-Lite API
            
          
          
            
              Examples
              Tutorials
              Documentation
              Usage
              About
            
            
              GitHub
              Try Online
            
          
        
      

      
        

  
  
    
      
      
        Documentation
      
      
      
      
        Parser
      
      
      
      
        View
      
      
      
      
        Locale
      
      
      
      
        Extensibility
      
      
      
      
        Statistics
      
      
      
      
        Time
      
      
      
      
        Util
      
      
      
      
        Debugging
      
      
    
  
  
    View API
    A View instantiates a Vega dataflow graph and provides a component for visualization rendering and interaction. When initialized with a container DOM element, the View adds a Canvas or SVG-based visualization to a web page. Alternatively, a View can be used either client-side or server-side to export static SVG or PNG (Canvas) images.

View API Reference


  View Construction
  View Configuration
  Dataflow and Rendering
  Signals
  Event Handling
  Image Export
  Data and Scales


View Construction

Methods for constructing and deconstructing views. In addition to the methods described below, View instances also inherit all (non-overridden) methods of the Dataflow parent class.

#
vega.View(runtime[, options])
<>

Constructor that creates a new View instance for the provided Vega dataflow runtime specification. If provided, the options argument should be an object with one or more of the following properties:


  background: View background color. See the background method.
  bind: DOM container element (or CSS selector) for input elements bound to signals. See the initialize method.
  container: Parent DOM container element (or unique CSS selector) for this view. See the initialize method.
  hover: Boolean flag indicating if hover processing should be enabled. See the hover method.
  loader: Default loader instance to use for data files and images.
  logLevel: Initial log level to use. See the logLevel method.
  logger: Initial logger to use. See the logger method.
  renderer: The type of renderer to use ('canvas' or 'svg'). See the renderer method.
  tooltip: Handler function invoked to support tooltip display. See the tooltip method.
  locale: Locale definitions for string parsing and formatting of number and date values. The locale object should contain number and/or time properties with locale definitions. If unspecified, the current default locale at the time of instantiation will be used for the View instance. ≥ 5.12
  expr: Alternate evaluator for Vega expressions. See the interpreter usage documentation. ≥ 5.13
  watchPixelRatio: Boolean flag allowing an event listener to trigger a re-render when the pixel ratio of the page changes (such as via zooming or changing monitors).


The View constructor call is typically followed by a chain of method calls to setup the desired view configuration. After this chain, the runAsync method evaluates the underlying dataflow graph to update and render the visualization.

var view = new vega.View(runtime)
  .logLevel(vega.Warn) // set view logging level
  .renderer('svg')     // set render type (defaults to 'canvas')
  .initialize('#view') // set parent DOM element
  .hover();            // enable hover event processing, *only call once*!

view.runAsync(); // evaluate and render the view


Alternatively, using View constructor options:

var view = new vega.View(runtime, {
    logLevel:  vega.Warn, // view logging level
    renderer:  'svg',     // render type (defaults to 'canvas')
    container: '#view',   // parent DOM element
    hover:     true       // enable hover event processing
  });

view.runAsync(); // evaluate and render the view


Or, if used within an async function:

var view = await new vega.View(runtime, {
    logLevel:  vega.Warn, // view logging level
    renderer:  'svg',     // render type (defaults to 'canvas')
    container: '#view',   // parent DOM element
    hover:     true       // enable hover event processing
  }).runAsync();          // evaluate and render the view


#
view.finalize()
<>

Prepares the view to be removed. To prevent unwanted behaviors and memory leaks, this method unregisters any timers and removes any event listeners that have been registered on the View or that the visualization has registered on external DOM elements. Applications should invoke this method when a View instance is no longer needed.

Back to reference

View Configuration

Methods for configuring the view state. These methods are often (but not always) invoked immediately after the View constructor, prior to the first invocation of the runAsync or run methods.

#
view.initialize([container, bindContainer])
<>

Initializes internal rendering and event handling, then returns this view instance. If the DOM element container is provided, visualization elements (such as Canvas or SVG HTML elements) will be added to the web page under this containing element. If container is not provided, the view will operate in headless mode, and can still generate static visualization images using the image export methods. The optional DOM element (or unique CSS selector) bindContainer indicates the element that should contain any input elements bound to signals; if not specified the same container element as the visualization will be used.

#
view.loader([loader])
<>

Get or set the loader instance to use for data files and images. If the loader is updated after initialize has been invoked, the visualization will be reinitialized. If a Vega View loads data from an external URL, the load request is made immediately upon view construction. To ensure a custom loader is used, provide the loader as a constructor option! Invoking this method will update the loader only after initial data requests have been made. This method will reset the renderer; invoke runAsync after calling this method to ensure the view is redrawn.

#
view.logLevel(level)
<>

Sets the current log level and returns this view instance. This method controls which types of log messages are printed to the JavaScript console, and is inherited from the Dataflow parent class. The valid level values are vega.None (the default), vega.Warn, vega.Info, vega.Debug. See the logger method in vega-util for more.

#
view.logger(logger)
<>

Get or set the logger instance used to log messages. If no arguments are provided, returns the current logger instance. Otherwise, sets the logger and return this View instance. Provided loggers must support the full API of logger objects generated by the vega-util logger method. Note that by default the log level of the new logger will be used; use the logLevel method to adjust the log level as needed.

When providing a custom logger instance, be aware that all logger methods will be invoked with the View as the function this context. This allows loggers to query additional View state (such as the current pulse timestamp) if desired. Custom loggers that reference their own internal state should avoid using this, unless those methods are defined using arrow function expressions.

#
view.renderer(type)
<>

Sets the renderer type (e.g., 'canvas' (the default) or 'svg') and returns this view instance. While typically invoked immediately upon view creation, this method can be called at any time to change the renderer. Invoke runAsync after calling this method to ensure the view is redrawn.

Additional renderer types may be used if registered via the renderModule method exported by vega-scenegraph; for an example see the vega-webgl-renderer.

#
view.tooltip(tooltipHandler)
<>

Get or set the tooltip handler function, which is invoked to handle display of tooltips (for example, when users hover the mouse cursor over an item). This method will reset the renderer; invoke runAsync after calling this method to ensure the view is redrawn. The tooltipHandler argument should be a function that respects the following method signature:

function(handler, event, item, value) {
  // perform custom tooltip presentation
}


The tooltipHandler function arguments are:


  handler - The scenegraph input Handler instance that invoked the tooltipHandler function.
  event - The event that caused an update to the tooltip display.
  item - The scenegraph item corresponding to the tooltip.
  value - The tooltip value to display. If null or undefined, indicates that no tooltip should be shown. The tooltip value may have an arbitrary type, including Object and Array values. It is up the tooltipHandler to appropriately interpret and display this value.
  In addition, Vega invokes the tooltipHandler using the current View as the this context for the function.


The default handler uses built-in browser support to show tooltips. It takes a value to show in a tooltip, transforms it to a string value, and sets the HTML "title" attribute on the element containing the View. The default handler will coerce literal values to strings, and will show the contents of Object or Array values (up to one level of depth). For Object values, each key-value pair is displayed on its own line of text ("key1: value\nkey2: value2").

#
view.hover([hoverSet, updateSet])
<>

Enables hover event processing and returns this view instance. The optional arguments specify which named encoding sets to invoke upon mouseover and mouseout. The hoverSet defaults to 'hover', corresponding to the "hover" set within a Vega mark specification "encode" block. The updateSet defaults to 'update', corresponding to the "update" set within a Vega mark specification "encode" block. If this method is never invoked, the view will not automatically handle hover events. Instead, the underlying dataflow definition will have to explicitly set up event streams for handling mouseover and mouseout events.

This method should be invoked only once, upon view initialization. Calling this method multiple times will add redundant event listeners to the view. In other words, this method is not idempotent.

#
view.description([text])
<> ≥ 5.10

Gets or sets descriptive text for this view. This description determines the aria-label attribute for the view’s container element. If no arguments are provided, returns the current description. If text is specified, this method sets the description and updates the view container element.

#
view.background([color])
<>

Gets or sets the view background color. If no arguments are provided, returns the current background color. If color is specified, this method sets the background color (overriding any background color defined in the input Vega specification) and returns this view instance. This method does not force an immediate update to the view: invoke the runAsync method when ready. This method is equivalent to view.signal('background'[, color]).

#
view.width([width])
<>

Gets or sets the view width, in pixels. If no arguments are provided, returns the current width value. If width is specified, this method sets the width and returns this view instance. This method does not force an immediate update to the view: invoke the runAsync method when ready. This method is equivalent to view.signal('width'[, width]).

#
view.height([height])
<>

Gets or sets the view height, in pixels. If no arguments are provided, returns the current height value. If height is specified, this method sets the height and returns this view instance. This method does not force an immediate update to the view: invoke the runAsync method when ready. This method is equivalent to view.signal('height'[, height]).

#
view.padding([padding])
<>

Gets or sets the view padding, in pixels. Input padding objects take the form {left: 5, top: 5, right: 5, bottom: 5}; if a numeric padding value is provided, it will be expanded to an object with all properties set to that number. If no arguments are provided, returns the current padding value. If padding is specified, this method sets the padding and returns this view instance. This method does not force an immediate update to the view: invoke the runAsync method when ready. This method is equivalent to view.signal('padding'[, padding]).

#
view.resize()
<>

Sets a flag indicating that layout autosize calculations should be re-run on the next pulse propagation cycle. If an autosize method of "pad" or "fit" is being used, calling this method will cause the chart bounds layout to be recomputed the next time the runAsync method is invoked.

Back to reference

Dataflow and Rendering

Methods for invoking dataflow evaluation and view rendering.

#
view.runAsync([encode, prerun, postrun])
<>

Evaluates the underlying dataflow graph and returns a Promise that resolves upon completion of dataflow processing and scenegraph rendering. The optional encode argument is a String value indicating the name of a custom "encode" set to run in addition to the standard "update" encoder. Any scenegraph elements modified during dataflow evaluation will automatically be re-rendered in the view.

Internally, this method invokes evaluation by the Dataflow parent class, and then additionally performs rendering. The returned Promise will resolve after rendering operations are complete. This method should not be invoked repeatedly until a prior call resolves: callers should await the result of runAsync (or use .then(...) chaining) before re-invoking the method.

The optional prerun and postrun functions are callbacks that will be invoked immediately before and after dataflow evaluation and rendering. The callback functions are called with this view instance as the sole argument. The callbacks may be async functions. If provided, postrun will be invoked after any callbacks registered via the runAfter method.

Most clients should not use the prerun and postrun callback arguments. The callbacks are provided to support internal Vega operations. To perform post-processing after dataflow evaluation, in most cases clients should invoke then or await the Promise returned by runAsync.

In the presence of streaming data, it might be helpful to invoke resize before executing runAsync (see Streaming Data).

#
view.run([encode, prerun, postrun])
<>

Requests asynchronous view evaluation and then synchronously returns this view instance without waiting for evaluation to complete. The arguments are identical to those for runAsync.

This method will return prior to completion of dataflow evaluation. To perform actions after dataflow evaluation is finished, instead use runAsync and invoke then or await on the returned Promise.

#
view.runAfter(callback)
<>

Schedules a callback function to be invoked after the current dataflow evaluation completes. The callback function will be called with this view instance as the sole argument. The callback may be an async function.

If dataflow evaluation is not currently occurring, the callback function is invoked immediately. This method is used internally to schedule follow-up operations within the dataflow runtime engine. Most clients should not use this method; instead call runAsync and perform follow-up operations when the returned Promise resolves.

#
view.dirty(item)
<>

Reports a “dirty” scenegraph item to be re-drawn the next time dataflow evaluation completes. This method is typically invoked by dataflow operators directly to populate a dirty list for incremental rendering.

#
view.container()
<>

Returns the DOM container element for this view, if it exists.

#
view.scenegraph()
<>

Returns the Vega scenegraph instance for this view.

#
view.origin()
<>

Returns the [x, y] origin coordinates for the current view. The origin coordinates indicate the translation of the view’s primary coordinate system, encompassing the left and top padding values as well as any additional padding due to autosize calculations.

Back to reference

Signals

Methods for accessing and updating dataflow signal values.

#
view.signal(name[, value])
<>

Gets or sets a dataflow signal. If only the name argument is provided, returns the requested signal value. If value is also specified, updates the signal and returns this view instance. If the signal does not exist, an error will be raised. This method does not force an immediate update to the view: invoke the runAsync method when ready.

#
view.getState([options])
<>

Gets the state of signals and data sets in this view’s backing dataflow graph. If no arguments are specified, returns an object containing both signal values and any modified data sets for this view. By default, the exported state includes all signal values (across all mark contexts) except for those bound to data pipeline transforms, and any data sets that were explicitly modified via triggers or the View API.

An options argument can be provided to control what internal state is collected. However, the options involve interacting with internal details of a Vega runtime dataflow and is intended for expert use only. The default options should suffice for state capture in most instances.

The options object supports the following properties:

  signals: A predicate function that accepts a signal name and operator and returns true to export the operator state.
  data: A predicate function that accepts a dataset name and dataset object and returns true to export the data.
  recurse: A boolean flag indicating if the state export process should recurse into mark sub-contexts.


#
view.setState(state)
<>

Sets the state of signals and/or datasets in this view’s backing dataflow graph. The state argument should be an object generated by the getState method. This method updates all implicated signals and data sets, invokes the run method, and returns this view instance.

#
view.addSignalListener(name, handler)
<>

Registers a listener for changes to the signal with the given name and returns this view instance. If the signal does not exist, an error will be raised. This method is idempotent: adding the same handler for the same signal multiple times has no effect beyond the first call.

When the signal value changes, the handler function is invoked with two arguments: the name of the signal and the new signal value. Listeners will be invoked when the signal value changes during pulse propagation (e.g., after runAsync is called, but before its returned Promise resolves).

Signal listeners are invoked immediately upon signal update, in the midst of dataflow evaluation. As a result, other signal updates and data transforms may have yet to update. If you wish to access the values of other signals, or update signal values and re-run the dataflow, use the runAsync method with a prerun callback that performs the desired actions after the current dataflow evaluation completes, but before the requested re-run begins. Attempting to call the synchronous run method from within a signal listener will result in an error, as recursive invocation is not allowed.

To remove a listener, use the removeSignalListener method.

view.addSignalListener('width', function(name, value) {
  console.log('WIDTH: ' + value);
});
view.width(500).run(); // listener logs 'WIDTH: 500'


#
view.removeSignalListener(name, handler)
<>

Removes a signal listener registered with the addSignalListener method and returns this view instance. If the signal does not exist, an error will be raised. If the signal exists but the provided handler is not registered, this method has no effect.

Back to reference

Event Handling

Methods for generating new event streams, registering event listeners, and handling tooltips. See also the hover method.

#
view.events(source, type[, filter])
<>

Returns a new EventStream for a specified source, event type, and optional filter function. The source should be one of "view" (to specify the current view), "window" (to specify the browser window object), or a valid CSS selector string (that will be passed to document.querySelectorAll). The event type should be a legal DOM event type. If provided, the optional filter argument should be a function that takes an event object as input and returns true if it should be included in the produced event stream.

Typically this method is invoked internally to create event streams referenced within Vega signal definitions. However, callers can use this method to create custom event streams if desired. This method assumes that the view is running in a browser environment, otherwise invoking this method may have no effect.

#
view.addEventListener(type, handler[, options])
<>

Registers an event listener for input events and returns this view instance. The event type should be a string indicating a legal DOM event type supported by vega-scenegraph event handlers. Examples include "mouseover", "click", "keydown" and "touchstart". This method is idempotent: adding the same handler for the same event type multiple times has no effect beyond the first call.

The optional options hash accepts one parameter (options.trap): if options.trap is set to false, automatic error trapping for event handler functions is disabled.

When events occur, the handler function is invoked with two arguments: the event instance and the currently active scenegraph item (which is null if the event target is the view component itself).

All registered event handlers are preserved upon changes of renderer. For example, if the View renderer type is changed from "canvas" to "svg", all listeners will remain active. To remove a listener, use the removeEventListener method.

view.addEventListener('click', function(event, item) {
  console.log('CLICK', event, item);
});


#
view.removeEventListener(type, handler)
<>

Removes an event listener registered with the addEventListener method and returns this view instance.

#
view.addResizeListener(handler)
<>

Registers a listener for changes to the view size and returns this view instance. This method is idempotent: adding the same handler multiple times has no effect beyond the first call.

When the view size changes, the handler function is invoked with two arguments: the width and height of the view.

view.addResizeListener(function(width, height) {
  console.log('RESIZE', width, height);
});


#
view.removeResizeListener(handler)
<>

Removes a listener registered with the addResizeListener method and returns this view instance.

#
view.globalCursor(flag)
<> ≥ 5.13

Gets or sets a boolean flag (default false) value indicating if Vega should adjust the cursor for the current document body (true) or within the Vega View component only (false). Values set via this method will override the cursor configuration provided by a Vega specification.

#
view.preventDefault(flag)
<>

Gets or sets a boolean flag value (default false) indicating if Vega should call preventDefault() on input events by default. This method specifies the default behavior only, and is overridden by input event configuration provided to the specification or parser.

Back to reference

Image Export

Methods for exporting static visualization images. These methods can be invoked either client-side or server-side.

#
view.toCanvas([scaleFactor, options])
<>

Returns a Promise that resolves to a canvas instance containing a rendered bitmap image of the view. The optional scaleFactor argument (default 1) is a number by which to multiply the view width and height when determining the output image size. If invoked in a browser, the returned Promise resolves to an HTML5 canvas element. If invoked server-side in node.js, the Promise resolves to a node-canvas Canvas instance.

The optional options object provides additional parameters for the canvas:


  type: Type string passed to the node-canvas Canvas constructor (for example, to specify 'pdf' output). This property will be ignored if used in the browser.
  context: An object of key-value pairs to assign to the Canvas 2D context object. Useful for setting context parameters, particularly for node-canvas.
  externalContext: An external Context2D instance to render into. If an external canvas is provided, the Promise returned by toCanvas will resolve to null. As Vega makes changes to the rendering context state, callers should invoke context.save() prior to toCanvas(), and invoke context.restore() to restore the state after the returned Promise resolves. ≥ 5.12


#
view.toSVG([scaleFactor])
<>

Returns a Promise that resolves to an SVG string, providing a vector graphics image of the view. The optional scaleFactor argument (default 1) is a number by which to multiply the view width and height when determining the output image size.

#
view.toImageURL(type[, scaleFactor])
<>

Returns a Promise that resolves to an image URL for a snapshot of the current view. The type argument must be one of 'svg', 'png' or 'canvas'. Both the png and canvas types result in a PNG image. The generated URL can be used to create downloadable visualization images. The optional scaleFactor argument (default 1) is a number by which to multiply the view width and height when determining the output image size.

// generate a PNG snapshot and then download the image
view.toImageURL('png').then(function(url) {
  var link = document.createElement('a');
  link.setAttribute('href', url);
  link.setAttribute('target', '_blank');
  link.setAttribute('download', 'vega-export.png');
  link.dispatchEvent(new MouseEvent('click'));
}).catch(function(error) { /* error handling */ });


Back to reference

Data and Scales

Methods for accessing scales or data sets, and performing streaming updates.

#
view.scale(name)
<>

Returns the scale or
projection instance with the given name. The return value is a live instance used by the underlying dataflow. Callers should take care not to modify the returned instance!

#
view.data(name[, values])
<>

If only one argument is provided, returns the data set with the given name. The returned array of data objects is a live array used by the underlying dataflow. Callers that wish to modify the returned array should first make a defensive copy, for example using view.data('name').slice().

≥ 5.5 If two arguments are provided, removes the current data and inserts the input values, which can be either a single data object or an array of data objects. This call is equivalent to:

view.change(vega.changeset().remove(vega.truthy).insert(values));


Data updates do not force an immediate update to the view: invoke the runAsync method when ready. Note also that a single argument (getter) call returns the output of the data transform pipeline, whereas the two argument (setter) call sets the input to the transform pipeline.

#
view.addDataListener(name, handler)
<>

Registers a listener for changes to a named data set with the given name and returns this view instance. If the data set does not exist, an error will be raised. This method is idempotent: adding the same handler for the same data set multiple times has no effect beyond the first call.

When the data set value changes, the handler function is invoked with two arguments: the name of the signal and the new data set value. Listeners will be invoked when the data set value changes during pulse propagation (e.g., after runAsync is called, but before its returned Promise resolves). The value passed to the handler is the same as that returned by the view.data method. The returned array of data objects is a live array used by the underlying dataflow. Listeners that wish to modify the returned array should first make a defensive copy, for example using value.slice().

Data listeners are invoked immediately upon data set update, in the midst of dataflow evaluation. As a result, other signal values and data transforms may have yet to update. If you wish to access the values of other signals, or update signal values and re-run the dataflow, use the runAsync method with a prerun callback that performs the desired actions after the current dataflow evaluation completes, but before the requested re-run begins. Attempting to call the synchronous run method from within a signal listener will result in an error, as recursive invocation is not allowed.

To remove a listener, use the removeDataListener method.

view.addDataListener('source', function(name, value) {
  console.log(name, value);
});


#
view.removeDataListener(name, handler)
<>

Removes a data set listener registered with the addDataListener method and returns this view instance. If the data set does not exist, an error will be raised. If the data set exists but the provided handler is not registered, this method has no effect.

#
view.change(name, changeset)
<>

Updates the data set with the given name with the changes specified by the provided changeset instance. This method does not force an immediate update to the view: invoke the runAsync method when ready. To issue a series of changes, insertions, or deletions, be sure to await the results of runAsync before issuing the next change.

view.change('data', vega.changeset().insert([...]).remove([...]))
    .run()


The insert and remove methods of the changeset accept a single argument. The supported inputs are identical to the second arguments accepted by the view.insert and view.remove methods.

Inserted data tuples must be JavaScript objects that have been properly parsed ahead of time. Any data source "format" directives in a Vega JSON specification will not be applied to tuples added through the View API. Internally, this method takes the provided ChangeSet and invokes Dataflow.pulse. See vega-dataflow for more.

For versions ≥ 5.13 a changeset also supports an optional clean setter that accepts a boolean and indicates if internal garbage collection should be performed by Vega in response to the change (this defaults to true if the changeset specifies data should be removed).

#
view.insert(name, tuples)
<>

Inserts an array of new data tuples into the data set with the given name, then returns this view instance. The input tuples array should contain one or more data objects that are not already included in the data set. This method does not force an immediate update to the view: invoke the runAsync method when ready.

Insert can not be used in combination with the remove method on the same pulse; to simultaneously add and remove data use the change method. To issue a series of changes, insertions, or deletions, be sure to await the results of runAsync before issuing the next change.

Inserted data tuples must be JavaScript objects that have been properly parsed ahead of time. Any data source "format" directives in a Vega JSON specification will not be applied to tuples added through the View API. Internally, this method creates a ChangeSet and invokes Dataflow.pulse. See vega-dataflow for more.

#
view.remove(name, tuples)
<>

Removes data tuples from the data set with the given name, then returns this view instance. The tuples argument can either be an array of tuples already included in the data set, or a predicate function indicating which tuples should be removed. This method does not force an immediate update to the view: invoke the runAsync method when ready.

Remove can not be used in combination with the insert method on the same pulse; to simultaneously add and remove data use the change method. To issue a series of changes, insertions, or deletions, be sure to await the results of runAsync before issuing the next change.

For example, to remove all tuples in the 'table' data set with a count property less than five:

view.remove('table', d => d.count < 5).run();


Internally, this method creates a ChangeSet and invokes Dataflow.pulse. See vega-dataflow for more.\nVega
            
              Vega-Lite
              Altair
              Vega-Lite API\nVega-Lite
              Altair
              Vega-Lite API\nExamples
              Tutorials
              Documentation
              Usage
              About
            
            
              GitHub
              Try Online\nExamples
              Tutorials
              Documentation
              Usage
              About\nGitHub
              Try Online\nDocumentation
      
      
      
      
        Parser
      
      
      
      
        View
      
      
      
      
        Locale
      
      
      
      
        Extensibility
      
      
      
      
        Statistics
      
      
      
      
        Time
      
      
      
      
        Util
      
      
      
      
        Debugging
      
      
    
  
  
    View API
    A View instantiates a Vega dataflow graph and provides a component for visualization rendering and interaction. When initialized with a container DOM element, the View adds a Canvas or SVG-based visualization to a web page. Alternatively, a View can be used either client-side or server-side to export static SVG or PNG (Canvas) images.

View API Reference


  View Construction
  View Configuration
  Dataflow and Rendering
  Signals
  Event Handling
  Image Export
  Data and Scales


View Construction

Methods for constructing and deconstructing views. In addition to the methods described below, View instances also inherit all (non-overridden) methods of the Dataflow parent class.

#
vega.View(runtime[, options])
<>

Constructor that creates a new View instance for the provided Vega dataflow runtime specification. If provided, the options argument should be an object with one or more of the following properties:


  background: View background color. See the background method.
  bind: DOM container element (or CSS selector) for input elements bound to signals. See the initialize method.
  container: Parent DOM container element (or unique CSS selector) for this view. See the initialize method.
  hover: Boolean flag indicating if hover processing should be enabled. See the hover method.
  loader: Default loader instance to use for data files and images.
  logLevel: Initial log level to use. See the logLevel method.
  logger: Initial logger to use. See the logger method.
  renderer: The type of renderer to use ('canvas' or 'svg'). See the renderer method.
  tooltip: Handler function invoked to support tooltip display. See the tooltip method.
  locale: Locale definitions for string parsing and formatting of number and date values. The locale object should contain number and/or time properties with locale definitions. If unspecified, the current default locale at the time of instantiation will be used for the View instance. ≥ 5.12
  expr: Alternate evaluator for Vega expressions. See the interpreter usage documentation. ≥ 5.13
  watchPixelRatio: Boolean flag allowing an event listener to trigger a re-render when the pixel ratio of the page changes (such as via zooming or changing monitors).


The View constructor call is typically followed by a chain of method calls to setup the desired view configuration. After this chain, the runAsync method evaluates the underlying dataflow graph to update and render the visualization.

var view = new vega.View(runtime)
  .logLevel(vega.Warn) // set view logging level
  .renderer('svg')     // set render type (defaults to 'canvas')
  .initialize('#view') // set parent DOM element
  .hover();            // enable hover event processing, *only call once*!

view.runAsync(); // evaluate and render the view


Alternatively, using View constructor options:

var view = new vega.View(runtime, {
    logLevel:  vega.Warn, // view logging level
    renderer:  'svg',     // render type (defaults to 'canvas')
    container: '#view',   // parent DOM element
    hover:     true       // enable hover event processing
  });

view.runAsync(); // evaluate and render the view


Or, if used within an async function:

var view = await new vega.View(runtime, {
    logLevel:  vega.Warn, // view logging level
    renderer:  'svg',     // render type (defaults to 'canvas')
    container: '#view',   // parent DOM element
    hover:     true       // enable hover event processing
  }).runAsync();          // evaluate and render the view


#
view.finalize()
<>

Prepares the view to be removed. To prevent unwanted behaviors and memory leaks, this method unregisters any timers and removes any event listeners that have been registered on the View or that the visualization has registered on external DOM elements. Applications should invoke this method when a View instance is no longer needed.

Back to reference

View Configuration

Methods for configuring the view state. These methods are often (but not always) invoked immediately after the View constructor, prior to the first invocation of the runAsync or run methods.

#
view.initialize([container, bindContainer])
<>

Initializes internal rendering and event handling, then returns this view instance. If the DOM element container is provided, visualization elements (such as Canvas or SVG HTML elements) will be added to the web page under this containing element. If container is not provided, the view will operate in headless mode, and can still generate static visualization images using the image export methods. The optional DOM element (or unique CSS selector) bindContainer indicates the element that should contain any input elements bound to signals; if not specified the same container element as the visualization will be used.

#
view.loader([loader])
<>

Get or set the loader instance to use for data files and images. If the loader is updated after initialize has been invoked, the visualization will be reinitialized. If a Vega View loads data from an external URL, the load request is made immediately upon view construction. To ensure a custom loader is used, provide the loader as a constructor option! Invoking this method will update the loader only after initial data requests have been made. This method will reset the renderer; invoke runAsync after calling this method to ensure the view is redrawn.

#
view.logLevel(level)
<>

Sets the current log level and returns this view instance. This method controls which types of log messages are printed to the JavaScript console, and is inherited from the Dataflow parent class. The valid level values are vega.None (the default), vega.Warn, vega.Info, vega.Debug. See the logger method in vega-util for more.

#
view.logger(logger)
<>

Get or set the logger instance used to log messages. If no arguments are provided, returns the current logger instance. Otherwise, sets the logger and return this View instance. Provided loggers must support the full API of logger objects generated by the vega-util logger method. Note that by default the log level of the new logger will be used; use the logLevel method to adjust the log level as needed.

When providing a custom logger instance, be aware that all logger methods will be invoked with the View as the function this context. This allows loggers to query additional View state (such as the current pulse timestamp) if desired. Custom loggers that reference their own internal state should avoid using this, unless those methods are defined using arrow function expressions.

#
view.renderer(type)
<>

Sets the renderer type (e.g., 'canvas' (the default) or 'svg') and returns this view instance. While typically invoked immediately upon view creation, this method can be called at any time to change the renderer. Invoke runAsync after calling this method to ensure the view is redrawn.

Additional renderer types may be used if registered via the renderModule method exported by vega-scenegraph; for an example see the vega-webgl-renderer.

#
view.tooltip(tooltipHandler)
<>

Get or set the tooltip handler function, which is invoked to handle display of tooltips (for example, when users hover the mouse cursor over an item). This method will reset the renderer; invoke runAsync after calling this method to ensure the view is redrawn. The tooltipHandler argument should be a function that respects the following method signature:

function(handler, event, item, value) {
  // perform custom tooltip presentation
}


The tooltipHandler function arguments are:


  handler - The scenegraph input Handler instance that invoked the tooltipHandler function.
  event - The event that caused an update to the tooltip display.
  item - The scenegraph item corresponding to the tooltip.
  value - The tooltip value to display. If null or undefined, indicates that no tooltip should be shown. The tooltip value may have an arbitrary type, including Object and Array values. It is up the tooltipHandler to appropriately interpret and display this value.
  In addition, Vega invokes the tooltipHandler using the current View as the this context for the function.


The default handler uses built-in browser support to show tooltips. It takes a value to show in a tooltip, transforms it to a string value, and sets the HTML "title" attribute on the element containing the View. The default handler will coerce literal values to strings, and will show the contents of Object or Array values (up to one level of depth). For Object values, each key-value pair is displayed on its own line of text ("key1: value\nkey2: value2").

#
view.hover([hoverSet, updateSet])
<>

Enables hover event processing and returns this view instance. The optional arguments specify which named encoding sets to invoke upon mouseover and mouseout. The hoverSet defaults to 'hover', corresponding to the "hover" set within a Vega mark specification "encode" block. The updateSet defaults to 'update', corresponding to the "update" set within a Vega mark specification "encode" block. If this method is never invoked, the view will not automatically handle hover events. Instead, the underlying dataflow definition will have to explicitly set up event streams for handling mouseover and mouseout events.

This method should be invoked only once, upon view initialization. Calling this method multiple times will add redundant event listeners to the view. In other words, this method is not idempotent.

#
view.description([text])
<> ≥ 5.10

Gets or sets descriptive text for this view. This description determines the aria-label attribute for the view’s container element. If no arguments are provided, returns the current description. If text is specified, this method sets the description and updates the view container element.

#
view.background([color])
<>

Gets or sets the view background color. If no arguments are provided, returns the current background color. If color is specified, this method sets the background color (overriding any background color defined in the input Vega specification) and returns this view instance. This method does not force an immediate update to the view: invoke the runAsync method when ready. This method is equivalent to view.signal('background'[, color]).

#
view.width([width])
<>

Gets or sets the view width, in pixels. If no arguments are provided, returns the current width value. If width is specified, this method sets the width and returns this view instance. This method does not force an immediate update to the view: invoke the runAsync method when ready. This method is equivalent to view.signal('width'[, width]).

#
view.height([height])
<>

Gets or sets the view height, in pixels. If no arguments are provided, returns the current height value. If height is specified, this method sets the height and returns this view instance. This method does not force an immediate update to the view: invoke the runAsync method when ready. This method is equivalent to view.signal('height'[, height]).

#
view.padding([padding])
<>

Gets or sets the view padding, in pixels. Input padding objects take the form {left: 5, top: 5, right: 5, bottom: 5}; if a numeric padding value is provided, it will be expanded to an object with all properties set to that number. If no arguments are provided, returns the current padding value. If padding is specified, this method sets the padding and returns this view instance. This method does not force an immediate update to the view: invoke the runAsync method when ready. This method is equivalent to view.signal('padding'[, padding]).

#
view.resize()
<>

Sets a flag indicating that layout autosize calculations should be re-run on the next pulse propagation cycle. If an autosize method of "pad" or "fit" is being used, calling this method will cause the chart bounds layout to be recomputed the next time the runAsync method is invoked.

Back to reference

Dataflow and Rendering

Methods for invoking dataflow evaluation and view rendering.

#
view.runAsync([encode, prerun, postrun])
<>

Evaluates the underlying dataflow graph and returns a Promise that resolves upon completion of dataflow processing and scenegraph rendering. The optional encode argument is a String value indicating the name of a custom "encode" set to run in addition to the standard "update" encoder. Any scenegraph elements modified during dataflow evaluation will automatically be re-rendered in the view.

Internally, this method invokes evaluation by the Dataflow parent class, and then additionally performs rendering. The returned Promise will resolve after rendering operations are complete. This method should not be invoked repeatedly until a prior call resolves: callers should await the result of runAsync (or use .then(...) chaining) before re-invoking the method.

The optional prerun and postrun functions are callbacks that will be invoked immediately before and after dataflow evaluation and rendering. The callback functions are called with this view instance as the sole argument. The callbacks may be async functions. If provided, postrun will be invoked after any callbacks registered via the runAfter method.

Most clients should not use the prerun and postrun callback arguments. The callbacks are provided to support internal Vega operations. To perform post-processing after dataflow evaluation, in most cases clients should invoke then or await the Promise returned by runAsync.

In the presence of streaming data, it might be helpful to invoke resize before executing runAsync (see Streaming Data).

#
view.run([encode, prerun, postrun])
<>

Requests asynchronous view evaluation and then synchronously returns this view instance without waiting for evaluation to complete. The arguments are identical to those for runAsync.

This method will return prior to completion of dataflow evaluation. To perform actions after dataflow evaluation is finished, instead use runAsync and invoke then or await on the returned Promise.

#
view.runAfter(callback)
<>

Schedules a callback function to be invoked after the current dataflow evaluation completes. The callback function will be called with this view instance as the sole argument. The callback may be an async function.

If dataflow evaluation is not currently occurring, the callback function is invoked immediately. This method is used internally to schedule follow-up operations within the dataflow runtime engine. Most clients should not use this method; instead call runAsync and perform follow-up operations when the returned Promise resolves.

#
view.dirty(item)
<>

Reports a “dirty” scenegraph item to be re-drawn the next time dataflow evaluation completes. This method is typically invoked by dataflow operators directly to populate a dirty list for incremental rendering.

#
view.container()
<>

Returns the DOM container element for this view, if it exists.

#
view.scenegraph()
<>

Returns the Vega scenegraph instance for this view.

#
view.origin()
<>

Returns the [x, y] origin coordinates for the current view. The origin coordinates indicate the translation of the view’s primary coordinate system, encompassing the left and top padding values as well as any additional padding due to autosize calculations.

Back to reference

Signals

Methods for accessing and updating dataflow signal values.

#
view.signal(name[, value])
<>

Gets or sets a dataflow signal. If only the name argument is provided, returns the requested signal value. If value is also specified, updates the signal and returns this view instance. If the signal does not exist, an error will be raised. This method does not force an immediate update to the view: invoke the runAsync method when ready.

#
view.getState([options])
<>

Gets the state of signals and data sets in this view’s backing dataflow graph. If no arguments are specified, returns an object containing both signal values and any modified data sets for this view. By default, the exported state includes all signal values (across all mark contexts) except for those bound to data pipeline transforms, and any data sets that were explicitly modified via triggers or the View API.

An options argument can be provided to control what internal state is collected. However, the options involve interacting with internal details of a Vega runtime dataflow and is intended for expert use only. The default options should suffice for state capture in most instances.

The options object supports the following properties:

  signals: A predicate function that accepts a signal name and operator and returns true to export the operator state.
  data: A predicate function that accepts a dataset name and dataset object and returns true to export the data.
  recurse: A boolean flag indicating if the state export process should recurse into mark sub-contexts.


#
view.setState(state)
<>

Sets the state of signals and/or datasets in this view’s backing dataflow graph. The state argument should be an object generated by the getState method. This method updates all implicated signals and data sets, invokes the run method, and returns this view instance.

#
view.addSignalListener(name, handler)
<>

Registers a listener for changes to the signal with the given name and returns this view instance. If the signal does not exist, an error will be raised. This method is idempotent: adding the same handler for the same signal multiple times has no effect beyond the first call.

When the signal value changes, the handler function is invoked with two arguments: the name of the signal and the new signal value. Listeners will be invoked when the signal value changes during pulse propagation (e.g., after runAsync is called, but before its returned Promise resolves).

Signal listeners are invoked immediately upon signal update, in the midst of dataflow evaluation. As a result, other signal updates and data transforms may have yet to update. If you wish to access the values of other signals, or update signal values and re-run the dataflow, use the runAsync method with a prerun callback that performs the desired actions after the current dataflow evaluation completes, but before the requested re-run begins. Attempting to call the synchronous run method from within a signal listener will result in an error, as recursive invocation is not allowed.

To remove a listener, use the removeSignalListener method.

view.addSignalListener('width', function(name, value) {
  console.log('WIDTH: ' + value);
});
view.width(500).run(); // listener logs 'WIDTH: 500'


#
view.removeSignalListener(name, handler)
<>

Removes a signal listener registered with the addSignalListener method and returns this view instance. If the signal does not exist, an error will be raised. If the signal exists but the provided handler is not registered, this method has no effect.

Back to reference

Event Handling

Methods for generating new event streams, registering event listeners, and handling tooltips. See also the hover method.

#
view.events(source, type[, filter])
<>

Returns a new EventStream for a specified source, event type, and optional filter function. The source should be one of "view" (to specify the current view), "window" (to specify the browser window object), or a valid CSS selector string (that will be passed to document.querySelectorAll). The event type should be a legal DOM event type. If provided, the optional filter argument should be a function that takes an event object as input and returns true if it should be included in the produced event stream.

Typically this method is invoked internally to create event streams referenced within Vega signal definitions. However, callers can use this method to create custom event streams if desired. This method assumes that the view is running in a browser environment, otherwise invoking this method may have no effect.

#
view.addEventListener(type, handler[, options])
<>

Registers an event listener for input events and returns this view instance. The event type should be a string indicating a legal DOM event type supported by vega-scenegraph event handlers. Examples include "mouseover", "click", "keydown" and "touchstart". This method is idempotent: adding the same handler for the same event type multiple times has no effect beyond the first call.

The optional options hash accepts one parameter (options.trap): if options.trap is set to false, automatic error trapping for event handler functions is disabled.

When events occur, the handler function is invoked with two arguments: the event instance and the currently active scenegraph item (which is null if the event target is the view component itself).

All registered event handlers are preserved upon changes of renderer. For example, if the View renderer type is changed from "canvas" to "svg", all listeners will remain active. To remove a listener, use the removeEventListener method.

view.addEventListener('click', function(event, item) {
  console.log('CLICK', event, item);
});


#
view.removeEventListener(type, handler)
<>

Removes an event listener registered with the addEventListener method and returns this view instance.

#
view.addResizeListener(handler)
<>

Registers a listener for changes to the view size and returns this view instance. This method is idempotent: adding the same handler multiple times has no effect beyond the first call.

When the view size changes, the handler function is invoked with two arguments: the width and height of the view.

view.addResizeListener(function(width, height) {
  console.log('RESIZE', width, height);
});


#
view.removeResizeListener(handler)
<>

Removes a listener registered with the addResizeListener method and returns this view instance.

#
view.globalCursor(flag)
<> ≥ 5.13

Gets or sets a boolean flag (default false) value indicating if Vega should adjust the cursor for the current document body (true) or within the Vega View component only (false). Values set via this method will override the cursor configuration provided by a Vega specification.

#
view.preventDefault(flag)
<>

Gets or sets a boolean flag value (default false) indicating if Vega should call preventDefault() on input events by default. This method specifies the default behavior only, and is overridden by input event configuration provided to the specification or parser.

Back to reference

Image Export

Methods for exporting static visualization images. These methods can be invoked either client-side or server-side.

#
view.toCanvas([scaleFactor, options])
<>

Returns a Promise that resolves to a canvas instance containing a rendered bitmap image of the view. The optional scaleFactor argument (default 1) is a number by which to multiply the view width and height when determining the output image size. If invoked in a browser, the returned Promise resolves to an HTML5 canvas element. If invoked server-side in node.js, the Promise resolves to a node-canvas Canvas instance.

The optional options object provides additional parameters for the canvas:


  type: Type string passed to the node-canvas Canvas constructor (for example, to specify 'pdf' output). This property will be ignored if used in the browser.
  context: An object of key-value pairs to assign to the Canvas 2D context object. Useful for setting context parameters, particularly for node-canvas.
  externalContext: An external Context2D instance to render into. If an external canvas is provided, the Promise returned by toCanvas will resolve to null. As Vega makes changes to the rendering context state, callers should invoke context.save() prior to toCanvas(), and invoke context.restore() to restore the state after the returned Promise resolves. ≥ 5.12


#
view.toSVG([scaleFactor])
<>

Returns a Promise that resolves to an SVG string, providing a vector graphics image of the view. The optional scaleFactor argument (default 1) is a number by which to multiply the view width and height when determining the output image size.

#
view.toImageURL(type[, scaleFactor])
<>

Returns a Promise that resolves to an image URL for a snapshot of the current view. The type argument must be one of 'svg', 'png' or 'canvas'. Both the png and canvas types result in a PNG image. The generated URL can be used to create downloadable visualization images. The optional scaleFactor argument (default 1) is a number by which to multiply the view width and height when determining the output image size.

// generate a PNG snapshot and then download the image
view.toImageURL('png').then(function(url) {
  var link = document.createElement('a');
  link.setAttribute('href', url);
  link.setAttribute('target', '_blank');
  link.setAttribute('download', 'vega-export.png');
  link.dispatchEvent(new MouseEvent('click'));
}).catch(function(error) { /* error handling */ });


Back to reference

Data and Scales

Methods for accessing scales or data sets, and performing streaming updates.

#
view.scale(name)
<>

Returns the scale or
projection instance with the given name. The return value is a live instance used by the underlying dataflow. Callers should take care not to modify the returned instance!

#
view.data(name[, values])
<>

If only one argument is provided, returns the data set with the given name. The returned array of data objects is a live array used by the underlying dataflow. Callers that wish to modify the returned array should first make a defensive copy, for example using view.data('name').slice().

≥ 5.5 If two arguments are provided, removes the current data and inserts the input values, which can be either a single data object or an array of data objects. This call is equivalent to:

view.change(vega.changeset().remove(vega.truthy).insert(values));


Data updates do not force an immediate update to the view: invoke the runAsync method when ready. Note also that a single argument (getter) call returns the output of the data transform pipeline, whereas the two argument (setter) call sets the input to the transform pipeline.

#
view.addDataListener(name, handler)
<>

Registers a listener for changes to a named data set with the given name and returns this view instance. If the data set does not exist, an error will be raised. This method is idempotent: adding the same handler for the same data set multiple times has no effect beyond the first call.

When the data set value changes, the handler function is invoked with two arguments: the name of the signal and the new data set value. Listeners will be invoked when the data set value changes during pulse propagation (e.g., after runAsync is called, but before its returned Promise resolves). The value passed to the handler is the same as that returned by the view.data method. The returned array of data objects is a live array used by the underlying dataflow. Listeners that wish to modify the returned array should first make a defensive copy, for example using value.slice().

Data listeners are invoked immediately upon data set update, in the midst of dataflow evaluation. As a result, other signal values and data transforms may have yet to update. If you wish to access the values of other signals, or update signal values and re-run the dataflow, use the runAsync method with a prerun callback that performs the desired actions after the current dataflow evaluation completes, but before the requested re-run begins. Attempting to call the synchronous run method from within a signal listener will result in an error, as recursive invocation is not allowed.

To remove a listener, use the removeDataListener method.

view.addDataListener('source', function(name, value) {
  console.log(name, value);
});


#
view.removeDataListener(name, handler)
<>

Removes a data set listener registered with the addDataListener method and returns this view instance. If the data set does not exist, an error will be raised. If the data set exists but the provided handler is not registered, this method has no effect.

#
view.change(name, changeset)
<>

Updates the data set with the given name with the changes specified by the provided changeset instance. This method does not force an immediate update to the view: invoke the runAsync method when ready. To issue a series of changes, insertions, or deletions, be sure to await the results of runAsync before issuing the next change.

view.change('data', vega.changeset().insert([...]).remove([...]))
    .run()


The insert and remove methods of the changeset accept a single argument. The supported inputs are identical to the second arguments accepted by the view.insert and view.remove methods.

Inserted data tuples must be JavaScript objects that have been properly parsed ahead of time. Any data source "format" directives in a Vega JSON specification will not be applied to tuples added through the View API. Internally, this method takes the provided ChangeSet and invokes Dataflow.pulse. See vega-dataflow for more.

For versions ≥ 5.13 a changeset also supports an optional clean setter that accepts a boolean and indicates if internal garbage collection should be performed by Vega in response to the change (this defaults to true if the changeset specifies data should be removed).

#
view.insert(name, tuples)
<>

Inserts an array of new data tuples into the data set with the given name, then returns this view instance. The input tuples array should contain one or more data objects that are not already included in the data set. This method does not force an immediate update to the view: invoke the runAsync method when ready.

Insert can not be used in combination with the remove method on the same pulse; to simultaneously add and remove data use the change method. To issue a series of changes, insertions, or deletions, be sure to await the results of runAsync before issuing the next change.

Inserted data tuples must be JavaScript objects that have been properly parsed ahead of time. Any data source "format" directives in a Vega JSON specification will not be applied to tuples added through the View API. Internally, this method creates a ChangeSet and invokes Dataflow.pulse. See vega-dataflow for more.

#
view.remove(name, tuples)
<>

Removes data tuples from the data set with the given name, then returns this view instance. The tuples argument can either be an array of tuples already included in the data set, or a predicate function indicating which tuples should be removed. This method does not force an immediate update to the view: invoke the runAsync method when ready.

Remove can not be used in combination with the insert method on the same pulse; to simultaneously add and remove data use the change method. To issue a series of changes, insertions, or deletions, be sure to await the results of runAsync before issuing the next change.

For example, to remove all tuples in the 'table' data set with a count property less than five:

view.remove('table', d => d.count < 5).run();


Internally, this method creates a ChangeSet and invokes Dataflow.pulse. See vega-dataflow for more.\nA View instantiates a Vega dataflow graph and provides a component for visualization rendering and interaction. When initialized with a container DOM element, the View adds a Canvas or SVG-based visualization to a web page. Alternatively, a View can be used either client-side or server-side to export static SVG or PNG (Canvas) images.\nDataflow and Rendering\nDataflow and Rendering\nMethods for constructing and deconstructing views. In addition to the methods described below, View instances also inherit all (non-overridden) methods of the Dataflow parent class.\n#
vega.View(runtime[, options])
<>\nConstructor that creates a new View instance for the provided Vega dataflow runtime specification. If provided, the options argument should be an object with one or more of the following properties:\nVega dataflow runtime specification\nbackground: View background color. See the background method.\nbind: DOM container element (or CSS selector) for input elements bound to signals. See the initialize method.\ncontainer: Parent DOM container element (or unique CSS selector) for this view. See the initialize method.\nhover: Boolean flag indicating if hover processing should be enabled. See the hover method.\nloader: Default loader instance to use for data files and images.\nlogLevel: Initial log level to use. See the logLevel method.\nlogger: Initial logger to use. See the logger method.\nrenderer: The type of renderer to use ('canvas' or 'svg'). See the renderer method.\ntooltip: Handler function invoked to support tooltip display. See the tooltip method.\nlocale: Locale definitions for string parsing and formatting of number and date values. The locale object should contain number and/or time properties with locale definitions. If unspecified, the current default locale at the time of instantiation will be used for the View instance. ≥ 5.12\nexpr: Alternate evaluator for Vega expressions. See the interpreter usage documentation. ≥ 5.13\nwatchPixelRatio: Boolean flag allowing an event listener to trigger a re-render when the pixel ratio of the page changes (such as via zooming or changing monitors).\nThe View constructor call is typically followed by a chain of method calls to setup the desired view configuration. After this chain, the runAsync method evaluates the underlying dataflow graph to update and render the visualization.\nvar view = new vega.View(runtime)
  .logLevel(vega.Warn) // set view logging level
  .renderer('svg')     // set render type (defaults to 'canvas')
  .initialize('#view') // set parent DOM element
  .hover();            // enable hover event processing, *only call once*!

view.runAsync(); // evaluate and render the view\nvar view = new vega.View(runtime)
  .logLevel(vega.Warn) // set view logging level
  .renderer('svg')     // set render type (defaults to 'canvas')
  .initialize('#view') // set parent DOM element
  .hover();            // enable hover event processing, *only call once*!

view.runAsync(); // evaluate and render the view\n// set view logging level\n// set render type (defaults to 'canvas')\n// set parent DOM element\n// enable hover event processing, *only call once*!\n// evaluate and render the view\nAlternatively, using View constructor options:\nvar view = new vega.View(runtime, {
    logLevel:  vega.Warn, // view logging level
    renderer:  'svg',     // render type (defaults to 'canvas')
    container: '#view',   // parent DOM element
    hover:     true       // enable hover event processing
  });

view.runAsync(); // evaluate and render the view\nvar view = new vega.View(runtime, {
    logLevel:  vega.Warn, // view logging level
    renderer:  'svg',     // render type (defaults to 'canvas')
    container: '#view',   // parent DOM element
    hover:     true       // enable hover event processing
  });

view.runAsync(); // evaluate and render the view\n// view logging level\n// render type (defaults to 'canvas')\n// parent DOM element\n// enable hover event processing\n// evaluate and render the view\nOr, if used within an async function:\nvar view = await new vega.View(runtime, {
    logLevel:  vega.Warn, // view logging level
    renderer:  'svg',     // render type (defaults to 'canvas')
    container: '#view',   // parent DOM element
    hover:     true       // enable hover event processing
  }).runAsync();          // evaluate and render the view\nvar view = await new vega.View(runtime, {
    logLevel:  vega.Warn, // view logging level
    renderer:  'svg',     // render type (defaults to 'canvas')
    container: '#view',   // parent DOM element
    hover:     true       // enable hover event processing
  }).runAsync();          // evaluate and render the view\n// view logging level\n// render type (defaults to 'canvas')\n// parent DOM element\n// enable hover event processing\n// evaluate and render the view\nPrepares the view to be removed. To prevent unwanted behaviors and memory leaks, this method unregisters any timers and removes any event listeners that have been registered on the View or that the visualization has registered on external DOM elements. Applications should invoke this method when a View instance is no longer needed.\nMethods for configuring the view state. These methods are often (but not always) invoked immediately after the View constructor, prior to the first invocation of the runAsync or run methods.\n#
view.initialize([container, bindContainer])
<>\nInitializes internal rendering and event handling, then returns this view instance. If the DOM element container is provided, visualization elements (such as Canvas or SVG HTML elements) will be added to the web page under this containing element. If container is not provided, the view will operate in headless mode, and can still generate static visualization images using the image export methods. The optional DOM element (or unique CSS selector) bindContainer indicates the element that should contain any input elements bound to signals; if not specified the same container element as the visualization will be used.\n#
view.loader([loader])
<>\nGet or set the loader instance to use for data files and images. If the loader is updated after initialize has been invoked, the visualization will be reinitialized. If a Vega View loads data from an external URL, the load request is made immediately upon view construction. To ensure a custom loader is used, provide the loader as a constructor option! Invoking this method will update the loader only after initial data requests have been made. This method will reset the renderer; invoke runAsync after calling this method to ensure the view is redrawn.\n#
view.logLevel(level)
<>\nSets the current log level and returns this view instance. This method controls which types of log messages are printed to the JavaScript console, and is inherited from the Dataflow parent class. The valid level values are vega.None (the default), vega.Warn, vega.Info, vega.Debug. See the logger method in vega-util for more.\n#
view.logger(logger)
<>\nGet or set the logger instance used to log messages. If no arguments are provided, returns the current logger instance. Otherwise, sets the logger and return this View instance. Provided loggers must support the full API of logger objects generated by the vega-util logger method. Note that by default the log level of the new logger will be used; use the logLevel method to adjust the log level as needed.\nWhen providing a custom logger instance, be aware that all logger methods will be invoked with the View as the function this context. This allows loggers to query additional View state (such as the current pulse timestamp) if desired. Custom loggers that reference their own internal state should avoid using this, unless those methods are defined using arrow function expressions.\nfunction this context\narrow function expressions\n#
view.renderer(type)
<>\nSets the renderer type (e.g., 'canvas' (the default) or 'svg') and returns this view instance. While typically invoked immediately upon view creation, this method can be called at any time to change the renderer. Invoke runAsync after calling this method to ensure the view is redrawn.\nAdditional renderer types may be used if registered via the renderModule method exported by vega-scenegraph; for an example see the vega-webgl-renderer.\n#
view.tooltip(tooltipHandler)
<>\nGet or set the tooltip handler function, which is invoked to handle display of tooltips (for example, when users hover the mouse cursor over an item). This method will reset the renderer; invoke runAsync after calling this method to ensure the view is redrawn. The tooltipHandler argument should be a function that respects the following method signature:\nfunction(handler, event, item, value) {
  // perform custom tooltip presentation
}\nfunction(handler, event, item, value) {
  // perform custom tooltip presentation
}\n// perform custom tooltip presentation\nThe tooltipHandler function arguments are:\nhandler - The scenegraph input Handler instance that invoked the tooltipHandler function.\nevent - The event that caused an update to the tooltip display.\nitem - The scenegraph item corresponding to the tooltip.\nvalue - The tooltip value to display. If null or undefined, indicates that no tooltip should be shown. The tooltip value may have an arbitrary type, including Object and Array values. It is up the tooltipHandler to appropriately interpret and display this value.\nIn addition, Vega invokes the tooltipHandler using the current View as the this context for the function.\nThe default handler uses built-in browser support to show tooltips. It takes a value to show in a tooltip, transforms it to a string value, and sets the HTML "title" attribute on the element containing the View. The default handler will coerce literal values to strings, and will show the contents of Object or Array values (up to one level of depth). For Object values, each key-value pair is displayed on its own line of text ("key1: value\nkey2: value2").\n#
view.hover([hoverSet, updateSet])
<>\nEnables hover event processing and returns this view instance. The optional arguments specify which named encoding sets to invoke upon mouseover and mouseout. The hoverSet defaults to 'hover', corresponding to the "hover" set within a Vega mark specification "encode" block. The updateSet defaults to 'update', corresponding to the "update" set within a Vega mark specification "encode" block. If this method is never invoked, the view will not automatically handle hover events. Instead, the underlying dataflow definition will have to explicitly set up event streams for handling mouseover and mouseout events.\nThis method should be invoked only once, upon view initialization. Calling this method multiple times will add redundant event listeners to the view. In other words, this method is not idempotent.\n#
view.description([text])
<> ≥ 5.10\nGets or sets descriptive text for this view. This description determines the aria-label attribute for the view’s container element. If no arguments are provided, returns the current description. If text is specified, this method sets the description and updates the view container element.\n#
view.background([color])
<>\nGets or sets the view background color. If no arguments are provided, returns the current background color. If color is specified, this method sets the background color (overriding any background color defined in the input Vega specification) and returns this view instance. This method does not force an immediate update to the view: invoke the runAsync method when ready. This method is equivalent to view.signal('background'[, color]).\n#
view.width([width])
<>\nGets or sets the view width, in pixels. If no arguments are provided, returns the current width value. If width is specified, this method sets the width and returns this view instance. This method does not force an immediate update to the view: invoke the runAsync method when ready. This method is equivalent to view.signal('width'[, width]).\n#
view.height([height])
<>\nGets or sets the view height, in pixels. If no arguments are provided, returns the current height value. If height is specified, this method sets the height and returns this view instance. This method does not force an immediate update to the view: invoke the runAsync method when ready. This method is equivalent to view.signal('height'[, height]).\n#
view.padding([padding])
<>\nGets or sets the view padding, in pixels. Input padding objects take the form {left: 5, top: 5, right: 5, bottom: 5}; if a numeric padding value is provided, it will be expanded to an object with all properties set to that number. If no arguments are provided, returns the current padding value. If padding is specified, this method sets the padding and returns this view instance. This method does not force an immediate update to the view: invoke the runAsync method when ready. This method is equivalent to view.signal('padding'[, padding]).\nSets a flag indicating that layout autosize calculations should be re-run on the next pulse propagation cycle. If an autosize method of "pad" or "fit" is being used, calling this method will cause the chart bounds layout to be recomputed the next time the runAsync method is invoked.\nDataflow and Rendering\nMethods for invoking dataflow evaluation and view rendering.\n#
view.runAsync([encode, prerun, postrun])
<>\nEvaluates the underlying dataflow graph and returns a Promise that resolves upon completion of dataflow processing and scenegraph rendering. The optional encode argument is a String value indicating the name of a custom "encode" set to run in addition to the standard "update" encoder. Any scenegraph elements modified during dataflow evaluation will automatically be re-rendered in the view.\nInternally, this method invokes evaluation by the Dataflow parent class, and then additionally performs rendering. The returned Promise will resolve after rendering operations are complete. This method should not be invoked repeatedly until a prior call resolves: callers should await the result of runAsync (or use .then(...) chaining) before re-invoking the method.\nThe optional prerun and postrun functions are callbacks that will be invoked immediately before and after dataflow evaluation and rendering. The callback functions are called with this view instance as the sole argument. The callbacks may be async functions. If provided, postrun will be invoked after any callbacks registered via the runAfter method.\nMost clients should not use the prerun and postrun callback arguments. The callbacks are provided to support internal Vega operations. To perform post-processing after dataflow evaluation, in most cases clients should invoke then or await the Promise returned by runAsync.\nIn the presence of streaming data, it might be helpful to invoke resize before executing runAsync (see Streaming Data).\n#
view.run([encode, prerun, postrun])
<>\nRequests asynchronous view evaluation and then synchronously returns this view instance without waiting for evaluation to complete. The arguments are identical to those for runAsync.\nThis method will return prior to completion of dataflow evaluation. To perform actions after dataflow evaluation is finished, instead use runAsync and invoke then or await on the returned Promise.\n#
view.runAfter(callback)
<>\nSchedules a callback function to be invoked after the current dataflow evaluation completes. The callback function will be called with this view instance as the sole argument. The callback may be an async function.\nIf dataflow evaluation is not currently occurring, the callback function is invoked immediately. This method is used internally to schedule follow-up operations within the dataflow runtime engine. Most clients should not use this method; instead call runAsync and perform follow-up operations when the returned Promise resolves.\n#
view.dirty(item)
<>\nReports a “dirty” scenegraph item to be re-drawn the next time dataflow evaluation completes. This method is typically invoked by dataflow operators directly to populate a dirty list for incremental rendering.\n#
view.container()
<>\nReturns the DOM container element for this view, if it exists.\n#
view.scenegraph()
<>\nReturns the Vega scenegraph instance for this view.\nReturns the [x, y] origin coordinates for the current view. The origin coordinates indicate the translation of the view’s primary coordinate system, encompassing the left and top padding values as well as any additional padding due to autosize calculations.\nMethods for accessing and updating dataflow signal values.\n#
view.signal(name[, value])
<>\nGets or sets a dataflow signal. If only the name argument is provided, returns the requested signal value. If value is also specified, updates the signal and returns this view instance. If the signal does not exist, an error will be raised. This method does not force an immediate update to the view: invoke the runAsync method when ready.\n#
view.getState([options])
<>\nGets the state of signals and data sets in this view’s backing dataflow graph. If no arguments are specified, returns an object containing both signal values and any modified data sets for this view. By default, the exported state includes all signal values (across all mark contexts) except for those bound to data pipeline transforms, and any data sets that were explicitly modified via triggers or the View API.\nAn options argument can be provided to control what internal state is collected. However, the options involve interacting with internal details of a Vega runtime dataflow and is intended for expert use only. The default options should suffice for state capture in most instances.\nThe options object supports the following properties:\nsignals: A predicate function that accepts a signal name and operator and returns true to export the operator state.\ndata: A predicate function that accepts a dataset name and dataset object and returns true to export the data.\nrecurse: A boolean flag indicating if the state export process should recurse into mark sub-contexts.\n#
view.setState(state)
<>\nSets the state of signals and/or datasets in this view’s backing dataflow graph. The state argument should be an object generated by the getState method. This method updates all implicated signals and data sets, invokes the run method, and returns this view instance.\n#
view.addSignalListener(name, handler)
<>\nRegisters a listener for changes to the signal with the given name and returns this view instance. If the signal does not exist, an error will be raised. This method is idempotent: adding the same handler for the same signal multiple times has no effect beyond the first call.\nWhen the signal value changes, the handler function is invoked with two arguments: the name of the signal and the new signal value. Listeners will be invoked when the signal value changes during pulse propagation (e.g., after runAsync is called, but before its returned Promise resolves).\nSignal listeners are invoked immediately upon signal update, in the midst of dataflow evaluation. As a result, other signal updates and data transforms may have yet to update. If you wish to access the values of other signals, or update signal values and re-run the dataflow, use the runAsync method with a prerun callback that performs the desired actions after the current dataflow evaluation completes, but before the requested re-run begins. Attempting to call the synchronous run method from within a signal listener will result in an error, as recursive invocation is not allowed.\nTo remove a listener, use the removeSignalListener method.\nview.addSignalListener('width', function(name, value) {
  console.log('WIDTH: ' + value);
});
view.width(500).run(); // listener logs 'WIDTH: 500'\nview.addSignalListener('width', function(name, value) {
  console.log('WIDTH: ' + value);
});
view.width(500).run(); // listener logs 'WIDTH: 500'\n// listener logs 'WIDTH: 500'\n#
view.removeSignalListener(name, handler)
<>\nRemoves a signal listener registered with the addSignalListener method and returns this view instance. If the signal does not exist, an error will be raised. If the signal exists but the provided handler is not registered, this method has no effect.\nMethods for generating new event streams, registering event listeners, and handling tooltips. See also the hover method.\n#
view.events(source, type[, filter])
<>\nReturns a new EventStream for a specified source, event type, and optional filter function. The source should be one of "view" (to specify the current view), "window" (to specify the browser window object), or a valid CSS selector string (that will be passed to document.querySelectorAll). The event type should be a legal DOM event type. If provided, the optional filter argument should be a function that takes an event object as input and returns true if it should be included in the produced event stream.\nTypically this method is invoked internally to create event streams referenced within Vega signal definitions. However, callers can use this method to create custom event streams if desired. This method assumes that the view is running in a browser environment, otherwise invoking this method may have no effect.\n#
view.addEventListener(type, handler[, options])
<>\nRegisters an event listener for input events and returns this view instance. The event type should be a string indicating a legal DOM event type supported by vega-scenegraph event handlers. Examples include "mouseover", "click", "keydown" and "touchstart". This method is idempotent: adding the same handler for the same event type multiple times has no effect beyond the first call.\nThe optional options hash accepts one parameter (options.trap): if options.trap is set to false, automatic error trapping for event handler functions is disabled.\nWhen events occur, the handler function is invoked with two arguments: the event instance and the currently active scenegraph item (which is null if the event target is the view component itself).\nAll registered event handlers are preserved upon changes of renderer. For example, if the View renderer type is changed from "canvas" to "svg", all listeners will remain active. To remove a listener, use the removeEventListener method.\nview.addEventListener('click', function(event, item) {
  console.log('CLICK', event, item);
});\nview.addEventListener('click', function(event, item) {
  console.log('CLICK', event, item);
});\n#
view.removeEventListener(type, handler)
<>\nRemoves an event listener registered with the addEventListener method and returns this view instance.\n#
view.addResizeListener(handler)
<>\nRegisters a listener for changes to the view size and returns this view instance. This method is idempotent: adding the same handler multiple times has no effect beyond the first call.\nWhen the view size changes, the handler function is invoked with two arguments: the width and height of the view.\nview.addResizeListener(function(width, height) {
  console.log('RESIZE', width, height);
});\nview.addResizeListener(function(width, height) {
  console.log('RESIZE', width, height);
});\n#
view.removeResizeListener(handler)
<>\nRemoves a listener registered with the addResizeListener method and returns this view instance.\n#
view.globalCursor(flag)
<> ≥ 5.13\nGets or sets a boolean flag (default false) value indicating if Vega should adjust the cursor for the current document body (true) or within the Vega View component only (false). Values set via this method will override the cursor configuration provided by a Vega specification.\n#
view.preventDefault(flag)
<>\nGets or sets a boolean flag value (default false) indicating if Vega should call preventDefault() on input events by default. This method specifies the default behavior only, and is overridden by input event configuration provided to the specification or parser.\nMethods for exporting static visualization images. These methods can be invoked either client-side or server-side.\n#
view.toCanvas([scaleFactor, options])
<>\nReturns a Promise that resolves to a canvas instance containing a rendered bitmap image of the view. The optional scaleFactor argument (default 1) is a number by which to multiply the view width and height when determining the output image size. If invoked in a browser, the returned Promise resolves to an HTML5 canvas element. If invoked server-side in node.js, the Promise resolves to a node-canvas Canvas instance.\nThe optional options object provides additional parameters for the canvas:\ntype: Type string passed to the node-canvas Canvas constructor (for example, to specify 'pdf' output). This property will be ignored if used in the browser.\nnode-canvas Canvas constructor\ncontext: An object of key-value pairs to assign to the Canvas 2D context object. Useful for setting context parameters, particularly for node-canvas.\nexternalContext: An external Context2D instance to render into. If an external canvas is provided, the Promise returned by toCanvas will resolve to null. As Vega makes changes to the rendering context state, callers should invoke context.save() prior to toCanvas(), and invoke context.restore() to restore the state after the returned Promise resolves. ≥ 5.12\n#
view.toSVG([scaleFactor])
<>\nReturns a Promise that resolves to an SVG string, providing a vector graphics image of the view. The optional scaleFactor argument (default 1) is a number by which to multiply the view width and height when determining the output image size.\n#
view.toImageURL(type[, scaleFactor])
<>\nReturns a Promise that resolves to an image URL for a snapshot of the current view. The type argument must be one of 'svg', 'png' or 'canvas'. Both the png and canvas types result in a PNG image. The generated URL can be used to create downloadable visualization images. The optional scaleFactor argument (default 1) is a number by which to multiply the view width and height when determining the output image size.\n// generate a PNG snapshot and then download the image
view.toImageURL('png').then(function(url) {
  var link = document.createElement('a');
  link.setAttribute('href', url);
  link.setAttribute('target', '_blank');
  link.setAttribute('download', 'vega-export.png');
  link.dispatchEvent(new MouseEvent('click'));
}).catch(function(error) { /* error handling */ });\n// generate a PNG snapshot and then download the image
view.toImageURL('png').then(function(url) {
  var link = document.createElement('a');
  link.setAttribute('href', url);
  link.setAttribute('target', '_blank');
  link.setAttribute('download', 'vega-export.png');
  link.dispatchEvent(new MouseEvent('click'));
}).catch(function(error) { /* error handling */ });\n// generate a PNG snapshot and then download the image\nMethods for accessing scales or data sets, and performing streaming updates.\n#
view.scale(name)
<>\nReturns the scale or
projection instance with the given name. The return value is a live instance used by the underlying dataflow. Callers should take care not to modify the returned instance!\n#
view.data(name[, values])
<>\nIf only one argument is provided, returns the data set with the given name. The returned array of data objects is a live array used by the underlying dataflow. Callers that wish to modify the returned array should first make a defensive copy, for example using view.data('name').slice().\n≥ 5.5 If two arguments are provided, removes the current data and inserts the input values, which can be either a single data object or an array of data objects. This call is equivalent to:\nview.change(vega.changeset().remove(vega.truthy).insert(values));\nview.change(vega.changeset().remove(vega.truthy).insert(values));\nData updates do not force an immediate update to the view: invoke the runAsync method when ready. Note also that a single argument (getter) call returns the output of the data transform pipeline, whereas the two argument (setter) call sets the input to the transform pipeline.\n#
view.addDataListener(name, handler)
<>\nRegisters a listener for changes to a named data set with the given name and returns this view instance. If the data set does not exist, an error will be raised. This method is idempotent: adding the same handler for the same data set multiple times has no effect beyond the first call.\nWhen the data set value changes, the handler function is invoked with two arguments: the name of the signal and the new data set value. Listeners will be invoked when the data set value changes during pulse propagation (e.g., after runAsync is called, but before its returned Promise resolves). The value passed to the handler is the same as that returned by the view.data method. The returned array of data objects is a live array used by the underlying dataflow. Listeners that wish to modify the returned array should first make a defensive copy, for example using value.slice().\nData listeners are invoked immediately upon data set update, in the midst of dataflow evaluation. As a result, other signal values and data transforms may have yet to update. If you wish to access the values of other signals, or update signal values and re-run the dataflow, use the runAsync method with a prerun callback that performs the desired actions after the current dataflow evaluation completes, but before the requested re-run begins. Attempting to call the synchronous run method from within a signal listener will result in an error, as recursive invocation is not allowed.\nTo remove a listener, use the removeDataListener method.\nview.addDataListener('source', function(name, value) {
  console.log(name, value);
});\nview.addDataListener('source', function(name, value) {
  console.log(name, value);
});\n#
view.removeDataListener(name, handler)
<>\nRemoves a data set listener registered with the addDataListener method and returns this view instance. If the data set does not exist, an error will be raised. If the data set exists but the provided handler is not registered, this method has no effect.\n#
view.change(name, changeset)
<>\nUpdates the data set with the given name with the changes specified by the provided changeset instance. This method does not force an immediate update to the view: invoke the runAsync method when ready. To issue a series of changes, insertions, or deletions, be sure to await the results of runAsync before issuing the next change.\nview.change('data', vega.changeset().insert([...]).remove([...]))
    .run()\nview.change('data', vega.changeset().insert([...]).remove([...]))
    .run()\nThe insert and remove methods of the changeset accept a single argument. The supported inputs are identical to the second arguments accepted by the view.insert and view.remove methods.\nInserted data tuples must be JavaScript objects that have been properly parsed ahead of time. Any data source "format" directives in a Vega JSON specification will not be applied to tuples added through the View API. Internally, this method takes the provided ChangeSet and invokes Dataflow.pulse. See vega-dataflow for more.\nFor versions ≥ 5.13 a changeset also supports an optional clean setter that accepts a boolean and indicates if internal garbage collection should be performed by Vega in response to the change (this defaults to true if the changeset specifies data should be removed).\n#
view.insert(name, tuples)
<>\nInserts an array of new data tuples into the data set with the given name, then returns this view instance. The input tuples array should contain one or more data objects that are not already included in the data set. This method does not force an immediate update to the view: invoke the runAsync method when ready.\nInsert can not be used in combination with the remove method on the same pulse; to simultaneously add and remove data use the change method. To issue a series of changes, insertions, or deletions, be sure to await the results of runAsync before issuing the next change.\nInserted data tuples must be JavaScript objects that have been properly parsed ahead of time. Any data source "format" directives in a Vega JSON specification will not be applied to tuples added through the View API. Internally, this method creates a ChangeSet and invokes Dataflow.pulse. See vega-dataflow for more.\n#
view.remove(name, tuples)
<>\nRemoves data tuples from the data set with the given name, then returns this view instance. The tuples argument can either be an array of tuples already included in the data set, or a predicate function indicating which tuples should be removed. This method does not force an immediate update to the view: invoke the runAsync method when ready.\nRemove can not be used in combination with the insert method on the same pulse; to simultaneously add and remove data use the change method. To issue a series of changes, insertions, or deletions, be sure to await the results of runAsync before issuing the next change.\nFor example, to remove all tuples in the 'table' data set with a count property less than five:\nview.remove('table', d => d.count < 5).run();\nview.remove('table', d => d.count < 5).run();\nInternally, this method creates a ChangeSet and invokes Dataflow.pulse. See vega-dataflow for more.\n\n\nVega
            
              Vega-Lite
              Altair
              Vega-Lite API
            
          
          
            
              Examples
              Tutorials
              Documentation
              Usage
              About
            
            
              GitHub
              Try Online
            
          
        
      

      
        

  
  
    
      
      
        Documentation
      
      
      
      
        Parser
      
      
      
      
        View
      
      
      
      
        Locale
      
      
      
      
        Extensibility
      
      
      
      
        Statistics
      
      
      
      
        Time
      
      
      
      
        Util
      
      
      
      
        Debugging
      
      
    
  
  
    Locale API
    To display number and date values, by default Vega uses formatting rules for American English. If you are deploying visualizations for other languages you will want to change these defaults. Vega uses the formatting utilities provided by the D3 framework, specifically the d3-format and d3-time-format libraries.

Vega supports changing the default locale for all visualizations using the methods below. To set the locale for a specific view, either provide a locale config or use the View constructor locale option.

Note: If changing the default locale, application code should set the locale to the desired value before performing parsing and view generation.

Locale Configuration

#
vega.formatLocale([definition])
<>

Get or set the default locale for number formatting. If no arguments are provided, returns the current default locale. Otherwise, sets the default locale based on the provided definition, and returns the resulting locale object. The definition argument must match the format expected by d3-format. For examples of definition files for a variety of languages, see the d3-format locale collection. To set the number and time locales simultaneously, use the defaultLocale method.

#
vega.timeFormatLocale([definition])
<>

Get or set the default locale for time formatting. If no arguments are provided, returns the current default locale. Otherwise, sets the default locale based on the provided definition, and returns the resulting locale object. The definition argument must match the format expected by d3-time-format. For examples of definition files for a variety of languages, see the d3-time-format locale collection. To set the number and time locales simultaneously, use the defaultLocale method.

Combined Locale ≥ 5.12

Combined locale objects provide a convenient abstraction for both number and time formatting methods defined on a single object. A combined locale object contains the methods of both a number format locale object and a time format locale object.

#
vega.locale(numberDefinition, timeDefinition)
<>

Returns a combined locale object with methods for both number and time formatting, based on the provided numberDefinition and timeDefinition. The definition arguments must match the format expected by d3-format and d3-time-format. If either argument is null or unspecified, the current default locale is used instead. For examples of definition files for a variety of languages, see the d3-format locale collection and d3-time-format locale collection.

For example, to create a locale for number and time formatting in German:

const deDE = vega.locale(
  {
    decimal: ',',
    thousands: '.',
    grouping: [3],
    currency: ['', '\u00a0€']
  },
  {
    dateTime: '%A, der %e. %B %Y, %X',
    date: '%d.%m.%Y',
    time: '%H:%M:%S',
    periods: ['AM', 'PM'],
    days: [
      'Sonntag', 'Montag', 'Dienstag', 'Mittwoch',
      'Donnerstag', 'Freitag', 'Samstag'
    ],
    shortDays: ['So', 'Mo', 'Di', 'Mi', 'Do', 'Fr', 'Sa'],
    months: [
      'Januar', 'Februar', 'März',
      'April', 'Mai', 'Juni',
      'Juli', 'August', 'September',
      'Oktober', 'November', 'Dezember'
    ],
    shortMonths: [
      'Jan', 'Feb', 'Mrz', 'Apr', 'Mai', 'Jun',
      'Jul', 'Aug', 'Sep', 'Okt', 'Nov', 'Dez'
    ]
  }
);


#
vega.defaultLocale([numberDefinition, timeDefinition])
<>

Get or set the default locale for both number and time formatting. If no arguments are provided, returns the current default locale. Otherwise, sets the default locales based on the provided numberDefinition and timeDefinition, and returns the resulting combined locale object. The input definitions should be of the same type accepted by the locale method.

#
vega.resetDefaultLocale()
<>

Resets the default locale for both number and time formatting and returns the resulting comgined locale object. The new default locales for Vega will match the current default locales for the underlying d3-format and d3-time-format libraries.\nVega
            
              Vega-Lite
              Altair
              Vega-Lite API\nVega-Lite
              Altair
              Vega-Lite API\nExamples
              Tutorials
              Documentation
              Usage
              About
            
            
              GitHub
              Try Online\nExamples
              Tutorials
              Documentation
              Usage
              About\nGitHub
              Try Online\nDocumentation
      
      
      
      
        Parser
      
      
      
      
        View
      
      
      
      
        Locale
      
      
      
      
        Extensibility
      
      
      
      
        Statistics
      
      
      
      
        Time
      
      
      
      
        Util
      
      
      
      
        Debugging
      
      
    
  
  
    Locale API
    To display number and date values, by default Vega uses formatting rules for American English. If you are deploying visualizations for other languages you will want to change these defaults. Vega uses the formatting utilities provided by the D3 framework, specifically the d3-format and d3-time-format libraries.

Vega supports changing the default locale for all visualizations using the methods below. To set the locale for a specific view, either provide a locale config or use the View constructor locale option.

Note: If changing the default locale, application code should set the locale to the desired value before performing parsing and view generation.

Locale Configuration

#
vega.formatLocale([definition])
<>

Get or set the default locale for number formatting. If no arguments are provided, returns the current default locale. Otherwise, sets the default locale based on the provided definition, and returns the resulting locale object. The definition argument must match the format expected by d3-format. For examples of definition files for a variety of languages, see the d3-format locale collection. To set the number and time locales simultaneously, use the defaultLocale method.

#
vega.timeFormatLocale([definition])
<>

Get or set the default locale for time formatting. If no arguments are provided, returns the current default locale. Otherwise, sets the default locale based on the provided definition, and returns the resulting locale object. The definition argument must match the format expected by d3-time-format. For examples of definition files for a variety of languages, see the d3-time-format locale collection. To set the number and time locales simultaneously, use the defaultLocale method.

Combined Locale ≥ 5.12

Combined locale objects provide a convenient abstraction for both number and time formatting methods defined on a single object. A combined locale object contains the methods of both a number format locale object and a time format locale object.

#
vega.locale(numberDefinition, timeDefinition)
<>

Returns a combined locale object with methods for both number and time formatting, based on the provided numberDefinition and timeDefinition. The definition arguments must match the format expected by d3-format and d3-time-format. If either argument is null or unspecified, the current default locale is used instead. For examples of definition files for a variety of languages, see the d3-format locale collection and d3-time-format locale collection.

For example, to create a locale for number and time formatting in German:

const deDE = vega.locale(
  {
    decimal: ',',
    thousands: '.',
    grouping: [3],
    currency: ['', '\u00a0€']
  },
  {
    dateTime: '%A, der %e. %B %Y, %X',
    date: '%d.%m.%Y',
    time: '%H:%M:%S',
    periods: ['AM', 'PM'],
    days: [
      'Sonntag', 'Montag', 'Dienstag', 'Mittwoch',
      'Donnerstag', 'Freitag', 'Samstag'
    ],
    shortDays: ['So', 'Mo', 'Di', 'Mi', 'Do', 'Fr', 'Sa'],
    months: [
      'Januar', 'Februar', 'März',
      'April', 'Mai', 'Juni',
      'Juli', 'August', 'September',
      'Oktober', 'November', 'Dezember'
    ],
    shortMonths: [
      'Jan', 'Feb', 'Mrz', 'Apr', 'Mai', 'Jun',
      'Jul', 'Aug', 'Sep', 'Okt', 'Nov', 'Dez'
    ]
  }
);


#
vega.defaultLocale([numberDefinition, timeDefinition])
<>

Get or set the default locale for both number and time formatting. If no arguments are provided, returns the current default locale. Otherwise, sets the default locales based on the provided numberDefinition and timeDefinition, and returns the resulting combined locale object. The input definitions should be of the same type accepted by the locale method.

#
vega.resetDefaultLocale()
<>

Resets the default locale for both number and time formatting and returns the resulting comgined locale object. The new default locales for Vega will match the current default locales for the underlying d3-format and d3-time-format libraries.\nTo display number and date values, by default Vega uses formatting rules for American English. If you are deploying visualizations for other languages you will want to change these defaults. Vega uses the formatting utilities provided by the D3 framework, specifically the d3-format and d3-time-format libraries.\nVega supports changing the default locale for all visualizations using the methods below. To set the locale for a specific view, either provide a locale config or use the View constructor locale option.\nView constructor locale option\nNote: If changing the default locale, application code should set the locale to the desired value before performing parsing and view generation.\n#
vega.formatLocale([definition])
<>\nGet or set the default locale for number formatting. If no arguments are provided, returns the current default locale. Otherwise, sets the default locale based on the provided definition, and returns the resulting locale object. The definition argument must match the format expected by d3-format. For examples of definition files for a variety of languages, see the d3-format locale collection. To set the number and time locales simultaneously, use the defaultLocale method.\nd3-format locale collection\n#
vega.timeFormatLocale([definition])
<>\nGet or set the default locale for time formatting. If no arguments are provided, returns the current default locale. Otherwise, sets the default locale based on the provided definition, and returns the resulting locale object. The definition argument must match the format expected by d3-time-format. For examples of definition files for a variety of languages, see the d3-time-format locale collection. To set the number and time locales simultaneously, use the defaultLocale method.\nd3-time-format locale collection\nCombined Locale ≥ 5.12\nCombined locale objects provide a convenient abstraction for both number and time formatting methods defined on a single object. A combined locale object contains the methods of both a number format locale object and a time format locale object.\n#
vega.locale(numberDefinition, timeDefinition)
<>\nReturns a combined locale object with methods for both number and time formatting, based on the provided numberDefinition and timeDefinition. The definition arguments must match the format expected by d3-format and d3-time-format. If either argument is null or unspecified, the current default locale is used instead. For examples of definition files for a variety of languages, see the d3-format locale collection and d3-time-format locale collection.\nd3-format locale collection\nd3-time-format locale collection\nFor example, to create a locale for number and time formatting in German:\nconst deDE = vega.locale(
  {
    decimal: ',',
    thousands: '.',
    grouping: [3],
    currency: ['', '\u00a0€']
  },
  {
    dateTime: '%A, der %e. %B %Y, %X',
    date: '%d.%m.%Y',
    time: '%H:%M:%S',
    periods: ['AM', 'PM'],
    days: [
      'Sonntag', 'Montag', 'Dienstag', 'Mittwoch',
      'Donnerstag', 'Freitag', 'Samstag'
    ],
    shortDays: ['So', 'Mo', 'Di', 'Mi', 'Do', 'Fr', 'Sa'],
    months: [
      'Januar', 'Februar', 'März',
      'April', 'Mai', 'Juni',
      'Juli', 'August', 'September',
      'Oktober', 'November', 'Dezember'
    ],
    shortMonths: [
      'Jan', 'Feb', 'Mrz', 'Apr', 'Mai', 'Jun',
      'Jul', 'Aug', 'Sep', 'Okt', 'Nov', 'Dez'
    ]
  }
);\nconst deDE = vega.locale(
  {
    decimal: ',',
    thousands: '.',
    grouping: [3],
    currency: ['', '\u00a0€']
  },
  {
    dateTime: '%A, der %e. %B %Y, %X',
    date: '%d.%m.%Y',
    time: '%H:%M:%S',
    periods: ['AM', 'PM'],
    days: [
      'Sonntag', 'Montag', 'Dienstag', 'Mittwoch',
      'Donnerstag', 'Freitag', 'Samstag'
    ],
    shortDays: ['So', 'Mo', 'Di', 'Mi', 'Do', 'Fr', 'Sa'],
    months: [
      'Januar', 'Februar', 'März',
      'April', 'Mai', 'Juni',
      'Juli', 'August', 'September',
      'Oktober', 'November', 'Dezember'
    ],
    shortMonths: [
      'Jan', 'Feb', 'Mrz', 'Apr', 'Mai', 'Jun',
      'Jul', 'Aug', 'Sep', 'Okt', 'Nov', 'Dez'
    ]
  }
);\n%A, der %e. %B %Y, %X\n#
vega.defaultLocale([numberDefinition, timeDefinition])
<>\nGet or set the default locale for both number and time formatting. If no arguments are provided, returns the current default locale. Otherwise, sets the default locales based on the provided numberDefinition and timeDefinition, and returns the resulting combined locale object. The input definitions should be of the same type accepted by the locale method.\n#
vega.resetDefaultLocale()
<>\nResets the default locale for both number and time formatting and returns the resulting comgined locale object. The new default locales for Vega will match the current default locales for the underlying d3-format and d3-time-format libraries.\n\n\nVega
            
              Vega-Lite
              Altair
              Vega-Lite API
            
          
          
            
              Examples
              Tutorials
              Documentation
              Usage
              About
            
            
              GitHub
              Try Online
            
          
        
      

      
        

  
  
    
      
      
        Documentation
      
      
      
      
        Parser
      
      
      
      
        View
      
      
      
      
        Locale
      
      
      
      
        Extensibility
      
      
      
      
        Statistics
      
      
      
      
        Time
      
      
      
      
        Util
      
      
      
      
        Debugging
      
      
    
  
  
    Extensibility API
    Vega can be extended at runtime with new scales, projections, color schemes, and data transforms. While sometimes useful for custom deployments, keep in mind that extending Vega with new components can result in Vega JSON specifications that others may not be able to use directly.

Extensibility API Reference


  Projections
  Scales
  Schemes
  Transforms
  Data Formats
  Expression Functions


Projections

#
vega.projection(type[, projection])
<>

Registry function for adding and accessing cartographic projections. The type argument is a String indicating the name of the projection type. If the projection argument is not specified, this method returns the matching projection constructor in the registry, or null if not found. If the projection argument is provided, it must be a projection constructor function to add to the registry under the given type name.

By default, Vega includes all cartographic projections described in the Vega Projections documentation. Projections created using the constructor returned by this method have an additional copy method that generates a new clone of a projection. Vega can be extended with additional projections, such as those found in the d3-geo-projection library. For example:

// d3-geo-projections must be imported and added to d3 object
// to register with Vega, provide a name and d3 projection function
vega.projection('winkel3', d3.geoWinkel3);

// Vega parser and runtime now support the 'winkel3' projection
var runtime = vega.parse({
  ...,
  "projections": [
    { "name": "proj", "type": "winkel3" }
  ],
  ...
});


Scales

#
vega.scale(type[, scale, metadata])
<>

Registry function for adding and accessing scale constructor functions. The type argument is a String indicating the name of the scale type. If the scale argument is not specified, this method returns the matching scale constructor in the registry, or null if not found. If the scale argument is provided, it must be a scale constructor function to add to the registry under the given type name.

The metadata argument provides additional information to guide appropriate use of scales within Vega. The metadata can be either a string or string array. The valid string values are:


  "continuous" - the scale is defined over a continuous-valued domain.
  "discrete" - the scale is defined over a discrete domain and range.
  "discretizing" - the scale discretizes a continuous domain to a discrete range.
  "interpolating" - the scale range is defined using a color interpolator.
  "log" - the scale performs a logarithmic transform of the continuous domain.
  "temporal" - the scale domain is defined over date-time values.


By default, the scale registry includes entries for all scale types provided by the d3-scale module. Scales created using the constructor returned by this method have an additional type property indicating the scale type. All scales supporting either an invert or invertExtent method are augmented with an additional invertRange function that returns an array of corresponding domain values for a given interval in the scale’s output range.

// linear scale
var linear = vega.scale('linear');
var scale = linear().domain([0, 10]).range([0, 100]);
scale.type; // 'linear'
scale.invertRange([0, 100]); // [0, 10]


var ordinal = vega.scale('ordinal');

// ordinal scale
var scale1 = ordinal().domain(['a', 'b', 'c']).range([0, 1, 2]);
scale1.type; // 'ordinal'

// ordinal scale with range set to the 'category20' color palette
var scale2 = ordinal().range(vega.scheme('category20'));


var seq = vega.scale('sequential');

// sequential scale, using the plasma color palette
var scale1 = seq().interpolator(vega.scheme('plasma'));
scale1.type; // 'sequential'


Color Schemes

#
vega.scheme(name[, scheme])
<>

Registry function for adding and accessing color schemes.  The name argument is a String indicating the name of the color scheme. Scheme names are not case sensitive, for example "blues" and "Blues" map to the same scheme. If the scheme argument is not specified, this method returns the matching scheme value in the registry, or undefined if not found. If the scheme argument is provided, it must be a valid array of color values or an interpolator function that maps the domain [0, 1] to color values.

By default, the scheme registry includes entries for all scheme types described in the Vega Color Schemes documentation.

Transforms

#
vega.transforms
<>

An object that maps transform names to transform constructors. To add a new transform to Vega, assign the transform to this object under the desired name.

In order to parse transform references within a Vega specification, the transform constructor must have a Definition property that provides the necessary metadata and parameter information. The vega-transforms package includes a collection of transforms demonstrating the syntax of definition objects.

Note that if a transform is added at runtime, any Vega JSON specifications using the new transform will fail JSON schema validation, as the new transform will not have been included in the default schema definition. To include new transforms within a custom JSON schema, developers can create a custom Vega build, adding new transforms to the vega-dataflow transforms export during the build process.

Data Formats

#
vega.formats(name[, format])
<>

Registry function for data format parsers. If invoked with two arguments, adds a new format parser with the provided name. Otherwise, returns an existing parser with the given name. The method signature of a format parser is:


  format(data, options)


A format parser that accepts two arguments, the input data to parse (e.g., a block of CSV text) and a set of format-specific options. The following data formats are registered by default:


  dsv: Delimiter-separated values format. Each line of text is a record,
with each field separated by a delimiter string. Accepts a delimiter option indicating the delimiter string used to separate field values.
  csv: Comma-separated values format. A dsv instance with a comma (,) delimiter.
  tsv: Tab-separated values format. A dsv instance with a tab (\t) delimiter.
  json: JavaScript Object Notation (JSON) format. Accepts a property option, indicating a sub-property of the parsed JSON to return; useful if a data array is nested within a larger object. Also accepts a copy option (default false), which will defensively copy a JSON Object that was passed to Vega directly, rather than parsed from a string.
  topojson: TopoJSON format for compressed encoding of geographic data. Requires either a feature option indicating the name of the geographic feature to extract (e.g., extracts individual paths for all countries), or a mesh option indicating a feature name for which a single mesh should be extracted (e.g., all country boundaries in a single path). Please see the TopoJSON documentation for more.


Expression Functions

#
vega.expressionFunction(name[, fn, visitor])
<>

Registry function for adding and accessing expression functions. The name argument is a String indicating the name of the function, as used within the Vega expression language. If the fn argument is not specified, this method returns the matching function value in the registry, or undefined if not found. If the fn argument is provided, it must be a valid JavaScript function to add to the registry under the given name. Once added, the parser will accept Vega specifications with expressions invoking this named function.

The visitor argument is an expression AST (abstract syntax tree) visitor function which can be used to perform dependency analysis (e.g., for scale or data source lookups), and is used internally by Vega. For most basic functions no visitor is needed, in which case this argument can be omitted.

Note that new expressions must be added before parsing a spec that uses the custom function. After registering a new expression function, all subsequently parsed Vega specifications will have access to the function.\nVega
            
              Vega-Lite
              Altair
              Vega-Lite API\nVega-Lite
              Altair
              Vega-Lite API\nExamples
              Tutorials
              Documentation
              Usage
              About
            
            
              GitHub
              Try Online\nExamples
              Tutorials
              Documentation
              Usage
              About\nGitHub
              Try Online\nDocumentation
      
      
      
      
        Parser
      
      
      
      
        View
      
      
      
      
        Locale
      
      
      
      
        Extensibility
      
      
      
      
        Statistics
      
      
      
      
        Time
      
      
      
      
        Util
      
      
      
      
        Debugging
      
      
    
  
  
    Extensibility API
    Vega can be extended at runtime with new scales, projections, color schemes, and data transforms. While sometimes useful for custom deployments, keep in mind that extending Vega with new components can result in Vega JSON specifications that others may not be able to use directly.

Extensibility API Reference


  Projections
  Scales
  Schemes
  Transforms
  Data Formats
  Expression Functions


Projections

#
vega.projection(type[, projection])
<>

Registry function for adding and accessing cartographic projections. The type argument is a String indicating the name of the projection type. If the projection argument is not specified, this method returns the matching projection constructor in the registry, or null if not found. If the projection argument is provided, it must be a projection constructor function to add to the registry under the given type name.

By default, Vega includes all cartographic projections described in the Vega Projections documentation. Projections created using the constructor returned by this method have an additional copy method that generates a new clone of a projection. Vega can be extended with additional projections, such as those found in the d3-geo-projection library. For example:

// d3-geo-projections must be imported and added to d3 object
// to register with Vega, provide a name and d3 projection function
vega.projection('winkel3', d3.geoWinkel3);

// Vega parser and runtime now support the 'winkel3' projection
var runtime = vega.parse({
  ...,
  "projections": [
    { "name": "proj", "type": "winkel3" }
  ],
  ...
});


Scales

#
vega.scale(type[, scale, metadata])
<>

Registry function for adding and accessing scale constructor functions. The type argument is a String indicating the name of the scale type. If the scale argument is not specified, this method returns the matching scale constructor in the registry, or null if not found. If the scale argument is provided, it must be a scale constructor function to add to the registry under the given type name.

The metadata argument provides additional information to guide appropriate use of scales within Vega. The metadata can be either a string or string array. The valid string values are:


  "continuous" - the scale is defined over a continuous-valued domain.
  "discrete" - the scale is defined over a discrete domain and range.
  "discretizing" - the scale discretizes a continuous domain to a discrete range.
  "interpolating" - the scale range is defined using a color interpolator.
  "log" - the scale performs a logarithmic transform of the continuous domain.
  "temporal" - the scale domain is defined over date-time values.


By default, the scale registry includes entries for all scale types provided by the d3-scale module. Scales created using the constructor returned by this method have an additional type property indicating the scale type. All scales supporting either an invert or invertExtent method are augmented with an additional invertRange function that returns an array of corresponding domain values for a given interval in the scale’s output range.

// linear scale
var linear = vega.scale('linear');
var scale = linear().domain([0, 10]).range([0, 100]);
scale.type; // 'linear'
scale.invertRange([0, 100]); // [0, 10]


var ordinal = vega.scale('ordinal');

// ordinal scale
var scale1 = ordinal().domain(['a', 'b', 'c']).range([0, 1, 2]);
scale1.type; // 'ordinal'

// ordinal scale with range set to the 'category20' color palette
var scale2 = ordinal().range(vega.scheme('category20'));


var seq = vega.scale('sequential');

// sequential scale, using the plasma color palette
var scale1 = seq().interpolator(vega.scheme('plasma'));
scale1.type; // 'sequential'


Color Schemes

#
vega.scheme(name[, scheme])
<>

Registry function for adding and accessing color schemes.  The name argument is a String indicating the name of the color scheme. Scheme names are not case sensitive, for example "blues" and "Blues" map to the same scheme. If the scheme argument is not specified, this method returns the matching scheme value in the registry, or undefined if not found. If the scheme argument is provided, it must be a valid array of color values or an interpolator function that maps the domain [0, 1] to color values.

By default, the scheme registry includes entries for all scheme types described in the Vega Color Schemes documentation.

Transforms

#
vega.transforms
<>

An object that maps transform names to transform constructors. To add a new transform to Vega, assign the transform to this object under the desired name.

In order to parse transform references within a Vega specification, the transform constructor must have a Definition property that provides the necessary metadata and parameter information. The vega-transforms package includes a collection of transforms demonstrating the syntax of definition objects.

Note that if a transform is added at runtime, any Vega JSON specifications using the new transform will fail JSON schema validation, as the new transform will not have been included in the default schema definition. To include new transforms within a custom JSON schema, developers can create a custom Vega build, adding new transforms to the vega-dataflow transforms export during the build process.

Data Formats

#
vega.formats(name[, format])
<>

Registry function for data format parsers. If invoked with two arguments, adds a new format parser with the provided name. Otherwise, returns an existing parser with the given name. The method signature of a format parser is:


  format(data, options)


A format parser that accepts two arguments, the input data to parse (e.g., a block of CSV text) and a set of format-specific options. The following data formats are registered by default:


  dsv: Delimiter-separated values format. Each line of text is a record,
with each field separated by a delimiter string. Accepts a delimiter option indicating the delimiter string used to separate field values.
  csv: Comma-separated values format. A dsv instance with a comma (,) delimiter.
  tsv: Tab-separated values format. A dsv instance with a tab (\t) delimiter.
  json: JavaScript Object Notation (JSON) format. Accepts a property option, indicating a sub-property of the parsed JSON to return; useful if a data array is nested within a larger object. Also accepts a copy option (default false), which will defensively copy a JSON Object that was passed to Vega directly, rather than parsed from a string.
  topojson: TopoJSON format for compressed encoding of geographic data. Requires either a feature option indicating the name of the geographic feature to extract (e.g., extracts individual paths for all countries), or a mesh option indicating a feature name for which a single mesh should be extracted (e.g., all country boundaries in a single path). Please see the TopoJSON documentation for more.


Expression Functions

#
vega.expressionFunction(name[, fn, visitor])
<>

Registry function for adding and accessing expression functions. The name argument is a String indicating the name of the function, as used within the Vega expression language. If the fn argument is not specified, this method returns the matching function value in the registry, or undefined if not found. If the fn argument is provided, it must be a valid JavaScript function to add to the registry under the given name. Once added, the parser will accept Vega specifications with expressions invoking this named function.

The visitor argument is an expression AST (abstract syntax tree) visitor function which can be used to perform dependency analysis (e.g., for scale or data source lookups), and is used internally by Vega. For most basic functions no visitor is needed, in which case this argument can be omitted.

Note that new expressions must be added before parsing a spec that uses the custom function. After registering a new expression function, all subsequently parsed Vega specifications will have access to the function.\nVega can be extended at runtime with new scales, projections, color schemes, and data transforms. While sometimes useful for custom deployments, keep in mind that extending Vega with new components can result in Vega JSON specifications that others may not be able to use directly.\nExtensibility API Reference\n#
vega.projection(type[, projection])
<>\nRegistry function for adding and accessing cartographic projections. The type argument is a String indicating the name of the projection type. If the projection argument is not specified, this method returns the matching projection constructor in the registry, or null if not found. If the projection argument is provided, it must be a projection constructor function to add to the registry under the given type name.\nBy default, Vega includes all cartographic projections described in the Vega Projections documentation. Projections created using the constructor returned by this method have an additional copy method that generates a new clone of a projection. Vega can be extended with additional projections, such as those found in the d3-geo-projection library. For example:\nVega Projections documentation\n// d3-geo-projections must be imported and added to d3 object
// to register with Vega, provide a name and d3 projection function
vega.projection('winkel3', d3.geoWinkel3);

// Vega parser and runtime now support the 'winkel3' projection
var runtime = vega.parse({
  ...,
  "projections": [
    { "name": "proj", "type": "winkel3" }
  ],
  ...
});\n// d3-geo-projections must be imported and added to d3 object
// to register with Vega, provide a name and d3 projection function
vega.projection('winkel3', d3.geoWinkel3);

// Vega parser and runtime now support the 'winkel3' projection
var runtime = vega.parse({
  ...,
  "projections": [
    { "name": "proj", "type": "winkel3" }
  ],
  ...
});\n// d3-geo-projections must be imported and added to d3 object\n// to register with Vega, provide a name and d3 projection function\n// Vega parser and runtime now support the 'winkel3' projection\n#
vega.scale(type[, scale, metadata])
<>\nRegistry function for adding and accessing scale constructor functions. The type argument is a String indicating the name of the scale type. If the scale argument is not specified, this method returns the matching scale constructor in the registry, or null if not found. If the scale argument is provided, it must be a scale constructor function to add to the registry under the given type name.\nThe metadata argument provides additional information to guide appropriate use of scales within Vega. The metadata can be either a string or string array. The valid string values are:\n"continuous" - the scale is defined over a continuous-valued domain.\n"discrete" - the scale is defined over a discrete domain and range.\n"discretizing" - the scale discretizes a continuous domain to a discrete range.\n"interpolating" - the scale range is defined using a color interpolator.\n"log" - the scale performs a logarithmic transform of the continuous domain.\n"temporal" - the scale domain is defined over date-time values.\nBy default, the scale registry includes entries for all scale types provided by the d3-scale module. Scales created using the constructor returned by this method have an additional type property indicating the scale type. All scales supporting either an invert or invertExtent method are augmented with an additional invertRange function that returns an array of corresponding domain values for a given interval in the scale’s output range.\n// linear scale
var linear = vega.scale('linear');
var scale = linear().domain([0, 10]).range([0, 100]);
scale.type; // 'linear'
scale.invertRange([0, 100]); // [0, 10]\n// linear scale
var linear = vega.scale('linear');
var scale = linear().domain([0, 10]).range([0, 100]);
scale.type; // 'linear'
scale.invertRange([0, 100]); // [0, 10]\nvar ordinal = vega.scale('ordinal');

// ordinal scale
var scale1 = ordinal().domain(['a', 'b', 'c']).range([0, 1, 2]);
scale1.type; // 'ordinal'

// ordinal scale with range set to the 'category20' color palette
var scale2 = ordinal().range(vega.scheme('category20'));\nvar ordinal = vega.scale('ordinal');

// ordinal scale
var scale1 = ordinal().domain(['a', 'b', 'c']).range([0, 1, 2]);
scale1.type; // 'ordinal'

// ordinal scale with range set to the 'category20' color palette
var scale2 = ordinal().range(vega.scheme('category20'));\n// ordinal scale with range set to the 'category20' color palette\nvar seq = vega.scale('sequential');

// sequential scale, using the plasma color palette
var scale1 = seq().interpolator(vega.scheme('plasma'));
scale1.type; // 'sequential'\nvar seq = vega.scale('sequential');

// sequential scale, using the plasma color palette
var scale1 = seq().interpolator(vega.scheme('plasma'));
scale1.type; // 'sequential'\n// sequential scale, using the plasma color palette\n#
vega.scheme(name[, scheme])
<>\nRegistry function for adding and accessing color schemes.  The name argument is a String indicating the name of the color scheme. Scheme names are not case sensitive, for example "blues" and "Blues" map to the same scheme. If the scheme argument is not specified, this method returns the matching scheme value in the registry, or undefined if not found. If the scheme argument is provided, it must be a valid array of color values or an interpolator function that maps the domain [0, 1] to color values.\nBy default, the scheme registry includes entries for all scheme types described in the Vega Color Schemes documentation.\nVega Color Schemes documentation\nAn object that maps transform names to transform constructors. To add a new transform to Vega, assign the transform to this object under the desired name.\nIn order to parse transform references within a Vega specification, the transform constructor must have a Definition property that provides the necessary metadata and parameter information. The vega-transforms package includes a collection of transforms demonstrating the syntax of definition objects.\nNote that if a transform is added at runtime, any Vega JSON specifications using the new transform will fail JSON schema validation, as the new transform will not have been included in the default schema definition. To include new transforms within a custom JSON schema, developers can create a custom Vega build, adding new transforms to the vega-dataflow transforms export during the build process.\n#
vega.formats(name[, format])
<>\nRegistry function for data format parsers. If invoked with two arguments, adds a new format parser with the provided name. Otherwise, returns an existing parser with the given name. The method signature of a format parser is:\nformat(data, options)\nA format parser that accepts two arguments, the input data to parse (e.g., a block of CSV text) and a set of format-specific options. The following data formats are registered by default:\ndsv: Delimiter-separated values format. Each line of text is a record,
with each field separated by a delimiter string. Accepts a delimiter option indicating the delimiter string used to separate field values.\ncsv: Comma-separated values format. A dsv instance with a comma (,) delimiter.\ntsv: Tab-separated values format. A dsv instance with a tab (\t) delimiter.\njson: JavaScript Object Notation (JSON) format. Accepts a property option, indicating a sub-property of the parsed JSON to return; useful if a data array is nested within a larger object. Also accepts a copy option (default false), which will defensively copy a JSON Object that was passed to Vega directly, rather than parsed from a string.\nJavaScript Object Notation (JSON)\ntopojson: TopoJSON format for compressed encoding of geographic data. Requires either a feature option indicating the name of the geographic feature to extract (e.g., extracts individual paths for all countries), or a mesh option indicating a feature name for which a single mesh should be extracted (e.g., all country boundaries in a single path). Please see the TopoJSON documentation for more.\nTopoJSON documentation\n#
vega.expressionFunction(name[, fn, visitor])
<>\nRegistry function for adding and accessing expression functions. The name argument is a String indicating the name of the function, as used within the Vega expression language. If the fn argument is not specified, this method returns the matching function value in the registry, or undefined if not found. If the fn argument is provided, it must be a valid JavaScript function to add to the registry under the given name. Once added, the parser will accept Vega specifications with expressions invoking this named function.\nVega expression language\nThe visitor argument is an expression AST (abstract syntax tree) visitor function which can be used to perform dependency analysis (e.g., for scale or data source lookups), and is used internally by Vega. For most basic functions no visitor is needed, in which case this argument can be omitted.\nNote that new expressions must be added before parsing a spec that uses the custom function. After registering a new expression function, all subsequently parsed Vega specifications will have access to the function.\n\n\nVega
            
              Vega-Lite
              Altair
              Vega-Lite API
            
          
          
            
              Examples
              Tutorials
              Documentation
              Usage
              About
            
            
              GitHub
              Try Online
            
          
        
      

      
        

  
  
    
      
      
        Documentation
      
      
      
      
        Parser
      
      
      
      
        View
      
      
      
      
        Locale
      
      
      
      
        Extensibility
      
      
      
      
        Statistics
      
      
      
      
        Time
      
      
      
      
        Util
      
      
      
      
        Debugging
      
      
    
  
  
    Statistics API
    Vega includes statistics functions for to model probability distributions and perform other statistical calculations. These methods are bound to the top-level vega object, and can also be used in a stand-alone fashion by using the vega-statistics project.

Statistics API Reference


  Random Number Generation
  Distribution Methods
  Distribution Objects
  Probability Distributions
  Regression
  Statistics Routines


Random Number Generation

#
vega.random()
<>

Returns a uniform pseudo-random number in the domain [0, 1). By default this is simply a call to JavaScript’s built-in Math.random function. All Vega routines that require random numbers should use this function.

#
vega.setRandom(randfunc)
<>

Sets the random number generator to the provided function randfunc. Subsequent calls to random will invoke the new function to generate random numbers. Setting a custom generator can be helpful if one wishes to use an alternative source of randomness or replace the default generator with a deterministic function for testing purposes.

#
vega.randomLCG(seed)
<>

Returns a new random number generator with the given random seed. The returned function takes zero arguments and generates random values in the domain [0, 1) using a linear congruential generator (LCG). This method is helpful in conjunction with setRandom to provide seeded random numbers for stable outputs and testing.

Distribution Methods

Methods for sampling and calculating values for probability distributions.

#
vega.sampleNormal([mean, stdev])
<>

Returns a sample from a univariate normal (Gaussian) probability distribution with specified mean and standard deviation stdev. If unspecified, the mean defaults to 0 and the standard deviation defaults to 1.

#
vega.cumulativeNormal(value[, mean, stdev])
<>

Returns the value of the cumulative distribution function at the given input domain value for a normal distribution with specified mean and standard deviation stdev. If unspecified, the mean defaults to 0 and the standard deviation defaults to 1.

#
vega.densityNormal(value[, mean, stdev])
<>

Returns the value of the probability density function at the given input domain value, for a normal distribution with specified mean and standard deviation stdev. If unspecified, the mean defaults to 0 and the standard deviation defaults to 1.

#
vega.quantileNormal(probability[, mean, stdev])
<>

Returns the quantile value (the inverse of the cumulative distribution function) for the given input probability, for a normal distribution with specified mean and standard deviation stdev. If unspecified, the mean defaults to 0 and the standard deviation defaults to 1.

#
vega.sampleLogNormal([mean, stdev])
<>

Returns a sample from a univariate log-normal probability distribution with specified log mean and log standard deviation stdev. If unspecified, the log mean defaults to 0 and the log standard deviation defaults to 1.

#
vega.cumulativeLogNormal(value[, mean, stdev])
<>

Returns the value of the cumulative distribution function at the given input domain value for a log-normal distribution with specified log mean and log standard deviation stdev. If unspecified, the log mean defaults to 0 and the log standard deviation defaults to 1.

#
vega.densityLogNormal(value[, mean, stdev])
<>

Returns the value of the probability density function at the given input domain value, for a log-normal distribution with specified log mean and log standard deviation stdev. If unspecified, the log mean defaults to 0 and the log standard deviation defaults to 1.

#
vega.quantileLogNormal(probability[, mean, stdev])
<>

Returns the quantile value (the inverse of the cumulative distribution function) for the given input probability, for a log-normal distribution with specified log mean and log standard deviation stdev. If unspecified, the log mean defaults to 0 and the log standard deviation defaults to 1.

#
vega.sampleUniform([min, max])
<>

Returns a sample from a univariate continuous uniform probability distribution over the interval [min, max). If unspecified, min defaults to 0 and max defaults to 1. If only one argument is provided, it is interpreted as the max value.

#
vega.cumulativeUniform(value[, min, max])
<>

Returns the value of the cumulative distribution function at the given input domain value for a uniform distribution over the interval [min, max). If unspecified, min defaults to 0 and max defaults to 1. If only one argument is provided, it is interpreted as the max value.

#
vega.densityUniform(value[, min, max])
<>

Returns the value of the probability density function at the given input domain value,  for a uniform distribution over the interval [min, max). If unspecified, min defaults to 0 and max defaults to 1. If only one argument is provided, it is interpreted as the max value.

#
vega.quantileUniform(probability[, min, max])
<>

Returns the quantile value (the inverse of the cumulative distribution function) for the given input probability,  for a uniform distribution over the interval [min, max). If unspecified, min defaults to 0 and max defaults to 1. If only one argument is provided, it is interpreted as the max value.

Distribution Objects

Methods for sampling and calculating probability distributions. Each method takes a set of distributional parameters and returns a distribution object representing a random variable.

Distribution objects expose the following methods:

  dist.sample(): Samples a random value drawn from this distribution.
  dist.pdf(value): Calculates the value of the probability density function at the given input domain value.
  dist.cdf(value): Calculates the value of the cumulative distribution function at the given input domain value.
  dist.icdf(probability): Calculates the inverse of the cumulative distribution function for the given input probability.


#
vega.randomNormal([mean, stdev])
<>

Creates a distribution object representing a normal (Gaussian) probability distribution with specified mean and standard deviation stdev. If unspecified, the mean defaults to 0 and the standard deviation defaults to 1.

Once created, mean and stdev values can be accessed or modified using the mean and stdev getter/setter methods.

#
vega.randomLogNormal([mean, stdev])
<>

Creates a distribution object representing a log-normal probability distribution with specified log mean and log standard deviation stdev. If unspecified, the log mean defaults to 0 and the log standard deviation defaults to 1.

Once created, mean and stdev values can be accessed or modified using the mean and stdev getter/setter methods.

#
vega.randomUniform([min, max])
<>

Creates a distribution object representing a continuous uniform probability distribution over the interval [min, max). If unspecified, min defaults to 0 and max defaults to 1. If only one argument is provided, it is interpreted as the max value.

Once created, min and max values can be accessed or modified using the min and max getter/setter methods.

#
vega.randomInteger([min,] max)
<>

Creates a distribution object representing a discrete uniform probability distribution over the integer domain [min, max). If only one argument is provided, it is interpreted as the max value. If unspecified, min defaults to 0.

Once created, min and max values can be accessed or modified using the min and max getter/setter methods.

#
vega.randomMixture(distributions[, weights])
<>

Creates a distribution object representing a (weighted) mixture of probability distributions. The distributions argument should be an array of distribution objects. The optional weights array provides proportional numerical weights for each distribution. If provided, the values in the weights array will be normalized to ensure that weights sum to 1. Any unspecified weight values default to 1 (prior to normalization). Mixture distributions do not support the icdf method: calling icdf will result in an error.

Once created, the distributions and weights arrays can be accessed or modified using the distributions and weights getter/setter methods.

#
vega.randomKDE(values[, bandwidth])
<>

Creates a distribution object representing a kernel density estimate for an array of numerical values. This method uses a Gaussian kernel to estimate a smoothed, continuous probability distribution. The optional bandwidth parameter determines the width of the Gaussian kernel. If the bandwidth is either 0 or unspecified, a default bandwidth value will be automatically estimated based on the input data. KDE distributions do not support the icdf method: calling icdf will result in an error.

Once created, data and bandwidth values can be accessed or modified using the data and bandwidth getter/setter methods.

Regression

Two-dimensional regression methods to predict one variable given another.

#
vega.regressionLinear(data, x, y)
<>

Fit a linear regression model with functional form y = a + b * x for the input data array and corresponding x and y accessor functions. Returns an object for the fit model parameters with the following properties:


  coef: An array of fitted coefficients of the form [a, b].
  predict: A function that returns a regression prediction for an input x value.
  rSquared: The R2 coefficient of determination, indicating the amount of total variance of y accounted for by the model.


#
vega.regressionLog(data, x, y)
<>

Fit a logarithmic regression model with functional form y = a + b * log(x) for the input input data array and corresponding x and y accessor functions.

Returns an object for the fit model parameters with the following properties:


  coef: An array of fitted coefficients of the form [a, b].
  predict: A function that returns a regression prediction for an input x value.
  rSquared: The R2 coefficient of determination, indicating the amount of total variance of y accounted for by the model.


#
vega.regressionExp(data, x, y)
<>

Fit an exponential regression model with functional form y = a + eb * x for the input data array and corresponding x and y accessor functions. Returns an object for the fit model parameters with the following properties:


  coef: An array of fitted coefficients of the form [a, b].
  predict: A function that returns a regression prediction for an input x value.
  rSquared: The R2 coefficient of determination, indicating the amount of total variance of y accounted for by the model.


#
vega.regressionPow(data, x, y)
<>

Fit a power law regression model with functional form y = a * xb for the input data array and corresponding x and y accessor functions. Returns an object for the fit model parameters with the following properties:


  coef: An array of fitted coefficients of the form [a, b].
  predict: A function that returns a regression prediction for an input x value.
  rSquared: The R2 coefficient of determination, indicating the amount of total variance of y accounted for by the model.


#
vega.regressionLinear(data, x, y)
<>

Fit a quadratic regression model with functional form y = a + b * x + c * x2 for the input data array and corresponding x and y accessor functions. Returns an object for the fit model parameters with the following properties:


  coef: An array of fitted coefficients of the form [a, b, c],
  predict: A function that returns a regression prediction for an input x value.
  rSquared: The R2 coefficient of determination, indicating the amount of total variance of y accounted for by the model.


#
vega.regressionPoly(data, x, y, order)
<>

Fit a polynomial regression model of specified order with functional form y = a + b * x + … + k * xorder for the input data array and corresponding x and y accessor functions. Returns an object for the fit model parameters with the following properties:


  coef: An (order + 1)-length array of polynomial coefficients of the form [a, b, c, d, …].
  predict: A function that returns a regression prediction for an input x value.
  rSquared: The R2 coefficient of determination, indicating the amount of total variance of y accounted for by the model.


#
vega.regressionLoess(data, x, y, bandwidth)
<>

Fit a smoothed, non-parametric trend line the input data array and corresponding x and y accessor functions using loess (locally-estimated scatterplot smoothing). Loess performs a sequence of local weighted regressions over a sliding window of nearest-neighbor points. The bandwidth argument determines the size of the sliding window, expressed as a [0, 1] fraction of the total number of data points included.

#
vega.sampleCurve(f, extent[, minSteps, maxSteps])
<>

Generate sample points from an interpolation function f for the provided domain extent and return an array of [x, y] points. Performs adaptive subdivision to dynamically sample more points in regions of higher curvature. Subdivision stops when the difference in angles between the current samples and a proposed subdivision falls below one-quarter of a degree. The optional minSteps argument (default 25), determines the minimal number of initial, uniformly-spaced sample points to draw. The optional maxSteps argument (default 200), indicates the maximum resolution at which adaptive sampling will stop, defined relative to a uniform grid of size maxSteps. If minSteps and maxSteps are identical, no adaptive sampling will be performed and only the initial, uniformly-spaced samples will be returned.

Statistics Routines

Statistical methods for bandwidth estimation, bin calculation, bootstrapped confidence intervals, and quartile boundaries.

#
vega.bandwidthNRD(array[, accessor])
<>

Given an array of numeric values, estimates a bandwidth value for use in Gaussian kernel density estimation, assuming a normal reference distribution. The underlying formula (from Scott 1992) is 1.06 times the minimum of the standard deviation and the interquartile range divided by 1.34 times the sample size to the negative one-fifth power, along with special case handling in case of zero values for the interquartile range or deviation. An optional accessor function can be used to first extract numerical values from an array of input objects, and is equivalent to first calling array.map(accessor).

#
vega.bin(options)
<>

Determine a quantitative binning scheme, for example to create a histogram. Based on the options provided given, this method will search over a space of possible bins, aligning step sizes with a given number base and applying constraints such as the maximum number of allowable bins. Given a set of options (see below), returns an object describing the binning scheme, in terms of start, stop and step properties.

The supported options properties are:


  extent: (required) A two-element ([min, max]) array indicating the range over which the bin values are defined.
  base: The number base to use for automatic bin determination (default base 10).
  maxbins: The maximum number of allowable bins (default 20). There will often be fewer bins as the domain is sliced at “nicely” rounded values.
  span: The value span over which to generate bin boundaries. The default is extent[1] - extent[0]. This parameter allows automatic step size determination over custom spans (for example, a zoomed-in region) while retaining the overall extent.
  step: An exact step size to use between bins. If provided, the maxbins, span, and steps options will be ignored.
  steps: An array of allowable step sizes to choose from. If provided, the maxbins option will be ignored.
  minstep: A minimum allowable step size (particularly useful for integer values, default 0).
  divide: An array of scale factors indicating allowable subdivisions. The default value is [5, 2], which indicates that the method may consider dividing bin sizes by 5 and/or 2. For example, for an initial step size of 10, the method can check if bin sizes of 2 (= 10/5), 5 (= 10/2), or 1 (= 10/(5*2)) might also satisfy the given constraints.
  nice: Boolean indicating if the start and stop values should be nicely-rounded relative to the step size (default true).


vega.bin({extent:[0, 1], maxbins:10}); // {start:0, stop:1, step:0.1}
vega.bin({extent:[0, 1], maxbins:5}); // {start:0, stop:10, step:2}
vega.bin({extent:[5, 10], maxbins:5}); // {start:5, stop:10, step:1}


#
vega.bootstrapCI(array, samples, alpha[, accessor])
<>

Calculates a bootstrapped confidence interval for an input array of values, based on a given number of samples iterations and a target alpha value. For example, an alpha value of 0.05 corresponds to a 95% confidence interval An optional accessor function can be used to first extract numerical values from an array of input objects, and is equivalent to first calling array.map(accessor). This method ignores null, undefined and NaN values.

#
vega.dotbin(sortedArray, step[, smooth, accessor])
<>

Calculates dot plot bin locations for an input sortedArray of numerical values, and returns an array of bin locations with indices matching the input sortedArray. This method implements the “dot density” algorithm of Wilkinson, 1999. The step parameter determines the bin width: points within step values of an anchor point will be assigned the same bin location. The optional smooth parameter is a boolean value indicating if the bin locations should additionally be smoothed to reduce variance. An optional accessor function can be used to first extract numerical values from an array of input objects, and is equivalent to first calling array.map(accessor). Any null, undefined, or NaN values should be removed prior to calling this method.

#
vega.quantiles(array, p[, accessor])
<>

Given an array of numeric values and array p of probability thresholds in the range [0, 1], returns an array of p-quantiles. The return value is a array the same length as the input p. An optional accessor function can be used to first extract numerical values from an array of input objects, and is equivalent to first calling array.map(accessor). This method ignores null, undefined and NaN values.

#
vega.quartiles(array[, accessor])
<>

Given an array of numeric values, returns an array of quartile boundaries. The return value is a 3-element array consisting of the first, second (median), and third quartile boundaries. An optional accessor function can be used to first extract numerical values from an array of input objects, and is equivalent to first calling array.map(accessor). This method ignores null, undefined and NaN values.\nVega
            
              Vega-Lite
              Altair
              Vega-Lite API\nVega-Lite
              Altair
              Vega-Lite API\nExamples
              Tutorials
              Documentation
              Usage
              About
            
            
              GitHub
              Try Online\nExamples
              Tutorials
              Documentation
              Usage
              About\nGitHub
              Try Online\nDocumentation
      
      
      
      
        Parser
      
      
      
      
        View
      
      
      
      
        Locale
      
      
      
      
        Extensibility
      
      
      
      
        Statistics
      
      
      
      
        Time
      
      
      
      
        Util
      
      
      
      
        Debugging
      
      
    
  
  
    Statistics API
    Vega includes statistics functions for to model probability distributions and perform other statistical calculations. These methods are bound to the top-level vega object, and can also be used in a stand-alone fashion by using the vega-statistics project.

Statistics API Reference


  Random Number Generation
  Distribution Methods
  Distribution Objects
  Probability Distributions
  Regression
  Statistics Routines


Random Number Generation

#
vega.random()
<>

Returns a uniform pseudo-random number in the domain [0, 1). By default this is simply a call to JavaScript’s built-in Math.random function. All Vega routines that require random numbers should use this function.

#
vega.setRandom(randfunc)
<>

Sets the random number generator to the provided function randfunc. Subsequent calls to random will invoke the new function to generate random numbers. Setting a custom generator can be helpful if one wishes to use an alternative source of randomness or replace the default generator with a deterministic function for testing purposes.

#
vega.randomLCG(seed)
<>

Returns a new random number generator with the given random seed. The returned function takes zero arguments and generates random values in the domain [0, 1) using a linear congruential generator (LCG). This method is helpful in conjunction with setRandom to provide seeded random numbers for stable outputs and testing.

Distribution Methods

Methods for sampling and calculating values for probability distributions.

#
vega.sampleNormal([mean, stdev])
<>

Returns a sample from a univariate normal (Gaussian) probability distribution with specified mean and standard deviation stdev. If unspecified, the mean defaults to 0 and the standard deviation defaults to 1.

#
vega.cumulativeNormal(value[, mean, stdev])
<>

Returns the value of the cumulative distribution function at the given input domain value for a normal distribution with specified mean and standard deviation stdev. If unspecified, the mean defaults to 0 and the standard deviation defaults to 1.

#
vega.densityNormal(value[, mean, stdev])
<>

Returns the value of the probability density function at the given input domain value, for a normal distribution with specified mean and standard deviation stdev. If unspecified, the mean defaults to 0 and the standard deviation defaults to 1.

#
vega.quantileNormal(probability[, mean, stdev])
<>

Returns the quantile value (the inverse of the cumulative distribution function) for the given input probability, for a normal distribution with specified mean and standard deviation stdev. If unspecified, the mean defaults to 0 and the standard deviation defaults to 1.

#
vega.sampleLogNormal([mean, stdev])
<>

Returns a sample from a univariate log-normal probability distribution with specified log mean and log standard deviation stdev. If unspecified, the log mean defaults to 0 and the log standard deviation defaults to 1.

#
vega.cumulativeLogNormal(value[, mean, stdev])
<>

Returns the value of the cumulative distribution function at the given input domain value for a log-normal distribution with specified log mean and log standard deviation stdev. If unspecified, the log mean defaults to 0 and the log standard deviation defaults to 1.

#
vega.densityLogNormal(value[, mean, stdev])
<>

Returns the value of the probability density function at the given input domain value, for a log-normal distribution with specified log mean and log standard deviation stdev. If unspecified, the log mean defaults to 0 and the log standard deviation defaults to 1.

#
vega.quantileLogNormal(probability[, mean, stdev])
<>

Returns the quantile value (the inverse of the cumulative distribution function) for the given input probability, for a log-normal distribution with specified log mean and log standard deviation stdev. If unspecified, the log mean defaults to 0 and the log standard deviation defaults to 1.

#
vega.sampleUniform([min, max])
<>

Returns a sample from a univariate continuous uniform probability distribution over the interval [min, max). If unspecified, min defaults to 0 and max defaults to 1. If only one argument is provided, it is interpreted as the max value.

#
vega.cumulativeUniform(value[, min, max])
<>

Returns the value of the cumulative distribution function at the given input domain value for a uniform distribution over the interval [min, max). If unspecified, min defaults to 0 and max defaults to 1. If only one argument is provided, it is interpreted as the max value.

#
vega.densityUniform(value[, min, max])
<>

Returns the value of the probability density function at the given input domain value,  for a uniform distribution over the interval [min, max). If unspecified, min defaults to 0 and max defaults to 1. If only one argument is provided, it is interpreted as the max value.

#
vega.quantileUniform(probability[, min, max])
<>

Returns the quantile value (the inverse of the cumulative distribution function) for the given input probability,  for a uniform distribution over the interval [min, max). If unspecified, min defaults to 0 and max defaults to 1. If only one argument is provided, it is interpreted as the max value.

Distribution Objects

Methods for sampling and calculating probability distributions. Each method takes a set of distributional parameters and returns a distribution object representing a random variable.

Distribution objects expose the following methods:

  dist.sample(): Samples a random value drawn from this distribution.
  dist.pdf(value): Calculates the value of the probability density function at the given input domain value.
  dist.cdf(value): Calculates the value of the cumulative distribution function at the given input domain value.
  dist.icdf(probability): Calculates the inverse of the cumulative distribution function for the given input probability.


#
vega.randomNormal([mean, stdev])
<>

Creates a distribution object representing a normal (Gaussian) probability distribution with specified mean and standard deviation stdev. If unspecified, the mean defaults to 0 and the standard deviation defaults to 1.

Once created, mean and stdev values can be accessed or modified using the mean and stdev getter/setter methods.

#
vega.randomLogNormal([mean, stdev])
<>

Creates a distribution object representing a log-normal probability distribution with specified log mean and log standard deviation stdev. If unspecified, the log mean defaults to 0 and the log standard deviation defaults to 1.

Once created, mean and stdev values can be accessed or modified using the mean and stdev getter/setter methods.

#
vega.randomUniform([min, max])
<>

Creates a distribution object representing a continuous uniform probability distribution over the interval [min, max). If unspecified, min defaults to 0 and max defaults to 1. If only one argument is provided, it is interpreted as the max value.

Once created, min and max values can be accessed or modified using the min and max getter/setter methods.

#
vega.randomInteger([min,] max)
<>

Creates a distribution object representing a discrete uniform probability distribution over the integer domain [min, max). If only one argument is provided, it is interpreted as the max value. If unspecified, min defaults to 0.

Once created, min and max values can be accessed or modified using the min and max getter/setter methods.

#
vega.randomMixture(distributions[, weights])
<>

Creates a distribution object representing a (weighted) mixture of probability distributions. The distributions argument should be an array of distribution objects. The optional weights array provides proportional numerical weights for each distribution. If provided, the values in the weights array will be normalized to ensure that weights sum to 1. Any unspecified weight values default to 1 (prior to normalization). Mixture distributions do not support the icdf method: calling icdf will result in an error.

Once created, the distributions and weights arrays can be accessed or modified using the distributions and weights getter/setter methods.

#
vega.randomKDE(values[, bandwidth])
<>

Creates a distribution object representing a kernel density estimate for an array of numerical values. This method uses a Gaussian kernel to estimate a smoothed, continuous probability distribution. The optional bandwidth parameter determines the width of the Gaussian kernel. If the bandwidth is either 0 or unspecified, a default bandwidth value will be automatically estimated based on the input data. KDE distributions do not support the icdf method: calling icdf will result in an error.

Once created, data and bandwidth values can be accessed or modified using the data and bandwidth getter/setter methods.

Regression

Two-dimensional regression methods to predict one variable given another.

#
vega.regressionLinear(data, x, y)
<>

Fit a linear regression model with functional form y = a + b * x for the input data array and corresponding x and y accessor functions. Returns an object for the fit model parameters with the following properties:


  coef: An array of fitted coefficients of the form [a, b].
  predict: A function that returns a regression prediction for an input x value.
  rSquared: The R2 coefficient of determination, indicating the amount of total variance of y accounted for by the model.


#
vega.regressionLog(data, x, y)
<>

Fit a logarithmic regression model with functional form y = a + b * log(x) for the input input data array and corresponding x and y accessor functions.

Returns an object for the fit model parameters with the following properties:


  coef: An array of fitted coefficients of the form [a, b].
  predict: A function that returns a regression prediction for an input x value.
  rSquared: The R2 coefficient of determination, indicating the amount of total variance of y accounted for by the model.


#
vega.regressionExp(data, x, y)
<>

Fit an exponential regression model with functional form y = a + eb * x for the input data array and corresponding x and y accessor functions. Returns an object for the fit model parameters with the following properties:


  coef: An array of fitted coefficients of the form [a, b].
  predict: A function that returns a regression prediction for an input x value.
  rSquared: The R2 coefficient of determination, indicating the amount of total variance of y accounted for by the model.


#
vega.regressionPow(data, x, y)
<>

Fit a power law regression model with functional form y = a * xb for the input data array and corresponding x and y accessor functions. Returns an object for the fit model parameters with the following properties:


  coef: An array of fitted coefficients of the form [a, b].
  predict: A function that returns a regression prediction for an input x value.
  rSquared: The R2 coefficient of determination, indicating the amount of total variance of y accounted for by the model.


#
vega.regressionLinear(data, x, y)
<>

Fit a quadratic regression model with functional form y = a + b * x + c * x2 for the input data array and corresponding x and y accessor functions. Returns an object for the fit model parameters with the following properties:


  coef: An array of fitted coefficients of the form [a, b, c],
  predict: A function that returns a regression prediction for an input x value.
  rSquared: The R2 coefficient of determination, indicating the amount of total variance of y accounted for by the model.


#
vega.regressionPoly(data, x, y, order)
<>

Fit a polynomial regression model of specified order with functional form y = a + b * x + … + k * xorder for the input data array and corresponding x and y accessor functions. Returns an object for the fit model parameters with the following properties:


  coef: An (order + 1)-length array of polynomial coefficients of the form [a, b, c, d, …].
  predict: A function that returns a regression prediction for an input x value.
  rSquared: The R2 coefficient of determination, indicating the amount of total variance of y accounted for by the model.


#
vega.regressionLoess(data, x, y, bandwidth)
<>

Fit a smoothed, non-parametric trend line the input data array and corresponding x and y accessor functions using loess (locally-estimated scatterplot smoothing). Loess performs a sequence of local weighted regressions over a sliding window of nearest-neighbor points. The bandwidth argument determines the size of the sliding window, expressed as a [0, 1] fraction of the total number of data points included.

#
vega.sampleCurve(f, extent[, minSteps, maxSteps])
<>

Generate sample points from an interpolation function f for the provided domain extent and return an array of [x, y] points. Performs adaptive subdivision to dynamically sample more points in regions of higher curvature. Subdivision stops when the difference in angles between the current samples and a proposed subdivision falls below one-quarter of a degree. The optional minSteps argument (default 25), determines the minimal number of initial, uniformly-spaced sample points to draw. The optional maxSteps argument (default 200), indicates the maximum resolution at which adaptive sampling will stop, defined relative to a uniform grid of size maxSteps. If minSteps and maxSteps are identical, no adaptive sampling will be performed and only the initial, uniformly-spaced samples will be returned.

Statistics Routines

Statistical methods for bandwidth estimation, bin calculation, bootstrapped confidence intervals, and quartile boundaries.

#
vega.bandwidthNRD(array[, accessor])
<>

Given an array of numeric values, estimates a bandwidth value for use in Gaussian kernel density estimation, assuming a normal reference distribution. The underlying formula (from Scott 1992) is 1.06 times the minimum of the standard deviation and the interquartile range divided by 1.34 times the sample size to the negative one-fifth power, along with special case handling in case of zero values for the interquartile range or deviation. An optional accessor function can be used to first extract numerical values from an array of input objects, and is equivalent to first calling array.map(accessor).

#
vega.bin(options)
<>

Determine a quantitative binning scheme, for example to create a histogram. Based on the options provided given, this method will search over a space of possible bins, aligning step sizes with a given number base and applying constraints such as the maximum number of allowable bins. Given a set of options (see below), returns an object describing the binning scheme, in terms of start, stop and step properties.

The supported options properties are:


  extent: (required) A two-element ([min, max]) array indicating the range over which the bin values are defined.
  base: The number base to use for automatic bin determination (default base 10).
  maxbins: The maximum number of allowable bins (default 20). There will often be fewer bins as the domain is sliced at “nicely” rounded values.
  span: The value span over which to generate bin boundaries. The default is extent[1] - extent[0]. This parameter allows automatic step size determination over custom spans (for example, a zoomed-in region) while retaining the overall extent.
  step: An exact step size to use between bins. If provided, the maxbins, span, and steps options will be ignored.
  steps: An array of allowable step sizes to choose from. If provided, the maxbins option will be ignored.
  minstep: A minimum allowable step size (particularly useful for integer values, default 0).
  divide: An array of scale factors indicating allowable subdivisions. The default value is [5, 2], which indicates that the method may consider dividing bin sizes by 5 and/or 2. For example, for an initial step size of 10, the method can check if bin sizes of 2 (= 10/5), 5 (= 10/2), or 1 (= 10/(5*2)) might also satisfy the given constraints.
  nice: Boolean indicating if the start and stop values should be nicely-rounded relative to the step size (default true).


vega.bin({extent:[0, 1], maxbins:10}); // {start:0, stop:1, step:0.1}
vega.bin({extent:[0, 1], maxbins:5}); // {start:0, stop:10, step:2}
vega.bin({extent:[5, 10], maxbins:5}); // {start:5, stop:10, step:1}


#
vega.bootstrapCI(array, samples, alpha[, accessor])
<>

Calculates a bootstrapped confidence interval for an input array of values, based on a given number of samples iterations and a target alpha value. For example, an alpha value of 0.05 corresponds to a 95% confidence interval An optional accessor function can be used to first extract numerical values from an array of input objects, and is equivalent to first calling array.map(accessor). This method ignores null, undefined and NaN values.

#
vega.dotbin(sortedArray, step[, smooth, accessor])
<>

Calculates dot plot bin locations for an input sortedArray of numerical values, and returns an array of bin locations with indices matching the input sortedArray. This method implements the “dot density” algorithm of Wilkinson, 1999. The step parameter determines the bin width: points within step values of an anchor point will be assigned the same bin location. The optional smooth parameter is a boolean value indicating if the bin locations should additionally be smoothed to reduce variance. An optional accessor function can be used to first extract numerical values from an array of input objects, and is equivalent to first calling array.map(accessor). Any null, undefined, or NaN values should be removed prior to calling this method.

#
vega.quantiles(array, p[, accessor])
<>

Given an array of numeric values and array p of probability thresholds in the range [0, 1], returns an array of p-quantiles. The return value is a array the same length as the input p. An optional accessor function can be used to first extract numerical values from an array of input objects, and is equivalent to first calling array.map(accessor). This method ignores null, undefined and NaN values.

#
vega.quartiles(array[, accessor])
<>

Given an array of numeric values, returns an array of quartile boundaries. The return value is a 3-element array consisting of the first, second (median), and third quartile boundaries. An optional accessor function can be used to first extract numerical values from an array of input objects, and is equivalent to first calling array.map(accessor). This method ignores null, undefined and NaN values.\nVega includes statistics functions for to model probability distributions and perform other statistical calculations. These methods are bound to the top-level vega object, and can also be used in a stand-alone fashion by using the vega-statistics project.\nStatistics API Reference\nRandom Number Generation\nRandom Number Generation\nProbability Distributions\nProbability Distributions\nRandom Number Generation\nReturns a uniform pseudo-random number in the domain [0, 1). By default this is simply a call to JavaScript’s built-in Math.random function. All Vega routines that require random numbers should use this function.\n#
vega.setRandom(randfunc)
<>\nSets the random number generator to the provided function randfunc. Subsequent calls to random will invoke the new function to generate random numbers. Setting a custom generator can be helpful if one wishes to use an alternative source of randomness or replace the default generator with a deterministic function for testing purposes.\n#
vega.randomLCG(seed)
<>\nReturns a new random number generator with the given random seed. The returned function takes zero arguments and generates random values in the domain [0, 1) using a linear congruential generator (LCG). This method is helpful in conjunction with setRandom to provide seeded random numbers for stable outputs and testing.\nlinear congruential generator (LCG)\nMethods for sampling and calculating values for probability distributions.\n#
vega.sampleNormal([mean, stdev])
<>\nReturns a sample from a univariate normal (Gaussian) probability distribution with specified mean and standard deviation stdev. If unspecified, the mean defaults to 0 and the standard deviation defaults to 1.\nnormal (Gaussian) probability distribution\n#
vega.cumulativeNormal(value[, mean, stdev])
<>\nReturns the value of the cumulative distribution function at the given input domain value for a normal distribution with specified mean and standard deviation stdev. If unspecified, the mean defaults to 0 and the standard deviation defaults to 1.\ncumulative distribution function\n#
vega.densityNormal(value[, mean, stdev])
<>\nReturns the value of the probability density function at the given input domain value, for a normal distribution with specified mean and standard deviation stdev. If unspecified, the mean defaults to 0 and the standard deviation defaults to 1.\nprobability density function\n#
vega.quantileNormal(probability[, mean, stdev])
<>\nReturns the quantile value (the inverse of the cumulative distribution function) for the given input probability, for a normal distribution with specified mean and standard deviation stdev. If unspecified, the mean defaults to 0 and the standard deviation defaults to 1.\ncumulative distribution function\n#
vega.sampleLogNormal([mean, stdev])
<>\nReturns a sample from a univariate log-normal probability distribution with specified log mean and log standard deviation stdev. If unspecified, the log mean defaults to 0 and the log standard deviation defaults to 1.\nlog-normal probability distribution\n#
vega.cumulativeLogNormal(value[, mean, stdev])
<>\nReturns the value of the cumulative distribution function at the given input domain value for a log-normal distribution with specified log mean and log standard deviation stdev. If unspecified, the log mean defaults to 0 and the log standard deviation defaults to 1.\ncumulative distribution function\n#
vega.densityLogNormal(value[, mean, stdev])
<>\nReturns the value of the probability density function at the given input domain value, for a log-normal distribution with specified log mean and log standard deviation stdev. If unspecified, the log mean defaults to 0 and the log standard deviation defaults to 1.\nprobability density function\n#
vega.quantileLogNormal(probability[, mean, stdev])
<>\nReturns the quantile value (the inverse of the cumulative distribution function) for the given input probability, for a log-normal distribution with specified log mean and log standard deviation stdev. If unspecified, the log mean defaults to 0 and the log standard deviation defaults to 1.\ncumulative distribution function\n#
vega.sampleUniform([min, max])
<>\nReturns a sample from a univariate continuous uniform probability distribution over the interval [min, max). If unspecified, min defaults to 0 and max defaults to 1. If only one argument is provided, it is interpreted as the max value.\ncontinuous uniform probability distribution\n#
vega.cumulativeUniform(value[, min, max])
<>\nReturns the value of the cumulative distribution function at the given input domain value for a uniform distribution over the interval [min, max). If unspecified, min defaults to 0 and max defaults to 1. If only one argument is provided, it is interpreted as the max value.\ncumulative distribution function\n#
vega.densityUniform(value[, min, max])
<>\nReturns the value of the probability density function at the given input domain value,  for a uniform distribution over the interval [min, max). If unspecified, min defaults to 0 and max defaults to 1. If only one argument is provided, it is interpreted as the max value.\nprobability density function\n#
vega.quantileUniform(probability[, min, max])
<>\nReturns the quantile value (the inverse of the cumulative distribution function) for the given input probability,  for a uniform distribution over the interval [min, max). If unspecified, min defaults to 0 and max defaults to 1. If only one argument is provided, it is interpreted as the max value.\ncumulative distribution function\nMethods for sampling and calculating probability distributions. Each method takes a set of distributional parameters and returns a distribution object representing a random variable.\nDistribution objects expose the following methods:\ndist.sample(): Samples a random value drawn from this distribution.\ndist.pdf(value): Calculates the value of the probability density function at the given input domain value.\nprobability density function\ndist.cdf(value): Calculates the value of the cumulative distribution function at the given input domain value.\ncumulative distribution function\ndist.icdf(probability): Calculates the inverse of the cumulative distribution function for the given input probability.\ncumulative distribution function\n#
vega.randomNormal([mean, stdev])
<>\nCreates a distribution object representing a normal (Gaussian) probability distribution with specified mean and standard deviation stdev. If unspecified, the mean defaults to 0 and the standard deviation defaults to 1.\nnormal (Gaussian) probability distribution\nOnce created, mean and stdev values can be accessed or modified using the mean and stdev getter/setter methods.\n#
vega.randomLogNormal([mean, stdev])
<>\nCreates a distribution object representing a log-normal probability distribution with specified log mean and log standard deviation stdev. If unspecified, the log mean defaults to 0 and the log standard deviation defaults to 1.\nlog-normal probability distribution\nOnce created, mean and stdev values can be accessed or modified using the mean and stdev getter/setter methods.\n#
vega.randomUniform([min, max])
<>\nCreates a distribution object representing a continuous uniform probability distribution over the interval [min, max). If unspecified, min defaults to 0 and max defaults to 1. If only one argument is provided, it is interpreted as the max value.\ncontinuous uniform probability distribution\nOnce created, min and max values can be accessed or modified using the min and max getter/setter methods.\n#
vega.randomInteger([min,] max)
<>\nCreates a distribution object representing a discrete uniform probability distribution over the integer domain [min, max). If only one argument is provided, it is interpreted as the max value. If unspecified, min defaults to 0.\ndiscrete uniform probability distribution\nOnce created, min and max values can be accessed or modified using the min and max getter/setter methods.\n#
vega.randomMixture(distributions[, weights])
<>\nCreates a distribution object representing a (weighted) mixture of probability distributions. The distributions argument should be an array of distribution objects. The optional weights array provides proportional numerical weights for each distribution. If provided, the values in the weights array will be normalized to ensure that weights sum to 1. Any unspecified weight values default to 1 (prior to normalization). Mixture distributions do not support the icdf method: calling icdf will result in an error.\nOnce created, the distributions and weights arrays can be accessed or modified using the distributions and weights getter/setter methods.\n#
vega.randomKDE(values[, bandwidth])
<>\nCreates a distribution object representing a kernel density estimate for an array of numerical values. This method uses a Gaussian kernel to estimate a smoothed, continuous probability distribution. The optional bandwidth parameter determines the width of the Gaussian kernel. If the bandwidth is either 0 or unspecified, a default bandwidth value will be automatically estimated based on the input data. KDE distributions do not support the icdf method: calling icdf will result in an error.\nkernel density estimate\nOnce created, data and bandwidth values can be accessed or modified using the data and bandwidth getter/setter methods.\nTwo-dimensional regression methods to predict one variable given another.\n#
vega.regressionLinear(data, x, y)
<>\nFit a linear regression model with functional form y = a + b * x for the input data array and corresponding x and y accessor functions. Returns an object for the fit model parameters with the following properties:\ncoef: An array of fitted coefficients of the form [a, b].\npredict: A function that returns a regression prediction for an input x value.\nrSquared: The R2 coefficient of determination, indicating the amount of total variance of y accounted for by the model.\ncoefficient of determination\n#
vega.regressionLog(data, x, y)
<>\nFit a logarithmic regression model with functional form y = a + b * log(x) for the input input data array and corresponding x and y accessor functions.\nReturns an object for the fit model parameters with the following properties:\ncoef: An array of fitted coefficients of the form [a, b].\npredict: A function that returns a regression prediction for an input x value.\nrSquared: The R2 coefficient of determination, indicating the amount of total variance of y accounted for by the model.\ncoefficient of determination\n#
vega.regressionExp(data, x, y)
<>\nFit an exponential regression model with functional form y = a + eb * x for the input data array and corresponding x and y accessor functions. Returns an object for the fit model parameters with the following properties:\ncoef: An array of fitted coefficients of the form [a, b].\npredict: A function that returns a regression prediction for an input x value.\nrSquared: The R2 coefficient of determination, indicating the amount of total variance of y accounted for by the model.\ncoefficient of determination\n#
vega.regressionPow(data, x, y)
<>\nFit a power law regression model with functional form y = a * xb for the input data array and corresponding x and y accessor functions. Returns an object for the fit model parameters with the following properties:\ncoef: An array of fitted coefficients of the form [a, b].\npredict: A function that returns a regression prediction for an input x value.\nrSquared: The R2 coefficient of determination, indicating the amount of total variance of y accounted for by the model.\ncoefficient of determination\n#
vega.regressionLinear(data, x, y)
<>\nFit a quadratic regression model with functional form y = a + b * x + c * x2 for the input data array and corresponding x and y accessor functions. Returns an object for the fit model parameters with the following properties:\ncoef: An array of fitted coefficients of the form [a, b, c],\npredict: A function that returns a regression prediction for an input x value.\nrSquared: The R2 coefficient of determination, indicating the amount of total variance of y accounted for by the model.\ncoefficient of determination\n#
vega.regressionPoly(data, x, y, order)
<>\nFit a polynomial regression model of specified order with functional form y = a + b * x + … + k * xorder for the input data array and corresponding x and y accessor functions. Returns an object for the fit model parameters with the following properties:\ncoef: An (order + 1)-length array of polynomial coefficients of the form [a, b, c, d, …].\npredict: A function that returns a regression prediction for an input x value.\nrSquared: The R2 coefficient of determination, indicating the amount of total variance of y accounted for by the model.\ncoefficient of determination\n#
vega.regressionLoess(data, x, y, bandwidth)
<>\nFit a smoothed, non-parametric trend line the input data array and corresponding x and y accessor functions using loess (locally-estimated scatterplot smoothing). Loess performs a sequence of local weighted regressions over a sliding window of nearest-neighbor points. The bandwidth argument determines the size of the sliding window, expressed as a [0, 1] fraction of the total number of data points included.\n#
vega.sampleCurve(f, extent[, minSteps, maxSteps])
<>\nGenerate sample points from an interpolation function f for the provided domain extent and return an array of [x, y] points. Performs adaptive subdivision to dynamically sample more points in regions of higher curvature. Subdivision stops when the difference in angles between the current samples and a proposed subdivision falls below one-quarter of a degree. The optional minSteps argument (default 25), determines the minimal number of initial, uniformly-spaced sample points to draw. The optional maxSteps argument (default 200), indicates the maximum resolution at which adaptive sampling will stop, defined relative to a uniform grid of size maxSteps. If minSteps and maxSteps are identical, no adaptive sampling will be performed and only the initial, uniformly-spaced samples will be returned.\nStatistical methods for bandwidth estimation, bin calculation, bootstrapped confidence intervals, and quartile boundaries.\n#
vega.bandwidthNRD(array[, accessor])
<>\nGiven an array of numeric values, estimates a bandwidth value for use in Gaussian kernel density estimation, assuming a normal reference distribution. The underlying formula (from Scott 1992) is 1.06 times the minimum of the standard deviation and the interquartile range divided by 1.34 times the sample size to the negative one-fifth power, along with special case handling in case of zero values for the interquartile range or deviation. An optional accessor function can be used to first extract numerical values from an array of input objects, and is equivalent to first calling array.map(accessor).\n#
vega.bin(options)
<>\nDetermine a quantitative binning scheme, for example to create a histogram. Based on the options provided given, this method will search over a space of possible bins, aligning step sizes with a given number base and applying constraints such as the maximum number of allowable bins. Given a set of options (see below), returns an object describing the binning scheme, in terms of start, stop and step properties.\nThe supported options properties are:\nextent: (required) A two-element ([min, max]) array indicating the range over which the bin values are defined.\nbase: The number base to use for automatic bin determination (default base 10).\nmaxbins: The maximum number of allowable bins (default 20). There will often be fewer bins as the domain is sliced at “nicely” rounded values.\nspan: The value span over which to generate bin boundaries. The default is extent[1] - extent[0]. This parameter allows automatic step size determination over custom spans (for example, a zoomed-in region) while retaining the overall extent.\nstep: An exact step size to use between bins. If provided, the maxbins, span, and steps options will be ignored.\nsteps: An array of allowable step sizes to choose from. If provided, the maxbins option will be ignored.\nminstep: A minimum allowable step size (particularly useful for integer values, default 0).\ndivide: An array of scale factors indicating allowable subdivisions. The default value is [5, 2], which indicates that the method may consider dividing bin sizes by 5 and/or 2. For example, for an initial step size of 10, the method can check if bin sizes of 2 (= 10/5), 5 (= 10/2), or 1 (= 10/(5*2)) might also satisfy the given constraints.\nnice: Boolean indicating if the start and stop values should be nicely-rounded relative to the step size (default true).\nvega.bin({extent:[0, 1], maxbins:10}); // {start:0, stop:1, step:0.1}
vega.bin({extent:[0, 1], maxbins:5}); // {start:0, stop:10, step:2}
vega.bin({extent:[5, 10], maxbins:5}); // {start:5, stop:10, step:1}\nvega.bin({extent:[0, 1], maxbins:10}); // {start:0, stop:1, step:0.1}
vega.bin({extent:[0, 1], maxbins:5}); // {start:0, stop:10, step:2}
vega.bin({extent:[5, 10], maxbins:5}); // {start:5, stop:10, step:1}\n// {start:0, stop:1, step:0.1}\n// {start:0, stop:10, step:2}\n// {start:5, stop:10, step:1}\n#
vega.bootstrapCI(array, samples, alpha[, accessor])
<>\nCalculates a bootstrapped confidence interval for an input array of values, based on a given number of samples iterations and a target alpha value. For example, an alpha value of 0.05 corresponds to a 95% confidence interval An optional accessor function can be used to first extract numerical values from an array of input objects, and is equivalent to first calling array.map(accessor). This method ignores null, undefined and NaN values.\n#
vega.dotbin(sortedArray, step[, smooth, accessor])
<>\nCalculates dot plot bin locations for an input sortedArray of numerical values, and returns an array of bin locations with indices matching the input sortedArray. This method implements the “dot density” algorithm of Wilkinson, 1999. The step parameter determines the bin width: points within step values of an anchor point will be assigned the same bin location. The optional smooth parameter is a boolean value indicating if the bin locations should additionally be smoothed to reduce variance. An optional accessor function can be used to first extract numerical values from an array of input objects, and is equivalent to first calling array.map(accessor). Any null, undefined, or NaN values should be removed prior to calling this method.\n“dot density” algorithm of Wilkinson, 1999\n#
vega.quantiles(array, p[, accessor])
<>\nGiven an array of numeric values and array p of probability thresholds in the range [0, 1], returns an array of p-quantiles. The return value is a array the same length as the input p. An optional accessor function can be used to first extract numerical values from an array of input objects, and is equivalent to first calling array.map(accessor). This method ignores null, undefined and NaN values.\n#
vega.quartiles(array[, accessor])
<>\nGiven an array of numeric values, returns an array of quartile boundaries. The return value is a 3-element array consisting of the first, second (median), and third quartile boundaries. An optional accessor function can be used to first extract numerical values from an array of input objects, and is equivalent to first calling array.map(accessor). This method ignores null, undefined and NaN values.\n\n\nVega
            
              Vega-Lite
              Altair
              Vega-Lite API
            
          
          
            
              Examples
              Tutorials
              Documentation
              Usage
              About
            
            
              GitHub
              Try Online
            
          
        
      

      
        

  
  
    
      
      
        Documentation
      
      
      
      
        Parser
      
      
      
      
        View
      
      
      
      
        Locale
      
      
      
      
        Extensibility
      
      
      
      
        Statistics
      
      
      
      
        Time
      
      
      
      
        Util
      
      
      
      
        Debugging
      
      
    
  
  
    Time Utilities API
    JavaScript date-time utilities for Vega. Provides a set of helper methods for working with date objects (or, equivalently, with UNIX timestamps). These methods are bound to the top-level vega object, and can also be used in a stand-alone fashion by using the vega-time package. For more general utility methods, see the Utilities API reference.

Time Utilities API Reference


  Time Units
  Local Time Utilities
  UTC Time Utilities


Time Units

The date-time utilities support a set of pre-defined time units. A single unit value is one of the following strings:


  'year' - Gregorian calendar years.
  'quarter' - Three-month intervals, starting in one of January, April, July, and October.
  'month' - Calendar months (January, February, etc.).
  'date' - Calendar day of the month (January 1, January 2, etc.).
  'week' - Sunday-based weeks. Days before the first Sunday of the year are considered to be in week 0, the first Sunday of the year is the start of week 1, the second Sunday week 2, etc..
  'day' - Day of the week (Sunday, Monday, etc.).
  'dayofyear' - Day of the year (1, 2, …, 365, etc.).
  'hours' - Hours of the day (12:00am, 1:00am, etc.).
  'minutes' - Minutes in an hour (12:00, 12:01, etc.).
  'seconds' - Seconds in a minute (12:00:00, 12:00:01, etc.).
  'milliseconds' - Milliseconds in a second.


Multiple units can be listed in an array to indicate desired intervals of time. For example, ['year', 'month', 'date'] indicates chronological time sensitive to year, month, and date (but not to hours, minutes, or seconds). The specifier ['month', 'date'] is sensitive to month and date, but not year, which can be useful for binning time values to look at seasonal patterns only.

#
vega.timeUnits(units)
<>

Returns a standardized and sorted specifier for the given units, which must be an array of one or more valid time unit strings. The returned array contains the same units, sorted in decreasing over of unit size, such that the most granular unit is last (for example, ['year', 'month', 'date']). This method throws an error if the units array is empty, contains an invalid unit, or contains incompatible units. Specifically, the 'quarter', 'month', and 'date' units can not be used in conjunction with the 'week' or 'day' units.

#
vega.timeUnitSpecifier(units[, specifiers])
<>

Returns a time format specifier string for the given time units. The optional specifiers object provides a set of desired specifier sub-strings for customizing the resulting time formats. The specifiers object may contain keys for both single time units ("year") and time unit sequences ("year-month-date"). This method will first standardize the input time units using the timeUnits method. It will then search, starting from the beginning of the units array, for the largest matching sequence defined in the specifiers object. Matching entries are then concatenated together, and the resulting string is whitespace-trimmed and returned.

If no specifiers object is provided, the following defaults are used:

{
  "year": "%Y ",
  "year-month": "%Y-%m ",
  "year-month-date": "%Y-%m-%d ",
  "quarter": "Q%q ",
  "month": "%b ",
  "date": "%d ",
  "week": "W%U ",
  "day": "%a ",
  "hours": "%H:00",
  "hours-minutes": "%H:%M",
  "minutes": "00:%M",
  "seconds": ":%S",
  "milliseconds": ".%L"
}


If a specifiers object is provided, its values are merged with the defaults above. As a result, for complete control callees may wish to override the multi-unit "year-month", "year-month-date", and "hours-minutes" entries in addition to any individual unit entries. The input specifiers object can use a null value to invalidate an entry in the defaults.

#
vega.timeBin(options)
<>

Determine a temporal binning scheme, for example to create a histogram. Based on the options provided given, this method will search over a space of possible time unit bins, applying constraints such as the maximum number of allowable bins. Given a set of options (see below), returns an object describing the binning scheme, in terms of units and step properties. These values can then be used as input to the timeFloor or utcFloor methods.

The supported options properties are:


  extent: (required) A two-element ([min, max]) array indicating the date range over which the bin values are defined.
  maxbins: The maximum number of allowable bins (default 40). There will often be fewer bins as the domain gets sliced at “nicely” rounded values.


Local Time Utilities

#
vega.timeFormat([specifier])
<>

Returns a function that takes a date or timestamp as input and returns a formatted string in the local timezone. If a string-valued format specifier is provided, it must follow the d3-time-format syntax. In this case, this method is equivalent to d3-time-format’s timeFormat method.

If an object-valued specifier is provided, a multi-format function will be generated, which selects among different format specifiers based on the granularity of the input date value (that is, values residing on a year, month, date, etc., boundary can all be formatted differently). The input object should use proper time unit strings for keys. If no time format specifier is provided, a default multi-format function is returned, equivalent to using the following specifier:

{
  "year": "%Y",
  "quarter": "%B",
  "month": "%B",
  "week": "%b %d",
  "date": "%a %d",
  "hours": "%I %p",
  "minutes": "%I:%M",
  "seconds": ":%S",
  "milliseconds": ".%L"
}


If an input specifier object omits any of these key values, a default value will be used. Note that for this method the "date" and "day" units are interchangeable; if both are defined the "date" entry take precedence.

#
vega.timeFloor(units[, step])
<>

Returns a function that performs flooring (truncation) of input dates to given time units in the local timezone. The units argument must be an array of valid time unit strings, for example ['year', 'month'] or ['week', 'date']. The optional step argument (default 1) indicates the number of time unit steps (of the smallest provided unit) to include as part of the truncation scheme. For example, timeFloor(['quarter']) is equivalent to timeFloor(['month'], 3).

#
vega.timeInterval(unit)
<>

Returns a d3-time interval for the given time unit in the local timezone.

#
vega.timeOffset(unit, date[, step])
<>

Returns a new Date instance that offsets the given date by the specified time unit in the local timezone. The optional step argument indicates the number of time unit steps to offset by (default 1).

#
vega.timeSequence(unit, start, stop[, step])
<>

Returns an array of Date instances from start (inclusive) to stop (exclusive), with each entry separated by the given time unit in the local timezone. The optional step argument indicates the number of time unit steps to take between each sequence entry (default 1).

#
vega.dayofyear(date)
<>

Returns the one-based day of the year for the given date, which should be either a Date object or timestamp value.

#
vega.week(date)
<>

Returns the week number of the year for the given date, which should be either a Date object or timestamp value. This function assumes Sunday-based weeks. Days before the first Sunday of the year are considered to be in week 0, the first Sunday of the year is the start of week 1, the second Sunday week 2, etc..

UTC Time Utilities

#
vega.utcFormat([specifier])
<>

Returns a function that takes a date or timestamp as input and returns a formatted string in Coordinated Universal Time (UTC). If a string-valued format specifier is provided, it must follow the d3-time-format syntax. In this case, this method is equivalent to d3-time-format’s utcFormat method.

This method also accepts object-valued specifiers for creating multi-format functions. If no argumennts are provided, a defualt multi-format function will be returned. For more details, see the timeFormat method documentation.

#
vega.utcFloor(units[, step])
<>

Returns a function that performs flooring (truncation) of input dates to given time units in Coordinated Universal Time (UTC). The units argument must be an array of valid time unit strings, for example ['year', 'month'] or ['week', 'date']. The optional step argument (default 1) indicates the number of time unit steps (of the smallest provided unit) to include as part of the truncation scheme. For example, utcFloor(['quarter']) is equivalent to utcFloor(['month'], 3).

#
vega.utcInterval(unit)
<>

Returns a d3-time interval for the given time unit in Coordinated Universal Time (UTC).

#
vega.utcOffset(unit, date[, step])
<>

Returns a new Date instance that offsets the given date by the specified time unit in Coordinated Universal Time (UTC). The optional step argument indicates the number of time unit steps to offset by (default 1).

#
vega.utcSequence(unit, start, stop[, step])
<>

Returns an array of Date instances from start (inclusive) to stop (exclusive), with each entry separated by the given time unit in Coordinated Universal Time (UTC). The optional step argument indicates the number of time unit steps to take between each sequence entry (default 1).

#
vega.utcweek(date)
<>

Returns the week number of the year for the given date in Coordinated Universal Time (UTC), which should be either a Date object or timestamp value. This function assumes Sunday-based weeks. Days before the first Sunday of the year are considered to be in week 0, the first Sunday of the year is the start of week 1, the second Sunday week 2, etc..\nVega
            
              Vega-Lite
              Altair
              Vega-Lite API\nVega-Lite
              Altair
              Vega-Lite API\nExamples
              Tutorials
              Documentation
              Usage
              About
            
            
              GitHub
              Try Online\nExamples
              Tutorials
              Documentation
              Usage
              About\nGitHub
              Try Online\nDocumentation
      
      
      
      
        Parser
      
      
      
      
        View
      
      
      
      
        Locale
      
      
      
      
        Extensibility
      
      
      
      
        Statistics
      
      
      
      
        Time
      
      
      
      
        Util
      
      
      
      
        Debugging
      
      
    
  
  
    Time Utilities API
    JavaScript date-time utilities for Vega. Provides a set of helper methods for working with date objects (or, equivalently, with UNIX timestamps). These methods are bound to the top-level vega object, and can also be used in a stand-alone fashion by using the vega-time package. For more general utility methods, see the Utilities API reference.

Time Utilities API Reference


  Time Units
  Local Time Utilities
  UTC Time Utilities


Time Units

The date-time utilities support a set of pre-defined time units. A single unit value is one of the following strings:


  'year' - Gregorian calendar years.
  'quarter' - Three-month intervals, starting in one of January, April, July, and October.
  'month' - Calendar months (January, February, etc.).
  'date' - Calendar day of the month (January 1, January 2, etc.).
  'week' - Sunday-based weeks. Days before the first Sunday of the year are considered to be in week 0, the first Sunday of the year is the start of week 1, the second Sunday week 2, etc..
  'day' - Day of the week (Sunday, Monday, etc.).
  'dayofyear' - Day of the year (1, 2, …, 365, etc.).
  'hours' - Hours of the day (12:00am, 1:00am, etc.).
  'minutes' - Minutes in an hour (12:00, 12:01, etc.).
  'seconds' - Seconds in a minute (12:00:00, 12:00:01, etc.).
  'milliseconds' - Milliseconds in a second.


Multiple units can be listed in an array to indicate desired intervals of time. For example, ['year', 'month', 'date'] indicates chronological time sensitive to year, month, and date (but not to hours, minutes, or seconds). The specifier ['month', 'date'] is sensitive to month and date, but not year, which can be useful for binning time values to look at seasonal patterns only.

#
vega.timeUnits(units)
<>

Returns a standardized and sorted specifier for the given units, which must be an array of one or more valid time unit strings. The returned array contains the same units, sorted in decreasing over of unit size, such that the most granular unit is last (for example, ['year', 'month', 'date']). This method throws an error if the units array is empty, contains an invalid unit, or contains incompatible units. Specifically, the 'quarter', 'month', and 'date' units can not be used in conjunction with the 'week' or 'day' units.

#
vega.timeUnitSpecifier(units[, specifiers])
<>

Returns a time format specifier string for the given time units. The optional specifiers object provides a set of desired specifier sub-strings for customizing the resulting time formats. The specifiers object may contain keys for both single time units ("year") and time unit sequences ("year-month-date"). This method will first standardize the input time units using the timeUnits method. It will then search, starting from the beginning of the units array, for the largest matching sequence defined in the specifiers object. Matching entries are then concatenated together, and the resulting string is whitespace-trimmed and returned.

If no specifiers object is provided, the following defaults are used:

{
  "year": "%Y ",
  "year-month": "%Y-%m ",
  "year-month-date": "%Y-%m-%d ",
  "quarter": "Q%q ",
  "month": "%b ",
  "date": "%d ",
  "week": "W%U ",
  "day": "%a ",
  "hours": "%H:00",
  "hours-minutes": "%H:%M",
  "minutes": "00:%M",
  "seconds": ":%S",
  "milliseconds": ".%L"
}


If a specifiers object is provided, its values are merged with the defaults above. As a result, for complete control callees may wish to override the multi-unit "year-month", "year-month-date", and "hours-minutes" entries in addition to any individual unit entries. The input specifiers object can use a null value to invalidate an entry in the defaults.

#
vega.timeBin(options)
<>

Determine a temporal binning scheme, for example to create a histogram. Based on the options provided given, this method will search over a space of possible time unit bins, applying constraints such as the maximum number of allowable bins. Given a set of options (see below), returns an object describing the binning scheme, in terms of units and step properties. These values can then be used as input to the timeFloor or utcFloor methods.

The supported options properties are:


  extent: (required) A two-element ([min, max]) array indicating the date range over which the bin values are defined.
  maxbins: The maximum number of allowable bins (default 40). There will often be fewer bins as the domain gets sliced at “nicely” rounded values.


Local Time Utilities

#
vega.timeFormat([specifier])
<>

Returns a function that takes a date or timestamp as input and returns a formatted string in the local timezone. If a string-valued format specifier is provided, it must follow the d3-time-format syntax. In this case, this method is equivalent to d3-time-format’s timeFormat method.

If an object-valued specifier is provided, a multi-format function will be generated, which selects among different format specifiers based on the granularity of the input date value (that is, values residing on a year, month, date, etc., boundary can all be formatted differently). The input object should use proper time unit strings for keys. If no time format specifier is provided, a default multi-format function is returned, equivalent to using the following specifier:

{
  "year": "%Y",
  "quarter": "%B",
  "month": "%B",
  "week": "%b %d",
  "date": "%a %d",
  "hours": "%I %p",
  "minutes": "%I:%M",
  "seconds": ":%S",
  "milliseconds": ".%L"
}


If an input specifier object omits any of these key values, a default value will be used. Note that for this method the "date" and "day" units are interchangeable; if both are defined the "date" entry take precedence.

#
vega.timeFloor(units[, step])
<>

Returns a function that performs flooring (truncation) of input dates to given time units in the local timezone. The units argument must be an array of valid time unit strings, for example ['year', 'month'] or ['week', 'date']. The optional step argument (default 1) indicates the number of time unit steps (of the smallest provided unit) to include as part of the truncation scheme. For example, timeFloor(['quarter']) is equivalent to timeFloor(['month'], 3).

#
vega.timeInterval(unit)
<>

Returns a d3-time interval for the given time unit in the local timezone.

#
vega.timeOffset(unit, date[, step])
<>

Returns a new Date instance that offsets the given date by the specified time unit in the local timezone. The optional step argument indicates the number of time unit steps to offset by (default 1).

#
vega.timeSequence(unit, start, stop[, step])
<>

Returns an array of Date instances from start (inclusive) to stop (exclusive), with each entry separated by the given time unit in the local timezone. The optional step argument indicates the number of time unit steps to take between each sequence entry (default 1).

#
vega.dayofyear(date)
<>

Returns the one-based day of the year for the given date, which should be either a Date object or timestamp value.

#
vega.week(date)
<>

Returns the week number of the year for the given date, which should be either a Date object or timestamp value. This function assumes Sunday-based weeks. Days before the first Sunday of the year are considered to be in week 0, the first Sunday of the year is the start of week 1, the second Sunday week 2, etc..

UTC Time Utilities

#
vega.utcFormat([specifier])
<>

Returns a function that takes a date or timestamp as input and returns a formatted string in Coordinated Universal Time (UTC). If a string-valued format specifier is provided, it must follow the d3-time-format syntax. In this case, this method is equivalent to d3-time-format’s utcFormat method.

This method also accepts object-valued specifiers for creating multi-format functions. If no argumennts are provided, a defualt multi-format function will be returned. For more details, see the timeFormat method documentation.

#
vega.utcFloor(units[, step])
<>

Returns a function that performs flooring (truncation) of input dates to given time units in Coordinated Universal Time (UTC). The units argument must be an array of valid time unit strings, for example ['year', 'month'] or ['week', 'date']. The optional step argument (default 1) indicates the number of time unit steps (of the smallest provided unit) to include as part of the truncation scheme. For example, utcFloor(['quarter']) is equivalent to utcFloor(['month'], 3).

#
vega.utcInterval(unit)
<>

Returns a d3-time interval for the given time unit in Coordinated Universal Time (UTC).

#
vega.utcOffset(unit, date[, step])
<>

Returns a new Date instance that offsets the given date by the specified time unit in Coordinated Universal Time (UTC). The optional step argument indicates the number of time unit steps to offset by (default 1).

#
vega.utcSequence(unit, start, stop[, step])
<>

Returns an array of Date instances from start (inclusive) to stop (exclusive), with each entry separated by the given time unit in Coordinated Universal Time (UTC). The optional step argument indicates the number of time unit steps to take between each sequence entry (default 1).

#
vega.utcweek(date)
<>

Returns the week number of the year for the given date in Coordinated Universal Time (UTC), which should be either a Date object or timestamp value. This function assumes Sunday-based weeks. Days before the first Sunday of the year are considered to be in week 0, the first Sunday of the year is the start of week 1, the second Sunday week 2, etc..\nJavaScript date-time utilities for Vega. Provides a set of helper methods for working with date objects (or, equivalently, with UNIX timestamps). These methods are bound to the top-level vega object, and can also be used in a stand-alone fashion by using the vega-time package. For more general utility methods, see the Utilities API reference.\nUtilities API reference\nTime Utilities API Reference\nThe date-time utilities support a set of pre-defined time units. A single unit value is one of the following strings:\n'year' - Gregorian calendar years.\n'quarter' - Three-month intervals, starting in one of January, April, July, and October.\n'month' - Calendar months (January, February, etc.).\n'date' - Calendar day of the month (January 1, January 2, etc.).\n'week' - Sunday-based weeks. Days before the first Sunday of the year are considered to be in week 0, the first Sunday of the year is the start of week 1, the second Sunday week 2, etc..\n'day' - Day of the week (Sunday, Monday, etc.).\n'dayofyear' - Day of the year (1, 2, …, 365, etc.).\n'hours' - Hours of the day (12:00am, 1:00am, etc.).\n'minutes' - Minutes in an hour (12:00, 12:01, etc.).\n'seconds' - Seconds in a minute (12:00:00, 12:00:01, etc.).\n'milliseconds' - Milliseconds in a second.\nMultiple units can be listed in an array to indicate desired intervals of time. For example, ['year', 'month', 'date'] indicates chronological time sensitive to year, month, and date (but not to hours, minutes, or seconds). The specifier ['month', 'date'] is sensitive to month and date, but not year, which can be useful for binning time values to look at seasonal patterns only.\n#
vega.timeUnits(units)
<>\nReturns a standardized and sorted specifier for the given units, which must be an array of one or more valid time unit strings. The returned array contains the same units, sorted in decreasing over of unit size, such that the most granular unit is last (for example, ['year', 'month', 'date']). This method throws an error if the units array is empty, contains an invalid unit, or contains incompatible units. Specifically, the 'quarter', 'month', and 'date' units can not be used in conjunction with the 'week' or 'day' units.\n#
vega.timeUnitSpecifier(units[, specifiers])
<>\nReturns a time format specifier string for the given time units. The optional specifiers object provides a set of desired specifier sub-strings for customizing the resulting time formats. The specifiers object may contain keys for both single time units ("year") and time unit sequences ("year-month-date"). This method will first standardize the input time units using the timeUnits method. It will then search, starting from the beginning of the units array, for the largest matching sequence defined in the specifiers object. Matching entries are then concatenated together, and the resulting string is whitespace-trimmed and returned.\nIf no specifiers object is provided, the following defaults are used:\n{
  "year": "%Y ",
  "year-month": "%Y-%m ",
  "year-month-date": "%Y-%m-%d ",
  "quarter": "Q%q ",
  "month": "%b ",
  "date": "%d ",
  "week": "W%U ",
  "day": "%a ",
  "hours": "%H:00",
  "hours-minutes": "%H:%M",
  "minutes": "00:%M",
  "seconds": ":%S",
  "milliseconds": ".%L"
}\n{
  "year": "%Y ",
  "year-month": "%Y-%m ",
  "year-month-date": "%Y-%m-%d ",
  "quarter": "Q%q ",
  "month": "%b ",
  "date": "%d ",
  "week": "W%U ",
  "day": "%a ",
  "hours": "%H:00",
  "hours-minutes": "%H:%M",
  "minutes": "00:%M",
  "seconds": ":%S",
  "milliseconds": ".%L"
}\nIf a specifiers object is provided, its values are merged with the defaults above. As a result, for complete control callees may wish to override the multi-unit "year-month", "year-month-date", and "hours-minutes" entries in addition to any individual unit entries. The input specifiers object can use a null value to invalidate an entry in the defaults.\n#
vega.timeBin(options)
<>\nDetermine a temporal binning scheme, for example to create a histogram. Based on the options provided given, this method will search over a space of possible time unit bins, applying constraints such as the maximum number of allowable bins. Given a set of options (see below), returns an object describing the binning scheme, in terms of units and step properties. These values can then be used as input to the timeFloor or utcFloor methods.\nThe supported options properties are:\nextent: (required) A two-element ([min, max]) array indicating the date range over which the bin values are defined.\nmaxbins: The maximum number of allowable bins (default 40). There will often be fewer bins as the domain gets sliced at “nicely” rounded values.\n#
vega.timeFormat([specifier])
<>\nReturns a function that takes a date or timestamp as input and returns a formatted string in the local timezone. If a string-valued format specifier is provided, it must follow the d3-time-format syntax. In this case, this method is equivalent to d3-time-format’s timeFormat method.\nIf an object-valued specifier is provided, a multi-format function will be generated, which selects among different format specifiers based on the granularity of the input date value (that is, values residing on a year, month, date, etc., boundary can all be formatted differently). The input object should use proper time unit strings for keys. If no time format specifier is provided, a default multi-format function is returned, equivalent to using the following specifier:\n{
  "year": "%Y",
  "quarter": "%B",
  "month": "%B",
  "week": "%b %d",
  "date": "%a %d",
  "hours": "%I %p",
  "minutes": "%I:%M",
  "seconds": ":%S",
  "milliseconds": ".%L"
}\n{
  "year": "%Y",
  "quarter": "%B",
  "month": "%B",
  "week": "%b %d",
  "date": "%a %d",
  "hours": "%I %p",
  "minutes": "%I:%M",
  "seconds": ":%S",
  "milliseconds": ".%L"
}\nIf an input specifier object omits any of these key values, a default value will be used. Note that for this method the "date" and "day" units are interchangeable; if both are defined the "date" entry take precedence.\n#
vega.timeFloor(units[, step])
<>\nReturns a function that performs flooring (truncation) of input dates to given time units in the local timezone. The units argument must be an array of valid time unit strings, for example ['year', 'month'] or ['week', 'date']. The optional step argument (default 1) indicates the number of time unit steps (of the smallest provided unit) to include as part of the truncation scheme. For example, timeFloor(['quarter']) is equivalent to timeFloor(['month'], 3).\n#
vega.timeInterval(unit)
<>\nReturns a d3-time interval for the given time unit in the local timezone.\n#
vega.timeOffset(unit, date[, step])
<>\nReturns a new Date instance that offsets the given date by the specified time unit in the local timezone. The optional step argument indicates the number of time unit steps to offset by (default 1).\n#
vega.timeSequence(unit, start, stop[, step])
<>\nReturns an array of Date instances from start (inclusive) to stop (exclusive), with each entry separated by the given time unit in the local timezone. The optional step argument indicates the number of time unit steps to take between each sequence entry (default 1).\n#
vega.dayofyear(date)
<>\nReturns the one-based day of the year for the given date, which should be either a Date object or timestamp value.\nReturns the week number of the year for the given date, which should be either a Date object or timestamp value. This function assumes Sunday-based weeks. Days before the first Sunday of the year are considered to be in week 0, the first Sunday of the year is the start of week 1, the second Sunday week 2, etc..\n#
vega.utcFormat([specifier])
<>\nReturns a function that takes a date or timestamp as input and returns a formatted string in Coordinated Universal Time (UTC). If a string-valued format specifier is provided, it must follow the d3-time-format syntax. In this case, this method is equivalent to d3-time-format’s utcFormat method.\nCoordinated Universal Time\nThis method also accepts object-valued specifiers for creating multi-format functions. If no argumennts are provided, a defualt multi-format function will be returned. For more details, see the timeFormat method documentation.\n#
vega.utcFloor(units[, step])
<>\nReturns a function that performs flooring (truncation) of input dates to given time units in Coordinated Universal Time (UTC). The units argument must be an array of valid time unit strings, for example ['year', 'month'] or ['week', 'date']. The optional step argument (default 1) indicates the number of time unit steps (of the smallest provided unit) to include as part of the truncation scheme. For example, utcFloor(['quarter']) is equivalent to utcFloor(['month'], 3).\nCoordinated Universal Time\n#
vega.utcInterval(unit)
<>\nReturns a d3-time interval for the given time unit in Coordinated Universal Time (UTC).\nCoordinated Universal Time\n#
vega.utcOffset(unit, date[, step])
<>\nReturns a new Date instance that offsets the given date by the specified time unit in Coordinated Universal Time (UTC). The optional step argument indicates the number of time unit steps to offset by (default 1).\nCoordinated Universal Time\n#
vega.utcSequence(unit, start, stop[, step])
<>\nReturns an array of Date instances from start (inclusive) to stop (exclusive), with each entry separated by the given time unit in Coordinated Universal Time (UTC). The optional step argument indicates the number of time unit steps to take between each sequence entry (default 1).\nCoordinated Universal Time\n#
vega.utcweek(date)
<>\nReturns the week number of the year for the given date in Coordinated Universal Time (UTC), which should be either a Date object or timestamp value. This function assumes Sunday-based weeks. Days before the first Sunday of the year are considered to be in week 0, the first Sunday of the year is the start of week 1, the second Sunday week 2, etc..\nCoordinated Universal Time\n\n\nVega
            
              Vega-Lite
              Altair
              Vega-Lite API
            
          
          
            
              Examples
              Tutorials
              Documentation
              Usage
              About
            
            
              GitHub
              Try Online
            
          
        
      

      
        

  
  
    
      
      
        Documentation
      
      
      
      
        Parser
      
      
      
      
        View
      
      
      
      
        Locale
      
      
      
      
        Extensibility
      
      
      
      
        Statistics
      
      
      
      
        Time
      
      
      
      
        Util
      
      
      
      
        Debugging
      
      
    
  
  
    Utilities API
    Vega uses a set of JavaScript utilities throughout its implementation, including function generators, type checkers, log messages, and additional utilities for Object, Array and String values. These methods are bound to the top-level vega object, and can also be used in a stand-alone fashion by using the vega-util package. For additional utility methods for date-time values, see the Time Utilities API reference.

Utilities API Reference


  Functions
  Type Checkers
  Type Coercion
  Objects
  Arrays
  Dates
  Logging
  Errors


Functions

Functions and function generators for accessing and comparing values.

#
vega.accessor(function[, fields, name])
<>

Annotates a function instance with a string array of dependent data fields and a string name, and returns the input function. Assumes the input function takes an object (data tuple) as input, and that strings in the fields array correspond to object properties accessed by the function. Once annotated, Vega dataflows can track data field dependencies and generate appropriate output names (e.g., when computing aggregations) if the function is used as an accessor.

Internally, this method assigns the field array to the fields property of the input function, and the name to the fname property. To be future-proof, clients should not access these properties directly. Instead, use the accessorFields and accessorName methods.

#
vega.accessorFields(accessor)
<>

Returns the array of dependent field names for a given accessor function. Returns null if no field names have been set.

#
vega.accessorName(accessor)
<>

Returns the name string for a given accessor function. Returns null if no name has been set.

#
vega.ascending(a, b)
<>

A comparator function for sorting primitive and Date values in ascending order.

#
vega.compare(fields[, orders])
<>

Generates a comparator function for sorting data values, based on the given set of fields and optional sort orders. The fields argument must be either a string, an accessor function, or an array of either. Strings indicate the name of object properties to sort by, in precedence order. Field strings may include nested properties (e.g., foo.bar.baz). The orders argument must be either a string or an array of strings; the valid string values are 'ascending' (for ascending sort order of the corresponding field) or 'descending' (for descending sort order of the corresponding field). If the orders argument is omitted, is shorter than the fields array, or includes values other than  'ascending' or 'descending', corresponding fields will default to ascending order.

#
vega.constant(value)
<>

Given an input value, returns a function that simply returns that value. If the input value is itself a function, that function is returned directly.

#
vega.debounce(delay, func)
<>

Generates a “debounced” function that delays invoking func until after delay milliseconds have elapsed since the last time the debounced function was invoked. Invocation passes up to one argument from the debounced function to func and does not preserve the this context.

#
vega.field(field[, name])
<>

Generates an accessor function for retrieving the specified field value. The input field string may include nested properties (e.g., foo.bar.baz). An optional name argument indicates the accessor name for the generated function; if excluded the field string will be used as the name (see the accessor method for more details).

var fooField = vega.field('foo');
fooField({foo: 5}); // 5
vega.accessorName(fooField); // 'foo'
vega.accessorFields(fooField); // ['foo']

var pathField = vega.field('foo.bar', 'path');
pathField({foo: {bar: 'vega'}}); // 'vega'
pathField({foo: 5}); // undefined
vega.accessorName(pathField); // 'path'
vega.accessorFields(pathField); // ['foo.bar']


#
vega.id(object)
<>

An accessor function that returns the value of the id property of an input object.

#
vega.identity(value)
<>

An accessor function that simply returns its value argument.

#
vega.key(fields[, flat])
<>

Generates an accessor function that returns a key string (suitable for using as an object property name) for a set of object fields. The fields argument must be either a string or string array, with each entry indicating a property of an input object to be used to produce representative key values. The resulting key function is an accessor instance with the accessor name 'key'. The optional flat argument is a boolean flag indicating if the field names should be treated as flat property names, side-stepping nested field lookups normally indicated by dot or bracket notation. By default, flat is false and nested property lookup is performed.

var keyf = vega.key(['foo', 'bar']);
keyf({foo:'hi', bar:5}); // 'hi|5'
vega.accessorName(keyf); // 'key'
vega.accessorFields(keyf); // ['foo', 'bar']


#
vega.one()
<>

An accessor function that simply returns the value one (1).

#
vega.zero()
<>

An accessor function that simply returns the value zero (0).

#
vega.truthy()
<>

An accessor function that simply returns the boolean true value.

#
vega.falsy()
<>

An accessor function that simply returns the boolean false value.

Type Checkers

Functions for checking the type of JavaScript values.

#
vega.isArray(value)
<>

Returns true if the input value is an Array instance, false otherwise.

#
vega.isBoolean(value)
<>

Returns true if the input value is a Boolean instance, false otherwise.

#
vega.isDate(value)
<>

Returns true if the input value is a Date instance, false otherwise.

#
vega.isFunction(value)
<>

Returns true if the input value is a Function instance, false otherwise.

#
vega.isIterable(value)
<>

Returns true if the input value supports the iterable protocol, false otherwise.

#
vega.isNumber(value)
<>

Returns true if the input value is a Number instance, false otherwise.

#
vega.isObject(value)
<>

Returns true if the input value is an Object instance, false otherwise.

#
vega.isRegExp(value)
<>

Returns true if the input value is a RegExp instance, false otherwise.

#
vega.isString(value)
<>

Returns true if the input value is a String instance, false otherwise.

Type Coercion

Functions for coercing values to a desired type.

#
vega.toBoolean(value)
<>

Coerces the input value to a boolean. The strings "true" and "1" map to true; the strings "false" and "0" map to false. Null values and empty strings are mapped to null.

#
vega.toDate(value[, parser])
<>

Coerces the input value to a Date timestamp. Null values and empty strings are mapped to null. Date objects are passed through unchanged. If an optional parser function is provided, it is used to perform date parsing. By default, numbers (timestamps) are passed through unchanged and otherwise Date.parse is used. Be aware that Date.parse has different implementations across browsers!

#
vega.toNumber(value)
<>

Coerces the input value to a number. Null values and empty strings are mapped to null.

#
vega.toString(value)
<>

Coerces the input value to a string. Null values and empty strings are mapped to null.

Objects

Functions for manipulating JavaScript Object values.

#
vega.extend(target[, source1, source2, …])
<>

Extends a target object by copying (in order) all enumerable properties of the input source objects.

#
vega.hasOwnProperty(object, property)
<>

Returns true if the input object has a named property defined on it, otherwise false. This method concerns the input object only, ignoring properties defined up the prototype chain. The method is equivalent to Object.hasOwnProperty, but improves security by guarding against overridden Object prototype built-ins.

#
vega.inherits(child, parent[, members])
<>

A convenience method for setting up object-oriented inheritance. Assigns the prototype property of the input child function, such that the child inherits the properties of the parent function’s prototype via prototypal inheritance. The optional members argument is an object containing methods or properties to add to the new child prototype. Returns the new child prototype object.

#
vega.lruCache([maxsize])
<>

Provides a key/value cache, keyed by string, that evicts least recently used (LRU) entries. Supports has, get, set, and clear methods. The optional maxsize argument (default 10,000) determines the maximum number of elements that can be added before items are evicted.

In the internal implementation two caches are used: a current cache and a previous cache. When then current cache fills, it becomes the previous cache and a new, empty current cache is created. Subsequent get calls will promote elements in the previous cache to the current cache. Once the current cache fills, the caches are again turned over and all LRU items still residing in the previous cache are dropped.

var cache = vega.lruCache(1); // use 1-element cache to demonstrate
cache.set('a', 1); // current cache has a->1
cache.set('b', 2); // current cache has b->2, previous cache has a->1
cache.get('a');    // -> 1 (a now in current cache, b in previous cache)
cache.set('c', 3); // current cache has c->3, previous cache has a->1
cache.has('c');    // -> true  (c is in the current cache)
cache.has('b');    // -> false (b has been evicted)
cache.has('a');    // -> true  (a is in the previous cache)
cache.get('c');    // -> 3
cache.clear();


#
vega.fastmap([object])
<>

Provides a key/value map data structure, keyed by string. Supports a subset of the ES6 Map API, including has, get, set, delete and clear methods and a size property. If the optional object argument is provided, all key/values on the input object will be added to the new map instance.

var map = vega.fastmap({foo:1, bar:2});
map.has('foo'); // -> true
map.get('foo'); // -> 1
map.delete('bar');
map.has('bar'); // -> false
map.set('baz', 0);
map.get('baz'); // -> 0
map.size; // -> 2
map.empty; // -> 1 (number of empty entries)
map.clean(); // invoke garbage collection, clears empty entries


By using basic JavaScript objects to hash values and avoiding calls to the built-in JavaScript delete operator, fastmaps provide good performance. However, this speed comes at the cost of some object bloat, requiring periodic garbage collection in the case of many deletions. The fastmap object provides a clean method for requesting garbage collection of empty map entries. The test method is a getter/setter for providing an optional boolean-valued function that indicates additional objects (not just empty entries from deleted keys) that should be removed during garbage collection.

#
vega.mergeConfig(…config)
<>

Merges a collection of Vega configuration objects into a single combined object. Configuration objects with higher index positions in the arguments list have higher precedence, and so may override settings provided by earlier objects.

#
vega.writeConfig(config, key, value[, recurse])
<>

Writes a value to a Vega configuration object. Given a config object and a configuration property key and value, appropriately assign the value to the config object. The recurse parameter controls if recursive merging (as opposed to overwriting) is performed: if false or undefined, no recursion is performed; if true one level of recursive merge is performed; if recurse is object-valued, one level of recursive merge is performed for keys that the recurse object maps to a truthy value. This method is a helper method used within mergeConfig.

Arrays

Functions for manipulating JavaScript Array values.

#
vega.array(value)
<>

Ensures that the input value is an Array instance. If so, the value is simply returned. If not, the value is wrapped within a new single-element an array, returning [value].

#
vega.clampRange(range, min, max)
<>

Span-preserving range clamp. If the span of the input range is less than (max - min) and an endpoint exceeds either the min or max value, the range is translated such that the span is preserved and one endpoint touches the boundary of the min/max range. If the span exceeds (max - min), returns the range [min, max].

#
vega.extent(array[, accessor])
<>

Returns an array with the minimum and maximum values in the input array, in the form [min, max]. Ignores null, undefined, and NaN values. The optional accessor argument provides a function that is first applied to each array value prior to comparison.

#
vega.extentIndex(array[, accessor])
<>

Returns the array indices for the minimum and maximum values in the input array (as a [minIndex, maxIndex] array), according to natural ordering. The optional accessor argument provides a function that is first applied to each array value prior to comparison.

vega.extentIndex([1,5,3,0,4,2]); // [3, 1]
vega.extentIndex([
  {a: 3, b:2},
  {a: 2, b:1},
  {a: 1, b:3}
], vega.field('b')); // [1, 2]


#
vega.flush(range, value, threshold, left, right, center)
<>

Selects among potential return values if the provided value is flush with the input numeric range. Returns left if value is within the *threshold distance of the minimum element of the range. Returns right if value is within the *threshold distance of the maximum element of the range. Otherwise, returns center.

#
vega.inrange(value, range[, left, right])
<>

Returns true if the input value lies within the span of the given range array. The left and right boolean flags control the use of inclusive (true) or exclusive (false) comparisons; if unspecified, inclusive tests are used.

#
vega.lerp(array, fraction)
<>

Returns the linearly interpolated value between the first and last entries in the array for the provided interpolation fraction (typically between 0 and 1). For example, lerp([0, 50], 0.5) returns 25.

#
vega.merge(compare, array1, array2[, output])
<>

Merge two sorted arrays into a single sorted array. The input compare function is a comparator for sorting elements and should correspond to the pre-sorted orders of the array1 and array2 source arrays. The merged array contents are written to the output array, if provided. If output is not specified, a new array is generated and returned.

#
vega.panLinear(domain, delta)
<>

Given an input numeric domain (sorted in increasing order), returns a new domain array that translates the domain by a delta using a linear transform. The delta value is expressed as a fraction of the current domain span, and may be positive or negative to indicate the translation direction. The return value is a two-element array indicating the starting and ending value of the translated (panned) domain.

#
vega.panLog(domain, delta)
<>

Given an input numeric domain (sorted in increasing order), returns a new domain array that translates the domain by a delta using a logarithmic transform. The delta value is expressed as a fraction of the current domain span, and may be positive or negative to indicate the translation direction. The return value is a two-element array indicating the starting and ending value of the translated (panned) domain.

#
vega.panPow(domain, delta, exponent)
<>

Given an input numeric domain (sorted in increasing order), returns a new domain array that translates the domain by a delta using a power scale transform parameterized by the provided exponent. The delta value is expressed as a fraction of the current domain span, and may be positive or negative to indicate the translation direction. The return value is a two-element array indicating the starting and ending value of the translated (panned) domain.

#
vega.panSymlog(domain, delta, constant)
<>

Given an input numeric domain (sorted in increasing order), returns a new domain array that translates the domain by a delta using a symlog (symmetric log) scale transform parameterized by the provided constant. The delta value is expressed as a fraction of the current domain span, and may be positive or negative to indicate the translation direction. The return value is a two-element array indicating the starting and ending value of the translated (panned) domain.

#
vega.peek(array)
<>

Returns the last element in the input array. Similar to the built-in Array.pop method, except that it does not remove the last element. This method is a convenient shorthand for array[array.length - 1].

#
vega.span(array)
<>

Returns the numerical span of the input array: the difference between the last and first values.

#
vega.toSet(array)
<>

Given an input array of values, returns a new Object instance whose property keys are the values in array, each assigned a property value of 1. Each value in array is coerced to a String value and so should map to a reasonable string key value.

vega.toSet([1, 2, 3]); // {'1':1, '2':1, '3':1}


#
vega.visitArray(array, [filter,] visitor)
<>

Vists the values in an input array, invoking the visitor function for each array value that passes an optional filter. If specified, the filter function is called with each individual array value. If the filter function return value is truthy, the returned value is then passed as input to the visitor function. Thus, the filter not only performs filtering, it can serve as a value transformer. If the filter function is not specified, all values in the array are passed to the visitor function. Similar to the built-in Array.forEach method, the visitor function is invoked with three arguments: the value to visit, the current index into the source array, and a reference to the soure array.

// console output: 1 0; 3 2
vega.visitArray([0, -1, 2],
  function(x) { return x + 1; },
  function(v, i, array) { console.log(v, i); });


#
vega.zoomLinear(domain, anchor, scale)
<>

Given an input numeric domain (sorted in increasing order), returns a new domain array that scales (zooms) the domain by a scale factor using a linear transform, centered on the given anchor value. If anchor is null, the midpoint of the domain is used instead. The return value is a two-element array indicating the starting and ending value of the scaled (zoomed) domain.

#
vega.zoomLog(domain, anchor, scale)
<>

Given an input numeric domain (sorted in increasing order), returns a new domain array that scales (zooms) the domain by a scale factor using a logarithmic transform, centered on the given anchor value. If anchor is null, the midpoint of the domain is used instead. The return value is a two-element array indicating the starting and ending value of the scaled (zoomed) domain.

#
vega.zoomPow(domain, anchor, scale, exponent)
<>

Given an input numeric domain (sorted in increasing order), returns a new domain array that scales (zooms) the domain by a scale factor using a power scale transform parameterized by the provided exponent, centered on the given anchor value. If anchor is null, the midpoint of the domain is used instead. The return value is a two-element array indicating the starting and ending value of the scaled (zoomed) domain.

#
vega.zoomSymlog(domain, anchor, scale, constant)
<>

Given an input numeric domain (sorted in increasing order), returns a new domain array that scales (zooms) the domain by a scale factor using a symlog (symmetric log) scale transform parameterized by the provided constant, centered on the given anchor value. If anchor is null, the midpoint of the domain is used instead. The return value is a two-element array indicating the starting and ending value of the scaled (zoomed) domain.

Dates

Functions for manipulating JavaScript Date values.

#
vega.quarter(date)
<>

Returns the quarter of the year (an integer between 1 and 4) for an input date object or timestamp for the local timezone.

#
vega.utcquarter(date)
<>

Returns the quarter of the year (an integer between 1 and 4) for an input date object or timestamp for Coordinated Universal Time (UTC).

Strings

Functions for generating and manipulating JavaScript String values.

#
vega.pad(string, length[, character, align])
<>

Pads a string value with repeated instances of a character up to a specified length. If character is not specified, a space (' ') is used. By default, padding is added to the end of a string. An optional align parameter specifies if padding should be added to the 'left' (beginning), 'center', or 'right' (end) of the input string.

vega.pad('15', 5, '0', 'left'); // '00015'


#
vega.repeat(string, count)
<>

Given an input string, returns a new string that repeats the input count times.

vega.repeat('0', 5); // '00000'


#
vega.splitAccessPath(path)
<>

Splits an input string representing an access path for JavaScript object properties into an array of constituent path elements.

vega.splitAccessPath('foo'); // ['foo']
vega.splitAccessPath('foo.bar'); // ['foo', 'bar']
vega.splitAccessPath('foo["bar"]'); // ['foo', 'bar']
vega.splitAccessPath('foo[0].bar'); // ['foo', '0', 'bar']


#
vega.stringValue(value)
<>

Returns an output representation of an input value that is both JSON and JavaScript compliant. For Object and String values, JSON.stringify is used to generate the output string. Primitive types such as Number or Boolean are returned as-is. This method can be used to generate values that can then be included in runtime-compiled code snippets (for example, via the Function constructor).

#
vega.truncate(string, length[, align, ellipsis])
<>

Truncates an input string to a target length. The optional align argument indicates what part of the string should be truncated: 'left' (the beginning), 'center', or 'right' (the end). By default, the 'right' end of the string is truncated. The optional ellipsis argument indicates the string to use to indicate truncated content; by default the ellipsis character (…, same as \u2026) is used.

Logging

#
vega.logger([level, method])
<>

Generates a new logger instance for selectively writing log messages to the JavaScript console. The optional level argument indicates the initial log level to use (one of None, Warn, Info, or Debug), and defaults to None if not specified.

The generated logger instance provides the following methods:


  level(value): Sets the current logging level. Only messages with a log level less than or equal to value will be written to the console.
  error(message1[, message2, …]): Logs an error message. The messages will be written to the console using the console.error method if the current log level is Error or higher.
  warn(message1[, message2, …]): Logs a warning message. The messages will be written to the console using the console.warn method if the current log level is Warn or higher.
  info(message1[, message2, …]): Logs an informative message. The messages will be written to the console using the console.log method if the current log level is Info or higher.
  debug(message1[, message2, …]): Logs a debugging message. The messages will be written to the console using the console.log method if the current log level is Debug or higher.


To override the choice of console method invoked (console.log, console.warn, or console.error), use the optional method argument (one of "log", "warn", or "error") to route all log messages through the same method.

#
vega.None
<>

Constant value indicating a log level of ‘None’. If set as the log level of a logger instance, all log messages will be suppressed.

#
vega.Error
<>

Constant value indicating a log level of ‘Error’. If set as the log level of a logger instance, only error messages will be presented.

#
vega.Warn
<>

Constant value indicating a log level of ‘Warn’. If set as the log level of a logger instance, both error and warning messages will be presented.

#
vega.Info
<>

Constant value indicating a log level of ‘Info’. If set as the log level of a logger instance, error, warning and info messages will be presented.

#
vega.Debug
<>

Constant value indicating a log level of ‘Debug’. If set as the log level of a logger instance, all log messages (error, warning, info and debug) will be presented.

Errors

#
vega.error(message)
<>

Throws a new error with the provided error message. This is a convenience method adding a layer of indirection for error handling, for example allowing error conditions to be included in expression chains.

vega.error('Uh oh'); // equivalent to: throw Error('Uh oh')

// embed error in an expression
return isOk ? returnValue : vega.error('Not OK');\nVega
            
              Vega-Lite
              Altair
              Vega-Lite API\nVega-Lite
              Altair
              Vega-Lite API\nExamples
              Tutorials
              Documentation
              Usage
              About
            
            
              GitHub
              Try Online\nExamples
              Tutorials
              Documentation
              Usage
              About\nGitHub
              Try Online\nDocumentation
      
      
      
      
        Parser
      
      
      
      
        View
      
      
      
      
        Locale
      
      
      
      
        Extensibility
      
      
      
      
        Statistics
      
      
      
      
        Time
      
      
      
      
        Util
      
      
      
      
        Debugging
      
      
    
  
  
    Utilities API
    Vega uses a set of JavaScript utilities throughout its implementation, including function generators, type checkers, log messages, and additional utilities for Object, Array and String values. These methods are bound to the top-level vega object, and can also be used in a stand-alone fashion by using the vega-util package. For additional utility methods for date-time values, see the Time Utilities API reference.

Utilities API Reference


  Functions
  Type Checkers
  Type Coercion
  Objects
  Arrays
  Dates
  Logging
  Errors


Functions

Functions and function generators for accessing and comparing values.

#
vega.accessor(function[, fields, name])
<>

Annotates a function instance with a string array of dependent data fields and a string name, and returns the input function. Assumes the input function takes an object (data tuple) as input, and that strings in the fields array correspond to object properties accessed by the function. Once annotated, Vega dataflows can track data field dependencies and generate appropriate output names (e.g., when computing aggregations) if the function is used as an accessor.

Internally, this method assigns the field array to the fields property of the input function, and the name to the fname property. To be future-proof, clients should not access these properties directly. Instead, use the accessorFields and accessorName methods.

#
vega.accessorFields(accessor)
<>

Returns the array of dependent field names for a given accessor function. Returns null if no field names have been set.

#
vega.accessorName(accessor)
<>

Returns the name string for a given accessor function. Returns null if no name has been set.

#
vega.ascending(a, b)
<>

A comparator function for sorting primitive and Date values in ascending order.

#
vega.compare(fields[, orders])
<>

Generates a comparator function for sorting data values, based on the given set of fields and optional sort orders. The fields argument must be either a string, an accessor function, or an array of either. Strings indicate the name of object properties to sort by, in precedence order. Field strings may include nested properties (e.g., foo.bar.baz). The orders argument must be either a string or an array of strings; the valid string values are 'ascending' (for ascending sort order of the corresponding field) or 'descending' (for descending sort order of the corresponding field). If the orders argument is omitted, is shorter than the fields array, or includes values other than  'ascending' or 'descending', corresponding fields will default to ascending order.

#
vega.constant(value)
<>

Given an input value, returns a function that simply returns that value. If the input value is itself a function, that function is returned directly.

#
vega.debounce(delay, func)
<>

Generates a “debounced” function that delays invoking func until after delay milliseconds have elapsed since the last time the debounced function was invoked. Invocation passes up to one argument from the debounced function to func and does not preserve the this context.

#
vega.field(field[, name])
<>

Generates an accessor function for retrieving the specified field value. The input field string may include nested properties (e.g., foo.bar.baz). An optional name argument indicates the accessor name for the generated function; if excluded the field string will be used as the name (see the accessor method for more details).

var fooField = vega.field('foo');
fooField({foo: 5}); // 5
vega.accessorName(fooField); // 'foo'
vega.accessorFields(fooField); // ['foo']

var pathField = vega.field('foo.bar', 'path');
pathField({foo: {bar: 'vega'}}); // 'vega'
pathField({foo: 5}); // undefined
vega.accessorName(pathField); // 'path'
vega.accessorFields(pathField); // ['foo.bar']


#
vega.id(object)
<>

An accessor function that returns the value of the id property of an input object.

#
vega.identity(value)
<>

An accessor function that simply returns its value argument.

#
vega.key(fields[, flat])
<>

Generates an accessor function that returns a key string (suitable for using as an object property name) for a set of object fields. The fields argument must be either a string or string array, with each entry indicating a property of an input object to be used to produce representative key values. The resulting key function is an accessor instance with the accessor name 'key'. The optional flat argument is a boolean flag indicating if the field names should be treated as flat property names, side-stepping nested field lookups normally indicated by dot or bracket notation. By default, flat is false and nested property lookup is performed.

var keyf = vega.key(['foo', 'bar']);
keyf({foo:'hi', bar:5}); // 'hi|5'
vega.accessorName(keyf); // 'key'
vega.accessorFields(keyf); // ['foo', 'bar']


#
vega.one()
<>

An accessor function that simply returns the value one (1).

#
vega.zero()
<>

An accessor function that simply returns the value zero (0).

#
vega.truthy()
<>

An accessor function that simply returns the boolean true value.

#
vega.falsy()
<>

An accessor function that simply returns the boolean false value.

Type Checkers

Functions for checking the type of JavaScript values.

#
vega.isArray(value)
<>

Returns true if the input value is an Array instance, false otherwise.

#
vega.isBoolean(value)
<>

Returns true if the input value is a Boolean instance, false otherwise.

#
vega.isDate(value)
<>

Returns true if the input value is a Date instance, false otherwise.

#
vega.isFunction(value)
<>

Returns true if the input value is a Function instance, false otherwise.

#
vega.isIterable(value)
<>

Returns true if the input value supports the iterable protocol, false otherwise.

#
vega.isNumber(value)
<>

Returns true if the input value is a Number instance, false otherwise.

#
vega.isObject(value)
<>

Returns true if the input value is an Object instance, false otherwise.

#
vega.isRegExp(value)
<>

Returns true if the input value is a RegExp instance, false otherwise.

#
vega.isString(value)
<>

Returns true if the input value is a String instance, false otherwise.

Type Coercion

Functions for coercing values to a desired type.

#
vega.toBoolean(value)
<>

Coerces the input value to a boolean. The strings "true" and "1" map to true; the strings "false" and "0" map to false. Null values and empty strings are mapped to null.

#
vega.toDate(value[, parser])
<>

Coerces the input value to a Date timestamp. Null values and empty strings are mapped to null. Date objects are passed through unchanged. If an optional parser function is provided, it is used to perform date parsing. By default, numbers (timestamps) are passed through unchanged and otherwise Date.parse is used. Be aware that Date.parse has different implementations across browsers!

#
vega.toNumber(value)
<>

Coerces the input value to a number. Null values and empty strings are mapped to null.

#
vega.toString(value)
<>

Coerces the input value to a string. Null values and empty strings are mapped to null.

Objects

Functions for manipulating JavaScript Object values.

#
vega.extend(target[, source1, source2, …])
<>

Extends a target object by copying (in order) all enumerable properties of the input source objects.

#
vega.hasOwnProperty(object, property)
<>

Returns true if the input object has a named property defined on it, otherwise false. This method concerns the input object only, ignoring properties defined up the prototype chain. The method is equivalent to Object.hasOwnProperty, but improves security by guarding against overridden Object prototype built-ins.

#
vega.inherits(child, parent[, members])
<>

A convenience method for setting up object-oriented inheritance. Assigns the prototype property of the input child function, such that the child inherits the properties of the parent function’s prototype via prototypal inheritance. The optional members argument is an object containing methods or properties to add to the new child prototype. Returns the new child prototype object.

#
vega.lruCache([maxsize])
<>

Provides a key/value cache, keyed by string, that evicts least recently used (LRU) entries. Supports has, get, set, and clear methods. The optional maxsize argument (default 10,000) determines the maximum number of elements that can be added before items are evicted.

In the internal implementation two caches are used: a current cache and a previous cache. When then current cache fills, it becomes the previous cache and a new, empty current cache is created. Subsequent get calls will promote elements in the previous cache to the current cache. Once the current cache fills, the caches are again turned over and all LRU items still residing in the previous cache are dropped.

var cache = vega.lruCache(1); // use 1-element cache to demonstrate
cache.set('a', 1); // current cache has a->1
cache.set('b', 2); // current cache has b->2, previous cache has a->1
cache.get('a');    // -> 1 (a now in current cache, b in previous cache)
cache.set('c', 3); // current cache has c->3, previous cache has a->1
cache.has('c');    // -> true  (c is in the current cache)
cache.has('b');    // -> false (b has been evicted)
cache.has('a');    // -> true  (a is in the previous cache)
cache.get('c');    // -> 3
cache.clear();


#
vega.fastmap([object])
<>

Provides a key/value map data structure, keyed by string. Supports a subset of the ES6 Map API, including has, get, set, delete and clear methods and a size property. If the optional object argument is provided, all key/values on the input object will be added to the new map instance.

var map = vega.fastmap({foo:1, bar:2});
map.has('foo'); // -> true
map.get('foo'); // -> 1
map.delete('bar');
map.has('bar'); // -> false
map.set('baz', 0);
map.get('baz'); // -> 0
map.size; // -> 2
map.empty; // -> 1 (number of empty entries)
map.clean(); // invoke garbage collection, clears empty entries


By using basic JavaScript objects to hash values and avoiding calls to the built-in JavaScript delete operator, fastmaps provide good performance. However, this speed comes at the cost of some object bloat, requiring periodic garbage collection in the case of many deletions. The fastmap object provides a clean method for requesting garbage collection of empty map entries. The test method is a getter/setter for providing an optional boolean-valued function that indicates additional objects (not just empty entries from deleted keys) that should be removed during garbage collection.

#
vega.mergeConfig(…config)
<>

Merges a collection of Vega configuration objects into a single combined object. Configuration objects with higher index positions in the arguments list have higher precedence, and so may override settings provided by earlier objects.

#
vega.writeConfig(config, key, value[, recurse])
<>

Writes a value to a Vega configuration object. Given a config object and a configuration property key and value, appropriately assign the value to the config object. The recurse parameter controls if recursive merging (as opposed to overwriting) is performed: if false or undefined, no recursion is performed; if true one level of recursive merge is performed; if recurse is object-valued, one level of recursive merge is performed for keys that the recurse object maps to a truthy value. This method is a helper method used within mergeConfig.

Arrays

Functions for manipulating JavaScript Array values.

#
vega.array(value)
<>

Ensures that the input value is an Array instance. If so, the value is simply returned. If not, the value is wrapped within a new single-element an array, returning [value].

#
vega.clampRange(range, min, max)
<>

Span-preserving range clamp. If the span of the input range is less than (max - min) and an endpoint exceeds either the min or max value, the range is translated such that the span is preserved and one endpoint touches the boundary of the min/max range. If the span exceeds (max - min), returns the range [min, max].

#
vega.extent(array[, accessor])
<>

Returns an array with the minimum and maximum values in the input array, in the form [min, max]. Ignores null, undefined, and NaN values. The optional accessor argument provides a function that is first applied to each array value prior to comparison.

#
vega.extentIndex(array[, accessor])
<>

Returns the array indices for the minimum and maximum values in the input array (as a [minIndex, maxIndex] array), according to natural ordering. The optional accessor argument provides a function that is first applied to each array value prior to comparison.

vega.extentIndex([1,5,3,0,4,2]); // [3, 1]
vega.extentIndex([
  {a: 3, b:2},
  {a: 2, b:1},
  {a: 1, b:3}
], vega.field('b')); // [1, 2]


#
vega.flush(range, value, threshold, left, right, center)
<>

Selects among potential return values if the provided value is flush with the input numeric range. Returns left if value is within the *threshold distance of the minimum element of the range. Returns right if value is within the *threshold distance of the maximum element of the range. Otherwise, returns center.

#
vega.inrange(value, range[, left, right])
<>

Returns true if the input value lies within the span of the given range array. The left and right boolean flags control the use of inclusive (true) or exclusive (false) comparisons; if unspecified, inclusive tests are used.

#
vega.lerp(array, fraction)
<>

Returns the linearly interpolated value between the first and last entries in the array for the provided interpolation fraction (typically between 0 and 1). For example, lerp([0, 50], 0.5) returns 25.

#
vega.merge(compare, array1, array2[, output])
<>

Merge two sorted arrays into a single sorted array. The input compare function is a comparator for sorting elements and should correspond to the pre-sorted orders of the array1 and array2 source arrays. The merged array contents are written to the output array, if provided. If output is not specified, a new array is generated and returned.

#
vega.panLinear(domain, delta)
<>

Given an input numeric domain (sorted in increasing order), returns a new domain array that translates the domain by a delta using a linear transform. The delta value is expressed as a fraction of the current domain span, and may be positive or negative to indicate the translation direction. The return value is a two-element array indicating the starting and ending value of the translated (panned) domain.

#
vega.panLog(domain, delta)
<>

Given an input numeric domain (sorted in increasing order), returns a new domain array that translates the domain by a delta using a logarithmic transform. The delta value is expressed as a fraction of the current domain span, and may be positive or negative to indicate the translation direction. The return value is a two-element array indicating the starting and ending value of the translated (panned) domain.

#
vega.panPow(domain, delta, exponent)
<>

Given an input numeric domain (sorted in increasing order), returns a new domain array that translates the domain by a delta using a power scale transform parameterized by the provided exponent. The delta value is expressed as a fraction of the current domain span, and may be positive or negative to indicate the translation direction. The return value is a two-element array indicating the starting and ending value of the translated (panned) domain.

#
vega.panSymlog(domain, delta, constant)
<>

Given an input numeric domain (sorted in increasing order), returns a new domain array that translates the domain by a delta using a symlog (symmetric log) scale transform parameterized by the provided constant. The delta value is expressed as a fraction of the current domain span, and may be positive or negative to indicate the translation direction. The return value is a two-element array indicating the starting and ending value of the translated (panned) domain.

#
vega.peek(array)
<>

Returns the last element in the input array. Similar to the built-in Array.pop method, except that it does not remove the last element. This method is a convenient shorthand for array[array.length - 1].

#
vega.span(array)
<>

Returns the numerical span of the input array: the difference between the last and first values.

#
vega.toSet(array)
<>

Given an input array of values, returns a new Object instance whose property keys are the values in array, each assigned a property value of 1. Each value in array is coerced to a String value and so should map to a reasonable string key value.

vega.toSet([1, 2, 3]); // {'1':1, '2':1, '3':1}


#
vega.visitArray(array, [filter,] visitor)
<>

Vists the values in an input array, invoking the visitor function for each array value that passes an optional filter. If specified, the filter function is called with each individual array value. If the filter function return value is truthy, the returned value is then passed as input to the visitor function. Thus, the filter not only performs filtering, it can serve as a value transformer. If the filter function is not specified, all values in the array are passed to the visitor function. Similar to the built-in Array.forEach method, the visitor function is invoked with three arguments: the value to visit, the current index into the source array, and a reference to the soure array.

// console output: 1 0; 3 2
vega.visitArray([0, -1, 2],
  function(x) { return x + 1; },
  function(v, i, array) { console.log(v, i); });


#
vega.zoomLinear(domain, anchor, scale)
<>

Given an input numeric domain (sorted in increasing order), returns a new domain array that scales (zooms) the domain by a scale factor using a linear transform, centered on the given anchor value. If anchor is null, the midpoint of the domain is used instead. The return value is a two-element array indicating the starting and ending value of the scaled (zoomed) domain.

#
vega.zoomLog(domain, anchor, scale)
<>

Given an input numeric domain (sorted in increasing order), returns a new domain array that scales (zooms) the domain by a scale factor using a logarithmic transform, centered on the given anchor value. If anchor is null, the midpoint of the domain is used instead. The return value is a two-element array indicating the starting and ending value of the scaled (zoomed) domain.

#
vega.zoomPow(domain, anchor, scale, exponent)
<>

Given an input numeric domain (sorted in increasing order), returns a new domain array that scales (zooms) the domain by a scale factor using a power scale transform parameterized by the provided exponent, centered on the given anchor value. If anchor is null, the midpoint of the domain is used instead. The return value is a two-element array indicating the starting and ending value of the scaled (zoomed) domain.

#
vega.zoomSymlog(domain, anchor, scale, constant)
<>

Given an input numeric domain (sorted in increasing order), returns a new domain array that scales (zooms) the domain by a scale factor using a symlog (symmetric log) scale transform parameterized by the provided constant, centered on the given anchor value. If anchor is null, the midpoint of the domain is used instead. The return value is a two-element array indicating the starting and ending value of the scaled (zoomed) domain.

Dates

Functions for manipulating JavaScript Date values.

#
vega.quarter(date)
<>

Returns the quarter of the year (an integer between 1 and 4) for an input date object or timestamp for the local timezone.

#
vega.utcquarter(date)
<>

Returns the quarter of the year (an integer between 1 and 4) for an input date object or timestamp for Coordinated Universal Time (UTC).

Strings

Functions for generating and manipulating JavaScript String values.

#
vega.pad(string, length[, character, align])
<>

Pads a string value with repeated instances of a character up to a specified length. If character is not specified, a space (' ') is used. By default, padding is added to the end of a string. An optional align parameter specifies if padding should be added to the 'left' (beginning), 'center', or 'right' (end) of the input string.

vega.pad('15', 5, '0', 'left'); // '00015'


#
vega.repeat(string, count)
<>

Given an input string, returns a new string that repeats the input count times.

vega.repeat('0', 5); // '00000'


#
vega.splitAccessPath(path)
<>

Splits an input string representing an access path for JavaScript object properties into an array of constituent path elements.

vega.splitAccessPath('foo'); // ['foo']
vega.splitAccessPath('foo.bar'); // ['foo', 'bar']
vega.splitAccessPath('foo["bar"]'); // ['foo', 'bar']
vega.splitAccessPath('foo[0].bar'); // ['foo', '0', 'bar']


#
vega.stringValue(value)
<>

Returns an output representation of an input value that is both JSON and JavaScript compliant. For Object and String values, JSON.stringify is used to generate the output string. Primitive types such as Number or Boolean are returned as-is. This method can be used to generate values that can then be included in runtime-compiled code snippets (for example, via the Function constructor).

#
vega.truncate(string, length[, align, ellipsis])
<>

Truncates an input string to a target length. The optional align argument indicates what part of the string should be truncated: 'left' (the beginning), 'center', or 'right' (the end). By default, the 'right' end of the string is truncated. The optional ellipsis argument indicates the string to use to indicate truncated content; by default the ellipsis character (…, same as \u2026) is used.

Logging

#
vega.logger([level, method])
<>

Generates a new logger instance for selectively writing log messages to the JavaScript console. The optional level argument indicates the initial log level to use (one of None, Warn, Info, or Debug), and defaults to None if not specified.

The generated logger instance provides the following methods:


  level(value): Sets the current logging level. Only messages with a log level less than or equal to value will be written to the console.
  error(message1[, message2, …]): Logs an error message. The messages will be written to the console using the console.error method if the current log level is Error or higher.
  warn(message1[, message2, …]): Logs a warning message. The messages will be written to the console using the console.warn method if the current log level is Warn or higher.
  info(message1[, message2, …]): Logs an informative message. The messages will be written to the console using the console.log method if the current log level is Info or higher.
  debug(message1[, message2, …]): Logs a debugging message. The messages will be written to the console using the console.log method if the current log level is Debug or higher.


To override the choice of console method invoked (console.log, console.warn, or console.error), use the optional method argument (one of "log", "warn", or "error") to route all log messages through the same method.

#
vega.None
<>

Constant value indicating a log level of ‘None’. If set as the log level of a logger instance, all log messages will be suppressed.

#
vega.Error
<>

Constant value indicating a log level of ‘Error’. If set as the log level of a logger instance, only error messages will be presented.

#
vega.Warn
<>

Constant value indicating a log level of ‘Warn’. If set as the log level of a logger instance, both error and warning messages will be presented.

#
vega.Info
<>

Constant value indicating a log level of ‘Info’. If set as the log level of a logger instance, error, warning and info messages will be presented.

#
vega.Debug
<>

Constant value indicating a log level of ‘Debug’. If set as the log level of a logger instance, all log messages (error, warning, info and debug) will be presented.

Errors

#
vega.error(message)
<>

Throws a new error with the provided error message. This is a convenience method adding a layer of indirection for error handling, for example allowing error conditions to be included in expression chains.

vega.error('Uh oh'); // equivalent to: throw Error('Uh oh')

// embed error in an expression
return isOk ? returnValue : vega.error('Not OK');\nVega uses a set of JavaScript utilities throughout its implementation, including function generators, type checkers, log messages, and additional utilities for Object, Array and String values. These methods are bound to the top-level vega object, and can also be used in a stand-alone fashion by using the vega-util package. For additional utility methods for date-time values, see the Time Utilities API reference.\nTime Utilities API reference\nUtilities API Reference\nFunctions and function generators for accessing and comparing values.\n#
vega.accessor(function[, fields, name])
<>\nAnnotates a function instance with a string array of dependent data fields and a string name, and returns the input function. Assumes the input function takes an object (data tuple) as input, and that strings in the fields array correspond to object properties accessed by the function. Once annotated, Vega dataflows can track data field dependencies and generate appropriate output names (e.g., when computing aggregations) if the function is used as an accessor.\nInternally, this method assigns the field array to the fields property of the input function, and the name to the fname property. To be future-proof, clients should not access these properties directly. Instead, use the accessorFields and accessorName methods.\n#
vega.accessorFields(accessor)
<>\nReturns the array of dependent field names for a given accessor function. Returns null if no field names have been set.\n#
vega.accessorName(accessor)
<>\nReturns the name string for a given accessor function. Returns null if no name has been set.\n#
vega.ascending(a, b)
<>\nA comparator function for sorting primitive and Date values in ascending order.\n#
vega.compare(fields[, orders])
<>\nGenerates a comparator function for sorting data values, based on the given set of fields and optional sort orders. The fields argument must be either a string, an accessor function, or an array of either. Strings indicate the name of object properties to sort by, in precedence order. Field strings may include nested properties (e.g., foo.bar.baz). The orders argument must be either a string or an array of strings; the valid string values are 'ascending' (for ascending sort order of the corresponding field) or 'descending' (for descending sort order of the corresponding field). If the orders argument is omitted, is shorter than the fields array, or includes values other than  'ascending' or 'descending', corresponding fields will default to ascending order.\n#
vega.constant(value)
<>\nGiven an input value, returns a function that simply returns that value. If the input value is itself a function, that function is returned directly.\n#
vega.debounce(delay, func)
<>\nGenerates a “debounced” function that delays invoking func until after delay milliseconds have elapsed since the last time the debounced function was invoked. Invocation passes up to one argument from the debounced function to func and does not preserve the this context.\n#
vega.field(field[, name])
<>\nGenerates an accessor function for retrieving the specified field value. The input field string may include nested properties (e.g., foo.bar.baz). An optional name argument indicates the accessor name for the generated function; if excluded the field string will be used as the name (see the accessor method for more details).\nvar fooField = vega.field('foo');
fooField({foo: 5}); // 5
vega.accessorName(fooField); // 'foo'
vega.accessorFields(fooField); // ['foo']

var pathField = vega.field('foo.bar', 'path');
pathField({foo: {bar: 'vega'}}); // 'vega'
pathField({foo: 5}); // undefined
vega.accessorName(pathField); // 'path'
vega.accessorFields(pathField); // ['foo.bar']\nvar fooField = vega.field('foo');
fooField({foo: 5}); // 5
vega.accessorName(fooField); // 'foo'
vega.accessorFields(fooField); // ['foo']

var pathField = vega.field('foo.bar', 'path');
pathField({foo: {bar: 'vega'}}); // 'vega'
pathField({foo: 5}); // undefined
vega.accessorName(pathField); // 'path'
vega.accessorFields(pathField); // ['foo.bar']\nAn accessor function that returns the value of the id property of an input object.\n#
vega.identity(value)
<>\nAn accessor function that simply returns its value argument.\n#
vega.key(fields[, flat])
<>\nGenerates an accessor function that returns a key string (suitable for using as an object property name) for a set of object fields. The fields argument must be either a string or string array, with each entry indicating a property of an input object to be used to produce representative key values. The resulting key function is an accessor instance with the accessor name 'key'. The optional flat argument is a boolean flag indicating if the field names should be treated as flat property names, side-stepping nested field lookups normally indicated by dot or bracket notation. By default, flat is false and nested property lookup is performed.\nvar keyf = vega.key(['foo', 'bar']);
keyf({foo:'hi', bar:5}); // 'hi|5'
vega.accessorName(keyf); // 'key'
vega.accessorFields(keyf); // ['foo', 'bar']\nvar keyf = vega.key(['foo', 'bar']);
keyf({foo:'hi', bar:5}); // 'hi|5'
vega.accessorName(keyf); // 'key'
vega.accessorFields(keyf); // ['foo', 'bar']\nAn accessor function that simply returns the value one (1).\nAn accessor function that simply returns the value zero (0).\nAn accessor function that simply returns the boolean true value.\nAn accessor function that simply returns the boolean false value.\nFunctions for checking the type of JavaScript values.\n#
vega.isArray(value)
<>\nReturns true if the input value is an Array instance, false otherwise.\n#
vega.isBoolean(value)
<>\nReturns true if the input value is a Boolean instance, false otherwise.\n#
vega.isDate(value)
<>\nReturns true if the input value is a Date instance, false otherwise.\n#
vega.isFunction(value)
<>\nReturns true if the input value is a Function instance, false otherwise.\n#
vega.isIterable(value)
<>\nReturns true if the input value supports the iterable protocol, false otherwise.\n#
vega.isNumber(value)
<>\nReturns true if the input value is a Number instance, false otherwise.\n#
vega.isObject(value)
<>\nReturns true if the input value is an Object instance, false otherwise.\n#
vega.isRegExp(value)
<>\nReturns true if the input value is a RegExp instance, false otherwise.\n#
vega.isString(value)
<>\nReturns true if the input value is a String instance, false otherwise.\nFunctions for coercing values to a desired type.\n#
vega.toBoolean(value)
<>\nCoerces the input value to a boolean. The strings "true" and "1" map to true; the strings "false" and "0" map to false. Null values and empty strings are mapped to null.\n#
vega.toDate(value[, parser])
<>\nCoerces the input value to a Date timestamp. Null values and empty strings are mapped to null. Date objects are passed through unchanged. If an optional parser function is provided, it is used to perform date parsing. By default, numbers (timestamps) are passed through unchanged and otherwise Date.parse is used. Be aware that Date.parse has different implementations across browsers!\n#
vega.toNumber(value)
<>\nCoerces the input value to a number. Null values and empty strings are mapped to null.\n#
vega.toString(value)
<>\nCoerces the input value to a string. Null values and empty strings are mapped to null.\nFunctions for manipulating JavaScript Object values.\n#
vega.extend(target[, source1, source2, …])
<>\nExtends a target object by copying (in order) all enumerable properties of the input source objects.\n#
vega.hasOwnProperty(object, property)
<>\nReturns true if the input object has a named property defined on it, otherwise false. This method concerns the input object only, ignoring properties defined up the prototype chain. The method is equivalent to Object.hasOwnProperty, but improves security by guarding against overridden Object prototype built-ins.\nObject.hasOwnProperty\n#
vega.inherits(child, parent[, members])
<>\nA convenience method for setting up object-oriented inheritance. Assigns the prototype property of the input child function, such that the child inherits the properties of the parent function’s prototype via prototypal inheritance. The optional members argument is an object containing methods or properties to add to the new child prototype. Returns the new child prototype object.\n#
vega.lruCache([maxsize])
<>\nProvides a key/value cache, keyed by string, that evicts least recently used (LRU) entries. Supports has, get, set, and clear methods. The optional maxsize argument (default 10,000) determines the maximum number of elements that can be added before items are evicted.\nIn the internal implementation two caches are used: a current cache and a previous cache. When then current cache fills, it becomes the previous cache and a new, empty current cache is created. Subsequent get calls will promote elements in the previous cache to the current cache. Once the current cache fills, the caches are again turned over and all LRU items still residing in the previous cache are dropped.\nvar cache = vega.lruCache(1); // use 1-element cache to demonstrate
cache.set('a', 1); // current cache has a->1
cache.set('b', 2); // current cache has b->2, previous cache has a->1
cache.get('a');    // -> 1 (a now in current cache, b in previous cache)
cache.set('c', 3); // current cache has c->3, previous cache has a->1
cache.has('c');    // -> true  (c is in the current cache)
cache.has('b');    // -> false (b has been evicted)
cache.has('a');    // -> true  (a is in the previous cache)
cache.get('c');    // -> 3
cache.clear();\nvar cache = vega.lruCache(1); // use 1-element cache to demonstrate
cache.set('a', 1); // current cache has a->1
cache.set('b', 2); // current cache has b->2, previous cache has a->1
cache.get('a');    // -> 1 (a now in current cache, b in previous cache)
cache.set('c', 3); // current cache has c->3, previous cache has a->1
cache.has('c');    // -> true  (c is in the current cache)
cache.has('b');    // -> false (b has been evicted)
cache.has('a');    // -> true  (a is in the previous cache)
cache.get('c');    // -> 3
cache.clear();\n// use 1-element cache to demonstrate\n// current cache has a->1\n// current cache has b->2, previous cache has a->1\n// -> 1 (a now in current cache, b in previous cache)\n// current cache has c->3, previous cache has a->1\n// -> true  (c is in the current cache)\n// -> false (b has been evicted)\n// -> true  (a is in the previous cache)\n#
vega.fastmap([object])
<>\nProvides a key/value map data structure, keyed by string. Supports a subset of the ES6 Map API, including has, get, set, delete and clear methods and a size property. If the optional object argument is provided, all key/values on the input object will be added to the new map instance.\nvar map = vega.fastmap({foo:1, bar:2});
map.has('foo'); // -> true
map.get('foo'); // -> 1
map.delete('bar');
map.has('bar'); // -> false
map.set('baz', 0);
map.get('baz'); // -> 0
map.size; // -> 2
map.empty; // -> 1 (number of empty entries)
map.clean(); // invoke garbage collection, clears empty entries\nvar map = vega.fastmap({foo:1, bar:2});
map.has('foo'); // -> true
map.get('foo'); // -> 1
map.delete('bar');
map.has('bar'); // -> false
map.set('baz', 0);
map.get('baz'); // -> 0
map.size; // -> 2
map.empty; // -> 1 (number of empty entries)
map.clean(); // invoke garbage collection, clears empty entries\n// -> 1 (number of empty entries)\n// invoke garbage collection, clears empty entries\nBy using basic JavaScript objects to hash values and avoiding calls to the built-in JavaScript delete operator, fastmaps provide good performance. However, this speed comes at the cost of some object bloat, requiring periodic garbage collection in the case of many deletions. The fastmap object provides a clean method for requesting garbage collection of empty map entries. The test method is a getter/setter for providing an optional boolean-valued function that indicates additional objects (not just empty entries from deleted keys) that should be removed during garbage collection.\n#
vega.mergeConfig(…config)
<>\nMerges a collection of Vega configuration objects into a single combined object. Configuration objects with higher index positions in the arguments list have higher precedence, and so may override settings provided by earlier objects.\n#
vega.writeConfig(config, key, value[, recurse])
<>\nWrites a value to a Vega configuration object. Given a config object and a configuration property key and value, appropriately assign the value to the config object. The recurse parameter controls if recursive merging (as opposed to overwriting) is performed: if false or undefined, no recursion is performed; if true one level of recursive merge is performed; if recurse is object-valued, one level of recursive merge is performed for keys that the recurse object maps to a truthy value. This method is a helper method used within mergeConfig.\nFunctions for manipulating JavaScript Array values.\n#
vega.array(value)
<>\nEnsures that the input value is an Array instance. If so, the value is simply returned. If not, the value is wrapped within a new single-element an array, returning [value].\n#
vega.clampRange(range, min, max)
<>\nSpan-preserving range clamp. If the span of the input range is less than (max - min) and an endpoint exceeds either the min or max value, the range is translated such that the span is preserved and one endpoint touches the boundary of the min/max range. If the span exceeds (max - min), returns the range [min, max].\n#
vega.extent(array[, accessor])
<>\nReturns an array with the minimum and maximum values in the input array, in the form [min, max]. Ignores null, undefined, and NaN values. The optional accessor argument provides a function that is first applied to each array value prior to comparison.\n#
vega.extentIndex(array[, accessor])
<>\nReturns the array indices for the minimum and maximum values in the input array (as a [minIndex, maxIndex] array), according to natural ordering. The optional accessor argument provides a function that is first applied to each array value prior to comparison.\nvega.extentIndex([1,5,3,0,4,2]); // [3, 1]
vega.extentIndex([
  {a: 3, b:2},
  {a: 2, b:1},
  {a: 1, b:3}
], vega.field('b')); // [1, 2]\nvega.extentIndex([1,5,3,0,4,2]); // [3, 1]
vega.extentIndex([
  {a: 3, b:2},
  {a: 2, b:1},
  {a: 1, b:3}
], vega.field('b')); // [1, 2]\n#
vega.flush(range, value, threshold, left, right, center)
<>\nSelects among potential return values if the provided value is flush with the input numeric range. Returns left if value is within the *threshold distance of the minimum element of the range. Returns right if value is within the *threshold distance of the maximum element of the range. Otherwise, returns center.\n#
vega.inrange(value, range[, left, right])
<>\nReturns true if the input value lies within the span of the given range array. The left and right boolean flags control the use of inclusive (true) or exclusive (false) comparisons; if unspecified, inclusive tests are used.\n#
vega.lerp(array, fraction)
<>\nReturns the linearly interpolated value between the first and last entries in the array for the provided interpolation fraction (typically between 0 and 1). For example, lerp([0, 50], 0.5) returns 25.\n#
vega.merge(compare, array1, array2[, output])
<>\nMerge two sorted arrays into a single sorted array. The input compare function is a comparator for sorting elements and should correspond to the pre-sorted orders of the array1 and array2 source arrays. The merged array contents are written to the output array, if provided. If output is not specified, a new array is generated and returned.\n#
vega.panLinear(domain, delta)
<>\nGiven an input numeric domain (sorted in increasing order), returns a new domain array that translates the domain by a delta using a linear transform. The delta value is expressed as a fraction of the current domain span, and may be positive or negative to indicate the translation direction. The return value is a two-element array indicating the starting and ending value of the translated (panned) domain.\n#
vega.panLog(domain, delta)
<>\nGiven an input numeric domain (sorted in increasing order), returns a new domain array that translates the domain by a delta using a logarithmic transform. The delta value is expressed as a fraction of the current domain span, and may be positive or negative to indicate the translation direction. The return value is a two-element array indicating the starting and ending value of the translated (panned) domain.\n#
vega.panPow(domain, delta, exponent)
<>\nGiven an input numeric domain (sorted in increasing order), returns a new domain array that translates the domain by a delta using a power scale transform parameterized by the provided exponent. The delta value is expressed as a fraction of the current domain span, and may be positive or negative to indicate the translation direction. The return value is a two-element array indicating the starting and ending value of the translated (panned) domain.\n#
vega.panSymlog(domain, delta, constant)
<>\nGiven an input numeric domain (sorted in increasing order), returns a new domain array that translates the domain by a delta using a symlog (symmetric log) scale transform parameterized by the provided constant. The delta value is expressed as a fraction of the current domain span, and may be positive or negative to indicate the translation direction. The return value is a two-element array indicating the starting and ending value of the translated (panned) domain.\n#
vega.peek(array)
<>\nReturns the last element in the input array. Similar to the built-in Array.pop method, except that it does not remove the last element. This method is a convenient shorthand for array[array.length - 1].\n#
vega.span(array)
<>\nReturns the numerical span of the input array: the difference between the last and first values.\n#
vega.toSet(array)
<>\nGiven an input array of values, returns a new Object instance whose property keys are the values in array, each assigned a property value of 1. Each value in array is coerced to a String value and so should map to a reasonable string key value.\nvega.toSet([1, 2, 3]); // {'1':1, '2':1, '3':1}\nvega.toSet([1, 2, 3]); // {'1':1, '2':1, '3':1}\n// {'1':1, '2':1, '3':1}\n#
vega.visitArray(array, [filter,] visitor)
<>\nVists the values in an input array, invoking the visitor function for each array value that passes an optional filter. If specified, the filter function is called with each individual array value. If the filter function return value is truthy, the returned value is then passed as input to the visitor function. Thus, the filter not only performs filtering, it can serve as a value transformer. If the filter function is not specified, all values in the array are passed to the visitor function. Similar to the built-in Array.forEach method, the visitor function is invoked with three arguments: the value to visit, the current index into the source array, and a reference to the soure array.\n// console output: 1 0; 3 2
vega.visitArray([0, -1, 2],
  function(x) { return x + 1; },
  function(v, i, array) { console.log(v, i); });\n// console output: 1 0; 3 2
vega.visitArray([0, -1, 2],
  function(x) { return x + 1; },
  function(v, i, array) { console.log(v, i); });\n// console output: 1 0; 3 2\n#
vega.zoomLinear(domain, anchor, scale)
<>\nGiven an input numeric domain (sorted in increasing order), returns a new domain array that scales (zooms) the domain by a scale factor using a linear transform, centered on the given anchor value. If anchor is null, the midpoint of the domain is used instead. The return value is a two-element array indicating the starting and ending value of the scaled (zoomed) domain.\n#
vega.zoomLog(domain, anchor, scale)
<>\nGiven an input numeric domain (sorted in increasing order), returns a new domain array that scales (zooms) the domain by a scale factor using a logarithmic transform, centered on the given anchor value. If anchor is null, the midpoint of the domain is used instead. The return value is a two-element array indicating the starting and ending value of the scaled (zoomed) domain.\n#
vega.zoomPow(domain, anchor, scale, exponent)
<>\nGiven an input numeric domain (sorted in increasing order), returns a new domain array that scales (zooms) the domain by a scale factor using a power scale transform parameterized by the provided exponent, centered on the given anchor value. If anchor is null, the midpoint of the domain is used instead. The return value is a two-element array indicating the starting and ending value of the scaled (zoomed) domain.\n#
vega.zoomSymlog(domain, anchor, scale, constant)
<>\nGiven an input numeric domain (sorted in increasing order), returns a new domain array that scales (zooms) the domain by a scale factor using a symlog (symmetric log) scale transform parameterized by the provided constant, centered on the given anchor value. If anchor is null, the midpoint of the domain is used instead. The return value is a two-element array indicating the starting and ending value of the scaled (zoomed) domain.\nFunctions for manipulating JavaScript Date values.\n#
vega.quarter(date)
<>\nReturns the quarter of the year (an integer between 1 and 4) for an input date object or timestamp for the local timezone.\n#
vega.utcquarter(date)
<>\nReturns the quarter of the year (an integer between 1 and 4) for an input date object or timestamp for Coordinated Universal Time (UTC).\nFunctions for generating and manipulating JavaScript String values.\n#
vega.pad(string, length[, character, align])
<>\nPads a string value with repeated instances of a character up to a specified length. If character is not specified, a space (' ') is used. By default, padding is added to the end of a string. An optional align parameter specifies if padding should be added to the 'left' (beginning), 'center', or 'right' (end) of the input string.\nvega.pad('15', 5, '0', 'left'); // '00015'\nvega.pad('15', 5, '0', 'left'); // '00015'\n#
vega.repeat(string, count)
<>\nGiven an input string, returns a new string that repeats the input count times.\nvega.repeat('0', 5); // '00000'\nvega.repeat('0', 5); // '00000'\n#
vega.splitAccessPath(path)
<>\nSplits an input string representing an access path for JavaScript object properties into an array of constituent path elements.\nvega.splitAccessPath('foo'); // ['foo']
vega.splitAccessPath('foo.bar'); // ['foo', 'bar']
vega.splitAccessPath('foo["bar"]'); // ['foo', 'bar']
vega.splitAccessPath('foo[0].bar'); // ['foo', '0', 'bar']\nvega.splitAccessPath('foo'); // ['foo']
vega.splitAccessPath('foo.bar'); // ['foo', 'bar']
vega.splitAccessPath('foo["bar"]'); // ['foo', 'bar']
vega.splitAccessPath('foo[0].bar'); // ['foo', '0', 'bar']\n// ['foo', '0', 'bar']\n#
vega.stringValue(value)
<>\nReturns an output representation of an input value that is both JSON and JavaScript compliant. For Object and String values, JSON.stringify is used to generate the output string. Primitive types such as Number or Boolean are returned as-is. This method can be used to generate values that can then be included in runtime-compiled code snippets (for example, via the Function constructor).\n#
vega.truncate(string, length[, align, ellipsis])
<>\nTruncates an input string to a target length. The optional align argument indicates what part of the string should be truncated: 'left' (the beginning), 'center', or 'right' (the end). By default, the 'right' end of the string is truncated. The optional ellipsis argument indicates the string to use to indicate truncated content; by default the ellipsis character (…, same as \u2026) is used.\n#
vega.logger([level, method])
<>\nGenerates a new logger instance for selectively writing log messages to the JavaScript console. The optional level argument indicates the initial log level to use (one of None, Warn, Info, or Debug), and defaults to None if not specified.\nThe generated logger instance provides the following methods:\nlevel(value): Sets the current logging level. Only messages with a log level less than or equal to value will be written to the console.\nerror(message1[, message2, …]): Logs an error message. The messages will be written to the console using the console.error method if the current log level is Error or higher.\nwarn(message1[, message2, …]): Logs a warning message. The messages will be written to the console using the console.warn method if the current log level is Warn or higher.\ninfo(message1[, message2, …]): Logs an informative message. The messages will be written to the console using the console.log method if the current log level is Info or higher.\ndebug(message1[, message2, …]): Logs a debugging message. The messages will be written to the console using the console.log method if the current log level is Debug or higher.\nTo override the choice of console method invoked (console.log, console.warn, or console.error), use the optional method argument (one of "log", "warn", or "error") to route all log messages through the same method.\nConstant value indicating a log level of ‘None’. If set as the log level of a logger instance, all log messages will be suppressed.\nConstant value indicating a log level of ‘Error’. If set as the log level of a logger instance, only error messages will be presented.\nConstant value indicating a log level of ‘Warn’. If set as the log level of a logger instance, both error and warning messages will be presented.\nConstant value indicating a log level of ‘Info’. If set as the log level of a logger instance, error, warning and info messages will be presented.\nConstant value indicating a log level of ‘Debug’. If set as the log level of a logger instance, all log messages (error, warning, info and debug) will be presented.\n#
vega.error(message)
<>\nThrows a new error with the provided error message. This is a convenience method adding a layer of indirection for error handling, for example allowing error conditions to be included in expression chains.\nvega.error('Uh oh'); // equivalent to: throw Error('Uh oh')

// embed error in an expression
return isOk ? returnValue : vega.error('Not OK');\nvega.error('Uh oh'); // equivalent to: throw Error('Uh oh')

// embed error in an expression
return isOk ? returnValue : vega.error('Not OK');\n// equivalent to: throw Error('Uh oh')\n// embed error in an expression\n\n\nVega
            
              Vega-Lite
              Altair
              Vega-Lite API
            
          
          
            
              Examples
              Tutorials
              Documentation
              Usage
              About
            
            
              GitHub
              Try Online
            
          
        
      

      
        

  
  
    
      
      
        Documentation
      
      
      
      
        Parser
      
      
      
      
        View
      
      
      
      
        Locale
      
      
      
      
        Extensibility
      
      
      
      
        Statistics
      
      
      
      
        Time
      
      
      
      
        Util
      
      
      
      
        Debugging
      
      
    
  
  
    Debugging Guide
    A collection of methods for debugging Vega visualizations at runtime. All examples below assume that the Vega View instance to debug has been bound to the view variable. To access the view in the online editor, open the debug console and use VEGA_DEBUG.view.

Debugging Methods


  Inspect Signal Values
  Inspect Data Sets
  Snapshot Signal and Data State
  Inspect the Scenegraph
  Debugging Expressions
  Inspect the Runtime Scope


Inspect Signal Values

To inspect signal values, use the view.signal method:

view.signal('name') // returns the value of the signal 'name'


You can also use the same method to set signals due to a desired value. You will still need to invoke view.run() to re-run the dataflow after updating any values.

view.signal('name', value).run(); // update signal 'name' and run the dataflow


The view.signal method will only return signals defined in the top-level of a Vega specification. To view signals defined in nested group marks, create a state snapshot or inspect the runtime scope.

Inspect Data Sets

To inspect a data set, use the view.data method:

view.data('name') // return a data object array for the data set 'name'


The view.data method returns the output of any data transforms applied. To get access to both input and output data, read about inspecting runtime scope below. Also, this method will only return data sets defined in the top-level of a Vega specification. To view data sets defined in nested group marks, create a state snapshot or inspect the runtime scope.

Snapshot Signal and Data State

The view.getState method returns a snapshot of active signals and data sets, and may be a convenient way to inspect the state of a visualization. The view.setState method can then be used to restore the state back to a previous value, which may sometimes be useful for testing.

view.getState() // {signals: [...], data: [...], subcontext: [...]}


The view.getState method returns an object whose properties are a hash of all named signals and a hash of all named input data sets. The getState method returns data sets prior to applying transforms, as this is more appropriate for changing the visualization back to a previous state. In addition, if a visualization includes nested group marks with signal or data set definitions, a subcontext property is included which contains state information for all nested scopes.

Inspect the Scenegraph

It is often helpful to be able to inspect the visual values on scenegraph items, as well as associated data objects. To access the scenegraph from the console, use the view.scenegraph method and access the scenegraph items starting with the root property. Each mark group and scenegraph items can then be accessed under the items property.

var root = view.scenegraph().root; // {marktype: "group", items: [...], ...}


It can sometimes be tedious to walk down the scenegraph tree manually. Scenegraph items can be accessed in a more direct manipulation way when using the SVG renderer. For example, if using the Chrome browser, first right click an element and select “Inspect” from the menu. The resulting SVG element will be bound to the global variable $0. The Vega scenegraph item is then accessible in the console as $0.__data__, and the backing data object is $0.__data__.datum.

Debugging Expressions

Debugging messages can be added to expressions using the logging methods: warn, info, debug. The last argument provided to these functions is used as the return value; this allows logging methods to be added to existing expressions without changing the logic of a specification.

To ensure that log messages make their way to the console, the Vega view must have the correct logging level set. For example, to ensure that warning messages are printed to the console:

view.logLevel(vega.Warn);


Inspect the Runtime Scope

If the above methods prove insufficient, one can also get down and dirty by directly inspecting the internals of the Vega dataflow graph. The dataflow graph consists of a set of operators (or nodes) that compute values and/or process streams of data objects. Operators are connected in a dependency graph structure, and each has a value property indicating the computed value for that node.

To access dataflow operators for the top-level scope, using the view._runtime property. Note that this is not an “official” part of the Vega API, but nonetheless can useful for advanced debugging. Do not modify any properties within the runtime object. If modified, the subsequent visualization behavior is undefined.

view._runtime // {signals: {}, data: {}, scales: {}, nodes: {}, subcontext: [], ...}


The runtime scope object includes properties for:

  signals - Dataflow operators corresponding to each named signal.
  data - Holds input, output and values nodes for each named data set. Inspect the input node for pre-transform data objects; inspect the values node for post-transform data objects.
  scales - Dataflow operators corresponding to named scales and projections.
  nodes - An id-based lookup table of all dataflow operators in the current scope (including transforms).
  subcontext - An array of recursive runtime scopes for nested group marks.\nVega
            
              Vega-Lite
              Altair
              Vega-Lite API\nVega-Lite
              Altair
              Vega-Lite API\nExamples
              Tutorials
              Documentation
              Usage
              About
            
            
              GitHub
              Try Online\nExamples
              Tutorials
              Documentation
              Usage
              About\nGitHub
              Try Online\nDocumentation
      
      
      
      
        Parser
      
      
      
      
        View
      
      
      
      
        Locale
      
      
      
      
        Extensibility
      
      
      
      
        Statistics
      
      
      
      
        Time
      
      
      
      
        Util
      
      
      
      
        Debugging
      
      
    
  
  
    Debugging Guide
    A collection of methods for debugging Vega visualizations at runtime. All examples below assume that the Vega View instance to debug has been bound to the view variable. To access the view in the online editor, open the debug console and use VEGA_DEBUG.view.

Debugging Methods


  Inspect Signal Values
  Inspect Data Sets
  Snapshot Signal and Data State
  Inspect the Scenegraph
  Debugging Expressions
  Inspect the Runtime Scope


Inspect Signal Values

To inspect signal values, use the view.signal method:

view.signal('name') // returns the value of the signal 'name'


You can also use the same method to set signals due to a desired value. You will still need to invoke view.run() to re-run the dataflow after updating any values.

view.signal('name', value).run(); // update signal 'name' and run the dataflow


The view.signal method will only return signals defined in the top-level of a Vega specification. To view signals defined in nested group marks, create a state snapshot or inspect the runtime scope.

Inspect Data Sets

To inspect a data set, use the view.data method:

view.data('name') // return a data object array for the data set 'name'


The view.data method returns the output of any data transforms applied. To get access to both input and output data, read about inspecting runtime scope below. Also, this method will only return data sets defined in the top-level of a Vega specification. To view data sets defined in nested group marks, create a state snapshot or inspect the runtime scope.

Snapshot Signal and Data State

The view.getState method returns a snapshot of active signals and data sets, and may be a convenient way to inspect the state of a visualization. The view.setState method can then be used to restore the state back to a previous value, which may sometimes be useful for testing.

view.getState() // {signals: [...], data: [...], subcontext: [...]}


The view.getState method returns an object whose properties are a hash of all named signals and a hash of all named input data sets. The getState method returns data sets prior to applying transforms, as this is more appropriate for changing the visualization back to a previous state. In addition, if a visualization includes nested group marks with signal or data set definitions, a subcontext property is included which contains state information for all nested scopes.

Inspect the Scenegraph

It is often helpful to be able to inspect the visual values on scenegraph items, as well as associated data objects. To access the scenegraph from the console, use the view.scenegraph method and access the scenegraph items starting with the root property. Each mark group and scenegraph items can then be accessed under the items property.

var root = view.scenegraph().root; // {marktype: "group", items: [...], ...}


It can sometimes be tedious to walk down the scenegraph tree manually. Scenegraph items can be accessed in a more direct manipulation way when using the SVG renderer. For example, if using the Chrome browser, first right click an element and select “Inspect” from the menu. The resulting SVG element will be bound to the global variable $0. The Vega scenegraph item is then accessible in the console as $0.__data__, and the backing data object is $0.__data__.datum.

Debugging Expressions

Debugging messages can be added to expressions using the logging methods: warn, info, debug. The last argument provided to these functions is used as the return value; this allows logging methods to be added to existing expressions without changing the logic of a specification.

To ensure that log messages make their way to the console, the Vega view must have the correct logging level set. For example, to ensure that warning messages are printed to the console:

view.logLevel(vega.Warn);


Inspect the Runtime Scope

If the above methods prove insufficient, one can also get down and dirty by directly inspecting the internals of the Vega dataflow graph. The dataflow graph consists of a set of operators (or nodes) that compute values and/or process streams of data objects. Operators are connected in a dependency graph structure, and each has a value property indicating the computed value for that node.

To access dataflow operators for the top-level scope, using the view._runtime property. Note that this is not an “official” part of the Vega API, but nonetheless can useful for advanced debugging. Do not modify any properties within the runtime object. If modified, the subsequent visualization behavior is undefined.

view._runtime // {signals: {}, data: {}, scales: {}, nodes: {}, subcontext: [], ...}


The runtime scope object includes properties for:

  signals - Dataflow operators corresponding to each named signal.
  data - Holds input, output and values nodes for each named data set. Inspect the input node for pre-transform data objects; inspect the values node for post-transform data objects.
  scales - Dataflow operators corresponding to named scales and projections.
  nodes - An id-based lookup table of all dataflow operators in the current scope (including transforms).
  subcontext - An array of recursive runtime scopes for nested group marks.\nA collection of methods for debugging Vega visualizations at runtime. All examples below assume that the Vega View instance to debug has been bound to the view variable. To access the view in the online editor, open the debug console and use VEGA_DEBUG.view.\nInspect Signal Values\nInspect Signal Values\nSnapshot Signal and Data State\nSnapshot Signal and Data State\nInspect the Scenegraph\nInspect the Scenegraph\nDebugging Expressions\nDebugging Expressions\nInspect the Runtime Scope\nInspect the Runtime Scope\nInspect Signal Values\nTo inspect signal values, use the view.signal method:\nview.signal('name') // returns the value of the signal 'name'\nview.signal('name') // returns the value of the signal 'name'\n// returns the value of the signal 'name'\nYou can also use the same method to set signals due to a desired value. You will still need to invoke view.run() to re-run the dataflow after updating any values.\nview.signal('name', value).run(); // update signal 'name' and run the dataflow\nview.signal('name', value).run(); // update signal 'name' and run the dataflow\n// update signal 'name' and run the dataflow\nThe view.signal method will only return signals defined in the top-level of a Vega specification. To view signals defined in nested group marks, create a state snapshot or inspect the runtime scope.\ninspect the runtime scope\nTo inspect a data set, use the view.data method:\nview.data('name') // return a data object array for the data set 'name'\nview.data('name') // return a data object array for the data set 'name'\n// return a data object array for the data set 'name'\nThe view.data method returns the output of any data transforms applied. To get access to both input and output data, read about inspecting runtime scope below. Also, this method will only return data sets defined in the top-level of a Vega specification. To view data sets defined in nested group marks, create a state snapshot or inspect the runtime scope.\ninspecting runtime scope\ninspect the runtime scope\nSnapshot Signal and Data State\nThe view.getState method returns a snapshot of active signals and data sets, and may be a convenient way to inspect the state of a visualization. The view.setState method can then be used to restore the state back to a previous value, which may sometimes be useful for testing.\nview.getState() // {signals: [...], data: [...], subcontext: [...]}\nview.getState() // {signals: [...], data: [...], subcontext: [...]}\n// {signals: [...], data: [...], subcontext: [...]}\nThe view.getState method returns an object whose properties are a hash of all named signals and a hash of all named input data sets. The getState method returns data sets prior to applying transforms, as this is more appropriate for changing the visualization back to a previous state. In addition, if a visualization includes nested group marks with signal or data set definitions, a subcontext property is included which contains state information for all nested scopes.\nInspect the Scenegraph\nIt is often helpful to be able to inspect the visual values on scenegraph items, as well as associated data objects. To access the scenegraph from the console, use the view.scenegraph method and access the scenegraph items starting with the root property. Each mark group and scenegraph items can then be accessed under the items property.\nvar root = view.scenegraph().root; // {marktype: "group", items: [...], ...}\nvar root = view.scenegraph().root; // {marktype: "group", items: [...], ...}\n// {marktype: "group", items: [...], ...}\nIt can sometimes be tedious to walk down the scenegraph tree manually. Scenegraph items can be accessed in a more direct manipulation way when using the SVG renderer. For example, if using the Chrome browser, first right click an element and select “Inspect” from the menu. The resulting SVG element will be bound to the global variable $0. The Vega scenegraph item is then accessible in the console as $0.__data__, and the backing data object is $0.__data__.datum.\nDebugging Expressions\nDebugging messages can be added to expressions using the logging methods: warn, info, debug. The last argument provided to these functions is used as the return value; this allows logging methods to be added to existing expressions without changing the logic of a specification.\nTo ensure that log messages make their way to the console, the Vega view must have the correct logging level set. For example, to ensure that warning messages are printed to the console:\nview.logLevel(vega.Warn);\nview.logLevel(vega.Warn);\nInspect the Runtime Scope\nIf the above methods prove insufficient, one can also get down and dirty by directly inspecting the internals of the Vega dataflow graph. The dataflow graph consists of a set of operators (or nodes) that compute values and/or process streams of data objects. Operators are connected in a dependency graph structure, and each has a value property indicating the computed value for that node.\nTo access dataflow operators for the top-level scope, using the view._runtime property. Note that this is not an “official” part of the Vega API, but nonetheless can useful for advanced debugging. Do not modify any properties within the runtime object. If modified, the subsequent visualization behavior is undefined.\nview._runtime // {signals: {}, data: {}, scales: {}, nodes: {}, subcontext: [], ...}\nview._runtime // {signals: {}, data: {}, scales: {}, nodes: {}, subcontext: [], ...}\n// {signals: {}, data: {}, scales: {}, nodes: {}, subcontext: [], ...}\nThe runtime scope object includes properties for:\nsignals - Dataflow operators corresponding to each named signal.\ndata - Holds input, output and values nodes for each named data set. Inspect the input node for pre-transform data objects; inspect the values node for post-transform data objects.\nscales - Dataflow operators corresponding to named scales and projections.\nnodes - An id-based lookup table of all dataflow operators in the current scope (including transforms).\nsubcontext - An array of recursive runtime scopes for nested group marks.\n\n\nVega
            
              Vega-Lite
              Altair
              Vega-Lite API
            
          
          
            
              Examples
              Tutorials
              Documentation
              Usage
              About
            
            
              GitHub
              Try Online
            
          
        
      

      
        

  
  
    Tutorials
    Tutorials for learning how to use Vega.

Let’s Make a Bar Chart

Skill level: Beginner. Learn the basic elements of Vega by creating a bar chart with interactive tooltips.

A Guide to Guides: Axes & Legends

Skill level: Intermediate. Tour the various types of axes and legends in Vega, learn how to parameterize them and adjust their layout.

Mapping Airport Connections

Skill level: Intermediate. Learn more advanced Vega features – including mapping, data transformation, and interaction – by building an interactive map of direct routes among major U.S. airports.

How Vega Works

Skill level: Advanced. How a Vega JSON specification becomes an interactive view, covering parsing, dataflow processing, scenegraph construction, and rendering.\nVega
            
              Vega-Lite
              Altair
              Vega-Lite API\nVega-Lite
              Altair
              Vega-Lite API\nExamples
              Tutorials
              Documentation
              Usage
              About
            
            
              GitHub
              Try Online\nExamples
              Tutorials
              Documentation
              Usage
              About\nGitHub
              Try Online\nTutorials
    Tutorials for learning how to use Vega.

Let’s Make a Bar Chart

Skill level: Beginner. Learn the basic elements of Vega by creating a bar chart with interactive tooltips.

A Guide to Guides: Axes & Legends

Skill level: Intermediate. Tour the various types of axes and legends in Vega, learn how to parameterize them and adjust their layout.

Mapping Airport Connections

Skill level: Intermediate. Learn more advanced Vega features – including mapping, data transformation, and interaction – by building an interactive map of direct routes among major U.S. airports.

How Vega Works

Skill level: Advanced. How a Vega JSON specification becomes an interactive view, covering parsing, dataflow processing, scenegraph construction, and rendering.\nTutorials for learning how to use Vega.\nLet’s Make a Bar Chart\nLet’s Make a Bar Chart\nSkill level: Beginner. Learn the basic elements of Vega by creating a bar chart with interactive tooltips.\nA Guide to Guides: Axes & Legends\nA Guide to Guides: Axes & Legends\nSkill level: Intermediate. Tour the various types of axes and legends in Vega, learn how to parameterize them and adjust their layout.\nMapping Airport Connections\nMapping Airport Connections\nSkill level: Intermediate. Learn more advanced Vega features – including mapping, data transformation, and interaction – by building an interactive map of direct routes among major U.S. airports.\nSkill level: Advanced. How a Vega JSON specification becomes an interactive view, covering parsing, dataflow processing, scenegraph construction, and rendering.\n\n\nVega
            
              Vega-Lite
              Altair
              Vega-Lite API
            
          
          
            
              Examples
              Tutorials
              Documentation
              Usage
              About
            
            
              GitHub
              Try Online
            
          
        
      

      
        

  
  
    
      
      
        About
      
      
      
      
        Video
      
      
      
      
        Projects
      
      
      
      
        Research
      
      
      
      
        Vega and D3
      
      
      
      
        Code of Conduct
      
      
    
  
  
    About the Vega Project
    Over years working in data visualization, we’ve sought to build tools that help designers craft sophisticated graphics, including systems such as Prefuse, Protovis and D3.js. However, in the grand scheme of things, “artisanal” visualizations hand-coded by skilled designers are the exception, not the rule. The vast majority of the world’s visualizations instead are produced using end-user applications such as spreadsheets and business intelligence tools. While valuable, these tools often fall short of fully supporting the iterative, interactive process of data analysis. Improved tools could help a larger swath of people create effective visualizations and better understand their data.

The goal of the Vega project is to promote an ecosystem of usable and interoperable tools, supporting use cases ranging from exploratory data analysis to effective communication via custom visualization design.

This goal has led us to develop not a singular system, but rather a stack of tools for interactive data visualization. At the foundation of this stack is the Vega visualization grammar. Similar in spirit to how SQL provides a language for expressing database queries, Vega provides a declarative language for describing visualizations. Vega specifications include the data transformations and visual encoding rules needed to express a rich space of visualizations. Building on libraries such as D3, the Vega runtime parses specifications in a JSON format to produce interactive web-based graphics. One unique aspect of Vega is its support for declarative interaction design: instead of the “spaghetti code” of event handler callbacks, Vega treats user input (mouse movement, touch events, etc.) as first-class streaming data to drive reactive updates to a visualization.

While Vega is useful in its own right (for example, Vega is deployed on Wikipedia to define visualizations directly within wiki pages), our primary motivation is for Vega to serve as a foundation for higher-level tools. Vega provides a formal language and computational file format for representing and reasoning about visualizations. In other words, Vega provides a more convenient yet powerful means for writing programs that generate visualizations, ranging from interactive design tools to automatic chart recommendation tools. Vega provides a performant runtime and can serve as an “assembly language” for visualization, letting other tools focus on design questions rather than low-level implementation details.

Want to Learn More?


  
    
      Video
      Videos of presentations about Vega and related topics.
    
    
      Projects
      Other languages, tools and models built on Vega.
    
    
      Research
      Research publications from the Vega project.
    
    
      Vega and D3
      On the relationship between Vega and D3.
    
    
      Code of Conduct
      The Vega project is governed by a code of conduct to foster an inclusive community.\nVega
            
              Vega-Lite
              Altair
              Vega-Lite API\nVega-Lite
              Altair
              Vega-Lite API\nExamples
              Tutorials
              Documentation
              Usage
              About
            
            
              GitHub
              Try Online\nExamples
              Tutorials
              Documentation
              Usage
              About\nGitHub
              Try Online\nAbout
      
      
      
      
        Video
      
      
      
      
        Projects
      
      
      
      
        Research
      
      
      
      
        Vega and D3
      
      
      
      
        Code of Conduct
      
      
    
  
  
    About the Vega Project
    Over years working in data visualization, we’ve sought to build tools that help designers craft sophisticated graphics, including systems such as Prefuse, Protovis and D3.js. However, in the grand scheme of things, “artisanal” visualizations hand-coded by skilled designers are the exception, not the rule. The vast majority of the world’s visualizations instead are produced using end-user applications such as spreadsheets and business intelligence tools. While valuable, these tools often fall short of fully supporting the iterative, interactive process of data analysis. Improved tools could help a larger swath of people create effective visualizations and better understand their data.

The goal of the Vega project is to promote an ecosystem of usable and interoperable tools, supporting use cases ranging from exploratory data analysis to effective communication via custom visualization design.

This goal has led us to develop not a singular system, but rather a stack of tools for interactive data visualization. At the foundation of this stack is the Vega visualization grammar. Similar in spirit to how SQL provides a language for expressing database queries, Vega provides a declarative language for describing visualizations. Vega specifications include the data transformations and visual encoding rules needed to express a rich space of visualizations. Building on libraries such as D3, the Vega runtime parses specifications in a JSON format to produce interactive web-based graphics. One unique aspect of Vega is its support for declarative interaction design: instead of the “spaghetti code” of event handler callbacks, Vega treats user input (mouse movement, touch events, etc.) as first-class streaming data to drive reactive updates to a visualization.

While Vega is useful in its own right (for example, Vega is deployed on Wikipedia to define visualizations directly within wiki pages), our primary motivation is for Vega to serve as a foundation for higher-level tools. Vega provides a formal language and computational file format for representing and reasoning about visualizations. In other words, Vega provides a more convenient yet powerful means for writing programs that generate visualizations, ranging from interactive design tools to automatic chart recommendation tools. Vega provides a performant runtime and can serve as an “assembly language” for visualization, letting other tools focus on design questions rather than low-level implementation details.

Want to Learn More?


  
    
      Video
      Videos of presentations about Vega and related topics.
    
    
      Projects
      Other languages, tools and models built on Vega.
    
    
      Research
      Research publications from the Vega project.
    
    
      Vega and D3
      On the relationship between Vega and D3.
    
    
      Code of Conduct
      The Vega project is governed by a code of conduct to foster an inclusive community.\nAbout the Vega Project\nOver years working in data visualization, we’ve sought to build tools that help designers craft sophisticated graphics, including systems such as Prefuse, Protovis and D3.js. However, in the grand scheme of things, “artisanal” visualizations hand-coded by skilled designers are the exception, not the rule. The vast majority of the world’s visualizations instead are produced using end-user applications such as spreadsheets and business intelligence tools. While valuable, these tools often fall short of fully supporting the iterative, interactive process of data analysis. Improved tools could help a larger swath of people create effective visualizations and better understand their data.\nThe goal of the Vega project is to promote an ecosystem of usable and interoperable tools, supporting use cases ranging from exploratory data analysis to effective communication via custom visualization design.\nThis goal has led us to develop not a singular system, but rather a stack of tools for interactive data visualization. At the foundation of this stack is the Vega visualization grammar. Similar in spirit to how SQL provides a language for expressing database queries, Vega provides a declarative language for describing visualizations. Vega specifications include the data transformations and visual encoding rules needed to express a rich space of visualizations. Building on libraries such as D3, the Vega runtime parses specifications in a JSON format to produce interactive web-based graphics. One unique aspect of Vega is its support for declarative interaction design: instead of the “spaghetti code” of event handler callbacks, Vega treats user input (mouse movement, touch events, etc.) as first-class streaming data to drive reactive updates to a visualization.\nWhile Vega is useful in its own right (for example, Vega is deployed on Wikipedia to define visualizations directly within wiki pages), our primary motivation is for Vega to serve as a foundation for higher-level tools. Vega provides a formal language and computational file format for representing and reasoning about visualizations. In other words, Vega provides a more convenient yet powerful means for writing programs that generate visualizations, ranging from interactive design tools to automatic chart recommendation tools. Vega provides a performant runtime and can serve as an “assembly language” for visualization, letting other tools focus on design questions rather than low-level implementation details.\nVega is deployed on Wikipedia\nVideos of presentations about Vega and related topics.\nOther languages, tools and models built on Vega.\nResearch publications from the Vega project.\nOn the relationship between Vega and D3.\nThe Vega project is governed by a code of conduct to foster an inclusive community.\n\n\nVega-Lite
        
          Vega
          Altair
          Vega-Lite API
        
      
      
        
          Examples
          Tutorials
          Documentation
          Usage
          Ecosystem
        
        
          GitHub
          Try Online
        
      
    
  
  
    
  
Vega-Lite – A Grammar of Interactive Graphics



  
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
  




  
  Vega-Lite is a high-level grammar of interactive graphics. It provides a concise, declarative JSON syntax to create an expressive range of visualizations for data analysis and presentation.



  
    Vega-Lite specifications describe visualizations as encoding mappings from data to properties of graphical marks (e.g., points or bars).
    The Vega-Lite compiler automatically produces visualization components including axes, legends, and scales.
    It determines default properties of these components based on a set of carefully designed rules.
    This approach allows Vega-Lite specifications to be concise for quick visualization authoring, while giving user control to override defaults and customize various parts of a visualization.
    As we also designed Vega-Lite to support data analysis, Vega-Lite supports both data transformations (e.g., aggregation, binning, filtering, sorting) and visual transformations (e.g., stacking and faceting).
    Moreover, Vega-Lite specifications can be composed into layered and multi-view displays, and made interactive with selections.
  
  
  Get startedLatest Version: 6.1.0
  Try online
  


Compared to Vega, Vega-Lite provides a more concise and convenient form to author common visualizations. As Vega-Lite can compile its specifications to Vega specifications, users may use Vega-Lite as the primary visualization tool and, if needed, transition to use the lower-level Vega for advanced use cases.

For more information, read our introduction article to Vega-Lite v2 on Medium, watch our OpenVis Conf talk about the new features in Vega-Lite v2, see the documentation and take a look at our example gallery. Follow us on Twitter at @vega_vis to stay informed about updates.

Example


  
    With Vega-Lite, we can start with a bar chart of the average monthly precipitation in Seattle, overlay a rule for the overall yearly average, and have it represent an interactive moving average for a dragged region. Next step
  

  
    
      
    
    
      
    
    
      
      
        
      
    
  
  
    
    
    
  


Additional Links


  Award winning research paper and video of our OpenVis Conf talk on the design of Vega-Lite
  The about page for the Vega project
  Listen to a Data Stories episode about Declarative Visualization with Vega-Lite and Altair

  
JSON schema specification for Vega-Lite (latest)
  Ask questions about Vega-Lite on Stack Overflow or Slack

  Fork our Observable Notebook.


Users

Vega-Lite is used by thousands of data enthusiasts, developers, journalists, data scientists, teachers, and researchers across many organizations. Here are some of them. Learn about integrations on our ecosystem page.


  
  
  
  
  
  
  
  
  
  
  
  
  


Team

The development of Vega-Lite is led by the alumni and members of the University of Washington Interactive Data Lab (UW IDL), including Kanit “Ham” Wongsuphasawat (now at Databricks), Dominik Moritz (now at CMU / Apple), Arvind Satyanarayan (now at MIT), and Jeffrey Heer (UW IDL).

Vega-Lite gets significant contributions from its community. Please see the contributors page for the full list of contributors.\nVega-Lite
        
          Vega
          Altair
          Vega-Lite API\nVega
          Altair
          Vega-Lite API\nExamples
          Tutorials
          Documentation
          Usage
          Ecosystem
        
        
          GitHub
          Try Online\nExamples
          Tutorials
          Documentation
          Usage
          Ecosystem\nGitHub
          Try Online\nVega-Lite – A Grammar of Interactive Graphics\nVega-Lite – A Grammar of Interactive Graphics\nVega-Lite is a high-level grammar of interactive graphics. It provides a concise, declarative JSON syntax to create an expressive range of visualizations for data analysis and presentation.



  
    Vega-Lite specifications describe visualizations as encoding mappings from data to properties of graphical marks (e.g., points or bars).
    The Vega-Lite compiler automatically produces visualization components including axes, legends, and scales.
    It determines default properties of these components based on a set of carefully designed rules.
    This approach allows Vega-Lite specifications to be concise for quick visualization authoring, while giving user control to override defaults and customize various parts of a visualization.
    As we also designed Vega-Lite to support data analysis, Vega-Lite supports both data transformations (e.g., aggregation, binning, filtering, sorting) and visual transformations (e.g., stacking and faceting).
    Moreover, Vega-Lite specifications can be composed into layered and multi-view displays, and made interactive with selections.
  
  
  Get startedLatest Version: 6.1.0
  Try online
  


Compared to Vega, Vega-Lite provides a more concise and convenient form to author common visualizations. As Vega-Lite can compile its specifications to Vega specifications, users may use Vega-Lite as the primary visualization tool and, if needed, transition to use the lower-level Vega for advanced use cases.

For more information, read our introduction article to Vega-Lite v2 on Medium, watch our OpenVis Conf talk about the new features in Vega-Lite v2, see the documentation and take a look at our example gallery. Follow us on Twitter at @vega_vis to stay informed about updates.

Example


  
    With Vega-Lite, we can start with a bar chart of the average monthly precipitation in Seattle, overlay a rule for the overall yearly average, and have it represent an interactive moving average for a dragged region. Next step
  

  
    
      
    
    
      
    
    
      
      
        
      
    
  
  
    
    
    
  


Additional Links


  Award winning research paper and video of our OpenVis Conf talk on the design of Vega-Lite
  The about page for the Vega project
  Listen to a Data Stories episode about Declarative Visualization with Vega-Lite and Altair

  
JSON schema specification for Vega-Lite (latest)
  Ask questions about Vega-Lite on Stack Overflow or Slack

  Fork our Observable Notebook.


Users

Vega-Lite is used by thousands of data enthusiasts, developers, journalists, data scientists, teachers, and researchers across many organizations. Here are some of them. Learn about integrations on our ecosystem page.


  
  
  
  
  
  
  
  
  
  
  
  
  


Team

The development of Vega-Lite is led by the alumni and members of the University of Washington Interactive Data Lab (UW IDL), including Kanit “Ham” Wongsuphasawat (now at Databricks), Dominik Moritz (now at CMU / Apple), Arvind Satyanarayan (now at MIT), and Jeffrey Heer (UW IDL).

Vega-Lite gets significant contributions from its community. Please see the contributors page for the full list of contributors.\nVega-Lite is a high-level grammar of interactive graphics. It provides a concise, declarative JSON syntax to create an expressive range of visualizations for data analysis and presentation.\nVega-Lite specifications describe visualizations as encoding mappings from data to properties of graphical marks (e.g., points or bars).
    The Vega-Lite compiler automatically produces visualization components including axes, legends, and scales.
    It determines default properties of these components based on a set of carefully designed rules.
    This approach allows Vega-Lite specifications to be concise for quick visualization authoring, while giving user control to override defaults and customize various parts of a visualization.
    As we also designed Vega-Lite to support data analysis, Vega-Lite supports both data transformations (e.g., aggregation, binning, filtering, sorting) and visual transformations (e.g., stacking and faceting).
    Moreover, Vega-Lite specifications can be composed into layered and multi-view displays, and made interactive with selections.
  
  
  Get startedLatest Version: 6.1.0
  Try online\nVega-Lite specifications describe visualizations as encoding mappings from data to properties of graphical marks (e.g., points or bars).
    The Vega-Lite compiler automatically produces visualization components including axes, legends, and scales.
    It determines default properties of these components based on a set of carefully designed rules.
    This approach allows Vega-Lite specifications to be concise for quick visualization authoring, while giving user control to override defaults and customize various parts of a visualization.
    As we also designed Vega-Lite to support data analysis, Vega-Lite supports both data transformations (e.g., aggregation, binning, filtering, sorting) and visual transformations (e.g., stacking and faceting).
    Moreover, Vega-Lite specifications can be composed into layered and multi-view displays, and made interactive with selections.
  
  
  Get startedLatest Version: 6.1.0
  Try online\nVega-Lite specifications describe visualizations as encoding mappings from data to properties of graphical marks (e.g., points or bars).
    The Vega-Lite compiler automatically produces visualization components including axes, legends, and scales.
    It determines default properties of these components based on a set of carefully designed rules.
    This approach allows Vega-Lite specifications to be concise for quick visualization authoring, while giving user control to override defaults and customize various parts of a visualization.
    As we also designed Vega-Lite to support data analysis, Vega-Lite supports both data transformations (e.g., aggregation, binning, filtering, sorting) and visual transformations (e.g., stacking and faceting).
    Moreover, Vega-Lite specifications can be composed into layered and multi-view displays, and made interactive with selections.\nGet startedLatest Version: 6.1.0
  Try online\nGet startedLatest Version: 6.1.0\nCompared to Vega, Vega-Lite provides a more concise and convenient form to author common visualizations. As Vega-Lite can compile its specifications to Vega specifications, users may use Vega-Lite as the primary visualization tool and, if needed, transition to use the lower-level Vega for advanced use cases.\nFor more information, read our introduction article to Vega-Lite v2 on Medium, watch our OpenVis Conf talk about the new features in Vega-Lite v2, see the documentation and take a look at our example gallery. Follow us on Twitter at @vega_vis to stay informed about updates.\nintroduction article to Vega-Lite v2 on Medium\nOpenVis Conf talk about the new features in Vega-Lite v2\nWith Vega-Lite, we can start with a bar chart of the average monthly precipitation in Seattle, overlay a rule for the overall yearly average, and have it represent an interactive moving average for a dragged region. Next step\nWith Vega-Lite, we can start with a bar chart of the average monthly precipitation in Seattle, overlay a rule for the overall yearly average, and have it represent an interactive moving average for a dragged region. Next step\nbar chart of the average monthly precipitation\noverlay a rule for the overall yearly average\nan interactive moving average for a dragged region\nAward winning research paper and video of our OpenVis Conf talk on the design of Vega-Lite\nvideo of our OpenVis Conf talk\nThe about page for the Vega project\nThe about page for the Vega project\nListen to a Data Stories episode about Declarative Visualization with Vega-Lite and Altair\nDeclarative Visualization with Vega-Lite and Altair\nJSON schema specification for Vega-Lite (latest)\nAsk questions about Vega-Lite on Stack Overflow or Slack\nFork our Observable Notebook.\nVega-Lite is used by thousands of data enthusiasts, developers, journalists, data scientists, teachers, and researchers across many organizations. Here are some of them. Learn about integrations on our ecosystem page.\nThe development of Vega-Lite is led by the alumni and members of the University of Washington Interactive Data Lab (UW IDL), including Kanit “Ham” Wongsuphasawat (now at Databricks), Dominik Moritz (now at CMU / Apple), Arvind Satyanarayan (now at MIT), and Jeffrey Heer (UW IDL).\nUniversity of Washington Interactive Data Lab\nKanit “Ham” Wongsuphasawat\nVega-Lite gets significant contributions from its community. Please see the contributors page for the full list of contributors.\nEdit this page and submit a pull request!\nEdit this page and submit a pull request!\n\n\nVega-Lite
        
          Vega
          Altair
          Vega-Lite API
        
      
      
        
          Examples
          Tutorials
          Documentation
          Usage
          Ecosystem
        
        
          GitHub
          Try Online
        
      
    
  
  
    
  
  Example Gallery
   This page shows example specifications for different types of graphics. To see example code for embedding visualizations in a webpage, please read the embed documentation.



  
Single-View Plots    
      Bar Charts
      Histograms, Density Plots, and Dot Plots
      Scatter & Strip Plots
      Line Charts
      Area Charts & Streamgraphs
      Table-based Plots
      Circular Plots
      Advanced Calculations
    
  
  
Composite Marks    
      Error Bars & Error Bands
      Box Plots
    
  
  
Layered Plots    
      Labeling & Annotation
      Other Layered Plots
    
  
  
Multi-View Displays    
      Faceting (Trellis Plot / Small Multiples)
      Repeat & Concatenation
    
  
  Maps (Geographic Displays)
  
Interactive    
      Interactive Charts
      Interactive Multi-View Displays
    
  
  Community Examples


Single-View Plots

Bar Charts


  
  Simple Bar Chart


  
  Responsive Bar Chart


  
  Aggregate Bar Chart


  
  Aggregate Bar Chart (Sorted)


  
  Grouped Bar Chart


  
  Grouped Bar Chart (Multiple Measure with Repeat)


  
  Stacked Bar Chart


  
  Stacked Bar Chart with Rounded Corners


  
  Horizontal Stacked Bar Chart


  
  Normalized (Percentage) Stacked Bar Chart


  
  Normalized (Percentage) Stacked Bar Chart With Labels


  
  Gantt Chart (Ranged Bar Marks)


  
  A Bar Chart Encoding Color Names in the Data


  
  Layered Bar Chart


  
  Diverging Stacked Bar Chart (Population Pyramid)


  
  Diverging Stacked Bar Chart (with Neutral Parts)


  
  Bar Chart with Labels


  
  Bar Chart with Label Overlays


  
  Bar Chart showing Initials of Month Names


  
  Bar Chart with bars center-aligned with time unit ticks


  
  Bar Chart with Negative Values and a Zero-Baseline


  
  Horizontal Bar Chart with Negative Values and Labels


  
  Bar Chart with a Spacing-Saving Y-Axis


  
  Heat Lane Chart



Histograms, Density Plots, and Dot Plots


  
  Histogram


  
  Histogram (from Binned Data)


  
  Log-scaled Histogram


  
  Non-linear Histogram


  
  Relative Frequency Histogram


  
  Density Plot


  
  Stacked Density Estimates


  
  2D Histogram Scatterplot


  
  2D Histogram Heatmap


  
  Cumulative Frequency Distribution


  
  Layered Histogram and Cumulative Histogram


  
  Wilkinson Dot Plot


  
  Isotype Dot Plot


  
  Isotype Dot Plot with Emoji


  
  Relative Bar Chart (Calculate Percentage of Total)



Scatter & Strip Plots


  
  Scatterplot


  
  1D Strip Plot


  
  Strip Plot


  
  Colored Scatterplot


  
  2D Histogram Scatterplot


  
  Bubble Plot


  
  Scatterplot with Null Values in Grey


  
  Scatterplot with Filled Circles


  
  Bubble Plot (Gapminder)


  
  Bubble Plot (Natural Disasters)


  
  Scatter Plot with Text Marks


  
  Image-based Scatter Plot


  
  Strip plot with custom axis tick labels


  
  Dot Plot with Jittering



Line Charts


  
  Line Chart


  
  Line Chart with Point Markers


  
  Line Chart with Stroked Point Markers


  
  Multi Series Line Chart


  
  Multi Series Line Chart with Repeat Operator


  
  Multi Series Line Chart with Halo Stroke


  
  Slope Graph


  
  Step Chart


  
  Line Chart with Monotone Interpolation


  
  Line Chart with Conditional Axis Properties


  
  Connected Scatterplot (Lines with Custom Paths)


  
  Bump Chart


  
  Line Chart with Varying Size (using the trail mark)


  
  A comet chart showing changes between between two states


  
  Line Chart with Markers and Invalid Values


  
  Carbon Dioxide in the Atmosphere


  
  Line Charts Showing Ranks Over Time


  
  Drawing Sine and Cosine Curves with the Sequence Generator


  
  Line chart with varying stroke dash


  
  Line chart with a dashed part



Area Charts & Streamgraphs


  
  Area Chart


  
  Area Chart with Gradient


  
  Area Chart with Overlaying Lines and Point Markers


  
  Stacked Area Chart


  
  Normalized Stacked Area Chart


  
  Streamgraph


  
  Horizon Graph



Table-based Plots


  
  Table Heatmap


  
  Annual Weather Heatmap


  
  2D Histogram Heatmap


  
  Table Bubble Plot (Github Punch Card)


  
  Heatmap with Labels


  
  Lasagna Plot (Dense Time-Series Heatmap)


  
  Mosaic Chart with Labels


  
  Wind Vector Map



Circular Plots


  
  Pie Chart


  
  Pie Chart with percentage_tooltip


  
  Donut Chart


  
  Pie Chart with Labels


  
  Radial Plot


  
  Pyramid Pie Chart



Advanced Calculations


  
  Relative Bar Chart (Calculate Percentage of Total)


  
  Calculate Difference from Average


  
  Calculate Difference from Annual Average


  
  Calculate Residuals


  
  Line Charts Showing Ranks Over Time


  
  Waterfall Chart of Monthly Profit and Loss


  
  Filtering Top-K Items


  
  Top-K Plot with “Others”


  
  Using the lookup transform to combine data


  
  Cumulative Frequency Distribution


  
  Layered Histogram and Cumulative Histogram


  
  Parallel Coordinate Plot


  
  Bar Chart Showing Argmax Value


  
  Layering Averages over Raw Values


  
  Layering Rolling Averages over Raw Values


  
  Line Chart to Show Benchmarking Results


  
  Quantile-Quantile Plot (QQ Plot)


  
  Linear Regression


  
  Loess Regression


  
  Using window transform to impute missing values by averaging the previous and next values.



Composite Marks

Error Bars & Error Bands


  
  Error Bars Showing Confidence Interval


  
  Error Bars Showing Standard Deviation


  
  Line Chart with Confidence Interval Band


  
  Scatterplot with Mean and Standard Deviation Overlay



Box Plots


  
  Box Plot with Min/Max Whiskers


  
  Tukey Box Plot (1.5 IQR)


  
  Box Plot with Pre-Calculated Summaries



Layered Plots

Labeling & Annotation


  
  Simple Bar Chart with Labels


  
  Simple Bar Chart with Labels and Emojis


  
  Layering text over heatmap


  
  Carbon Dioxide in the Atmosphere


  
  Bar Chart Highlighting Values beyond a Threshold


  
  Mean overlay over precipitation chart


  
  Histogram with a Global Mean Overlay


  
  Line Chart with Highlighted Rectangles


  
  Layering Averages over Raw Values


  
  Layering Rolling Averages over Raw Values


  
  Distributions and Medians of Likert Scale Ratings


  
  Comparative Likert Scale Ratings



Other Layered Plots


  
  Candlestick Chart


  
  Ranged Dot Plot


  
  Bullet Chart


  
  Layered Plot with Dual-Axis


  
  Horizon Graph


  
  Weekly Weather Plot


  
  Wheat and Wages Example



Multi-View Displays

Faceting (Trellis Plot / Small Multiples)


  
  Trellis Bar Chart


  
  Trellis Stacked Bar Chart


  
  Trellis Scatter Plot (wrapped)


  
  Trellis Histograms


  
  Trellis Scatter Plot Showing Anscombe’s Quartet


  
  Becker’s Barley Trellis Plot


  
  Trellis Area


  
  Trellis Area Plot Showing Annual Temperatures in Seattle


  
  Faceted Density Plot


  
  Compact Trellis Grid of Bar Charts



Repeat & Concatenation


  
  Repeat and Layer to Show Different Movie Measures


  
  Vertical Concatenation


  
  Horizontally Repeated Charts


  
  Interactive Scatterplot Matrix


  
  Marginal Histograms


  
  Discretizing scales


  
  Nested View Concatenation Aligned with Axis minExtent


  
  Population Pyramid



Maps (Geographic Displays)


  
  Choropleth of Unemployment Rate per County


  
  One Dot per Zipcode in the U.S.


  
  One Dot per Airport in the U.S. Overlayed on Geoshape


  
  Rules (line segments) Connecting SEA to every Airport Reachable via Direct Flights


  
  Three Choropleths Representing Disjoint Data from the Same Table


  
  U.S. State Capitals Overlayed on a Map of U.S.


  
  Line between Airports in the U.S.


  
  Income in the U.S. by State, Faceted over Income Brackets


  
  London Tube Lines


  
  Projection explorer


  
  Earthquakes Example



Interactive

Interactive Charts


  
  Bar Chart with Highlighting on Hover and Selection on Click


  
  Histogram with Full-Height Hover Targets for Tooltip


  
  Interactive Legend


  
  Scatterplot with External Links and Tooltips


  
  Rectangular Brush


  
  Area Chart with Rectangular Brush


  
  Paintbrush Highlight


  
  Scatterplot Pan & Zoom


  
  Query Widgets


  
  Interactive Average


  
  Multi Series Line Chart with an Interactive Line Highlight


  
  Multi Series Line Chart with an Interactive Point Highlight


  
  Multi Series Line Chart with Labels


  
  Multi Series Line Chart with Tooltip


  
  Multi Series Line Chart with Tooltip


  
  Isotype Grid


  
  Brushing Scatter Plot to show data on a table


  
  Selectable Heatmap


  
  Bar Chart with a Minimap


  
  Interactive Index Chart


  
  Focus + Context - Smooth Histogram Zooming


  
  Dynamic Color Legend


  
  Search Input


  
  Change zorder on hover



Interactive Multi-View Displays


  
  Overview and Detail


  
  Crossfilter (Filter)


  
  Crossfilter (Highlight)


  
  Interactive Scatterplot Matrix


  
  Interactive Dashboard with Cross Highlight


  
  Seattle Weather Exploration


  
  Connections among Major U.S. Airports.


  
  An interactive scatter plot of global health statistics by country and year.



Community Examples

Here we list great examples of Vega-Lite visualizations that were created by the community. Please help us expand this gallery by forking our example block and sending us a pull request with your example added to this list.


  Many visualizations in the book Making Data Visual by Danyel Fisher and Miriah Meyer are made with Vega-Lite
  
Grouped Bar Chart by @churtado

  
Bar Chart with Negative Values by @digi0ps

  
Multi Line Highlight by @amitkaps

  
Slope graph by @g3o2

  
Scatter Nearest Rule by @amitkaps

  
Scatter Brush Rule by @amitkaps

  
Unit Chart Rectangular by @amitkaps

  
Unit Chart Stacked by @amitkaps

  
Unit Chart Small Multiple by @amitkaps

  
Dot-dash plot by @g3o2

  
Cumulative Wikipedia Donations by @domoritz

  
CO2 Concentration in the Atmosphere by @domoritz

  
Horizontal Stacked Bar Chart with Labels by @pratapvardhan

  
Interactive stacked time-series by @jakevdp

  
Bicycle Count Time-series with Dynamic Scale by @jakevdp

  
Vega-Lite downloads by @domoritz

  
Waterfall Chart by @italo-batista

  
Bar, Small Multiple, Heatmap, Gantt Charts: Exploring NYC Event Permits by @hydrosquall

  
Image Pixel Render by @amitkaps

  
Top-K Plot with Others by @manzt

  
Trafford Data Lab’s Vega-Lite graphics companion by @trafforddatalab

  
International Flight Map by @alhenry

  
BBC Visual and Data Journalism cookbook port to Vega-Lite by @aezarebski

  
Car Registrations in Portugal - 3 plots with cross-filtering by @jlborges

  
An interactive Rank-Plot by @jlborges

  
An interactive Dashboard by @jlborges

  
Dashboard for the Effects of Labor Market Subsidies in Austria by @schmoigl

  
Size of People around the World by @schmoigl

  
Diverging Dot Plot by @shadfrigui\nVega-Lite
        
          Vega
          Altair
          Vega-Lite API\nVega
          Altair
          Vega-Lite API\nExamples
          Tutorials
          Documentation
          Usage
          Ecosystem
        
        
          GitHub
          Try Online\nExamples
          Tutorials
          Documentation
          Usage
          Ecosystem\nGitHub
          Try Online\nExample Gallery
   This page shows example specifications for different types of graphics. To see example code for embedding visualizations in a webpage, please read the embed documentation.



  
Single-View Plots    
      Bar Charts
      Histograms, Density Plots, and Dot Plots
      Scatter & Strip Plots
      Line Charts
      Area Charts & Streamgraphs
      Table-based Plots
      Circular Plots
      Advanced Calculations
    
  
  
Composite Marks    
      Error Bars & Error Bands
      Box Plots
    
  
  
Layered Plots    
      Labeling & Annotation
      Other Layered Plots
    
  
  
Multi-View Displays    
      Faceting (Trellis Plot / Small Multiples)
      Repeat & Concatenation
    
  
  Maps (Geographic Displays)
  
Interactive    
      Interactive Charts
      Interactive Multi-View Displays
    
  
  Community Examples


Single-View Plots

Bar Charts


  
  Simple Bar Chart


  
  Responsive Bar Chart


  
  Aggregate Bar Chart


  
  Aggregate Bar Chart (Sorted)


  
  Grouped Bar Chart


  
  Grouped Bar Chart (Multiple Measure with Repeat)


  
  Stacked Bar Chart


  
  Stacked Bar Chart with Rounded Corners


  
  Horizontal Stacked Bar Chart


  
  Normalized (Percentage) Stacked Bar Chart


  
  Normalized (Percentage) Stacked Bar Chart With Labels


  
  Gantt Chart (Ranged Bar Marks)


  
  A Bar Chart Encoding Color Names in the Data


  
  Layered Bar Chart


  
  Diverging Stacked Bar Chart (Population Pyramid)


  
  Diverging Stacked Bar Chart (with Neutral Parts)


  
  Bar Chart with Labels


  
  Bar Chart with Label Overlays


  
  Bar Chart showing Initials of Month Names


  
  Bar Chart with bars center-aligned with time unit ticks


  
  Bar Chart with Negative Values and a Zero-Baseline


  
  Horizontal Bar Chart with Negative Values and Labels


  
  Bar Chart with a Spacing-Saving Y-Axis


  
  Heat Lane Chart



Histograms, Density Plots, and Dot Plots


  
  Histogram


  
  Histogram (from Binned Data)


  
  Log-scaled Histogram


  
  Non-linear Histogram


  
  Relative Frequency Histogram


  
  Density Plot


  
  Stacked Density Estimates


  
  2D Histogram Scatterplot


  
  2D Histogram Heatmap


  
  Cumulative Frequency Distribution


  
  Layered Histogram and Cumulative Histogram


  
  Wilkinson Dot Plot


  
  Isotype Dot Plot


  
  Isotype Dot Plot with Emoji


  
  Relative Bar Chart (Calculate Percentage of Total)



Scatter & Strip Plots


  
  Scatterplot


  
  1D Strip Plot


  
  Strip Plot


  
  Colored Scatterplot


  
  2D Histogram Scatterplot


  
  Bubble Plot


  
  Scatterplot with Null Values in Grey


  
  Scatterplot with Filled Circles


  
  Bubble Plot (Gapminder)


  
  Bubble Plot (Natural Disasters)


  
  Scatter Plot with Text Marks


  
  Image-based Scatter Plot


  
  Strip plot with custom axis tick labels


  
  Dot Plot with Jittering



Line Charts


  
  Line Chart


  
  Line Chart with Point Markers


  
  Line Chart with Stroked Point Markers


  
  Multi Series Line Chart


  
  Multi Series Line Chart with Repeat Operator


  
  Multi Series Line Chart with Halo Stroke


  
  Slope Graph


  
  Step Chart


  
  Line Chart with Monotone Interpolation


  
  Line Chart with Conditional Axis Properties


  
  Connected Scatterplot (Lines with Custom Paths)


  
  Bump Chart


  
  Line Chart with Varying Size (using the trail mark)


  
  A comet chart showing changes between between two states


  
  Line Chart with Markers and Invalid Values


  
  Carbon Dioxide in the Atmosphere


  
  Line Charts Showing Ranks Over Time


  
  Drawing Sine and Cosine Curves with the Sequence Generator


  
  Line chart with varying stroke dash


  
  Line chart with a dashed part



Area Charts & Streamgraphs


  
  Area Chart


  
  Area Chart with Gradient


  
  Area Chart with Overlaying Lines and Point Markers


  
  Stacked Area Chart


  
  Normalized Stacked Area Chart


  
  Streamgraph


  
  Horizon Graph



Table-based Plots


  
  Table Heatmap


  
  Annual Weather Heatmap


  
  2D Histogram Heatmap


  
  Table Bubble Plot (Github Punch Card)


  
  Heatmap with Labels


  
  Lasagna Plot (Dense Time-Series Heatmap)


  
  Mosaic Chart with Labels


  
  Wind Vector Map



Circular Plots


  
  Pie Chart


  
  Pie Chart with percentage_tooltip


  
  Donut Chart


  
  Pie Chart with Labels


  
  Radial Plot


  
  Pyramid Pie Chart



Advanced Calculations


  
  Relative Bar Chart (Calculate Percentage of Total)


  
  Calculate Difference from Average


  
  Calculate Difference from Annual Average


  
  Calculate Residuals


  
  Line Charts Showing Ranks Over Time


  
  Waterfall Chart of Monthly Profit and Loss


  
  Filtering Top-K Items


  
  Top-K Plot with “Others”


  
  Using the lookup transform to combine data


  
  Cumulative Frequency Distribution


  
  Layered Histogram and Cumulative Histogram


  
  Parallel Coordinate Plot


  
  Bar Chart Showing Argmax Value


  
  Layering Averages over Raw Values


  
  Layering Rolling Averages over Raw Values


  
  Line Chart to Show Benchmarking Results


  
  Quantile-Quantile Plot (QQ Plot)


  
  Linear Regression


  
  Loess Regression


  
  Using window transform to impute missing values by averaging the previous and next values.



Composite Marks

Error Bars & Error Bands


  
  Error Bars Showing Confidence Interval


  
  Error Bars Showing Standard Deviation


  
  Line Chart with Confidence Interval Band


  
  Scatterplot with Mean and Standard Deviation Overlay



Box Plots


  
  Box Plot with Min/Max Whiskers


  
  Tukey Box Plot (1.5 IQR)


  
  Box Plot with Pre-Calculated Summaries



Layered Plots

Labeling & Annotation


  
  Simple Bar Chart with Labels


  
  Simple Bar Chart with Labels and Emojis


  
  Layering text over heatmap


  
  Carbon Dioxide in the Atmosphere


  
  Bar Chart Highlighting Values beyond a Threshold


  
  Mean overlay over precipitation chart


  
  Histogram with a Global Mean Overlay


  
  Line Chart with Highlighted Rectangles


  
  Layering Averages over Raw Values


  
  Layering Rolling Averages over Raw Values


  
  Distributions and Medians of Likert Scale Ratings


  
  Comparative Likert Scale Ratings



Other Layered Plots


  
  Candlestick Chart


  
  Ranged Dot Plot


  
  Bullet Chart


  
  Layered Plot with Dual-Axis


  
  Horizon Graph


  
  Weekly Weather Plot


  
  Wheat and Wages Example



Multi-View Displays

Faceting (Trellis Plot / Small Multiples)


  
  Trellis Bar Chart


  
  Trellis Stacked Bar Chart


  
  Trellis Scatter Plot (wrapped)


  
  Trellis Histograms


  
  Trellis Scatter Plot Showing Anscombe’s Quartet


  
  Becker’s Barley Trellis Plot


  
  Trellis Area


  
  Trellis Area Plot Showing Annual Temperatures in Seattle


  
  Faceted Density Plot


  
  Compact Trellis Grid of Bar Charts



Repeat & Concatenation


  
  Repeat and Layer to Show Different Movie Measures


  
  Vertical Concatenation


  
  Horizontally Repeated Charts


  
  Interactive Scatterplot Matrix


  
  Marginal Histograms


  
  Discretizing scales


  
  Nested View Concatenation Aligned with Axis minExtent


  
  Population Pyramid



Maps (Geographic Displays)


  
  Choropleth of Unemployment Rate per County


  
  One Dot per Zipcode in the U.S.


  
  One Dot per Airport in the U.S. Overlayed on Geoshape


  
  Rules (line segments) Connecting SEA to every Airport Reachable via Direct Flights


  
  Three Choropleths Representing Disjoint Data from the Same Table


  
  U.S. State Capitals Overlayed on a Map of U.S.


  
  Line between Airports in the U.S.


  
  Income in the U.S. by State, Faceted over Income Brackets


  
  London Tube Lines


  
  Projection explorer


  
  Earthquakes Example



Interactive

Interactive Charts


  
  Bar Chart with Highlighting on Hover and Selection on Click


  
  Histogram with Full-Height Hover Targets for Tooltip


  
  Interactive Legend


  
  Scatterplot with External Links and Tooltips


  
  Rectangular Brush


  
  Area Chart with Rectangular Brush


  
  Paintbrush Highlight


  
  Scatterplot Pan & Zoom


  
  Query Widgets


  
  Interactive Average


  
  Multi Series Line Chart with an Interactive Line Highlight


  
  Multi Series Line Chart with an Interactive Point Highlight


  
  Multi Series Line Chart with Labels


  
  Multi Series Line Chart with Tooltip


  
  Multi Series Line Chart with Tooltip


  
  Isotype Grid


  
  Brushing Scatter Plot to show data on a table


  
  Selectable Heatmap


  
  Bar Chart with a Minimap


  
  Interactive Index Chart


  
  Focus + Context - Smooth Histogram Zooming


  
  Dynamic Color Legend


  
  Search Input


  
  Change zorder on hover



Interactive Multi-View Displays


  
  Overview and Detail


  
  Crossfilter (Filter)


  
  Crossfilter (Highlight)


  
  Interactive Scatterplot Matrix


  
  Interactive Dashboard with Cross Highlight


  
  Seattle Weather Exploration


  
  Connections among Major U.S. Airports.


  
  An interactive scatter plot of global health statistics by country and year.



Community Examples

Here we list great examples of Vega-Lite visualizations that were created by the community. Please help us expand this gallery by forking our example block and sending us a pull request with your example added to this list.


  Many visualizations in the book Making Data Visual by Danyel Fisher and Miriah Meyer are made with Vega-Lite
  
Grouped Bar Chart by @churtado

  
Bar Chart with Negative Values by @digi0ps

  
Multi Line Highlight by @amitkaps

  
Slope graph by @g3o2

  
Scatter Nearest Rule by @amitkaps

  
Scatter Brush Rule by @amitkaps

  
Unit Chart Rectangular by @amitkaps

  
Unit Chart Stacked by @amitkaps

  
Unit Chart Small Multiple by @amitkaps

  
Dot-dash plot by @g3o2

  
Cumulative Wikipedia Donations by @domoritz

  
CO2 Concentration in the Atmosphere by @domoritz

  
Horizontal Stacked Bar Chart with Labels by @pratapvardhan

  
Interactive stacked time-series by @jakevdp

  
Bicycle Count Time-series with Dynamic Scale by @jakevdp

  
Vega-Lite downloads by @domoritz

  
Waterfall Chart by @italo-batista

  
Bar, Small Multiple, Heatmap, Gantt Charts: Exploring NYC Event Permits by @hydrosquall

  
Image Pixel Render by @amitkaps

  
Top-K Plot with Others by @manzt

  
Trafford Data Lab’s Vega-Lite graphics companion by @trafforddatalab

  
International Flight Map by @alhenry

  
BBC Visual and Data Journalism cookbook port to Vega-Lite by @aezarebski

  
Car Registrations in Portugal - 3 plots with cross-filtering by @jlborges

  
An interactive Rank-Plot by @jlborges

  
An interactive Dashboard by @jlborges

  
Dashboard for the Effects of Labor Market Subsidies in Austria by @schmoigl

  
Size of People around the World by @schmoigl

  
Diverging Dot Plot by @shadfrigui\nThis page shows example specifications for different types of graphics. To see example code for embedding visualizations in a webpage, please read the embed documentation.\nSingle-View Plots    
      Bar Charts
      Histograms, Density Plots, and Dot Plots
      Scatter & Strip Plots
      Line Charts
      Area Charts & Streamgraphs
      Table-based Plots
      Circular Plots
      Advanced Calculations\nHistograms, Density Plots, and Dot Plots\nHistograms, Density Plots, and Dot Plots\nScatter & Strip Plots\nScatter & Strip Plots\nArea Charts & Streamgraphs\nArea Charts & Streamgraphs\nAdvanced Calculations\nAdvanced Calculations\nComposite Marks    
      Error Bars & Error Bands
      Box Plots\nError Bars & Error Bands\nError Bars & Error Bands\nLayered Plots    
      Labeling & Annotation
      Other Layered Plots\nLabeling & Annotation\nLabeling & Annotation\nMulti-View Displays    
      Faceting (Trellis Plot / Small Multiples)
      Repeat & Concatenation\nFaceting (Trellis Plot / Small Multiples)\nFaceting (Trellis Plot / Small Multiples)\nRepeat & Concatenation\nRepeat & Concatenation\nMaps (Geographic Displays)\nMaps (Geographic Displays)\nInteractive    
      Interactive Charts
      Interactive Multi-View Displays\nInteractive Multi-View Displays\nInteractive Multi-View Displays\nSimple Bar Chart


  
  Responsive Bar Chart


  
  Aggregate Bar Chart


  
  Aggregate Bar Chart (Sorted)


  
  Grouped Bar Chart


  
  Grouped Bar Chart (Multiple Measure with Repeat)


  
  Stacked Bar Chart


  
  Stacked Bar Chart with Rounded Corners


  
  Horizontal Stacked Bar Chart


  
  Normalized (Percentage) Stacked Bar Chart


  
  Normalized (Percentage) Stacked Bar Chart With Labels


  
  Gantt Chart (Ranged Bar Marks)


  
  A Bar Chart Encoding Color Names in the Data


  
  Layered Bar Chart


  
  Diverging Stacked Bar Chart (Population Pyramid)


  
  Diverging Stacked Bar Chart (with Neutral Parts)


  
  Bar Chart with Labels


  
  Bar Chart with Label Overlays


  
  Bar Chart showing Initials of Month Names


  
  Bar Chart with bars center-aligned with time unit ticks


  
  Bar Chart with Negative Values and a Zero-Baseline


  
  Horizontal Bar Chart with Negative Values and Labels


  
  Bar Chart with a Spacing-Saving Y-Axis


  
  Heat Lane Chart\nSimple Bar Chart


  
  Responsive Bar Chart


  
  Aggregate Bar Chart


  
  Aggregate Bar Chart (Sorted)


  
  Grouped Bar Chart


  
  Grouped Bar Chart (Multiple Measure with Repeat)


  
  Stacked Bar Chart


  
  Stacked Bar Chart with Rounded Corners


  
  Horizontal Stacked Bar Chart


  
  Normalized (Percentage) Stacked Bar Chart


  
  Normalized (Percentage) Stacked Bar Chart With Labels


  
  Gantt Chart (Ranged Bar Marks)


  
  A Bar Chart Encoding Color Names in the Data


  
  Layered Bar Chart


  
  Diverging Stacked Bar Chart (Population Pyramid)


  
  Diverging Stacked Bar Chart (with Neutral Parts)


  
  Bar Chart with Labels


  
  Bar Chart with Label Overlays


  
  Bar Chart showing Initials of Month Names


  
  Bar Chart with bars center-aligned with time unit ticks


  
  Bar Chart with Negative Values and a Zero-Baseline


  
  Horizontal Bar Chart with Negative Values and Labels


  
  Bar Chart with a Spacing-Saving Y-Axis


  
  Heat Lane Chart\nAggregate Bar Chart (Sorted)\nAggregate Bar Chart (Sorted)\nGrouped Bar Chart (Multiple Measure with Repeat)\nGrouped Bar Chart (Multiple Measure with Repeat)\nStacked Bar Chart with Rounded Corners\nStacked Bar Chart with Rounded Corners\nHorizontal Stacked Bar Chart\nHorizontal Stacked Bar Chart\nNormalized (Percentage) Stacked Bar Chart\nNormalized (Percentage) Stacked Bar Chart\nNormalized (Percentage) Stacked Bar Chart With Labels\nNormalized (Percentage) Stacked Bar Chart With Labels\nGantt Chart (Ranged Bar Marks)\nGantt Chart (Ranged Bar Marks)\nA Bar Chart Encoding Color Names in the Data\nA Bar Chart Encoding Color Names in the Data\nDiverging Stacked Bar Chart (Population Pyramid)\nDiverging Stacked Bar Chart (Population Pyramid)\nDiverging Stacked Bar Chart (with Neutral Parts)\nDiverging Stacked Bar Chart (with Neutral Parts)\nBar Chart with Labels\nBar Chart with Labels\nBar Chart with Label Overlays\nBar Chart with Label Overlays\nBar Chart showing Initials of Month Names\nBar Chart showing Initials of Month Names\nBar Chart with bars center-aligned with time unit ticks\nBar Chart with bars center-aligned with time unit ticks\nBar Chart with Negative Values and a Zero-Baseline\nBar Chart with Negative Values and a Zero-Baseline\nHorizontal Bar Chart with Negative Values and Labels\nHorizontal Bar Chart with Negative Values and Labels\nBar Chart with a Spacing-Saving Y-Axis\nBar Chart with a Spacing-Saving Y-Axis\nHistograms, Density Plots, and Dot Plots\nHistogram


  
  Histogram (from Binned Data)


  
  Log-scaled Histogram


  
  Non-linear Histogram


  
  Relative Frequency Histogram


  
  Density Plot


  
  Stacked Density Estimates


  
  2D Histogram Scatterplot


  
  2D Histogram Heatmap


  
  Cumulative Frequency Distribution


  
  Layered Histogram and Cumulative Histogram


  
  Wilkinson Dot Plot


  
  Isotype Dot Plot


  
  Isotype Dot Plot with Emoji


  
  Relative Bar Chart (Calculate Percentage of Total)\nHistogram


  
  Histogram (from Binned Data)


  
  Log-scaled Histogram


  
  Non-linear Histogram


  
  Relative Frequency Histogram


  
  Density Plot


  
  Stacked Density Estimates


  
  2D Histogram Scatterplot


  
  2D Histogram Heatmap


  
  Cumulative Frequency Distribution


  
  Layered Histogram and Cumulative Histogram


  
  Wilkinson Dot Plot


  
  Isotype Dot Plot


  
  Isotype Dot Plot with Emoji


  
  Relative Bar Chart (Calculate Percentage of Total)\nHistogram (from Binned Data)\nHistogram (from Binned Data)\nRelative Frequency Histogram\nRelative Frequency Histogram\nStacked Density Estimates\nStacked Density Estimates\n2D Histogram Scatterplot\n2D Histogram Scatterplot\nCumulative Frequency Distribution\nCumulative Frequency Distribution\nLayered Histogram and Cumulative Histogram\nLayered Histogram and Cumulative Histogram\nIsotype Dot Plot with Emoji\nIsotype Dot Plot with Emoji\nRelative Bar Chart (Calculate Percentage of Total)\nRelative Bar Chart (Calculate Percentage of Total)\nScatter & Strip Plots\nScatterplot


  
  1D Strip Plot


  
  Strip Plot


  
  Colored Scatterplot


  
  2D Histogram Scatterplot


  
  Bubble Plot


  
  Scatterplot with Null Values in Grey


  
  Scatterplot with Filled Circles


  
  Bubble Plot (Gapminder)


  
  Bubble Plot (Natural Disasters)


  
  Scatter Plot with Text Marks


  
  Image-based Scatter Plot


  
  Strip plot with custom axis tick labels


  
  Dot Plot with Jittering\nScatterplot


  
  1D Strip Plot


  
  Strip Plot


  
  Colored Scatterplot


  
  2D Histogram Scatterplot


  
  Bubble Plot


  
  Scatterplot with Null Values in Grey


  
  Scatterplot with Filled Circles


  
  Bubble Plot (Gapminder)


  
  Bubble Plot (Natural Disasters)


  
  Scatter Plot with Text Marks


  
  Image-based Scatter Plot


  
  Strip plot with custom axis tick labels


  
  Dot Plot with Jittering\n2D Histogram Scatterplot\n2D Histogram Scatterplot\nScatterplot with Null Values in Grey\nScatterplot with Null Values in Grey\nScatterplot with Filled Circles\nScatterplot with Filled Circles\nBubble Plot (Gapminder)\nBubble Plot (Gapminder)\nBubble Plot (Natural Disasters)\nBubble Plot (Natural Disasters)\nScatter Plot with Text Marks\nScatter Plot with Text Marks\nImage-based Scatter Plot\nImage-based Scatter Plot\nStrip plot with custom axis tick labels\nStrip plot with custom axis tick labels\nDot Plot with Jittering\nDot Plot with Jittering\nLine Chart


  
  Line Chart with Point Markers


  
  Line Chart with Stroked Point Markers


  
  Multi Series Line Chart


  
  Multi Series Line Chart with Repeat Operator


  
  Multi Series Line Chart with Halo Stroke


  
  Slope Graph


  
  Step Chart


  
  Line Chart with Monotone Interpolation


  
  Line Chart with Conditional Axis Properties


  
  Connected Scatterplot (Lines with Custom Paths)


  
  Bump Chart


  
  Line Chart with Varying Size (using the trail mark)


  
  A comet chart showing changes between between two states


  
  Line Chart with Markers and Invalid Values


  
  Carbon Dioxide in the Atmosphere


  
  Line Charts Showing Ranks Over Time


  
  Drawing Sine and Cosine Curves with the Sequence Generator


  
  Line chart with varying stroke dash


  
  Line chart with a dashed part\nLine Chart


  
  Line Chart with Point Markers


  
  Line Chart with Stroked Point Markers


  
  Multi Series Line Chart


  
  Multi Series Line Chart with Repeat Operator


  
  Multi Series Line Chart with Halo Stroke


  
  Slope Graph


  
  Step Chart


  
  Line Chart with Monotone Interpolation


  
  Line Chart with Conditional Axis Properties


  
  Connected Scatterplot (Lines with Custom Paths)


  
  Bump Chart


  
  Line Chart with Varying Size (using the trail mark)


  
  A comet chart showing changes between between two states


  
  Line Chart with Markers and Invalid Values


  
  Carbon Dioxide in the Atmosphere


  
  Line Charts Showing Ranks Over Time


  
  Drawing Sine and Cosine Curves with the Sequence Generator


  
  Line chart with varying stroke dash


  
  Line chart with a dashed part\nLine Chart with Point Markers\nLine Chart with Point Markers\nLine Chart with Stroked Point Markers\nLine Chart with Stroked Point Markers\nMulti Series Line Chart\nMulti Series Line Chart\nMulti Series Line Chart with Repeat Operator\nMulti Series Line Chart with Repeat Operator\nMulti Series Line Chart with Halo Stroke\nMulti Series Line Chart with Halo Stroke\nLine Chart with Monotone Interpolation\nLine Chart with Monotone Interpolation\nLine Chart with Conditional Axis Properties\nLine Chart with Conditional Axis Properties\nConnected Scatterplot (Lines with Custom Paths)\nConnected Scatterplot (Lines with Custom Paths)\nLine Chart with Varying Size (using the trail mark)\nLine Chart with Varying Size (using the trail mark)\nA comet chart showing changes between between two states\nA comet chart showing changes between between two states\nLine Chart with Markers and Invalid Values\nLine Chart with Markers and Invalid Values\nCarbon Dioxide in the Atmosphere\nCarbon Dioxide in the Atmosphere\nLine Charts Showing Ranks Over Time\nLine Charts Showing Ranks Over Time\nDrawing Sine and Cosine Curves with the Sequence Generator\nDrawing Sine and Cosine Curves with the Sequence Generator\nLine chart with varying stroke dash\nLine chart with varying stroke dash\nLine chart with a dashed part\nLine chart with a dashed part\nArea Charts & Streamgraphs\nArea Chart


  
  Area Chart with Gradient


  
  Area Chart with Overlaying Lines and Point Markers


  
  Stacked Area Chart


  
  Normalized Stacked Area Chart


  
  Streamgraph


  
  Horizon Graph\nArea Chart


  
  Area Chart with Gradient


  
  Area Chart with Overlaying Lines and Point Markers


  
  Stacked Area Chart


  
  Normalized Stacked Area Chart


  
  Streamgraph


  
  Horizon Graph\nArea Chart with Gradient\nArea Chart with Gradient\nArea Chart with Overlaying Lines and Point Markers\nArea Chart with Overlaying Lines and Point Markers\nNormalized Stacked Area Chart\nNormalized Stacked Area Chart\nTable Heatmap


  
  Annual Weather Heatmap


  
  2D Histogram Heatmap


  
  Table Bubble Plot (Github Punch Card)


  
  Heatmap with Labels


  
  Lasagna Plot (Dense Time-Series Heatmap)


  
  Mosaic Chart with Labels


  
  Wind Vector Map\nTable Heatmap


  
  Annual Weather Heatmap


  
  2D Histogram Heatmap


  
  Table Bubble Plot (Github Punch Card)


  
  Heatmap with Labels


  
  Lasagna Plot (Dense Time-Series Heatmap)


  
  Mosaic Chart with Labels


  
  Wind Vector Map\nAnnual Weather Heatmap\nAnnual Weather Heatmap\nTable Bubble Plot (Github Punch Card)\nTable Bubble Plot (Github Punch Card)\nLasagna Plot (Dense Time-Series Heatmap)\nLasagna Plot (Dense Time-Series Heatmap)\nMosaic Chart with Labels\nMosaic Chart with Labels\nPie Chart


  
  Pie Chart with percentage_tooltip


  
  Donut Chart


  
  Pie Chart with Labels


  
  Radial Plot


  
  Pyramid Pie Chart\nPie Chart


  
  Pie Chart with percentage_tooltip


  
  Donut Chart


  
  Pie Chart with Labels


  
  Radial Plot


  
  Pyramid Pie Chart\nPie Chart with percentage_tooltip\nPie Chart with percentage_tooltip\nPie Chart with Labels\nPie Chart with Labels\nAdvanced Calculations\nRelative Bar Chart (Calculate Percentage of Total)


  
  Calculate Difference from Average


  
  Calculate Difference from Annual Average


  
  Calculate Residuals


  
  Line Charts Showing Ranks Over Time


  
  Waterfall Chart of Monthly Profit and Loss


  
  Filtering Top-K Items


  
  Top-K Plot with “Others”


  
  Using the lookup transform to combine data


  
  Cumulative Frequency Distribution


  
  Layered Histogram and Cumulative Histogram


  
  Parallel Coordinate Plot


  
  Bar Chart Showing Argmax Value


  
  Layering Averages over Raw Values


  
  Layering Rolling Averages over Raw Values


  
  Line Chart to Show Benchmarking Results


  
  Quantile-Quantile Plot (QQ Plot)


  
  Linear Regression


  
  Loess Regression


  
  Using window transform to impute missing values by averaging the previous and next values.\nRelative Bar Chart (Calculate Percentage of Total)


  
  Calculate Difference from Average


  
  Calculate Difference from Annual Average


  
  Calculate Residuals


  
  Line Charts Showing Ranks Over Time


  
  Waterfall Chart of Monthly Profit and Loss


  
  Filtering Top-K Items


  
  Top-K Plot with “Others”


  
  Using the lookup transform to combine data


  
  Cumulative Frequency Distribution


  
  Layered Histogram and Cumulative Histogram


  
  Parallel Coordinate Plot


  
  Bar Chart Showing Argmax Value


  
  Layering Averages over Raw Values


  
  Layering Rolling Averages over Raw Values


  
  Line Chart to Show Benchmarking Results


  
  Quantile-Quantile Plot (QQ Plot)


  
  Linear Regression


  
  Loess Regression


  
  Using window transform to impute missing values by averaging the previous and next values.\nRelative Bar Chart (Calculate Percentage of Total)\nRelative Bar Chart (Calculate Percentage of Total)\nCalculate Difference from Average\nCalculate Difference from Average\nCalculate Difference from Annual Average\nCalculate Difference from Annual Average\nLine Charts Showing Ranks Over Time\nLine Charts Showing Ranks Over Time\nWaterfall Chart of Monthly Profit and Loss\nWaterfall Chart of Monthly Profit and Loss\nFiltering Top-K Items\nFiltering Top-K Items\nTop-K Plot with “Others”\nTop-K Plot with “Others”\nUsing the lookup transform to combine data\nUsing the lookup transform to combine data\nCumulative Frequency Distribution\nCumulative Frequency Distribution\nLayered Histogram and Cumulative Histogram\nLayered Histogram and Cumulative Histogram\nParallel Coordinate Plot\nParallel Coordinate Plot\nBar Chart Showing Argmax Value\nBar Chart Showing Argmax Value\nLayering Averages over Raw Values\nLayering Averages over Raw Values\nLayering Rolling Averages over Raw Values\nLayering Rolling Averages over Raw Values\nLine Chart to Show Benchmarking Results\nLine Chart to Show Benchmarking Results\nQuantile-Quantile Plot (QQ Plot)\nQuantile-Quantile Plot (QQ Plot)\nUsing window transform to impute missing values by averaging the previous and next values.\nUsing window transform to impute missing values by averaging the previous and next values.\nError Bars & Error Bands\nError Bars Showing Confidence Interval


  
  Error Bars Showing Standard Deviation


  
  Line Chart with Confidence Interval Band


  
  Scatterplot with Mean and Standard Deviation Overlay\nError Bars Showing Confidence Interval


  
  Error Bars Showing Standard Deviation


  
  Line Chart with Confidence Interval Band


  
  Scatterplot with Mean and Standard Deviation Overlay\nError Bars Showing Confidence Interval\nError Bars Showing Confidence Interval\nError Bars Showing Standard Deviation\nError Bars Showing Standard Deviation\nLine Chart with Confidence Interval Band\nLine Chart with Confidence Interval Band\nScatterplot with Mean and Standard Deviation Overlay\nScatterplot with Mean and Standard Deviation Overlay\nBox Plot with Min/Max Whiskers


  
  Tukey Box Plot (1.5 IQR)


  
  Box Plot with Pre-Calculated Summaries\nBox Plot with Min/Max Whiskers


  
  Tukey Box Plot (1.5 IQR)


  
  Box Plot with Pre-Calculated Summaries\nBox Plot with Min/Max Whiskers\nBox Plot with Min/Max Whiskers\nTukey Box Plot (1.5 IQR)\nTukey Box Plot (1.5 IQR)\nBox Plot with Pre-Calculated Summaries\nBox Plot with Pre-Calculated Summaries\nLabeling & Annotation\nSimple Bar Chart with Labels


  
  Simple Bar Chart with Labels and Emojis


  
  Layering text over heatmap


  
  Carbon Dioxide in the Atmosphere


  
  Bar Chart Highlighting Values beyond a Threshold


  
  Mean overlay over precipitation chart


  
  Histogram with a Global Mean Overlay


  
  Line Chart with Highlighted Rectangles


  
  Layering Averages over Raw Values


  
  Layering Rolling Averages over Raw Values


  
  Distributions and Medians of Likert Scale Ratings


  
  Comparative Likert Scale Ratings\nSimple Bar Chart with Labels


  
  Simple Bar Chart with Labels and Emojis


  
  Layering text over heatmap


  
  Carbon Dioxide in the Atmosphere


  
  Bar Chart Highlighting Values beyond a Threshold


  
  Mean overlay over precipitation chart


  
  Histogram with a Global Mean Overlay


  
  Line Chart with Highlighted Rectangles


  
  Layering Averages over Raw Values


  
  Layering Rolling Averages over Raw Values


  
  Distributions and Medians of Likert Scale Ratings


  
  Comparative Likert Scale Ratings\nSimple Bar Chart with Labels\nSimple Bar Chart with Labels\nSimple Bar Chart with Labels and Emojis\nSimple Bar Chart with Labels and Emojis\nLayering text over heatmap\nLayering text over heatmap\nCarbon Dioxide in the Atmosphere\nCarbon Dioxide in the Atmosphere\nBar Chart Highlighting Values beyond a Threshold\nBar Chart Highlighting Values beyond a Threshold\nMean overlay over precipitation chart\nMean overlay over precipitation chart\nHistogram with a Global Mean Overlay\nHistogram with a Global Mean Overlay\nLine Chart with Highlighted Rectangles\nLine Chart with Highlighted Rectangles\nLayering Averages over Raw Values\nLayering Averages over Raw Values\nLayering Rolling Averages over Raw Values\nLayering Rolling Averages over Raw Values\nDistributions and Medians of Likert Scale Ratings\nDistributions and Medians of Likert Scale Ratings\nComparative Likert Scale Ratings\nComparative Likert Scale Ratings\nCandlestick Chart


  
  Ranged Dot Plot


  
  Bullet Chart


  
  Layered Plot with Dual-Axis


  
  Horizon Graph


  
  Weekly Weather Plot


  
  Wheat and Wages Example\nCandlestick Chart


  
  Ranged Dot Plot


  
  Bullet Chart


  
  Layered Plot with Dual-Axis


  
  Horizon Graph


  
  Weekly Weather Plot


  
  Wheat and Wages Example\nLayered Plot with Dual-Axis\nLayered Plot with Dual-Axis\nWheat and Wages Example\nWheat and Wages Example\nFaceting (Trellis Plot / Small Multiples)\nTrellis Bar Chart


  
  Trellis Stacked Bar Chart


  
  Trellis Scatter Plot (wrapped)


  
  Trellis Histograms


  
  Trellis Scatter Plot Showing Anscombe’s Quartet


  
  Becker’s Barley Trellis Plot


  
  Trellis Area


  
  Trellis Area Plot Showing Annual Temperatures in Seattle


  
  Faceted Density Plot


  
  Compact Trellis Grid of Bar Charts\nTrellis Bar Chart


  
  Trellis Stacked Bar Chart


  
  Trellis Scatter Plot (wrapped)


  
  Trellis Histograms


  
  Trellis Scatter Plot Showing Anscombe’s Quartet


  
  Becker’s Barley Trellis Plot


  
  Trellis Area


  
  Trellis Area Plot Showing Annual Temperatures in Seattle


  
  Faceted Density Plot


  
  Compact Trellis Grid of Bar Charts\nTrellis Stacked Bar Chart\nTrellis Stacked Bar Chart\nTrellis Scatter Plot (wrapped)\nTrellis Scatter Plot (wrapped)\nTrellis Scatter Plot Showing Anscombe’s Quartet\nTrellis Scatter Plot Showing Anscombe’s Quartet\nBecker’s Barley Trellis Plot\nBecker’s Barley Trellis Plot\nTrellis Area Plot Showing Annual Temperatures in Seattle\nTrellis Area Plot Showing Annual Temperatures in Seattle\nCompact Trellis Grid of Bar Charts\nCompact Trellis Grid of Bar Charts\nRepeat & Concatenation\nRepeat and Layer to Show Different Movie Measures


  
  Vertical Concatenation


  
  Horizontally Repeated Charts


  
  Interactive Scatterplot Matrix


  
  Marginal Histograms


  
  Discretizing scales


  
  Nested View Concatenation Aligned with Axis minExtent


  
  Population Pyramid\nRepeat and Layer to Show Different Movie Measures


  
  Vertical Concatenation


  
  Horizontally Repeated Charts


  
  Interactive Scatterplot Matrix


  
  Marginal Histograms


  
  Discretizing scales


  
  Nested View Concatenation Aligned with Axis minExtent


  
  Population Pyramid\nRepeat and Layer to Show Different Movie Measures\nRepeat and Layer to Show Different Movie Measures\nVertical Concatenation\nVertical Concatenation\nHorizontally Repeated Charts\nHorizontally Repeated Charts\nInteractive Scatterplot Matrix\nInteractive Scatterplot Matrix\nNested View Concatenation Aligned with Axis minExtent\nNested View Concatenation Aligned with Axis minExtent\nMaps (Geographic Displays)\nChoropleth of Unemployment Rate per County


  
  One Dot per Zipcode in the U.S.


  
  One Dot per Airport in the U.S. Overlayed on Geoshape


  
  Rules (line segments) Connecting SEA to every Airport Reachable via Direct Flights


  
  Three Choropleths Representing Disjoint Data from the Same Table


  
  U.S. State Capitals Overlayed on a Map of U.S.


  
  Line between Airports in the U.S.


  
  Income in the U.S. by State, Faceted over Income Brackets


  
  London Tube Lines


  
  Projection explorer


  
  Earthquakes Example\nChoropleth of Unemployment Rate per County


  
  One Dot per Zipcode in the U.S.


  
  One Dot per Airport in the U.S. Overlayed on Geoshape


  
  Rules (line segments) Connecting SEA to every Airport Reachable via Direct Flights


  
  Three Choropleths Representing Disjoint Data from the Same Table


  
  U.S. State Capitals Overlayed on a Map of U.S.


  
  Line between Airports in the U.S.


  
  Income in the U.S. by State, Faceted over Income Brackets


  
  London Tube Lines


  
  Projection explorer


  
  Earthquakes Example\nChoropleth of Unemployment Rate per County\nChoropleth of Unemployment Rate per County\nOne Dot per Zipcode in the U.S.\nOne Dot per Zipcode in the U.S.\nOne Dot per Airport in the U.S. Overlayed on Geoshape\nOne Dot per Airport in the U.S. Overlayed on Geoshape\nRules (line segments) Connecting SEA to every Airport Reachable via Direct Flights\nRules (line segments) Connecting SEA to every Airport Reachable via Direct Flights\nThree Choropleths Representing Disjoint Data from the Same Table\nThree Choropleths Representing Disjoint Data from the Same Table\nU.S. State Capitals Overlayed on a Map of U.S.\nU.S. State Capitals Overlayed on a Map of U.S.\nLine between Airports in the U.S.\nLine between Airports in the U.S.\nIncome in the U.S. by State, Faceted over Income Brackets\nIncome in the U.S. by State, Faceted over Income Brackets\nBar Chart with Highlighting on Hover and Selection on Click


  
  Histogram with Full-Height Hover Targets for Tooltip


  
  Interactive Legend


  
  Scatterplot with External Links and Tooltips


  
  Rectangular Brush


  
  Area Chart with Rectangular Brush


  
  Paintbrush Highlight


  
  Scatterplot Pan & Zoom


  
  Query Widgets


  
  Interactive Average


  
  Multi Series Line Chart with an Interactive Line Highlight


  
  Multi Series Line Chart with an Interactive Point Highlight


  
  Multi Series Line Chart with Labels


  
  Multi Series Line Chart with Tooltip


  
  Multi Series Line Chart with Tooltip


  
  Isotype Grid


  
  Brushing Scatter Plot to show data on a table


  
  Selectable Heatmap


  
  Bar Chart with a Minimap


  
  Interactive Index Chart


  
  Focus + Context - Smooth Histogram Zooming


  
  Dynamic Color Legend


  
  Search Input


  
  Change zorder on hover\nBar Chart with Highlighting on Hover and Selection on Click


  
  Histogram with Full-Height Hover Targets for Tooltip


  
  Interactive Legend


  
  Scatterplot with External Links and Tooltips


  
  Rectangular Brush


  
  Area Chart with Rectangular Brush


  
  Paintbrush Highlight


  
  Scatterplot Pan & Zoom


  
  Query Widgets


  
  Interactive Average


  
  Multi Series Line Chart with an Interactive Line Highlight


  
  Multi Series Line Chart with an Interactive Point Highlight


  
  Multi Series Line Chart with Labels


  
  Multi Series Line Chart with Tooltip


  
  Multi Series Line Chart with Tooltip


  
  Isotype Grid


  
  Brushing Scatter Plot to show data on a table


  
  Selectable Heatmap


  
  Bar Chart with a Minimap


  
  Interactive Index Chart


  
  Focus + Context - Smooth Histogram Zooming


  
  Dynamic Color Legend


  
  Search Input


  
  Change zorder on hover\nBar Chart with Highlighting on Hover and Selection on Click\nBar Chart with Highlighting on Hover and Selection on Click\nHistogram with Full-Height Hover Targets for Tooltip\nHistogram with Full-Height Hover Targets for Tooltip\nScatterplot with External Links and Tooltips\nScatterplot with External Links and Tooltips\nArea Chart with Rectangular Brush\nArea Chart with Rectangular Brush\nScatterplot Pan & Zoom\nScatterplot Pan & Zoom\nMulti Series Line Chart with an Interactive Line Highlight\nMulti Series Line Chart with an Interactive Line Highlight\nMulti Series Line Chart with an Interactive Point Highlight\nMulti Series Line Chart with an Interactive Point Highlight\nMulti Series Line Chart with Labels\nMulti Series Line Chart with Labels\nMulti Series Line Chart with Tooltip\nMulti Series Line Chart with Tooltip\nMulti Series Line Chart with Tooltip\nMulti Series Line Chart with Tooltip\nBrushing Scatter Plot to show data on a table\nBrushing Scatter Plot to show data on a table\nBar Chart with a Minimap\nBar Chart with a Minimap\nInteractive Index Chart\nInteractive Index Chart\nFocus + Context - Smooth Histogram Zooming\nFocus + Context - Smooth Histogram Zooming\nChange zorder on hover\nChange zorder on hover\nInteractive Multi-View Displays\nOverview and Detail


  
  Crossfilter (Filter)


  
  Crossfilter (Highlight)


  
  Interactive Scatterplot Matrix


  
  Interactive Dashboard with Cross Highlight


  
  Seattle Weather Exploration


  
  Connections among Major U.S. Airports.


  
  An interactive scatter plot of global health statistics by country and year.\nOverview and Detail


  
  Crossfilter (Filter)


  
  Crossfilter (Highlight)


  
  Interactive Scatterplot Matrix


  
  Interactive Dashboard with Cross Highlight


  
  Seattle Weather Exploration


  
  Connections among Major U.S. Airports.


  
  An interactive scatter plot of global health statistics by country and year.\nCrossfilter (Highlight)\nCrossfilter (Highlight)\nInteractive Scatterplot Matrix\nInteractive Scatterplot Matrix\nInteractive Dashboard with Cross Highlight\nInteractive Dashboard with Cross Highlight\nSeattle Weather Exploration\nSeattle Weather Exploration\nConnections among Major U.S. Airports.\nConnections among Major U.S. Airports.\nAn interactive scatter plot of global health statistics by country and year.\nAn interactive scatter plot of global health statistics by country and year.\nHere we list great examples of Vega-Lite visualizations that were created by the community. Please help us expand this gallery by forking our example block and sending us a pull request with your example added to this list.\nforking our example block\nMany visualizations in the book Making Data Visual by Danyel Fisher and Miriah Meyer are made with Vega-Lite\nGrouped Bar Chart by @churtado\nBar Chart with Negative Values by @digi0ps\nBar Chart with Negative Values\nMulti Line Highlight by @amitkaps\nScatter Nearest Rule by @amitkaps\nScatter Brush Rule by @amitkaps\nUnit Chart Rectangular by @amitkaps\nUnit Chart Rectangular\nUnit Chart Stacked by @amitkaps\nUnit Chart Small Multiple by @amitkaps\nUnit Chart Small Multiple\nDot-dash plot by @g3o2\nCumulative Wikipedia Donations by @domoritz\nCumulative Wikipedia Donations\nCO2 Concentration in the Atmosphere by @domoritz\nCO2 Concentration in the Atmosphere\nHorizontal Stacked Bar Chart with Labels by @pratapvardhan\nHorizontal Stacked Bar Chart with Labels\nInteractive stacked time-series by @jakevdp\nInteractive stacked time-series\nBicycle Count Time-series with Dynamic Scale by @jakevdp\nBicycle Count Time-series with Dynamic Scale\nVega-Lite downloads by @domoritz\nWaterfall Chart by @italo-batista\nBar, Small Multiple, Heatmap, Gantt Charts: Exploring NYC Event Permits by @hydrosquall\nBar, Small Multiple, Heatmap, Gantt Charts: Exploring NYC Event Permits\nImage Pixel Render by @amitkaps\nTop-K Plot with Others by @manzt\nTop-K Plot with Others\nTrafford Data Lab’s Vega-Lite graphics companion by @trafforddatalab\nTrafford Data Lab’s Vega-Lite graphics companion\nInternational Flight Map by @alhenry\nInternational Flight Map\nBBC Visual and Data Journalism cookbook port to Vega-Lite by @aezarebski\nBBC Visual and Data Journalism cookbook port to Vega-Lite\nCar Registrations in Portugal - 3 plots with cross-filtering by @jlborges\nCar Registrations in Portugal - 3 plots with cross-filtering\nAn interactive Rank-Plot by @jlborges\nAn interactive Rank-Plot\nAn interactive Dashboard by @jlborges\nAn interactive Dashboard\nDashboard for the Effects of Labor Market Subsidies in Austria by @schmoigl\nDashboard for the Effects of Labor Market Subsidies in Austria\nSize of People around the World by @schmoigl\nSize of People around the World\nDiverging Dot Plot by @shadfrigui\nEdit this page and submit a pull request!\nEdit this page and submit a pull request!\n\n\nVega-Lite
        
          Vega
          Altair
          Vega-Lite API
        
      
      
        
          Examples
          Tutorials
          Documentation
          Usage
          Ecosystem
        
        
          GitHub
          Try Online
        
      
    
  
  
    



  
    
    Getting Started
    
    
    Exploring Data
    
    
    Paper Figures
    
    
    Streaming Data
    
    
  




  

  
    Introduction to Vega-Lite
    This tutorial will guide through the process of writing a visualization specification in Vega-Lite. We will walk you through all main components of Vega-Lite by adding each of them to an example specification one-by-one. After creating the example visualization, we will also guide you how to embed the final visualization on a web page.

We suggest that you follow along the tutorial by building a visualization in the online editor. Extend your specification in the editor as you read through this tutorial. If something does not work as expected, compare your specifications with ones inside this tutorial.

Tutorial Overview



  Tutorial Overview
  The Data
  Encoding Data with Marks
  Data Transformation: Aggregation
  Customize your Visualization
  Publish your Visualization Online
  Next Steps


The Data

Let’s say you have a tabular data set with a categorical variable in the first column a and a numerical variable in the second column b.


  
    
      a
      b
    
  
  
    
      C
      2
    
    
      C
      7
    
    
      C
      4
    
    
      D
      1
    
    
      D
      2
    
    
      D
      6
    
    
      E
      8
    
    
      E
      4
    
    
      E
      7
    
  


We can represent this data as a JSON array in which each row is an object in the array.

[
  {"a": "C", "b": 2},
  {"a": "C", "b": 7},
  {"a": "C", "b": 4},
  {"a": "D", "b": 1},
  {"a": "D", "b": 2},
  {"a": "D", "b": 6},
  {"a": "E", "b": 8},
  {"a": "E", "b": 4},
  {"a": "E", "b": 7}
]


To visualize this data with Vega-Lite, we can add it directly to the data property in a Vega-Lite specification.

{
  "data": {
    "values": [
      {"a": "C", "b": 2},
      {"a": "C", "b": 7},
      {"a": "C", "b": 4},
      {"a": "D", "b": 1},
      {"a": "D", "b": 2},
      {"a": "D", "b": 6},
      {"a": "E", "b": 8},
      {"a": "E", "b": 4},
      {"a": "E", "b": 7}
    ]
  }
}


The data property defines the data source of the visualization. In this example, we embed the data inline by directly setting values property. Vega-Lite also supports other types of data sources besides inline data.

Encoding Data with Marks

Now we have a data source but we haven’t defined yet how the data should be visualized.

Basic graphical elements in Vega-Lite are marks. Marks provide basic shapes whose properties (such as position, size, and color) can be used to visually encode data, either from a data field (or a variable), or a constant value.

To show the data as a point, we can set the mark property to point.



Now, it looks like we get a point. In fact, Vega-Lite renders one point for each object in the array, but they are all overlapping since we have not specified each point’s position.

To visually separate the points, data variables can be mapped to visual properties of a mark. For example, we can encode the variable a of the data with x channel, which represents the x-position of the points. We can do that by adding an encoding object with its key x mapped to a channel definition that describes variable a.

...
"encoding": {
  "x": {"field": "a", "type": "nominal"}
}
...




The encoding object is a key-value mapping between encoding channels (such as x, y) and definitions of the mapped data fields. The channel definition describes the field’s name (field) and its data type (type). In this example, we map the values for field a to the encoding channel x (the x-location of the points) and set a’s data type to nominal, since it represents categories. (See the documentation for more information about data types.)

In the visualization above, Vega-Lite automatically adds an axis with labels for the different categories as well as an axis title. However, 3 points in each category are still overlapping. So far, we have only defined a visual encoding for the field a. We can also map the field b to the y channel.

...
"y": {"field": "b", "type": "quantitative"}
...


This time we set the field type to be quantitative because the values in field b are numeric.



Now we can see the raw data points. Note that Vega-Lite automatically adds grid lines to the y-axis to facilitate comparison of the b values.

Data Transformation: Aggregation

Vega-Lite also supports data transformation such as aggregation. By adding "aggregate": "average" to the definition of the y channel, we can see the average value of a in each category. For example, the average value of category D is (1 + 2 + 6)/3 = 9/3 = 3.



Great! You computed the aggregate values for each category and visualized the resulting value as a point. Typically aggregated values for categories are visualized using bar charts. To create a bar chart, we have to change the mark type from point to bar.

- "mark": "point"
+ "mark": "bar"




Since the quantitative value is on y, you automatically get a vertical bar chart. If we swap the x and y channel, we get a horizontal bar chart instead.



Customize your Visualization



Vega-Lite automatically provides default properties for the visualization. You can further customize these values by adding more properties. For example, to change the title of the x-axis from Average of b to Mean of b, we can set the title property of the axis in the x channel.



Publish your Visualization Online

You have learned about basic components of a Vega-Lite specification. Now, let’s see how to publish your visualization.

You can use Vega-Embed to embed your Vega-Lite visualization in a webpage. For example, you can create a web page with the following content:

<!doctype html>
<html>
  <head>
    <title>Vega-Lite Bar Chart</title>
    <meta charset="utf-8" />

    <script src="https://cdn.jsdelivr.net/npm/vega@6.0.0"></script>
    <script src="https://cdn.jsdelivr.net/npm/vega-lite@6.1.0"></script>
    <script src="https://cdn.jsdelivr.net/npm/vega-embed@6.29.0"></script>

    <style media="screen">
      /* Add space between Vega-Embed links  */
      .vega-actions a {
        margin-right: 5px;
      }
    </style>
  </head>
  <body>
    <h1>Template for Embedding Vega-Lite Visualization</h1>
    <!-- Container for the visualization -->
    <div id="vis"></div>

    <script>
      // Assign the specification to a local variable vlSpec.
      var vlSpec = {
        $schema: 'https://vega.github.io/schema/vega-lite/v6.json',
        data: {
          values: [
            {a: 'C', b: 2},
            {a: 'C', b: 7},
            {a: 'C', b: 4},
            {a: 'D', b: 1},
            {a: 'D', b: 2},
            {a: 'D', b: 6},
            {a: 'E', b: 8},
            {a: 'E', b: 4},
            {a: 'E', b: 7},
          ],
        },
        mark: 'bar',
        encoding: {
          y: {field: 'a', type: 'nominal'},
          x: {
            aggregate: 'average',
            field: 'b',
            type: 'quantitative',
            axis: {
              title: 'Average of b',
            },
          },
        },
      };

      // Embed the visualization in the container with id `vis`
      vegaEmbed('#vis', vlSpec);
    </script>
  </body>
</html>


In this webpage, we first load the dependencies for Vega-Lite (Vega-Embed, Vega, and Vega-Lite) in the <head/> tag of the document. We also create an HTML <div/> element with id vis to serve as a container for the visualization.

In the JavaScript code, we create a variable vlSpec that holds the Vega-Lite specification in JSON format. The vegaEmbed method translates a Vega-Lite specification into a Vega specification and then calls the Vega Runtime to display visualization in the container <div/> element.

If viewed in a browser, this page displays our bar chart like on our demo page. You can also fork our Vega-Lite Block example.

Next Steps

Now you can create a website that embeds a Vega-Lite specification. If you want to learn more about Vega-Lite, please feel free to:


  Read the next tutorial.
  See the examples gallery.
  Build your own visualizations in the online editor.
  Browse through the documentation.
  See the list of applications that you can use Vega-Lite with.\nVega-Lite
        
          Vega
          Altair
          Vega-Lite API\nVega
          Altair
          Vega-Lite API\nExamples
          Tutorials
          Documentation
          Usage
          Ecosystem
        
        
          GitHub
          Try Online\nExamples
          Tutorials
          Documentation
          Usage
          Ecosystem\nGitHub
          Try Online\nGetting Started
    
    
    Exploring Data
    
    
    Paper Figures
    
    
    Streaming Data\nIntroduction to Vega-Lite
    This tutorial will guide through the process of writing a visualization specification in Vega-Lite. We will walk you through all main components of Vega-Lite by adding each of them to an example specification one-by-one. After creating the example visualization, we will also guide you how to embed the final visualization on a web page.

We suggest that you follow along the tutorial by building a visualization in the online editor. Extend your specification in the editor as you read through this tutorial. If something does not work as expected, compare your specifications with ones inside this tutorial.

Tutorial Overview



  Tutorial Overview
  The Data
  Encoding Data with Marks
  Data Transformation: Aggregation
  Customize your Visualization
  Publish your Visualization Online
  Next Steps


The Data

Let’s say you have a tabular data set with a categorical variable in the first column a and a numerical variable in the second column b.


  
    
      a
      b
    
  
  
    
      C
      2
    
    
      C
      7
    
    
      C
      4
    
    
      D
      1
    
    
      D
      2
    
    
      D
      6
    
    
      E
      8
    
    
      E
      4
    
    
      E
      7
    
  


We can represent this data as a JSON array in which each row is an object in the array.

[
  {"a": "C", "b": 2},
  {"a": "C", "b": 7},
  {"a": "C", "b": 4},
  {"a": "D", "b": 1},
  {"a": "D", "b": 2},
  {"a": "D", "b": 6},
  {"a": "E", "b": 8},
  {"a": "E", "b": 4},
  {"a": "E", "b": 7}
]


To visualize this data with Vega-Lite, we can add it directly to the data property in a Vega-Lite specification.

{
  "data": {
    "values": [
      {"a": "C", "b": 2},
      {"a": "C", "b": 7},
      {"a": "C", "b": 4},
      {"a": "D", "b": 1},
      {"a": "D", "b": 2},
      {"a": "D", "b": 6},
      {"a": "E", "b": 8},
      {"a": "E", "b": 4},
      {"a": "E", "b": 7}
    ]
  }
}


The data property defines the data source of the visualization. In this example, we embed the data inline by directly setting values property. Vega-Lite also supports other types of data sources besides inline data.

Encoding Data with Marks

Now we have a data source but we haven’t defined yet how the data should be visualized.

Basic graphical elements in Vega-Lite are marks. Marks provide basic shapes whose properties (such as position, size, and color) can be used to visually encode data, either from a data field (or a variable), or a constant value.

To show the data as a point, we can set the mark property to point.



Now, it looks like we get a point. In fact, Vega-Lite renders one point for each object in the array, but they are all overlapping since we have not specified each point’s position.

To visually separate the points, data variables can be mapped to visual properties of a mark. For example, we can encode the variable a of the data with x channel, which represents the x-position of the points. We can do that by adding an encoding object with its key x mapped to a channel definition that describes variable a.

...
"encoding": {
  "x": {"field": "a", "type": "nominal"}
}
...




The encoding object is a key-value mapping between encoding channels (such as x, y) and definitions of the mapped data fields. The channel definition describes the field’s name (field) and its data type (type). In this example, we map the values for field a to the encoding channel x (the x-location of the points) and set a’s data type to nominal, since it represents categories. (See the documentation for more information about data types.)

In the visualization above, Vega-Lite automatically adds an axis with labels for the different categories as well as an axis title. However, 3 points in each category are still overlapping. So far, we have only defined a visual encoding for the field a. We can also map the field b to the y channel.

...
"y": {"field": "b", "type": "quantitative"}
...


This time we set the field type to be quantitative because the values in field b are numeric.



Now we can see the raw data points. Note that Vega-Lite automatically adds grid lines to the y-axis to facilitate comparison of the b values.

Data Transformation: Aggregation

Vega-Lite also supports data transformation such as aggregation. By adding "aggregate": "average" to the definition of the y channel, we can see the average value of a in each category. For example, the average value of category D is (1 + 2 + 6)/3 = 9/3 = 3.



Great! You computed the aggregate values for each category and visualized the resulting value as a point. Typically aggregated values for categories are visualized using bar charts. To create a bar chart, we have to change the mark type from point to bar.

- "mark": "point"
+ "mark": "bar"




Since the quantitative value is on y, you automatically get a vertical bar chart. If we swap the x and y channel, we get a horizontal bar chart instead.



Customize your Visualization



Vega-Lite automatically provides default properties for the visualization. You can further customize these values by adding more properties. For example, to change the title of the x-axis from Average of b to Mean of b, we can set the title property of the axis in the x channel.



Publish your Visualization Online

You have learned about basic components of a Vega-Lite specification. Now, let’s see how to publish your visualization.

You can use Vega-Embed to embed your Vega-Lite visualization in a webpage. For example, you can create a web page with the following content:

<!doctype html>
<html>
  <head>
    <title>Vega-Lite Bar Chart</title>
    <meta charset="utf-8" />

    <script src="https://cdn.jsdelivr.net/npm/vega@6.0.0"></script>
    <script src="https://cdn.jsdelivr.net/npm/vega-lite@6.1.0"></script>
    <script src="https://cdn.jsdelivr.net/npm/vega-embed@6.29.0"></script>

    <style media="screen">
      /* Add space between Vega-Embed links  */
      .vega-actions a {
        margin-right: 5px;
      }
    </style>
  </head>
  <body>
    <h1>Template for Embedding Vega-Lite Visualization</h1>
    <!-- Container for the visualization -->
    <div id="vis"></div>

    <script>
      // Assign the specification to a local variable vlSpec.
      var vlSpec = {
        $schema: 'https://vega.github.io/schema/vega-lite/v6.json',
        data: {
          values: [
            {a: 'C', b: 2},
            {a: 'C', b: 7},
            {a: 'C', b: 4},
            {a: 'D', b: 1},
            {a: 'D', b: 2},
            {a: 'D', b: 6},
            {a: 'E', b: 8},
            {a: 'E', b: 4},
            {a: 'E', b: 7},
          ],
        },
        mark: 'bar',
        encoding: {
          y: {field: 'a', type: 'nominal'},
          x: {
            aggregate: 'average',
            field: 'b',
            type: 'quantitative',
            axis: {
              title: 'Average of b',
            },
          },
        },
      };

      // Embed the visualization in the container with id `vis`
      vegaEmbed('#vis', vlSpec);
    </script>
  </body>
</html>


In this webpage, we first load the dependencies for Vega-Lite (Vega-Embed, Vega, and Vega-Lite) in the <head/> tag of the document. We also create an HTML <div/> element with id vis to serve as a container for the visualization.

In the JavaScript code, we create a variable vlSpec that holds the Vega-Lite specification in JSON format. The vegaEmbed method translates a Vega-Lite specification into a Vega specification and then calls the Vega Runtime to display visualization in the container <div/> element.

If viewed in a browser, this page displays our bar chart like on our demo page. You can also fork our Vega-Lite Block example.

Next Steps

Now you can create a website that embeds a Vega-Lite specification. If you want to learn more about Vega-Lite, please feel free to:


  Read the next tutorial.
  See the examples gallery.
  Build your own visualizations in the online editor.
  Browse through the documentation.
  See the list of applications that you can use Vega-Lite with.\nIntroduction to Vega-Lite\nThis tutorial will guide through the process of writing a visualization specification in Vega-Lite. We will walk you through all main components of Vega-Lite by adding each of them to an example specification one-by-one. After creating the example visualization, we will also guide you how to embed the final visualization on a web page.\nWe suggest that you follow along the tutorial by building a visualization in the online editor. Extend your specification in the editor as you read through this tutorial. If something does not work as expected, compare your specifications with ones inside this tutorial.\nEncoding Data with Marks\nEncoding Data with Marks\nData Transformation: Aggregation\nData Transformation: Aggregation\nCustomize your Visualization\nCustomize your Visualization\nPublish your Visualization Online\nPublish your Visualization Online\nLet’s say you have a tabular data set with a categorical variable in the first column a and a numerical variable in the second column b.\nWe can represent this data as a JSON array in which each row is an object in the array.\nTo visualize this data with Vega-Lite, we can add it directly to the data property in a Vega-Lite specification.\nThe data property defines the data source of the visualization. In this example, we embed the data inline by directly setting values property. Vega-Lite also supports other types of data sources besides inline data.\nother types of data sources\nEncoding Data with Marks\nNow we have a data source but we haven’t defined yet how the data should be visualized.\nBasic graphical elements in Vega-Lite are marks. Marks provide basic shapes whose properties (such as position, size, and color) can be used to visually encode data, either from a data field (or a variable), or a constant value.\nTo show the data as a point, we can set the mark property to point.\nNow, it looks like we get a point. In fact, Vega-Lite renders one point for each object in the array, but they are all overlapping since we have not specified each point’s position.\nTo visually separate the points, data variables can be mapped to visual properties of a mark. For example, we can encode the variable a of the data with x channel, which represents the x-position of the points. We can do that by adding an encoding object with its key x mapped to a channel definition that describes variable a.\nThe encoding object is a key-value mapping between encoding channels (such as x, y) and definitions of the mapped data fields. The channel definition describes the field’s name (field) and its data type (type). In this example, we map the values for field a to the encoding channel x (the x-location of the points) and set a’s data type to nominal, since it represents categories. (See the documentation for more information about data types.)\nthe documentation for more information about data types\nIn the visualization above, Vega-Lite automatically adds an axis with labels for the different categories as well as an axis title. However, 3 points in each category are still overlapping. So far, we have only defined a visual encoding for the field a. We can also map the field b to the y channel.\nThis time we set the field type to be quantitative because the values in field b are numeric.\nNow we can see the raw data points. Note that Vega-Lite automatically adds grid lines to the y-axis to facilitate comparison of the b values.\nData Transformation: Aggregation\nVega-Lite also supports data transformation such as aggregation. By adding "aggregate": "average" to the definition of the y channel, we can see the average value of a in each category. For example, the average value of category D is (1 + 2 + 6)/3 = 9/3 = 3.\nGreat! You computed the aggregate values for each category and visualized the resulting value as a point. Typically aggregated values for categories are visualized using bar charts. To create a bar chart, we have to change the mark type from point to bar.\nSince the quantitative value is on y, you automatically get a vertical bar chart. If we swap the x and y channel, we get a horizontal bar chart instead.\nCustomize your Visualization\nVega-Lite automatically provides default properties for the visualization. You can further customize these values by adding more properties. For example, to change the title of the x-axis from Average of b to Mean of b, we can set the title property of the axis in the x channel.\nPublish your Visualization Online\nYou have learned about basic components of a Vega-Lite specification. Now, let’s see how to publish your visualization.\nYou can use Vega-Embed to embed your Vega-Lite visualization in a webpage. For example, you can create a web page with the following content:\nIn this webpage, we first load the dependencies for Vega-Lite (Vega-Embed, Vega, and Vega-Lite) in the <head/> tag of the document. We also create an HTML <div/> element with id vis to serve as a container for the visualization.\nIn the JavaScript code, we create a variable vlSpec that holds the Vega-Lite specification in JSON format. The vegaEmbed method translates a Vega-Lite specification into a Vega specification and then calls the Vega Runtime to display visualization in the container <div/> element.\nIf viewed in a browser, this page displays our bar chart like on our demo page. You can also fork our Vega-Lite Block example.\nVega-Lite Block example\nNow you can create a website that embeds a Vega-Lite specification. If you want to learn more about Vega-Lite, please feel free to:\nRead the next tutorial.\nSee the examples gallery.\nBuild your own visualizations in the online editor.\nBrowse through the documentation.\nSee the list of applications that you can use Vega-Lite with.\nEdit this page and submit a pull request!\nEdit this page and submit a pull request!\n\n\nVega-Lite
        
          Vega
          Altair
          Vega-Lite API
        
      
      
        
          Examples
          Tutorials
          Documentation
          Usage
          Ecosystem
        
        
          GitHub
          Try Online
        
      
    
  
  
    




  
  
    
      
      
      Overview
      
      
      
      
      
      View Specification
      
      
      
        
        Title
        
        
        Width / Height
        
        
      
      
      
      
      
      Data / Datasets
      
      
      
      
      
      Transform
      
      
      
        
        Aggregate
        
        
        Bin
        
        
        Calculate
        
        
        Density
        
        
        Extent
        
        
        Filter
        
        
        Flatten
        
        
        Fold
        
        
        Impute
        
        
        Join Aggregate
        
        
        Loess
        
        
        Lookup
        
        
        Pivot
        
        
        Quantile
        
        
        Regression
        
        
        Sample
        
        
        Stack
        
        
        Time Unit
        
        
        Window
        
        
      
      
      
      
      
      Mark
      
      
      
        
        Arc
        
        
        Area
        
        
        Bar
        
        
        Box Plot
        
        
        Circle
        
        
        Error Band
        
        
        Error Bar
        
        
        Geoshape
        
        
        Image
        
        
        Line
        
        
        Point
        
        
        Rect
        
        
        Rule
        
        
        Square
        
        
        Text
        
        
        Tick
        
        
        Trail
        
        
      
      
      
      
      
      Encoding
      
      
      
        
        Aggregate
        
        
        Axis
        
        
        Band Position
        
        
        Bin
        
        
        Condition
        
        
        Datum
        
        
        Field
        
        
        Format
        
        
        Header
        
        
        Impute
        
        
        Legend
        
        
        Scale
        
        
        Stack
        
        
        Sort
        
        
        Time Unit
        
        
        Type
        
        
        Value
        
        
      
      
      
      
      
      Projection
      
      
      
      
      
      View Composition
      
      
      
        
        Facet
        
        
        Layer
        
        
        Concat
        
        
        Repeat
        
        
        Resolve
        
        
      
      
      
      
      
      Parameter
      
      
      
        
        Value
        
        
        Expr
        
        
        Bind
        
        
        Select
        
        
      
      
      
      
      
      Config
      
      
      
      
      
      
      
      
      
      Property Types
      
      
      
        
        Date Time
        
        
        Gradient
        
        
        Predicate
        
        
      
      
      
      
      
      Tooltip
      
      
      
      
      
      Invalid Data
      
      
      
      
    
  
  

  
    Overview
    
  Edit this page

Vega-Lite is a high-level grammar for interactive graphics. It provides a concise JSON syntax for supporting rapid generation of interactive multi-view visualizations to support analysis. Vega-Lite can serve as a declarative format for describing and creating data visualizations. To use Vega-Lite, our compiler compiles a Vega-Lite specification into a lower-level, more detailed Vega specifications and rendered using Vega’s compiler.

This documentation describes the JSON specification language and how to use Vega-Lite visualizations in a web application.


  
  
  
    Search
  


Table of Contents

Below is an overview of the documentation for Vega-Lite properties. See the specification page for an overview of Vega-Lite specifications.


  Overview
    
      Table of Contents
    
  
  View Specification
    
      Documentation Overview
      Common Properties of Specifications
      Top-Level Specifications
      Single View Specifications
      Layered and Multi-view Specifications
      View Configuration
      Title
        
          Title Properties Object
          Title Config
        
      
      Width / Height
        
          Documentation Overview
          Width and Height of Single and Layered Plots
          Width and Height of Multi-View Displays
        
      
    
  
  Data / Datasets
    
      Documentation Overview
      Types of Data Sources
      Format
      Data Generators
      Datasets
    
  
  Transform
    
      View-level Transform Property
      Aggregate
        
          Documentation Overview
          Aggregate in Encoding Field Definition
          Aggregate Transform
          Supported Aggregation Operations
          Argmin / Argmax
        
      
      Bin
        
          Documentation Overview
          Binning in Encoding Field Definition
          Bin Transform
          Bin Parameters
          Ordinal Bin
        
      
      Calculate
        
          Calculate Transform Definition
          Example
        
      
      Density
        
          Density Transform Definition
          Usage
        
      
      Extent
        
          Extent Transform Definition
          Usage
          Example
        
      
      Filter
      Flatten
        
          Flatten Transform Definition
          Usage
          Examples
        
      
      Fold
        
          Fold Transform Definition
          Usage
          Example
        
      
      Impute
        
          Documentation Overview
          Impute in Encoding Field Definition
          Impute Transform
        
      
      Join Aggregate
        
          Documentation Overview
          Join Aggregate Field Definition
          Join Aggregate Transform Definition
          Examples
        
      
      Loess
        
          Loess Transform Definition
          Usage
          Example
        
      
      Lookup
        
          Lookup Transform
        
      
      Pivot
        
          Pivot Transform Definition
          Usage
          Example
        
      
      Quantile
        
          Quantile Transform Definition
          Usage
        
      
      Regression
        
          Regression Transform Definition
          Usage
          Example
        
      
      Sample
        
          Sample Transform Definition
          Usage
          Example
        
      
      Stack
        
          Documentation Overview
          Stack in Encoding Field Definition
          Stack Transform
        
      
      Time Unit
        
          Documentation Overview
          Time Unit in Encoding Field Definition
          Time Unit Transform
          UTC time
          Time Unit Parameters
        
      
      Window
        
          Documentation Overview
          Window Field Definition
          Window Transform Definition
          Window Only Operation Reference
          Examples
        
      
    
  
  Mark
    
      Documentation Overview
      Mark Types
      Mark Definition Object
      Mark Config
      Mark Style Config
      Arc
        
          Documentation Overview
          Arc Mark Properties
          Examples
          Arc Config
          Faceted Pie Charts
        
      
      Area
        
          Documentation Overview
          Area Mark Properties
          Examples
          Area Config
        
      
      Bar
        
          Documentation Overview
          Bar Mark Properties
          Examples
          Bar Config
        
      
      Box Plot
        
          Documentation Overview
          Box Plot Mark Properties
          Types of Box Plot
          Dimension & Orientation
          The Parts of Box Plots
          Color, Size, and Opacity Encoding Channels
          Tooltip Encoding Channels
          Mark Config
          Box Plot with Pre-Calculated Summaries
        
      
      Circle
        
          Circle Mark Properties
          Examples
          Circle Config
        
      
      Error Band
        
          Documentation Overview
          Error Band Mark Properties
          Comparing the usage of Error Band to the usage of Error Bar
          Using Error Band to Aggregate Raw Data
          Using Error Band to Visualize Aggregated Data
          Dimension
          The Parts of Error Band
          Color, and Opacity Encoding Channels
          Tooltip Encoding Channels
          Mark Config
        
      
      Error Bar
        
          Documentation Overview
          Error Bar Mark Properties
          Using Error Bars to Aggregate Raw Data
          Using Error Bars to Visualize Aggregated Data
          Dimension & Orientation
          The Parts of Error Bars
          Color, and Opacity Encoding Channels
          Tooltip Encoding Channels
          Mark Config
        
      
      Geoshape
        
          Geoshape Config
        
      
      Image
        
          Documentation Overview
          Image Mark Properties
          Examples
          Image Config
        
      
      Line
        
          Documentation Overview
          Line Mark Properties
          Examples
          Line Config
        
      
      Point
        
          Documentation Overview
          Point Mark Properties
          Examples
          Point Config
        
      
      Rect
        
          Documentation Overview
          Rect Mark Properties
          Examples
          Rect Config
        
      
      Rule
        
          Documentation Overview
          Rule Mark Properties
          Examples
          Rule Config
        
      
      Square
        
          Square Mark Properties
          Example: Scatterplot with Square
          Square Config
        
      
      Text
        
          Documentation Overview
          Text Mark Properties
          Examples
          Text Config
        
      
      Tick
        
          Documentation Overview
          Tick Mark Properties
          Examples
          Tick Config
        
      
      Trail
        
          Documentation Overview
          Trail Mark Properties
          Examples
          Trail Config
        
      
    
  
  Encoding
    
      Encoding Channels
      Channel Definition
      Position Channels
      Position Offset Channels
      Polar Position Channels
      Geographic Position Channels
      Mark Property Channels
      Text and Tooltip Channels
      Hyperlink Channel
      Description Channel
      Level of Detail Channel
      Key Channel
      Order Channel
      Facet Channels
      Aggregate
        
          Documentation Overview
          Aggregate in Encoding Field Definition
          Aggregate Transform
          Supported Aggregation Operations
          Argmin / Argmax
        
      
      Axis
        
          Documentation Overview
          Axis Properties
          Axis Config
        
      
      Band Position
        
          Examples
        
      
      Bin
        
          Documentation Overview
          Binning in Encoding Field Definition
          Bin Transform
          Bin Parameters
          Ordinal Bin
        
      
      Condition
        
          Conditional Field Definition
          Conditional Value Definition
        
      
      Datum
        
          Examples
        
      
      Field
      Format
        
          Formatting Text Marks and Tooltips
          Formatting Axis, Legend, and Header Labels
        
      
      Header
        
          Documentation Overview
          Header Properties
          Header Config
        
      
      Impute
        
          Documentation Overview
          Impute in Encoding Field Definition
          Impute Transform
        
      
      Legend
        
          Legend Types
          Combined Legend
          Legend Properties
          Legend Config
        
      
      Scale
        
          Documentation Overview
          Scale Types
          Scale Domains
          Scale Ranges
          Common Scale Properties
          Continuous Scales
          Discrete Scales
          Discretizing Scales
          Disabling Scale
          Configuration
        
      
      Stack
        
          Documentation Overview
          Stack in Encoding Field Definition
          Stack Transform
        
      
      Sort
        
          Documentation Overview
          Sorting Continuous Fields
          Sorting Discrete Fields
        
      
      Time Unit
        
          Documentation Overview
          Time Unit in Encoding Field Definition
          Time Unit Transform
          UTC time
          Time Unit Parameters
        
      
      Type
        
          Quantitative
          Temporal
          Ordinal
          Nominal
          GeoJSON
        
      
      Value
    
  
  Projection
    
      Documentation Overview
      Projection Properties
      Projection Types
      Projection Configuration
    
  
  View Composition
    
      Documentation Overview
      Faceting
      Layering
      Concatenation
      Repeating
      Resolution
      Facet
        
          Documentation Overview
          Facet Operator
          Facet, Row, and Column Encoding Channels
          Resolve
          Facet Configuration
        
      
      Layer
        
          Example
        
      
      Concat
        
          Documentation Overview
          Horizontal Concatenation
          Vertical Concatenation
          General (Wrappable) Concatenation
          Resolve
          Concat Configuration
        
      
      Repeat
        
          Documentation Overview
          Repeat Operator
          Row/Column/Layer Repeat Mapping
          Examples
          Resolve
          Repeat Configuration
        
      
      Resolve
        
          Example
        
      
    
  
  Parameter
    
      Documentation Overview
      Defining a Parameter
      Using Parameters
      Selection Configuration
      Value
        
          Examples
        
      
      Expr
        
          Documentation Overview
          Defining a Parameter
          Using Parameters
          Selection Configuration
        
      
      Bind
        
          Input Element Binding
          Legend Binding
          Scale Binding
        
      
      Select
        
          Documentation Overview
          Common Selection Properties
          Point Selection Properties
          Interval Selection Properties
        
      
    
  
  Config
    
      Top-level Configuration
      Format Configuration
      Guide Configurations
      Mark Configurations
      Style Configuration
      Scale and Scale Range Configuration
      Projection Configuration
      Selection Configuration
      Title Configuration
      View & View Composition Configuration
      Locale Configuration
      ARIA Configuration
    
  
  Property Types
    
      Documentation Overview
      Primitive Types
      Special Object Types
      Date Time
      Gradient
        
          Linear Gradient
          Radial Gradient
          Gradient Stop
        
      
      Predicate
        
          Field Predicate
          Parameter Predicate
          Predicate Composition
        
      
    
  
  Tooltip
    
      Documentation Overview
      Tooltip Based on Encoding
      Tooltip Based on Underlying Data Point
      Tooltip channel
      Tooltip image
      Disable tooltips
      Vega Tooltip plugin
    
  
  Invalid Data
    
      Documentation Overview
      Mark Invalid Mode
      Scale Output for Invalid Values
      Other solutions\nVega-Lite
        
          Vega
          Altair
          Vega-Lite API\nVega
          Altair
          Vega-Lite API\nExamples
          Tutorials
          Documentation
          Usage
          Ecosystem
        
        
          GitHub
          Try Online\nExamples
          Tutorials
          Documentation
          Usage
          Ecosystem\nGitHub
          Try Online\nOverview
      
      
      
      
      
      View Specification
      
      
      
        
        Title
        
        
        Width / Height
        
        
      
      
      
      
      
      Data / Datasets
      
      
      
      
      
      Transform
      
      
      
        
        Aggregate
        
        
        Bin
        
        
        Calculate
        
        
        Density
        
        
        Extent
        
        
        Filter
        
        
        Flatten
        
        
        Fold
        
        
        Impute
        
        
        Join Aggregate
        
        
        Loess
        
        
        Lookup
        
        
        Pivot
        
        
        Quantile
        
        
        Regression
        
        
        Sample
        
        
        Stack
        
        
        Time Unit
        
        
        Window
        
        
      
      
      
      
      
      Mark
      
      
      
        
        Arc
        
        
        Area
        
        
        Bar
        
        
        Box Plot
        
        
        Circle
        
        
        Error Band
        
        
        Error Bar
        
        
        Geoshape
        
        
        Image
        
        
        Line
        
        
        Point
        
        
        Rect
        
        
        Rule
        
        
        Square
        
        
        Text
        
        
        Tick
        
        
        Trail
        
        
      
      
      
      
      
      Encoding
      
      
      
        
        Aggregate
        
        
        Axis
        
        
        Band Position
        
        
        Bin
        
        
        Condition
        
        
        Datum
        
        
        Field
        
        
        Format
        
        
        Header
        
        
        Impute
        
        
        Legend
        
        
        Scale
        
        
        Stack
        
        
        Sort
        
        
        Time Unit
        
        
        Type
        
        
        Value
        
        
      
      
      
      
      
      Projection
      
      
      
      
      
      View Composition
      
      
      
        
        Facet
        
        
        Layer
        
        
        Concat
        
        
        Repeat
        
        
        Resolve
        
        
      
      
      
      
      
      Parameter
      
      
      
        
        Value
        
        
        Expr
        
        
        Bind
        
        
        Select
        
        
      
      
      
      
      
      Config
      
      
      
      
      
      
      
      
      
      Property Types
      
      
      
        
        Date Time
        
        
        Gradient
        
        
        Predicate
        
        
      
      
      
      
      
      Tooltip
      
      
      
      
      
      Invalid Data
      
      
      
      
    
  
  

  
    Overview
    
  Edit this page

Vega-Lite is a high-level grammar for interactive graphics. It provides a concise JSON syntax for supporting rapid generation of interactive multi-view visualizations to support analysis. Vega-Lite can serve as a declarative format for describing and creating data visualizations. To use Vega-Lite, our compiler compiles a Vega-Lite specification into a lower-level, more detailed Vega specifications and rendered using Vega’s compiler.

This documentation describes the JSON specification language and how to use Vega-Lite visualizations in a web application.


  
  
  
    Search
  


Table of Contents

Below is an overview of the documentation for Vega-Lite properties. See the specification page for an overview of Vega-Lite specifications.


  Overview
    
      Table of Contents
    
  
  View Specification
    
      Documentation Overview
      Common Properties of Specifications
      Top-Level Specifications
      Single View Specifications
      Layered and Multi-view Specifications
      View Configuration
      Title
        
          Title Properties Object
          Title Config
        
      
      Width / Height
        
          Documentation Overview
          Width and Height of Single and Layered Plots
          Width and Height of Multi-View Displays
        
      
    
  
  Data / Datasets
    
      Documentation Overview
      Types of Data Sources
      Format
      Data Generators
      Datasets
    
  
  Transform
    
      View-level Transform Property
      Aggregate
        
          Documentation Overview
          Aggregate in Encoding Field Definition
          Aggregate Transform
          Supported Aggregation Operations
          Argmin / Argmax
        
      
      Bin
        
          Documentation Overview
          Binning in Encoding Field Definition
          Bin Transform
          Bin Parameters
          Ordinal Bin
        
      
      Calculate
        
          Calculate Transform Definition
          Example
        
      
      Density
        
          Density Transform Definition
          Usage
        
      
      Extent
        
          Extent Transform Definition
          Usage
          Example
        
      
      Filter
      Flatten
        
          Flatten Transform Definition
          Usage
          Examples
        
      
      Fold
        
          Fold Transform Definition
          Usage
          Example
        
      
      Impute
        
          Documentation Overview
          Impute in Encoding Field Definition
          Impute Transform
        
      
      Join Aggregate
        
          Documentation Overview
          Join Aggregate Field Definition
          Join Aggregate Transform Definition
          Examples
        
      
      Loess
        
          Loess Transform Definition
          Usage
          Example
        
      
      Lookup
        
          Lookup Transform
        
      
      Pivot
        
          Pivot Transform Definition
          Usage
          Example
        
      
      Quantile
        
          Quantile Transform Definition
          Usage
        
      
      Regression
        
          Regression Transform Definition
          Usage
          Example
        
      
      Sample
        
          Sample Transform Definition
          Usage
          Example
        
      
      Stack
        
          Documentation Overview
          Stack in Encoding Field Definition
          Stack Transform
        
      
      Time Unit
        
          Documentation Overview
          Time Unit in Encoding Field Definition
          Time Unit Transform
          UTC time
          Time Unit Parameters
        
      
      Window
        
          Documentation Overview
          Window Field Definition
          Window Transform Definition
          Window Only Operation Reference
          Examples
        
      
    
  
  Mark
    
      Documentation Overview
      Mark Types
      Mark Definition Object
      Mark Config
      Mark Style Config
      Arc
        
          Documentation Overview
          Arc Mark Properties
          Examples
          Arc Config
          Faceted Pie Charts
        
      
      Area
        
          Documentation Overview
          Area Mark Properties
          Examples
          Area Config
        
      
      Bar
        
          Documentation Overview
          Bar Mark Properties
          Examples
          Bar Config
        
      
      Box Plot
        
          Documentation Overview
          Box Plot Mark Properties
          Types of Box Plot
          Dimension & Orientation
          The Parts of Box Plots
          Color, Size, and Opacity Encoding Channels
          Tooltip Encoding Channels
          Mark Config
          Box Plot with Pre-Calculated Summaries
        
      
      Circle
        
          Circle Mark Properties
          Examples
          Circle Config
        
      
      Error Band
        
          Documentation Overview
          Error Band Mark Properties
          Comparing the usage of Error Band to the usage of Error Bar
          Using Error Band to Aggregate Raw Data
          Using Error Band to Visualize Aggregated Data
          Dimension
          The Parts of Error Band
          Color, and Opacity Encoding Channels
          Tooltip Encoding Channels
          Mark Config
        
      
      Error Bar
        
          Documentation Overview
          Error Bar Mark Properties
          Using Error Bars to Aggregate Raw Data
          Using Error Bars to Visualize Aggregated Data
          Dimension & Orientation
          The Parts of Error Bars
          Color, and Opacity Encoding Channels
          Tooltip Encoding Channels
          Mark Config
        
      
      Geoshape
        
          Geoshape Config
        
      
      Image
        
          Documentation Overview
          Image Mark Properties
          Examples
          Image Config
        
      
      Line
        
          Documentation Overview
          Line Mark Properties
          Examples
          Line Config
        
      
      Point
        
          Documentation Overview
          Point Mark Properties
          Examples
          Point Config
        
      
      Rect
        
          Documentation Overview
          Rect Mark Properties
          Examples
          Rect Config
        
      
      Rule
        
          Documentation Overview
          Rule Mark Properties
          Examples
          Rule Config
        
      
      Square
        
          Square Mark Properties
          Example: Scatterplot with Square
          Square Config
        
      
      Text
        
          Documentation Overview
          Text Mark Properties
          Examples
          Text Config
        
      
      Tick
        
          Documentation Overview
          Tick Mark Properties
          Examples
          Tick Config
        
      
      Trail
        
          Documentation Overview
          Trail Mark Properties
          Examples
          Trail Config
        
      
    
  
  Encoding
    
      Encoding Channels
      Channel Definition
      Position Channels
      Position Offset Channels
      Polar Position Channels
      Geographic Position Channels
      Mark Property Channels
      Text and Tooltip Channels
      Hyperlink Channel
      Description Channel
      Level of Detail Channel
      Key Channel
      Order Channel
      Facet Channels
      Aggregate
        
          Documentation Overview
          Aggregate in Encoding Field Definition
          Aggregate Transform
          Supported Aggregation Operations
          Argmin / Argmax
        
      
      Axis
        
          Documentation Overview
          Axis Properties
          Axis Config
        
      
      Band Position
        
          Examples
        
      
      Bin
        
          Documentation Overview
          Binning in Encoding Field Definition
          Bin Transform
          Bin Parameters
          Ordinal Bin
        
      
      Condition
        
          Conditional Field Definition
          Conditional Value Definition
        
      
      Datum
        
          Examples
        
      
      Field
      Format
        
          Formatting Text Marks and Tooltips
          Formatting Axis, Legend, and Header Labels
        
      
      Header
        
          Documentation Overview
          Header Properties
          Header Config
        
      
      Impute
        
          Documentation Overview
          Impute in Encoding Field Definition
          Impute Transform
        
      
      Legend
        
          Legend Types
          Combined Legend
          Legend Properties
          Legend Config
        
      
      Scale
        
          Documentation Overview
          Scale Types
          Scale Domains
          Scale Ranges
          Common Scale Properties
          Continuous Scales
          Discrete Scales
          Discretizing Scales
          Disabling Scale
          Configuration
        
      
      Stack
        
          Documentation Overview
          Stack in Encoding Field Definition
          Stack Transform
        
      
      Sort
        
          Documentation Overview
          Sorting Continuous Fields
          Sorting Discrete Fields
        
      
      Time Unit
        
          Documentation Overview
          Time Unit in Encoding Field Definition
          Time Unit Transform
          UTC time
          Time Unit Parameters
        
      
      Type
        
          Quantitative
          Temporal
          Ordinal
          Nominal
          GeoJSON
        
      
      Value
    
  
  Projection
    
      Documentation Overview
      Projection Properties
      Projection Types
      Projection Configuration
    
  
  View Composition
    
      Documentation Overview
      Faceting
      Layering
      Concatenation
      Repeating
      Resolution
      Facet
        
          Documentation Overview
          Facet Operator
          Facet, Row, and Column Encoding Channels
          Resolve
          Facet Configuration
        
      
      Layer
        
          Example
        
      
      Concat
        
          Documentation Overview
          Horizontal Concatenation
          Vertical Concatenation
          General (Wrappable) Concatenation
          Resolve
          Concat Configuration
        
      
      Repeat
        
          Documentation Overview
          Repeat Operator
          Row/Column/Layer Repeat Mapping
          Examples
          Resolve
          Repeat Configuration
        
      
      Resolve
        
          Example
        
      
    
  
  Parameter
    
      Documentation Overview
      Defining a Parameter
      Using Parameters
      Selection Configuration
      Value
        
          Examples
        
      
      Expr
        
          Documentation Overview
          Defining a Parameter
          Using Parameters
          Selection Configuration
        
      
      Bind
        
          Input Element Binding
          Legend Binding
          Scale Binding
        
      
      Select
        
          Documentation Overview
          Common Selection Properties
          Point Selection Properties
          Interval Selection Properties
        
      
    
  
  Config
    
      Top-level Configuration
      Format Configuration
      Guide Configurations
      Mark Configurations
      Style Configuration
      Scale and Scale Range Configuration
      Projection Configuration
      Selection Configuration
      Title Configuration
      View & View Composition Configuration
      Locale Configuration
      ARIA Configuration
    
  
  Property Types
    
      Documentation Overview
      Primitive Types
      Special Object Types
      Date Time
      Gradient
        
          Linear Gradient
          Radial Gradient
          Gradient Stop
        
      
      Predicate
        
          Field Predicate
          Parameter Predicate
          Predicate Composition
        
      
    
  
  Tooltip
    
      Documentation Overview
      Tooltip Based on Encoding
      Tooltip Based on Underlying Data Point
      Tooltip channel
      Tooltip image
      Disable tooltips
      Vega Tooltip plugin
    
  
  Invalid Data
    
      Documentation Overview
      Mark Invalid Mode
      Scale Output for Invalid Values
      Other solutions\nVega-Lite is a high-level grammar for interactive graphics. It provides a concise JSON syntax for supporting rapid generation of interactive multi-view visualizations to support analysis. Vega-Lite can serve as a declarative format for describing and creating data visualizations. To use Vega-Lite, our compiler compiles a Vega-Lite specification into a lower-level, more detailed Vega specifications and rendered using Vega’s compiler.\nThis documentation describes the JSON specification language and how to use Vega-Lite visualizations in a web application.\nJSON specification language\nuse Vega-Lite visualizations\nBelow is an overview of the documentation for Vega-Lite properties. See the specification page for an overview of Vega-Lite specifications.\nthe specification page\nOverview
    
      Table of Contents\nView Specification
    
      Documentation Overview
      Common Properties of Specifications
      Top-Level Specifications
      Single View Specifications
      Layered and Multi-view Specifications
      View Configuration
      Title
        
          Title Properties Object
          Title Config
        
      
      Width / Height
        
          Documentation Overview
          Width and Height of Single and Layered Plots
          Width and Height of Multi-View Displays\nDocumentation Overview\nDocumentation Overview\nCommon Properties of Specifications\nCommon Properties of Specifications\nTop-Level Specifications\nTop-Level Specifications\nSingle View Specifications\nSingle View Specifications\nLayered and Multi-view Specifications\nLayered and Multi-view Specifications\nTitle
        
          Title Properties Object
          Title Config\nTitle Properties Object\nTitle Properties Object\nWidth / Height
        
          Documentation Overview
          Width and Height of Single and Layered Plots
          Width and Height of Multi-View Displays\nDocumentation Overview\nDocumentation Overview\nWidth and Height of Single and Layered Plots\nWidth and Height of Single and Layered Plots\nWidth and Height of Multi-View Displays\nWidth and Height of Multi-View Displays\nData / Datasets
    
      Documentation Overview
      Types of Data Sources
      Format
      Data Generators
      Datasets\nDocumentation Overview\nDocumentation Overview\nTypes of Data Sources\nTypes of Data Sources\nTransform
    
      View-level Transform Property
      Aggregate
        
          Documentation Overview
          Aggregate in Encoding Field Definition
          Aggregate Transform
          Supported Aggregation Operations
          Argmin / Argmax
        
      
      Bin
        
          Documentation Overview
          Binning in Encoding Field Definition
          Bin Transform
          Bin Parameters
          Ordinal Bin
        
      
      Calculate
        
          Calculate Transform Definition
          Example
        
      
      Density
        
          Density Transform Definition
          Usage
        
      
      Extent
        
          Extent Transform Definition
          Usage
          Example
        
      
      Filter
      Flatten
        
          Flatten Transform Definition
          Usage
          Examples
        
      
      Fold
        
          Fold Transform Definition
          Usage
          Example
        
      
      Impute
        
          Documentation Overview
          Impute in Encoding Field Definition
          Impute Transform
        
      
      Join Aggregate
        
          Documentation Overview
          Join Aggregate Field Definition
          Join Aggregate Transform Definition
          Examples
        
      
      Loess
        
          Loess Transform Definition
          Usage
          Example
        
      
      Lookup
        
          Lookup Transform
        
      
      Pivot
        
          Pivot Transform Definition
          Usage
          Example
        
      
      Quantile
        
          Quantile Transform Definition
          Usage
        
      
      Regression
        
          Regression Transform Definition
          Usage
          Example
        
      
      Sample
        
          Sample Transform Definition
          Usage
          Example
        
      
      Stack
        
          Documentation Overview
          Stack in Encoding Field Definition
          Stack Transform
        
      
      Time Unit
        
          Documentation Overview
          Time Unit in Encoding Field Definition
          Time Unit Transform
          UTC time
          Time Unit Parameters
        
      
      Window
        
          Documentation Overview
          Window Field Definition
          Window Transform Definition
          Window Only Operation Reference
          Examples\nView-level Transform Property\nView-level Transform Property\nAggregate
        
          Documentation Overview
          Aggregate in Encoding Field Definition
          Aggregate Transform
          Supported Aggregation Operations
          Argmin / Argmax\nDocumentation Overview\nDocumentation Overview\nAggregate in Encoding Field Definition\nAggregate in Encoding Field Definition\nSupported Aggregation Operations\nSupported Aggregation Operations\nBin
        
          Documentation Overview
          Binning in Encoding Field Definition
          Bin Transform
          Bin Parameters
          Ordinal Bin\nDocumentation Overview\nDocumentation Overview\nBinning in Encoding Field Definition\nBinning in Encoding Field Definition\nCalculate
        
          Calculate Transform Definition
          Example\nCalculate Transform Definition\nCalculate Transform Definition\nDensity
        
          Density Transform Definition
          Usage\nDensity Transform Definition\nDensity Transform Definition\nExtent
        
          Extent Transform Definition
          Usage
          Example\nExtent Transform Definition\nExtent Transform Definition\nFlatten
        
          Flatten Transform Definition
          Usage
          Examples\nFlatten Transform Definition\nFlatten Transform Definition\nFold
        
          Fold Transform Definition
          Usage
          Example\nFold Transform Definition\nFold Transform Definition\nImpute
        
          Documentation Overview
          Impute in Encoding Field Definition
          Impute Transform\nDocumentation Overview\nDocumentation Overview\nImpute in Encoding Field Definition\nImpute in Encoding Field Definition\nJoin Aggregate
        
          Documentation Overview
          Join Aggregate Field Definition
          Join Aggregate Transform Definition
          Examples\nDocumentation Overview\nDocumentation Overview\nJoin Aggregate Field Definition\nJoin Aggregate Field Definition\nJoin Aggregate Transform Definition\nJoin Aggregate Transform Definition\nLoess
        
          Loess Transform Definition
          Usage
          Example\nLoess Transform Definition\nLoess Transform Definition\nLookup
        
          Lookup Transform\nPivot
        
          Pivot Transform Definition
          Usage
          Example\nPivot Transform Definition\nPivot Transform Definition\nQuantile
        
          Quantile Transform Definition
          Usage\nQuantile Transform Definition\nQuantile Transform Definition\nRegression
        
          Regression Transform Definition
          Usage
          Example\nRegression Transform Definition\nRegression Transform Definition\nSample
        
          Sample Transform Definition
          Usage
          Example\nSample Transform Definition\nSample Transform Definition\nStack
        
          Documentation Overview
          Stack in Encoding Field Definition
          Stack Transform\nDocumentation Overview\nDocumentation Overview\nStack in Encoding Field Definition\nStack in Encoding Field Definition\nTime Unit
        
          Documentation Overview
          Time Unit in Encoding Field Definition
          Time Unit Transform
          UTC time
          Time Unit Parameters\nDocumentation Overview\nDocumentation Overview\nTime Unit in Encoding Field Definition\nTime Unit in Encoding Field Definition\nWindow
        
          Documentation Overview
          Window Field Definition
          Window Transform Definition
          Window Only Operation Reference
          Examples\nDocumentation Overview\nDocumentation Overview\nWindow Field Definition\nWindow Field Definition\nWindow Transform Definition\nWindow Transform Definition\nWindow Only Operation Reference\nWindow Only Operation Reference\nMark
    
      Documentation Overview
      Mark Types
      Mark Definition Object
      Mark Config
      Mark Style Config
      Arc
        
          Documentation Overview
          Arc Mark Properties
          Examples
          Arc Config
          Faceted Pie Charts
        
      
      Area
        
          Documentation Overview
          Area Mark Properties
          Examples
          Area Config
        
      
      Bar
        
          Documentation Overview
          Bar Mark Properties
          Examples
          Bar Config
        
      
      Box Plot
        
          Documentation Overview
          Box Plot Mark Properties
          Types of Box Plot
          Dimension & Orientation
          The Parts of Box Plots
          Color, Size, and Opacity Encoding Channels
          Tooltip Encoding Channels
          Mark Config
          Box Plot with Pre-Calculated Summaries
        
      
      Circle
        
          Circle Mark Properties
          Examples
          Circle Config
        
      
      Error Band
        
          Documentation Overview
          Error Band Mark Properties
          Comparing the usage of Error Band to the usage of Error Bar
          Using Error Band to Aggregate Raw Data
          Using Error Band to Visualize Aggregated Data
          Dimension
          The Parts of Error Band
          Color, and Opacity Encoding Channels
          Tooltip Encoding Channels
          Mark Config
        
      
      Error Bar
        
          Documentation Overview
          Error Bar Mark Properties
          Using Error Bars to Aggregate Raw Data
          Using Error Bars to Visualize Aggregated Data
          Dimension & Orientation
          The Parts of Error Bars
          Color, and Opacity Encoding Channels
          Tooltip Encoding Channels
          Mark Config
        
      
      Geoshape
        
          Geoshape Config
        
      
      Image
        
          Documentation Overview
          Image Mark Properties
          Examples
          Image Config
        
      
      Line
        
          Documentation Overview
          Line Mark Properties
          Examples
          Line Config
        
      
      Point
        
          Documentation Overview
          Point Mark Properties
          Examples
          Point Config
        
      
      Rect
        
          Documentation Overview
          Rect Mark Properties
          Examples
          Rect Config
        
      
      Rule
        
          Documentation Overview
          Rule Mark Properties
          Examples
          Rule Config
        
      
      Square
        
          Square Mark Properties
          Example: Scatterplot with Square
          Square Config
        
      
      Text
        
          Documentation Overview
          Text Mark Properties
          Examples
          Text Config
        
      
      Tick
        
          Documentation Overview
          Tick Mark Properties
          Examples
          Tick Config
        
      
      Trail
        
          Documentation Overview
          Trail Mark Properties
          Examples
          Trail Config\nDocumentation Overview\nDocumentation Overview\nMark Definition Object\nMark Definition Object\nArc
        
          Documentation Overview
          Arc Mark Properties
          Examples
          Arc Config
          Faceted Pie Charts\nDocumentation Overview\nDocumentation Overview\nArea
        
          Documentation Overview
          Area Mark Properties
          Examples
          Area Config\nDocumentation Overview\nDocumentation Overview\nBar
        
          Documentation Overview
          Bar Mark Properties
          Examples
          Bar Config\nDocumentation Overview\nDocumentation Overview\nBox Plot
        
          Documentation Overview
          Box Plot Mark Properties
          Types of Box Plot
          Dimension & Orientation
          The Parts of Box Plots
          Color, Size, and Opacity Encoding Channels
          Tooltip Encoding Channels
          Mark Config
          Box Plot with Pre-Calculated Summaries\nDocumentation Overview\nDocumentation Overview\nBox Plot Mark Properties\nBox Plot Mark Properties\nDimension & Orientation\nDimension & Orientation\nThe Parts of Box Plots\nThe Parts of Box Plots\nColor, Size, and Opacity Encoding Channels\nColor, Size, and Opacity Encoding Channels\nTooltip Encoding Channels\nTooltip Encoding Channels\nBox Plot with Pre-Calculated Summaries\nBox Plot with Pre-Calculated Summaries\nCircle
        
          Circle Mark Properties
          Examples
          Circle Config\nCircle Mark Properties\nCircle Mark Properties\nError Band
        
          Documentation Overview
          Error Band Mark Properties
          Comparing the usage of Error Band to the usage of Error Bar
          Using Error Band to Aggregate Raw Data
          Using Error Band to Visualize Aggregated Data
          Dimension
          The Parts of Error Band
          Color, and Opacity Encoding Channels
          Tooltip Encoding Channels
          Mark Config\nDocumentation Overview\nDocumentation Overview\nError Band Mark Properties\nError Band Mark Properties\nComparing the usage of Error Band to the usage of Error Bar\nComparing the usage of Error Band to the usage of Error Bar\nUsing Error Band to Aggregate Raw Data\nUsing Error Band to Aggregate Raw Data\nUsing Error Band to Visualize Aggregated Data\nUsing Error Band to Visualize Aggregated Data\nThe Parts of Error Band\nThe Parts of Error Band\nColor, and Opacity Encoding Channels\nColor, and Opacity Encoding Channels\nTooltip Encoding Channels\nTooltip Encoding Channels\nError Bar
        
          Documentation Overview
          Error Bar Mark Properties
          Using Error Bars to Aggregate Raw Data
          Using Error Bars to Visualize Aggregated Data
          Dimension & Orientation
          The Parts of Error Bars
          Color, and Opacity Encoding Channels
          Tooltip Encoding Channels
          Mark Config\nDocumentation Overview\nDocumentation Overview\nError Bar Mark Properties\nError Bar Mark Properties\nUsing Error Bars to Aggregate Raw Data\nUsing Error Bars to Aggregate Raw Data\nUsing Error Bars to Visualize Aggregated Data\nUsing Error Bars to Visualize Aggregated Data\nDimension & Orientation\nDimension & Orientation\nThe Parts of Error Bars\nThe Parts of Error Bars\nColor, and Opacity Encoding Channels\nColor, and Opacity Encoding Channels\nTooltip Encoding Channels\nTooltip Encoding Channels\nGeoshape
        
          Geoshape Config\nImage
        
          Documentation Overview
          Image Mark Properties
          Examples
          Image Config\nDocumentation Overview\nDocumentation Overview\nImage Mark Properties\nImage Mark Properties\nLine
        
          Documentation Overview
          Line Mark Properties
          Examples
          Line Config\nDocumentation Overview\nDocumentation Overview\nPoint
        
          Documentation Overview
          Point Mark Properties
          Examples
          Point Config\nDocumentation Overview\nDocumentation Overview\nPoint Mark Properties\nPoint Mark Properties\nRect
        
          Documentation Overview
          Rect Mark Properties
          Examples
          Rect Config\nDocumentation Overview\nDocumentation Overview\nRule
        
          Documentation Overview
          Rule Mark Properties
          Examples
          Rule Config\nDocumentation Overview\nDocumentation Overview\nSquare
        
          Square Mark Properties
          Example: Scatterplot with Square
          Square Config\nSquare Mark Properties\nSquare Mark Properties\nExample: Scatterplot with Square\nExample: Scatterplot with Square\nText
        
          Documentation Overview
          Text Mark Properties
          Examples
          Text Config\nDocumentation Overview\nDocumentation Overview\nTick
        
          Documentation Overview
          Tick Mark Properties
          Examples
          Tick Config\nDocumentation Overview\nDocumentation Overview\nTrail
        
          Documentation Overview
          Trail Mark Properties
          Examples
          Trail Config\nDocumentation Overview\nDocumentation Overview\nTrail Mark Properties\nTrail Mark Properties\nEncoding
    
      Encoding Channels
      Channel Definition
      Position Channels
      Position Offset Channels
      Polar Position Channels
      Geographic Position Channels
      Mark Property Channels
      Text and Tooltip Channels
      Hyperlink Channel
      Description Channel
      Level of Detail Channel
      Key Channel
      Order Channel
      Facet Channels
      Aggregate
        
          Documentation Overview
          Aggregate in Encoding Field Definition
          Aggregate Transform
          Supported Aggregation Operations
          Argmin / Argmax
        
      
      Axis
        
          Documentation Overview
          Axis Properties
          Axis Config
        
      
      Band Position
        
          Examples
        
      
      Bin
        
          Documentation Overview
          Binning in Encoding Field Definition
          Bin Transform
          Bin Parameters
          Ordinal Bin
        
      
      Condition
        
          Conditional Field Definition
          Conditional Value Definition
        
      
      Datum
        
          Examples
        
      
      Field
      Format
        
          Formatting Text Marks and Tooltips
          Formatting Axis, Legend, and Header Labels
        
      
      Header
        
          Documentation Overview
          Header Properties
          Header Config
        
      
      Impute
        
          Documentation Overview
          Impute in Encoding Field Definition
          Impute Transform
        
      
      Legend
        
          Legend Types
          Combined Legend
          Legend Properties
          Legend Config
        
      
      Scale
        
          Documentation Overview
          Scale Types
          Scale Domains
          Scale Ranges
          Common Scale Properties
          Continuous Scales
          Discrete Scales
          Discretizing Scales
          Disabling Scale
          Configuration
        
      
      Stack
        
          Documentation Overview
          Stack in Encoding Field Definition
          Stack Transform
        
      
      Sort
        
          Documentation Overview
          Sorting Continuous Fields
          Sorting Discrete Fields
        
      
      Time Unit
        
          Documentation Overview
          Time Unit in Encoding Field Definition
          Time Unit Transform
          UTC time
          Time Unit Parameters
        
      
      Type
        
          Quantitative
          Temporal
          Ordinal
          Nominal
          GeoJSON
        
      
      Value\nPosition Offset Channels\nPosition Offset Channels\nPolar Position Channels\nPolar Position Channels\nGeographic Position Channels\nGeographic Position Channels\nMark Property Channels\nMark Property Channels\nText and Tooltip Channels\nText and Tooltip Channels\nLevel of Detail Channel\nLevel of Detail Channel\nAggregate
        
          Documentation Overview
          Aggregate in Encoding Field Definition
          Aggregate Transform
          Supported Aggregation Operations
          Argmin / Argmax\nDocumentation Overview\nDocumentation Overview\nAggregate in Encoding Field Definition\nAggregate in Encoding Field Definition\nSupported Aggregation Operations\nSupported Aggregation Operations\nAxis
        
          Documentation Overview
          Axis Properties
          Axis Config\nDocumentation Overview\nDocumentation Overview\nBand Position
        
          Examples\nBin
        
          Documentation Overview
          Binning in Encoding Field Definition
          Bin Transform
          Bin Parameters
          Ordinal Bin\nDocumentation Overview\nDocumentation Overview\nBinning in Encoding Field Definition\nBinning in Encoding Field Definition\nCondition
        
          Conditional Field Definition
          Conditional Value Definition\nConditional Field Definition\nConditional Field Definition\nConditional Value Definition\nConditional Value Definition\nDatum
        
          Examples\nFormat
        
          Formatting Text Marks and Tooltips
          Formatting Axis, Legend, and Header Labels\nFormatting Text Marks and Tooltips\nFormatting Text Marks and Tooltips\nFormatting Axis, Legend, and Header Labels\nFormatting Axis, Legend, and Header Labels\nHeader
        
          Documentation Overview
          Header Properties
          Header Config\nDocumentation Overview\nDocumentation Overview\nImpute
        
          Documentation Overview
          Impute in Encoding Field Definition
          Impute Transform\nDocumentation Overview\nDocumentation Overview\nImpute in Encoding Field Definition\nImpute in Encoding Field Definition\nLegend
        
          Legend Types
          Combined Legend
          Legend Properties
          Legend Config\nScale
        
          Documentation Overview
          Scale Types
          Scale Domains
          Scale Ranges
          Common Scale Properties
          Continuous Scales
          Discrete Scales
          Discretizing Scales
          Disabling Scale
          Configuration\nDocumentation Overview\nDocumentation Overview\nCommon Scale Properties\nCommon Scale Properties\nStack
        
          Documentation Overview
          Stack in Encoding Field Definition
          Stack Transform\nDocumentation Overview\nDocumentation Overview\nStack in Encoding Field Definition\nStack in Encoding Field Definition\nSort
        
          Documentation Overview
          Sorting Continuous Fields
          Sorting Discrete Fields\nDocumentation Overview\nDocumentation Overview\nSorting Continuous Fields\nSorting Continuous Fields\nSorting Discrete Fields\nSorting Discrete Fields\nTime Unit
        
          Documentation Overview
          Time Unit in Encoding Field Definition
          Time Unit Transform
          UTC time
          Time Unit Parameters\nDocumentation Overview\nDocumentation Overview\nTime Unit in Encoding Field Definition\nTime Unit in Encoding Field Definition\nType
        
          Quantitative
          Temporal
          Ordinal
          Nominal
          GeoJSON\nProjection
    
      Documentation Overview
      Projection Properties
      Projection Types
      Projection Configuration\nDocumentation Overview\nDocumentation Overview\nProjection Properties\nProjection Properties\nProjection Configuration\nProjection Configuration\nView Composition
    
      Documentation Overview
      Faceting
      Layering
      Concatenation
      Repeating
      Resolution
      Facet
        
          Documentation Overview
          Facet Operator
          Facet, Row, and Column Encoding Channels
          Resolve
          Facet Configuration
        
      
      Layer
        
          Example
        
      
      Concat
        
          Documentation Overview
          Horizontal Concatenation
          Vertical Concatenation
          General (Wrappable) Concatenation
          Resolve
          Concat Configuration
        
      
      Repeat
        
          Documentation Overview
          Repeat Operator
          Row/Column/Layer Repeat Mapping
          Examples
          Resolve
          Repeat Configuration
        
      
      Resolve
        
          Example\nDocumentation Overview\nDocumentation Overview\nFacet
        
          Documentation Overview
          Facet Operator
          Facet, Row, and Column Encoding Channels
          Resolve
          Facet Configuration\nDocumentation Overview\nDocumentation Overview\nFacet, Row, and Column Encoding Channels\nFacet, Row, and Column Encoding Channels\nLayer
        
          Example\nConcat
        
          Documentation Overview
          Horizontal Concatenation
          Vertical Concatenation
          General (Wrappable) Concatenation
          Resolve
          Concat Configuration\nDocumentation Overview\nDocumentation Overview\nHorizontal Concatenation\nHorizontal Concatenation\nVertical Concatenation\nVertical Concatenation\nGeneral (Wrappable) Concatenation\nGeneral (Wrappable) Concatenation\nRepeat
        
          Documentation Overview
          Repeat Operator
          Row/Column/Layer Repeat Mapping
          Examples
          Resolve
          Repeat Configuration\nDocumentation Overview\nDocumentation Overview\nRow/Column/Layer Repeat Mapping\nRow/Column/Layer Repeat Mapping\nResolve
        
          Example\nParameter
    
      Documentation Overview
      Defining a Parameter
      Using Parameters
      Selection Configuration
      Value
        
          Examples
        
      
      Expr
        
          Documentation Overview
          Defining a Parameter
          Using Parameters
          Selection Configuration
        
      
      Bind
        
          Input Element Binding
          Legend Binding
          Scale Binding
        
      
      Select
        
          Documentation Overview
          Common Selection Properties
          Point Selection Properties
          Interval Selection Properties\nDocumentation Overview\nDocumentation Overview\nSelection Configuration\nSelection Configuration\nValue
        
          Examples\nExpr
        
          Documentation Overview
          Defining a Parameter
          Using Parameters
          Selection Configuration\nDocumentation Overview\nDocumentation Overview\nSelection Configuration\nSelection Configuration\nBind
        
          Input Element Binding
          Legend Binding
          Scale Binding\nInput Element Binding\nInput Element Binding\nSelect
        
          Documentation Overview
          Common Selection Properties
          Point Selection Properties
          Interval Selection Properties\nDocumentation Overview\nDocumentation Overview\nCommon Selection Properties\nCommon Selection Properties\nPoint Selection Properties\nPoint Selection Properties\nInterval Selection Properties\nInterval Selection Properties\nConfig
    
      Top-level Configuration
      Format Configuration
      Guide Configurations
      Mark Configurations
      Style Configuration
      Scale and Scale Range Configuration
      Projection Configuration
      Selection Configuration
      Title Configuration
      View & View Composition Configuration
      Locale Configuration
      ARIA Configuration\nTop-level Configuration\nTop-level Configuration\nScale and Scale Range Configuration\nScale and Scale Range Configuration\nProjection Configuration\nProjection Configuration\nSelection Configuration\nSelection Configuration\nView & View Composition Configuration\nView & View Composition Configuration\nProperty Types
    
      Documentation Overview
      Primitive Types
      Special Object Types
      Date Time
      Gradient
        
          Linear Gradient
          Radial Gradient
          Gradient Stop
        
      
      Predicate
        
          Field Predicate
          Parameter Predicate
          Predicate Composition\nDocumentation Overview\nDocumentation Overview\nGradient
        
          Linear Gradient
          Radial Gradient
          Gradient Stop\nPredicate
        
          Field Predicate
          Parameter Predicate
          Predicate Composition\nPredicate Composition\nPredicate Composition\nTooltip
    
      Documentation Overview
      Tooltip Based on Encoding
      Tooltip Based on Underlying Data Point
      Tooltip channel
      Tooltip image
      Disable tooltips
      Vega Tooltip plugin\nDocumentation Overview\nDocumentation Overview\nTooltip Based on Encoding\nTooltip Based on Encoding\nTooltip Based on Underlying Data Point\nTooltip Based on Underlying Data Point\nInvalid Data
    
      Documentation Overview
      Mark Invalid Mode
      Scale Output for Invalid Values
      Other solutions\nDocumentation Overview\nDocumentation Overview\nScale Output for Invalid Values\nScale Output for Invalid Values\nEdit this page and submit a pull request!\nEdit this page and submit a pull request!\n\n\nVega-Lite
        
          Vega
          Altair
          Vega-Lite API
        
      
      
        
          Examples
          Tutorials
          Documentation
          Usage
          Ecosystem
        
        
          GitHub
          Try Online
        
      
    
  
  
    



  
    
    Embed
    
    
    Compile
    
    
    TypeScript
    
    
    Debugging
    
    
  




  

  
    Embedding Vega-Lite
    Fork our Vega-Lite Block if you want to quickly publish a Vega-Lite visualization on the web.

The easiest way to use Vega-Lite on your own web page is with Vega-Embed, a library we built to make the process as painless as possible.

Get Vega-Lite and other dependencies

To embed a Vega-Lite specification on your web page first load the required libraries. You can get Vega, Vega-Lite, and Vega-Embed via a CDN, NPM, or manually download them.

CDN

For production deployments you will likely want to serve your own files or use a content delivery network (CDN). Vega-Lite releases are hosted on jsDelivr:

<script src="https://cdn.jsdelivr.net/npm/vega@6.0.0"></script>
<script src="https://cdn.jsdelivr.net/npm/vega-lite@6.1.0"></script>
<script src="https://cdn.jsdelivr.net/npm/vega-embed@6.29.0"></script>


If you want to automatically use the latest versions of Vega-Lite, Vega, and Vega-Embed, you can specify only the major version.

<script src="https://cdn.jsdelivr.net/npm/vega@6"></script>
<script src="https://cdn.jsdelivr.net/npm/vega-lite@6"></script>
<script src="https://cdn.jsdelivr.net/npm/vega-embed@6"></script>


NPM

If you prefer to host the dependencies yourself, we suggest that you use npm to install the libraries (Vega, Vega-Lite, and Vega-Embed) to get the latest stable version. To install with npm, simply install it as you would any other npm module.

npm install vega
npm install vega-lite
npm install vega-embed


You can learn more about NPM on the official website.

Download

Alternatively, you can download the latest Vega-Lite release and add it to your project manually. In this case, you will also have to download Vega, and Vega-Embed.

Start using Vega-Lite with Vega-Embed

The next step after getting the libraries is to create a DOM element that the visualization will be attached to.

<div id="vis"></div>


Then use Vega-Embed’s provided function to embed your spec.

// More argument info at https://github.com/vega/vega-embed
vegaEmbed('#vis', yourVlSpec);


Vega-Embed automatically adds links to export an image, view the source, and open the specification in the online editor. These links can be individually disabled. For more information, read the Vega-Embed documentation.

Here is the final HTML file in the easiest way to embed Vega-Lite (assuming that you use the CDN approach from above). See the output in your browser.

<!doctype html>
<html>
  <head>
    <title>Embedding Vega-Lite</title>
    <script src="https://cdn.jsdelivr.net/npm/vega@6.0.0"></script>
    <script src="https://cdn.jsdelivr.net/npm/vega-lite@6.1.0"></script>
    <script src="https://cdn.jsdelivr.net/npm/vega-embed@6.29.0"></script>
  </head>
  <body>
    <div id="vis"></div>

    <script type="text/javascript">
      var yourVlSpec = {
        $schema: 'https://vega.github.io/schema/vega-lite/v6.json',
        description: 'A simple bar chart with embedded data.',
        data: {
          values: [
            {a: 'A', b: 28},
            {a: 'B', b: 55},
            {a: 'C', b: 43},
            {a: 'D', b: 91},
            {a: 'E', b: 81},
            {a: 'F', b: 53},
            {a: 'G', b: 19},
            {a: 'H', b: 87},
            {a: 'I', b: 52},
          ],
        },
        mark: 'bar',
        encoding: {
          x: {field: 'a', type: 'ordinal'},
          y: {field: 'b', type: 'quantitative'},
        },
      };
      vegaEmbed('#vis', yourVlSpec);
    </script>
  </body>
</html>\nVega-Lite
        
          Vega
          Altair
          Vega-Lite API\nVega
          Altair
          Vega-Lite API\nExamples
          Tutorials
          Documentation
          Usage
          Ecosystem
        
        
          GitHub
          Try Online\nExamples
          Tutorials
          Documentation
          Usage
          Ecosystem\nGitHub
          Try Online\nEmbed
    
    
    Compile
    
    
    TypeScript
    
    
    Debugging\nEmbedding Vega-Lite
    Fork our Vega-Lite Block if you want to quickly publish a Vega-Lite visualization on the web.

The easiest way to use Vega-Lite on your own web page is with Vega-Embed, a library we built to make the process as painless as possible.

Get Vega-Lite and other dependencies

To embed a Vega-Lite specification on your web page first load the required libraries. You can get Vega, Vega-Lite, and Vega-Embed via a CDN, NPM, or manually download them.

CDN

For production deployments you will likely want to serve your own files or use a content delivery network (CDN). Vega-Lite releases are hosted on jsDelivr:

<script src="https://cdn.jsdelivr.net/npm/vega@6.0.0"></script>
<script src="https://cdn.jsdelivr.net/npm/vega-lite@6.1.0"></script>
<script src="https://cdn.jsdelivr.net/npm/vega-embed@6.29.0"></script>


If you want to automatically use the latest versions of Vega-Lite, Vega, and Vega-Embed, you can specify only the major version.

<script src="https://cdn.jsdelivr.net/npm/vega@6"></script>
<script src="https://cdn.jsdelivr.net/npm/vega-lite@6"></script>
<script src="https://cdn.jsdelivr.net/npm/vega-embed@6"></script>


NPM

If you prefer to host the dependencies yourself, we suggest that you use npm to install the libraries (Vega, Vega-Lite, and Vega-Embed) to get the latest stable version. To install with npm, simply install it as you would any other npm module.

npm install vega
npm install vega-lite
npm install vega-embed


You can learn more about NPM on the official website.

Download

Alternatively, you can download the latest Vega-Lite release and add it to your project manually. In this case, you will also have to download Vega, and Vega-Embed.

Start using Vega-Lite with Vega-Embed

The next step after getting the libraries is to create a DOM element that the visualization will be attached to.

<div id="vis"></div>


Then use Vega-Embed’s provided function to embed your spec.

// More argument info at https://github.com/vega/vega-embed
vegaEmbed('#vis', yourVlSpec);


Vega-Embed automatically adds links to export an image, view the source, and open the specification in the online editor. These links can be individually disabled. For more information, read the Vega-Embed documentation.

Here is the final HTML file in the easiest way to embed Vega-Lite (assuming that you use the CDN approach from above). See the output in your browser.

<!doctype html>
<html>
  <head>
    <title>Embedding Vega-Lite</title>
    <script src="https://cdn.jsdelivr.net/npm/vega@6.0.0"></script>
    <script src="https://cdn.jsdelivr.net/npm/vega-lite@6.1.0"></script>
    <script src="https://cdn.jsdelivr.net/npm/vega-embed@6.29.0"></script>
  </head>
  <body>
    <div id="vis"></div>

    <script type="text/javascript">
      var yourVlSpec = {
        $schema: 'https://vega.github.io/schema/vega-lite/v6.json',
        description: 'A simple bar chart with embedded data.',
        data: {
          values: [
            {a: 'A', b: 28},
            {a: 'B', b: 55},
            {a: 'C', b: 43},
            {a: 'D', b: 91},
            {a: 'E', b: 81},
            {a: 'F', b: 53},
            {a: 'G', b: 19},
            {a: 'H', b: 87},
            {a: 'I', b: 52},
          ],
        },
        mark: 'bar',
        encoding: {
          x: {field: 'a', type: 'ordinal'},
          y: {field: 'b', type: 'quantitative'},
        },
      };
      vegaEmbed('#vis', yourVlSpec);
    </script>
  </body>
</html>\nFork our Vega-Lite Block if you want to quickly publish a Vega-Lite visualization on the web.\nThe easiest way to use Vega-Lite on your own web page is with Vega-Embed, a library we built to make the process as painless as possible.\nGet Vega-Lite and other dependencies\nTo embed a Vega-Lite specification on your web page first load the required libraries. You can get Vega, Vega-Lite, and Vega-Embed via a CDN, NPM, or manually download them.\nFor production deployments you will likely want to serve your own files or use a content delivery network (CDN). Vega-Lite releases are hosted on jsDelivr:\ncontent delivery network (CDN)\nIf you want to automatically use the latest versions of Vega-Lite, Vega, and Vega-Embed, you can specify only the major version.\nIf you prefer to host the dependencies yourself, we suggest that you use npm to install the libraries (Vega, Vega-Lite, and Vega-Embed) to get the latest stable version. To install with npm, simply install it as you would any other npm module.\nYou can learn more about NPM on the official website.\nAlternatively, you can download the latest Vega-Lite release and add it to your project manually. In this case, you will also have to download Vega, and Vega-Embed.\ndownload the latest Vega-Lite release\nStart using Vega-Lite with Vega-Embed\nThe next step after getting the libraries is to create a DOM element that the visualization will be attached to.\nThen use Vega-Embed’s provided function to embed your spec.\nVega-Embed automatically adds links to export an image, view the source, and open the specification in the online editor. These links can be individually disabled. For more information, read the Vega-Embed documentation.\nVega-Embed documentation\nHere is the final HTML file in the easiest way to embed Vega-Lite (assuming that you use the CDN approach from above). See the output in your browser.\noutput in your browser\nEdit this page and submit a pull request!\nEdit this page and submit a pull request!\n\n\nVega-Lite
        
          Vega
          Altair
          Vega-Lite API
        
      
      
        
          Examples
          Tutorials
          Documentation
          Usage
          Ecosystem
        
        
          GitHub
          Try Online
        
      
    
  
  
    
  
  Vega-Lite Ecosystem
   This is an incomplete list of integrations, applications, and extensions of the Vega-Lite language and compiler. If you want to add a tool or library, edit this file and send us a pull request.

We mark featured plugins and tools with a .

Tools for Authoring Vega-Lite Visualizations


   Vega-Editor, the online editor for Vega and Vega-Lite. You can also get an output Vega spec from a given Vega-Lite spec as well.
   Vega Viewer, a VSCode extension for interactive preview of Vega and Vega-Lite maps and graphs.
  vega-desktop, a desktop app that lets you open .vg.json and .vl.json to see visualizations just like you open image files with an image viewer. This is useful for creating visualizations with Vega/Vega-Lite locally.
   Voyager (2), visualization tool for exploratory data analysis that blends a Tableau-style specification interface (formerly Polestar) with chart recommendations (formerly the Voyager visualization browser) and generates Vega-Lite visualizations.
  Bayes - A creative data exploration and storytelling tool. Easily create and publish Vega-Lite visualizations.
  data.world Chart Builder, a chart builder that imports data from queries in data.world. The generated specs can be saved locally or uploaded back to data.world. Project is open source.
  ColorBrewer-Lite, a fork of the ColorBrewer project that allows importing Vega-Lite specifications into the ColorBrewer interface to pick effective color schemes “in situ” for any color encoding.
  Emacs Vega View, a tool that allows one to view Vega visualizations directly within emacs, currently supporting specs written in JSON, elisp or clojure.
  Codimd, realtime collaborative markdown notes editor with support of various diagram syntaxes including Vega-Lite.
  Ivy, an Integrated Visualization Editing environment that wraps Vega-Lite (among other declarative visualization grammars) as templates to facilitate reuse, exploration, and opportunistic creation. Includes an in-app reproduction of Polestar.
  Deneb, a Power BI custom visual with an editor for Vega-Lite or Vega specifications.
  VizLinter, an online editor that detects and fixes encoding issues based on vega-lite-linter.
  Datapane, a Python framework for building interactive reports from open-source visualization formats such as Vega-Lite.
  Graphpad, an editor for creating Vega-Lite visualizations in the Figjam collaborative whiteboarding tool.


Tools for Scaling Vega-Lite Visualizations


  altair-transform, a Python library for pre-evaluating Altair/Vega-Lite transforms with Pandas.
  ibis-vega-transform, a Python library and JupyterLab extension for evaluating Altair/Vega-Lite transforms with external databases using Ibis.
  StatisticalGraphics.jl, a Julia library for statistical graphics.
   VegaFusion, a Rust library and Python API that provides server-side acceleration for interactive Altair/Vega-Lite visualizations using Apache Arrow and DataFusion.
  Scalable Vega, a demo of how to scale Vega to large datasets by implementing a custom transform that accepts SQL queries and requests data from an external database.


Plug-ins for Vega-Lite


   Tooltips for Vega and Vega-Lite
  Leaflet Tile Map integration for Vega and Vega-Lite


Bindings for Programming Languages


   Altair exposes a Python API for building statistical visualizations that follows Vega-Lite syntax.
   Vega-Lite API is a JavaScript API for creating Vega-Lite JSON specifications.
   elm-vegaLite generates Vega-Lite specifications in the pure functional language Elm.
  Altair wrapper in R
  ipyvega supports Vega and Vega-Lite charts in Jupyter Notebooks.
  VegaLite (Elixir bindings).
   VegaLite.jl are Julia bindings to Vega and Vega-Lite.
  Deneb.jl is a convenient Julia API for creating Vega-Lite visualizations.
  Vega-Lite “bindings” for R, create Vega-Lite visualizations in R.
  vegaliteR, vega-lite htmlwidget for R.
  Vegas brings visualizations to Scala and Spark using Vega-Lite.
  Smile is a machine learning engine for JVM using Vega-Lite.
  vegawidget, low-level interface in R to render Vega and Vega-Lite specifications as htmlwidgets, including functions to interact with data, events, and signals in Shiny.
  vegabrite, functional interface for building up Vega-Lite specifications in R. Built on top of the lower-level interface provided by vegawidget
  Hanami A Clojure(Script) library for creating domain specific interactive visualization applications. Exposes a parameterized template system that uses recursive transformation to finished Vega-Lite and Vega specs. Built with reagent (react) and re-com enabled.
  Vizard tiny REPL client to visualize Clojure data in browser w/ Vega-Lite.
  Oz is a Vega & Vega-Lite based visualization and scientific document toolkit for Clojure & ClojureScript (Reagent). Originally a fork of Vizard, Oz adds support for Vega, publishing/sharing, markdown & hiccup extensions for embedding Vega-Lite & Vega visualizations in html documents, static html output, and Jupyter notebooks.
  Vizsla is a simple JavaScript API for Vega-Lite.
  Vega node for Node-RED Dashboard supports Vega and Vega-Lite visualizations on the Node-RED flow-based programming tool.
  hvega generates Vega-Lite specifications in Haskell and is based on Elm-Vega.
  Vega-Lite “bindings” for Rust, create vega-lite v3, or v4, vizualizations in Rust A high-level like Altair in under construction at procyon
  Vega.rb brings Vega and Vega-Lite to Ruby.
  Jekyll Diagrams A Jekyll plugin with support for Vega & Vega-Lite and others diagramming libraries.
  Liquid Diagrams A Liquid plugin with support for Vega & Vega-Lite and others diagramming libraries.
  Vega-Lite-Linter is a python package to help users detect and fix encoding issues.
  VegaLite is a library for Dyalog APL to build and render Vega-Lite specifications from your data.
  React Spectrum Charts are declarative visualization components from Adobe using Vega and Vega-Lite.
  vega-view displays nushell tables using Vega-Lite in a webview.


Programming / Data Science Environment that supports Vega-Lite


   JupyterLab, an extensible environment for interactive and reproducible computing, based on the Jupyter Notebook and Architecture.
  nteract, interactive notebook application with Vega and Vega-Lite renderer.
   Observable, an interactive JavaScript notebook. Embed example and exploration example.
  data.world, upload .vg.json and .vl.json files along side your raw data, or embed Vega directly into comments and summary markdown.
  nextjournal, scientific computing environment with support for data visualizations including Vega-Lite
  Liminoid, toolkit for building interactive analytics applications with Python and WebAssembly. Can pass Python data to JavaScript callbacks which render Vega/Vega-Lite specifications.
  Neptune.ai, machine learning experiment tracking tool with Vega-Lite and Altair visualizations.
  Livebook, Interactive and collaborative code notebooks with Vega-Lite visualizations.
  Hex is a data science platform that uses Vega-Lite visualizations.


Tools that use Vega-Lite


  Lyra, an interactive, graphical Visualization Design Environment (VDE)
   PdVega, lets you create interactive Vega-Lite plots for Pandas. Uses ipyvega.
  Turi Create Apple’s tool to simplify the development of custom machine learning models.
  mondrian-rest-ui, an experimental UI for mondrian-rest inspired by Polestar and CubesViewer.
  Django Chartflo, charts for the lazy ones in Django
  Vega-Lite for PowerBI is an example of a PowerBI custom visual built with Vega-Lite.
  Sci-Hub stats browser provides coverage and usage statistics for Sci-Hub.
  github-repo-stats, a GitHub Action for advanced repository traffic analysis and reporting.
  Iris, a conversational agent for data science.
  dashcard: a simple Bootstrap-based UI for dynamic dashboarding using Vega-Lite and Mondrian via a REST API.
  histbook, a versatile, high-performance histogram toolkit for Numpy.
  Olmsted: a web application for biologists to explore and visualize the adapative immune system using deep sequenced B-cell receptor data. The app uses Vega’s interactive capabilities in the context of a React/Redux application to allow users to drill down into the data at multiple levels of granularity, and is currently being used by HIV researchers in the quest for a vaccine. Demo available here.
  Lens.org: Provides free search and analysis for millions of patents and scholarly works. Simplified interface for creating Vega-Lite data visualisations.
  DataVoyager.jl, a Julia package that exposes the Voyager (2) UI to the Julia programming language.
  ProfileVega.jl, a Julia profile visualization tool that uses Vega-Lite.
  Voyager clone, a basic Voyager clone with step-by-step tutorial made with Ellx.
  NL4DV, a Python toolkit that generates analytic specifications (attributes + tasks + Vega-Lite visualizations) from natural language (NL) queries, helping people prototype NL systems for data visualization.
  Saite Interactive exploratory graphics and ad hoc visualization application for Clojure(Script). Built on top of Hanami.
  Datablocks, a node-based editor for exploring, analyzing and transforming data without code.
  Rath An augmented analysis tool including auto-EDA, pattern discovery, multi-dimensional visualization recommendation, and interactive dashboards generation.
  MarkText: An open-source markdown editor that supports Vega-Lite.
  Scalene: A CPU+GPU+memory profiler for Python.
  CSrankings: a metrics-based ranking of top computer science institutions around the world.
  Kibana: a browser-based analytics and search dashboard for Elasticsearch that supports authoring and embedding Vega and Vega-Lite visualizations.
  PyGWalker A python library that turns your data into an interactive visual exploration app with one line of code.
  GWalkR An R library that turns your dataframe into an interactive visual exploration app in RStudio.
  graphic-walker, an open-source alternative to Tableau, is a versatile visualization tool for data exploration and no-code Vega-Lite editing, that can be easily embedded as a component in web apps.


Tools for Embedding Vega-Lite Visualizations


   Vega-Embed, a convenience wrapper for Vega and Vega-Lite.
   Flourish - Visualization and Storytelling Platform
  Visdown, a web app to create Vega-Lite visualizations in Markdown. Specs are written in YAML (not JSON) within code blocks.
  vega-element is a Polymer web component to embed Vega or Vega-Lite visualization using custom HTML tags.
  marked-vega is a Polymer web component to parse image/code markdowns into Vega and Vega-Lite charts.
  gulp-marked-vega is a gulp plugin (comes with a cli tool also) to replace marked-vega markdown syntax with base64 embedded image tags, so that any standard markdown parser can render the Vega and Vega-Lite charts without modifying their render rules.
  idyll-vega-lite is a component that allows you to embed Vega-Lite graphics inside of Idyll markup, an interactive markup language.
  generator-veeg is a Vega and Vega-Lite boilerplate generator for Yeoman.
  Kroki is a service to render Vega and Vega-Lite as PNG, SVG, or PDF.
  vega_embed_flutter, a flutter-web widget to embed Vega-Lite specs into flutter-web apps.\nVega-Lite
        
          Vega
          Altair
          Vega-Lite API\nVega
          Altair
          Vega-Lite API\nExamples
          Tutorials
          Documentation
          Usage
          Ecosystem
        
        
          GitHub
          Try Online\nExamples
          Tutorials
          Documentation
          Usage
          Ecosystem\nGitHub
          Try Online\nVega-Lite Ecosystem
   This is an incomplete list of integrations, applications, and extensions of the Vega-Lite language and compiler. If you want to add a tool or library, edit this file and send us a pull request.

We mark featured plugins and tools with a .

Tools for Authoring Vega-Lite Visualizations


   Vega-Editor, the online editor for Vega and Vega-Lite. You can also get an output Vega spec from a given Vega-Lite spec as well.
   Vega Viewer, a VSCode extension for interactive preview of Vega and Vega-Lite maps and graphs.
  vega-desktop, a desktop app that lets you open .vg.json and .vl.json to see visualizations just like you open image files with an image viewer. This is useful for creating visualizations with Vega/Vega-Lite locally.
   Voyager (2), visualization tool for exploratory data analysis that blends a Tableau-style specification interface (formerly Polestar) with chart recommendations (formerly the Voyager visualization browser) and generates Vega-Lite visualizations.
  Bayes - A creative data exploration and storytelling tool. Easily create and publish Vega-Lite visualizations.
  data.world Chart Builder, a chart builder that imports data from queries in data.world. The generated specs can be saved locally or uploaded back to data.world. Project is open source.
  ColorBrewer-Lite, a fork of the ColorBrewer project that allows importing Vega-Lite specifications into the ColorBrewer interface to pick effective color schemes “in situ” for any color encoding.
  Emacs Vega View, a tool that allows one to view Vega visualizations directly within emacs, currently supporting specs written in JSON, elisp or clojure.
  Codimd, realtime collaborative markdown notes editor with support of various diagram syntaxes including Vega-Lite.
  Ivy, an Integrated Visualization Editing environment that wraps Vega-Lite (among other declarative visualization grammars) as templates to facilitate reuse, exploration, and opportunistic creation. Includes an in-app reproduction of Polestar.
  Deneb, a Power BI custom visual with an editor for Vega-Lite or Vega specifications.
  VizLinter, an online editor that detects and fixes encoding issues based on vega-lite-linter.
  Datapane, a Python framework for building interactive reports from open-source visualization formats such as Vega-Lite.
  Graphpad, an editor for creating Vega-Lite visualizations in the Figjam collaborative whiteboarding tool.


Tools for Scaling Vega-Lite Visualizations


  altair-transform, a Python library for pre-evaluating Altair/Vega-Lite transforms with Pandas.
  ibis-vega-transform, a Python library and JupyterLab extension for evaluating Altair/Vega-Lite transforms with external databases using Ibis.
  StatisticalGraphics.jl, a Julia library for statistical graphics.
   VegaFusion, a Rust library and Python API that provides server-side acceleration for interactive Altair/Vega-Lite visualizations using Apache Arrow and DataFusion.
  Scalable Vega, a demo of how to scale Vega to large datasets by implementing a custom transform that accepts SQL queries and requests data from an external database.


Plug-ins for Vega-Lite


   Tooltips for Vega and Vega-Lite
  Leaflet Tile Map integration for Vega and Vega-Lite


Bindings for Programming Languages


   Altair exposes a Python API for building statistical visualizations that follows Vega-Lite syntax.
   Vega-Lite API is a JavaScript API for creating Vega-Lite JSON specifications.
   elm-vegaLite generates Vega-Lite specifications in the pure functional language Elm.
  Altair wrapper in R
  ipyvega supports Vega and Vega-Lite charts in Jupyter Notebooks.
  VegaLite (Elixir bindings).
   VegaLite.jl are Julia bindings to Vega and Vega-Lite.
  Deneb.jl is a convenient Julia API for creating Vega-Lite visualizations.
  Vega-Lite “bindings” for R, create Vega-Lite visualizations in R.
  vegaliteR, vega-lite htmlwidget for R.
  Vegas brings visualizations to Scala and Spark using Vega-Lite.
  Smile is a machine learning engine for JVM using Vega-Lite.
  vegawidget, low-level interface in R to render Vega and Vega-Lite specifications as htmlwidgets, including functions to interact with data, events, and signals in Shiny.
  vegabrite, functional interface for building up Vega-Lite specifications in R. Built on top of the lower-level interface provided by vegawidget
  Hanami A Clojure(Script) library for creating domain specific interactive visualization applications. Exposes a parameterized template system that uses recursive transformation to finished Vega-Lite and Vega specs. Built with reagent (react) and re-com enabled.
  Vizard tiny REPL client to visualize Clojure data in browser w/ Vega-Lite.
  Oz is a Vega & Vega-Lite based visualization and scientific document toolkit for Clojure & ClojureScript (Reagent). Originally a fork of Vizard, Oz adds support for Vega, publishing/sharing, markdown & hiccup extensions for embedding Vega-Lite & Vega visualizations in html documents, static html output, and Jupyter notebooks.
  Vizsla is a simple JavaScript API for Vega-Lite.
  Vega node for Node-RED Dashboard supports Vega and Vega-Lite visualizations on the Node-RED flow-based programming tool.
  hvega generates Vega-Lite specifications in Haskell and is based on Elm-Vega.
  Vega-Lite “bindings” for Rust, create vega-lite v3, or v4, vizualizations in Rust A high-level like Altair in under construction at procyon
  Vega.rb brings Vega and Vega-Lite to Ruby.
  Jekyll Diagrams A Jekyll plugin with support for Vega & Vega-Lite and others diagramming libraries.
  Liquid Diagrams A Liquid plugin with support for Vega & Vega-Lite and others diagramming libraries.
  Vega-Lite-Linter is a python package to help users detect and fix encoding issues.
  VegaLite is a library for Dyalog APL to build and render Vega-Lite specifications from your data.
  React Spectrum Charts are declarative visualization components from Adobe using Vega and Vega-Lite.
  vega-view displays nushell tables using Vega-Lite in a webview.


Programming / Data Science Environment that supports Vega-Lite


   JupyterLab, an extensible environment for interactive and reproducible computing, based on the Jupyter Notebook and Architecture.
  nteract, interactive notebook application with Vega and Vega-Lite renderer.
   Observable, an interactive JavaScript notebook. Embed example and exploration example.
  data.world, upload .vg.json and .vl.json files along side your raw data, or embed Vega directly into comments and summary markdown.
  nextjournal, scientific computing environment with support for data visualizations including Vega-Lite
  Liminoid, toolkit for building interactive analytics applications with Python and WebAssembly. Can pass Python data to JavaScript callbacks which render Vega/Vega-Lite specifications.
  Neptune.ai, machine learning experiment tracking tool with Vega-Lite and Altair visualizations.
  Livebook, Interactive and collaborative code notebooks with Vega-Lite visualizations.
  Hex is a data science platform that uses Vega-Lite visualizations.


Tools that use Vega-Lite


  Lyra, an interactive, graphical Visualization Design Environment (VDE)
   PdVega, lets you create interactive Vega-Lite plots for Pandas. Uses ipyvega.
  Turi Create Apple’s tool to simplify the development of custom machine learning models.
  mondrian-rest-ui, an experimental UI for mondrian-rest inspired by Polestar and CubesViewer.
  Django Chartflo, charts for the lazy ones in Django
  Vega-Lite for PowerBI is an example of a PowerBI custom visual built with Vega-Lite.
  Sci-Hub stats browser provides coverage and usage statistics for Sci-Hub.
  github-repo-stats, a GitHub Action for advanced repository traffic analysis and reporting.
  Iris, a conversational agent for data science.
  dashcard: a simple Bootstrap-based UI for dynamic dashboarding using Vega-Lite and Mondrian via a REST API.
  histbook, a versatile, high-performance histogram toolkit for Numpy.
  Olmsted: a web application for biologists to explore and visualize the adapative immune system using deep sequenced B-cell receptor data. The app uses Vega’s interactive capabilities in the context of a React/Redux application to allow users to drill down into the data at multiple levels of granularity, and is currently being used by HIV researchers in the quest for a vaccine. Demo available here.
  Lens.org: Provides free search and analysis for millions of patents and scholarly works. Simplified interface for creating Vega-Lite data visualisations.
  DataVoyager.jl, a Julia package that exposes the Voyager (2) UI to the Julia programming language.
  ProfileVega.jl, a Julia profile visualization tool that uses Vega-Lite.
  Voyager clone, a basic Voyager clone with step-by-step tutorial made with Ellx.
  NL4DV, a Python toolkit that generates analytic specifications (attributes + tasks + Vega-Lite visualizations) from natural language (NL) queries, helping people prototype NL systems for data visualization.
  Saite Interactive exploratory graphics and ad hoc visualization application for Clojure(Script). Built on top of Hanami.
  Datablocks, a node-based editor for exploring, analyzing and transforming data without code.
  Rath An augmented analysis tool including auto-EDA, pattern discovery, multi-dimensional visualization recommendation, and interactive dashboards generation.
  MarkText: An open-source markdown editor that supports Vega-Lite.
  Scalene: A CPU+GPU+memory profiler for Python.
  CSrankings: a metrics-based ranking of top computer science institutions around the world.
  Kibana: a browser-based analytics and search dashboard for Elasticsearch that supports authoring and embedding Vega and Vega-Lite visualizations.
  PyGWalker A python library that turns your data into an interactive visual exploration app with one line of code.
  GWalkR An R library that turns your dataframe into an interactive visual exploration app in RStudio.
  graphic-walker, an open-source alternative to Tableau, is a versatile visualization tool for data exploration and no-code Vega-Lite editing, that can be easily embedded as a component in web apps.


Tools for Embedding Vega-Lite Visualizations


   Vega-Embed, a convenience wrapper for Vega and Vega-Lite.
   Flourish - Visualization and Storytelling Platform
  Visdown, a web app to create Vega-Lite visualizations in Markdown. Specs are written in YAML (not JSON) within code blocks.
  vega-element is a Polymer web component to embed Vega or Vega-Lite visualization using custom HTML tags.
  marked-vega is a Polymer web component to parse image/code markdowns into Vega and Vega-Lite charts.
  gulp-marked-vega is a gulp plugin (comes with a cli tool also) to replace marked-vega markdown syntax with base64 embedded image tags, so that any standard markdown parser can render the Vega and Vega-Lite charts without modifying their render rules.
  idyll-vega-lite is a component that allows you to embed Vega-Lite graphics inside of Idyll markup, an interactive markup language.
  generator-veeg is a Vega and Vega-Lite boilerplate generator for Yeoman.
  Kroki is a service to render Vega and Vega-Lite as PNG, SVG, or PDF.
  vega_embed_flutter, a flutter-web widget to embed Vega-Lite specs into flutter-web apps.\nThis is an incomplete list of integrations, applications, and extensions of the Vega-Lite language and compiler. If you want to add a tool or library, edit this file and send us a pull request.\nedit this file and send us a pull request\nWe mark featured plugins and tools with a .\nTools for Authoring Vega-Lite Visualizations\nVega-Editor, the online editor for Vega and Vega-Lite. You can also get an output Vega spec from a given Vega-Lite spec as well.\nVega Viewer, a VSCode extension for interactive preview of Vega and Vega-Lite maps and graphs.\nvega-desktop, a desktop app that lets you open .vg.json and .vl.json to see visualizations just like you open image files with an image viewer. This is useful for creating visualizations with Vega/Vega-Lite locally.\ncreating visualizations with Vega/Vega-Lite locally\nVoyager (2), visualization tool for exploratory data analysis that blends a Tableau-style specification interface (formerly Polestar) with chart recommendations (formerly the Voyager visualization browser) and generates Vega-Lite visualizations.\nBayes - A creative data exploration and storytelling tool. Easily create and publish Vega-Lite visualizations.\ndata.world Chart Builder, a chart builder that imports data from queries in data.world. The generated specs can be saved locally or uploaded back to data.world. Project is open source.\ndata.world Chart Builder\nColorBrewer-Lite, a fork of the ColorBrewer project that allows importing Vega-Lite specifications into the ColorBrewer interface to pick effective color schemes “in situ” for any color encoding.\nEmacs Vega View, a tool that allows one to view Vega visualizations directly within emacs, currently supporting specs written in JSON, elisp or clojure.\nCodimd, realtime collaborative markdown notes editor with support of various diagram syntaxes including Vega-Lite.\nIvy, an Integrated Visualization Editing environment that wraps Vega-Lite (among other declarative visualization grammars) as templates to facilitate reuse, exploration, and opportunistic creation. Includes an in-app reproduction of Polestar.\nDeneb, a Power BI custom visual with an editor for Vega-Lite or Vega specifications.\nVizLinter, an online editor that detects and fixes encoding issues based on vega-lite-linter.\nDatapane, a Python framework for building interactive reports from open-source visualization formats such as Vega-Lite.\nGraphpad, an editor for creating Vega-Lite visualizations in the Figjam collaborative whiteboarding tool.\nTools for Scaling Vega-Lite Visualizations\naltair-transform, a Python library for pre-evaluating Altair/Vega-Lite transforms with Pandas.\nibis-vega-transform, a Python library and JupyterLab extension for evaluating Altair/Vega-Lite transforms with external databases using Ibis.\nStatisticalGraphics.jl, a Julia library for statistical graphics.\nStatisticalGraphics.jl\nVegaFusion, a Rust library and Python API that provides server-side acceleration for interactive Altair/Vega-Lite visualizations using Apache Arrow and DataFusion.\nScalable Vega, a demo of how to scale Vega to large datasets by implementing a custom transform that accepts SQL queries and requests data from an external database.\nPlug-ins for Vega-Lite\nTooltips for Vega and Vega-Lite\nTooltips for Vega and Vega-Lite\nLeaflet Tile Map integration for Vega and Vega-Lite\nLeaflet Tile Map integration for Vega and Vega-Lite\nBindings for Programming Languages\nAltair exposes a Python API for building statistical visualizations that follows Vega-Lite syntax.\nVega-Lite API is a JavaScript API for creating Vega-Lite JSON specifications.\nelm-vegaLite generates Vega-Lite specifications in the pure functional language Elm.\nipyvega supports Vega and Vega-Lite charts in Jupyter Notebooks.\nVegaLite (Elixir bindings).\nVegaLite (Elixir bindings)\nVegaLite.jl are Julia bindings to Vega and Vega-Lite.\nDeneb.jl is a convenient Julia API for creating Vega-Lite visualizations.\nVega-Lite “bindings” for R, create Vega-Lite visualizations in R.\nVega-Lite “bindings” for R\nvegaliteR, vega-lite htmlwidget for R.\nVegas brings visualizations to Scala and Spark using Vega-Lite.\nSmile is a machine learning engine for JVM using Vega-Lite.\nvegawidget, low-level interface in R to render Vega and Vega-Lite specifications as htmlwidgets, including functions to interact with data, events, and signals in Shiny.\nvegabrite, functional interface for building up Vega-Lite specifications in R. Built on top of the lower-level interface provided by vegawidget\nHanami A Clojure(Script) library for creating domain specific interactive visualization applications. Exposes a parameterized template system that uses recursive transformation to finished Vega-Lite and Vega specs. Built with reagent (react) and re-com enabled.\nVizard tiny REPL client to visualize Clojure data in browser w/ Vega-Lite.\nOz is a Vega & Vega-Lite based visualization and scientific document toolkit for Clojure & ClojureScript (Reagent). Originally a fork of Vizard, Oz adds support for Vega, publishing/sharing, markdown & hiccup extensions for embedding Vega-Lite & Vega visualizations in html documents, static html output, and Jupyter notebooks.\nVizsla is a simple JavaScript API for Vega-Lite.\nVega node for Node-RED Dashboard supports Vega and Vega-Lite visualizations on the Node-RED flow-based programming tool.\nVega node for Node-RED Dashboard\nhvega generates Vega-Lite specifications in Haskell and is based on Elm-Vega.\nVega-Lite “bindings” for Rust, create vega-lite v3, or v4, vizualizations in Rust A high-level like Altair in under construction at procyon\nVega-Lite “bindings” for Rust\nVega.rb brings Vega and Vega-Lite to Ruby.\nJekyll Diagrams A Jekyll plugin with support for Vega & Vega-Lite and others diagramming libraries.\nLiquid Diagrams A Liquid plugin with support for Vega & Vega-Lite and others diagramming libraries.\nVega-Lite-Linter is a python package to help users detect and fix encoding issues.\nVegaLite is a library for Dyalog APL to build and render Vega-Lite specifications from your data.\nReact Spectrum Charts are declarative visualization components from Adobe using Vega and Vega-Lite.\nReact Spectrum Charts\nvega-view displays nushell tables using Vega-Lite in a webview.\nProgramming / Data Science Environment that supports Vega-Lite\nJupyterLab, an extensible environment for interactive and reproducible computing, based on the Jupyter Notebook and Architecture.\nnteract, interactive notebook application with Vega and Vega-Lite renderer.\nObservable, an interactive JavaScript notebook. Embed example and exploration example.\ndata.world, upload .vg.json and .vl.json files along side your raw data, or embed Vega directly into comments and summary markdown.\nnextjournal, scientific computing environment with support for data visualizations including Vega-Lite\nLiminoid, toolkit for building interactive analytics applications with Python and WebAssembly. Can pass Python data to JavaScript callbacks which render Vega/Vega-Lite specifications.\nNeptune.ai, machine learning experiment tracking tool with Vega-Lite and Altair visualizations.\nLivebook, Interactive and collaborative code notebooks with Vega-Lite visualizations.\nHex is a data science platform that uses Vega-Lite visualizations.\nTools that use Vega-Lite\nLyra, an interactive, graphical Visualization Design Environment (VDE)\nPdVega, lets you create interactive Vega-Lite plots for Pandas. Uses ipyvega.\nTuri Create Apple’s tool to simplify the development of custom machine learning models.\nmondrian-rest-ui, an experimental UI for mondrian-rest inspired by Polestar and CubesViewer.\nDjango Chartflo, charts for the lazy ones in Django\nVega-Lite for PowerBI is an example of a PowerBI custom visual built with Vega-Lite.\nVega-Lite for PowerBI\nSci-Hub stats browser provides coverage and usage statistics for Sci-Hub.\nSci-Hub stats browser\ngithub-repo-stats, a GitHub Action for advanced repository traffic analysis and reporting.\nIris, a conversational agent for data science.\ndashcard: a simple Bootstrap-based UI for dynamic dashboarding using Vega-Lite and Mondrian via a REST API.\nhistbook, a versatile, high-performance histogram toolkit for Numpy.\nOlmsted: a web application for biologists to explore and visualize the adapative immune system using deep sequenced B-cell receptor data. The app uses Vega’s interactive capabilities in the context of a React/Redux application to allow users to drill down into the data at multiple levels of granularity, and is currently being used by HIV researchers in the quest for a vaccine. Demo available here.\nLens.org: Provides free search and analysis for millions of patents and scholarly works. Simplified interface for creating Vega-Lite data visualisations.\nDataVoyager.jl, a Julia package that exposes the Voyager (2) UI to the Julia programming language.\nProfileVega.jl, a Julia profile visualization tool that uses Vega-Lite.\nVoyager clone, a basic Voyager clone with step-by-step tutorial made with Ellx.\nNL4DV, a Python toolkit that generates analytic specifications (attributes + tasks + Vega-Lite visualizations) from natural language (NL) queries, helping people prototype NL systems for data visualization.\nSaite Interactive exploratory graphics and ad hoc visualization application for Clojure(Script). Built on top of Hanami.\nDatablocks, a node-based editor for exploring, analyzing and transforming data without code.\nRath An augmented analysis tool including auto-EDA, pattern discovery, multi-dimensional visualization recommendation, and interactive dashboards generation.\nMarkText: An open-source markdown editor that supports Vega-Lite.\nScalene: A CPU+GPU+memory profiler for Python.\nCSrankings: a metrics-based ranking of top computer science institutions around the world.\nKibana: a browser-based analytics and search dashboard for Elasticsearch that supports authoring and embedding Vega and Vega-Lite visualizations.\nauthoring and embedding Vega and Vega-Lite visualizations\nPyGWalker A python library that turns your data into an interactive visual exploration app with one line of code.\nGWalkR An R library that turns your dataframe into an interactive visual exploration app in RStudio.\ngraphic-walker, an open-source alternative to Tableau, is a versatile visualization tool for data exploration and no-code Vega-Lite editing, that can be easily embedded as a component in web apps.\nTools for Embedding Vega-Lite Visualizations\nVega-Embed, a convenience wrapper for Vega and Vega-Lite.\nFlourish - Visualization and Storytelling Platform\nVisdown, a web app to create Vega-Lite visualizations in Markdown. Specs are written in YAML (not JSON) within code blocks.\nvega-element is a Polymer web component to embed Vega or Vega-Lite visualization using custom HTML tags.\nmarked-vega is a Polymer web component to parse image/code markdowns into Vega and Vega-Lite charts.\ngulp-marked-vega is a gulp plugin (comes with a cli tool also) to replace marked-vega markdown syntax with base64 embedded image tags, so that any standard markdown parser can render the Vega and Vega-Lite charts without modifying their render rules.\nidyll-vega-lite is a component that allows you to embed Vega-Lite graphics inside of Idyll markup, an interactive markup language.\ngenerator-veeg is a Vega and Vega-Lite boilerplate generator for Yeoman.\nKroki is a service to render Vega and Vega-Lite as PNG, SVG, or PDF.\nvega_embed_flutter, a flutter-web widget to embed Vega-Lite specs into flutter-web apps.\nEdit this page and submit a pull request!\nEdit this page and submit a pull request!\n\n\n\n\nVega-Lite
        
          Vega
          Altair
          Vega-Lite API
        
      
      
        
          Examples
          Tutorials
          Documentation
          Usage
          Ecosystem
        
        
          GitHub
          Try Online
        
      
    
  
  
    
  
  Streamgraph
   





  View this example in the online editor


Vega-Lite JSON Specification

{
  "$schema": "https://vega.github.io/schema/vega-lite/v6.json",
  "width": 300, "height": 200,
  "data": {"url": "data/unemployment-across-industries.json"},
  "mark": "area",
  "encoding": {
    "x": {
      "timeUnit": "yearmonth", "field": "date",
      "axis": {"domain": false, "format": "%Y", "tickSize": 0}
    },
    "y": {
      "aggregate": "sum", "field": "count",
      "axis": null,
      "stack": "center"
    },
    "color": {"field":"series", "scale":{"scheme": "category20b"}}
  }
}\nVega-Lite
        
          Vega
          Altair
          Vega-Lite API\nVega
          Altair
          Vega-Lite API\nExamples
          Tutorials
          Documentation
          Usage
          Ecosystem
        
        
          GitHub
          Try Online\nExamples
          Tutorials
          Documentation
          Usage
          Ecosystem\nGitHub
          Try Online\nStreamgraph
   





  View this example in the online editor


Vega-Lite JSON Specification

{
  "$schema": "https://vega.github.io/schema/vega-lite/v6.json",
  "width": 300, "height": 200,
  "data": {"url": "data/unemployment-across-industries.json"},
  "mark": "area",
  "encoding": {
    "x": {
      "timeUnit": "yearmonth", "field": "date",
      "axis": {"domain": false, "format": "%Y", "tickSize": 0}
    },
    "y": {
      "aggregate": "sum", "field": "count",
      "axis": null,
      "stack": "center"
    },
    "color": {"field":"series", "scale":{"scheme": "category20b"}}
  }
}\nView this example in the online editor\nView this example in the online editor\nVega-Lite JSON Specification\nEdit this page and submit a pull request!\nEdit this page and submit a pull request!\n\n\nVega-Lite
        
          Vega
          Altair
          Vega-Lite API
        
      
      
        
          Examples
          Tutorials
          Documentation
          Usage
          Ecosystem
        
        
          GitHub
          Try Online
        
      
    
  
  
    
  
  Scatterplot Pan & Zoom
   





  View this example in the online editor


Vega-Lite JSON Specification

{
  "$schema": "https://vega.github.io/schema/vega-lite/v6.json",
  "data": {"url": "data/cars.json"},
  "params": [{
    "name": "grid",
    "select": "interval",
    "bind": "scales"
  }],
  "mark": "circle",
  "encoding": {
    "x": {
      "field": "Horsepower", "type": "quantitative",
      "scale": {"domain": [75, 150]}
    },
    "y": {
      "field": "Miles_per_Gallon", "type": "quantitative",
      "scale": {"domain": [20, 40]}
    },
    "size": {"field": "Cylinders", "type": "quantitative"}
  }
}\nVega-Lite
        
          Vega
          Altair
          Vega-Lite API\nVega
          Altair
          Vega-Lite API\nExamples
          Tutorials
          Documentation
          Usage
          Ecosystem
        
        
          GitHub
          Try Online\nExamples
          Tutorials
          Documentation
          Usage
          Ecosystem\nGitHub
          Try Online\nScatterplot Pan & Zoom
   





  View this example in the online editor


Vega-Lite JSON Specification

{
  "$schema": "https://vega.github.io/schema/vega-lite/v6.json",
  "data": {"url": "data/cars.json"},
  "params": [{
    "name": "grid",
    "select": "interval",
    "bind": "scales"
  }],
  "mark": "circle",
  "encoding": {
    "x": {
      "field": "Horsepower", "type": "quantitative",
      "scale": {"domain": [75, 150]}
    },
    "y": {
      "field": "Miles_per_Gallon", "type": "quantitative",
      "scale": {"domain": [20, 40]}
    },
    "size": {"field": "Cylinders", "type": "quantitative"}
  }
}\nScatterplot Pan & Zoom\nView this example in the online editor\nView this example in the online editor\nVega-Lite JSON Specification\nEdit this page and submit a pull request!\nEdit this page and submit a pull request!\n\n\nVega-Lite
        
          Vega
          Altair
          Vega-Lite API
        
      
      
        
          Examples
          Tutorials
          Documentation
          Usage
          Ecosystem
        
        
          GitHub
          Try Online
        
      
    
  
  
    
  
  Error Bars Showing Standard Deviation
   





  View this example in the online editor


Vega-Lite JSON Specification

{
  "$schema": "https://vega.github.io/schema/vega-lite/v6.json",
  "data": {"url": "data/barley.json"},
  "encoding": {"y": {"field": "variety", "type": "ordinal"}},
  "layer": [
    {
      "mark": {"type": "point", "filled": true},
      "encoding": {
        "x": {
          "aggregate": "mean",
          "field": "yield",
          "type": "quantitative",
          "scale": {"zero": false},
          "title": "Barley Yield"
        },
        "color": {"value": "black"}
      }
    },
    {
      "mark": {"type": "errorbar", "extent": "stdev"},
      "encoding": {
        "x": {"field": "yield", "type": "quantitative", "title": "Barley Yield"}
      }
    }
  ]
}\nVega-Lite
        
          Vega
          Altair
          Vega-Lite API\nVega
          Altair
          Vega-Lite API\nExamples
          Tutorials
          Documentation
          Usage
          Ecosystem
        
        
          GitHub
          Try Online\nExamples
          Tutorials
          Documentation
          Usage
          Ecosystem\nGitHub
          Try Online\nError Bars Showing Standard Deviation
   





  View this example in the online editor


Vega-Lite JSON Specification

{
  "$schema": "https://vega.github.io/schema/vega-lite/v6.json",
  "data": {"url": "data/barley.json"},
  "encoding": {"y": {"field": "variety", "type": "ordinal"}},
  "layer": [
    {
      "mark": {"type": "point", "filled": true},
      "encoding": {
        "x": {
          "aggregate": "mean",
          "field": "yield",
          "type": "quantitative",
          "scale": {"zero": false},
          "title": "Barley Yield"
        },
        "color": {"value": "black"}
      }
    },
    {
      "mark": {"type": "errorbar", "extent": "stdev"},
      "encoding": {
        "x": {"field": "yield", "type": "quantitative", "title": "Barley Yield"}
      }
    }
  ]
}\nError Bars Showing Standard Deviation\nView this example in the online editor\nView this example in the online editor\nVega-Lite JSON Specification\nEdit this page and submit a pull request!\nEdit this page and submit a pull request!\n\n\nVega-Lite
        
          Vega
          Altair
          Vega-Lite API
        
      
      
        
          Examples
          Tutorials
          Documentation
          Usage
          Ecosystem
        
        
          GitHub
          Try Online
        
      
    
  
  
    
  
  Strip Plot
   Shows the relationship between horsepower and the number of cylinders using tick marks.






  View this example in the online editor


Vega-Lite JSON Specification

{
  "$schema": "https://vega.github.io/schema/vega-lite/v6.json",
  "description": "Shows the relationship between horsepower and the number of cylinders using tick marks.",
  "data": {"url": "data/cars.json"},
  "mark": "tick",
  "encoding": {
    "x": {"field": "Horsepower", "type": "quantitative"},
    "y": {"field": "Cylinders", "type": "ordinal"}
  }
}\nVega-Lite
        
          Vega
          Altair
          Vega-Lite API\nVega
          Altair
          Vega-Lite API\nExamples
          Tutorials
          Documentation
          Usage
          Ecosystem
        
        
          GitHub
          Try Online\nExamples
          Tutorials
          Documentation
          Usage
          Ecosystem\nGitHub
          Try Online\nStrip Plot
   Shows the relationship between horsepower and the number of cylinders using tick marks.






  View this example in the online editor


Vega-Lite JSON Specification

{
  "$schema": "https://vega.github.io/schema/vega-lite/v6.json",
  "description": "Shows the relationship between horsepower and the number of cylinders using tick marks.",
  "data": {"url": "data/cars.json"},
  "mark": "tick",
  "encoding": {
    "x": {"field": "Horsepower", "type": "quantitative"},
    "y": {"field": "Cylinders", "type": "ordinal"}
  }
}\nShows the relationship between horsepower and the number of cylinders using tick marks.\nView this example in the online editor\nView this example in the online editor\nVega-Lite JSON Specification\nEdit this page and submit a pull request!\nEdit this page and submit a pull request!\n\n\nVega-Lite
        
          Vega
          Altair
          Vega-Lite API
        
      
      
        
          Examples
          Tutorials
          Documentation
          Usage
          Ecosystem
        
        
          GitHub
          Try Online
        
      
    
  
  
    
  
  Line Chart with Stroked Point Markers
   By setting the point property of the line mark definition to an object defining a property of the overlaying point marks, we can overlay point markers on top of line. Here we create stroked points by setting their "filled" to false and their fill to "white".

Notes: (1) This is equivalent to adding another layer of point marks. 
 (2) While "point" marks are normally semi-transparent, the overlay point marker has opacity = 1 by default.






  View this example in the online editor


Vega-Lite JSON Specification

{
  "$schema": "https://vega.github.io/schema/vega-lite/v6.json",
  "description": "Stock prices of 5 Tech Companies over Time.",
  "data": {"url": "data/stocks.csv"},
  "mark": {
    "type": "line",
    "point": {
      "filled": false,
      "fill": "white"
    }
  },
  "encoding": {
    "x": {"timeUnit": "year", "field": "date"},
    "y": {"aggregate":"mean", "field": "price", "type": "quantitative"},
    "color": {"field": "symbol", "type": "nominal"}
  }
}\nVega-Lite
        
          Vega
          Altair
          Vega-Lite API\nVega
          Altair
          Vega-Lite API\nExamples
          Tutorials
          Documentation
          Usage
          Ecosystem
        
        
          GitHub
          Try Online\nExamples
          Tutorials
          Documentation
          Usage
          Ecosystem\nGitHub
          Try Online\nLine Chart with Stroked Point Markers
   By setting the point property of the line mark definition to an object defining a property of the overlaying point marks, we can overlay point markers on top of line. Here we create stroked points by setting their "filled" to false and their fill to "white".

Notes: (1) This is equivalent to adding another layer of point marks. 
 (2) While "point" marks are normally semi-transparent, the overlay point marker has opacity = 1 by default.






  View this example in the online editor


Vega-Lite JSON Specification

{
  "$schema": "https://vega.github.io/schema/vega-lite/v6.json",
  "description": "Stock prices of 5 Tech Companies over Time.",
  "data": {"url": "data/stocks.csv"},
  "mark": {
    "type": "line",
    "point": {
      "filled": false,
      "fill": "white"
    }
  },
  "encoding": {
    "x": {"timeUnit": "year", "field": "date"},
    "y": {"aggregate":"mean", "field": "price", "type": "quantitative"},
    "color": {"field": "symbol", "type": "nominal"}
  }
}\nLine Chart with Stroked Point Markers\nBy setting the point property of the line mark definition to an object defining a property of the overlaying point marks, we can overlay point markers on top of line. Here we create stroked points by setting their "filled" to false and their fill to "white".\nNotes: (1) This is equivalent to adding another layer of point marks. 
 (2) While "point" marks are normally semi-transparent, the overlay point marker has opacity = 1 by default.\nView this example in the online editor\nView this example in the online editor\nVega-Lite JSON Specification\nEdit this page and submit a pull request!\nEdit this page and submit a pull request!\n\n\nVega-Lite
        
          Vega
          Altair
          Vega-Lite API
        
      
      
        
          Examples
          Tutorials
          Documentation
          Usage
          Ecosystem
        
        
          GitHub
          Try Online
        
      
    
  
  
    
  
  Becker's Barley Trellis Plot
   The Trellis display by Becker et al. helped establish small multiples as a “powerful mechanism for understanding interactions in studies of how a response depends on explanatory variables”. Here we reproduce a trellis of Barley yields from the 1930s, complete with main-effects ordering to facilitate comparison.






  View this example in the online editor


Vega-Lite JSON Specification

{
  "$schema": "https://vega.github.io/schema/vega-lite/v6.json",
  "name": "trellis_barley",
  "description": "The Trellis display by Becker et al. helped establish small multiples as a “powerful mechanism for understanding interactions in studies of how a response depends on explanatory variables”. Here we reproduce a trellis of Barley yields from the 1930s, complete with main-effects ordering to facilitate comparison.",
  "data": {"url": "data/barley.json"},
  "mark": "point",
  "height": {"step": 12},
  "encoding": {
    "facet": {
      "field": "site",
      "type": "ordinal",
      "columns": 2,
      "sort": {"op": "median", "field": "yield"}
    },
    "x": {
      "aggregate": "median",
      "field": "yield",
      "type": "quantitative",
      "scale": {"zero": false}
    },
    "y": {
      "field": "variety",
      "type": "ordinal",
      "sort": "-x"
    },
    "color": {"field": "year", "type": "nominal"}
  }
}\nVega-Lite
        
          Vega
          Altair
          Vega-Lite API\nVega
          Altair
          Vega-Lite API\nExamples
          Tutorials
          Documentation
          Usage
          Ecosystem
        
        
          GitHub
          Try Online\nExamples
          Tutorials
          Documentation
          Usage
          Ecosystem\nGitHub
          Try Online\nBecker's Barley Trellis Plot
   The Trellis display by Becker et al. helped establish small multiples as a “powerful mechanism for understanding interactions in studies of how a response depends on explanatory variables”. Here we reproduce a trellis of Barley yields from the 1930s, complete with main-effects ordering to facilitate comparison.






  View this example in the online editor


Vega-Lite JSON Specification

{
  "$schema": "https://vega.github.io/schema/vega-lite/v6.json",
  "name": "trellis_barley",
  "description": "The Trellis display by Becker et al. helped establish small multiples as a “powerful mechanism for understanding interactions in studies of how a response depends on explanatory variables”. Here we reproduce a trellis of Barley yields from the 1930s, complete with main-effects ordering to facilitate comparison.",
  "data": {"url": "data/barley.json"},
  "mark": "point",
  "height": {"step": 12},
  "encoding": {
    "facet": {
      "field": "site",
      "type": "ordinal",
      "columns": 2,
      "sort": {"op": "median", "field": "yield"}
    },
    "x": {
      "aggregate": "median",
      "field": "yield",
      "type": "quantitative",
      "scale": {"zero": false}
    },
    "y": {
      "field": "variety",
      "type": "ordinal",
      "sort": "-x"
    },
    "color": {"field": "year", "type": "nominal"}
  }
}\nBecker's Barley Trellis Plot\nThe Trellis display by Becker et al. helped establish small multiples as a “powerful mechanism for understanding interactions in studies of how a response depends on explanatory variables”. Here we reproduce a trellis of Barley yields from the 1930s, complete with main-effects ordering to facilitate comparison.\nView this example in the online editor\nView this example in the online editor\nVega-Lite JSON Specification\nEdit this page and submit a pull request!\nEdit this page and submit a pull request!\n\n\nVega-Lite
        
          Vega
          Altair
          Vega-Lite API
        
      
      
        
          Examples
          Tutorials
          Documentation
          Usage
          Ecosystem
        
        
          GitHub
          Try Online
        
      
    
  
  
    
  
  Choropleth of Unemployment Rate per County
   





  View this example in the online editor


Vega-Lite JSON Specification

{
  "$schema": "https://vega.github.io/schema/vega-lite/v6.json",
  "width": 500,
  "height": 300,
  "data": {
    "url": "data/us-10m.json",
    "format": {
      "type": "topojson",
      "feature": "counties"
    }
  },
  "transform": [{
    "lookup": "id",
    "from": {
      "data": {
        "url": "data/unemployment.tsv"
      },
      "key": "id",
      "fields": ["rate"]
    }
  }],
  "projection": {
    "type": "albersUsa"
  },
  "mark": "geoshape",
  "encoding": {
    "color": {
      "field": "rate",
      "type": "quantitative"
    }
  }
}\nVega-Lite
        
          Vega
          Altair
          Vega-Lite API\nVega
          Altair
          Vega-Lite API\nExamples
          Tutorials
          Documentation
          Usage
          Ecosystem
        
        
          GitHub
          Try Online\nExamples
          Tutorials
          Documentation
          Usage
          Ecosystem\nGitHub
          Try Online\nChoropleth of Unemployment Rate per County
   





  View this example in the online editor


Vega-Lite JSON Specification

{
  "$schema": "https://vega.github.io/schema/vega-lite/v6.json",
  "width": 500,
  "height": 300,
  "data": {
    "url": "data/us-10m.json",
    "format": {
      "type": "topojson",
      "feature": "counties"
    }
  },
  "transform": [{
    "lookup": "id",
    "from": {
      "data": {
        "url": "data/unemployment.tsv"
      },
      "key": "id",
      "fields": ["rate"]
    }
  }],
  "projection": {
    "type": "albersUsa"
  },
  "mark": "geoshape",
  "encoding": {
    "color": {
      "field": "rate",
      "type": "quantitative"
    }
  }
}\nChoropleth of Unemployment Rate per County\nView this example in the online editor\nView this example in the online editor\nVega-Lite JSON Specification\nEdit this page and submit a pull request!\nEdit this page and submit a pull request!\n\n\nVega-Lite
        
          Vega
          Altair
          Vega-Lite API
        
      
      
        
          Examples
          Tutorials
          Documentation
          Usage
          Ecosystem
        
        
          GitHub
          Try Online
        
      
    
  
  
    
  
  Table Bubble Plot (Github Punch Card)
   Punchcard Visualization like on Github. The day on y-axis uses a custom order from Monday to Sunday.  The sort property supports both full day names (e.g., ‘Monday’) and their three letter initials (e.g., ‘mon’) – both of which are case insensitive.






  View this example in the online editor


Vega-Lite JSON Specification

{
  "$schema": "https://vega.github.io/schema/vega-lite/v6.json",
  "description": "Punchcard Visualization like on Github. The day on y-axis uses a custom order from Monday to Sunday.  The sort property supports both full day names (e.g., 'Monday') and their three letter initials (e.g., 'mon') -- both of which are case insensitive.",
  "data": { "url": "data/github.csv"},
  "mark": "circle",
  "encoding": {
    "y": {
      "field": "time",
      "type": "ordinal",
      "timeUnit": "day",
      "sort": ["mon", "tue", "wed", "thu", "fri", "sat", "sun"]
    },
    "x": {
      "field": "time",
      "type": "ordinal",
      "timeUnit": "hours"
    },
    "size": {
      "field": "count",
      "type": "quantitative",
      "aggregate": "sum"
    }
  }
}\nVega-Lite
        
          Vega
          Altair
          Vega-Lite API\nVega
          Altair
          Vega-Lite API\nExamples
          Tutorials
          Documentation
          Usage
          Ecosystem
        
        
          GitHub
          Try Online\nExamples
          Tutorials
          Documentation
          Usage
          Ecosystem\nGitHub
          Try Online\nTable Bubble Plot (Github Punch Card)
   Punchcard Visualization like on Github. The day on y-axis uses a custom order from Monday to Sunday.  The sort property supports both full day names (e.g., ‘Monday’) and their three letter initials (e.g., ‘mon’) – both of which are case insensitive.






  View this example in the online editor


Vega-Lite JSON Specification

{
  "$schema": "https://vega.github.io/schema/vega-lite/v6.json",
  "description": "Punchcard Visualization like on Github. The day on y-axis uses a custom order from Monday to Sunday.  The sort property supports both full day names (e.g., 'Monday') and their three letter initials (e.g., 'mon') -- both of which are case insensitive.",
  "data": { "url": "data/github.csv"},
  "mark": "circle",
  "encoding": {
    "y": {
      "field": "time",
      "type": "ordinal",
      "timeUnit": "day",
      "sort": ["mon", "tue", "wed", "thu", "fri", "sat", "sun"]
    },
    "x": {
      "field": "time",
      "type": "ordinal",
      "timeUnit": "hours"
    },
    "size": {
      "field": "count",
      "type": "quantitative",
      "aggregate": "sum"
    }
  }
}\nTable Bubble Plot (Github Punch Card)\nPunchcard Visualization like on Github. The day on y-axis uses a custom order from Monday to Sunday.  The sort property supports both full day names (e.g., ‘Monday’) and their three letter initials (e.g., ‘mon’) – both of which are case insensitive.\nView this example in the online editor\nView this example in the online editor\nVega-Lite JSON Specification\nEdit this page and submit a pull request!\nEdit this page and submit a pull request!\n\n\nVega-Lite
        
          Vega
          Altair
          Vega-Lite API
        
      
      
        
          Examples
          Tutorials
          Documentation
          Usage
          Ecosystem
        
        
          GitHub
          Try Online
        
      
    
  
  
    
  
  London Tube Lines
   This example was created by @jwoLondon.






  View this example in the online editor


Vega-Lite JSON Specification

{
  "$schema": "https://vega.github.io/schema/vega-lite/v6.json",
  "width": 700,
  "height": 500,
  "view": {
    "stroke": "transparent"
  },
  "layer": [
    {
      "data": {
        "url": "data/londonBoroughs.json",
        "format": {
          "type": "topojson",
          "feature": "boroughs"
        }
      },
      "mark": {
        "type": "geoshape",
        "stroke": "white",
        "strokeWidth": 2
      },
      "encoding": {
        "color": {
          "value": "#eee"
        }
      }
    },
    {
      "data": {
        "url": "data/londonCentroids.json",
        "format": {
          "type": "json"
        }
      },
      "transform": [
        {
          "calculate": "indexof (datum.name,' ') > 0  ? substring(datum.name,0,indexof(datum.name, ' ')) : datum.name",
          "as": "bLabel"
        }
      ],
      "mark": "text",
      "encoding": {
        "longitude": {
          "field": "cx",
          "type": "quantitative"
        },
        "latitude": {
          "field": "cy",
          "type": "quantitative"
        },
        "text": {
          "field": "bLabel",
          "type": "nominal"
        },
        "size": {
          "value": 8
        },
        "opacity": {
          "value": 0.6
        }
      }
    },
    {
      "data": {
        "url": "data/londonTubeLines.json",
        "format": {
          "type": "topojson",
          "feature": "line"
        }
      },
      "mark": {
        "type": "geoshape",
        "filled": false,
        "strokeWidth": 2
      },
      "encoding": {
        "color": {
          "field": "id",
          "type": "nominal",
          "legend": {
            "title": null,
            "orient": "bottom-right",
            "offset": 0
          },
          "scale": {
            "domain": [
              "Bakerloo",
              "Central",
              "Circle",
              "District",
              "DLR",
              "Hammersmith & City",
              "Jubilee",
              "Metropolitan",
              "Northern",
              "Piccadilly",
              "Victoria",
              "Waterloo & City"
            ],
            "range": [
              "rgb(137,78,36)",
              "rgb(220,36,30)",
              "rgb(255,206,0)",
              "rgb(1,114,41)",
              "rgb(0,175,173)",
              "rgb(215,153,175)",
              "rgb(106,114,120)",
              "rgb(114,17,84)",
              "rgb(0,0,0)",
              "rgb(0,24,168)",
              "rgb(0,160,226)",
              "rgb(106,187,170)"
            ]
          }
        }
      }
    }
  ]
}\nVega-Lite
        
          Vega
          Altair
          Vega-Lite API\nVega
          Altair
          Vega-Lite API\nExamples
          Tutorials
          Documentation
          Usage
          Ecosystem
        
        
          GitHub
          Try Online\nExamples
          Tutorials
          Documentation
          Usage
          Ecosystem\nGitHub
          Try Online\nLondon Tube Lines
   This example was created by @jwoLondon.






  View this example in the online editor


Vega-Lite JSON Specification

{
  "$schema": "https://vega.github.io/schema/vega-lite/v6.json",
  "width": 700,
  "height": 500,
  "view": {
    "stroke": "transparent"
  },
  "layer": [
    {
      "data": {
        "url": "data/londonBoroughs.json",
        "format": {
          "type": "topojson",
          "feature": "boroughs"
        }
      },
      "mark": {
        "type": "geoshape",
        "stroke": "white",
        "strokeWidth": 2
      },
      "encoding": {
        "color": {
          "value": "#eee"
        }
      }
    },
    {
      "data": {
        "url": "data/londonCentroids.json",
        "format": {
          "type": "json"
        }
      },
      "transform": [
        {
          "calculate": "indexof (datum.name,' ') > 0  ? substring(datum.name,0,indexof(datum.name, ' ')) : datum.name",
          "as": "bLabel"
        }
      ],
      "mark": "text",
      "encoding": {
        "longitude": {
          "field": "cx",
          "type": "quantitative"
        },
        "latitude": {
          "field": "cy",
          "type": "quantitative"
        },
        "text": {
          "field": "bLabel",
          "type": "nominal"
        },
        "size": {
          "value": 8
        },
        "opacity": {
          "value": 0.6
        }
      }
    },
    {
      "data": {
        "url": "data/londonTubeLines.json",
        "format": {
          "type": "topojson",
          "feature": "line"
        }
      },
      "mark": {
        "type": "geoshape",
        "filled": false,
        "strokeWidth": 2
      },
      "encoding": {
        "color": {
          "field": "id",
          "type": "nominal",
          "legend": {
            "title": null,
            "orient": "bottom-right",
            "offset": 0
          },
          "scale": {
            "domain": [
              "Bakerloo",
              "Central",
              "Circle",
              "District",
              "DLR",
              "Hammersmith & City",
              "Jubilee",
              "Metropolitan",
              "Northern",
              "Piccadilly",
              "Victoria",
              "Waterloo & City"
            ],
            "range": [
              "rgb(137,78,36)",
              "rgb(220,36,30)",
              "rgb(255,206,0)",
              "rgb(1,114,41)",
              "rgb(0,175,173)",
              "rgb(215,153,175)",
              "rgb(106,114,120)",
              "rgb(114,17,84)",
              "rgb(0,0,0)",
              "rgb(0,24,168)",
              "rgb(0,160,226)",
              "rgb(106,187,170)"
            ]
          }
        }
      }
    }
  ]
}\nThis example was created by @jwoLondon.\nView this example in the online editor\nView this example in the online editor\nVega-Lite JSON Specification\nEdit this page and submit a pull request!\nEdit this page and submit a pull request!\n\n\nVega-Lite
        
          Vega
          Altair
          Vega-Lite API
        
      
      
        
          Examples
          Tutorials
          Documentation
          Usage
          Ecosystem
        
        
          GitHub
          Try Online
        
      
    
  
  
    
  
  Stacked Bar Chart
   





  View this example in the online editor


Vega-Lite JSON Specification

{
  "$schema": "https://vega.github.io/schema/vega-lite/v6.json",
  "data": {"url": "data/seattle-weather.csv"},
  "mark": "bar",
  "encoding": {
    "x": {
      "timeUnit": "month",
      "field": "date",
      "type": "ordinal",
      "title": "Month of the year"
    },
    "y": {
      "aggregate": "count",
      "type": "quantitative"
    },
    "color": {
      "field": "weather",
      "type": "nominal",
      "scale": {
        "domain": ["sun", "fog", "drizzle", "rain", "snow"],
        "range": ["#e7ba52", "#c7c7c7", "#aec7e8", "#1f77b4", "#9467bd"]
      },
      "title": "Weather type"
    }
  }
}\nVega-Lite
        
          Vega
          Altair
          Vega-Lite API\nVega
          Altair
          Vega-Lite API\nExamples
          Tutorials
          Documentation
          Usage
          Ecosystem
        
        
          GitHub
          Try Online\nExamples
          Tutorials
          Documentation
          Usage
          Ecosystem\nGitHub
          Try Online\nStacked Bar Chart
   





  View this example in the online editor


Vega-Lite JSON Specification

{
  "$schema": "https://vega.github.io/schema/vega-lite/v6.json",
  "data": {"url": "data/seattle-weather.csv"},
  "mark": "bar",
  "encoding": {
    "x": {
      "timeUnit": "month",
      "field": "date",
      "type": "ordinal",
      "title": "Month of the year"
    },
    "y": {
      "aggregate": "count",
      "type": "quantitative"
    },
    "color": {
      "field": "weather",
      "type": "nominal",
      "scale": {
        "domain": ["sun", "fog", "drizzle", "rain", "snow"],
        "range": ["#e7ba52", "#c7c7c7", "#aec7e8", "#1f77b4", "#9467bd"]
      },
      "title": "Weather type"
    }
  }
}\nView this example in the online editor\nView this example in the online editor\nVega-Lite JSON Specification\nEdit this page and submit a pull request!\nEdit this page and submit a pull request!\n\n\nVega-Lite
        
          Vega
          Altair
          Vega-Lite API
        
      
      
        
          Examples
          Tutorials
          Documentation
          Usage
          Ecosystem
        
        
          GitHub
          Try Online
        
      
    
  
  
    
  
  Carbon Dioxide in the Atmosphere
   This example was inspired by Gregor Aisch’s Carbon Dioxide Concentration By Decade.






  View this example in the online editor


Vega-Lite JSON Specification

{
  "$schema": "https://vega.github.io/schema/vega-lite/v6.json",
  "data": {
    "url": "data/co2-concentration.csv",
    "format": {"parse": {"Date": "utc:'%Y-%m-%d'"}}
  },
  "width": 800,
  "height": 500,
  "transform": [
    {"calculate": "year(datum.Date)", "as": "year"},
    {"calculate": "floor(datum.year / 10)", "as": "decade"},
    {
      "calculate": "(datum.year % 10) + (month(datum.Date)/12)",
      "as": "scaled_date"
    },
    {
      "calculate": "datum.first_date === datum.scaled_date ? 'first' : datum.last_date === datum.scaled_date ? 'last' : null",
      "as": "end"
    }
  ],
  "encoding": {
    "x": {
      "type": "quantitative",
      "title": "Year into Decade",
      "axis": {"tickCount": 11}
    },
    "y": {
      "title": "CO2 concentration in ppm",
      "type": "quantitative",
      "scale": {"zero": false}
    },
    "color": {
      "field": "decade",
      "type": "ordinal",
      "scale": {"scheme": "magma"},
      "legend": null
    }
  },

  "layer": [
    {
      "mark": "line",
      "encoding": {
        "x": {"field": "scaled_date"},
        "y": {"field": "CO2"}
      }
    },
    {
      "mark": {"type": "text", "baseline": "top", "aria": false},
      "encoding": {
        "x": {"aggregate": "min", "field": "scaled_date"},
        "y": {"aggregate": {"argmin": "scaled_date"}, "field": "CO2"},
        "text": {"aggregate": {"argmin": "scaled_date"}, "field": "year"}
      }
    },
    {
      "mark": {"type": "text", "aria": false},
      "encoding": {
        "x": {"aggregate": "max", "field": "scaled_date"},
        "y": {"aggregate": {"argmax": "scaled_date"}, "field": "CO2"},
        "text": {"aggregate": {"argmax": "scaled_date"}, "field": "year"}
      }
    }
  ],
  "config": {"text": {"align": "left", "dx": 3, "dy": 1}}
}\nVega-Lite
        
          Vega
          Altair
          Vega-Lite API\nVega
          Altair
          Vega-Lite API\nExamples
          Tutorials
          Documentation
          Usage
          Ecosystem
        
        
          GitHub
          Try Online\nExamples
          Tutorials
          Documentation
          Usage
          Ecosystem\nGitHub
          Try Online\nCarbon Dioxide in the Atmosphere
   This example was inspired by Gregor Aisch’s Carbon Dioxide Concentration By Decade.






  View this example in the online editor


Vega-Lite JSON Specification

{
  "$schema": "https://vega.github.io/schema/vega-lite/v6.json",
  "data": {
    "url": "data/co2-concentration.csv",
    "format": {"parse": {"Date": "utc:'%Y-%m-%d'"}}
  },
  "width": 800,
  "height": 500,
  "transform": [
    {"calculate": "year(datum.Date)", "as": "year"},
    {"calculate": "floor(datum.year / 10)", "as": "decade"},
    {
      "calculate": "(datum.year % 10) + (month(datum.Date)/12)",
      "as": "scaled_date"
    },
    {
      "calculate": "datum.first_date === datum.scaled_date ? 'first' : datum.last_date === datum.scaled_date ? 'last' : null",
      "as": "end"
    }
  ],
  "encoding": {
    "x": {
      "type": "quantitative",
      "title": "Year into Decade",
      "axis": {"tickCount": 11}
    },
    "y": {
      "title": "CO2 concentration in ppm",
      "type": "quantitative",
      "scale": {"zero": false}
    },
    "color": {
      "field": "decade",
      "type": "ordinal",
      "scale": {"scheme": "magma"},
      "legend": null
    }
  },

  "layer": [
    {
      "mark": "line",
      "encoding": {
        "x": {"field": "scaled_date"},
        "y": {"field": "CO2"}
      }
    },
    {
      "mark": {"type": "text", "baseline": "top", "aria": false},
      "encoding": {
        "x": {"aggregate": "min", "field": "scaled_date"},
        "y": {"aggregate": {"argmin": "scaled_date"}, "field": "CO2"},
        "text": {"aggregate": {"argmin": "scaled_date"}, "field": "year"}
      }
    },
    {
      "mark": {"type": "text", "aria": false},
      "encoding": {
        "x": {"aggregate": "max", "field": "scaled_date"},
        "y": {"aggregate": {"argmax": "scaled_date"}, "field": "CO2"},
        "text": {"aggregate": {"argmax": "scaled_date"}, "field": "year"}
      }
    }
  ],
  "config": {"text": {"align": "left", "dx": 3, "dy": 1}}
}\nCarbon Dioxide in the Atmosphere\nThis example was inspired by Gregor Aisch’s Carbon Dioxide Concentration By Decade.\nCarbon Dioxide Concentration By Decade\nView this example in the online editor\nView this example in the online editor\nVega-Lite JSON Specification\nEdit this page and submit a pull request!\nEdit this page and submit a pull request!\n\n\nVega-Lite
        
          Vega
          Altair
          Vega-Lite API
        
      
      
        
          Examples
          Tutorials
          Documentation
          Usage
          Ecosystem
        
        
          GitHub
          Try Online
        
      
    
  
  
    
  
  Bubble Plot (Natural Disasters)
   Visualization of global deaths from natural disasters. Copy of chart from Our World in Data.






  View this example in the online editor


Vega-Lite JSON Specification

{
  "$schema": "https://vega.github.io/schema/vega-lite/v6.json",
  "data": {
    "url": "data/disasters.csv"
  },
  "width": 600,
  "height": 400,
  "transform": [
    {"filter": "datum.Entity !== 'All natural disasters'"}
  ],
  "mark": {
    "type": "circle",
    "opacity": 0.8,
    "stroke": "black",
    "strokeWidth": 1
  },
  "encoding": {
    "x": {
      "field": "Year",
      "type": "temporal",
      "axis": {"grid": false}
    },
    "y": {"field": "Entity", "type": "nominal", "axis": {"title": ""}},
    "size": {
      "field": "Deaths",
      "type": "quantitative",
      "title": "Annual Global Deaths",
      "legend": {"clipHeight": 30},
      "scale": {"rangeMax": 5000}
    },
    "color": {"field": "Entity", "type": "nominal", "legend": null}
  }
}\nVega-Lite
        
          Vega
          Altair
          Vega-Lite API\nVega
          Altair
          Vega-Lite API\nExamples
          Tutorials
          Documentation
          Usage
          Ecosystem
        
        
          GitHub
          Try Online\nExamples
          Tutorials
          Documentation
          Usage
          Ecosystem\nGitHub
          Try Online\nBubble Plot (Natural Disasters)
   Visualization of global deaths from natural disasters. Copy of chart from Our World in Data.






  View this example in the online editor


Vega-Lite JSON Specification

{
  "$schema": "https://vega.github.io/schema/vega-lite/v6.json",
  "data": {
    "url": "data/disasters.csv"
  },
  "width": 600,
  "height": 400,
  "transform": [
    {"filter": "datum.Entity !== 'All natural disasters'"}
  ],
  "mark": {
    "type": "circle",
    "opacity": 0.8,
    "stroke": "black",
    "strokeWidth": 1
  },
  "encoding": {
    "x": {
      "field": "Year",
      "type": "temporal",
      "axis": {"grid": false}
    },
    "y": {"field": "Entity", "type": "nominal", "axis": {"title": ""}},
    "size": {
      "field": "Deaths",
      "type": "quantitative",
      "title": "Annual Global Deaths",
      "legend": {"clipHeight": 30},
      "scale": {"rangeMax": 5000}
    },
    "color": {"field": "Entity", "type": "nominal", "legend": null}
  }
}\nBubble Plot (Natural Disasters)\nVisualization of global deaths from natural disasters. Copy of chart from Our World in Data.\nView this example in the online editor\nView this example in the online editor\nVega-Lite JSON Specification\nEdit this page and submit a pull request!\nEdit this page and submit a pull request!\n\n\nVega-Lite
        
          Vega
          Altair
          Vega-Lite API
        
      
      
        
          Examples
          Tutorials
          Documentation
          Usage
          Ecosystem
        
        
          GitHub
          Try Online
        
      
    
  
  
    
  
  Trellis Area
   Stock prices of four large companies as a small multiples of area charts.






  View this example in the online editor


Vega-Lite JSON Specification

{
  "$schema": "https://vega.github.io/schema/vega-lite/v6.json",
  "description": "Stock prices of four large companies as a small multiples of area charts.",
  "transform": [{"filter": "datum.symbol !== 'GOOG'"}],
  "width": 300,
  "height": 40,
  "data": {"url": "data/stocks.csv"},
  "mark": "area",
  "encoding": {
    "x": {
      "field": "date",
      "type": "temporal",
      "title": "Time",
      "axis": {"grid": false}
    },
    "y": {
      "field": "price",
      "type": "quantitative",
      "title": "Price",
      "axis": {"grid": false}
    },
    "color": {
      "field": "symbol",
      "type": "nominal",
      "legend": null
    },
    "row": {
      "field": "symbol",
      "type": "nominal",
      "title": "Symbol"
    }
  }
}\nVega-Lite
        
          Vega
          Altair
          Vega-Lite API\nVega
          Altair
          Vega-Lite API\nExamples
          Tutorials
          Documentation
          Usage
          Ecosystem
        
        
          GitHub
          Try Online\nExamples
          Tutorials
          Documentation
          Usage
          Ecosystem\nGitHub
          Try Online\nTrellis Area
   Stock prices of four large companies as a small multiples of area charts.






  View this example in the online editor


Vega-Lite JSON Specification

{
  "$schema": "https://vega.github.io/schema/vega-lite/v6.json",
  "description": "Stock prices of four large companies as a small multiples of area charts.",
  "transform": [{"filter": "datum.symbol !== 'GOOG'"}],
  "width": 300,
  "height": 40,
  "data": {"url": "data/stocks.csv"},
  "mark": "area",
  "encoding": {
    "x": {
      "field": "date",
      "type": "temporal",
      "title": "Time",
      "axis": {"grid": false}
    },
    "y": {
      "field": "price",
      "type": "quantitative",
      "title": "Price",
      "axis": {"grid": false}
    },
    "color": {
      "field": "symbol",
      "type": "nominal",
      "legend": null
    },
    "row": {
      "field": "symbol",
      "type": "nominal",
      "title": "Symbol"
    }
  }
}\nStock prices of four large companies as a small multiples of area charts.\nView this example in the online editor\nView this example in the online editor\nVega-Lite JSON Specification\nEdit this page and submit a pull request!\nEdit this page and submit a pull request!\n\n\nVega-Lite
        
          Vega
          Altair
          Vega-Lite API
        
      
      
        
          Examples
          Tutorials
          Documentation
          Usage
          Ecosystem
        
        
          GitHub
          Try Online
        
      
    
  
  
    
  
  Line Chart with Confidence Interval Band
   





  View this example in the online editor


Vega-Lite JSON Specification

{
  "$schema": "https://vega.github.io/schema/vega-lite/v6.json",
  "data": {"url": "data/cars.json"},
  "encoding": {
    "x": {
      "field": "Year",
      "timeUnit": "year"
    }
  },
  "layer": [
    {
      "mark": {"type": "errorband", "extent": "ci"},
      "encoding": {
        "y": {
          "field": "Miles_per_Gallon",
          "type": "quantitative",
          "title": "Mean of Miles per Gallon (95% CIs)"
        }
      }
    },
    {
      "mark": "line",
      "encoding": {
        "y": {
          "aggregate": "mean",
          "field": "Miles_per_Gallon"
        }
      }
    }
  ]
}\nVega-Lite
        
          Vega
          Altair
          Vega-Lite API\nVega
          Altair
          Vega-Lite API\nExamples
          Tutorials
          Documentation
          Usage
          Ecosystem
        
        
          GitHub
          Try Online\nExamples
          Tutorials
          Documentation
          Usage
          Ecosystem\nGitHub
          Try Online\nLine Chart with Confidence Interval Band
   





  View this example in the online editor


Vega-Lite JSON Specification

{
  "$schema": "https://vega.github.io/schema/vega-lite/v6.json",
  "data": {"url": "data/cars.json"},
  "encoding": {
    "x": {
      "field": "Year",
      "timeUnit": "year"
    }
  },
  "layer": [
    {
      "mark": {"type": "errorband", "extent": "ci"},
      "encoding": {
        "y": {
          "field": "Miles_per_Gallon",
          "type": "quantitative",
          "title": "Mean of Miles per Gallon (95% CIs)"
        }
      }
    },
    {
      "mark": "line",
      "encoding": {
        "y": {
          "aggregate": "mean",
          "field": "Miles_per_Gallon"
        }
      }
    }
  ]
}\nLine Chart with Confidence Interval Band\nView this example in the online editor\nView this example in the online editor\nVega-Lite JSON Specification\nEdit this page and submit a pull request!\nEdit this page and submit a pull request!\n\n\nVega-Lite
        
          Vega
          Altair
          Vega-Lite API
        
      
      
        
          Examples
          Tutorials
          Documentation
          Usage
          Ecosystem
        
        
          GitHub
          Try Online
        
      
    
  
  
    
  
  Slope Graph
   Slope graph showing the change in yield for different barley sites. It shows the error in the year labels for the Morris site.






  View this example in the online editor


Vega-Lite JSON Specification

{
  "$schema": "https://vega.github.io/schema/vega-lite/v6.json",
  "data": {"url": "data/barley.json"},
  "description": "Slope graph showing the change in yield for different barley sites. It shows the error in the year labels for the Morris site.",
  "mark": "line",
  "width": {"step": 50},
  "encoding": {
    "x": {
      "field": "year",
      "type": "ordinal",
      "scale": {"padding": 0.5}
    },
    "y": {
      "aggregate": "median",
      "field": "yield",
      "type": "quantitative"
    },
    "color": {"field": "site", "type": "nominal"}
  }
}\nVega-Lite
        
          Vega
          Altair
          Vega-Lite API\nVega
          Altair
          Vega-Lite API\nExamples
          Tutorials
          Documentation
          Usage
          Ecosystem
        
        
          GitHub
          Try Online\nExamples
          Tutorials
          Documentation
          Usage
          Ecosystem\nGitHub
          Try Online\nSlope Graph
   Slope graph showing the change in yield for different barley sites. It shows the error in the year labels for the Morris site.






  View this example in the online editor


Vega-Lite JSON Specification

{
  "$schema": "https://vega.github.io/schema/vega-lite/v6.json",
  "data": {"url": "data/barley.json"},
  "description": "Slope graph showing the change in yield for different barley sites. It shows the error in the year labels for the Morris site.",
  "mark": "line",
  "width": {"step": 50},
  "encoding": {
    "x": {
      "field": "year",
      "type": "ordinal",
      "scale": {"padding": 0.5}
    },
    "y": {
      "aggregate": "median",
      "field": "yield",
      "type": "quantitative"
    },
    "color": {"field": "site", "type": "nominal"}
  }
}\nSlope graph showing the change in yield for different barley sites. It shows the error in the year labels for the Morris site.\nView this example in the online editor\nView this example in the online editor\nVega-Lite JSON Specification\nEdit this page and submit a pull request!\nEdit this page and submit a pull request!\n\n\nVega-Lite
        
          Vega
          Altair
          Vega-Lite API
        
      
      
        
          Examples
          Tutorials
          Documentation
          Usage
          Ecosystem
        
        
          GitHub
          Try Online
        
      
    
  
  
    
  
  Ranged Dot Plot
   A ranged dot plot that uses ‘layer’ to convey changing life expectancy for the five most populous countries (between 1955 and 2000).






  View this example in the online editor


Vega-Lite JSON Specification

{
  "$schema": "https://vega.github.io/schema/vega-lite/v6.json",
  "description": "A ranged dot plot that uses 'layer' to convey changing life expectancy for the five most populous countries (between 1955 and 2000).",
  "data": {"url": "data/countries.json"},
  "transform": [
    {
      "filter": {
        "field": "country",
        "oneOf": ["China", "India", "United States", "Indonesia", "Brazil"]
      }
    },
    {
      "filter": {
        "field": "year",
        "oneOf": [1955, 2000]
      }
    }
  ],
  "encoding": {
    "x": {
      "field": "life_expect",
      "type": "quantitative",
      "title": "Life Expectancy (years)"
    },
    "y": {
      "field": "country",
      "type": "nominal",
      "title": "Country",
      "axis": {
        "offset": 5,
        "ticks": false,
        "minExtent": 70,
        "domain": false
      }
    }
  },
  "layer": [
    {
      "mark": "line",
      "encoding": {
        "detail": {
          "field": "country",
          "type": "nominal"
        },
        "color": {"value": "#db646f"}
      }
    },
    {
      "mark": {
        "type": "point",
        "filled": true
      },
      "encoding": {
        "color": {
          "field": "year",
          "type": "ordinal",
          "scale": {
            "domain": [1955, 2000],
            "range": ["#e6959c", "#911a24"]
          },
          "title": "Year"
        },
        "size": {"value": 100},
        "opacity": {"value": 1}
      }
    }
  ]
}\nVega-Lite
        
          Vega
          Altair
          Vega-Lite API\nVega
          Altair
          Vega-Lite API\nExamples
          Tutorials
          Documentation
          Usage
          Ecosystem
        
        
          GitHub
          Try Online\nExamples
          Tutorials
          Documentation
          Usage
          Ecosystem\nGitHub
          Try Online\nRanged Dot Plot
   A ranged dot plot that uses ‘layer’ to convey changing life expectancy for the five most populous countries (between 1955 and 2000).






  View this example in the online editor


Vega-Lite JSON Specification

{
  "$schema": "https://vega.github.io/schema/vega-lite/v6.json",
  "description": "A ranged dot plot that uses 'layer' to convey changing life expectancy for the five most populous countries (between 1955 and 2000).",
  "data": {"url": "data/countries.json"},
  "transform": [
    {
      "filter": {
        "field": "country",
        "oneOf": ["China", "India", "United States", "Indonesia", "Brazil"]
      }
    },
    {
      "filter": {
        "field": "year",
        "oneOf": [1955, 2000]
      }
    }
  ],
  "encoding": {
    "x": {
      "field": "life_expect",
      "type": "quantitative",
      "title": "Life Expectancy (years)"
    },
    "y": {
      "field": "country",
      "type": "nominal",
      "title": "Country",
      "axis": {
        "offset": 5,
        "ticks": false,
        "minExtent": 70,
        "domain": false
      }
    }
  },
  "layer": [
    {
      "mark": "line",
      "encoding": {
        "detail": {
          "field": "country",
          "type": "nominal"
        },
        "color": {"value": "#db646f"}
      }
    },
    {
      "mark": {
        "type": "point",
        "filled": true
      },
      "encoding": {
        "color": {
          "field": "year",
          "type": "ordinal",
          "scale": {
            "domain": [1955, 2000],
            "range": ["#e6959c", "#911a24"]
          },
          "title": "Year"
        },
        "size": {"value": 100},
        "opacity": {"value": 1}
      }
    }
  ]
}\nA ranged dot plot that uses ‘layer’ to convey changing life expectancy for the five most populous countries (between 1955 and 2000).\nView this example in the online editor\nView this example in the online editor\nVega-Lite JSON Specification\nEdit this page and submit a pull request!\nEdit this page and submit a pull request!\n\n\nVega-Lite
        
          Vega
          Altair
          Vega-Lite API
        
      
      
        
          Examples
          Tutorials
          Documentation
          Usage
          Ecosystem
        
        
          GitHub
          Try Online
        
      
    
  
  
    
  
  Bar Chart Highlighting Values beyond a Threshold
   To create a bar chart that highlights values beyond a threshold, we use two layers of bar marks. The lower layer shows all the bars while the upper layer shows bar with values above the threshold in red (#e45755).  We then layer a rule mark and a text mark over the bars to annotate the threshold value.






  View this example in the online editor


Vega-Lite JSON Specification

{
  "$schema": "https://vega.github.io/schema/vega-lite/v6.json",
  "description": "The PM2.5 value of Beijing observed 15 days, highlighting the days when PM2.5 level is hazardous to human health. Data source https://chartaccent.github.io/chartaccent.html",
    "layer": [{
      "data": {
        "values": [
          {"Day": 1, "Value": 54.8},
          {"Day": 2, "Value": 112.1},
          {"Day": 3, "Value": 63.6},
          {"Day": 4, "Value": 37.6},
          {"Day": 5, "Value": 79.7},
          {"Day": 6, "Value": 137.9},
          {"Day": 7, "Value": 120.1},
          {"Day": 8, "Value": 103.3},
          {"Day": 9, "Value": 394.8},
          {"Day": 10, "Value": 199.5},
          {"Day": 11, "Value": 72.3},
          {"Day": 12, "Value": 51.1},
          {"Day": 13, "Value": 112.0},
          {"Day": 14, "Value": 174.5},
          {"Day": 15, "Value": 130.5}
        ]
      },
      "layer": [{
        "mark": "bar",
        "encoding": {
          "x": {"field": "Day", "type": "ordinal", "axis": {"labelAngle": 0}},
          "y": {"field": "Value", "type": "quantitative"}
        }
      }, {
        "mark": "bar",
        "transform": [
          {"filter": "datum.Value >= 300"},
          {"calculate": "300", "as": "baseline"}
        ],
        "encoding": {
          "x": {"field": "Day", "type": "ordinal"},
          "y": {"field": "baseline", "type": "quantitative", "title": "PM2.5 Value"},
          "y2": {"field": "Value"},
          "color": {"value": "#e45755"}
        }
      }
    ]}, {
      "data": {
         "values": [{}]
      },
      "encoding": {
        "y": {"datum": 300}
      },
      "layer": [{
        "mark": "rule"
      }, {
        "mark": {
          "type": "text",
          "align": "right",
          "baseline": "bottom",
          "dx": -2,
          "dy": -2,
          "x": "width",
          "text": "hazardous"
        }
      }]
    }
  ]
}\nVega-Lite
        
          Vega
          Altair
          Vega-Lite API\nVega
          Altair
          Vega-Lite API\nExamples
          Tutorials
          Documentation
          Usage
          Ecosystem
        
        
          GitHub
          Try Online\nExamples
          Tutorials
          Documentation
          Usage
          Ecosystem\nGitHub
          Try Online\nBar Chart Highlighting Values beyond a Threshold
   To create a bar chart that highlights values beyond a threshold, we use two layers of bar marks. The lower layer shows all the bars while the upper layer shows bar with values above the threshold in red (#e45755).  We then layer a rule mark and a text mark over the bars to annotate the threshold value.






  View this example in the online editor


Vega-Lite JSON Specification

{
  "$schema": "https://vega.github.io/schema/vega-lite/v6.json",
  "description": "The PM2.5 value of Beijing observed 15 days, highlighting the days when PM2.5 level is hazardous to human health. Data source https://chartaccent.github.io/chartaccent.html",
    "layer": [{
      "data": {
        "values": [
          {"Day": 1, "Value": 54.8},
          {"Day": 2, "Value": 112.1},
          {"Day": 3, "Value": 63.6},
          {"Day": 4, "Value": 37.6},
          {"Day": 5, "Value": 79.7},
          {"Day": 6, "Value": 137.9},
          {"Day": 7, "Value": 120.1},
          {"Day": 8, "Value": 103.3},
          {"Day": 9, "Value": 394.8},
          {"Day": 10, "Value": 199.5},
          {"Day": 11, "Value": 72.3},
          {"Day": 12, "Value": 51.1},
          {"Day": 13, "Value": 112.0},
          {"Day": 14, "Value": 174.5},
          {"Day": 15, "Value": 130.5}
        ]
      },
      "layer": [{
        "mark": "bar",
        "encoding": {
          "x": {"field": "Day", "type": "ordinal", "axis": {"labelAngle": 0}},
          "y": {"field": "Value", "type": "quantitative"}
        }
      }, {
        "mark": "bar",
        "transform": [
          {"filter": "datum.Value >= 300"},
          {"calculate": "300", "as": "baseline"}
        ],
        "encoding": {
          "x": {"field": "Day", "type": "ordinal"},
          "y": {"field": "baseline", "type": "quantitative", "title": "PM2.5 Value"},
          "y2": {"field": "Value"},
          "color": {"value": "#e45755"}
        }
      }
    ]}, {
      "data": {
         "values": [{}]
      },
      "encoding": {
        "y": {"datum": 300}
      },
      "layer": [{
        "mark": "rule"
      }, {
        "mark": {
          "type": "text",
          "align": "right",
          "baseline": "bottom",
          "dx": -2,
          "dy": -2,
          "x": "width",
          "text": "hazardous"
        }
      }]
    }
  ]
}\nBar Chart Highlighting Values beyond a Threshold\nTo create a bar chart that highlights values beyond a threshold, we use two layers of bar marks. The lower layer shows all the bars while the upper layer shows bar with values above the threshold in red (#e45755).  We then layer a rule mark and a text mark over the bars to annotate the threshold value.\nView this example in the online editor\nView this example in the online editor\nVega-Lite JSON Specification\nEdit this page and submit a pull request!\nEdit this page and submit a pull request!\n\n\nVega-Lite
        
          Vega
          Altair
          Vega-Lite API
        
      
      
        
          Examples
          Tutorials
          Documentation
          Usage
          Ecosystem
        
        
          GitHub
          Try Online
        
      
    
  
  
    
  
  2D Histogram Heatmap
   





  View this example in the online editor


Vega-Lite JSON Specification

{
  "$schema": "https://vega.github.io/schema/vega-lite/v6.json",
  "data": {"url": "data/movies.json"},
  "transform": [{
    "filter": {"and": [
      {"field": "IMDB Rating", "valid": true},
      {"field": "Rotten Tomatoes Rating", "valid": true}
    ]}
  }],
  "mark": "rect",
  "width": 300,
  "height": 200,
  "encoding": {
    "x": {
      "bin": {"maxbins":60},
      "field": "IMDB Rating",
      "type": "quantitative"
    },
    "y": {
      "bin": {"maxbins": 40},
      "field": "Rotten Tomatoes Rating",
      "type": "quantitative"
    },
    "color": {
      "aggregate": "count",
      "type": "quantitative"
    }
  },
  "config": {
    "view": {
      "stroke": "transparent"
    }
  }
}\nVega-Lite
        
          Vega
          Altair
          Vega-Lite API\nVega
          Altair
          Vega-Lite API\nExamples
          Tutorials
          Documentation
          Usage
          Ecosystem
        
        
          GitHub
          Try Online\nExamples
          Tutorials
          Documentation
          Usage
          Ecosystem\nGitHub
          Try Online\n2D Histogram Heatmap
   





  View this example in the online editor


Vega-Lite JSON Specification

{
  "$schema": "https://vega.github.io/schema/vega-lite/v6.json",
  "data": {"url": "data/movies.json"},
  "transform": [{
    "filter": {"and": [
      {"field": "IMDB Rating", "valid": true},
      {"field": "Rotten Tomatoes Rating", "valid": true}
    ]}
  }],
  "mark": "rect",
  "width": 300,
  "height": 200,
  "encoding": {
    "x": {
      "bin": {"maxbins":60},
      "field": "IMDB Rating",
      "type": "quantitative"
    },
    "y": {
      "bin": {"maxbins": 40},
      "field": "Rotten Tomatoes Rating",
      "type": "quantitative"
    },
    "color": {
      "aggregate": "count",
      "type": "quantitative"
    }
  },
  "config": {
    "view": {
      "stroke": "transparent"
    }
  }
}\nView this example in the online editor\nView this example in the online editor\nVega-Lite JSON Specification\nEdit this page and submit a pull request!\nEdit this page and submit a pull request!\n\n\nVega-Lite
        
          Vega
          Altair
          Vega-Lite API
        
      
      
        
          Examples
          Tutorials
          Documentation
          Usage
          Ecosystem
        
        
          GitHub
          Try Online
        
      
    
  
  
    
  
  Interactive Scatterplot Matrix
   





  View this example in the online editor


Vega-Lite JSON Specification

{
  "$schema": "https://vega.github.io/schema/vega-lite/v6.json",
  "repeat": {
    "row": ["Horsepower", "Acceleration", "Miles_per_Gallon"],
    "column": ["Miles_per_Gallon", "Acceleration", "Horsepower"]
  },
  "spec": {
    "data": {"url": "data/cars.json"},
    "mark": "point",
    "params": [
      {
        "name": "brush",
        "select": {
          "type": "interval",
          "resolve": "union",
          "on": "[pointerdown[event.shiftKey], window:pointerup] > window:pointermove!",
          "translate": "[pointerdown[event.shiftKey], window:pointerup] > window:pointermove!",
          "zoom": "wheel![event.shiftKey]"
        }
      },
      {
        "name": "grid",
        "select": {
          "type": "interval",
          "resolve": "global",
          "translate": "[pointerdown[!event.shiftKey], window:pointerup] > window:pointermove!",
          "zoom": "wheel![!event.shiftKey]"
        },
        "bind": "scales"
      }
    ],
    "encoding": {
      "x": {"field": {"repeat": "column"}, "type": "quantitative"},
      "y": {
        "field": {"repeat": "row"},
        "type": "quantitative",
        "axis": {"minExtent": 30}
      },
      "color": {
        "condition": {
          "param": "brush",
          "field": "Origin",
          "type": "nominal"
        },
        "value": "grey"
      }
    }
  }
}\nVega-Lite
        
          Vega
          Altair
          Vega-Lite API\nVega
          Altair
          Vega-Lite API\nExamples
          Tutorials
          Documentation
          Usage
          Ecosystem
        
        
          GitHub
          Try Online\nExamples
          Tutorials
          Documentation
          Usage
          Ecosystem\nGitHub
          Try Online\nInteractive Scatterplot Matrix
   





  View this example in the online editor


Vega-Lite JSON Specification

{
  "$schema": "https://vega.github.io/schema/vega-lite/v6.json",
  "repeat": {
    "row": ["Horsepower", "Acceleration", "Miles_per_Gallon"],
    "column": ["Miles_per_Gallon", "Acceleration", "Horsepower"]
  },
  "spec": {
    "data": {"url": "data/cars.json"},
    "mark": "point",
    "params": [
      {
        "name": "brush",
        "select": {
          "type": "interval",
          "resolve": "union",
          "on": "[pointerdown[event.shiftKey], window:pointerup] > window:pointermove!",
          "translate": "[pointerdown[event.shiftKey], window:pointerup] > window:pointermove!",
          "zoom": "wheel![event.shiftKey]"
        }
      },
      {
        "name": "grid",
        "select": {
          "type": "interval",
          "resolve": "global",
          "translate": "[pointerdown[!event.shiftKey], window:pointerup] > window:pointermove!",
          "zoom": "wheel![!event.shiftKey]"
        },
        "bind": "scales"
      }
    ],
    "encoding": {
      "x": {"field": {"repeat": "column"}, "type": "quantitative"},
      "y": {
        "field": {"repeat": "row"},
        "type": "quantitative",
        "axis": {"minExtent": 30}
      },
      "color": {
        "condition": {
          "param": "brush",
          "field": "Origin",
          "type": "nominal"
        },
        "value": "grey"
      }
    }
  }
}\nInteractive Scatterplot Matrix\nView this example in the online editor\nView this example in the online editor\nVega-Lite JSON Specification\nEdit this page and submit a pull request!\nEdit this page and submit a pull request!\n\n\nVega-Lite
        
          Vega
          Altair
          Vega-Lite API
        
      
      
        
          Examples
          Tutorials
          Documentation
          Usage
          Ecosystem
        
        
          GitHub
          Try Online
        
      
    
  
  
    
  
  Crossfilter (Highlight)
   





  View this example in the online editor


Vega-Lite JSON Specification

{
  "$schema": "https://vega.github.io/schema/vega-lite/v6.json",
  "data": {
    "url": "data/flights-2k.json",
    "format": {"parse": {"date": "date"}}
  },
  "transform": [{"calculate": "hours(datum.date)", "as": "time"}],
  "repeat": {"column": ["distance", "delay", "time"]},
  "spec": {
    "layer": [{
      "params": [{
        "name": "brush",
        "select": {"type": "interval", "encodings": ["x"]}
      }],
      "mark": "bar",
      "encoding": {
        "x": {
          "field": {"repeat": "column"},
          "bin": {"maxbins": 20}
        },
        "y": {"aggregate": "count"},
        "color": {"value": "#ddd"}
      }
    }, {
      "transform": [{"filter": {"param": "brush"}}],
      "mark": "bar",
      "encoding": {
        "x": {
          "field": {"repeat": "column"},
          "bin": {"maxbins": 20}
        },
        "y": {"aggregate": "count"}
      }
    }]
  }
}\nVega-Lite
        
          Vega
          Altair
          Vega-Lite API\nVega
          Altair
          Vega-Lite API\nExamples
          Tutorials
          Documentation
          Usage
          Ecosystem
        
        
          GitHub
          Try Online\nExamples
          Tutorials
          Documentation
          Usage
          Ecosystem\nGitHub
          Try Online\nCrossfilter (Highlight)
   





  View this example in the online editor


Vega-Lite JSON Specification

{
  "$schema": "https://vega.github.io/schema/vega-lite/v6.json",
  "data": {
    "url": "data/flights-2k.json",
    "format": {"parse": {"date": "date"}}
  },
  "transform": [{"calculate": "hours(datum.date)", "as": "time"}],
  "repeat": {"column": ["distance", "delay", "time"]},
  "spec": {
    "layer": [{
      "params": [{
        "name": "brush",
        "select": {"type": "interval", "encodings": ["x"]}
      }],
      "mark": "bar",
      "encoding": {
        "x": {
          "field": {"repeat": "column"},
          "bin": {"maxbins": 20}
        },
        "y": {"aggregate": "count"},
        "color": {"value": "#ddd"}
      }
    }, {
      "transform": [{"filter": {"param": "brush"}}],
      "mark": "bar",
      "encoding": {
        "x": {
          "field": {"repeat": "column"},
          "bin": {"maxbins": 20}
        },
        "y": {"aggregate": "count"}
      }
    }]
  }
}\nCrossfilter (Highlight)\nView this example in the online editor\nView this example in the online editor\nVega-Lite JSON Specification\nEdit this page and submit a pull request!\nEdit this page and submit a pull request!\n\n\nVega-Lite
        
          Vega
          Altair
          Vega-Lite API
        
      
      
        
          Examples
          Tutorials
          Documentation
          Usage
          Ecosystem
        
        
          GitHub
          Try Online
        
      
    
  
  
    
  
  Overview and Detail
   





  View this example in the online editor


Vega-Lite JSON Specification

{
  "$schema": "https://vega.github.io/schema/vega-lite/v6.json",
  "data": {"url": "data/sp500.csv"},
  "vconcat": [{
    "width": 480,
    "mark": "area",
    "encoding": {
      "x": {
        "field": "date",
        "type": "temporal",
        "scale": {"domain": {"param": "brush"}},
        "axis": {"title": ""}
      },
      "y": {"field": "price", "type": "quantitative"}
    }
  }, {
    "width": 480,
    "height": 60,
    "mark": "area",
    "params": [{
      "name": "brush",
      "select": {"type": "interval", "encodings": ["x"]}
    }],
    "encoding": {
      "x": {
        "field": "date",
        "type": "temporal"
      },
      "y": {
        "field": "price",
        "type": "quantitative",
        "axis": {"tickCount": 3, "grid": false}
      }
    }
  }]
}\nVega-Lite
        
          Vega
          Altair
          Vega-Lite API\nVega
          Altair
          Vega-Lite API\nExamples
          Tutorials
          Documentation
          Usage
          Ecosystem
        
        
          GitHub
          Try Online\nExamples
          Tutorials
          Documentation
          Usage
          Ecosystem\nGitHub
          Try Online\nOverview and Detail
   





  View this example in the online editor


Vega-Lite JSON Specification

{
  "$schema": "https://vega.github.io/schema/vega-lite/v6.json",
  "data": {"url": "data/sp500.csv"},
  "vconcat": [{
    "width": 480,
    "mark": "area",
    "encoding": {
      "x": {
        "field": "date",
        "type": "temporal",
        "scale": {"domain": {"param": "brush"}},
        "axis": {"title": ""}
      },
      "y": {"field": "price", "type": "quantitative"}
    }
  }, {
    "width": 480,
    "height": 60,
    "mark": "area",
    "params": [{
      "name": "brush",
      "select": {"type": "interval", "encodings": ["x"]}
    }],
    "encoding": {
      "x": {
        "field": "date",
        "type": "temporal"
      },
      "y": {
        "field": "price",
        "type": "quantitative",
        "axis": {"tickCount": 3, "grid": false}
      }
    }
  }]
}\nView this example in the online editor\nView this example in the online editor\nVega-Lite JSON Specification\nEdit this page and submit a pull request!\nEdit this page and submit a pull request!\n\n\n\n\nVega
            
              Vega-Lite
              Altair
              Vega-Lite API
            
          
          
            
              Examples
              Tutorials
              Documentation
              Usage
              About
            
            
              GitHub
              Try Online
            
          
        
      

      
        
  
    Vega – A Visualization Grammar
  






  
    Vega is a visualization grammar, a declarative language for creating, saving, and sharing interactive visualization designs. With Vega, you can describe the visual appearance and interactive behavior of a visualization in a JSON format, and generate web-based views using Canvas or SVG.

Version 5.31.0

Vega provides basic building blocks for a wide variety of visualization designs: data loading and transformation, scales, map projections, axes, legends, and graphical marks such as rectangles, lines, plotting symbols, etc. Interaction techniques can be specified using reactive signals that dynamically modify a visualization in response to input event streams.

A Vega specification defines an interactive visualization in a JSON format. Specifications are parsed by Vega’s JavaScript runtime to generate both static images or interactive web-based views. Vega provides a convenient representation for computational generation of visualizations, and can serve as a foundation for new APIs and visual analysis tools.

To get started with Vega, take a look at the tutorials, example gallery, and usage guide, or read about the project’s goals.

To rapidly create common statistical graphics, check out Vega-Lite, a higher-level language built on top of Vega. Not that into JavaScript? Take a look at the Altair Python API for Vega-Lite.

Need help or want to share examples? Join the Vega discussion forum or the Vega Slack organization!\nVega
            
              Vega-Lite
              Altair
              Vega-Lite API\nVega-Lite
              Altair
              Vega-Lite API\nExamples
              Tutorials
              Documentation
              Usage
              About
            
            
              GitHub
              Try Online\nExamples
              Tutorials
              Documentation
              Usage
              About\nGitHub
              Try Online\nVega – A Visualization Grammar\nVega – A Visualization Grammar\nVega is a visualization grammar, a declarative language for creating, saving, and sharing interactive visualization designs. With Vega, you can describe the visual appearance and interactive behavior of a visualization in a JSON format, and generate web-based views using Canvas or SVG.

Version 5.31.0

Vega provides basic building blocks for a wide variety of visualization designs: data loading and transformation, scales, map projections, axes, legends, and graphical marks such as rectangles, lines, plotting symbols, etc. Interaction techniques can be specified using reactive signals that dynamically modify a visualization in response to input event streams.

A Vega specification defines an interactive visualization in a JSON format. Specifications are parsed by Vega’s JavaScript runtime to generate both static images or interactive web-based views. Vega provides a convenient representation for computational generation of visualizations, and can serve as a foundation for new APIs and visual analysis tools.

To get started with Vega, take a look at the tutorials, example gallery, and usage guide, or read about the project’s goals.

To rapidly create common statistical graphics, check out Vega-Lite, a higher-level language built on top of Vega. Not that into JavaScript? Take a look at the Altair Python API for Vega-Lite.

Need help or want to share examples? Join the Vega discussion forum or the Vega Slack organization!\nVega is a visualization grammar, a declarative language for creating, saving, and sharing interactive visualization designs. With Vega, you can describe the visual appearance and interactive behavior of a visualization in a JSON format, and generate web-based views using Canvas or SVG.\nVega provides basic building blocks for a wide variety of visualization designs: data loading and transformation, scales, map projections, axes, legends, and graphical marks such as rectangles, lines, plotting symbols, etc. Interaction techniques can be specified using reactive signals that dynamically modify a visualization in response to input event streams.\nA Vega specification defines an interactive visualization in a JSON format. Specifications are parsed by Vega’s JavaScript runtime to generate both static images or interactive web-based views. Vega provides a convenient representation for computational generation of visualizations, and can serve as a foundation for new APIs and visual analysis tools.\nTo get started with Vega, take a look at the tutorials, example gallery, and usage guide, or read about the project’s goals.\nabout the project’s goals\nTo rapidly create common statistical graphics, check out Vega-Lite, a higher-level language built on top of Vega. Not that into JavaScript? Take a look at the Altair Python API for Vega-Lite.\nNeed help or want to share examples? Join the Vega discussion forum or the Vega Slack organization!\nVega discussion forum\nVega Slack organization\n\n\nThe Vega projects provide an ecosystem of tools for declarative data visualizations. 
                The various components of this ecosystem build on each other providing different levels of abstraction.
            
            
                Vega is a NumFocus sponsored project.
            
            
                Toolkits
            

            
            

                
                
                    
                        
                            
                        
                    
                    
                        
                            Vega
                        
                        is a visualization grammar, a declarative language for creating, saving, and sharing interactive visualization designs. With
                        Vega, you can describe the visual appearance and interactive behavior of a visualization in a JSON
                        format, and generate web-based views using HTML5 Canvas or SVG.
                        
                            
                                Examples
                                |
                                Docs
                                |
                                Tutorials
                                |
                                Online Editor
                                |
                                GitHub
                            
                        
                    
                
                

                
                
                    
                        
                            
                        
                    
                    
                        
                            Vega-Lite
                        
                        is a high-level visualization grammar. It provides a concise JSON syntax for supporting rapid generation of visualizations
                        to support analysis. Vega-Lite support interactive multi-view graphics. Specifications can be compiled
                        to Vega.
                        
                            
                                Examples
                                |
                                Docs
                                |
                                Tutorials
                                |
                                Online Editor
                                |
                                GitHub
                            
                        
                    
                
                

            
            

            
            

                
                
                    
                        
                            
                        
                    
                    
                        
                            Vega-Altair
                        
                        is a declarative visualization library for Python. Its simple, friendly and
                        consistent API,
                        built on top of the powerful Vega-Lite grammar, empowers you to spend less time writing code and
                        more time exploring your data.
                        
                            
                                Examples
                                |
                                Docs
                                |
                                Tutorials
                                |
                                GitHub
                            
                        
                    
                
                

                
                
                    
                        
                            
                        
                    
                    
                        
                            VegaFusion
                        
                        provides serverside acceleration for the Vega visualization grammar. While not limited to Python, 
                        an initial application of VegaFusion is the acceleration of the Vega-Altair Python interface to Vega-Lite.
                        
                            
                                Examples
                                |
                                Docs
                                |
                                GitHub
                            
                        
                    
                
                
            

            
                Systems
            

            
            

                
                
                    
                        
                            
                        
                    
                    
                        
                            Vega-Embed
                        
                        makes it easy to embed interactive Vega and Vega-Lite views into web pages. With Vega-Embed you can
                        publish Vega visualizations as embedded web components with interactive parameters.
                        
                            
                                jsDelivr
                                |
                                Documentation
                                |
                                GitHub
                            
                        
                    
                
                


                
                
                    
                        
                            
                        
                    
                    
                        
                            Vega-Editor
                        
                        is a web application for authoring and testing Vega and Vega-Lite visualizations. It includes a number of example specifications that showcase both the visual encodings and interaction techniques. 
                        
                            
                                Online Editor
                                |
                                GitHub
                            
                        
                    
                
                

            
            

            
                
                    Components
                
            

            
            

                
                
                    
                        
                            Vega-Datasets
                        
                        is a collection of datasets used in Vega and Vega-Lite examples.
                        
                            
                                jsDelivr
                                |
                                GitHub
                            
                        
                    
                
                

                
                
                    
                        
                            Vega Themes
                        
                        is a configuration object with default settings for a variety of visual properties such as colors, typefaces, line widths and spacing.
                        
                            
                                jsDelivr
                                |
                                Demo page
                                |
                                GitHub
                            
                        
                    
                
                

            
            

            
            

                
                
                    
                        
                            Vega-Tooltips
                        
                        is a tooltip plugin for Vega and Vega-Lite visualizations. This plugin implements a custom tooltip handler for Vega that uses custom HTML tooltips instead of the HTML title attribute.
                        
                            
                                jsDelivr
                                |
                                GitHub
                            
                        
                    
                
                

                
                
                    
                        
                            VlConvert
                        
                        provides a Rust library, CLI utility, and Python library for converting Vega-Lite chart specifications into static images (SVG or PNG) or Vega chart specifications.
                        
                            
                                Python Examples
                                |
                                GitHub
                            
                        
                    
                
                

            
            

            
            

                
                
                    
                        
                            Altair-Tiles
                        
                        can be used to add tiles from any xyz tile provider such as OpenStreetMap to your Altair chart.
                        
                            
                                Documentation
                                |
                                GitHub
                            
                        
                    
                
                

                
                
                    
                        
                            Dash Vega Components
                        
                        can be used to display Vega-Altair charts in Dash applications.
                        
                            
                                Dash Documentation
                                |
                                GitHub
                            
                        
                    
                
                

            
            

            
                Governance
            

            
            

                
                
                    
                        
                            Governance
                        
                        Community health files for the Vega Projects.
                        
                            
                                Charter
                                |
                                Code of Conduct
                                |
                                Steering-Committee
                                |
                                GitHub
                            
                        
                    
                
                


                
                
                    
                        
                            Roadmap
                        
                        provides our ideas to refine and extend the feature set and improve scalability to larger datasets. All of the planned improvements will benefit the whole Vega ecosystem. 
                        
                            
                                Project Board
                                |
                                GitHub\n\nVega Projects
            
            
                Visualization Grammars
            
            
        
        
            
                The Vega projects provide an ecosystem of tools for declarative data visualizations. 
                The various components of this ecosystem build on each other providing different levels of abstraction.
            
            
                Vega is a NumFocus sponsored project.
            
            
                Toolkits
            

            
            

                
                
                    
                        
                            
                        
                    
                    
                        
                            Vega
                        
                        is a visualization grammar, a declarative language for creating, saving, and sharing interactive visualization designs. With
                        Vega, you can describe the visual appearance and interactive behavior of a visualization in a JSON
                        format, and generate web-based views using HTML5 Canvas or SVG.
                        
                            
                                Examples
                                |
                                Docs
                                |
                                Tutorials
                                |
                                Online Editor
                                |
                                GitHub
                            
                        
                    
                
                

                
                
                    
                        
                            
                        
                    
                    
                        
                            Vega-Lite
                        
                        is a high-level visualization grammar. It provides a concise JSON syntax for supporting rapid generation of visualizations
                        to support analysis. Vega-Lite support interactive multi-view graphics. Specifications can be compiled
                        to Vega.
                        
                            
                                Examples
                                |
                                Docs
                                |
                                Tutorials
                                |
                                Online Editor
                                |
                                GitHub
                            
                        
                    
                
                

            
            

            
            

                
                
                    
                        
                            
                        
                    
                    
                        
                            Vega-Altair
                        
                        is a declarative visualization library for Python. Its simple, friendly and
                        consistent API,
                        built on top of the powerful Vega-Lite grammar, empowers you to spend less time writing code and
                        more time exploring your data.
                        
                            
                                Examples
                                |
                                Docs
                                |
                                Tutorials
                                |
                                GitHub
                            
                        
                    
                
                

                
                
                    
                        
                            
                        
                    
                    
                        
                            VegaFusion
                        
                        provides serverside acceleration for the Vega visualization grammar. While not limited to Python, 
                        an initial application of VegaFusion is the acceleration of the Vega-Altair Python interface to Vega-Lite.
                        
                            
                                Examples
                                |
                                Docs
                                |
                                GitHub
                            
                        
                    
                
                
            

            
                Systems
            

            
            

                
                
                    
                        
                            
                        
                    
                    
                        
                            Vega-Embed
                        
                        makes it easy to embed interactive Vega and Vega-Lite views into web pages. With Vega-Embed you can
                        publish Vega visualizations as embedded web components with interactive parameters.
                        
                            
                                jsDelivr
                                |
                                Documentation
                                |
                                GitHub
                            
                        
                    
                
                


                
                
                    
                        
                            
                        
                    
                    
                        
                            Vega-Editor
                        
                        is a web application for authoring and testing Vega and Vega-Lite visualizations. It includes a number of example specifications that showcase both the visual encodings and interaction techniques. 
                        
                            
                                Online Editor
                                |
                                GitHub
                            
                        
                    
                
                

            
            

            
                
                    Components
                
            

            
            

                
                
                    
                        
                            Vega-Datasets
                        
                        is a collection of datasets used in Vega and Vega-Lite examples.
                        
                            
                                jsDelivr
                                |
                                GitHub
                            
                        
                    
                
                

                
                
                    
                        
                            Vega Themes
                        
                        is a configuration object with default settings for a variety of visual properties such as colors, typefaces, line widths and spacing.
                        
                            
                                jsDelivr
                                |
                                Demo page
                                |
                                GitHub
                            
                        
                    
                
                

            
            

            
            

                
                
                    
                        
                            Vega-Tooltips
                        
                        is a tooltip plugin for Vega and Vega-Lite visualizations. This plugin implements a custom tooltip handler for Vega that uses custom HTML tooltips instead of the HTML title attribute.
                        
                            
                                jsDelivr
                                |
                                GitHub
                            
                        
                    
                
                

                
                
                    
                        
                            VlConvert
                        
                        provides a Rust library, CLI utility, and Python library for converting Vega-Lite chart specifications into static images (SVG or PNG) or Vega chart specifications.
                        
                            
                                Python Examples
                                |
                                GitHub
                            
                        
                    
                
                

            
            

            
            

                
                
                    
                        
                            Altair-Tiles
                        
                        can be used to add tiles from any xyz tile provider such as OpenStreetMap to your Altair chart.
                        
                            
                                Documentation
                                |
                                GitHub
                            
                        
                    
                
                

                
                
                    
                        
                            Dash Vega Components
                        
                        can be used to display Vega-Altair charts in Dash applications.
                        
                            
                                Dash Documentation
                                |
                                GitHub
                            
                        
                    
                
                

            
            

            
                Governance
            

            
            

                
                
                    
                        
                            Governance
                        
                        Community health files for the Vega Projects.
                        
                            
                                Charter
                                |
                                Code of Conduct
                                |
                                Steering-Committee
                                |
                                GitHub
                            
                        
                    
                
                


                
                
                    
                        
                            Roadmap
                        
                        provides our ideas to refine and extend the feature set and improve scalability to larger datasets. All of the planned improvements will benefit the whole Vega ecosystem. 
                        
                            
                                Project Board
                                |
                                GitHub
                            
                        
                    
                
                

            
            

        

        
            Edit this page at
            github.com/vega/vega.github.io.\n\n\n\nvega-lite-api
      

      Vega-Lite API Reference

Chart Constructors


  vl.mark - Create a new mark of unspecified type.
  vl.markArc - Create a new arc mark.
  vl.markArea - Create a new area mark.
  vl.markBar - Create a new bar mark.
  vl.markBoxplot - Create a new boxplot mark.
  vl.markCircle - Create a new circle mark.
  vl.markErrorband - Create a new errorband mark.
  vl.markErrorbar - Create a new errorbar mark.
  vl.markGeoshape - Create a new geoshape mark.
  vl.markImage - Create a new image mark.
  vl.markLine - Create a new line mark.
  vl.markPoint - Create a new point mark.
  vl.markRect - Create a new rect mark.
  vl.markRule - Create a new rule mark.
  vl.markSquare - Create a new square mark.
  vl.markText - Create a new text mark.
  vl.markTick - Create a new tick mark.
  vl.markTrail - Create a new trail mark.
  vl.layer - Create a new layered chart.
  vl.concat - Concatenate charts.
  vl.hconcat - Horizontally concatenate charts.
  vl.vconcat - Vertically concatenate charts.
  vl.spec - Create an arbitrary Vega-Lite specification.


Utilities


  vl.register - Register Vega and Vega-Lite with the API.
  vl.render - Render a provided Vega-Lite specification.
  vl.vega - Access the registered Vega instance.
  vl.vegalite - Access the registered Vega-Lite instance.


Data


  vl.data - Create a new data reference for a chart or lookup.
  vl.urlData - Define a url data source.
  vl.inlineData - Define a inline data source.
  vl.sequence - Define a sequence data generator.
  vl.sphere - Define a sphere data generator.
  vl.graticule - Define a graticule data generator.
  vl.csv - Define a data source for csv format data.
  vl.dsv - Define a data source for dsv format data.
  vl.json - Define a data source for json format data.
  vl.topojson - Define a data source for topojson format data.
  vl.tsv - Define a data source for tsv format data.
  vl.csvFormat - Specify parsing of csv format data.
  vl.dsvFormat - Specify parsing of dsv format data.
  vl.jsonFormat - Specify parsing of json format data.
  vl.topojsonFormat - Specify parsing of topojson format data.
  vl.tsvFormat - Specify parsing of tsv format data.
  vl.lookupData - Specify a lookup on a secondary data source.
  vl.lookupSelection - Specify a lookup on an interactive selection.


Encodings


  vl.angle - Specify the angle encoding channel.
  vl.color - Specify the color encoding channel.
  vl.column - Specify the column encoding channel.
  vl.description - Specify the description encoding channel.
  vl.detail - Specify the detail encoding channel.
  vl.facet - Specify the facet encoding channel.
  vl.fill - Specify the fill encoding channel.
  vl.fillOpacity - Specify the fillOpacity encoding channel.
  vl.href - Specify the href encoding channel.
  vl.key - Specify the key encoding channel.
  vl.latitude - Specify the latitude encoding channel.
  vl.latitude2 - Specify the latitude2 encoding channel.
  vl.longitude - Specify the longitude encoding channel.
  vl.longitude2 - Specify the longitude2 encoding channel.
  vl.opacity - Specify the opacity encoding channel.
  vl.order - Specify the order encoding channel.
  vl.radius - Specify the radius encoding channel.
  vl.radius2 - Specify the radius2 encoding channel.
  vl.row - Specify the row encoding channel.
  vl.shape - Specify the shape encoding channel.
  vl.size - Specify the size encoding channel.
  vl.stroke - Specify the stroke encoding channel.
  vl.strokeDash - Specify the strokeDash encoding channel.
  vl.strokeOpacity - Specify the strokeOpacity encoding channel.
  vl.strokeWidth - Specify the strokeWidth encoding channel.
  vl.text - Specify the text encoding channel.
  vl.theta - Specify the theta encoding channel.
  vl.theta2 - Specify the theta2 encoding channel.
  vl.tooltip - Specify the tooltip encoding channel.
  vl.url - Specify the url encoding channel.
  vl.x - Specify the x encoding channel.
  vl.x2 - Specify the x2 encoding channel.
  vl.xError - Specify the xError encoding channel.
  vl.xError2 - Specify the xError2 encoding channel.
  vl.xOffset - Specify the xOffset encoding channel.
  vl.y - Specify the y encoding channel.
  vl.y2 - Specify the y2 encoding channel.
  vl.yError - Specify the yError encoding channel.
  vl.yError2 - Specify the yError2 encoding channel.
  vl.yOffset - Specify the yOffset encoding channel.


Projections


  vl.projection - Define a cartographic projection for longitude, latitude coordinates.


References


  vl.field - A reference to a data field.
  vl.fieldN - A reference to a nominal data field.
  vl.fieldO - A reference to an ordinal data field.
  vl.fieldQ - A reference to a quantitative data field.
  vl.fieldT - A reference to a temporal data field.
  vl.encoding - A reference to an encoding channel.
  vl.repeat - A field variable reference for a repeated chart.
  vl.value - A constant encoding value.
  vl.expr - An expression in the Vega expression language.


Parameters


  vl.param - Define or reference a variable parameter.
  vl.selectInterval - Define or reference a interval selection parameter.
  vl.selectPoint - Define or reference a point selection parameter.
  vl.selectSingle - Define or reference a point selection parameter. This method provides backwards compatiblity with earlier API versions; it is deprecated and may be removed in future versions. Use selectPoint() instead.
  vl.selectMulti - Define or reference a point selection parameter. This method provides backwards compatiblity with earlier API versions; it is deprecated and may be removed in future versions. Use selectPoint() instead.
  vl.configInterval - Configure interval selections.
  vl.configPoint - Configure point selections.


Parameter Bindings


  vl.checkbox - Define a new HTML checkbox input element binding.
  vl.menu - Define a new HTML select input element binding.
  vl.radio - Define a new HTML radio input element binding.
  vl.slider - Define a new HTML range input element binding.


Logical Operations


  vl.not - Logical NOT operation.
  vl.and - Logical AND operation.
  vl.or - Logical OR operation.


Data Transformations


  vl.aggregate - Group and summarize data as counts, sums, averages, etc.
  vl.bin - Discretize numeric values into uniform bins.
  vl.calculate - Calculate a new data field value.
  vl.density - Estimate smoothed densities for numeric values.
  vl.filter - Remove data that does not match provided conditions.
  vl.flatten - Map array fields to new records, one per array entry.
  vl.fold - Collapse one or more data fields into two key, value fields.
  vl.impute - Fill in missing values with imputed values.
  vl.joinaggregate - Extend input data with aggregate values as new fields.
  vl.join - A convenient shorthand for joinaggregate.
  vl.loess - Fit a smoothed trend line using local regression.
  vl.lookup - Extend input data with values from another data source.
  vl.pivot - Pivot unique values to new aggregate fields.
  vl.quantile - Calculate sample quantile values for input data.
  vl.regression - Fit regression models to smooth and predict values.
  vl.sample - Filter random records from the data limit its size.
  vl.stack - Compute running sums to stack groups of values.
  vl.timeUnit - Discretize date/time values into meaningful intervals.
  vl.window - Perform running calculations over sorted groups.
  vl.groupby - Group by fields for aggregate or window transforms.


Aggregate Operations


  vl.count - Specify a count aggregate operation.
  vl.valid - Specify a valid aggregate operation.
  vl.missing - Specify a missing aggregate operation.
  vl.distinct - Specify a distinct aggregate operation.
  vl.sum - Specify a sum aggregate operation.
  vl.mean - Specify a mean aggregate operation.
  vl.product - Specify a product aggregate operation.
  vl.average - Specify an average aggregate operation.
  vl.variance - Specify a variance aggregate operation.
  vl.variancep - Specify a variancep aggregate operation.
  vl.stdev - Specify a stdev aggregate operation.
  vl.stdevp - Specify a stdevp aggregate operation.
  vl.stderr - Specify a stderr aggregate operation.
  vl.median - Specify a median aggregate operation.
  vl.q1 - Specify a q1 aggregate operation.
  vl.q3 - Specify a q3 aggregate operation.
  vl.ci0 - Specify a ci0 aggregate operation.
  vl.ci1 - Specify a ci1 aggregate operation.
  vl.min - Specify a min aggregate operation.
  vl.max - Specify a max aggregate operation.
  vl.argmin - Specify an argmin aggregate operation.
  vl.argmax - Specify an argmax aggregate operation.


Window Operations


  vl.row_number - A row_number window operation.
  vl.rank - A rank window operation.
  vl.dense_rank - A dense_rank window operation.
  vl.percent_rank - A percent_rank window operation.
  vl.cume_dist - A cume_dist window operation.
  vl.ntile - A ntile window operation.
  vl.lag - A lag window operation.
  vl.lead - A lead window operation.
  vl.first_value - A first_value window operation.
  vl.last_value - A last_Value window operation.
  vl.nth_value - A nth_value window operation.


TimeUnit Operations


  vl.year - A time unit operation for year.
  vl.quarter - A time unit operation for quarter.
  vl.month - A time unit operation for month.
  vl.day - A time unit operation for day.
  vl.date - A time unit operation for date.
  vl.hours - A time unit operation for hours.
  vl.minutes - A time unit operation for minutes.
  vl.seconds - A time unit operation for seconds.
  vl.milliseconds - A time unit operation for milliseconds.
  vl.yearmonth - A time unit operation for yearmonth.
  vl.timeYQ - A time unit operation for yearquarter.
  vl.timeYQM - A time unit operation for yearquartermonth.
  vl.timeYM - A time unit operation for yearmonth.
  vl.timeYMD - A time unit operation for yearmonthdate.
  vl.timeYMDH - A time unit operation for yearmonthdatehours.
  vl.timeYMDHM - A time unit operation for yearmonthdatehoursminutes.
  vl.timeYMDHMS - A time unit operation for yearmonthdatehoursminutesseconds.
  vl.timeQM - A time unit operation for quartermonth.
  vl.timeMD - A time unit operation for monthdate.
  vl.timeMDH - A time unit operation for monthdatehours.
  vl.timeHM - A time unit operation for hoursminutes.
  vl.timeHMS - A time unit operation for hoursminutesseconds.
  vl.timeMS - A time unit operation for minutesseconds.
  vl.timeSMS - A time unit operation for secondsmilliseconds.
  vl.utcyear - A time unit operation for utcyear.
  vl.utcquarter - A time unit operation for utcquarter.
  vl.utcmonth - A time unit operation for utcmonth.
  vl.utcday - A time unit operation for utcday.
  vl.utcdate - A time unit operation for utcdate.
  vl.utchours - A time unit operation for utchours.
  vl.utcminutes - A time unit operation for utcminutes.
  vl.utcseconds - A time unit operation for utcseconds.
  vl.utcmilliseconds - A time unit operation for utcmilliseconds.
  vl.utcyearmonth - A time unit operation for utcyearmonth.
  vl.utcYQ - A time unit operation for utcyearquarter.
  vl.utcYQM - A time unit operation for utcyearquartermonth.
  vl.utcYM - A time unit operation for utcyearmonth.
  vl.utcYMD - A time unit operation for utcyearmonthdate.
  vl.utcYMDH - A time unit operation for utcyearmonthdatehours.
  vl.utcYMDHM - A time unit operation for utcyearmonthdatehoursminutes.
  vl.utcYMDHMS - A time unit operation for utcyearmonthdatehoursminutesseconds.
  vl.utcQM - A time unit operation for utcquartermonth.
  vl.utcMD - A time unit operation for utcmonthdate.
  vl.utcMDH - A time unit operation for utcmonthdatehours.
  vl.utcHM - A time unit operation for utchoursminutes.
  vl.utcHMS - A time unit operation for utchoursminutesseconds.
  vl.utcMS - A time unit operation for utcminutesseconds.
  vl.utcSMS - A time unit operation for utcsecondsmilliseconds.



      
      
        This site is open source. Improve this page.\nVega-Lite API Reference\nvl.mark - Create a new mark of unspecified type.\nvl.markArc - Create a new arc mark.\nvl.markArea - Create a new area mark.\nvl.markBar - Create a new bar mark.\nvl.markBoxplot - Create a new boxplot mark.\nvl.markCircle - Create a new circle mark.\nvl.markErrorband - Create a new errorband mark.\nvl.markErrorbar - Create a new errorbar mark.\nvl.markGeoshape - Create a new geoshape mark.\nvl.markImage - Create a new image mark.\nvl.markLine - Create a new line mark.\nvl.markPoint - Create a new point mark.\nvl.markRect - Create a new rect mark.\nvl.markRule - Create a new rule mark.\nvl.markSquare - Create a new square mark.\nvl.markText - Create a new text mark.\nvl.markTick - Create a new tick mark.\nvl.markTrail - Create a new trail mark.\nvl.layer - Create a new layered chart.\nvl.concat - Concatenate charts.\nvl.hconcat - Horizontally concatenate charts.\nvl.vconcat - Vertically concatenate charts.\nvl.spec - Create an arbitrary Vega-Lite specification.\nvl.register - Register Vega and Vega-Lite with the API.\nvl.render - Render a provided Vega-Lite specification.\nvl.vega - Access the registered Vega instance.\nvl.vegalite - Access the registered Vega-Lite instance.\nvl.data - Create a new data reference for a chart or lookup.\nvl.urlData - Define a url data source.\nvl.inlineData - Define a inline data source.\nvl.sequence - Define a sequence data generator.\nvl.sphere - Define a sphere data generator.\nvl.graticule - Define a graticule data generator.\nvl.csv - Define a data source for csv format data.\nvl.dsv - Define a data source for dsv format data.\nvl.json - Define a data source for json format data.\nvl.topojson - Define a data source for topojson format data.\nvl.tsv - Define a data source for tsv format data.\nvl.csvFormat - Specify parsing of csv format data.\nvl.dsvFormat - Specify parsing of dsv format data.\nvl.jsonFormat - Specify parsing of json format data.\nvl.topojsonFormat - Specify parsing of topojson format data.\nvl.tsvFormat - Specify parsing of tsv format data.\nvl.lookupData - Specify a lookup on a secondary data source.\nvl.lookupSelection - Specify a lookup on an interactive selection.\nvl.angle - Specify the angle encoding channel.\nvl.color - Specify the color encoding channel.\nvl.column - Specify the column encoding channel.\nvl.description - Specify the description encoding channel.\nvl.detail - Specify the detail encoding channel.\nvl.facet - Specify the facet encoding channel.\nvl.fill - Specify the fill encoding channel.\nvl.fillOpacity - Specify the fillOpacity encoding channel.\nvl.href - Specify the href encoding channel.\nvl.key - Specify the key encoding channel.\nvl.latitude - Specify the latitude encoding channel.\nvl.latitude2 - Specify the latitude2 encoding channel.\nvl.longitude - Specify the longitude encoding channel.\nvl.longitude2 - Specify the longitude2 encoding channel.\nvl.opacity - Specify the opacity encoding channel.\nvl.order - Specify the order encoding channel.\nvl.radius - Specify the radius encoding channel.\nvl.radius2 - Specify the radius2 encoding channel.\nvl.row - Specify the row encoding channel.\nvl.shape - Specify the shape encoding channel.\nvl.size - Specify the size encoding channel.\nvl.stroke - Specify the stroke encoding channel.\nvl.strokeDash - Specify the strokeDash encoding channel.\nvl.strokeOpacity - Specify the strokeOpacity encoding channel.\nvl.strokeWidth - Specify the strokeWidth encoding channel.\nvl.text - Specify the text encoding channel.\nvl.theta - Specify the theta encoding channel.\nvl.theta2 - Specify the theta2 encoding channel.\nvl.tooltip - Specify the tooltip encoding channel.\nvl.url - Specify the url encoding channel.\nvl.x - Specify the x encoding channel.\nvl.x2 - Specify the x2 encoding channel.\nvl.xError - Specify the xError encoding channel.\nvl.xError2 - Specify the xError2 encoding channel.\nvl.xOffset - Specify the xOffset encoding channel.\nvl.y - Specify the y encoding channel.\nvl.y2 - Specify the y2 encoding channel.\nvl.yError - Specify the yError encoding channel.\nvl.yError2 - Specify the yError2 encoding channel.\nvl.yOffset - Specify the yOffset encoding channel.\nvl.projection - Define a cartographic projection for longitude, latitude coordinates.\nvl.field - A reference to a data field.\nvl.fieldN - A reference to a nominal data field.\nvl.fieldO - A reference to an ordinal data field.\nvl.fieldQ - A reference to a quantitative data field.\nvl.fieldT - A reference to a temporal data field.\nvl.encoding - A reference to an encoding channel.\nvl.repeat - A field variable reference for a repeated chart.\nvl.value - A constant encoding value.\nvl.expr - An expression in the Vega expression language.\nVega expression language\nvl.param - Define or reference a variable parameter.\nvl.selectInterval - Define or reference a interval selection parameter.\nvl.selectPoint - Define or reference a point selection parameter.\nvl.selectSingle - Define or reference a point selection parameter. This method provides backwards compatiblity with earlier API versions; it is deprecated and may be removed in future versions. Use selectPoint() instead.\nvl.selectMulti - Define or reference a point selection parameter. This method provides backwards compatiblity with earlier API versions; it is deprecated and may be removed in future versions. Use selectPoint() instead.\nvl.configInterval - Configure interval selections.\nvl.configPoint - Configure point selections.\nvl.checkbox - Define a new HTML checkbox input element binding.\nvl.menu - Define a new HTML select input element binding.\nvl.radio - Define a new HTML radio input element binding.\nvl.slider - Define a new HTML range input element binding.\nvl.not - Logical NOT operation.\nvl.and - Logical AND operation.\nvl.or - Logical OR operation.\nvl.aggregate - Group and summarize data as counts, sums, averages, etc.\nvl.bin - Discretize numeric values into uniform bins.\nvl.calculate - Calculate a new data field value.\nvl.density - Estimate smoothed densities for numeric values.\nvl.filter - Remove data that does not match provided conditions.\nvl.flatten - Map array fields to new records, one per array entry.\nvl.fold - Collapse one or more data fields into two key, value fields.\nvl.impute - Fill in missing values with imputed values.\nvl.joinaggregate - Extend input data with aggregate values as new fields.\nvl.join - A convenient shorthand for joinaggregate.\nvl.loess - Fit a smoothed trend line using local regression.\nvl.lookup - Extend input data with values from another data source.\nvl.pivot - Pivot unique values to new aggregate fields.\nvl.quantile - Calculate sample quantile values for input data.\nvl.regression - Fit regression models to smooth and predict values.\nvl.sample - Filter random records from the data limit its size.\nvl.stack - Compute running sums to stack groups of values.\nvl.timeUnit - Discretize date/time values into meaningful intervals.\nvl.window - Perform running calculations over sorted groups.\nvl.groupby - Group by fields for aggregate or window transforms.\nvl.count - Specify a count aggregate operation.\nvl.valid - Specify a valid aggregate operation.\nvl.missing - Specify a missing aggregate operation.\nvl.distinct - Specify a distinct aggregate operation.\nvl.sum - Specify a sum aggregate operation.\nvl.mean - Specify a mean aggregate operation.\nvl.product - Specify a product aggregate operation.\nvl.average - Specify an average aggregate operation.\nvl.variance - Specify a variance aggregate operation.\nvl.variancep - Specify a variancep aggregate operation.\nvl.stdev - Specify a stdev aggregate operation.\nvl.stdevp - Specify a stdevp aggregate operation.\nvl.stderr - Specify a stderr aggregate operation.\nvl.median - Specify a median aggregate operation.\nvl.q1 - Specify a q1 aggregate operation.\nvl.q3 - Specify a q3 aggregate operation.\nvl.ci0 - Specify a ci0 aggregate operation.\nvl.ci1 - Specify a ci1 aggregate operation.\nvl.min - Specify a min aggregate operation.\nvl.max - Specify a max aggregate operation.\nvl.argmin - Specify an argmin aggregate operation.\nvl.argmax - Specify an argmax aggregate operation.\nvl.row_number - A row_number window operation.\nvl.rank - A rank window operation.\nvl.dense_rank - A dense_rank window operation.\nvl.percent_rank - A percent_rank window operation.\nvl.cume_dist - A cume_dist window operation.\nvl.ntile - A ntile window operation.\nvl.lag - A lag window operation.\nvl.lead - A lead window operation.\nvl.first_value - A first_value window operation.\nvl.last_value - A last_Value window operation.\nvl.nth_value - A nth_value window operation.\nvl.year - A time unit operation for year.\nvl.quarter - A time unit operation for quarter.\nvl.month - A time unit operation for month.\nvl.day - A time unit operation for day.\nvl.date - A time unit operation for date.\nvl.hours - A time unit operation for hours.\nvl.minutes - A time unit operation for minutes.\nvl.seconds - A time unit operation for seconds.\nvl.milliseconds - A time unit operation for milliseconds.\nvl.yearmonth - A time unit operation for yearmonth.\nvl.timeYQ - A time unit operation for yearquarter.\nvl.timeYQM - A time unit operation for yearquartermonth.\nvl.timeYM - A time unit operation for yearmonth.\nvl.timeYMD - A time unit operation for yearmonthdate.\nvl.timeYMDH - A time unit operation for yearmonthdatehours.\nvl.timeYMDHM - A time unit operation for yearmonthdatehoursminutes.\nvl.timeYMDHMS - A time unit operation for yearmonthdatehoursminutesseconds.\nvl.timeQM - A time unit operation for quartermonth.\nvl.timeMD - A time unit operation for monthdate.\nvl.timeMDH - A time unit operation for monthdatehours.\nvl.timeHM - A time unit operation for hoursminutes.\nvl.timeHMS - A time unit operation for hoursminutesseconds.\nvl.timeMS - A time unit operation for minutesseconds.\nvl.timeSMS - A time unit operation for secondsmilliseconds.\nvl.utcyear - A time unit operation for utcyear.\nvl.utcquarter - A time unit operation for utcquarter.\nvl.utcmonth - A time unit operation for utcmonth.\nvl.utcday - A time unit operation for utcday.\nvl.utcdate - A time unit operation for utcdate.\nvl.utchours - A time unit operation for utchours.\nvl.utcminutes - A time unit operation for utcminutes.\nvl.utcseconds - A time unit operation for utcseconds.\nvl.utcmilliseconds - A time unit operation for utcmilliseconds.\nvl.utcyearmonth - A time unit operation for utcyearmonth.\nvl.utcYQ - A time unit operation for utcyearquarter.\nvl.utcYQM - A time unit operation for utcyearquartermonth.\nvl.utcYM - A time unit operation for utcyearmonth.\nvl.utcYMD - A time unit operation for utcyearmonthdate.\nvl.utcYMDH - A time unit operation for utcyearmonthdatehours.\nvl.utcYMDHM - A time unit operation for utcyearmonthdatehoursminutes.\nvl.utcYMDHMS - A time unit operation for utcyearmonthdatehoursminutesseconds.\nvl.utcQM - A time unit operation for utcquartermonth.\nvl.utcMD - A time unit operation for utcmonthdate.\nvl.utcMDH - A time unit operation for utcmonthdatehours.\nvl.utcHM - A time unit operation for utchoursminutes.\nvl.utcHMS - A time unit operation for utchoursminutesseconds.\nvl.utcMS - A time unit operation for utcminutesseconds.\nvl.utcSMS - A time unit operation for utcsecondsmilliseconds.\nThis site is open source. Improve this page.\n\n\nVega
            
              Vega-Lite
              Altair
              Vega-Lite API
            
          
          
            
              Examples
              Tutorials
              Documentation
              Usage
              About
            
            
              GitHub
              Try Online
            
          
        
      

      
        

  
  
    Bar Chart Example
    A bar chart encodes quantitative values as the extent of rectangular bars. This example includes basic highlighting and tooltips on mouse hover. For a step-by-step guide to building this visualization, see the bar chart tutorial.




  
  View Source
  Export PNG
  Export SVG






  View in Online Vega Editor


Vega JSON Specification <>

{
  "$schema": "https://vega.github.io/schema/vega/v5.json",
  "description": "A basic bar chart example, with value labels shown upon pointer hover.",
  "width": 400,
  "height": 200,
  "padding": 5,

  "data": [
    {
      "name": "table",
      "values": [
        {"category": "A", "amount": 28},
        {"category": "B", "amount": 55},
        {"category": "C", "amount": 43},
        {"category": "D", "amount": 91},
        {"category": "E", "amount": 81},
        {"category": "F", "amount": 53},
        {"category": "G", "amount": 19},
        {"category": "H", "amount": 87}
      ]
    }
  ],

  "signals": [
    {
      "name": "tooltip",
      "value": {},
      "on": [
        {"events": "rect:pointerover", "update": "datum"},
        {"events": "rect:pointerout",  "update": "{}"}
      ]
    }
  ],

  "scales": [
    {
      "name": "xscale",
      "type": "band",
      "domain": {"data": "table", "field": "category"},
      "range": "width",
      "padding": 0.05,
      "round": true
    },
    {
      "name": "yscale",
      "domain": {"data": "table", "field": "amount"},
      "nice": true,
      "range": "height"
    }
  ],

  "axes": [
    { "orient": "bottom", "scale": "xscale" },
    { "orient": "left", "scale": "yscale" }
  ],

  "marks": [
    {
      "type": "rect",
      "from": {"data":"table"},
      "encode": {
        "enter": {
          "x": {"scale": "xscale", "field": "category"},
          "width": {"scale": "xscale", "band": 1},
          "y": {"scale": "yscale", "field": "amount"},
          "y2": {"scale": "yscale", "value": 0}
        },
        "update": {
          "fill": {"value": "steelblue"}
        },
        "hover": {
          "fill": {"value": "red"}
        }
      }
    },
    {
      "type": "text",
      "encode": {
        "enter": {
          "align": {"value": "center"},
          "baseline": {"value": "bottom"},
          "fill": {"value": "#333"}
        },
        "update": {
          "x": {"scale": "xscale", "signal": "tooltip.category", "band": 0.5},
          "y": {"scale": "yscale", "signal": "tooltip.amount", "offset": -2},
          "text": {"signal": "tooltip.amount"},
          "fillOpacity": [
            {"test": "datum === tooltip", "value": 0},
            {"value": 1}
          ]
        }
      }
    }
  ]
}\nVega
            
              Vega-Lite
              Altair
              Vega-Lite API\nVega-Lite
              Altair
              Vega-Lite API\nExamples
              Tutorials
              Documentation
              Usage
              About
            
            
              GitHub
              Try Online\nExamples
              Tutorials
              Documentation
              Usage
              About\nGitHub
              Try Online\nBar Chart Example
    A bar chart encodes quantitative values as the extent of rectangular bars. This example includes basic highlighting and tooltips on mouse hover. For a step-by-step guide to building this visualization, see the bar chart tutorial.




  
  View Source
  Export PNG
  Export SVG






  View in Online Vega Editor


Vega JSON Specification <>

{
  "$schema": "https://vega.github.io/schema/vega/v5.json",
  "description": "A basic bar chart example, with value labels shown upon pointer hover.",
  "width": 400,
  "height": 200,
  "padding": 5,

  "data": [
    {
      "name": "table",
      "values": [
        {"category": "A", "amount": 28},
        {"category": "B", "amount": 55},
        {"category": "C", "amount": 43},
        {"category": "D", "amount": 91},
        {"category": "E", "amount": 81},
        {"category": "F", "amount": 53},
        {"category": "G", "amount": 19},
        {"category": "H", "amount": 87}
      ]
    }
  ],

  "signals": [
    {
      "name": "tooltip",
      "value": {},
      "on": [
        {"events": "rect:pointerover", "update": "datum"},
        {"events": "rect:pointerout",  "update": "{}"}
      ]
    }
  ],

  "scales": [
    {
      "name": "xscale",
      "type": "band",
      "domain": {"data": "table", "field": "category"},
      "range": "width",
      "padding": 0.05,
      "round": true
    },
    {
      "name": "yscale",
      "domain": {"data": "table", "field": "amount"},
      "nice": true,
      "range": "height"
    }
  ],

  "axes": [
    { "orient": "bottom", "scale": "xscale" },
    { "orient": "left", "scale": "yscale" }
  ],

  "marks": [
    {
      "type": "rect",
      "from": {"data":"table"},
      "encode": {
        "enter": {
          "x": {"scale": "xscale", "field": "category"},
          "width": {"scale": "xscale", "band": 1},
          "y": {"scale": "yscale", "field": "amount"},
          "y2": {"scale": "yscale", "value": 0}
        },
        "update": {
          "fill": {"value": "steelblue"}
        },
        "hover": {
          "fill": {"value": "red"}
        }
      }
    },
    {
      "type": "text",
      "encode": {
        "enter": {
          "align": {"value": "center"},
          "baseline": {"value": "bottom"},
          "fill": {"value": "#333"}
        },
        "update": {
          "x": {"scale": "xscale", "signal": "tooltip.category", "band": 0.5},
          "y": {"scale": "yscale", "signal": "tooltip.amount", "offset": -2},
          "text": {"signal": "tooltip.amount"},
          "fillOpacity": [
            {"test": "datum === tooltip", "value": 0},
            {"value": 1}
          ]
        }
      }
    }
  ]
}\nA bar chart encodes quantitative values as the extent of rectangular bars. This example includes basic highlighting and tooltips on mouse hover. For a step-by-step guide to building this visualization, see the bar chart tutorial.\nView Source
  Export PNG
  Export SVG\nView Source
  Export PNG
  Export SVG\nView in Online Vega Editor\nView in Online Vega Editor\nVega JSON Specification <>\n{
  "$schema": "https://vega.github.io/schema/vega/v5.json",
  "description": "A basic bar chart example, with value labels shown upon pointer hover.",
  "width": 400,
  "height": 200,
  "padding": 5,

  "data": [
    {
      "name": "table",
      "values": [
        {"category": "A", "amount": 28},
        {"category": "B", "amount": 55},
        {"category": "C", "amount": 43},
        {"category": "D", "amount": 91},
        {"category": "E", "amount": 81},
        {"category": "F", "amount": 53},
        {"category": "G", "amount": 19},
        {"category": "H", "amount": 87}
      ]
    }
  ],

  "signals": [
    {
      "name": "tooltip",
      "value": {},
      "on": [
        {"events": "rect:pointerover", "update": "datum"},
        {"events": "rect:pointerout",  "update": "{}"}
      ]
    }
  ],

  "scales": [
    {
      "name": "xscale",
      "type": "band",
      "domain": {"data": "table", "field": "category"},
      "range": "width",
      "padding": 0.05,
      "round": true
    },
    {
      "name": "yscale",
      "domain": {"data": "table", "field": "amount"},
      "nice": true,
      "range": "height"
    }
  ],

  "axes": [
    { "orient": "bottom", "scale": "xscale" },
    { "orient": "left", "scale": "yscale" }
  ],

  "marks": [
    {
      "type": "rect",
      "from": {"data":"table"},
      "encode": {
        "enter": {
          "x": {"scale": "xscale", "field": "category"},
          "width": {"scale": "xscale", "band": 1},
          "y": {"scale": "yscale", "field": "amount"},
          "y2": {"scale": "yscale", "value": 0}
        },
        "update": {
          "fill": {"value": "steelblue"}
        },
        "hover": {
          "fill": {"value": "red"}
        }
      }
    },
    {
      "type": "text",
      "encode": {
        "enter": {
          "align": {"value": "center"},
          "baseline": {"value": "bottom"},
          "fill": {"value": "#333"}
        },
        "update": {
          "x": {"scale": "xscale", "signal": "tooltip.category", "band": 0.5},
          "y": {"scale": "yscale", "signal": "tooltip.amount", "offset": -2},
          "text": {"signal": "tooltip.amount"},
          "fillOpacity": [
            {"test": "datum === tooltip", "value": 0},
            {"value": 1}
          ]
        }
      }
    }
  ]
}\n{
  "$schema": "https://vega.github.io/schema/vega/v5.json",
  "description": "A basic bar chart example, with value labels shown upon pointer hover.",
  "width": 400,
  "height": 200,
  "padding": 5,

  "data": [
    {
      "name": "table",
      "values": [
        {"category": "A", "amount": 28},
        {"category": "B", "amount": 55},
        {"category": "C", "amount": 43},
        {"category": "D", "amount": 91},
        {"category": "E", "amount": 81},
        {"category": "F", "amount": 53},
        {"category": "G", "amount": 19},
        {"category": "H", "amount": 87}
      ]
    }
  ],

  "signals": [
    {
      "name": "tooltip",
      "value": {},
      "on": [
        {"events": "rect:pointerover", "update": "datum"},
        {"events": "rect:pointerout",  "update": "{}"}
      ]
    }
  ],

  "scales": [
    {
      "name": "xscale",
      "type": "band",
      "domain": {"data": "table", "field": "category"},
      "range": "width",
      "padding": 0.05,
      "round": true
    },
    {
      "name": "yscale",
      "domain": {"data": "table", "field": "amount"},
      "nice": true,
      "range": "height"
    }
  ],

  "axes": [
    { "orient": "bottom", "scale": "xscale" },
    { "orient": "left", "scale": "yscale" }
  ],

  "marks": [
    {
      "type": "rect",
      "from": {"data":"table"},
      "encode": {
        "enter": {
          "x": {"scale": "xscale", "field": "category"},
          "width": {"scale": "xscale", "band": 1},
          "y": {"scale": "yscale", "field": "amount"},
          "y2": {"scale": "yscale", "value": 0}
        },
        "update": {
          "fill": {"value": "steelblue"}
        },
        "hover": {
          "fill": {"value": "red"}
        }
      }
    },
    {
      "type": "text",
      "encode": {
        "enter": {
          "align": {"value": "center"},
          "baseline": {"value": "bottom"},
          "fill": {"value": "#333"}
        },
        "update": {
          "x": {"scale": "xscale", "signal": "tooltip.category", "band": 0.5},
          "y": {"scale": "yscale", "signal": "tooltip.amount", "offset": -2},
          "text": {"signal": "tooltip.amount"},
          "fillOpacity": [
            {"test": "datum === tooltip", "value": 0},
            {"value": 1}
          ]
        }
      }
    }
  ]
}\n"https://vega.github.io/schema/vega/v5.json"\n"A basic bar chart example, with value labels shown upon pointer hover."\n\n\nVega
            
              Vega-Lite
              Altair
              Vega-Lite API
            
          
          
            
              Examples
              Tutorials
              Documentation
              Usage
              About
            
            
              GitHub
              Try Online
            
          
        
      

      
        

  
  
    Stacked Bar Chart Example
    A stacked bar chart depicts the sum of series of quantitative values using layered bars, while still enabling inspection of individual series.




  
  View Source
  Export PNG
  Export SVG






  View in Online Vega Editor


Vega JSON Specification <>

{
  "$schema": "https://vega.github.io/schema/vega/v5.json",
  "description": "A basic stacked bar chart example.",
  "width": 500,
  "height": 200,
  "padding": 5,

  "data": [
    {
      "name": "table",
      "values": [
        {"x": 0, "y": 28, "c": 0}, {"x": 0, "y": 55, "c": 1},
        {"x": 1, "y": 43, "c": 0}, {"x": 1, "y": 91, "c": 1},
        {"x": 2, "y": 81, "c": 0}, {"x": 2, "y": 53, "c": 1},
        {"x": 3, "y": 19, "c": 0}, {"x": 3, "y": 87, "c": 1},
        {"x": 4, "y": 52, "c": 0}, {"x": 4, "y": 48, "c": 1},
        {"x": 5, "y": 24, "c": 0}, {"x": 5, "y": 49, "c": 1},
        {"x": 6, "y": 87, "c": 0}, {"x": 6, "y": 66, "c": 1},
        {"x": 7, "y": 17, "c": 0}, {"x": 7, "y": 27, "c": 1},
        {"x": 8, "y": 68, "c": 0}, {"x": 8, "y": 16, "c": 1},
        {"x": 9, "y": 49, "c": 0}, {"x": 9, "y": 15, "c": 1}
      ],
      "transform": [
        {
          "type": "stack",
          "groupby": ["x"],
          "sort": {"field": "c"},
          "field": "y"
        }
      ]
    }
  ],

  "scales": [
    {
      "name": "x",
      "type": "band",
      "range": "width",
      "domain": {"data": "table", "field": "x"}
    },
    {
      "name": "y",
      "type": "linear",
      "range": "height",
      "nice": true, "zero": true,
      "domain": {"data": "table", "field": "y1"}
    },
    {
      "name": "color",
      "type": "ordinal",
      "range": "category",
      "domain": {"data": "table", "field": "c"}
    }
  ],

  "axes": [
    {"orient": "bottom", "scale": "x", "zindex": 1},
    {"orient": "left", "scale": "y", "zindex": 1}
  ],

  "marks": [
    {
      "type": "rect",
      "from": {"data": "table"},
      "encode": {
        "enter": {
          "x": {"scale": "x", "field": "x"},
          "width": {"scale": "x", "band": 1, "offset": -1},
          "y": {"scale": "y", "field": "y0"},
          "y2": {"scale": "y", "field": "y1"},
          "fill": {"scale": "color", "field": "c"}
        },
        "update": {
          "fillOpacity": {"value": 1}
        },
        "hover": {
          "fillOpacity": {"value": 0.5}
        }
      }
    }
  ]
}\nVega
            
              Vega-Lite
              Altair
              Vega-Lite API\nVega-Lite
              Altair
              Vega-Lite API\nExamples
              Tutorials
              Documentation
              Usage
              About
            
            
              GitHub
              Try Online\nExamples
              Tutorials
              Documentation
              Usage
              About\nGitHub
              Try Online\nStacked Bar Chart Example
    A stacked bar chart depicts the sum of series of quantitative values using layered bars, while still enabling inspection of individual series.




  
  View Source
  Export PNG
  Export SVG






  View in Online Vega Editor


Vega JSON Specification <>

{
  "$schema": "https://vega.github.io/schema/vega/v5.json",
  "description": "A basic stacked bar chart example.",
  "width": 500,
  "height": 200,
  "padding": 5,

  "data": [
    {
      "name": "table",
      "values": [
        {"x": 0, "y": 28, "c": 0}, {"x": 0, "y": 55, "c": 1},
        {"x": 1, "y": 43, "c": 0}, {"x": 1, "y": 91, "c": 1},
        {"x": 2, "y": 81, "c": 0}, {"x": 2, "y": 53, "c": 1},
        {"x": 3, "y": 19, "c": 0}, {"x": 3, "y": 87, "c": 1},
        {"x": 4, "y": 52, "c": 0}, {"x": 4, "y": 48, "c": 1},
        {"x": 5, "y": 24, "c": 0}, {"x": 5, "y": 49, "c": 1},
        {"x": 6, "y": 87, "c": 0}, {"x": 6, "y": 66, "c": 1},
        {"x": 7, "y": 17, "c": 0}, {"x": 7, "y": 27, "c": 1},
        {"x": 8, "y": 68, "c": 0}, {"x": 8, "y": 16, "c": 1},
        {"x": 9, "y": 49, "c": 0}, {"x": 9, "y": 15, "c": 1}
      ],
      "transform": [
        {
          "type": "stack",
          "groupby": ["x"],
          "sort": {"field": "c"},
          "field": "y"
        }
      ]
    }
  ],

  "scales": [
    {
      "name": "x",
      "type": "band",
      "range": "width",
      "domain": {"data": "table", "field": "x"}
    },
    {
      "name": "y",
      "type": "linear",
      "range": "height",
      "nice": true, "zero": true,
      "domain": {"data": "table", "field": "y1"}
    },
    {
      "name": "color",
      "type": "ordinal",
      "range": "category",
      "domain": {"data": "table", "field": "c"}
    }
  ],

  "axes": [
    {"orient": "bottom", "scale": "x", "zindex": 1},
    {"orient": "left", "scale": "y", "zindex": 1}
  ],

  "marks": [
    {
      "type": "rect",
      "from": {"data": "table"},
      "encode": {
        "enter": {
          "x": {"scale": "x", "field": "x"},
          "width": {"scale": "x", "band": 1, "offset": -1},
          "y": {"scale": "y", "field": "y0"},
          "y2": {"scale": "y", "field": "y1"},
          "fill": {"scale": "color", "field": "c"}
        },
        "update": {
          "fillOpacity": {"value": 1}
        },
        "hover": {
          "fillOpacity": {"value": 0.5}
        }
      }
    }
  ]
}\nStacked Bar Chart Example\nA stacked bar chart depicts the sum of series of quantitative values using layered bars, while still enabling inspection of individual series.\nView Source
  Export PNG
  Export SVG\nView Source
  Export PNG
  Export SVG\nView in Online Vega Editor\nView in Online Vega Editor\nVega JSON Specification <>\n{
  "$schema": "https://vega.github.io/schema/vega/v5.json",
  "description": "A basic stacked bar chart example.",
  "width": 500,
  "height": 200,
  "padding": 5,

  "data": [
    {
      "name": "table",
      "values": [
        {"x": 0, "y": 28, "c": 0}, {"x": 0, "y": 55, "c": 1},
        {"x": 1, "y": 43, "c": 0}, {"x": 1, "y": 91, "c": 1},
        {"x": 2, "y": 81, "c": 0}, {"x": 2, "y": 53, "c": 1},
        {"x": 3, "y": 19, "c": 0}, {"x": 3, "y": 87, "c": 1},
        {"x": 4, "y": 52, "c": 0}, {"x": 4, "y": 48, "c": 1},
        {"x": 5, "y": 24, "c": 0}, {"x": 5, "y": 49, "c": 1},
        {"x": 6, "y": 87, "c": 0}, {"x": 6, "y": 66, "c": 1},
        {"x": 7, "y": 17, "c": 0}, {"x": 7, "y": 27, "c": 1},
        {"x": 8, "y": 68, "c": 0}, {"x": 8, "y": 16, "c": 1},
        {"x": 9, "y": 49, "c": 0}, {"x": 9, "y": 15, "c": 1}
      ],
      "transform": [
        {
          "type": "stack",
          "groupby": ["x"],
          "sort": {"field": "c"},
          "field": "y"
        }
      ]
    }
  ],

  "scales": [
    {
      "name": "x",
      "type": "band",
      "range": "width",
      "domain": {"data": "table", "field": "x"}
    },
    {
      "name": "y",
      "type": "linear",
      "range": "height",
      "nice": true, "zero": true,
      "domain": {"data": "table", "field": "y1"}
    },
    {
      "name": "color",
      "type": "ordinal",
      "range": "category",
      "domain": {"data": "table", "field": "c"}
    }
  ],

  "axes": [
    {"orient": "bottom", "scale": "x", "zindex": 1},
    {"orient": "left", "scale": "y", "zindex": 1}
  ],

  "marks": [
    {
      "type": "rect",
      "from": {"data": "table"},
      "encode": {
        "enter": {
          "x": {"scale": "x", "field": "x"},
          "width": {"scale": "x", "band": 1, "offset": -1},
          "y": {"scale": "y", "field": "y0"},
          "y2": {"scale": "y", "field": "y1"},
          "fill": {"scale": "color", "field": "c"}
        },
        "update": {
          "fillOpacity": {"value": 1}
        },
        "hover": {
          "fillOpacity": {"value": 0.5}
        }
      }
    }
  ]
}\n{
  "$schema": "https://vega.github.io/schema/vega/v5.json",
  "description": "A basic stacked bar chart example.",
  "width": 500,
  "height": 200,
  "padding": 5,

  "data": [
    {
      "name": "table",
      "values": [
        {"x": 0, "y": 28, "c": 0}, {"x": 0, "y": 55, "c": 1},
        {"x": 1, "y": 43, "c": 0}, {"x": 1, "y": 91, "c": 1},
        {"x": 2, "y": 81, "c": 0}, {"x": 2, "y": 53, "c": 1},
        {"x": 3, "y": 19, "c": 0}, {"x": 3, "y": 87, "c": 1},
        {"x": 4, "y": 52, "c": 0}, {"x": 4, "y": 48, "c": 1},
        {"x": 5, "y": 24, "c": 0}, {"x": 5, "y": 49, "c": 1},
        {"x": 6, "y": 87, "c": 0}, {"x": 6, "y": 66, "c": 1},
        {"x": 7, "y": 17, "c": 0}, {"x": 7, "y": 27, "c": 1},
        {"x": 8, "y": 68, "c": 0}, {"x": 8, "y": 16, "c": 1},
        {"x": 9, "y": 49, "c": 0}, {"x": 9, "y": 15, "c": 1}
      ],
      "transform": [
        {
          "type": "stack",
          "groupby": ["x"],
          "sort": {"field": "c"},
          "field": "y"
        }
      ]
    }
  ],

  "scales": [
    {
      "name": "x",
      "type": "band",
      "range": "width",
      "domain": {"data": "table", "field": "x"}
    },
    {
      "name": "y",
      "type": "linear",
      "range": "height",
      "nice": true, "zero": true,
      "domain": {"data": "table", "field": "y1"}
    },
    {
      "name": "color",
      "type": "ordinal",
      "range": "category",
      "domain": {"data": "table", "field": "c"}
    }
  ],

  "axes": [
    {"orient": "bottom", "scale": "x", "zindex": 1},
    {"orient": "left", "scale": "y", "zindex": 1}
  ],

  "marks": [
    {
      "type": "rect",
      "from": {"data": "table"},
      "encode": {
        "enter": {
          "x": {"scale": "x", "field": "x"},
          "width": {"scale": "x", "band": 1, "offset": -1},
          "y": {"scale": "y", "field": "y0"},
          "y2": {"scale": "y", "field": "y1"},
          "fill": {"scale": "color", "field": "c"}
        },
        "update": {
          "fillOpacity": {"value": 1}
        },
        "hover": {
          "fillOpacity": {"value": 0.5}
        }
      }
    }
  ]
}\n"https://vega.github.io/schema/vega/v5.json"\n"A basic stacked bar chart example."\n\n\nVega
            
              Vega-Lite
              Altair
              Vega-Lite API
            
          
          
            
              Examples
              Tutorials
              Documentation
              Usage
              About
            
            
              GitHub
              Try Online
            
          
        
      

      
        

  
  
    Grouped Bar Chart Example
    This grouped bar chart facets the data into groups, then creates a bar chart for each sub-group.




  
  View Source
  Export PNG
  Export SVG






  View in Online Vega Editor


Vega JSON Specification <>

{
  "$schema": "https://vega.github.io/schema/vega/v5.json",
  "description": "A basic grouped bar chart example.",
  "width": 300,
  "height": 240,
  "padding": 5,

  "data": [
    {
      "name": "table",
      "values": [
        {"category":"A", "position":0, "value":0.1},
        {"category":"A", "position":1, "value":0.6},
        {"category":"A", "position":2, "value":0.9},
        {"category":"A", "position":3, "value":0.4},
        {"category":"B", "position":0, "value":0.7},
        {"category":"B", "position":1, "value":0.2},
        {"category":"B", "position":2, "value":1.1},
        {"category":"B", "position":3, "value":0.8},
        {"category":"C", "position":0, "value":0.6},
        {"category":"C", "position":1, "value":0.1},
        {"category":"C", "position":2, "value":0.2},
        {"category":"C", "position":3, "value":0.7}
      ]
    }
  ],

  "scales": [
    {
      "name": "yscale",
      "type": "band",
      "domain": {"data": "table", "field": "category"},
      "range": "height",
      "padding": 0.2
    },
    {
      "name": "xscale",
      "type": "linear",
      "domain": {"data": "table", "field": "value"},
      "range": "width",
      "round": true,
      "zero": true,
      "nice": true
    },
    {
      "name": "color",
      "type": "ordinal",
      "domain": {"data": "table", "field": "position"},
      "range": {"scheme": "category20"}
    }
  ],

  "axes": [
    {"orient": "left", "scale": "yscale", "tickSize": 0, "labelPadding": 4, "zindex": 1},
    {"orient": "bottom", "scale": "xscale"}
  ],

  "marks": [
    {
      "type": "group",

      "from": {
        "facet": {
          "data": "table",
          "name": "facet",
          "groupby": "category"
        }
      },

      "encode": {
        "enter": {
          "y": {"scale": "yscale", "field": "category"}
        }
      },

      "signals": [
        {"name": "height", "update": "bandwidth('yscale')"}
      ],

      "scales": [
        {
          "name": "pos",
          "type": "band",
          "range": "height",
          "domain": {"data": "facet", "field": "position"}
        }
      ],

      "marks": [
        {
          "name": "bars",
          "from": {"data": "facet"},
          "type": "rect",
          "encode": {
            "enter": {
              "y": {"scale": "pos", "field": "position"},
              "height": {"scale": "pos", "band": 1},
              "x": {"scale": "xscale", "field": "value"},
              "x2": {"scale": "xscale", "value": 0},
              "fill": {"scale": "color", "field": "position"}
            }
          }
        },
        {
          "type": "text",
          "from": {"data": "bars"},
          "encode": {
            "enter": {
              "x": {"field": "x2", "offset": -5},
              "y": {"field": "y", "offset": {"field": "height", "mult": 0.5}},
              "fill": [
                {"test": "contrast('white', datum.fill) > contrast('black', datum.fill)", "value": "white"},
                {"value": "black"}
              ],
              "align": {"value": "right"},
              "baseline": {"value": "middle"},
              "text": {"field": "datum.value"}
            }
          }
        }
      ]
    }
  ]
}\nVega
            
              Vega-Lite
              Altair
              Vega-Lite API\nVega-Lite
              Altair
              Vega-Lite API\nExamples
              Tutorials
              Documentation
              Usage
              About
            
            
              GitHub
              Try Online\nExamples
              Tutorials
              Documentation
              Usage
              About\nGitHub
              Try Online\nGrouped Bar Chart Example
    This grouped bar chart facets the data into groups, then creates a bar chart for each sub-group.




  
  View Source
  Export PNG
  Export SVG






  View in Online Vega Editor


Vega JSON Specification <>

{
  "$schema": "https://vega.github.io/schema/vega/v5.json",
  "description": "A basic grouped bar chart example.",
  "width": 300,
  "height": 240,
  "padding": 5,

  "data": [
    {
      "name": "table",
      "values": [
        {"category":"A", "position":0, "value":0.1},
        {"category":"A", "position":1, "value":0.6},
        {"category":"A", "position":2, "value":0.9},
        {"category":"A", "position":3, "value":0.4},
        {"category":"B", "position":0, "value":0.7},
        {"category":"B", "position":1, "value":0.2},
        {"category":"B", "position":2, "value":1.1},
        {"category":"B", "position":3, "value":0.8},
        {"category":"C", "position":0, "value":0.6},
        {"category":"C", "position":1, "value":0.1},
        {"category":"C", "position":2, "value":0.2},
        {"category":"C", "position":3, "value":0.7}
      ]
    }
  ],

  "scales": [
    {
      "name": "yscale",
      "type": "band",
      "domain": {"data": "table", "field": "category"},
      "range": "height",
      "padding": 0.2
    },
    {
      "name": "xscale",
      "type": "linear",
      "domain": {"data": "table", "field": "value"},
      "range": "width",
      "round": true,
      "zero": true,
      "nice": true
    },
    {
      "name": "color",
      "type": "ordinal",
      "domain": {"data": "table", "field": "position"},
      "range": {"scheme": "category20"}
    }
  ],

  "axes": [
    {"orient": "left", "scale": "yscale", "tickSize": 0, "labelPadding": 4, "zindex": 1},
    {"orient": "bottom", "scale": "xscale"}
  ],

  "marks": [
    {
      "type": "group",

      "from": {
        "facet": {
          "data": "table",
          "name": "facet",
          "groupby": "category"
        }
      },

      "encode": {
        "enter": {
          "y": {"scale": "yscale", "field": "category"}
        }
      },

      "signals": [
        {"name": "height", "update": "bandwidth('yscale')"}
      ],

      "scales": [
        {
          "name": "pos",
          "type": "band",
          "range": "height",
          "domain": {"data": "facet", "field": "position"}
        }
      ],

      "marks": [
        {
          "name": "bars",
          "from": {"data": "facet"},
          "type": "rect",
          "encode": {
            "enter": {
              "y": {"scale": "pos", "field": "position"},
              "height": {"scale": "pos", "band": 1},
              "x": {"scale": "xscale", "field": "value"},
              "x2": {"scale": "xscale", "value": 0},
              "fill": {"scale": "color", "field": "position"}
            }
          }
        },
        {
          "type": "text",
          "from": {"data": "bars"},
          "encode": {
            "enter": {
              "x": {"field": "x2", "offset": -5},
              "y": {"field": "y", "offset": {"field": "height", "mult": 0.5}},
              "fill": [
                {"test": "contrast('white', datum.fill) > contrast('black', datum.fill)", "value": "white"},
                {"value": "black"}
              ],
              "align": {"value": "right"},
              "baseline": {"value": "middle"},
              "text": {"field": "datum.value"}
            }
          }
        }
      ]
    }
  ]
}\nGrouped Bar Chart Example\nThis grouped bar chart facets the data into groups, then creates a bar chart for each sub-group.\nView Source
  Export PNG
  Export SVG\nView Source
  Export PNG
  Export SVG\nView in Online Vega Editor\nView in Online Vega Editor\nVega JSON Specification <>\n{
  "$schema": "https://vega.github.io/schema/vega/v5.json",
  "description": "A basic grouped bar chart example.",
  "width": 300,
  "height": 240,
  "padding": 5,

  "data": [
    {
      "name": "table",
      "values": [
        {"category":"A", "position":0, "value":0.1},
        {"category":"A", "position":1, "value":0.6},
        {"category":"A", "position":2, "value":0.9},
        {"category":"A", "position":3, "value":0.4},
        {"category":"B", "position":0, "value":0.7},
        {"category":"B", "position":1, "value":0.2},
        {"category":"B", "position":2, "value":1.1},
        {"category":"B", "position":3, "value":0.8},
        {"category":"C", "position":0, "value":0.6},
        {"category":"C", "position":1, "value":0.1},
        {"category":"C", "position":2, "value":0.2},
        {"category":"C", "position":3, "value":0.7}
      ]
    }
  ],

  "scales": [
    {
      "name": "yscale",
      "type": "band",
      "domain": {"data": "table", "field": "category"},
      "range": "height",
      "padding": 0.2
    },
    {
      "name": "xscale",
      "type": "linear",
      "domain": {"data": "table", "field": "value"},
      "range": "width",
      "round": true,
      "zero": true,
      "nice": true
    },
    {
      "name": "color",
      "type": "ordinal",
      "domain": {"data": "table", "field": "position"},
      "range": {"scheme": "category20"}
    }
  ],

  "axes": [
    {"orient": "left", "scale": "yscale", "tickSize": 0, "labelPadding": 4, "zindex": 1},
    {"orient": "bottom", "scale": "xscale"}
  ],

  "marks": [
    {
      "type": "group",

      "from": {
        "facet": {
          "data": "table",
          "name": "facet",
          "groupby": "category"
        }
      },

      "encode": {
        "enter": {
          "y": {"scale": "yscale", "field": "category"}
        }
      },

      "signals": [
        {"name": "height", "update": "bandwidth('yscale')"}
      ],

      "scales": [
        {
          "name": "pos",
          "type": "band",
          "range": "height",
          "domain": {"data": "facet", "field": "position"}
        }
      ],

      "marks": [
        {
          "name": "bars",
          "from": {"data": "facet"},
          "type": "rect",
          "encode": {
            "enter": {
              "y": {"scale": "pos", "field": "position"},
              "height": {"scale": "pos", "band": 1},
              "x": {"scale": "xscale", "field": "value"},
              "x2": {"scale": "xscale", "value": 0},
              "fill": {"scale": "color", "field": "position"}
            }
          }
        },
        {
          "type": "text",
          "from": {"data": "bars"},
          "encode": {
            "enter": {
              "x": {"field": "x2", "offset": -5},
              "y": {"field": "y", "offset": {"field": "height", "mult": 0.5}},
              "fill": [
                {"test": "contrast('white', datum.fill) > contrast('black', datum.fill)", "value": "white"},
                {"value": "black"}
              ],
              "align": {"value": "right"},
              "baseline": {"value": "middle"},
              "text": {"field": "datum.value"}
            }
          }
        }
      ]
    }
  ]
}\n{
  "$schema": "https://vega.github.io/schema/vega/v5.json",
  "description": "A basic grouped bar chart example.",
  "width": 300,
  "height": 240,
  "padding": 5,

  "data": [
    {
      "name": "table",
      "values": [
        {"category":"A", "position":0, "value":0.1},
        {"category":"A", "position":1, "value":0.6},
        {"category":"A", "position":2, "value":0.9},
        {"category":"A", "position":3, "value":0.4},
        {"category":"B", "position":0, "value":0.7},
        {"category":"B", "position":1, "value":0.2},
        {"category":"B", "position":2, "value":1.1},
        {"category":"B", "position":3, "value":0.8},
        {"category":"C", "position":0, "value":0.6},
        {"category":"C", "position":1, "value":0.1},
        {"category":"C", "position":2, "value":0.2},
        {"category":"C", "position":3, "value":0.7}
      ]
    }
  ],

  "scales": [
    {
      "name": "yscale",
      "type": "band",
      "domain": {"data": "table", "field": "category"},
      "range": "height",
      "padding": 0.2
    },
    {
      "name": "xscale",
      "type": "linear",
      "domain": {"data": "table", "field": "value"},
      "range": "width",
      "round": true,
      "zero": true,
      "nice": true
    },
    {
      "name": "color",
      "type": "ordinal",
      "domain": {"data": "table", "field": "position"},
      "range": {"scheme": "category20"}
    }
  ],

  "axes": [
    {"orient": "left", "scale": "yscale", "tickSize": 0, "labelPadding": 4, "zindex": 1},
    {"orient": "bottom", "scale": "xscale"}
  ],

  "marks": [
    {
      "type": "group",

      "from": {
        "facet": {
          "data": "table",
          "name": "facet",
          "groupby": "category"
        }
      },

      "encode": {
        "enter": {
          "y": {"scale": "yscale", "field": "category"}
        }
      },

      "signals": [
        {"name": "height", "update": "bandwidth('yscale')"}
      ],

      "scales": [
        {
          "name": "pos",
          "type": "band",
          "range": "height",
          "domain": {"data": "facet", "field": "position"}
        }
      ],

      "marks": [
        {
          "name": "bars",
          "from": {"data": "facet"},
          "type": "rect",
          "encode": {
            "enter": {
              "y": {"scale": "pos", "field": "position"},
              "height": {"scale": "pos", "band": 1},
              "x": {"scale": "xscale", "field": "value"},
              "x2": {"scale": "xscale", "value": 0},
              "fill": {"scale": "color", "field": "position"}
            }
          }
        },
        {
          "type": "text",
          "from": {"data": "bars"},
          "encode": {
            "enter": {
              "x": {"field": "x2", "offset": -5},
              "y": {"field": "y", "offset": {"field": "height", "mult": 0.5}},
              "fill": [
                {"test": "contrast('white', datum.fill) > contrast('black', datum.fill)", "value": "white"},
                {"value": "black"}
              ],
              "align": {"value": "right"},
              "baseline": {"value": "middle"},
              "text": {"field": "datum.value"}
            }
          }
        }
      ]
    }
  ]
}\n"https://vega.github.io/schema/vega/v5.json"\n"A basic grouped bar chart example."\n"bandwidth('yscale')"\n"contrast('white', datum.fill) > contrast('black', datum.fill)"\n\n\nVega
            
              Vega-Lite
              Altair
              Vega-Lite API
            
          
          
            
              Examples
              Tutorials
              Documentation
              Usage
              About
            
            
              GitHub
              Try Online
            
          
        
      

      
        

  
  
    Nested Bar Chart Example
    This nested bar chart depicts aggregated values across multiple categories. The input data is subdivided according to two fields (with uneven category membership). Each sub-group is then aggregated to show the average value of a third, quantitative field.




  
  View Source
  Export PNG
  Export SVG






  View in Online Vega Editor


Vega JSON Specification <>

{
  "$schema": "https://vega.github.io/schema/vega/v5.json",
  "description": "A nested bar chart example, with bars grouped by category.",
  "width": 300,
  "padding": 5,
  "autosize": "pad",

  "signals": [
    {
      "name": "rangeStep", "value": 20,
      "bind": {"input": "range", "min": 5, "max": 50, "step": 1}
    },
    {
      "name": "innerPadding", "value": 0.1,
      "bind": {"input": "range", "min": 0, "max": 0.7, "step": 0.01}
    },
    {
      "name": "outerPadding", "value": 0.2,
      "bind": {"input": "range", "min": 0, "max": 0.4, "step": 0.01}
    },
    {
      "name": "height",
      "update": "trellisExtent[1]"
    }
  ],

  "data": [
    {
      "name": "tuples",
      "values": [
        {"a": 0, "b": "a", "c": 6.3},
        {"a": 0, "b": "a", "c": 4.2},
        {"a": 0, "b": "b", "c": 6.8},
        {"a": 0, "b": "c", "c": 5.1},
        {"a": 1, "b": "b", "c": 4.4},
        {"a": 2, "b": "b", "c": 3.5},
        {"a": 2, "b": "c", "c": 6.2}
      ],
      "transform": [
        {
          "type": "aggregate",
          "groupby": ["a", "b"],
          "fields": ["c"],
          "ops": ["average"],
          "as": ["c"]
        }
      ]
    },
    {
      "name": "trellis",
      "source": "tuples",
      "transform": [
        {
          "type": "aggregate",
          "groupby": ["a"]
        },
        {
          "type": "formula", "as": "span",
          "expr": "rangeStep * bandspace(datum.count, innerPadding, outerPadding)"
        },
        {
          "type": "stack",
          "field": "span"
        },
        {
          "type": "extent",
          "field": "y1",
          "signal": "trellisExtent"
        }
      ]
    }
  ],

  "scales": [
    {
      "name": "xscale",
      "domain": {"data": "tuples", "field": "c"},
      "nice": true,
      "zero": true,
      "round": true,
      "range": "width"
    },
    {
      "name": "color",
      "type": "ordinal",
      "range": "category",
      "domain": {"data": "trellis", "field": "a"}
    }
  ],

  "axes": [
    { "orient": "bottom", "scale": "xscale", "domain": true }
  ],

  "marks": [
    {
      "type": "group",

      "from": {
        "data": "trellis",
        "facet": {
          "name": "faceted_tuples",
          "data": "tuples",
          "groupby": "a"
        }
      },

      "encode": {
        "enter": {
          "x": {"value": 0},
          "width": {"signal": "width"}
        },
        "update": {
          "y": {"field": "y0"},
          "y2": {"field": "y1"}
        }
      },

      "scales": [
        {
          "name": "yscale",
          "type": "band",
          "paddingInner": {"signal": "innerPadding"},
          "paddingOuter": {"signal": "outerPadding"},
          "round": true,
          "domain": {"data": "faceted_tuples", "field": "b"},
          "range": {"step": {"signal": "rangeStep"}}
        }
      ],

      "axes": [
        { "orient": "left", "scale": "yscale",
          "ticks": false, "domain": false, "labelPadding": 4 }
      ],

      "marks": [
        {
          "type": "rect",
          "from": {"data": "faceted_tuples"},
          "encode": {
            "enter": {
              "x": {"value": 0},
              "x2": {"scale": "xscale", "field": "c"},
              "fill": {"scale": "color", "field": "a"},
              "strokeWidth": {"value": 2}
            },
            "update": {
              "y": {"scale": "yscale", "field": "b"},
              "height": {"scale": "yscale", "band": 1},
              "stroke": {"value": null},
              "zindex": {"value": 0}
            },
            "hover": {
              "stroke": {"value": "firebrick"},
              "zindex": {"value": 1}
            }
          }
        }
      ]
    }
  ]
}\nVega
            
              Vega-Lite
              Altair
              Vega-Lite API\nVega-Lite
              Altair
              Vega-Lite API\nExamples
              Tutorials
              Documentation
              Usage
              About
            
            
              GitHub
              Try Online\nExamples
              Tutorials
              Documentation
              Usage
              About\nGitHub
              Try Online\nNested Bar Chart Example
    This nested bar chart depicts aggregated values across multiple categories. The input data is subdivided according to two fields (with uneven category membership). Each sub-group is then aggregated to show the average value of a third, quantitative field.




  
  View Source
  Export PNG
  Export SVG






  View in Online Vega Editor


Vega JSON Specification <>

{
  "$schema": "https://vega.github.io/schema/vega/v5.json",
  "description": "A nested bar chart example, with bars grouped by category.",
  "width": 300,
  "padding": 5,
  "autosize": "pad",

  "signals": [
    {
      "name": "rangeStep", "value": 20,
      "bind": {"input": "range", "min": 5, "max": 50, "step": 1}
    },
    {
      "name": "innerPadding", "value": 0.1,
      "bind": {"input": "range", "min": 0, "max": 0.7, "step": 0.01}
    },
    {
      "name": "outerPadding", "value": 0.2,
      "bind": {"input": "range", "min": 0, "max": 0.4, "step": 0.01}
    },
    {
      "name": "height",
      "update": "trellisExtent[1]"
    }
  ],

  "data": [
    {
      "name": "tuples",
      "values": [
        {"a": 0, "b": "a", "c": 6.3},
        {"a": 0, "b": "a", "c": 4.2},
        {"a": 0, "b": "b", "c": 6.8},
        {"a": 0, "b": "c", "c": 5.1},
        {"a": 1, "b": "b", "c": 4.4},
        {"a": 2, "b": "b", "c": 3.5},
        {"a": 2, "b": "c", "c": 6.2}
      ],
      "transform": [
        {
          "type": "aggregate",
          "groupby": ["a", "b"],
          "fields": ["c"],
          "ops": ["average"],
          "as": ["c"]
        }
      ]
    },
    {
      "name": "trellis",
      "source": "tuples",
      "transform": [
        {
          "type": "aggregate",
          "groupby": ["a"]
        },
        {
          "type": "formula", "as": "span",
          "expr": "rangeStep * bandspace(datum.count, innerPadding, outerPadding)"
        },
        {
          "type": "stack",
          "field": "span"
        },
        {
          "type": "extent",
          "field": "y1",
          "signal": "trellisExtent"
        }
      ]
    }
  ],

  "scales": [
    {
      "name": "xscale",
      "domain": {"data": "tuples", "field": "c"},
      "nice": true,
      "zero": true,
      "round": true,
      "range": "width"
    },
    {
      "name": "color",
      "type": "ordinal",
      "range": "category",
      "domain": {"data": "trellis", "field": "a"}
    }
  ],

  "axes": [
    { "orient": "bottom", "scale": "xscale", "domain": true }
  ],

  "marks": [
    {
      "type": "group",

      "from": {
        "data": "trellis",
        "facet": {
          "name": "faceted_tuples",
          "data": "tuples",
          "groupby": "a"
        }
      },

      "encode": {
        "enter": {
          "x": {"value": 0},
          "width": {"signal": "width"}
        },
        "update": {
          "y": {"field": "y0"},
          "y2": {"field": "y1"}
        }
      },

      "scales": [
        {
          "name": "yscale",
          "type": "band",
          "paddingInner": {"signal": "innerPadding"},
          "paddingOuter": {"signal": "outerPadding"},
          "round": true,
          "domain": {"data": "faceted_tuples", "field": "b"},
          "range": {"step": {"signal": "rangeStep"}}
        }
      ],

      "axes": [
        { "orient": "left", "scale": "yscale",
          "ticks": false, "domain": false, "labelPadding": 4 }
      ],

      "marks": [
        {
          "type": "rect",
          "from": {"data": "faceted_tuples"},
          "encode": {
            "enter": {
              "x": {"value": 0},
              "x2": {"scale": "xscale", "field": "c"},
              "fill": {"scale": "color", "field": "a"},
              "strokeWidth": {"value": 2}
            },
            "update": {
              "y": {"scale": "yscale", "field": "b"},
              "height": {"scale": "yscale", "band": 1},
              "stroke": {"value": null},
              "zindex": {"value": 0}
            },
            "hover": {
              "stroke": {"value": "firebrick"},
              "zindex": {"value": 1}
            }
          }
        }
      ]
    }
  ]
}\nNested Bar Chart Example\nThis nested bar chart depicts aggregated values across multiple categories. The input data is subdivided according to two fields (with uneven category membership). Each sub-group is then aggregated to show the average value of a third, quantitative field.\nView Source
  Export PNG
  Export SVG\nView Source
  Export PNG
  Export SVG\nView in Online Vega Editor\nView in Online Vega Editor\nVega JSON Specification <>\n{
  "$schema": "https://vega.github.io/schema/vega/v5.json",
  "description": "A nested bar chart example, with bars grouped by category.",
  "width": 300,
  "padding": 5,
  "autosize": "pad",

  "signals": [
    {
      "name": "rangeStep", "value": 20,
      "bind": {"input": "range", "min": 5, "max": 50, "step": 1}
    },
    {
      "name": "innerPadding", "value": 0.1,
      "bind": {"input": "range", "min": 0, "max": 0.7, "step": 0.01}
    },
    {
      "name": "outerPadding", "value": 0.2,
      "bind": {"input": "range", "min": 0, "max": 0.4, "step": 0.01}
    },
    {
      "name": "height",
      "update": "trellisExtent[1]"
    }
  ],

  "data": [
    {
      "name": "tuples",
      "values": [
        {"a": 0, "b": "a", "c": 6.3},
        {"a": 0, "b": "a", "c": 4.2},
        {"a": 0, "b": "b", "c": 6.8},
        {"a": 0, "b": "c", "c": 5.1},
        {"a": 1, "b": "b", "c": 4.4},
        {"a": 2, "b": "b", "c": 3.5},
        {"a": 2, "b": "c", "c": 6.2}
      ],
      "transform": [
        {
          "type": "aggregate",
          "groupby": ["a", "b"],
          "fields": ["c"],
          "ops": ["average"],
          "as": ["c"]
        }
      ]
    },
    {
      "name": "trellis",
      "source": "tuples",
      "transform": [
        {
          "type": "aggregate",
          "groupby": ["a"]
        },
        {
          "type": "formula", "as": "span",
          "expr": "rangeStep * bandspace(datum.count, innerPadding, outerPadding)"
        },
        {
          "type": "stack",
          "field": "span"
        },
        {
          "type": "extent",
          "field": "y1",
          "signal": "trellisExtent"
        }
      ]
    }
  ],

  "scales": [
    {
      "name": "xscale",
      "domain": {"data": "tuples", "field": "c"},
      "nice": true,
      "zero": true,
      "round": true,
      "range": "width"
    },
    {
      "name": "color",
      "type": "ordinal",
      "range": "category",
      "domain": {"data": "trellis", "field": "a"}
    }
  ],

  "axes": [
    { "orient": "bottom", "scale": "xscale", "domain": true }
  ],

  "marks": [
    {
      "type": "group",

      "from": {
        "data": "trellis",
        "facet": {
          "name": "faceted_tuples",
          "data": "tuples",
          "groupby": "a"
        }
      },

      "encode": {
        "enter": {
          "x": {"value": 0},
          "width": {"signal": "width"}
        },
        "update": {
          "y": {"field": "y0"},
          "y2": {"field": "y1"}
        }
      },

      "scales": [
        {
          "name": "yscale",
          "type": "band",
          "paddingInner": {"signal": "innerPadding"},
          "paddingOuter": {"signal": "outerPadding"},
          "round": true,
          "domain": {"data": "faceted_tuples", "field": "b"},
          "range": {"step": {"signal": "rangeStep"}}
        }
      ],

      "axes": [
        { "orient": "left", "scale": "yscale",
          "ticks": false, "domain": false, "labelPadding": 4 }
      ],

      "marks": [
        {
          "type": "rect",
          "from": {"data": "faceted_tuples"},
          "encode": {
            "enter": {
              "x": {"value": 0},
              "x2": {"scale": "xscale", "field": "c"},
              "fill": {"scale": "color", "field": "a"},
              "strokeWidth": {"value": 2}
            },
            "update": {
              "y": {"scale": "yscale", "field": "b"},
              "height": {"scale": "yscale", "band": 1},
              "stroke": {"value": null},
              "zindex": {"value": 0}
            },
            "hover": {
              "stroke": {"value": "firebrick"},
              "zindex": {"value": 1}
            }
          }
        }
      ]
    }
  ]
}\n{
  "$schema": "https://vega.github.io/schema/vega/v5.json",
  "description": "A nested bar chart example, with bars grouped by category.",
  "width": 300,
  "padding": 5,
  "autosize": "pad",

  "signals": [
    {
      "name": "rangeStep", "value": 20,
      "bind": {"input": "range", "min": 5, "max": 50, "step": 1}
    },
    {
      "name": "innerPadding", "value": 0.1,
      "bind": {"input": "range", "min": 0, "max": 0.7, "step": 0.01}
    },
    {
      "name": "outerPadding", "value": 0.2,
      "bind": {"input": "range", "min": 0, "max": 0.4, "step": 0.01}
    },
    {
      "name": "height",
      "update": "trellisExtent[1]"
    }
  ],

  "data": [
    {
      "name": "tuples",
      "values": [
        {"a": 0, "b": "a", "c": 6.3},
        {"a": 0, "b": "a", "c": 4.2},
        {"a": 0, "b": "b", "c": 6.8},
        {"a": 0, "b": "c", "c": 5.1},
        {"a": 1, "b": "b", "c": 4.4},
        {"a": 2, "b": "b", "c": 3.5},
        {"a": 2, "b": "c", "c": 6.2}
      ],
      "transform": [
        {
          "type": "aggregate",
          "groupby": ["a", "b"],
          "fields": ["c"],
          "ops": ["average"],
          "as": ["c"]
        }
      ]
    },
    {
      "name": "trellis",
      "source": "tuples",
      "transform": [
        {
          "type": "aggregate",
          "groupby": ["a"]
        },
        {
          "type": "formula", "as": "span",
          "expr": "rangeStep * bandspace(datum.count, innerPadding, outerPadding)"
        },
        {
          "type": "stack",
          "field": "span"
        },
        {
          "type": "extent",
          "field": "y1",
          "signal": "trellisExtent"
        }
      ]
    }
  ],

  "scales": [
    {
      "name": "xscale",
      "domain": {"data": "tuples", "field": "c"},
      "nice": true,
      "zero": true,
      "round": true,
      "range": "width"
    },
    {
      "name": "color",
      "type": "ordinal",
      "range": "category",
      "domain": {"data": "trellis", "field": "a"}
    }
  ],

  "axes": [
    { "orient": "bottom", "scale": "xscale", "domain": true }
  ],

  "marks": [
    {
      "type": "group",

      "from": {
        "data": "trellis",
        "facet": {
          "name": "faceted_tuples",
          "data": "tuples",
          "groupby": "a"
        }
      },

      "encode": {
        "enter": {
          "x": {"value": 0},
          "width": {"signal": "width"}
        },
        "update": {
          "y": {"field": "y0"},
          "y2": {"field": "y1"}
        }
      },

      "scales": [
        {
          "name": "yscale",
          "type": "band",
          "paddingInner": {"signal": "innerPadding"},
          "paddingOuter": {"signal": "outerPadding"},
          "round": true,
          "domain": {"data": "faceted_tuples", "field": "b"},
          "range": {"step": {"signal": "rangeStep"}}
        }
      ],

      "axes": [
        { "orient": "left", "scale": "yscale",
          "ticks": false, "domain": false, "labelPadding": 4 }
      ],

      "marks": [
        {
          "type": "rect",
          "from": {"data": "faceted_tuples"},
          "encode": {
            "enter": {
              "x": {"value": 0},
              "x2": {"scale": "xscale", "field": "c"},
              "fill": {"scale": "color", "field": "a"},
              "strokeWidth": {"value": 2}
            },
            "update": {
              "y": {"scale": "yscale", "field": "b"},
              "height": {"scale": "yscale", "band": 1},
              "stroke": {"value": null},
              "zindex": {"value": 0}
            },
            "hover": {
              "stroke": {"value": "firebrick"},
              "zindex": {"value": 1}
            }
          }
        }
      ]
    }
  ]
}\n"https://vega.github.io/schema/vega/v5.json"\n"A nested bar chart example, with bars grouped by category."\n"rangeStep * bandspace(datum.count, innerPadding, outerPadding)"\n\n\nVega
            
              Vega-Lite
              Altair
              Vega-Lite API
            
          
          
            
              Examples
              Tutorials
              Documentation
              Usage
              About
            
            
              GitHub
              Try Online
            
          
        
      

      
        

  
  
    Population Pyramid Example
    A population pyramid shows the distribution of age groups within a population. This example shows males and females across 150 years of U.S. census data. Drag the slider to see the U.S. population change over time (but watch out for missing data in 1890!).




  
  View Source
  Export PNG
  Export SVG






  View in Online Vega Editor


Vega JSON Specification <>

{
  "$schema": "https://vega.github.io/schema/vega/v5.json",
  "description": "A population pyramid showing U.S. demographics from 1850 to 2000.",
  "height": 400,
  "padding": 5,

  "signals": [
    { "name": "chartWidth", "value": 300 },
    { "name": "chartPad", "value": 20 },
    { "name": "width", "update": "2 * chartWidth + chartPad" },
    { "name": "year", "value": 2000,
      "bind": {"input": "range", "min": 1850, "max": 2000, "step": 10} }
  ],

  "data": [
    {
      "name": "population",
      "url": "data/population.json"
    },
    {
      "name": "popYear",
      "source": "population",
      "transform": [
        {"type": "filter", "expr": "datum.year == year"}
      ]
    },
    {
      "name": "males",
      "source": "popYear",
      "transform": [
        {"type": "filter", "expr": "datum.sex == 1"}
      ]
    },
    {
      "name": "females",
      "source": "popYear",
      "transform": [
        {"type": "filter", "expr": "datum.sex == 2"}
      ]
    },
    {
      "name": "ageGroups",
      "source": "population",
      "transform": [
        { "type": "aggregate", "groupby": ["age"] }
      ]
    }
  ],

  "scales": [
    {
      "name": "y",
      "type": "band",
      "range": [{"signal": "height"}, 0],
      "round": true,
      "domain": {"data": "ageGroups", "field": "age"}
    },
    {
      "name": "c",
      "type": "ordinal",
      "domain": [1, 2],
      "range": ["#d5855a", "#6c4e97"]
    }
  ],

  "marks": [
    {
      "type": "text",
      "interactive": false,
      "from": {"data": "ageGroups"},
      "encode": {
        "enter": {
          "x": {"signal": "chartWidth + chartPad / 2"},
          "y": {"scale": "y", "field": "age", "band": 0.5},
          "text": {"field": "age"},
          "baseline": {"value": "middle"},
          "align": {"value": "center"},
          "fill": {"value": "#000"}
        }
      }
    },
    {
      "type": "group",

      "encode": {
        "update": {
          "x": {"value": 0},
          "height": {"signal": "height"}
        }
      },

      "scales": [
        {
          "name": "x",
          "type": "linear",
          "range": [{"signal": "chartWidth"}, 0],
          "nice": true, "zero": true,
          "domain": {"data": "population", "field": "people"}
        }
      ],

      "axes": [
        {"orient": "bottom", "scale": "x", "format": "s", "title": "Females"}
      ],

      "marks": [
        {
          "type": "rect",
          "from": {"data": "females"},
          "encode": {
            "enter": {
              "x": {"scale": "x", "field": "people"},
              "x2": {"scale": "x", "value": 0},
              "y": {"scale": "y", "field": "age"},
              "height": {"scale": "y", "band": 1, "offset": -1},
              "fillOpacity": {"value": 0.6},
              "fill": {"scale": "c", "field": "sex"}
            }
          }
        }
      ]
    },
    {
      "type": "group",

      "encode": {
        "update": {
          "x": {"signal": "chartWidth + chartPad"},
          "height": {"signal": "height"}
        }
      },

      "scales": [
        {
          "name": "x",
          "type": "linear",
          "range": [0, {"signal": "chartWidth"}],
          "nice": true, "zero": true,
          "domain": {"data": "population", "field": "people"}
        }
      ],

      "axes": [
        {"orient": "bottom", "scale": "x", "format": "s", "title": "Males"}
      ],

      "marks": [
        {
          "type": "rect",
          "from": {"data": "males"},
          "encode": {
            "enter": {
              "x": {"scale": "x", "field": "people"},
              "x2": {"scale": "x", "value": 0},
              "y": {"scale": "y", "field": "age"},
              "height": {"scale": "y", "band": 1, "offset": -1},
              "fillOpacity": {"value": 0.6},
              "fill": {"scale": "c", "field": "sex"}
            }
          }
        }
      ]
    }
  ]
}\nVega
            
              Vega-Lite
              Altair
              Vega-Lite API\nVega-Lite
              Altair
              Vega-Lite API\nExamples
              Tutorials
              Documentation
              Usage
              About
            
            
              GitHub
              Try Online\nExamples
              Tutorials
              Documentation
              Usage
              About\nGitHub
              Try Online\nPopulation Pyramid Example
    A population pyramid shows the distribution of age groups within a population. This example shows males and females across 150 years of U.S. census data. Drag the slider to see the U.S. population change over time (but watch out for missing data in 1890!).




  
  View Source
  Export PNG
  Export SVG






  View in Online Vega Editor


Vega JSON Specification <>

{
  "$schema": "https://vega.github.io/schema/vega/v5.json",
  "description": "A population pyramid showing U.S. demographics from 1850 to 2000.",
  "height": 400,
  "padding": 5,

  "signals": [
    { "name": "chartWidth", "value": 300 },
    { "name": "chartPad", "value": 20 },
    { "name": "width", "update": "2 * chartWidth + chartPad" },
    { "name": "year", "value": 2000,
      "bind": {"input": "range", "min": 1850, "max": 2000, "step": 10} }
  ],

  "data": [
    {
      "name": "population",
      "url": "data/population.json"
    },
    {
      "name": "popYear",
      "source": "population",
      "transform": [
        {"type": "filter", "expr": "datum.year == year"}
      ]
    },
    {
      "name": "males",
      "source": "popYear",
      "transform": [
        {"type": "filter", "expr": "datum.sex == 1"}
      ]
    },
    {
      "name": "females",
      "source": "popYear",
      "transform": [
        {"type": "filter", "expr": "datum.sex == 2"}
      ]
    },
    {
      "name": "ageGroups",
      "source": "population",
      "transform": [
        { "type": "aggregate", "groupby": ["age"] }
      ]
    }
  ],

  "scales": [
    {
      "name": "y",
      "type": "band",
      "range": [{"signal": "height"}, 0],
      "round": true,
      "domain": {"data": "ageGroups", "field": "age"}
    },
    {
      "name": "c",
      "type": "ordinal",
      "domain": [1, 2],
      "range": ["#d5855a", "#6c4e97"]
    }
  ],

  "marks": [
    {
      "type": "text",
      "interactive": false,
      "from": {"data": "ageGroups"},
      "encode": {
        "enter": {
          "x": {"signal": "chartWidth + chartPad / 2"},
          "y": {"scale": "y", "field": "age", "band": 0.5},
          "text": {"field": "age"},
          "baseline": {"value": "middle"},
          "align": {"value": "center"},
          "fill": {"value": "#000"}
        }
      }
    },
    {
      "type": "group",

      "encode": {
        "update": {
          "x": {"value": 0},
          "height": {"signal": "height"}
        }
      },

      "scales": [
        {
          "name": "x",
          "type": "linear",
          "range": [{"signal": "chartWidth"}, 0],
          "nice": true, "zero": true,
          "domain": {"data": "population", "field": "people"}
        }
      ],

      "axes": [
        {"orient": "bottom", "scale": "x", "format": "s", "title": "Females"}
      ],

      "marks": [
        {
          "type": "rect",
          "from": {"data": "females"},
          "encode": {
            "enter": {
              "x": {"scale": "x", "field": "people"},
              "x2": {"scale": "x", "value": 0},
              "y": {"scale": "y", "field": "age"},
              "height": {"scale": "y", "band": 1, "offset": -1},
              "fillOpacity": {"value": 0.6},
              "fill": {"scale": "c", "field": "sex"}
            }
          }
        }
      ]
    },
    {
      "type": "group",

      "encode": {
        "update": {
          "x": {"signal": "chartWidth + chartPad"},
          "height": {"signal": "height"}
        }
      },

      "scales": [
        {
          "name": "x",
          "type": "linear",
          "range": [0, {"signal": "chartWidth"}],
          "nice": true, "zero": true,
          "domain": {"data": "population", "field": "people"}
        }
      ],

      "axes": [
        {"orient": "bottom", "scale": "x", "format": "s", "title": "Males"}
      ],

      "marks": [
        {
          "type": "rect",
          "from": {"data": "males"},
          "encode": {
            "enter": {
              "x": {"scale": "x", "field": "people"},
              "x2": {"scale": "x", "value": 0},
              "y": {"scale": "y", "field": "age"},
              "height": {"scale": "y", "band": 1, "offset": -1},
              "fillOpacity": {"value": 0.6},
              "fill": {"scale": "c", "field": "sex"}
            }
          }
        }
      ]
    }
  ]
}\nPopulation Pyramid Example\nA population pyramid shows the distribution of age groups within a population. This example shows males and females across 150 years of U.S. census data. Drag the slider to see the U.S. population change over time (but watch out for missing data in 1890!).\nView Source
  Export PNG
  Export SVG\nView Source
  Export PNG
  Export SVG\nView in Online Vega Editor\nView in Online Vega Editor\nVega JSON Specification <>\n{
  "$schema": "https://vega.github.io/schema/vega/v5.json",
  "description": "A population pyramid showing U.S. demographics from 1850 to 2000.",
  "height": 400,
  "padding": 5,

  "signals": [
    { "name": "chartWidth", "value": 300 },
    { "name": "chartPad", "value": 20 },
    { "name": "width", "update": "2 * chartWidth + chartPad" },
    { "name": "year", "value": 2000,
      "bind": {"input": "range", "min": 1850, "max": 2000, "step": 10} }
  ],

  "data": [
    {
      "name": "population",
      "url": "data/population.json"
    },
    {
      "name": "popYear",
      "source": "population",
      "transform": [
        {"type": "filter", "expr": "datum.year == year"}
      ]
    },
    {
      "name": "males",
      "source": "popYear",
      "transform": [
        {"type": "filter", "expr": "datum.sex == 1"}
      ]
    },
    {
      "name": "females",
      "source": "popYear",
      "transform": [
        {"type": "filter", "expr": "datum.sex == 2"}
      ]
    },
    {
      "name": "ageGroups",
      "source": "population",
      "transform": [
        { "type": "aggregate", "groupby": ["age"] }
      ]
    }
  ],

  "scales": [
    {
      "name": "y",
      "type": "band",
      "range": [{"signal": "height"}, 0],
      "round": true,
      "domain": {"data": "ageGroups", "field": "age"}
    },
    {
      "name": "c",
      "type": "ordinal",
      "domain": [1, 2],
      "range": ["#d5855a", "#6c4e97"]
    }
  ],

  "marks": [
    {
      "type": "text",
      "interactive": false,
      "from": {"data": "ageGroups"},
      "encode": {
        "enter": {
          "x": {"signal": "chartWidth + chartPad / 2"},
          "y": {"scale": "y", "field": "age", "band": 0.5},
          "text": {"field": "age"},
          "baseline": {"value": "middle"},
          "align": {"value": "center"},
          "fill": {"value": "#000"}
        }
      }
    },
    {
      "type": "group",

      "encode": {
        "update": {
          "x": {"value": 0},
          "height": {"signal": "height"}
        }
      },

      "scales": [
        {
          "name": "x",
          "type": "linear",
          "range": [{"signal": "chartWidth"}, 0],
          "nice": true, "zero": true,
          "domain": {"data": "population", "field": "people"}
        }
      ],

      "axes": [
        {"orient": "bottom", "scale": "x", "format": "s", "title": "Females"}
      ],

      "marks": [
        {
          "type": "rect",
          "from": {"data": "females"},
          "encode": {
            "enter": {
              "x": {"scale": "x", "field": "people"},
              "x2": {"scale": "x", "value": 0},
              "y": {"scale": "y", "field": "age"},
              "height": {"scale": "y", "band": 1, "offset": -1},
              "fillOpacity": {"value": 0.6},
              "fill": {"scale": "c", "field": "sex"}
            }
          }
        }
      ]
    },
    {
      "type": "group",

      "encode": {
        "update": {
          "x": {"signal": "chartWidth + chartPad"},
          "height": {"signal": "height"}
        }
      },

      "scales": [
        {
          "name": "x",
          "type": "linear",
          "range": [0, {"signal": "chartWidth"}],
          "nice": true, "zero": true,
          "domain": {"data": "population", "field": "people"}
        }
      ],

      "axes": [
        {"orient": "bottom", "scale": "x", "format": "s", "title": "Males"}
      ],

      "marks": [
        {
          "type": "rect",
          "from": {"data": "males"},
          "encode": {
            "enter": {
              "x": {"scale": "x", "field": "people"},
              "x2": {"scale": "x", "value": 0},
              "y": {"scale": "y", "field": "age"},
              "height": {"scale": "y", "band": 1, "offset": -1},
              "fillOpacity": {"value": 0.6},
              "fill": {"scale": "c", "field": "sex"}
            }
          }
        }
      ]
    }
  ]
}\n{
  "$schema": "https://vega.github.io/schema/vega/v5.json",
  "description": "A population pyramid showing U.S. demographics from 1850 to 2000.",
  "height": 400,
  "padding": 5,

  "signals": [
    { "name": "chartWidth", "value": 300 },
    { "name": "chartPad", "value": 20 },
    { "name": "width", "update": "2 * chartWidth + chartPad" },
    { "name": "year", "value": 2000,
      "bind": {"input": "range", "min": 1850, "max": 2000, "step": 10} }
  ],

  "data": [
    {
      "name": "population",
      "url": "data/population.json"
    },
    {
      "name": "popYear",
      "source": "population",
      "transform": [
        {"type": "filter", "expr": "datum.year == year"}
      ]
    },
    {
      "name": "males",
      "source": "popYear",
      "transform": [
        {"type": "filter", "expr": "datum.sex == 1"}
      ]
    },
    {
      "name": "females",
      "source": "popYear",
      "transform": [
        {"type": "filter", "expr": "datum.sex == 2"}
      ]
    },
    {
      "name": "ageGroups",
      "source": "population",
      "transform": [
        { "type": "aggregate", "groupby": ["age"] }
      ]
    }
  ],

  "scales": [
    {
      "name": "y",
      "type": "band",
      "range": [{"signal": "height"}, 0],
      "round": true,
      "domain": {"data": "ageGroups", "field": "age"}
    },
    {
      "name": "c",
      "type": "ordinal",
      "domain": [1, 2],
      "range": ["#d5855a", "#6c4e97"]
    }
  ],

  "marks": [
    {
      "type": "text",
      "interactive": false,
      "from": {"data": "ageGroups"},
      "encode": {
        "enter": {
          "x": {"signal": "chartWidth + chartPad / 2"},
          "y": {"scale": "y", "field": "age", "band": 0.5},
          "text": {"field": "age"},
          "baseline": {"value": "middle"},
          "align": {"value": "center"},
          "fill": {"value": "#000"}
        }
      }
    },
    {
      "type": "group",

      "encode": {
        "update": {
          "x": {"value": 0},
          "height": {"signal": "height"}
        }
      },

      "scales": [
        {
          "name": "x",
          "type": "linear",
          "range": [{"signal": "chartWidth"}, 0],
          "nice": true, "zero": true,
          "domain": {"data": "population", "field": "people"}
        }
      ],

      "axes": [
        {"orient": "bottom", "scale": "x", "format": "s", "title": "Females"}
      ],

      "marks": [
        {
          "type": "rect",
          "from": {"data": "females"},
          "encode": {
            "enter": {
              "x": {"scale": "x", "field": "people"},
              "x2": {"scale": "x", "value": 0},
              "y": {"scale": "y", "field": "age"},
              "height": {"scale": "y", "band": 1, "offset": -1},
              "fillOpacity": {"value": 0.6},
              "fill": {"scale": "c", "field": "sex"}
            }
          }
        }
      ]
    },
    {
      "type": "group",

      "encode": {
        "update": {
          "x": {"signal": "chartWidth + chartPad"},
          "height": {"signal": "height"}
        }
      },

      "scales": [
        {
          "name": "x",
          "type": "linear",
          "range": [0, {"signal": "chartWidth"}],
          "nice": true, "zero": true,
          "domain": {"data": "population", "field": "people"}
        }
      ],

      "axes": [
        {"orient": "bottom", "scale": "x", "format": "s", "title": "Males"}
      ],

      "marks": [
        {
          "type": "rect",
          "from": {"data": "males"},
          "encode": {
            "enter": {
              "x": {"scale": "x", "field": "people"},
              "x2": {"scale": "x", "value": 0},
              "y": {"scale": "y", "field": "age"},
              "height": {"scale": "y", "band": 1, "offset": -1},
              "fillOpacity": {"value": 0.6},
              "fill": {"scale": "c", "field": "sex"}
            }
          }
        }
      ]
    }
  ]
}\n"https://vega.github.io/schema/vega/v5.json"\n"A population pyramid showing U.S. demographics from 1850 to 2000."\n"2 * chartWidth + chartPad"\n"data/population.json"\n"chartWidth + chartPad / 2"\n"chartWidth + chartPad"\n\n\nVega
            
              Vega-Lite
              Altair
              Vega-Lite API
            
          
          
            
              Examples
              Tutorials
              Documentation
              Usage
              About
            
            
              GitHub
              Try Online
            
          
        
      

      
        

  
  
    Line Chart Example
    Line charts are used to depict changing values, with line slopes conveying rates of change. Different interpolators change the curvature of the line. Options such as cardinal or Catmull-Rom interpolation can produce pleasing curves, but can also “hallucinate” maximum or minimum values that do not exist in the data. Use monotone interpolation for smooth curves that faithfully preserve monotonicity.




  
  View Source
  Export PNG
  Export SVG






  View in Online Vega Editor


Vega JSON Specification <>

{
  "$schema": "https://vega.github.io/schema/vega/v5.json",
  "description": "A basic line chart example.",
  "width": 500,
  "height": 200,
  "padding": 5,

  "signals": [
    {
      "name": "interpolate",
      "value": "linear",
      "bind": {
        "input": "select",
        "options": [
          "basis",
          "cardinal",
          "catmull-rom",
          "linear",
          "monotone",
          "natural",
          "step",
          "step-after",
          "step-before"
        ]
      }
    }
  ],

  "data": [
    {
      "name": "table",
      "values": [
        {"x": 0, "y": 28, "c":0}, {"x": 0, "y": 20, "c":1},
        {"x": 1, "y": 43, "c":0}, {"x": 1, "y": 35, "c":1},
        {"x": 2, "y": 81, "c":0}, {"x": 2, "y": 10, "c":1},
        {"x": 3, "y": 19, "c":0}, {"x": 3, "y": 15, "c":1},
        {"x": 4, "y": 52, "c":0}, {"x": 4, "y": 48, "c":1},
        {"x": 5, "y": 24, "c":0}, {"x": 5, "y": 28, "c":1},
        {"x": 6, "y": 87, "c":0}, {"x": 6, "y": 66, "c":1},
        {"x": 7, "y": 17, "c":0}, {"x": 7, "y": 27, "c":1},
        {"x": 8, "y": 68, "c":0}, {"x": 8, "y": 16, "c":1},
        {"x": 9, "y": 49, "c":0}, {"x": 9, "y": 25, "c":1}
      ]
    }
  ],

  "scales": [
    {
      "name": "x",
      "type": "point",
      "range": "width",
      "domain": {"data": "table", "field": "x"}
    },
    {
      "name": "y",
      "type": "linear",
      "range": "height",
      "nice": true,
      "zero": true,
      "domain": {"data": "table", "field": "y"}
    },
    {
      "name": "color",
      "type": "ordinal",
      "range": "category",
      "domain": {"data": "table", "field": "c"}
    }
  ],

  "axes": [
    {"orient": "bottom", "scale": "x"},
    {"orient": "left", "scale": "y"}
  ],

  "marks": [
    {
      "type": "group",
      "from": {
        "facet": {
          "name": "series",
          "data": "table",
          "groupby": "c"
        }
      },
      "marks": [
        {
          "type": "line",
          "from": {"data": "series"},
          "encode": {
            "enter": {
              "x": {"scale": "x", "field": "x"},
              "y": {"scale": "y", "field": "y"},
              "stroke": {"scale": "color", "field": "c"},
              "strokeWidth": {"value": 2}
            },
            "update": {
              "interpolate": {"signal": "interpolate"},
              "strokeOpacity": {"value": 1}
            },
            "hover": {
              "strokeOpacity": {"value": 0.5}
            }
          }
        }
      ]
    }
  ]
}\nVega
            
              Vega-Lite
              Altair
              Vega-Lite API\nVega-Lite
              Altair
              Vega-Lite API\nExamples
              Tutorials
              Documentation
              Usage
              About
            
            
              GitHub
              Try Online\nExamples
              Tutorials
              Documentation
              Usage
              About\nGitHub
              Try Online\nLine Chart Example
    Line charts are used to depict changing values, with line slopes conveying rates of change. Different interpolators change the curvature of the line. Options such as cardinal or Catmull-Rom interpolation can produce pleasing curves, but can also “hallucinate” maximum or minimum values that do not exist in the data. Use monotone interpolation for smooth curves that faithfully preserve monotonicity.




  
  View Source
  Export PNG
  Export SVG






  View in Online Vega Editor


Vega JSON Specification <>

{
  "$schema": "https://vega.github.io/schema/vega/v5.json",
  "description": "A basic line chart example.",
  "width": 500,
  "height": 200,
  "padding": 5,

  "signals": [
    {
      "name": "interpolate",
      "value": "linear",
      "bind": {
        "input": "select",
        "options": [
          "basis",
          "cardinal",
          "catmull-rom",
          "linear",
          "monotone",
          "natural",
          "step",
          "step-after",
          "step-before"
        ]
      }
    }
  ],

  "data": [
    {
      "name": "table",
      "values": [
        {"x": 0, "y": 28, "c":0}, {"x": 0, "y": 20, "c":1},
        {"x": 1, "y": 43, "c":0}, {"x": 1, "y": 35, "c":1},
        {"x": 2, "y": 81, "c":0}, {"x": 2, "y": 10, "c":1},
        {"x": 3, "y": 19, "c":0}, {"x": 3, "y": 15, "c":1},
        {"x": 4, "y": 52, "c":0}, {"x": 4, "y": 48, "c":1},
        {"x": 5, "y": 24, "c":0}, {"x": 5, "y": 28, "c":1},
        {"x": 6, "y": 87, "c":0}, {"x": 6, "y": 66, "c":1},
        {"x": 7, "y": 17, "c":0}, {"x": 7, "y": 27, "c":1},
        {"x": 8, "y": 68, "c":0}, {"x": 8, "y": 16, "c":1},
        {"x": 9, "y": 49, "c":0}, {"x": 9, "y": 25, "c":1}
      ]
    }
  ],

  "scales": [
    {
      "name": "x",
      "type": "point",
      "range": "width",
      "domain": {"data": "table", "field": "x"}
    },
    {
      "name": "y",
      "type": "linear",
      "range": "height",
      "nice": true,
      "zero": true,
      "domain": {"data": "table", "field": "y"}
    },
    {
      "name": "color",
      "type": "ordinal",
      "range": "category",
      "domain": {"data": "table", "field": "c"}
    }
  ],

  "axes": [
    {"orient": "bottom", "scale": "x"},
    {"orient": "left", "scale": "y"}
  ],

  "marks": [
    {
      "type": "group",
      "from": {
        "facet": {
          "name": "series",
          "data": "table",
          "groupby": "c"
        }
      },
      "marks": [
        {
          "type": "line",
          "from": {"data": "series"},
          "encode": {
            "enter": {
              "x": {"scale": "x", "field": "x"},
              "y": {"scale": "y", "field": "y"},
              "stroke": {"scale": "color", "field": "c"},
              "strokeWidth": {"value": 2}
            },
            "update": {
              "interpolate": {"signal": "interpolate"},
              "strokeOpacity": {"value": 1}
            },
            "hover": {
              "strokeOpacity": {"value": 0.5}
            }
          }
        }
      ]
    }
  ]
}\nLine charts are used to depict changing values, with line slopes conveying rates of change. Different interpolators change the curvature of the line. Options such as cardinal or Catmull-Rom interpolation can produce pleasing curves, but can also “hallucinate” maximum or minimum values that do not exist in the data. Use monotone interpolation for smooth curves that faithfully preserve monotonicity.\nmonotone interpolation\nView Source
  Export PNG
  Export SVG\nView Source
  Export PNG
  Export SVG\nView in Online Vega Editor\nView in Online Vega Editor\nVega JSON Specification <>\n{
  "$schema": "https://vega.github.io/schema/vega/v5.json",
  "description": "A basic line chart example.",
  "width": 500,
  "height": 200,
  "padding": 5,

  "signals": [
    {
      "name": "interpolate",
      "value": "linear",
      "bind": {
        "input": "select",
        "options": [
          "basis",
          "cardinal",
          "catmull-rom",
          "linear",
          "monotone",
          "natural",
          "step",
          "step-after",
          "step-before"
        ]
      }
    }
  ],

  "data": [
    {
      "name": "table",
      "values": [
        {"x": 0, "y": 28, "c":0}, {"x": 0, "y": 20, "c":1},
        {"x": 1, "y": 43, "c":0}, {"x": 1, "y": 35, "c":1},
        {"x": 2, "y": 81, "c":0}, {"x": 2, "y": 10, "c":1},
        {"x": 3, "y": 19, "c":0}, {"x": 3, "y": 15, "c":1},
        {"x": 4, "y": 52, "c":0}, {"x": 4, "y": 48, "c":1},
        {"x": 5, "y": 24, "c":0}, {"x": 5, "y": 28, "c":1},
        {"x": 6, "y": 87, "c":0}, {"x": 6, "y": 66, "c":1},
        {"x": 7, "y": 17, "c":0}, {"x": 7, "y": 27, "c":1},
        {"x": 8, "y": 68, "c":0}, {"x": 8, "y": 16, "c":1},
        {"x": 9, "y": 49, "c":0}, {"x": 9, "y": 25, "c":1}
      ]
    }
  ],

  "scales": [
    {
      "name": "x",
      "type": "point",
      "range": "width",
      "domain": {"data": "table", "field": "x"}
    },
    {
      "name": "y",
      "type": "linear",
      "range": "height",
      "nice": true,
      "zero": true,
      "domain": {"data": "table", "field": "y"}
    },
    {
      "name": "color",
      "type": "ordinal",
      "range": "category",
      "domain": {"data": "table", "field": "c"}
    }
  ],

  "axes": [
    {"orient": "bottom", "scale": "x"},
    {"orient": "left", "scale": "y"}
  ],

  "marks": [
    {
      "type": "group",
      "from": {
        "facet": {
          "name": "series",
          "data": "table",
          "groupby": "c"
        }
      },
      "marks": [
        {
          "type": "line",
          "from": {"data": "series"},
          "encode": {
            "enter": {
              "x": {"scale": "x", "field": "x"},
              "y": {"scale": "y", "field": "y"},
              "stroke": {"scale": "color", "field": "c"},
              "strokeWidth": {"value": 2}
            },
            "update": {
              "interpolate": {"signal": "interpolate"},
              "strokeOpacity": {"value": 1}
            },
            "hover": {
              "strokeOpacity": {"value": 0.5}
            }
          }
        }
      ]
    }
  ]
}\n{
  "$schema": "https://vega.github.io/schema/vega/v5.json",
  "description": "A basic line chart example.",
  "width": 500,
  "height": 200,
  "padding": 5,

  "signals": [
    {
      "name": "interpolate",
      "value": "linear",
      "bind": {
        "input": "select",
        "options": [
          "basis",
          "cardinal",
          "catmull-rom",
          "linear",
          "monotone",
          "natural",
          "step",
          "step-after",
          "step-before"
        ]
      }
    }
  ],

  "data": [
    {
      "name": "table",
      "values": [
        {"x": 0, "y": 28, "c":0}, {"x": 0, "y": 20, "c":1},
        {"x": 1, "y": 43, "c":0}, {"x": 1, "y": 35, "c":1},
        {"x": 2, "y": 81, "c":0}, {"x": 2, "y": 10, "c":1},
        {"x": 3, "y": 19, "c":0}, {"x": 3, "y": 15, "c":1},
        {"x": 4, "y": 52, "c":0}, {"x": 4, "y": 48, "c":1},
        {"x": 5, "y": 24, "c":0}, {"x": 5, "y": 28, "c":1},
        {"x": 6, "y": 87, "c":0}, {"x": 6, "y": 66, "c":1},
        {"x": 7, "y": 17, "c":0}, {"x": 7, "y": 27, "c":1},
        {"x": 8, "y": 68, "c":0}, {"x": 8, "y": 16, "c":1},
        {"x": 9, "y": 49, "c":0}, {"x": 9, "y": 25, "c":1}
      ]
    }
  ],

  "scales": [
    {
      "name": "x",
      "type": "point",
      "range": "width",
      "domain": {"data": "table", "field": "x"}
    },
    {
      "name": "y",
      "type": "linear",
      "range": "height",
      "nice": true,
      "zero": true,
      "domain": {"data": "table", "field": "y"}
    },
    {
      "name": "color",
      "type": "ordinal",
      "range": "category",
      "domain": {"data": "table", "field": "c"}
    }
  ],

  "axes": [
    {"orient": "bottom", "scale": "x"},
    {"orient": "left", "scale": "y"}
  ],

  "marks": [
    {
      "type": "group",
      "from": {
        "facet": {
          "name": "series",
          "data": "table",
          "groupby": "c"
        }
      },
      "marks": [
        {
          "type": "line",
          "from": {"data": "series"},
          "encode": {
            "enter": {
              "x": {"scale": "x", "field": "x"},
              "y": {"scale": "y", "field": "y"},
              "stroke": {"scale": "color", "field": "c"},
              "strokeWidth": {"value": 2}
            },
            "update": {
              "interpolate": {"signal": "interpolate"},
              "strokeOpacity": {"value": 1}
            },
            "hover": {
              "strokeOpacity": {"value": 0.5}
            }
          }
        }
      ]
    }
  ]
}\n"https://vega.github.io/schema/vega/v5.json"\n"A basic line chart example."\n\n\nVega
            
              Vega-Lite
              Altair
              Vega-Lite API
            
          
          
            
              Examples
              Tutorials
              Documentation
              Usage
              About
            
            
              GitHub
              Try Online
            
          
        
      

      
        

  
  
    Area Chart Example
    An area chart uses a filled shape to show changes in a quantitative value.




  
  View Source
  Export PNG
  Export SVG






  View in Online Vega Editor


Vega JSON Specification <>

{
  "$schema": "https://vega.github.io/schema/vega/v5.json",
  "description": "A basic area chart example.",
  "width": 500,
  "height": 200,
  "padding": 5,

  "signals": [
    {
      "name": "interpolate",
      "value": "monotone",
      "bind": {
        "input": "select",
        "options": [
          "basis",
          "cardinal",
          "catmull-rom",
          "linear",
          "monotone",
          "natural",
          "step",
          "step-after",
          "step-before"
        ]
      }
    }
  ],

  "data": [
    {
      "name": "table",
      "values": [
        {"u": 1,  "v": 28}, {"u": 2,  "v": 55},
        {"u": 3,  "v": 43}, {"u": 4,  "v": 91},
        {"u": 5,  "v": 81}, {"u": 6,  "v": 53},
        {"u": 7,  "v": 19}, {"u": 8,  "v": 87},
        {"u": 9,  "v": 52}, {"u": 10, "v": 48},
        {"u": 11, "v": 24}, {"u": 12, "v": 49},
        {"u": 13, "v": 87}, {"u": 14, "v": 66},
        {"u": 15, "v": 17}, {"u": 16, "v": 27},
        {"u": 17, "v": 68}, {"u": 18, "v": 16},
        {"u": 19, "v": 49}, {"u": 20, "v": 15}
      ]
    }
  ],

  "scales": [
    {
      "name": "xscale",
      "type": "linear",
      "range": "width",
      "zero": false,
      "domain": {"data": "table", "field": "u"}
    },
    {
      "name": "yscale",
      "type": "linear",
      "range": "height",
      "nice": true,
      "zero": true,
      "domain": {"data": "table", "field": "v"}
    }
  ],

  "axes": [
    {"orient": "bottom", "scale": "xscale", "tickCount": 20},
    {"orient": "left", "scale": "yscale"}
  ],

  "marks": [
    {
      "type": "area",
      "from": {"data": "table"},
      "encode": {
        "enter": {
          "x": {"scale": "xscale", "field": "u"},
          "y": {"scale": "yscale", "field": "v"},
          "y2": {"scale": "yscale", "value": 0},
          "fill": {"value": "steelblue"}
        },
        "update": {
          "interpolate": {"signal": "interpolate"},
          "fillOpacity": {"value": 1}
        },
        "hover": {
          "fillOpacity": {"value": 0.5}
        }
      }
    }
  ]
}\nVega
            
              Vega-Lite
              Altair
              Vega-Lite API\nVega-Lite
              Altair
              Vega-Lite API\nExamples
              Tutorials
              Documentation
              Usage
              About
            
            
              GitHub
              Try Online\nExamples
              Tutorials
              Documentation
              Usage
              About\nGitHub
              Try Online\nArea Chart Example
    An area chart uses a filled shape to show changes in a quantitative value.




  
  View Source
  Export PNG
  Export SVG






  View in Online Vega Editor


Vega JSON Specification <>

{
  "$schema": "https://vega.github.io/schema/vega/v5.json",
  "description": "A basic area chart example.",
  "width": 500,
  "height": 200,
  "padding": 5,

  "signals": [
    {
      "name": "interpolate",
      "value": "monotone",
      "bind": {
        "input": "select",
        "options": [
          "basis",
          "cardinal",
          "catmull-rom",
          "linear",
          "monotone",
          "natural",
          "step",
          "step-after",
          "step-before"
        ]
      }
    }
  ],

  "data": [
    {
      "name": "table",
      "values": [
        {"u": 1,  "v": 28}, {"u": 2,  "v": 55},
        {"u": 3,  "v": 43}, {"u": 4,  "v": 91},
        {"u": 5,  "v": 81}, {"u": 6,  "v": 53},
        {"u": 7,  "v": 19}, {"u": 8,  "v": 87},
        {"u": 9,  "v": 52}, {"u": 10, "v": 48},
        {"u": 11, "v": 24}, {"u": 12, "v": 49},
        {"u": 13, "v": 87}, {"u": 14, "v": 66},
        {"u": 15, "v": 17}, {"u": 16, "v": 27},
        {"u": 17, "v": 68}, {"u": 18, "v": 16},
        {"u": 19, "v": 49}, {"u": 20, "v": 15}
      ]
    }
  ],

  "scales": [
    {
      "name": "xscale",
      "type": "linear",
      "range": "width",
      "zero": false,
      "domain": {"data": "table", "field": "u"}
    },
    {
      "name": "yscale",
      "type": "linear",
      "range": "height",
      "nice": true,
      "zero": true,
      "domain": {"data": "table", "field": "v"}
    }
  ],

  "axes": [
    {"orient": "bottom", "scale": "xscale", "tickCount": 20},
    {"orient": "left", "scale": "yscale"}
  ],

  "marks": [
    {
      "type": "area",
      "from": {"data": "table"},
      "encode": {
        "enter": {
          "x": {"scale": "xscale", "field": "u"},
          "y": {"scale": "yscale", "field": "v"},
          "y2": {"scale": "yscale", "value": 0},
          "fill": {"value": "steelblue"}
        },
        "update": {
          "interpolate": {"signal": "interpolate"},
          "fillOpacity": {"value": 1}
        },
        "hover": {
          "fillOpacity": {"value": 0.5}
        }
      }
    }
  ]
}\nAn area chart uses a filled shape to show changes in a quantitative value.\nView Source
  Export PNG
  Export SVG\nView Source
  Export PNG
  Export SVG\nView in Online Vega Editor\nView in Online Vega Editor\nVega JSON Specification <>\n{
  "$schema": "https://vega.github.io/schema/vega/v5.json",
  "description": "A basic area chart example.",
  "width": 500,
  "height": 200,
  "padding": 5,

  "signals": [
    {
      "name": "interpolate",
      "value": "monotone",
      "bind": {
        "input": "select",
        "options": [
          "basis",
          "cardinal",
          "catmull-rom",
          "linear",
          "monotone",
          "natural",
          "step",
          "step-after",
          "step-before"
        ]
      }
    }
  ],

  "data": [
    {
      "name": "table",
      "values": [
        {"u": 1,  "v": 28}, {"u": 2,  "v": 55},
        {"u": 3,  "v": 43}, {"u": 4,  "v": 91},
        {"u": 5,  "v": 81}, {"u": 6,  "v": 53},
        {"u": 7,  "v": 19}, {"u": 8,  "v": 87},
        {"u": 9,  "v": 52}, {"u": 10, "v": 48},
        {"u": 11, "v": 24}, {"u": 12, "v": 49},
        {"u": 13, "v": 87}, {"u": 14, "v": 66},
        {"u": 15, "v": 17}, {"u": 16, "v": 27},
        {"u": 17, "v": 68}, {"u": 18, "v": 16},
        {"u": 19, "v": 49}, {"u": 20, "v": 15}
      ]
    }
  ],

  "scales": [
    {
      "name": "xscale",
      "type": "linear",
      "range": "width",
      "zero": false,
      "domain": {"data": "table", "field": "u"}
    },
    {
      "name": "yscale",
      "type": "linear",
      "range": "height",
      "nice": true,
      "zero": true,
      "domain": {"data": "table", "field": "v"}
    }
  ],

  "axes": [
    {"orient": "bottom", "scale": "xscale", "tickCount": 20},
    {"orient": "left", "scale": "yscale"}
  ],

  "marks": [
    {
      "type": "area",
      "from": {"data": "table"},
      "encode": {
        "enter": {
          "x": {"scale": "xscale", "field": "u"},
          "y": {"scale": "yscale", "field": "v"},
          "y2": {"scale": "yscale", "value": 0},
          "fill": {"value": "steelblue"}
        },
        "update": {
          "interpolate": {"signal": "interpolate"},
          "fillOpacity": {"value": 1}
        },
        "hover": {
          "fillOpacity": {"value": 0.5}
        }
      }
    }
  ]
}\n{
  "$schema": "https://vega.github.io/schema/vega/v5.json",
  "description": "A basic area chart example.",
  "width": 500,
  "height": 200,
  "padding": 5,

  "signals": [
    {
      "name": "interpolate",
      "value": "monotone",
      "bind": {
        "input": "select",
        "options": [
          "basis",
          "cardinal",
          "catmull-rom",
          "linear",
          "monotone",
          "natural",
          "step",
          "step-after",
          "step-before"
        ]
      }
    }
  ],

  "data": [
    {
      "name": "table",
      "values": [
        {"u": 1,  "v": 28}, {"u": 2,  "v": 55},
        {"u": 3,  "v": 43}, {"u": 4,  "v": 91},
        {"u": 5,  "v": 81}, {"u": 6,  "v": 53},
        {"u": 7,  "v": 19}, {"u": 8,  "v": 87},
        {"u": 9,  "v": 52}, {"u": 10, "v": 48},
        {"u": 11, "v": 24}, {"u": 12, "v": 49},
        {"u": 13, "v": 87}, {"u": 14, "v": 66},
        {"u": 15, "v": 17}, {"u": 16, "v": 27},
        {"u": 17, "v": 68}, {"u": 18, "v": 16},
        {"u": 19, "v": 49}, {"u": 20, "v": 15}
      ]
    }
  ],

  "scales": [
    {
      "name": "xscale",
      "type": "linear",
      "range": "width",
      "zero": false,
      "domain": {"data": "table", "field": "u"}
    },
    {
      "name": "yscale",
      "type": "linear",
      "range": "height",
      "nice": true,
      "zero": true,
      "domain": {"data": "table", "field": "v"}
    }
  ],

  "axes": [
    {"orient": "bottom", "scale": "xscale", "tickCount": 20},
    {"orient": "left", "scale": "yscale"}
  ],

  "marks": [
    {
      "type": "area",
      "from": {"data": "table"},
      "encode": {
        "enter": {
          "x": {"scale": "xscale", "field": "u"},
          "y": {"scale": "yscale", "field": "v"},
          "y2": {"scale": "yscale", "value": 0},
          "fill": {"value": "steelblue"}
        },
        "update": {
          "interpolate": {"signal": "interpolate"},
          "fillOpacity": {"value": 1}
        },
        "hover": {
          "fillOpacity": {"value": 0.5}
        }
      }
    }
  ]
}\n"https://vega.github.io/schema/vega/v5.json"\n"A basic area chart example."\n\n\nVega
            
              Vega-Lite
              Altair
              Vega-Lite API
            
          
          
            
              Examples
              Tutorials
              Documentation
              Usage
              About
            
            
              GitHub
              Try Online
            
          
        
      

      
        

  
  
    Stacked Area Chart Example
    A stacked area chart depicts the sum of series of quantitative values using layered areas, while still enabling inspection of individual series.




  
  View Source
  Export PNG
  Export SVG






  View in Online Vega Editor


Vega JSON Specification <>

{
  "$schema": "https://vega.github.io/schema/vega/v5.json",
  "description": "A basic stacked area chart example.",
  "width": 500,
  "height": 200,
  "padding": 5,

  "data": [
    {
      "name": "table",
      "values": [
        {"x": 0, "y": 28, "c":0}, {"x": 0, "y": 55, "c":1},
        {"x": 1, "y": 43, "c":0}, {"x": 1, "y": 91, "c":1},
        {"x": 2, "y": 81, "c":0}, {"x": 2, "y": 53, "c":1},
        {"x": 3, "y": 19, "c":0}, {"x": 3, "y": 87, "c":1},
        {"x": 4, "y": 52, "c":0}, {"x": 4, "y": 48, "c":1},
        {"x": 5, "y": 24, "c":0}, {"x": 5, "y": 49, "c":1},
        {"x": 6, "y": 87, "c":0}, {"x": 6, "y": 66, "c":1},
        {"x": 7, "y": 17, "c":0}, {"x": 7, "y": 27, "c":1},
        {"x": 8, "y": 68, "c":0}, {"x": 8, "y": 16, "c":1},
        {"x": 9, "y": 49, "c":0}, {"x": 9, "y": 15, "c":1}
      ],
      "transform": [
        {
          "type": "stack",
          "groupby": ["x"],
          "sort": {"field": "c"},
          "field": "y"
        }
      ]
    }
  ],

  "scales": [
    {
      "name": "x",
      "type": "point",
      "range": "width",
      "domain": {"data": "table", "field": "x"}
    },
    {
      "name": "y",
      "type": "linear",
      "range": "height",
      "nice": true, "zero": true,
      "domain": {"data": "table", "field": "y1"}
    },
    {
      "name": "color",
      "type": "ordinal",
      "range": "category",
      "domain": {"data": "table", "field": "c"}
    }
  ],

  "axes": [
    {"orient": "bottom", "scale": "x", "zindex": 1},
    {"orient": "left", "scale": "y", "zindex": 1}
  ],

  "marks": [
    {
      "type": "group",
      "from": {
        "facet": {
          "name": "series",
          "data": "table",
          "groupby": "c"
        }
      },
      "marks": [
        {
          "type": "area",
          "from": {"data": "series"},
          "encode": {
            "enter": {
              "interpolate": {"value": "monotone"},
              "x": {"scale": "x", "field": "x"},
              "y": {"scale": "y", "field": "y0"},
              "y2": {"scale": "y", "field": "y1"},
              "fill": {"scale": "color", "field": "c"}
            },
            "update": {
              "fillOpacity": {"value": 1}
            },
            "hover": {
              "fillOpacity": {"value": 0.5}
            }
          }
        }
      ]
    }
  ]
}\nVega
            
              Vega-Lite
              Altair
              Vega-Lite API\nVega-Lite
              Altair
              Vega-Lite API\nExamples
              Tutorials
              Documentation
              Usage
              About
            
            
              GitHub
              Try Online\nExamples
              Tutorials
              Documentation
              Usage
              About\nGitHub
              Try Online\nStacked Area Chart Example
    A stacked area chart depicts the sum of series of quantitative values using layered areas, while still enabling inspection of individual series.




  
  View Source
  Export PNG
  Export SVG






  View in Online Vega Editor


Vega JSON Specification <>

{
  "$schema": "https://vega.github.io/schema/vega/v5.json",
  "description": "A basic stacked area chart example.",
  "width": 500,
  "height": 200,
  "padding": 5,

  "data": [
    {
      "name": "table",
      "values": [
        {"x": 0, "y": 28, "c":0}, {"x": 0, "y": 55, "c":1},
        {"x": 1, "y": 43, "c":0}, {"x": 1, "y": 91, "c":1},
        {"x": 2, "y": 81, "c":0}, {"x": 2, "y": 53, "c":1},
        {"x": 3, "y": 19, "c":0}, {"x": 3, "y": 87, "c":1},
        {"x": 4, "y": 52, "c":0}, {"x": 4, "y": 48, "c":1},
        {"x": 5, "y": 24, "c":0}, {"x": 5, "y": 49, "c":1},
        {"x": 6, "y": 87, "c":0}, {"x": 6, "y": 66, "c":1},
        {"x": 7, "y": 17, "c":0}, {"x": 7, "y": 27, "c":1},
        {"x": 8, "y": 68, "c":0}, {"x": 8, "y": 16, "c":1},
        {"x": 9, "y": 49, "c":0}, {"x": 9, "y": 15, "c":1}
      ],
      "transform": [
        {
          "type": "stack",
          "groupby": ["x"],
          "sort": {"field": "c"},
          "field": "y"
        }
      ]
    }
  ],

  "scales": [
    {
      "name": "x",
      "type": "point",
      "range": "width",
      "domain": {"data": "table", "field": "x"}
    },
    {
      "name": "y",
      "type": "linear",
      "range": "height",
      "nice": true, "zero": true,
      "domain": {"data": "table", "field": "y1"}
    },
    {
      "name": "color",
      "type": "ordinal",
      "range": "category",
      "domain": {"data": "table", "field": "c"}
    }
  ],

  "axes": [
    {"orient": "bottom", "scale": "x", "zindex": 1},
    {"orient": "left", "scale": "y", "zindex": 1}
  ],

  "marks": [
    {
      "type": "group",
      "from": {
        "facet": {
          "name": "series",
          "data": "table",
          "groupby": "c"
        }
      },
      "marks": [
        {
          "type": "area",
          "from": {"data": "series"},
          "encode": {
            "enter": {
              "interpolate": {"value": "monotone"},
              "x": {"scale": "x", "field": "x"},
              "y": {"scale": "y", "field": "y0"},
              "y2": {"scale": "y", "field": "y1"},
              "fill": {"scale": "color", "field": "c"}
            },
            "update": {
              "fillOpacity": {"value": 1}
            },
            "hover": {
              "fillOpacity": {"value": 0.5}
            }
          }
        }
      ]
    }
  ]
}\nStacked Area Chart Example\nA stacked area chart depicts the sum of series of quantitative values using layered areas, while still enabling inspection of individual series.\nView Source
  Export PNG
  Export SVG\nView Source
  Export PNG
  Export SVG\nView in Online Vega Editor\nView in Online Vega Editor\nVega JSON Specification <>\n{
  "$schema": "https://vega.github.io/schema/vega/v5.json",
  "description": "A basic stacked area chart example.",
  "width": 500,
  "height": 200,
  "padding": 5,

  "data": [
    {
      "name": "table",
      "values": [
        {"x": 0, "y": 28, "c":0}, {"x": 0, "y": 55, "c":1},
        {"x": 1, "y": 43, "c":0}, {"x": 1, "y": 91, "c":1},
        {"x": 2, "y": 81, "c":0}, {"x": 2, "y": 53, "c":1},
        {"x": 3, "y": 19, "c":0}, {"x": 3, "y": 87, "c":1},
        {"x": 4, "y": 52, "c":0}, {"x": 4, "y": 48, "c":1},
        {"x": 5, "y": 24, "c":0}, {"x": 5, "y": 49, "c":1},
        {"x": 6, "y": 87, "c":0}, {"x": 6, "y": 66, "c":1},
        {"x": 7, "y": 17, "c":0}, {"x": 7, "y": 27, "c":1},
        {"x": 8, "y": 68, "c":0}, {"x": 8, "y": 16, "c":1},
        {"x": 9, "y": 49, "c":0}, {"x": 9, "y": 15, "c":1}
      ],
      "transform": [
        {
          "type": "stack",
          "groupby": ["x"],
          "sort": {"field": "c"},
          "field": "y"
        }
      ]
    }
  ],

  "scales": [
    {
      "name": "x",
      "type": "point",
      "range": "width",
      "domain": {"data": "table", "field": "x"}
    },
    {
      "name": "y",
      "type": "linear",
      "range": "height",
      "nice": true, "zero": true,
      "domain": {"data": "table", "field": "y1"}
    },
    {
      "name": "color",
      "type": "ordinal",
      "range": "category",
      "domain": {"data": "table", "field": "c"}
    }
  ],

  "axes": [
    {"orient": "bottom", "scale": "x", "zindex": 1},
    {"orient": "left", "scale": "y", "zindex": 1}
  ],

  "marks": [
    {
      "type": "group",
      "from": {
        "facet": {
          "name": "series",
          "data": "table",
          "groupby": "c"
        }
      },
      "marks": [
        {
          "type": "area",
          "from": {"data": "series"},
          "encode": {
            "enter": {
              "interpolate": {"value": "monotone"},
              "x": {"scale": "x", "field": "x"},
              "y": {"scale": "y", "field": "y0"},
              "y2": {"scale": "y", "field": "y1"},
              "fill": {"scale": "color", "field": "c"}
            },
            "update": {
              "fillOpacity": {"value": 1}
            },
            "hover": {
              "fillOpacity": {"value": 0.5}
            }
          }
        }
      ]
    }
  ]
}\n{
  "$schema": "https://vega.github.io/schema/vega/v5.json",
  "description": "A basic stacked area chart example.",
  "width": 500,
  "height": 200,
  "padding": 5,

  "data": [
    {
      "name": "table",
      "values": [
        {"x": 0, "y": 28, "c":0}, {"x": 0, "y": 55, "c":1},
        {"x": 1, "y": 43, "c":0}, {"x": 1, "y": 91, "c":1},
        {"x": 2, "y": 81, "c":0}, {"x": 2, "y": 53, "c":1},
        {"x": 3, "y": 19, "c":0}, {"x": 3, "y": 87, "c":1},
        {"x": 4, "y": 52, "c":0}, {"x": 4, "y": 48, "c":1},
        {"x": 5, "y": 24, "c":0}, {"x": 5, "y": 49, "c":1},
        {"x": 6, "y": 87, "c":0}, {"x": 6, "y": 66, "c":1},
        {"x": 7, "y": 17, "c":0}, {"x": 7, "y": 27, "c":1},
        {"x": 8, "y": 68, "c":0}, {"x": 8, "y": 16, "c":1},
        {"x": 9, "y": 49, "c":0}, {"x": 9, "y": 15, "c":1}
      ],
      "transform": [
        {
          "type": "stack",
          "groupby": ["x"],
          "sort": {"field": "c"},
          "field": "y"
        }
      ]
    }
  ],

  "scales": [
    {
      "name": "x",
      "type": "point",
      "range": "width",
      "domain": {"data": "table", "field": "x"}
    },
    {
      "name": "y",
      "type": "linear",
      "range": "height",
      "nice": true, "zero": true,
      "domain": {"data": "table", "field": "y1"}
    },
    {
      "name": "color",
      "type": "ordinal",
      "range": "category",
      "domain": {"data": "table", "field": "c"}
    }
  ],

  "axes": [
    {"orient": "bottom", "scale": "x", "zindex": 1},
    {"orient": "left", "scale": "y", "zindex": 1}
  ],

  "marks": [
    {
      "type": "group",
      "from": {
        "facet": {
          "name": "series",
          "data": "table",
          "groupby": "c"
        }
      },
      "marks": [
        {
          "type": "area",
          "from": {"data": "series"},
          "encode": {
            "enter": {
              "interpolate": {"value": "monotone"},
              "x": {"scale": "x", "field": "x"},
              "y": {"scale": "y", "field": "y0"},
              "y2": {"scale": "y", "field": "y1"},
              "fill": {"scale": "color", "field": "c"}
            },
            "update": {
              "fillOpacity": {"value": 1}
            },
            "hover": {
              "fillOpacity": {"value": 0.5}
            }
          }
        }
      ]
    }
  ]
}\n"https://vega.github.io/schema/vega/v5.json"\n"A basic stacked area chart example."\n\n\nVega
            
              Vega-Lite
              Altair
              Vega-Lite API
            
          
          
            
              Examples
              Tutorials
              Documentation
              Usage
              About
            
            
              GitHub
              Try Online
            
          
        
      

      
        

  
  
    Horizon Graph Example
    By dividing an area chart into consecutive layers, horizon graphs present time-series data in a compact space while preserving resolution. Click the chart to change the number of layers. Though the chart size changes, the spatial resolution of the area chart stays constant.




  
  View Source
  Export PNG
  Export SVG






  View in Online Vega Editor


Vega JSON Specification <>

{
  "$schema": "https://vega.github.io/schema/vega/v5.json",
  "description": "A horizon graph, which preserves resolution by layering slices of an area chart.",
  "width": 500,
  "height": 100,

  "signals": [
    {
      "name": "layers",
      "value": 2,
      "on": [{"events": "pointerdown!", "update": "1 + (layers % 4)"}],
      "bind": {"input": "select", "options": [1, 2, 3, 4]}
    },
    {
      "name": "height",
      "update": "floor(200 / layers)"
    },
    {
      "name": "vheight",
      "update": "height * layers"
    },
    {
      "name": "opacity",
      "update": "pow(layers, -2/3)"
    }
  ],

  "data": [
    {
      "name": "layer_indices",
      "values": [0, 1, 2, 3],
      "transform": [
        {"type": "filter", "expr": "datum.data < layers"},
        {"type": "formula", "expr": "datum.data * -height", "as": "offset"}
      ]
    },
    {
      "name": "table",
      "values": [
        {"x": 1,  "y": 28}, {"x": 2,  "y": 55},
        {"x": 3,  "y": 43}, {"x": 4,  "y": 91},
        {"x": 5,  "y": 81}, {"x": 6,  "y": 53},
        {"x": 7,  "y": 19}, {"x": 8,  "y": 87},
        {"x": 9,  "y": 52}, {"x": 10, "y": 48},
        {"x": 11, "y": 24}, {"x": 12, "y": 49},
        {"x": 13, "y": 87}, {"x": 14, "y": 66},
        {"x": 15, "y": 17}, {"x": 16, "y": 27},
        {"x": 17, "y": 68}, {"x": 18, "y": 16},
        {"x": 19, "y": 49}, {"x": 20, "y": 15}
      ]
    }
  ],

  "scales": [
    {
      "name": "x",
      "type": "linear",
      "range": "width",
      "zero": false, "round": true,
      "domain": {"data": "table", "field": "x"}
    },
    {
      "name": "y",
      "type": "linear",
      "range": [{"signal":"vheight"}, 0],
      "nice": true, "zero": true,
      "domain": {"data": "table", "field": "y"}
    }
  ],

  "axes": [
    {"orient": "bottom", "scale": "x", "tickCount": 20}
  ],

  "marks": [
    {
      "type": "group",
      "encode": {
        "update": {
          "width": {"field": {"group": "width"}},
          "height": {"field": {"group": "height"}},
          "clip": {"value": true}
        }
      },
      "marks": [
        {
          "type": "group",
          "from": {"data": "layer_indices"},
          "encode": {
            "update": {
              "y": {"field": "offset"}
            }
          },
          "marks": [
            {
              "type": "area",
              "from": {"data": "table"},
              "encode": {
                "enter": {
                  "interpolate": {"value": "monotone"},
                  "x": {"scale": "x", "field": "x"},
                  "fill": {"value": "steelblue"}
                },
                "update": {
                  "y": {"scale": "y", "field": "y"},
                  "y2": {"scale": "y", "value": 0},
                  "fillOpacity": {"signal": "opacity"}
                }
              }
            }
          ]
        }
      ]
    }
  ]
}\nVega
            
              Vega-Lite
              Altair
              Vega-Lite API\nVega-Lite
              Altair
              Vega-Lite API\nExamples
              Tutorials
              Documentation
              Usage
              About
            
            
              GitHub
              Try Online\nExamples
              Tutorials
              Documentation
              Usage
              About\nGitHub
              Try Online\nHorizon Graph Example
    By dividing an area chart into consecutive layers, horizon graphs present time-series data in a compact space while preserving resolution. Click the chart to change the number of layers. Though the chart size changes, the spatial resolution of the area chart stays constant.




  
  View Source
  Export PNG
  Export SVG






  View in Online Vega Editor


Vega JSON Specification <>

{
  "$schema": "https://vega.github.io/schema/vega/v5.json",
  "description": "A horizon graph, which preserves resolution by layering slices of an area chart.",
  "width": 500,
  "height": 100,

  "signals": [
    {
      "name": "layers",
      "value": 2,
      "on": [{"events": "pointerdown!", "update": "1 + (layers % 4)"}],
      "bind": {"input": "select", "options": [1, 2, 3, 4]}
    },
    {
      "name": "height",
      "update": "floor(200 / layers)"
    },
    {
      "name": "vheight",
      "update": "height * layers"
    },
    {
      "name": "opacity",
      "update": "pow(layers, -2/3)"
    }
  ],

  "data": [
    {
      "name": "layer_indices",
      "values": [0, 1, 2, 3],
      "transform": [
        {"type": "filter", "expr": "datum.data < layers"},
        {"type": "formula", "expr": "datum.data * -height", "as": "offset"}
      ]
    },
    {
      "name": "table",
      "values": [
        {"x": 1,  "y": 28}, {"x": 2,  "y": 55},
        {"x": 3,  "y": 43}, {"x": 4,  "y": 91},
        {"x": 5,  "y": 81}, {"x": 6,  "y": 53},
        {"x": 7,  "y": 19}, {"x": 8,  "y": 87},
        {"x": 9,  "y": 52}, {"x": 10, "y": 48},
        {"x": 11, "y": 24}, {"x": 12, "y": 49},
        {"x": 13, "y": 87}, {"x": 14, "y": 66},
        {"x": 15, "y": 17}, {"x": 16, "y": 27},
        {"x": 17, "y": 68}, {"x": 18, "y": 16},
        {"x": 19, "y": 49}, {"x": 20, "y": 15}
      ]
    }
  ],

  "scales": [
    {
      "name": "x",
      "type": "linear",
      "range": "width",
      "zero": false, "round": true,
      "domain": {"data": "table", "field": "x"}
    },
    {
      "name": "y",
      "type": "linear",
      "range": [{"signal":"vheight"}, 0],
      "nice": true, "zero": true,
      "domain": {"data": "table", "field": "y"}
    }
  ],

  "axes": [
    {"orient": "bottom", "scale": "x", "tickCount": 20}
  ],

  "marks": [
    {
      "type": "group",
      "encode": {
        "update": {
          "width": {"field": {"group": "width"}},
          "height": {"field": {"group": "height"}},
          "clip": {"value": true}
        }
      },
      "marks": [
        {
          "type": "group",
          "from": {"data": "layer_indices"},
          "encode": {
            "update": {
              "y": {"field": "offset"}
            }
          },
          "marks": [
            {
              "type": "area",
              "from": {"data": "table"},
              "encode": {
                "enter": {
                  "interpolate": {"value": "monotone"},
                  "x": {"scale": "x", "field": "x"},
                  "fill": {"value": "steelblue"}
                },
                "update": {
                  "y": {"scale": "y", "field": "y"},
                  "y2": {"scale": "y", "value": 0},
                  "fillOpacity": {"signal": "opacity"}
                }
              }
            }
          ]
        }
      ]
    }
  ]
}\nHorizon Graph Example\nBy dividing an area chart into consecutive layers, horizon graphs present time-series data in a compact space while preserving resolution. Click the chart to change the number of layers. Though the chart size changes, the spatial resolution of the area chart stays constant.\nView Source
  Export PNG
  Export SVG\nView Source
  Export PNG
  Export SVG\nView in Online Vega Editor\nView in Online Vega Editor\nVega JSON Specification <>\n{
  "$schema": "https://vega.github.io/schema/vega/v5.json",
  "description": "A horizon graph, which preserves resolution by layering slices of an area chart.",
  "width": 500,
  "height": 100,

  "signals": [
    {
      "name": "layers",
      "value": 2,
      "on": [{"events": "pointerdown!", "update": "1 + (layers % 4)"}],
      "bind": {"input": "select", "options": [1, 2, 3, 4]}
    },
    {
      "name": "height",
      "update": "floor(200 / layers)"
    },
    {
      "name": "vheight",
      "update": "height * layers"
    },
    {
      "name": "opacity",
      "update": "pow(layers, -2/3)"
    }
  ],

  "data": [
    {
      "name": "layer_indices",
      "values": [0, 1, 2, 3],
      "transform": [
        {"type": "filter", "expr": "datum.data < layers"},
        {"type": "formula", "expr": "datum.data * -height", "as": "offset"}
      ]
    },
    {
      "name": "table",
      "values": [
        {"x": 1,  "y": 28}, {"x": 2,  "y": 55},
        {"x": 3,  "y": 43}, {"x": 4,  "y": 91},
        {"x": 5,  "y": 81}, {"x": 6,  "y": 53},
        {"x": 7,  "y": 19}, {"x": 8,  "y": 87},
        {"x": 9,  "y": 52}, {"x": 10, "y": 48},
        {"x": 11, "y": 24}, {"x": 12, "y": 49},
        {"x": 13, "y": 87}, {"x": 14, "y": 66},
        {"x": 15, "y": 17}, {"x": 16, "y": 27},
        {"x": 17, "y": 68}, {"x": 18, "y": 16},
        {"x": 19, "y": 49}, {"x": 20, "y": 15}
      ]
    }
  ],

  "scales": [
    {
      "name": "x",
      "type": "linear",
      "range": "width",
      "zero": false, "round": true,
      "domain": {"data": "table", "field": "x"}
    },
    {
      "name": "y",
      "type": "linear",
      "range": [{"signal":"vheight"}, 0],
      "nice": true, "zero": true,
      "domain": {"data": "table", "field": "y"}
    }
  ],

  "axes": [
    {"orient": "bottom", "scale": "x", "tickCount": 20}
  ],

  "marks": [
    {
      "type": "group",
      "encode": {
        "update": {
          "width": {"field": {"group": "width"}},
          "height": {"field": {"group": "height"}},
          "clip": {"value": true}
        }
      },
      "marks": [
        {
          "type": "group",
          "from": {"data": "layer_indices"},
          "encode": {
            "update": {
              "y": {"field": "offset"}
            }
          },
          "marks": [
            {
              "type": "area",
              "from": {"data": "table"},
              "encode": {
                "enter": {
                  "interpolate": {"value": "monotone"},
                  "x": {"scale": "x", "field": "x"},
                  "fill": {"value": "steelblue"}
                },
                "update": {
                  "y": {"scale": "y", "field": "y"},
                  "y2": {"scale": "y", "value": 0},
                  "fillOpacity": {"signal": "opacity"}
                }
              }
            }
          ]
        }
      ]
    }
  ]
}\n{
  "$schema": "https://vega.github.io/schema/vega/v5.json",
  "description": "A horizon graph, which preserves resolution by layering slices of an area chart.",
  "width": 500,
  "height": 100,

  "signals": [
    {
      "name": "layers",
      "value": 2,
      "on": [{"events": "pointerdown!", "update": "1 + (layers % 4)"}],
      "bind": {"input": "select", "options": [1, 2, 3, 4]}
    },
    {
      "name": "height",
      "update": "floor(200 / layers)"
    },
    {
      "name": "vheight",
      "update": "height * layers"
    },
    {
      "name": "opacity",
      "update": "pow(layers, -2/3)"
    }
  ],

  "data": [
    {
      "name": "layer_indices",
      "values": [0, 1, 2, 3],
      "transform": [
        {"type": "filter", "expr": "datum.data < layers"},
        {"type": "formula", "expr": "datum.data * -height", "as": "offset"}
      ]
    },
    {
      "name": "table",
      "values": [
        {"x": 1,  "y": 28}, {"x": 2,  "y": 55},
        {"x": 3,  "y": 43}, {"x": 4,  "y": 91},
        {"x": 5,  "y": 81}, {"x": 6,  "y": 53},
        {"x": 7,  "y": 19}, {"x": 8,  "y": 87},
        {"x": 9,  "y": 52}, {"x": 10, "y": 48},
        {"x": 11, "y": 24}, {"x": 12, "y": 49},
        {"x": 13, "y": 87}, {"x": 14, "y": 66},
        {"x": 15, "y": 17}, {"x": 16, "y": 27},
        {"x": 17, "y": 68}, {"x": 18, "y": 16},
        {"x": 19, "y": 49}, {"x": 20, "y": 15}
      ]
    }
  ],

  "scales": [
    {
      "name": "x",
      "type": "linear",
      "range": "width",
      "zero": false, "round": true,
      "domain": {"data": "table", "field": "x"}
    },
    {
      "name": "y",
      "type": "linear",
      "range": [{"signal":"vheight"}, 0],
      "nice": true, "zero": true,
      "domain": {"data": "table", "field": "y"}
    }
  ],

  "axes": [
    {"orient": "bottom", "scale": "x", "tickCount": 20}
  ],

  "marks": [
    {
      "type": "group",
      "encode": {
        "update": {
          "width": {"field": {"group": "width"}},
          "height": {"field": {"group": "height"}},
          "clip": {"value": true}
        }
      },
      "marks": [
        {
          "type": "group",
          "from": {"data": "layer_indices"},
          "encode": {
            "update": {
              "y": {"field": "offset"}
            }
          },
          "marks": [
            {
              "type": "area",
              "from": {"data": "table"},
              "encode": {
                "enter": {
                  "interpolate": {"value": "monotone"},
                  "x": {"scale": "x", "field": "x"},
                  "fill": {"value": "steelblue"}
                },
                "update": {
                  "y": {"scale": "y", "field": "y"},
                  "y2": {"scale": "y", "value": 0},
                  "fillOpacity": {"signal": "opacity"}
                }
              }
            }
          ]
        }
      ]
    }
  ]
}\n"https://vega.github.io/schema/vega/v5.json"\n"A horizon graph, which preserves resolution by layering slices of an area chart."\n"floor(200 / layers)"\n"datum.data < layers"\n"datum.data * -height"\n\n\nVega
            
              Vega-Lite
              Altair
              Vega-Lite API
            
          
          
            
              Examples
              Tutorials
              Documentation
              Usage
              About
            
            
              GitHub
              Try Online
            
          
        
      

      
        

  
  
    Job Voyager Example
    The Job Voyager is an interactive stacked graph of occupations based on 150 years of U.S. census data. Either click elements or type queries to explore. The search box supports regular expressions; for example the query "ist$" finds all jobs ending with “ist”.




  
  View Source
  Export PNG
  Export SVG






  View in Online Vega Editor


Vega JSON Specification <>

{
  "$schema": "https://vega.github.io/schema/vega/v5.json",
  "description": "A searchable, stacked area chart of U.S. occupations from 1850 to 2000.",
  "width": 800,
  "height": 500,
  "padding": 5,

  "signals": [
    {
      "name": "sex", "value": "all",
      "bind": {"input": "radio", "options": ["men", "women", "all"]}
    },
    {
      "name": "query", "value": "",
      "on": [
        {"events": "area:click!", "update": "datum.job"},
        {"events": "dblclick!", "update": "''"}
      ],
      "bind": {"input": "text", "placeholder": "search", "autocomplete": "off"}
    }
  ],

  "data": [
    {
      "name": "jobs",
      "url": "data/jobs.json",
      "transform": [
        {
          "type": "filter",
          "expr": "(sex === 'all' || datum.sex === sex) && (!query || test(regexp(query,'i'), datum.job))"
        },
        {
          "type": "stack",
          "field": "perc",
          "groupby": ["year"],
          "sort": {
            "field": ["job", "sex"],
            "order": ["descending", "descending"]
          }
        }
      ]
    },
    {
      "name": "series",
      "source": "jobs",
      "transform": [
        {
          "type": "aggregate",
          "groupby": ["job", "sex"],
          "fields": ["perc", "perc"],
          "ops": ["sum", "argmax"],
          "as": ["sum", "argmax"]
        }
      ]
    }
  ],

  "scales": [
    {
      "name": "x",
      "type": "linear",
      "range": "width",
      "zero": false, "round": true,
      "domain": {"data": "jobs", "field": "year"}
    },
    {
      "name": "y",
      "type": "linear",
      "range": "height", "round": true, "zero": true,
      "domain": {"data": "jobs", "field": "y1"}
    },
    {
      "name": "color",
      "type": "ordinal",
      "domain": ["men", "women"],
      "range": ["#33f", "#f33"]
    },
    {
      "name": "alpha",
      "type": "linear", "zero": true,
      "domain": {"data": "series", "field": "sum"},
      "range": [0.4, 0.8]
    },
    {
      "name": "font",
      "type": "sqrt",
      "range": [0, 20], "round": true, "zero": true,
      "domain": {"data": "series", "field": "argmax.perc"}
    },
    {
      "name": "opacity",
      "type": "quantile",
      "range": [0, 0, 0, 0, 0, 0.1, 0.2, 0.4, 0.7, 1.0],
      "domain": {"data": "series", "field": "argmax.perc"}
    },
    {
      "name": "align",
      "type": "quantize",
      "range": ["left", "center", "right"], "zero": false,
      "domain": [1730, 2130]
    },
    {
      "name": "offset",
      "type": "quantize",
      "range": [6, 0, -6], "zero": false,
      "domain": [1730, 2130]
    }
  ],

  "axes": [
    {
      "orient": "bottom", "scale": "x", "format": "d", "tickCount": 15
    },
    {
      "orient": "right", "scale": "y", "format": "%",
      "grid": true, "domain": false, "tickSize": 12,
      "encode": {
        "grid": {"enter": {"stroke": {"value": "#ccc"}}},
        "ticks": {"enter": {"stroke": {"value": "#ccc"}}}
      }
    }
  ],

  "marks": [
    {
      "type": "group",
      "from": {
        "data": "series",
        "facet": {
          "name": "facet",
          "data": "jobs",
          "groupby": ["job", "sex"]
        }
      },

      "marks": [
        {
          "type": "area",
          "from": {"data": "facet"},
          "encode": {
            "update": {
              "x": {"scale": "x", "field": "year"},
              "y": {"scale": "y", "field": "y0"},
              "y2": {"scale": "y", "field": "y1"},
              "fill": {"scale": "color", "field": "sex"},
              "fillOpacity": {"scale": "alpha", "field": {"parent": "sum"}}
            },
            "hover": {
              "fillOpacity": {"value": 0.2}
            }
          }
        }
      ]
    },
    {
      "type": "text",
      "from": {"data": "series"},
      "interactive": false,
      "encode": {
        "update": {
          "x": {"scale": "x", "field": "argmax.year"},
          "dx": {"scale": "offset", "field": "argmax.year"},
          "y": {"signal": "scale('y', 0.5 * (datum.argmax.y0 + datum.argmax.y1))"},
          "fill": {"value": "#000"},
          "fillOpacity": {"scale": "opacity", "field": "argmax.perc"},
          "fontSize": {"scale": "font", "field": "argmax.perc", "offset": 5},
          "text": {"field": "job"},
          "align": {"scale": "align", "field": "argmax.year"},
          "baseline": {"value": "middle"}
        }
      }
    }
  ]
}\nVega
            
              Vega-Lite
              Altair
              Vega-Lite API\nVega-Lite
              Altair
              Vega-Lite API\nExamples
              Tutorials
              Documentation
              Usage
              About
            
            
              GitHub
              Try Online\nExamples
              Tutorials
              Documentation
              Usage
              About\nGitHub
              Try Online\nJob Voyager Example
    The Job Voyager is an interactive stacked graph of occupations based on 150 years of U.S. census data. Either click elements or type queries to explore. The search box supports regular expressions; for example the query "ist$" finds all jobs ending with “ist”.




  
  View Source
  Export PNG
  Export SVG






  View in Online Vega Editor


Vega JSON Specification <>

{
  "$schema": "https://vega.github.io/schema/vega/v5.json",
  "description": "A searchable, stacked area chart of U.S. occupations from 1850 to 2000.",
  "width": 800,
  "height": 500,
  "padding": 5,

  "signals": [
    {
      "name": "sex", "value": "all",
      "bind": {"input": "radio", "options": ["men", "women", "all"]}
    },
    {
      "name": "query", "value": "",
      "on": [
        {"events": "area:click!", "update": "datum.job"},
        {"events": "dblclick!", "update": "''"}
      ],
      "bind": {"input": "text", "placeholder": "search", "autocomplete": "off"}
    }
  ],

  "data": [
    {
      "name": "jobs",
      "url": "data/jobs.json",
      "transform": [
        {
          "type": "filter",
          "expr": "(sex === 'all' || datum.sex === sex) && (!query || test(regexp(query,'i'), datum.job))"
        },
        {
          "type": "stack",
          "field": "perc",
          "groupby": ["year"],
          "sort": {
            "field": ["job", "sex"],
            "order": ["descending", "descending"]
          }
        }
      ]
    },
    {
      "name": "series",
      "source": "jobs",
      "transform": [
        {
          "type": "aggregate",
          "groupby": ["job", "sex"],
          "fields": ["perc", "perc"],
          "ops": ["sum", "argmax"],
          "as": ["sum", "argmax"]
        }
      ]
    }
  ],

  "scales": [
    {
      "name": "x",
      "type": "linear",
      "range": "width",
      "zero": false, "round": true,
      "domain": {"data": "jobs", "field": "year"}
    },
    {
      "name": "y",
      "type": "linear",
      "range": "height", "round": true, "zero": true,
      "domain": {"data": "jobs", "field": "y1"}
    },
    {
      "name": "color",
      "type": "ordinal",
      "domain": ["men", "women"],
      "range": ["#33f", "#f33"]
    },
    {
      "name": "alpha",
      "type": "linear", "zero": true,
      "domain": {"data": "series", "field": "sum"},
      "range": [0.4, 0.8]
    },
    {
      "name": "font",
      "type": "sqrt",
      "range": [0, 20], "round": true, "zero": true,
      "domain": {"data": "series", "field": "argmax.perc"}
    },
    {
      "name": "opacity",
      "type": "quantile",
      "range": [0, 0, 0, 0, 0, 0.1, 0.2, 0.4, 0.7, 1.0],
      "domain": {"data": "series", "field": "argmax.perc"}
    },
    {
      "name": "align",
      "type": "quantize",
      "range": ["left", "center", "right"], "zero": false,
      "domain": [1730, 2130]
    },
    {
      "name": "offset",
      "type": "quantize",
      "range": [6, 0, -6], "zero": false,
      "domain": [1730, 2130]
    }
  ],

  "axes": [
    {
      "orient": "bottom", "scale": "x", "format": "d", "tickCount": 15
    },
    {
      "orient": "right", "scale": "y", "format": "%",
      "grid": true, "domain": false, "tickSize": 12,
      "encode": {
        "grid": {"enter": {"stroke": {"value": "#ccc"}}},
        "ticks": {"enter": {"stroke": {"value": "#ccc"}}}
      }
    }
  ],

  "marks": [
    {
      "type": "group",
      "from": {
        "data": "series",
        "facet": {
          "name": "facet",
          "data": "jobs",
          "groupby": ["job", "sex"]
        }
      },

      "marks": [
        {
          "type": "area",
          "from": {"data": "facet"},
          "encode": {
            "update": {
              "x": {"scale": "x", "field": "year"},
              "y": {"scale": "y", "field": "y0"},
              "y2": {"scale": "y", "field": "y1"},
              "fill": {"scale": "color", "field": "sex"},
              "fillOpacity": {"scale": "alpha", "field": {"parent": "sum"}}
            },
            "hover": {
              "fillOpacity": {"value": 0.2}
            }
          }
        }
      ]
    },
    {
      "type": "text",
      "from": {"data": "series"},
      "interactive": false,
      "encode": {
        "update": {
          "x": {"scale": "x", "field": "argmax.year"},
          "dx": {"scale": "offset", "field": "argmax.year"},
          "y": {"signal": "scale('y', 0.5 * (datum.argmax.y0 + datum.argmax.y1))"},
          "fill": {"value": "#000"},
          "fillOpacity": {"scale": "opacity", "field": "argmax.perc"},
          "fontSize": {"scale": "font", "field": "argmax.perc", "offset": 5},
          "text": {"field": "job"},
          "align": {"scale": "align", "field": "argmax.year"},
          "baseline": {"value": "middle"}
        }
      }
    }
  ]
}\nThe Job Voyager is an interactive stacked graph of occupations based on 150 years of U.S. census data. Either click elements or type queries to explore. The search box supports regular expressions; for example the query "ist$" finds all jobs ending with “ist”.\nView Source
  Export PNG
  Export SVG\nView Source
  Export PNG
  Export SVG\nView in Online Vega Editor\nView in Online Vega Editor\nVega JSON Specification <>\n{
  "$schema": "https://vega.github.io/schema/vega/v5.json",
  "description": "A searchable, stacked area chart of U.S. occupations from 1850 to 2000.",
  "width": 800,
  "height": 500,
  "padding": 5,

  "signals": [
    {
      "name": "sex", "value": "all",
      "bind": {"input": "radio", "options": ["men", "women", "all"]}
    },
    {
      "name": "query", "value": "",
      "on": [
        {"events": "area:click!", "update": "datum.job"},
        {"events": "dblclick!", "update": "''"}
      ],
      "bind": {"input": "text", "placeholder": "search", "autocomplete": "off"}
    }
  ],

  "data": [
    {
      "name": "jobs",
      "url": "data/jobs.json",
      "transform": [
        {
          "type": "filter",
          "expr": "(sex === 'all' || datum.sex === sex) && (!query || test(regexp(query,'i'), datum.job))"
        },
        {
          "type": "stack",
          "field": "perc",
          "groupby": ["year"],
          "sort": {
            "field": ["job", "sex"],
            "order": ["descending", "descending"]
          }
        }
      ]
    },
    {
      "name": "series",
      "source": "jobs",
      "transform": [
        {
          "type": "aggregate",
          "groupby": ["job", "sex"],
          "fields": ["perc", "perc"],
          "ops": ["sum", "argmax"],
          "as": ["sum", "argmax"]
        }
      ]
    }
  ],

  "scales": [
    {
      "name": "x",
      "type": "linear",
      "range": "width",
      "zero": false, "round": true,
      "domain": {"data": "jobs", "field": "year"}
    },
    {
      "name": "y",
      "type": "linear",
      "range": "height", "round": true, "zero": true,
      "domain": {"data": "jobs", "field": "y1"}
    },
    {
      "name": "color",
      "type": "ordinal",
      "domain": ["men", "women"],
      "range": ["#33f", "#f33"]
    },
    {
      "name": "alpha",
      "type": "linear", "zero": true,
      "domain": {"data": "series", "field": "sum"},
      "range": [0.4, 0.8]
    },
    {
      "name": "font",
      "type": "sqrt",
      "range": [0, 20], "round": true, "zero": true,
      "domain": {"data": "series", "field": "argmax.perc"}
    },
    {
      "name": "opacity",
      "type": "quantile",
      "range": [0, 0, 0, 0, 0, 0.1, 0.2, 0.4, 0.7, 1.0],
      "domain": {"data": "series", "field": "argmax.perc"}
    },
    {
      "name": "align",
      "type": "quantize",
      "range": ["left", "center", "right"], "zero": false,
      "domain": [1730, 2130]
    },
    {
      "name": "offset",
      "type": "quantize",
      "range": [6, 0, -6], "zero": false,
      "domain": [1730, 2130]
    }
  ],

  "axes": [
    {
      "orient": "bottom", "scale": "x", "format": "d", "tickCount": 15
    },
    {
      "orient": "right", "scale": "y", "format": "%",
      "grid": true, "domain": false, "tickSize": 12,
      "encode": {
        "grid": {"enter": {"stroke": {"value": "#ccc"}}},
        "ticks": {"enter": {"stroke": {"value": "#ccc"}}}
      }
    }
  ],

  "marks": [
    {
      "type": "group",
      "from": {
        "data": "series",
        "facet": {
          "name": "facet",
          "data": "jobs",
          "groupby": ["job", "sex"]
        }
      },

      "marks": [
        {
          "type": "area",
          "from": {"data": "facet"},
          "encode": {
            "update": {
              "x": {"scale": "x", "field": "year"},
              "y": {"scale": "y", "field": "y0"},
              "y2": {"scale": "y", "field": "y1"},
              "fill": {"scale": "color", "field": "sex"},
              "fillOpacity": {"scale": "alpha", "field": {"parent": "sum"}}
            },
            "hover": {
              "fillOpacity": {"value": 0.2}
            }
          }
        }
      ]
    },
    {
      "type": "text",
      "from": {"data": "series"},
      "interactive": false,
      "encode": {
        "update": {
          "x": {"scale": "x", "field": "argmax.year"},
          "dx": {"scale": "offset", "field": "argmax.year"},
          "y": {"signal": "scale('y', 0.5 * (datum.argmax.y0 + datum.argmax.y1))"},
          "fill": {"value": "#000"},
          "fillOpacity": {"scale": "opacity", "field": "argmax.perc"},
          "fontSize": {"scale": "font", "field": "argmax.perc", "offset": 5},
          "text": {"field": "job"},
          "align": {"scale": "align", "field": "argmax.year"},
          "baseline": {"value": "middle"}
        }
      }
    }
  ]
}\n{
  "$schema": "https://vega.github.io/schema/vega/v5.json",
  "description": "A searchable, stacked area chart of U.S. occupations from 1850 to 2000.",
  "width": 800,
  "height": 500,
  "padding": 5,

  "signals": [
    {
      "name": "sex", "value": "all",
      "bind": {"input": "radio", "options": ["men", "women", "all"]}
    },
    {
      "name": "query", "value": "",
      "on": [
        {"events": "area:click!", "update": "datum.job"},
        {"events": "dblclick!", "update": "''"}
      ],
      "bind": {"input": "text", "placeholder": "search", "autocomplete": "off"}
    }
  ],

  "data": [
    {
      "name": "jobs",
      "url": "data/jobs.json",
      "transform": [
        {
          "type": "filter",
          "expr": "(sex === 'all' || datum.sex === sex) && (!query || test(regexp(query,'i'), datum.job))"
        },
        {
          "type": "stack",
          "field": "perc",
          "groupby": ["year"],
          "sort": {
            "field": ["job", "sex"],
            "order": ["descending", "descending"]
          }
        }
      ]
    },
    {
      "name": "series",
      "source": "jobs",
      "transform": [
        {
          "type": "aggregate",
          "groupby": ["job", "sex"],
          "fields": ["perc", "perc"],
          "ops": ["sum", "argmax"],
          "as": ["sum", "argmax"]
        }
      ]
    }
  ],

  "scales": [
    {
      "name": "x",
      "type": "linear",
      "range": "width",
      "zero": false, "round": true,
      "domain": {"data": "jobs", "field": "year"}
    },
    {
      "name": "y",
      "type": "linear",
      "range": "height", "round": true, "zero": true,
      "domain": {"data": "jobs", "field": "y1"}
    },
    {
      "name": "color",
      "type": "ordinal",
      "domain": ["men", "women"],
      "range": ["#33f", "#f33"]
    },
    {
      "name": "alpha",
      "type": "linear", "zero": true,
      "domain": {"data": "series", "field": "sum"},
      "range": [0.4, 0.8]
    },
    {
      "name": "font",
      "type": "sqrt",
      "range": [0, 20], "round": true, "zero": true,
      "domain": {"data": "series", "field": "argmax.perc"}
    },
    {
      "name": "opacity",
      "type": "quantile",
      "range": [0, 0, 0, 0, 0, 0.1, 0.2, 0.4, 0.7, 1.0],
      "domain": {"data": "series", "field": "argmax.perc"}
    },
    {
      "name": "align",
      "type": "quantize",
      "range": ["left", "center", "right"], "zero": false,
      "domain": [1730, 2130]
    },
    {
      "name": "offset",
      "type": "quantize",
      "range": [6, 0, -6], "zero": false,
      "domain": [1730, 2130]
    }
  ],

  "axes": [
    {
      "orient": "bottom", "scale": "x", "format": "d", "tickCount": 15
    },
    {
      "orient": "right", "scale": "y", "format": "%",
      "grid": true, "domain": false, "tickSize": 12,
      "encode": {
        "grid": {"enter": {"stroke": {"value": "#ccc"}}},
        "ticks": {"enter": {"stroke": {"value": "#ccc"}}}
      }
    }
  ],

  "marks": [
    {
      "type": "group",
      "from": {
        "data": "series",
        "facet": {
          "name": "facet",
          "data": "jobs",
          "groupby": ["job", "sex"]
        }
      },

      "marks": [
        {
          "type": "area",
          "from": {"data": "facet"},
          "encode": {
            "update": {
              "x": {"scale": "x", "field": "year"},
              "y": {"scale": "y", "field": "y0"},
              "y2": {"scale": "y", "field": "y1"},
              "fill": {"scale": "color", "field": "sex"},
              "fillOpacity": {"scale": "alpha", "field": {"parent": "sum"}}
            },
            "hover": {
              "fillOpacity": {"value": 0.2}
            }
          }
        }
      ]
    },
    {
      "type": "text",
      "from": {"data": "series"},
      "interactive": false,
      "encode": {
        "update": {
          "x": {"scale": "x", "field": "argmax.year"},
          "dx": {"scale": "offset", "field": "argmax.year"},
          "y": {"signal": "scale('y', 0.5 * (datum.argmax.y0 + datum.argmax.y1))"},
          "fill": {"value": "#000"},
          "fillOpacity": {"scale": "opacity", "field": "argmax.perc"},
          "fontSize": {"scale": "font", "field": "argmax.perc", "offset": 5},
          "text": {"field": "job"},
          "align": {"scale": "align", "field": "argmax.year"},
          "baseline": {"value": "middle"}
        }
      }
    }
  ]
}\n"https://vega.github.io/schema/vega/v5.json"\n"A searchable, stacked area chart of U.S. occupations from 1850 to 2000."\n"(sex === 'all' || datum.sex === sex) && (!query || test(regexp(query,'i'), datum.job))"\n"scale('y', 0.5 * (datum.argmax.y0 + datum.argmax.y1))"\n\n\nVega
            
              Vega-Lite
              Altair
              Vega-Lite API
            
          
          
            
              Examples
              Tutorials
              Documentation
              Usage
              About
            
            
              GitHub
              Try Online
            
          
        
      

      
        

  
  
    Pie Chart Example
    A pie chart encodes proportional differences among a set of numeric values as the angular extent and area of a circular slice.




  
  View Source
  Export PNG
  Export SVG






  View in Online Vega Editor


Vega JSON Specification <>

{
  "$schema": "https://vega.github.io/schema/vega/v5.json",
  "description": "A basic pie chart example.",
  "width": 200,
  "height": 200,
  "autosize": "none",

  "signals": [
    {
      "name": "startAngle", "value": 0,
      "bind": {"input": "range", "min": 0, "max": 6.29, "step": 0.01}
    },
    {
      "name": "endAngle", "value": 6.29,
      "bind": {"input": "range", "min": 0, "max": 6.29, "step": 0.01}
    },
    {
      "name": "padAngle", "value": 0,
      "bind": {"input": "range", "min": 0, "max": 0.1}
    },
    {
      "name": "innerRadius", "value": 0,
      "bind": {"input": "range", "min": 0, "max": 90, "step": 1}
    },
    {
      "name": "cornerRadius", "value": 0,
      "bind": {"input": "range", "min": 0, "max": 10, "step": 0.5}
    },
    {
      "name": "sort", "value": false,
      "bind": {"input": "checkbox"}
    }
  ],

  "data": [
    {
      "name": "table",
      "values": [
        {"id": 1, "field": 4},
        {"id": 2, "field": 6},
        {"id": 3, "field": 10},
        {"id": 4, "field": 3},
        {"id": 5, "field": 7},
        {"id": 6, "field": 8}
      ],
      "transform": [
        {
          "type": "pie",
          "field": "field",
          "startAngle": {"signal": "startAngle"},
          "endAngle": {"signal": "endAngle"},
          "sort": {"signal": "sort"}
        }
      ]
    }
  ],

  "scales": [
    {
      "name": "color",
      "type": "ordinal",
      "domain": {"data": "table", "field": "id"},
      "range": {"scheme": "category20"}
    }
  ],

  "marks": [
    {
      "type": "arc",
      "from": {"data": "table"},
      "encode": {
        "enter": {
          "fill": {"scale": "color", "field": "id"},
          "x": {"signal": "width / 2"},
          "y": {"signal": "height / 2"}
        },
        "update": {
          "startAngle": {"field": "startAngle"},
          "endAngle": {"field": "endAngle"},
          "padAngle": {"signal": "padAngle"},
          "innerRadius": {"signal": "innerRadius"},
          "outerRadius": {"signal": "width / 2"},
          "cornerRadius": {"signal": "cornerRadius"}
        }
      }
    }
  ]
}\nVega
            
              Vega-Lite
              Altair
              Vega-Lite API\nVega-Lite
              Altair
              Vega-Lite API\nExamples
              Tutorials
              Documentation
              Usage
              About
            
            
              GitHub
              Try Online\nExamples
              Tutorials
              Documentation
              Usage
              About\nGitHub
              Try Online\nPie Chart Example
    A pie chart encodes proportional differences among a set of numeric values as the angular extent and area of a circular slice.




  
  View Source
  Export PNG
  Export SVG






  View in Online Vega Editor


Vega JSON Specification <>

{
  "$schema": "https://vega.github.io/schema/vega/v5.json",
  "description": "A basic pie chart example.",
  "width": 200,
  "height": 200,
  "autosize": "none",

  "signals": [
    {
      "name": "startAngle", "value": 0,
      "bind": {"input": "range", "min": 0, "max": 6.29, "step": 0.01}
    },
    {
      "name": "endAngle", "value": 6.29,
      "bind": {"input": "range", "min": 0, "max": 6.29, "step": 0.01}
    },
    {
      "name": "padAngle", "value": 0,
      "bind": {"input": "range", "min": 0, "max": 0.1}
    },
    {
      "name": "innerRadius", "value": 0,
      "bind": {"input": "range", "min": 0, "max": 90, "step": 1}
    },
    {
      "name": "cornerRadius", "value": 0,
      "bind": {"input": "range", "min": 0, "max": 10, "step": 0.5}
    },
    {
      "name": "sort", "value": false,
      "bind": {"input": "checkbox"}
    }
  ],

  "data": [
    {
      "name": "table",
      "values": [
        {"id": 1, "field": 4},
        {"id": 2, "field": 6},
        {"id": 3, "field": 10},
        {"id": 4, "field": 3},
        {"id": 5, "field": 7},
        {"id": 6, "field": 8}
      ],
      "transform": [
        {
          "type": "pie",
          "field": "field",
          "startAngle": {"signal": "startAngle"},
          "endAngle": {"signal": "endAngle"},
          "sort": {"signal": "sort"}
        }
      ]
    }
  ],

  "scales": [
    {
      "name": "color",
      "type": "ordinal",
      "domain": {"data": "table", "field": "id"},
      "range": {"scheme": "category20"}
    }
  ],

  "marks": [
    {
      "type": "arc",
      "from": {"data": "table"},
      "encode": {
        "enter": {
          "fill": {"scale": "color", "field": "id"},
          "x": {"signal": "width / 2"},
          "y": {"signal": "height / 2"}
        },
        "update": {
          "startAngle": {"field": "startAngle"},
          "endAngle": {"field": "endAngle"},
          "padAngle": {"signal": "padAngle"},
          "innerRadius": {"signal": "innerRadius"},
          "outerRadius": {"signal": "width / 2"},
          "cornerRadius": {"signal": "cornerRadius"}
        }
      }
    }
  ]
}\nA pie chart encodes proportional differences among a set of numeric values as the angular extent and area of a circular slice.\nView Source
  Export PNG
  Export SVG\nView Source
  Export PNG
  Export SVG\nView in Online Vega Editor\nView in Online Vega Editor\nVega JSON Specification <>\n{
  "$schema": "https://vega.github.io/schema/vega/v5.json",
  "description": "A basic pie chart example.",
  "width": 200,
  "height": 200,
  "autosize": "none",

  "signals": [
    {
      "name": "startAngle", "value": 0,
      "bind": {"input": "range", "min": 0, "max": 6.29, "step": 0.01}
    },
    {
      "name": "endAngle", "value": 6.29,
      "bind": {"input": "range", "min": 0, "max": 6.29, "step": 0.01}
    },
    {
      "name": "padAngle", "value": 0,
      "bind": {"input": "range", "min": 0, "max": 0.1}
    },
    {
      "name": "innerRadius", "value": 0,
      "bind": {"input": "range", "min": 0, "max": 90, "step": 1}
    },
    {
      "name": "cornerRadius", "value": 0,
      "bind": {"input": "range", "min": 0, "max": 10, "step": 0.5}
    },
    {
      "name": "sort", "value": false,
      "bind": {"input": "checkbox"}
    }
  ],

  "data": [
    {
      "name": "table",
      "values": [
        {"id": 1, "field": 4},
        {"id": 2, "field": 6},
        {"id": 3, "field": 10},
        {"id": 4, "field": 3},
        {"id": 5, "field": 7},
        {"id": 6, "field": 8}
      ],
      "transform": [
        {
          "type": "pie",
          "field": "field",
          "startAngle": {"signal": "startAngle"},
          "endAngle": {"signal": "endAngle"},
          "sort": {"signal": "sort"}
        }
      ]
    }
  ],

  "scales": [
    {
      "name": "color",
      "type": "ordinal",
      "domain": {"data": "table", "field": "id"},
      "range": {"scheme": "category20"}
    }
  ],

  "marks": [
    {
      "type": "arc",
      "from": {"data": "table"},
      "encode": {
        "enter": {
          "fill": {"scale": "color", "field": "id"},
          "x": {"signal": "width / 2"},
          "y": {"signal": "height / 2"}
        },
        "update": {
          "startAngle": {"field": "startAngle"},
          "endAngle": {"field": "endAngle"},
          "padAngle": {"signal": "padAngle"},
          "innerRadius": {"signal": "innerRadius"},
          "outerRadius": {"signal": "width / 2"},
          "cornerRadius": {"signal": "cornerRadius"}
        }
      }
    }
  ]
}\n{
  "$schema": "https://vega.github.io/schema/vega/v5.json",
  "description": "A basic pie chart example.",
  "width": 200,
  "height": 200,
  "autosize": "none",

  "signals": [
    {
      "name": "startAngle", "value": 0,
      "bind": {"input": "range", "min": 0, "max": 6.29, "step": 0.01}
    },
    {
      "name": "endAngle", "value": 6.29,
      "bind": {"input": "range", "min": 0, "max": 6.29, "step": 0.01}
    },
    {
      "name": "padAngle", "value": 0,
      "bind": {"input": "range", "min": 0, "max": 0.1}
    },
    {
      "name": "innerRadius", "value": 0,
      "bind": {"input": "range", "min": 0, "max": 90, "step": 1}
    },
    {
      "name": "cornerRadius", "value": 0,
      "bind": {"input": "range", "min": 0, "max": 10, "step": 0.5}
    },
    {
      "name": "sort", "value": false,
      "bind": {"input": "checkbox"}
    }
  ],

  "data": [
    {
      "name": "table",
      "values": [
        {"id": 1, "field": 4},
        {"id": 2, "field": 6},
        {"id": 3, "field": 10},
        {"id": 4, "field": 3},
        {"id": 5, "field": 7},
        {"id": 6, "field": 8}
      ],
      "transform": [
        {
          "type": "pie",
          "field": "field",
          "startAngle": {"signal": "startAngle"},
          "endAngle": {"signal": "endAngle"},
          "sort": {"signal": "sort"}
        }
      ]
    }
  ],

  "scales": [
    {
      "name": "color",
      "type": "ordinal",
      "domain": {"data": "table", "field": "id"},
      "range": {"scheme": "category20"}
    }
  ],

  "marks": [
    {
      "type": "arc",
      "from": {"data": "table"},
      "encode": {
        "enter": {
          "fill": {"scale": "color", "field": "id"},
          "x": {"signal": "width / 2"},
          "y": {"signal": "height / 2"}
        },
        "update": {
          "startAngle": {"field": "startAngle"},
          "endAngle": {"field": "endAngle"},
          "padAngle": {"signal": "padAngle"},
          "innerRadius": {"signal": "innerRadius"},
          "outerRadius": {"signal": "width / 2"},
          "cornerRadius": {"signal": "cornerRadius"}
        }
      }
    }
  ]
}\n"https://vega.github.io/schema/vega/v5.json"\n"A basic pie chart example."\n\n\nVega
            
              Vega-Lite
              Altair
              Vega-Lite API
            
          
          
            
              Examples
              Tutorials
              Documentation
              Usage
              About
            
            
              GitHub
              Try Online
            
          
        
      

      
        

  
  
    Donut Chart Example
    A donut chart encodes proportional differences among a set of numeric values using angular extents.




  
  View Source
  Export PNG
  Export SVG






  View in Online Vega Editor


Vega JSON Specification <>

{
  "$schema": "https://vega.github.io/schema/vega/v5.json",
  "description": "A basic donut chart example.",
  "width": 200,
  "height": 200,
  "autosize": "none",

  "signals": [
    {
      "name": "startAngle", "value": 0,
      "bind": {"input": "range", "min": 0, "max": 6.29, "step": 0.01}
    },
    {
      "name": "endAngle", "value": 6.29,
      "bind": {"input": "range", "min": 0, "max": 6.29, "step": 0.01}
    },
    {
      "name": "padAngle", "value": 0,
      "bind": {"input": "range", "min": 0, "max": 0.1}
    },
    {
      "name": "innerRadius", "value": 60,
      "bind": {"input": "range", "min": 0, "max": 90, "step": 1}
    },
    {
      "name": "cornerRadius", "value": 0,
      "bind": {"input": "range", "min": 0, "max": 10, "step": 0.5}
    },
    {
      "name": "sort", "value": false,
      "bind": {"input": "checkbox"}
    }
  ],

  "data": [
    {
      "name": "table",
      "values": [
        {"id": 1, "field": 4},
        {"id": 2, "field": 6},
        {"id": 3, "field": 10},
        {"id": 4, "field": 3},
        {"id": 5, "field": 7},
        {"id": 6, "field": 8}
      ],
      "transform": [
        {
          "type": "pie",
          "field": "field",
          "startAngle": {"signal": "startAngle"},
          "endAngle": {"signal": "endAngle"},
          "sort": {"signal": "sort"}
        }
      ]
    }
  ],

  "scales": [
    {
      "name": "color",
      "type": "ordinal",
      "domain": {"data": "table", "field": "id"},
      "range": {"scheme": "category20"}
    }
  ],

  "marks": [
    {
      "type": "arc",
      "from": {"data": "table"},
      "encode": {
        "enter": {
          "fill": {"scale": "color", "field": "id"},
          "x": {"signal": "width / 2"},
          "y": {"signal": "height / 2"}
        },
        "update": {
          "startAngle": {"field": "startAngle"},
          "endAngle": {"field": "endAngle"},
          "padAngle": {"signal": "padAngle"},
          "innerRadius": {"signal": "innerRadius"},
          "outerRadius": {"signal": "width / 2"},
          "cornerRadius": {"signal": "cornerRadius"}
        }
      }
    }
  ]
}\nVega
            
              Vega-Lite
              Altair
              Vega-Lite API\nVega-Lite
              Altair
              Vega-Lite API\nExamples
              Tutorials
              Documentation
              Usage
              About
            
            
              GitHub
              Try Online\nExamples
              Tutorials
              Documentation
              Usage
              About\nGitHub
              Try Online\nDonut Chart Example
    A donut chart encodes proportional differences among a set of numeric values using angular extents.




  
  View Source
  Export PNG
  Export SVG






  View in Online Vega Editor


Vega JSON Specification <>

{
  "$schema": "https://vega.github.io/schema/vega/v5.json",
  "description": "A basic donut chart example.",
  "width": 200,
  "height": 200,
  "autosize": "none",

  "signals": [
    {
      "name": "startAngle", "value": 0,
      "bind": {"input": "range", "min": 0, "max": 6.29, "step": 0.01}
    },
    {
      "name": "endAngle", "value": 6.29,
      "bind": {"input": "range", "min": 0, "max": 6.29, "step": 0.01}
    },
    {
      "name": "padAngle", "value": 0,
      "bind": {"input": "range", "min": 0, "max": 0.1}
    },
    {
      "name": "innerRadius", "value": 60,
      "bind": {"input": "range", "min": 0, "max": 90, "step": 1}
    },
    {
      "name": "cornerRadius", "value": 0,
      "bind": {"input": "range", "min": 0, "max": 10, "step": 0.5}
    },
    {
      "name": "sort", "value": false,
      "bind": {"input": "checkbox"}
    }
  ],

  "data": [
    {
      "name": "table",
      "values": [
        {"id": 1, "field": 4},
        {"id": 2, "field": 6},
        {"id": 3, "field": 10},
        {"id": 4, "field": 3},
        {"id": 5, "field": 7},
        {"id": 6, "field": 8}
      ],
      "transform": [
        {
          "type": "pie",
          "field": "field",
          "startAngle": {"signal": "startAngle"},
          "endAngle": {"signal": "endAngle"},
          "sort": {"signal": "sort"}
        }
      ]
    }
  ],

  "scales": [
    {
      "name": "color",
      "type": "ordinal",
      "domain": {"data": "table", "field": "id"},
      "range": {"scheme": "category20"}
    }
  ],

  "marks": [
    {
      "type": "arc",
      "from": {"data": "table"},
      "encode": {
        "enter": {
          "fill": {"scale": "color", "field": "id"},
          "x": {"signal": "width / 2"},
          "y": {"signal": "height / 2"}
        },
        "update": {
          "startAngle": {"field": "startAngle"},
          "endAngle": {"field": "endAngle"},
          "padAngle": {"signal": "padAngle"},
          "innerRadius": {"signal": "innerRadius"},
          "outerRadius": {"signal": "width / 2"},
          "cornerRadius": {"signal": "cornerRadius"}
        }
      }
    }
  ]
}\nA donut chart encodes proportional differences among a set of numeric values using angular extents.\nView Source
  Export PNG
  Export SVG\nView Source
  Export PNG
  Export SVG\nView in Online Vega Editor\nView in Online Vega Editor\nVega JSON Specification <>\n{
  "$schema": "https://vega.github.io/schema/vega/v5.json",
  "description": "A basic donut chart example.",
  "width": 200,
  "height": 200,
  "autosize": "none",

  "signals": [
    {
      "name": "startAngle", "value": 0,
      "bind": {"input": "range", "min": 0, "max": 6.29, "step": 0.01}
    },
    {
      "name": "endAngle", "value": 6.29,
      "bind": {"input": "range", "min": 0, "max": 6.29, "step": 0.01}
    },
    {
      "name": "padAngle", "value": 0,
      "bind": {"input": "range", "min": 0, "max": 0.1}
    },
    {
      "name": "innerRadius", "value": 60,
      "bind": {"input": "range", "min": 0, "max": 90, "step": 1}
    },
    {
      "name": "cornerRadius", "value": 0,
      "bind": {"input": "range", "min": 0, "max": 10, "step": 0.5}
    },
    {
      "name": "sort", "value": false,
      "bind": {"input": "checkbox"}
    }
  ],

  "data": [
    {
      "name": "table",
      "values": [
        {"id": 1, "field": 4},
        {"id": 2, "field": 6},
        {"id": 3, "field": 10},
        {"id": 4, "field": 3},
        {"id": 5, "field": 7},
        {"id": 6, "field": 8}
      ],
      "transform": [
        {
          "type": "pie",
          "field": "field",
          "startAngle": {"signal": "startAngle"},
          "endAngle": {"signal": "endAngle"},
          "sort": {"signal": "sort"}
        }
      ]
    }
  ],

  "scales": [
    {
      "name": "color",
      "type": "ordinal",
      "domain": {"data": "table", "field": "id"},
      "range": {"scheme": "category20"}
    }
  ],

  "marks": [
    {
      "type": "arc",
      "from": {"data": "table"},
      "encode": {
        "enter": {
          "fill": {"scale": "color", "field": "id"},
          "x": {"signal": "width / 2"},
          "y": {"signal": "height / 2"}
        },
        "update": {
          "startAngle": {"field": "startAngle"},
          "endAngle": {"field": "endAngle"},
          "padAngle": {"signal": "padAngle"},
          "innerRadius": {"signal": "innerRadius"},
          "outerRadius": {"signal": "width / 2"},
          "cornerRadius": {"signal": "cornerRadius"}
        }
      }
    }
  ]
}\n{
  "$schema": "https://vega.github.io/schema/vega/v5.json",
  "description": "A basic donut chart example.",
  "width": 200,
  "height": 200,
  "autosize": "none",

  "signals": [
    {
      "name": "startAngle", "value": 0,
      "bind": {"input": "range", "min": 0, "max": 6.29, "step": 0.01}
    },
    {
      "name": "endAngle", "value": 6.29,
      "bind": {"input": "range", "min": 0, "max": 6.29, "step": 0.01}
    },
    {
      "name": "padAngle", "value": 0,
      "bind": {"input": "range", "min": 0, "max": 0.1}
    },
    {
      "name": "innerRadius", "value": 60,
      "bind": {"input": "range", "min": 0, "max": 90, "step": 1}
    },
    {
      "name": "cornerRadius", "value": 0,
      "bind": {"input": "range", "min": 0, "max": 10, "step": 0.5}
    },
    {
      "name": "sort", "value": false,
      "bind": {"input": "checkbox"}
    }
  ],

  "data": [
    {
      "name": "table",
      "values": [
        {"id": 1, "field": 4},
        {"id": 2, "field": 6},
        {"id": 3, "field": 10},
        {"id": 4, "field": 3},
        {"id": 5, "field": 7},
        {"id": 6, "field": 8}
      ],
      "transform": [
        {
          "type": "pie",
          "field": "field",
          "startAngle": {"signal": "startAngle"},
          "endAngle": {"signal": "endAngle"},
          "sort": {"signal": "sort"}
        }
      ]
    }
  ],

  "scales": [
    {
      "name": "color",
      "type": "ordinal",
      "domain": {"data": "table", "field": "id"},
      "range": {"scheme": "category20"}
    }
  ],

  "marks": [
    {
      "type": "arc",
      "from": {"data": "table"},
      "encode": {
        "enter": {
          "fill": {"scale": "color", "field": "id"},
          "x": {"signal": "width / 2"},
          "y": {"signal": "height / 2"}
        },
        "update": {
          "startAngle": {"field": "startAngle"},
          "endAngle": {"field": "endAngle"},
          "padAngle": {"signal": "padAngle"},
          "innerRadius": {"signal": "innerRadius"},
          "outerRadius": {"signal": "width / 2"},
          "cornerRadius": {"signal": "cornerRadius"}
        }
      }
    }
  ]
}\n"https://vega.github.io/schema/vega/v5.json"\n"A basic donut chart example."\n\n\nVega
            
              Vega-Lite
              Altair
              Vega-Lite API
            
          
          
            
              Examples
              Tutorials
              Documentation
              Usage
              About
            
            
              GitHub
              Try Online
            
          
        
      

      
        

  
  
    Labelled Donut Chart Example
    A donut chart with non overlapping labels using native Vega transforms.

This Vega example made by David Bacci @PBI-David.




  
  View Source
  Export PNG
  Export SVG






  View in Online Vega Editor


Vega JSON Specification <>

{
  "$schema": "https://vega.github.io/schema/vega/v6.json",
  "description": "Donut with non-overlapping labels.",
  "width": 200,
  "height": 200,
  "autosize": "pad",
  "padding": 30,
  "signals": [
    {
      "name": "startAngle",
      "value": 0,
      "bind": {"input": "range", "min": 0, "max": 6.29, "step": 0.01}
    },
    {
      "name": "sortField",
      "update": "''",
      "description": "Sort field if desired"
    },
    {
      "name": "sortOrder",
      "update": "''",
      "description": "Sort order if desired (ascending or descending)"
    },
    {
      "name": "labelFontSize",
      "init": "12",
      "description": "The font size used for labels"
    },
    {
      "name": "labelHeight",
      "update": "labelFontSize",
      "description": "This is approximately the same as the label font size but can be adjusted if you want extra padding"
    },
    {"name": "innerRadius", "update": "60"},
    {"name": "outerRadius", "update": "100"},
    {
      "name": "counter",
      "description": "Counter used to loop through an array",
      "value": 0,
      "on": [
        {
          "events": {"type": "timer", "throttle": 0},
          "update": "counter<length(data('labelPositions'))?counter + 1:counter"
        },
        {"events": {"signal": "leftRightCount"}, "update": "0"}
      ]
    },
    {
      "name": "shiftArray",
      "description": "An array of shift positions",
      "update": "{right: leftRightCount.right!=0? pluck(data('labelPositions')[0]['shiftArray'],'shift'):[], left: leftRightCount.left!=0? pluck(data('labelPositions')[leftRightCount.right]['shiftArray'],'shift'):[]}"
    },
    {
      "name": "leftRightCountArray",
      "description": "Array of label sides",
      "update": "reverse(sort( pluck( data('labelPositions'), 'side')))"
    },
    {
      "name": "leftRightCount",
      "description": "Count of  label sides",
      "update": "{right:lastindexof(leftRightCountArray,'right')+1,left:length(leftRightCountArray)- (lastindexof(leftRightCountArray,'right')+1)}"
    },
    {
      "name": "p1",
      "description": "Used to loop through position array one element at a time with a running sum but reseting the counter to 0 if it ever goes negative",
      "value": {"right": 0, "left": 0},
      "on": [
        {
          "events": {"signal": "leftRightCount"},
          "update": "{'right': 0, 'left': 0}"
        },
        {
          "events": {"signal": "counter"},
          "update": "{right:shiftArray.right[counter-1]+p1.right<0?0:shiftArray.right[counter-1]+p1.right, left:shiftArray.left[counter-1]+p1.left<0?0:shiftArray.left[counter-1]+p1.left}",
          "force": true
        }
      ]
    },
    {
      "name": "p2",
      "description": "Used to reassemble the position array as a string with final shift positions",
      "value": {"right": [], "left": []},
      "on": [
        {
          "events": {"signal": "leftRightCount"},
          "update": "{'right': [], 'left': []}"
        },
        {
          "events": {"signal": "p1"},
          "update": "{right:length(p2.right)!=0? p1.right+','+p2.right:p1.right,left:length(p2.left)!=0? p1.left+','+p2.left:p1.left}"
        }
      ]
    },
    {
      "name": "shiftArrayRunning",
      "description": "Converts a string to an array and reverses",
      "update": "{right:reverse(split(p2.right,',')),left:reverse(split(p2.left,','))}"
    }
  ],
  "data": [
    {
      "name": "table",
      "values": [
        {"id": "United States", "value": 1},
        {"id": "France", "value": 1},
        {"id": "Germany", "value": 1},
        {"id": "Italy", "value": 1},
        {"id": "UK", "value": 1},
        {"id": "Canada", "value": 10},
        {"id": "China", "value": 3},
        {"id": "India", "value": 7},
        {"id": "Argentina", "value": 8}
      ],
      "transform": [
        {
          "type": "collect",
          "sort": {
            "field": {"signal": "sortField"},
            "order": {"signal": "sortOrder"}
          }
        },
        {
          "type": "pie",
          "field": "value",
          "startAngle": {"signal": "startAngle"},
          "endAngle": {"signal": "round((2*PI)*10000)/10000+startAngle"}
        },
        {
          "type": "formula",
          "as": "middleAngle",
          "expr": " (((datum.endAngle - datum.startAngle)/2) + datum.startAngle)-PI/2"
        },
        {
          "type": "formula",
          "as": "side",
          "expr": "datum.middleAngle + PI/2  <= PI || datum.middleAngle + PI/2 >= 2*PI && datum.middleAngle + PI/2 <= PI*3?'right':'left'"
        },
        {
          "type": "formula",
          "as": "x1",
          "expr": " (outerRadius*cos(datum.middleAngle))+outerRadius "
        },
        {
          "type": "formula",
          "as": "y1",
          "expr": " (outerRadius*sin(datum.middleAngle))+outerRadius "
        },
        {
          "type": "formula",
          "as": "x2",
          "expr": " ((outerRadius+10)*cos(datum.middleAngle))+outerRadius "
        },
        {
          "type": "formula",
          "as": "y2",
          "expr": " ((outerRadius+10)*sin(datum.middleAngle))+outerRadius "
        },
        {
          "type": "formula",
          "as": "x3",
          "expr": "datum.side== 'right'?width+20:-20"
        },
        {"type": "formula", "as": "bin", "expr": "0"}
      ]
    },
    {
      "name": "leftExt",
      "source": ["table"],
      "transform": [
        {"type": "filter", "expr": "datum.side=='left'"},
        {"type": "extent", "field": "y2", "signal": "leftExt"}
      ]
    },
    {
      "name": "rightExt",
      "source": ["table"],
      "transform": [
        {"type": "filter", "expr": "datum.side=='right'"},
        {"type": "extent", "field": "y2", "signal": "rightExt"}
      ]
    },
    {
      "name": "labelSequenceRight",
      "transform": [
        {
          "type": "sequence",
          "start": {"signal": "rightExt[0]"},
          "stop": {"signal": "(rightExt[1]+labelHeight)"},
          "step": {"signal": "labelHeight"},
          "as": "bin"
        },
        {"type": "formula", "expr": "'right'", "as": "side"}
      ]
    },
    {
      "name": "labelSequenceLeft",
      "transform": [
        {
          "type": "sequence",
          "start": {"signal": "leftExt[0]"},
          "stop": {"signal": "(leftExt[1]+labelHeight)"},
          "step": {"signal": "labelHeight"},
          "as": "bin"
        },
        {"type": "formula", "expr": "'left'", "as": "side"}
      ]
    },
    {
      "name": "labelBinsRight",
      "source": ["rightExt", "labelSequenceRight"],
      "transform": [
        {
          "type": "bin",
          "field": "y2",
          "step": {"signal": "labelHeight"},
          "extent": {"signal": "rightExt"},
          "interval": false,
          "as": ["binTemp", "bin1"],
          "nice": false
        },
        {
          "type": "formula",
          "expr": "datum.bin==0?datum.binTemp:datum.bin",
          "as": "bin"
        }
      ]
    },
    {
      "name": "labelBinsLeft",
      "source": ["leftExt", "labelSequenceLeft"],
      "transform": [
        {
          "type": "bin",
          "field": "y2",
          "step": {"signal": "labelHeight"},
          "extent": {"signal": "leftExt"},
          "interval": false,
          "as": ["binTemp", "bin1"],
          "nice": false
        },
        {
          "type": "formula",
          "expr": "datum.bin==0?datum.binTemp:datum.bin",
          "as": "bin"
        }
      ]
    },
    {
      "name": "labelPositions",
      "source": ["labelBinsLeft", "labelBinsRight"],
      "transform": [
        {
          "type": "joinaggregate",
          "ops": ["count"],
          "as": ["count"],
          "groupby": ["side", "bin"]
        },
        {"type": "filter", "expr": "datum.value != null || datum.count == 1"},
        {"type": "formula", "expr": "datum.count-1", "as": "count"},
        {
          "type": "collect",
          "sort": {
            "field": ["side", "bin"],
            "order": ["descending", "ascending"]
          }
        },
        {
          "type": "window",
          "sort": {"field": ["bin", "y2"], "order": ["ascending", "ascending"]},
          "ops": ["row_number"],
          "as": ["index"],
          "groupby": ["side"]
        },
        {
          "type": "window",
          "sort": {"field": "index", "order": "ascending"},
          "ops": ["row_number"],
          "groupby": ["side", "bin"]
        },
        {
          "type": "formula",
          "expr": "datum.value==0?0:datum.row_number",
          "as": "row_number"
        },
        {
          "type": "formula",
          "expr": "datum.value==null?-labelHeight:datum.row_number==1?0:labelHeight",
          "as": "shift"
        },
        {
          "type": "collect",
          "sort": {
            "field": ["side", "index"],
            "order": ["descending", "ascending"]
          }
        },
        {
          "type": "joinaggregate",
          "ops": ["values"],
          "as": ["shiftArray"],
          "fields": ["shift"],
          "groupby": ["side"]
        }
      ]
    },
    {
      "name": "labelPositionsFinal",
      "source": ["labelPositions"],
      "transform": [
        {
          "type": "collect",
          "sort": {
            "field": ["side", "index"],
            "order": ["descending", "ascending"]
          }
        },
        {
          "type": "formula",
          "expr": "datum.side=='right'?toNumber(shiftArrayRunning.right[datum.index-1]):toNumber(shiftArrayRunning.left[datum.index-1])",
          "as": "shiftArrayRunning"
        },
        {
          "type": "formula",
          "expr": "datum.shiftArrayRunning+datum.bin",
          "as": "binShifted"
        },
        {
          "type": "formula",
          "as": "x4",
          "expr": "datum.side== 'right'?width+25:-25"
        },
        {
          "type": "window",
          "sort": {"field": "index", "order": "ascending"},
          "ops": ["lead"],
          "fields": ["shift"],
          "groupby": ["side"]
        },
        {
          "type": "formula",
          "as": "y4",
          "expr": "datum.y2>datum.binShifted&&datum.lead_shift<0?datum.y2:datum.binShifted"
        },
        {
          "type": "formula",
          "as": "labelPath",
          "expr": "datum.value==null?'': 'M '+ datum.x1 + ' ' + datum.y1 + 'L'+ datum.x2 + ' ' + datum.y2 + ' H'+ datum.x3  +'L '+ datum.x4 + ' ' + datum.y4 "
        }
      ]
    }
  ],
  "scales": [
    {
      "name": "color",
      "type": "ordinal",
      "domain": {"data": "table", "field": "id"},
      "range": {"scheme": "category20"}
    }
  ],
  "marks": [
    {
      "type": "arc",
      "from": {"data": "table"},
      "encode": {
        "enter": {
          "fill": {"scale": "color", "field": "id"},
          "x": {"signal": "width / 2"},
          "y": {"signal": "height / 2"},
          "stroke": {"value": "white"}
        },
        "update": {
          "startAngle": {"field": "startAngle"},
          "endAngle": {"field": "endAngle"},
          "innerRadius": {"signal": "innerRadius"},
          "outerRadius": {"signal": "outerRadius"}
        }
      }
    },
    {
      "type": "path",
      "name": "labelPath",
      "from": {"data": "labelPositionsFinal"},
      "encode": {
        "update": {
          "strokeWidth": {"value": 1},
          "path": {"field": "labelPath"},
          "stroke": {"value": "grey"},
          "opacity": {"value": 0.7}
        }
      }
    },
    {
      "type": "rect",
      "from": {"data": "labelPositionsFinal"},
      "description": "Debug boxes. Opacity is set to zero but can be changed to better understand how the bins are being layed out",
      "encode": {
        "update": {
          "x": {"field": "x4"},
          "y": {"field": "y4"},
          "width": {"value": 20},
          "height": {"signal": "labelHeight"},
          "strokeWidth": {"value": 2},
          "stroke": {"value": "grey"},
          "fill": {"value": "#4682b4"},
          "opacity": {"signal": "datum.value==null?0:0"}
        }
      }
    },
    {
      "type": "text",
      "name": "labels",
      "from": {"data": "labelPositionsFinal"},
      "encode": {
        "update": {
          "text": {"field": "id"},
          "opacity": {"value": 0.6},
          "fill": {"value": "black"},
          "baseline": {"value": "middle"},
          "align": {"signal": "datum.side=='left'?'right':'left'"},
          "dx": {"signal": "datum.side=='left'?-3:3"},
          "x": {"field": "x4"},
          "y": {"field": "y4"},
          "fontSize": {"signal": "labelFontSize"}
        }
      }
    }
  ]
}\nVega
            
              Vega-Lite
              Altair
              Vega-Lite API\nVega-Lite
              Altair
              Vega-Lite API\nExamples
              Tutorials
              Documentation
              Usage
              About
            
            
              GitHub
              Try Online\nExamples
              Tutorials
              Documentation
              Usage
              About\nGitHub
              Try Online\nLabelled Donut Chart Example
    A donut chart with non overlapping labels using native Vega transforms.

This Vega example made by David Bacci @PBI-David.




  
  View Source
  Export PNG
  Export SVG






  View in Online Vega Editor


Vega JSON Specification <>

{
  "$schema": "https://vega.github.io/schema/vega/v6.json",
  "description": "Donut with non-overlapping labels.",
  "width": 200,
  "height": 200,
  "autosize": "pad",
  "padding": 30,
  "signals": [
    {
      "name": "startAngle",
      "value": 0,
      "bind": {"input": "range", "min": 0, "max": 6.29, "step": 0.01}
    },
    {
      "name": "sortField",
      "update": "''",
      "description": "Sort field if desired"
    },
    {
      "name": "sortOrder",
      "update": "''",
      "description": "Sort order if desired (ascending or descending)"
    },
    {
      "name": "labelFontSize",
      "init": "12",
      "description": "The font size used for labels"
    },
    {
      "name": "labelHeight",
      "update": "labelFontSize",
      "description": "This is approximately the same as the label font size but can be adjusted if you want extra padding"
    },
    {"name": "innerRadius", "update": "60"},
    {"name": "outerRadius", "update": "100"},
    {
      "name": "counter",
      "description": "Counter used to loop through an array",
      "value": 0,
      "on": [
        {
          "events": {"type": "timer", "throttle": 0},
          "update": "counter<length(data('labelPositions'))?counter + 1:counter"
        },
        {"events": {"signal": "leftRightCount"}, "update": "0"}
      ]
    },
    {
      "name": "shiftArray",
      "description": "An array of shift positions",
      "update": "{right: leftRightCount.right!=0? pluck(data('labelPositions')[0]['shiftArray'],'shift'):[], left: leftRightCount.left!=0? pluck(data('labelPositions')[leftRightCount.right]['shiftArray'],'shift'):[]}"
    },
    {
      "name": "leftRightCountArray",
      "description": "Array of label sides",
      "update": "reverse(sort( pluck( data('labelPositions'), 'side')))"
    },
    {
      "name": "leftRightCount",
      "description": "Count of  label sides",
      "update": "{right:lastindexof(leftRightCountArray,'right')+1,left:length(leftRightCountArray)- (lastindexof(leftRightCountArray,'right')+1)}"
    },
    {
      "name": "p1",
      "description": "Used to loop through position array one element at a time with a running sum but reseting the counter to 0 if it ever goes negative",
      "value": {"right": 0, "left": 0},
      "on": [
        {
          "events": {"signal": "leftRightCount"},
          "update": "{'right': 0, 'left': 0}"
        },
        {
          "events": {"signal": "counter"},
          "update": "{right:shiftArray.right[counter-1]+p1.right<0?0:shiftArray.right[counter-1]+p1.right, left:shiftArray.left[counter-1]+p1.left<0?0:shiftArray.left[counter-1]+p1.left}",
          "force": true
        }
      ]
    },
    {
      "name": "p2",
      "description": "Used to reassemble the position array as a string with final shift positions",
      "value": {"right": [], "left": []},
      "on": [
        {
          "events": {"signal": "leftRightCount"},
          "update": "{'right': [], 'left': []}"
        },
        {
          "events": {"signal": "p1"},
          "update": "{right:length(p2.right)!=0? p1.right+','+p2.right:p1.right,left:length(p2.left)!=0? p1.left+','+p2.left:p1.left}"
        }
      ]
    },
    {
      "name": "shiftArrayRunning",
      "description": "Converts a string to an array and reverses",
      "update": "{right:reverse(split(p2.right,',')),left:reverse(split(p2.left,','))}"
    }
  ],
  "data": [
    {
      "name": "table",
      "values": [
        {"id": "United States", "value": 1},
        {"id": "France", "value": 1},
        {"id": "Germany", "value": 1},
        {"id": "Italy", "value": 1},
        {"id": "UK", "value": 1},
        {"id": "Canada", "value": 10},
        {"id": "China", "value": 3},
        {"id": "India", "value": 7},
        {"id": "Argentina", "value": 8}
      ],
      "transform": [
        {
          "type": "collect",
          "sort": {
            "field": {"signal": "sortField"},
            "order": {"signal": "sortOrder"}
          }
        },
        {
          "type": "pie",
          "field": "value",
          "startAngle": {"signal": "startAngle"},
          "endAngle": {"signal": "round((2*PI)*10000)/10000+startAngle"}
        },
        {
          "type": "formula",
          "as": "middleAngle",
          "expr": " (((datum.endAngle - datum.startAngle)/2) + datum.startAngle)-PI/2"
        },
        {
          "type": "formula",
          "as": "side",
          "expr": "datum.middleAngle + PI/2  <= PI || datum.middleAngle + PI/2 >= 2*PI && datum.middleAngle + PI/2 <= PI*3?'right':'left'"
        },
        {
          "type": "formula",
          "as": "x1",
          "expr": " (outerRadius*cos(datum.middleAngle))+outerRadius "
        },
        {
          "type": "formula",
          "as": "y1",
          "expr": " (outerRadius*sin(datum.middleAngle))+outerRadius "
        },
        {
          "type": "formula",
          "as": "x2",
          "expr": " ((outerRadius+10)*cos(datum.middleAngle))+outerRadius "
        },
        {
          "type": "formula",
          "as": "y2",
          "expr": " ((outerRadius+10)*sin(datum.middleAngle))+outerRadius "
        },
        {
          "type": "formula",
          "as": "x3",
          "expr": "datum.side== 'right'?width+20:-20"
        },
        {"type": "formula", "as": "bin", "expr": "0"}
      ]
    },
    {
      "name": "leftExt",
      "source": ["table"],
      "transform": [
        {"type": "filter", "expr": "datum.side=='left'"},
        {"type": "extent", "field": "y2", "signal": "leftExt"}
      ]
    },
    {
      "name": "rightExt",
      "source": ["table"],
      "transform": [
        {"type": "filter", "expr": "datum.side=='right'"},
        {"type": "extent", "field": "y2", "signal": "rightExt"}
      ]
    },
    {
      "name": "labelSequenceRight",
      "transform": [
        {
          "type": "sequence",
          "start": {"signal": "rightExt[0]"},
          "stop": {"signal": "(rightExt[1]+labelHeight)"},
          "step": {"signal": "labelHeight"},
          "as": "bin"
        },
        {"type": "formula", "expr": "'right'", "as": "side"}
      ]
    },
    {
      "name": "labelSequenceLeft",
      "transform": [
        {
          "type": "sequence",
          "start": {"signal": "leftExt[0]"},
          "stop": {"signal": "(leftExt[1]+labelHeight)"},
          "step": {"signal": "labelHeight"},
          "as": "bin"
        },
        {"type": "formula", "expr": "'left'", "as": "side"}
      ]
    },
    {
      "name": "labelBinsRight",
      "source": ["rightExt", "labelSequenceRight"],
      "transform": [
        {
          "type": "bin",
          "field": "y2",
          "step": {"signal": "labelHeight"},
          "extent": {"signal": "rightExt"},
          "interval": false,
          "as": ["binTemp", "bin1"],
          "nice": false
        },
        {
          "type": "formula",
          "expr": "datum.bin==0?datum.binTemp:datum.bin",
          "as": "bin"
        }
      ]
    },
    {
      "name": "labelBinsLeft",
      "source": ["leftExt", "labelSequenceLeft"],
      "transform": [
        {
          "type": "bin",
          "field": "y2",
          "step": {"signal": "labelHeight"},
          "extent": {"signal": "leftExt"},
          "interval": false,
          "as": ["binTemp", "bin1"],
          "nice": false
        },
        {
          "type": "formula",
          "expr": "datum.bin==0?datum.binTemp:datum.bin",
          "as": "bin"
        }
      ]
    },
    {
      "name": "labelPositions",
      "source": ["labelBinsLeft", "labelBinsRight"],
      "transform": [
        {
          "type": "joinaggregate",
          "ops": ["count"],
          "as": ["count"],
          "groupby": ["side", "bin"]
        },
        {"type": "filter", "expr": "datum.value != null || datum.count == 1"},
        {"type": "formula", "expr": "datum.count-1", "as": "count"},
        {
          "type": "collect",
          "sort": {
            "field": ["side", "bin"],
            "order": ["descending", "ascending"]
          }
        },
        {
          "type": "window",
          "sort": {"field": ["bin", "y2"], "order": ["ascending", "ascending"]},
          "ops": ["row_number"],
          "as": ["index"],
          "groupby": ["side"]
        },
        {
          "type": "window",
          "sort": {"field": "index", "order": "ascending"},
          "ops": ["row_number"],
          "groupby": ["side", "bin"]
        },
        {
          "type": "formula",
          "expr": "datum.value==0?0:datum.row_number",
          "as": "row_number"
        },
        {
          "type": "formula",
          "expr": "datum.value==null?-labelHeight:datum.row_number==1?0:labelHeight",
          "as": "shift"
        },
        {
          "type": "collect",
          "sort": {
            "field": ["side", "index"],
            "order": ["descending", "ascending"]
          }
        },
        {
          "type": "joinaggregate",
          "ops": ["values"],
          "as": ["shiftArray"],
          "fields": ["shift"],
          "groupby": ["side"]
        }
      ]
    },
    {
      "name": "labelPositionsFinal",
      "source": ["labelPositions"],
      "transform": [
        {
          "type": "collect",
          "sort": {
            "field": ["side", "index"],
            "order": ["descending", "ascending"]
          }
        },
        {
          "type": "formula",
          "expr": "datum.side=='right'?toNumber(shiftArrayRunning.right[datum.index-1]):toNumber(shiftArrayRunning.left[datum.index-1])",
          "as": "shiftArrayRunning"
        },
        {
          "type": "formula",
          "expr": "datum.shiftArrayRunning+datum.bin",
          "as": "binShifted"
        },
        {
          "type": "formula",
          "as": "x4",
          "expr": "datum.side== 'right'?width+25:-25"
        },
        {
          "type": "window",
          "sort": {"field": "index", "order": "ascending"},
          "ops": ["lead"],
          "fields": ["shift"],
          "groupby": ["side"]
        },
        {
          "type": "formula",
          "as": "y4",
          "expr": "datum.y2>datum.binShifted&&datum.lead_shift<0?datum.y2:datum.binShifted"
        },
        {
          "type": "formula",
          "as": "labelPath",
          "expr": "datum.value==null?'': 'M '+ datum.x1 + ' ' + datum.y1 + 'L'+ datum.x2 + ' ' + datum.y2 + ' H'+ datum.x3  +'L '+ datum.x4 + ' ' + datum.y4 "
        }
      ]
    }
  ],
  "scales": [
    {
      "name": "color",
      "type": "ordinal",
      "domain": {"data": "table", "field": "id"},
      "range": {"scheme": "category20"}
    }
  ],
  "marks": [
    {
      "type": "arc",
      "from": {"data": "table"},
      "encode": {
        "enter": {
          "fill": {"scale": "color", "field": "id"},
          "x": {"signal": "width / 2"},
          "y": {"signal": "height / 2"},
          "stroke": {"value": "white"}
        },
        "update": {
          "startAngle": {"field": "startAngle"},
          "endAngle": {"field": "endAngle"},
          "innerRadius": {"signal": "innerRadius"},
          "outerRadius": {"signal": "outerRadius"}
        }
      }
    },
    {
      "type": "path",
      "name": "labelPath",
      "from": {"data": "labelPositionsFinal"},
      "encode": {
        "update": {
          "strokeWidth": {"value": 1},
          "path": {"field": "labelPath"},
          "stroke": {"value": "grey"},
          "opacity": {"value": 0.7}
        }
      }
    },
    {
      "type": "rect",
      "from": {"data": "labelPositionsFinal"},
      "description": "Debug boxes. Opacity is set to zero but can be changed to better understand how the bins are being layed out",
      "encode": {
        "update": {
          "x": {"field": "x4"},
          "y": {"field": "y4"},
          "width": {"value": 20},
          "height": {"signal": "labelHeight"},
          "strokeWidth": {"value": 2},
          "stroke": {"value": "grey"},
          "fill": {"value": "#4682b4"},
          "opacity": {"signal": "datum.value==null?0:0"}
        }
      }
    },
    {
      "type": "text",
      "name": "labels",
      "from": {"data": "labelPositionsFinal"},
      "encode": {
        "update": {
          "text": {"field": "id"},
          "opacity": {"value": 0.6},
          "fill": {"value": "black"},
          "baseline": {"value": "middle"},
          "align": {"signal": "datum.side=='left'?'right':'left'"},
          "dx": {"signal": "datum.side=='left'?-3:3"},
          "x": {"field": "x4"},
          "y": {"field": "y4"},
          "fontSize": {"signal": "labelFontSize"}
        }
      }
    }
  ]
}\nLabelled Donut Chart Example\nA donut chart with non overlapping labels using native Vega transforms.\nThis Vega example made by David Bacci @PBI-David.\nView Source
  Export PNG
  Export SVG\nView Source
  Export PNG
  Export SVG\nView in Online Vega Editor\nView in Online Vega Editor\nVega JSON Specification <>\n{
  "$schema": "https://vega.github.io/schema/vega/v6.json",
  "description": "Donut with non-overlapping labels.",
  "width": 200,
  "height": 200,
  "autosize": "pad",
  "padding": 30,
  "signals": [
    {
      "name": "startAngle",
      "value": 0,
      "bind": {"input": "range", "min": 0, "max": 6.29, "step": 0.01}
    },
    {
      "name": "sortField",
      "update": "''",
      "description": "Sort field if desired"
    },
    {
      "name": "sortOrder",
      "update": "''",
      "description": "Sort order if desired (ascending or descending)"
    },
    {
      "name": "labelFontSize",
      "init": "12",
      "description": "The font size used for labels"
    },
    {
      "name": "labelHeight",
      "update": "labelFontSize",
      "description": "This is approximately the same as the label font size but can be adjusted if you want extra padding"
    },
    {"name": "innerRadius", "update": "60"},
    {"name": "outerRadius", "update": "100"},
    {
      "name": "counter",
      "description": "Counter used to loop through an array",
      "value": 0,
      "on": [
        {
          "events": {"type": "timer", "throttle": 0},
          "update": "counter<length(data('labelPositions'))?counter + 1:counter"
        },
        {"events": {"signal": "leftRightCount"}, "update": "0"}
      ]
    },
    {
      "name": "shiftArray",
      "description": "An array of shift positions",
      "update": "{right: leftRightCount.right!=0? pluck(data('labelPositions')[0]['shiftArray'],'shift'):[], left: leftRightCount.left!=0? pluck(data('labelPositions')[leftRightCount.right]['shiftArray'],'shift'):[]}"
    },
    {
      "name": "leftRightCountArray",
      "description": "Array of label sides",
      "update": "reverse(sort( pluck( data('labelPositions'), 'side')))"
    },
    {
      "name": "leftRightCount",
      "description": "Count of  label sides",
      "update": "{right:lastindexof(leftRightCountArray,'right')+1,left:length(leftRightCountArray)- (lastindexof(leftRightCountArray,'right')+1)}"
    },
    {
      "name": "p1",
      "description": "Used to loop through position array one element at a time with a running sum but reseting the counter to 0 if it ever goes negative",
      "value": {"right": 0, "left": 0},
      "on": [
        {
          "events": {"signal": "leftRightCount"},
          "update": "{'right': 0, 'left': 0}"
        },
        {
          "events": {"signal": "counter"},
          "update": "{right:shiftArray.right[counter-1]+p1.right<0?0:shiftArray.right[counter-1]+p1.right, left:shiftArray.left[counter-1]+p1.left<0?0:shiftArray.left[counter-1]+p1.left}",
          "force": true
        }
      ]
    },
    {
      "name": "p2",
      "description": "Used to reassemble the position array as a string with final shift positions",
      "value": {"right": [], "left": []},
      "on": [
        {
          "events": {"signal": "leftRightCount"},
          "update": "{'right': [], 'left': []}"
        },
        {
          "events": {"signal": "p1"},
          "update": "{right:length(p2.right)!=0? p1.right+','+p2.right:p1.right,left:length(p2.left)!=0? p1.left+','+p2.left:p1.left}"
        }
      ]
    },
    {
      "name": "shiftArrayRunning",
      "description": "Converts a string to an array and reverses",
      "update": "{right:reverse(split(p2.right,',')),left:reverse(split(p2.left,','))}"
    }
  ],
  "data": [
    {
      "name": "table",
      "values": [
        {"id": "United States", "value": 1},
        {"id": "France", "value": 1},
        {"id": "Germany", "value": 1},
        {"id": "Italy", "value": 1},
        {"id": "UK", "value": 1},
        {"id": "Canada", "value": 10},
        {"id": "China", "value": 3},
        {"id": "India", "value": 7},
        {"id": "Argentina", "value": 8}
      ],
      "transform": [
        {
          "type": "collect",
          "sort": {
            "field": {"signal": "sortField"},
            "order": {"signal": "sortOrder"}
          }
        },
        {
          "type": "pie",
          "field": "value",
          "startAngle": {"signal": "startAngle"},
          "endAngle": {"signal": "round((2*PI)*10000)/10000+startAngle"}
        },
        {
          "type": "formula",
          "as": "middleAngle",
          "expr": " (((datum.endAngle - datum.startAngle)/2) + datum.startAngle)-PI/2"
        },
        {
          "type": "formula",
          "as": "side",
          "expr": "datum.middleAngle + PI/2  <= PI || datum.middleAngle + PI/2 >= 2*PI && datum.middleAngle + PI/2 <= PI*3?'right':'left'"
        },
        {
          "type": "formula",
          "as": "x1",
          "expr": " (outerRadius*cos(datum.middleAngle))+outerRadius "
        },
        {
          "type": "formula",
          "as": "y1",
          "expr": " (outerRadius*sin(datum.middleAngle))+outerRadius "
        },
        {
          "type": "formula",
          "as": "x2",
          "expr": " ((outerRadius+10)*cos(datum.middleAngle))+outerRadius "
        },
        {
          "type": "formula",
          "as": "y2",
          "expr": " ((outerRadius+10)*sin(datum.middleAngle))+outerRadius "
        },
        {
          "type": "formula",
          "as": "x3",
          "expr": "datum.side== 'right'?width+20:-20"
        },
        {"type": "formula", "as": "bin", "expr": "0"}
      ]
    },
    {
      "name": "leftExt",
      "source": ["table"],
      "transform": [
        {"type": "filter", "expr": "datum.side=='left'"},
        {"type": "extent", "field": "y2", "signal": "leftExt"}
      ]
    },
    {
      "name": "rightExt",
      "source": ["table"],
      "transform": [
        {"type": "filter", "expr": "datum.side=='right'"},
        {"type": "extent", "field": "y2", "signal": "rightExt"}
      ]
    },
    {
      "name": "labelSequenceRight",
      "transform": [
        {
          "type": "sequence",
          "start": {"signal": "rightExt[0]"},
          "stop": {"signal": "(rightExt[1]+labelHeight)"},
          "step": {"signal": "labelHeight"},
          "as": "bin"
        },
        {"type": "formula", "expr": "'right'", "as": "side"}
      ]
    },
    {
      "name": "labelSequenceLeft",
      "transform": [
        {
          "type": "sequence",
          "start": {"signal": "leftExt[0]"},
          "stop": {"signal": "(leftExt[1]+labelHeight)"},
          "step": {"signal": "labelHeight"},
          "as": "bin"
        },
        {"type": "formula", "expr": "'left'", "as": "side"}
      ]
    },
    {
      "name": "labelBinsRight",
      "source": ["rightExt", "labelSequenceRight"],
      "transform": [
        {
          "type": "bin",
          "field": "y2",
          "step": {"signal": "labelHeight"},
          "extent": {"signal": "rightExt"},
          "interval": false,
          "as": ["binTemp", "bin1"],
          "nice": false
        },
        {
          "type": "formula",
          "expr": "datum.bin==0?datum.binTemp:datum.bin",
          "as": "bin"
        }
      ]
    },
    {
      "name": "labelBinsLeft",
      "source": ["leftExt", "labelSequenceLeft"],
      "transform": [
        {
          "type": "bin",
          "field": "y2",
          "step": {"signal": "labelHeight"},
          "extent": {"signal": "leftExt"},
          "interval": false,
          "as": ["binTemp", "bin1"],
          "nice": false
        },
        {
          "type": "formula",
          "expr": "datum.bin==0?datum.binTemp:datum.bin",
          "as": "bin"
        }
      ]
    },
    {
      "name": "labelPositions",
      "source": ["labelBinsLeft", "labelBinsRight"],
      "transform": [
        {
          "type": "joinaggregate",
          "ops": ["count"],
          "as": ["count"],
          "groupby": ["side", "bin"]
        },
        {"type": "filter", "expr": "datum.value != null || datum.count == 1"},
        {"type": "formula", "expr": "datum.count-1", "as": "count"},
        {
          "type": "collect",
          "sort": {
            "field": ["side", "bin"],
            "order": ["descending", "ascending"]
          }
        },
        {
          "type": "window",
          "sort": {"field": ["bin", "y2"], "order": ["ascending", "ascending"]},
          "ops": ["row_number"],
          "as": ["index"],
          "groupby": ["side"]
        },
        {
          "type": "window",
          "sort": {"field": "index", "order": "ascending"},
          "ops": ["row_number"],
          "groupby": ["side", "bin"]
        },
        {
          "type": "formula",
          "expr": "datum.value==0?0:datum.row_number",
          "as": "row_number"
        },
        {
          "type": "formula",
          "expr": "datum.value==null?-labelHeight:datum.row_number==1?0:labelHeight",
          "as": "shift"
        },
        {
          "type": "collect",
          "sort": {
            "field": ["side", "index"],
            "order": ["descending", "ascending"]
          }
        },
        {
          "type": "joinaggregate",
          "ops": ["values"],
          "as": ["shiftArray"],
          "fields": ["shift"],
          "groupby": ["side"]
        }
      ]
    },
    {
      "name": "labelPositionsFinal",
      "source": ["labelPositions"],
      "transform": [
        {
          "type": "collect",
          "sort": {
            "field": ["side", "index"],
            "order": ["descending", "ascending"]
          }
        },
        {
          "type": "formula",
          "expr": "datum.side=='right'?toNumber(shiftArrayRunning.right[datum.index-1]):toNumber(shiftArrayRunning.left[datum.index-1])",
          "as": "shiftArrayRunning"
        },
        {
          "type": "formula",
          "expr": "datum.shiftArrayRunning+datum.bin",
          "as": "binShifted"
        },
        {
          "type": "formula",
          "as": "x4",
          "expr": "datum.side== 'right'?width+25:-25"
        },
        {
          "type": "window",
          "sort": {"field": "index", "order": "ascending"},
          "ops": ["lead"],
          "fields": ["shift"],
          "groupby": ["side"]
        },
        {
          "type": "formula",
          "as": "y4",
          "expr": "datum.y2>datum.binShifted&&datum.lead_shift<0?datum.y2:datum.binShifted"
        },
        {
          "type": "formula",
          "as": "labelPath",
          "expr": "datum.value==null?'': 'M '+ datum.x1 + ' ' + datum.y1 + 'L'+ datum.x2 + ' ' + datum.y2 + ' H'+ datum.x3  +'L '+ datum.x4 + ' ' + datum.y4 "
        }
      ]
    }
  ],
  "scales": [
    {
      "name": "color",
      "type": "ordinal",
      "domain": {"data": "table", "field": "id"},
      "range": {"scheme": "category20"}
    }
  ],
  "marks": [
    {
      "type": "arc",
      "from": {"data": "table"},
      "encode": {
        "enter": {
          "fill": {"scale": "color", "field": "id"},
          "x": {"signal": "width / 2"},
          "y": {"signal": "height / 2"},
          "stroke": {"value": "white"}
        },
        "update": {
          "startAngle": {"field": "startAngle"},
          "endAngle": {"field": "endAngle"},
          "innerRadius": {"signal": "innerRadius"},
          "outerRadius": {"signal": "outerRadius"}
        }
      }
    },
    {
      "type": "path",
      "name": "labelPath",
      "from": {"data": "labelPositionsFinal"},
      "encode": {
        "update": {
          "strokeWidth": {"value": 1},
          "path": {"field": "labelPath"},
          "stroke": {"value": "grey"},
          "opacity": {"value": 0.7}
        }
      }
    },
    {
      "type": "rect",
      "from": {"data": "labelPositionsFinal"},
      "description": "Debug boxes. Opacity is set to zero but can be changed to better understand how the bins are being layed out",
      "encode": {
        "update": {
          "x": {"field": "x4"},
          "y": {"field": "y4"},
          "width": {"value": 20},
          "height": {"signal": "labelHeight"},
          "strokeWidth": {"value": 2},
          "stroke": {"value": "grey"},
          "fill": {"value": "#4682b4"},
          "opacity": {"signal": "datum.value==null?0:0"}
        }
      }
    },
    {
      "type": "text",
      "name": "labels",
      "from": {"data": "labelPositionsFinal"},
      "encode": {
        "update": {
          "text": {"field": "id"},
          "opacity": {"value": 0.6},
          "fill": {"value": "black"},
          "baseline": {"value": "middle"},
          "align": {"signal": "datum.side=='left'?'right':'left'"},
          "dx": {"signal": "datum.side=='left'?-3:3"},
          "x": {"field": "x4"},
          "y": {"field": "y4"},
          "fontSize": {"signal": "labelFontSize"}
        }
      }
    }
  ]
}\n{
  "$schema": "https://vega.github.io/schema/vega/v6.json",
  "description": "Donut with non-overlapping labels.",
  "width": 200,
  "height": 200,
  "autosize": "pad",
  "padding": 30,
  "signals": [
    {
      "name": "startAngle",
      "value": 0,
      "bind": {"input": "range", "min": 0, "max": 6.29, "step": 0.01}
    },
    {
      "name": "sortField",
      "update": "''",
      "description": "Sort field if desired"
    },
    {
      "name": "sortOrder",
      "update": "''",
      "description": "Sort order if desired (ascending or descending)"
    },
    {
      "name": "labelFontSize",
      "init": "12",
      "description": "The font size used for labels"
    },
    {
      "name": "labelHeight",
      "update": "labelFontSize",
      "description": "This is approximately the same as the label font size but can be adjusted if you want extra padding"
    },
    {"name": "innerRadius", "update": "60"},
    {"name": "outerRadius", "update": "100"},
    {
      "name": "counter",
      "description": "Counter used to loop through an array",
      "value": 0,
      "on": [
        {
          "events": {"type": "timer", "throttle": 0},
          "update": "counter<length(data('labelPositions'))?counter + 1:counter"
        },
        {"events": {"signal": "leftRightCount"}, "update": "0"}
      ]
    },
    {
      "name": "shiftArray",
      "description": "An array of shift positions",
      "update": "{right: leftRightCount.right!=0? pluck(data('labelPositions')[0]['shiftArray'],'shift'):[], left: leftRightCount.left!=0? pluck(data('labelPositions')[leftRightCount.right]['shiftArray'],'shift'):[]}"
    },
    {
      "name": "leftRightCountArray",
      "description": "Array of label sides",
      "update": "reverse(sort( pluck( data('labelPositions'), 'side')))"
    },
    {
      "name": "leftRightCount",
      "description": "Count of  label sides",
      "update": "{right:lastindexof(leftRightCountArray,'right')+1,left:length(leftRightCountArray)- (lastindexof(leftRightCountArray,'right')+1)}"
    },
    {
      "name": "p1",
      "description": "Used to loop through position array one element at a time with a running sum but reseting the counter to 0 if it ever goes negative",
      "value": {"right": 0, "left": 0},
      "on": [
        {
          "events": {"signal": "leftRightCount"},
          "update": "{'right': 0, 'left': 0}"
        },
        {
          "events": {"signal": "counter"},
          "update": "{right:shiftArray.right[counter-1]+p1.right<0?0:shiftArray.right[counter-1]+p1.right, left:shiftArray.left[counter-1]+p1.left<0?0:shiftArray.left[counter-1]+p1.left}",
          "force": true
        }
      ]
    },
    {
      "name": "p2",
      "description": "Used to reassemble the position array as a string with final shift positions",
      "value": {"right": [], "left": []},
      "on": [
        {
          "events": {"signal": "leftRightCount"},
          "update": "{'right': [], 'left': []}"
        },
        {
          "events": {"signal": "p1"},
          "update": "{right:length(p2.right)!=0? p1.right+','+p2.right:p1.right,left:length(p2.left)!=0? p1.left+','+p2.left:p1.left}"
        }
      ]
    },
    {
      "name": "shiftArrayRunning",
      "description": "Converts a string to an array and reverses",
      "update": "{right:reverse(split(p2.right,',')),left:reverse(split(p2.left,','))}"
    }
  ],
  "data": [
    {
      "name": "table",
      "values": [
        {"id": "United States", "value": 1},
        {"id": "France", "value": 1},
        {"id": "Germany", "value": 1},
        {"id": "Italy", "value": 1},
        {"id": "UK", "value": 1},
        {"id": "Canada", "value": 10},
        {"id": "China", "value": 3},
        {"id": "India", "value": 7},
        {"id": "Argentina", "value": 8}
      ],
      "transform": [
        {
          "type": "collect",
          "sort": {
            "field": {"signal": "sortField"},
            "order": {"signal": "sortOrder"}
          }
        },
        {
          "type": "pie",
          "field": "value",
          "startAngle": {"signal": "startAngle"},
          "endAngle": {"signal": "round((2*PI)*10000)/10000+startAngle"}
        },
        {
          "type": "formula",
          "as": "middleAngle",
          "expr": " (((datum.endAngle - datum.startAngle)/2) + datum.startAngle)-PI/2"
        },
        {
          "type": "formula",
          "as": "side",
          "expr": "datum.middleAngle + PI/2  <= PI || datum.middleAngle + PI/2 >= 2*PI && datum.middleAngle + PI/2 <= PI*3?'right':'left'"
        },
        {
          "type": "formula",
          "as": "x1",
          "expr": " (outerRadius*cos(datum.middleAngle))+outerRadius "
        },
        {
          "type": "formula",
          "as": "y1",
          "expr": " (outerRadius*sin(datum.middleAngle))+outerRadius "
        },
        {
          "type": "formula",
          "as": "x2",
          "expr": " ((outerRadius+10)*cos(datum.middleAngle))+outerRadius "
        },
        {
          "type": "formula",
          "as": "y2",
          "expr": " ((outerRadius+10)*sin(datum.middleAngle))+outerRadius "
        },
        {
          "type": "formula",
          "as": "x3",
          "expr": "datum.side== 'right'?width+20:-20"
        },
        {"type": "formula", "as": "bin", "expr": "0"}
      ]
    },
    {
      "name": "leftExt",
      "source": ["table"],
      "transform": [
        {"type": "filter", "expr": "datum.side=='left'"},
        {"type": "extent", "field": "y2", "signal": "leftExt"}
      ]
    },
    {
      "name": "rightExt",
      "source": ["table"],
      "transform": [
        {"type": "filter", "expr": "datum.side=='right'"},
        {"type": "extent", "field": "y2", "signal": "rightExt"}
      ]
    },
    {
      "name": "labelSequenceRight",
      "transform": [
        {
          "type": "sequence",
          "start": {"signal": "rightExt[0]"},
          "stop": {"signal": "(rightExt[1]+labelHeight)"},
          "step": {"signal": "labelHeight"},
          "as": "bin"
        },
        {"type": "formula", "expr": "'right'", "as": "side"}
      ]
    },
    {
      "name": "labelSequenceLeft",
      "transform": [
        {
          "type": "sequence",
          "start": {"signal": "leftExt[0]"},
          "stop": {"signal": "(leftExt[1]+labelHeight)"},
          "step": {"signal": "labelHeight"},
          "as": "bin"
        },
        {"type": "formula", "expr": "'left'", "as": "side"}
      ]
    },
    {
      "name": "labelBinsRight",
      "source": ["rightExt", "labelSequenceRight"],
      "transform": [
        {
          "type": "bin",
          "field": "y2",
          "step": {"signal": "labelHeight"},
          "extent": {"signal": "rightExt"},
          "interval": false,
          "as": ["binTemp", "bin1"],
          "nice": false
        },
        {
          "type": "formula",
          "expr": "datum.bin==0?datum.binTemp:datum.bin",
          "as": "bin"
        }
      ]
    },
    {
      "name": "labelBinsLeft",
      "source": ["leftExt", "labelSequenceLeft"],
      "transform": [
        {
          "type": "bin",
          "field": "y2",
          "step": {"signal": "labelHeight"},
          "extent": {"signal": "leftExt"},
          "interval": false,
          "as": ["binTemp", "bin1"],
          "nice": false
        },
        {
          "type": "formula",
          "expr": "datum.bin==0?datum.binTemp:datum.bin",
          "as": "bin"
        }
      ]
    },
    {
      "name": "labelPositions",
      "source": ["labelBinsLeft", "labelBinsRight"],
      "transform": [
        {
          "type": "joinaggregate",
          "ops": ["count"],
          "as": ["count"],
          "groupby": ["side", "bin"]
        },
        {"type": "filter", "expr": "datum.value != null || datum.count == 1"},
        {"type": "formula", "expr": "datum.count-1", "as": "count"},
        {
          "type": "collect",
          "sort": {
            "field": ["side", "bin"],
            "order": ["descending", "ascending"]
          }
        },
        {
          "type": "window",
          "sort": {"field": ["bin", "y2"], "order": ["ascending", "ascending"]},
          "ops": ["row_number"],
          "as": ["index"],
          "groupby": ["side"]
        },
        {
          "type": "window",
          "sort": {"field": "index", "order": "ascending"},
          "ops": ["row_number"],
          "groupby": ["side", "bin"]
        },
        {
          "type": "formula",
          "expr": "datum.value==0?0:datum.row_number",
          "as": "row_number"
        },
        {
          "type": "formula",
          "expr": "datum.value==null?-labelHeight:datum.row_number==1?0:labelHeight",
          "as": "shift"
        },
        {
          "type": "collect",
          "sort": {
            "field": ["side", "index"],
            "order": ["descending", "ascending"]
          }
        },
        {
          "type": "joinaggregate",
          "ops": ["values"],
          "as": ["shiftArray"],
          "fields": ["shift"],
          "groupby": ["side"]
        }
      ]
    },
    {
      "name": "labelPositionsFinal",
      "source": ["labelPositions"],
      "transform": [
        {
          "type": "collect",
          "sort": {
            "field": ["side", "index"],
            "order": ["descending", "ascending"]
          }
        },
        {
          "type": "formula",
          "expr": "datum.side=='right'?toNumber(shiftArrayRunning.right[datum.index-1]):toNumber(shiftArrayRunning.left[datum.index-1])",
          "as": "shiftArrayRunning"
        },
        {
          "type": "formula",
          "expr": "datum.shiftArrayRunning+datum.bin",
          "as": "binShifted"
        },
        {
          "type": "formula",
          "as": "x4",
          "expr": "datum.side== 'right'?width+25:-25"
        },
        {
          "type": "window",
          "sort": {"field": "index", "order": "ascending"},
          "ops": ["lead"],
          "fields": ["shift"],
          "groupby": ["side"]
        },
        {
          "type": "formula",
          "as": "y4",
          "expr": "datum.y2>datum.binShifted&&datum.lead_shift<0?datum.y2:datum.binShifted"
        },
        {
          "type": "formula",
          "as": "labelPath",
          "expr": "datum.value==null?'': 'M '+ datum.x1 + ' ' + datum.y1 + 'L'+ datum.x2 + ' ' + datum.y2 + ' H'+ datum.x3  +'L '+ datum.x4 + ' ' + datum.y4 "
        }
      ]
    }
  ],
  "scales": [
    {
      "name": "color",
      "type": "ordinal",
      "domain": {"data": "table", "field": "id"},
      "range": {"scheme": "category20"}
    }
  ],
  "marks": [
    {
      "type": "arc",
      "from": {"data": "table"},
      "encode": {
        "enter": {
          "fill": {"scale": "color", "field": "id"},
          "x": {"signal": "width / 2"},
          "y": {"signal": "height / 2"},
          "stroke": {"value": "white"}
        },
        "update": {
          "startAngle": {"field": "startAngle"},
          "endAngle": {"field": "endAngle"},
          "innerRadius": {"signal": "innerRadius"},
          "outerRadius": {"signal": "outerRadius"}
        }
      }
    },
    {
      "type": "path",
      "name": "labelPath",
      "from": {"data": "labelPositionsFinal"},
      "encode": {
        "update": {
          "strokeWidth": {"value": 1},
          "path": {"field": "labelPath"},
          "stroke": {"value": "grey"},
          "opacity": {"value": 0.7}
        }
      }
    },
    {
      "type": "rect",
      "from": {"data": "labelPositionsFinal"},
      "description": "Debug boxes. Opacity is set to zero but can be changed to better understand how the bins are being layed out",
      "encode": {
        "update": {
          "x": {"field": "x4"},
          "y": {"field": "y4"},
          "width": {"value": 20},
          "height": {"signal": "labelHeight"},
          "strokeWidth": {"value": 2},
          "stroke": {"value": "grey"},
          "fill": {"value": "#4682b4"},
          "opacity": {"signal": "datum.value==null?0:0"}
        }
      }
    },
    {
      "type": "text",
      "name": "labels",
      "from": {"data": "labelPositionsFinal"},
      "encode": {
        "update": {
          "text": {"field": "id"},
          "opacity": {"value": 0.6},
          "fill": {"value": "black"},
          "baseline": {"value": "middle"},
          "align": {"signal": "datum.side=='left'?'right':'left'"},
          "dx": {"signal": "datum.side=='left'?-3:3"},
          "x": {"field": "x4"},
          "y": {"field": "y4"},
          "fontSize": {"signal": "labelFontSize"}
        }
      }
    }
  ]
}\n"https://vega.github.io/schema/vega/v6.json"\n"Donut with non-overlapping labels."\n"Sort field if desired"\n"Sort order if desired (ascending or descending)"\n"The font size used for labels"\n"This is approximately the same as the label font size but can be adjusted if you want extra padding"\n"Counter used to loop through an array"\n"counter<length(data('labelPositions'))?counter + 1:counter"\n"An array of shift positions"\n"{right: leftRightCount.right!=0? pluck(data('labelPositions')[0]['shiftArray'],'shift'):[], left: leftRightCount.left!=0? pluck(data('labelPositions')[leftRightCount.right]['shiftArray'],'shift'):[]}"\n"leftRightCountArray"\n"Array of label sides"\n"reverse(sort( pluck( data('labelPositions'), 'side')))"\n"Count of  label sides"\n"{right:lastindexof(leftRightCountArray,'right')+1,left:length(leftRightCountArray)- (lastindexof(leftRightCountArray,'right')+1)}"\n"Used to loop through position array one element at a time with a running sum but reseting the counter to 0 if it ever goes negative"\n"{'right': 0, 'left': 0}"\n"{right:shiftArray.right[counter-1]+p1.right<0?0:shiftArray.right[counter-1]+p1.right, left:shiftArray.left[counter-1]+p1.left<0?0:shiftArray.left[counter-1]+p1.left}"\n"Used to reassemble the position array as a string with final shift positions"\n"{'right': [], 'left': []}"\n"{right:length(p2.right)!=0? p1.right+','+p2.right:p1.right,left:length(p2.left)!=0? p1.left+','+p2.left:p1.left}"\n"Converts a string to an array and reverses"\n"{right:reverse(split(p2.right,',')),left:reverse(split(p2.left,','))}"\n"round((2*PI)*10000)/10000+startAngle"\n" (((datum.endAngle - datum.startAngle)/2) + datum.startAngle)-PI/2"\n"datum.middleAngle + PI/2  <= PI || datum.middleAngle + PI/2 >= 2*PI && datum.middleAngle + PI/2 <= PI*3?'right':'left'"\n" (outerRadius*cos(datum.middleAngle))+outerRadius "\n" (outerRadius*sin(datum.middleAngle))+outerRadius "\n" ((outerRadius+10)*cos(datum.middleAngle))+outerRadius "\n" ((outerRadius+10)*sin(datum.middleAngle))+outerRadius "\n"datum.side== 'right'?width+20:-20"\n"datum.side=='right'"\n"(rightExt[1]+labelHeight)"\n"(leftExt[1]+labelHeight)"\n"datum.bin==0?datum.binTemp:datum.bin"\n"datum.bin==0?datum.binTemp:datum.bin"\n"datum.value != null || datum.count == 1"\n"datum.value==0?0:datum.row_number"\n"datum.value==null?-labelHeight:datum.row_number==1?0:labelHeight"\n"labelPositionsFinal"\n"datum.side=='right'?toNumber(shiftArrayRunning.right[datum.index-1]):toNumber(shiftArrayRunning.left[datum.index-1])"\n"datum.shiftArrayRunning+datum.bin"\n"datum.side== 'right'?width+25:-25"\n"datum.y2>datum.binShifted&&datum.lead_shift<0?datum.y2:datum.binShifted"\n"datum.value==null?'': 'M '+ datum.x1 + ' ' + datum.y1 + 'L'+ datum.x2 + ' ' + datum.y2 + ' H'+ datum.x3  +'L '+ datum.x4 + ' ' + datum.y4 "\n"labelPositionsFinal"\n"labelPositionsFinal"\n"Debug boxes. Opacity is set to zero but can be changed to better understand how the bins are being layed out"\n"datum.value==null?0:0"\n"labelPositionsFinal"\n"datum.side=='left'?'right':'left'"\n"datum.side=='left'?-3:3"\n\n\nVega
            
              Vega-Lite
              Altair
              Vega-Lite API
            
          
          
            
              Examples
              Tutorials
              Documentation
              Usage
              About
            
            
              GitHub
              Try Online
            
          
        
      

      
        

  
  
    Radial Plot Example
    This radial plot uses both angular and radial extent to convey multiple dimensions of data. However, this approach is not perceptually effective, as viewers will most likely be drawn to the total area of the shape, conflating the two dimensions. This example also demonstrates one way to add labels to circular plots.




  
  View Source
  Export PNG
  Export SVG






  View in Online Vega Editor


Vega JSON Specification <>

{
  "$schema": "https://vega.github.io/schema/vega/v5.json",
  "description": "A basic radial plot that encodes two values as the angle and radius of an arc.",
  "width": 200,
  "height": 200,

  "data": [
    {
      "name": "table",
      "values": [12, 23, 47, 6, 52, 19],
      "transform": [{"type": "pie", "field": "data"}]
    }
  ],

  "scales": [
    {
      "name": "r",
      "type": "sqrt",
      "domain": {"data": "table", "field": "data"},
      "zero": true,
      "range": [20, 100]
    }
  ],

  "marks": [
    {
      "type": "arc",
      "from": {"data": "table"},
      "encode": {
        "enter": {
          "x": {"field": {"group": "width"}, "mult": 0.5},
          "y": {"field": {"group": "height"}, "mult": 0.5},
          "startAngle": {"field": "startAngle"},
          "endAngle": {"field": "endAngle"},
          "innerRadius": {"value": 20},
          "outerRadius": {"scale": "r", "field": "data"},
          "stroke": {"value": "#fff"}
        },
        "update": {
          "fill": {"value": "#ccc"}
        },
        "hover": {
          "fill": {"value": "pink"}
        }
      }
    },

    {
      "type": "text",
      "from": {"data": "table"},
      "encode": {
        "enter": {
          "x": {"field": {"group": "width"}, "mult": 0.5},
          "y": {"field": {"group": "height"}, "mult": 0.5},
          "radius": {"scale": "r", "field": "data", "offset": 8},
          "theta": {"signal": "(datum.startAngle + datum.endAngle)/2"},
          "fill": {"value": "#000"},
          "align": {"value": "center"},
          "baseline": {"value": "middle"},
          "text": {"field": "data"}
        }
      }
    }
  ]
}\nVega
            
              Vega-Lite
              Altair
              Vega-Lite API\nVega-Lite
              Altair
              Vega-Lite API\nExamples
              Tutorials
              Documentation
              Usage
              About
            
            
              GitHub
              Try Online\nExamples
              Tutorials
              Documentation
              Usage
              About\nGitHub
              Try Online\nRadial Plot Example
    This radial plot uses both angular and radial extent to convey multiple dimensions of data. However, this approach is not perceptually effective, as viewers will most likely be drawn to the total area of the shape, conflating the two dimensions. This example also demonstrates one way to add labels to circular plots.




  
  View Source
  Export PNG
  Export SVG






  View in Online Vega Editor


Vega JSON Specification <>

{
  "$schema": "https://vega.github.io/schema/vega/v5.json",
  "description": "A basic radial plot that encodes two values as the angle and radius of an arc.",
  "width": 200,
  "height": 200,

  "data": [
    {
      "name": "table",
      "values": [12, 23, 47, 6, 52, 19],
      "transform": [{"type": "pie", "field": "data"}]
    }
  ],

  "scales": [
    {
      "name": "r",
      "type": "sqrt",
      "domain": {"data": "table", "field": "data"},
      "zero": true,
      "range": [20, 100]
    }
  ],

  "marks": [
    {
      "type": "arc",
      "from": {"data": "table"},
      "encode": {
        "enter": {
          "x": {"field": {"group": "width"}, "mult": 0.5},
          "y": {"field": {"group": "height"}, "mult": 0.5},
          "startAngle": {"field": "startAngle"},
          "endAngle": {"field": "endAngle"},
          "innerRadius": {"value": 20},
          "outerRadius": {"scale": "r", "field": "data"},
          "stroke": {"value": "#fff"}
        },
        "update": {
          "fill": {"value": "#ccc"}
        },
        "hover": {
          "fill": {"value": "pink"}
        }
      }
    },

    {
      "type": "text",
      "from": {"data": "table"},
      "encode": {
        "enter": {
          "x": {"field": {"group": "width"}, "mult": 0.5},
          "y": {"field": {"group": "height"}, "mult": 0.5},
          "radius": {"scale": "r", "field": "data", "offset": 8},
          "theta": {"signal": "(datum.startAngle + datum.endAngle)/2"},
          "fill": {"value": "#000"},
          "align": {"value": "center"},
          "baseline": {"value": "middle"},
          "text": {"field": "data"}
        }
      }
    }
  ]
}\nThis radial plot uses both angular and radial extent to convey multiple dimensions of data. However, this approach is not perceptually effective, as viewers will most likely be drawn to the total area of the shape, conflating the two dimensions. This example also demonstrates one way to add labels to circular plots.\nView Source
  Export PNG
  Export SVG\nView Source
  Export PNG
  Export SVG\nView in Online Vega Editor\nView in Online Vega Editor\nVega JSON Specification <>\n{
  "$schema": "https://vega.github.io/schema/vega/v5.json",
  "description": "A basic radial plot that encodes two values as the angle and radius of an arc.",
  "width": 200,
  "height": 200,

  "data": [
    {
      "name": "table",
      "values": [12, 23, 47, 6, 52, 19],
      "transform": [{"type": "pie", "field": "data"}]
    }
  ],

  "scales": [
    {
      "name": "r",
      "type": "sqrt",
      "domain": {"data": "table", "field": "data"},
      "zero": true,
      "range": [20, 100]
    }
  ],

  "marks": [
    {
      "type": "arc",
      "from": {"data": "table"},
      "encode": {
        "enter": {
          "x": {"field": {"group": "width"}, "mult": 0.5},
          "y": {"field": {"group": "height"}, "mult": 0.5},
          "startAngle": {"field": "startAngle"},
          "endAngle": {"field": "endAngle"},
          "innerRadius": {"value": 20},
          "outerRadius": {"scale": "r", "field": "data"},
          "stroke": {"value": "#fff"}
        },
        "update": {
          "fill": {"value": "#ccc"}
        },
        "hover": {
          "fill": {"value": "pink"}
        }
      }
    },

    {
      "type": "text",
      "from": {"data": "table"},
      "encode": {
        "enter": {
          "x": {"field": {"group": "width"}, "mult": 0.5},
          "y": {"field": {"group": "height"}, "mult": 0.5},
          "radius": {"scale": "r", "field": "data", "offset": 8},
          "theta": {"signal": "(datum.startAngle + datum.endAngle)/2"},
          "fill": {"value": "#000"},
          "align": {"value": "center"},
          "baseline": {"value": "middle"},
          "text": {"field": "data"}
        }
      }
    }
  ]
}\n{
  "$schema": "https://vega.github.io/schema/vega/v5.json",
  "description": "A basic radial plot that encodes two values as the angle and radius of an arc.",
  "width": 200,
  "height": 200,

  "data": [
    {
      "name": "table",
      "values": [12, 23, 47, 6, 52, 19],
      "transform": [{"type": "pie", "field": "data"}]
    }
  ],

  "scales": [
    {
      "name": "r",
      "type": "sqrt",
      "domain": {"data": "table", "field": "data"},
      "zero": true,
      "range": [20, 100]
    }
  ],

  "marks": [
    {
      "type": "arc",
      "from": {"data": "table"},
      "encode": {
        "enter": {
          "x": {"field": {"group": "width"}, "mult": 0.5},
          "y": {"field": {"group": "height"}, "mult": 0.5},
          "startAngle": {"field": "startAngle"},
          "endAngle": {"field": "endAngle"},
          "innerRadius": {"value": 20},
          "outerRadius": {"scale": "r", "field": "data"},
          "stroke": {"value": "#fff"}
        },
        "update": {
          "fill": {"value": "#ccc"}
        },
        "hover": {
          "fill": {"value": "pink"}
        }
      }
    },

    {
      "type": "text",
      "from": {"data": "table"},
      "encode": {
        "enter": {
          "x": {"field": {"group": "width"}, "mult": 0.5},
          "y": {"field": {"group": "height"}, "mult": 0.5},
          "radius": {"scale": "r", "field": "data", "offset": 8},
          "theta": {"signal": "(datum.startAngle + datum.endAngle)/2"},
          "fill": {"value": "#000"},
          "align": {"value": "center"},
          "baseline": {"value": "middle"},
          "text": {"field": "data"}
        }
      }
    }
  ]
}\n"https://vega.github.io/schema/vega/v5.json"\n"A basic radial plot that encodes two values as the angle and radius of an arc."\n"(datum.startAngle + datum.endAngle)/2"\n\n\nVega
            
              Vega-Lite
              Altair
              Vega-Lite API
            
          
          
            
              Examples
              Tutorials
              Documentation
              Usage
              About
            
            
              GitHub
              Try Online
            
          
        
      

      
        

  
  
    Radar Chart Example
    A radar chart is a graphical method of displaying multivariate data in the form of a two-dimensional chart of three or more quantitative variables represented on axes starting from the same point.




  
  View Source
  Export PNG
  Export SVG






  View in Online Vega Editor


Vega JSON Specification <>

{
  "$schema": "https://vega.github.io/schema/vega/v5.json",
  "description": "A radar chart example, showing multiple dimensions in a radial layout.",
  "width": 400,
  "height": 400,
  "padding": 40,
  "autosize": {"type": "none", "contains": "padding"},

  "signals": [
    {"name": "radius", "update": "width / 2"}
  ],

  "data": [
    {
      "name": "table",
      "values": [
        {"key": "key-0", "value": 19, "category": 0},
        {"key": "key-1", "value": 22, "category": 0},
        {"key": "key-2", "value": 14, "category": 0},
        {"key": "key-3", "value": 38, "category": 0},
        {"key": "key-4", "value": 23, "category": 0},
        {"key": "key-5", "value": 5, "category": 0},
        {"key": "key-6", "value": 27, "category": 0},
        {"key": "key-0", "value": 13, "category": 1},
        {"key": "key-1", "value": 12, "category": 1},
        {"key": "key-2", "value": 42, "category": 1},
        {"key": "key-3", "value": 13, "category": 1},
        {"key": "key-4", "value": 6, "category": 1},
        {"key": "key-5", "value": 15, "category": 1},
        {"key": "key-6", "value": 8, "category": 1}
      ]
    },
    {
      "name": "keys",
      "source": "table",
      "transform": [
        {
          "type": "aggregate",
          "groupby": ["key"]
        }
      ]
    }
  ],

  "scales": [
    {
      "name": "angular",
      "type": "point",
      "range": {"signal": "[-PI, PI]"},
      "padding": 0.5,
      "domain": {"data": "table", "field": "key"}
    },
    {
      "name": "radial",
      "type": "linear",
      "range": {"signal": "[0, radius]"},
      "zero": true,
      "nice": false,
      "domain": {"data": "table", "field": "value"},
      "domainMin": 0
    },
    {
      "name": "color",
      "type": "ordinal",
      "domain": {"data": "table", "field": "category"},
      "range": {"scheme": "category10"}
    }
  ],

  "encode": {
    "enter": {
      "x": {"signal": "radius"},
      "y": {"signal": "radius"}
    }
  },

  "marks": [
    {
      "type": "group",
      "name": "categories",
      "zindex": 1,
      "from": {
        "facet": {"data": "table", "name": "facet", "groupby": ["category"]}
      },
      "marks": [
        {
          "type": "line",
          "name": "category-line",
          "from": {"data": "facet"},
          "encode": {
            "enter": {
              "interpolate": {"value": "linear-closed"},
              "x": {"signal": "scale('radial', datum.value) * cos(scale('angular', datum.key))"},
              "y": {"signal": "scale('radial', datum.value) * sin(scale('angular', datum.key))"},
              "stroke": {"scale": "color", "field": "category"},
              "strokeWidth": {"value": 1},
              "fill": {"scale": "color", "field": "category"},
              "fillOpacity": {"value": 0.1}
            }
          }
        },
        {
          "type": "text",
          "name": "value-text",
          "from": {"data": "category-line"},
          "encode": {
            "enter": {
              "x": {"signal": "datum.x"},
              "y": {"signal": "datum.y"},
              "text": {"signal": "datum.datum.value"},
              "align": {"value": "center"},
              "baseline": {"value": "middle"},
              "fill": {"value": "black"}
            }
          }
        }
      ]
    },
    {
      "type": "rule",
      "name": "radial-grid",
      "from": {"data": "keys"},
      "zindex": 0,
      "encode": {
        "enter": {
          "x": {"value": 0},
          "y": {"value": 0},
          "x2": {"signal": "radius * cos(scale('angular', datum.key))"},
          "y2": {"signal": "radius * sin(scale('angular', datum.key))"},
          "stroke": {"value": "lightgray"},
          "strokeWidth": {"value": 1}
        }
      }
    },
    {
      "type": "text",
      "name": "key-label",
      "from": {"data": "keys"},
      "zindex": 1,
      "encode": {
        "enter": {
          "x": {"signal": "(radius + 5) * cos(scale('angular', datum.key))"},
          "y": {"signal": "(radius + 5) * sin(scale('angular', datum.key))"},
          "text": {"field": "key"},
          "align": [
            {
              "test": "abs(scale('angular', datum.key)) > PI / 2",
              "value": "right"
            },
            {
              "value": "left"
            }
          ],
          "baseline": [
            {
              "test": "scale('angular', datum.key) > 0", "value": "top"
            },
            {
              "test": "scale('angular', datum.key) == 0", "value": "middle"
            },
            {
              "value": "bottom"
            }
          ],
          "fill": {"value": "black"},
          "fontWeight": {"value": "bold"}
        }
      }
    },
    {
      "type": "line",
      "name": "outer-line",
      "from": {"data": "radial-grid"},
      "encode": {
        "enter": {
          "interpolate": {"value": "linear-closed"},
          "x": {"field": "x2"},
          "y": {"field": "y2"},
          "stroke": {"value": "lightgray"},
          "strokeWidth": {"value": 1}
        }
      }
    }
  ]
}\nVega
            
              Vega-Lite
              Altair
              Vega-Lite API\nVega-Lite
              Altair
              Vega-Lite API\nExamples
              Tutorials
              Documentation
              Usage
              About
            
            
              GitHub
              Try Online\nExamples
              Tutorials
              Documentation
              Usage
              About\nGitHub
              Try Online\nRadar Chart Example
    A radar chart is a graphical method of displaying multivariate data in the form of a two-dimensional chart of three or more quantitative variables represented on axes starting from the same point.




  
  View Source
  Export PNG
  Export SVG






  View in Online Vega Editor


Vega JSON Specification <>

{
  "$schema": "https://vega.github.io/schema/vega/v5.json",
  "description": "A radar chart example, showing multiple dimensions in a radial layout.",
  "width": 400,
  "height": 400,
  "padding": 40,
  "autosize": {"type": "none", "contains": "padding"},

  "signals": [
    {"name": "radius", "update": "width / 2"}
  ],

  "data": [
    {
      "name": "table",
      "values": [
        {"key": "key-0", "value": 19, "category": 0},
        {"key": "key-1", "value": 22, "category": 0},
        {"key": "key-2", "value": 14, "category": 0},
        {"key": "key-3", "value": 38, "category": 0},
        {"key": "key-4", "value": 23, "category": 0},
        {"key": "key-5", "value": 5, "category": 0},
        {"key": "key-6", "value": 27, "category": 0},
        {"key": "key-0", "value": 13, "category": 1},
        {"key": "key-1", "value": 12, "category": 1},
        {"key": "key-2", "value": 42, "category": 1},
        {"key": "key-3", "value": 13, "category": 1},
        {"key": "key-4", "value": 6, "category": 1},
        {"key": "key-5", "value": 15, "category": 1},
        {"key": "key-6", "value": 8, "category": 1}
      ]
    },
    {
      "name": "keys",
      "source": "table",
      "transform": [
        {
          "type": "aggregate",
          "groupby": ["key"]
        }
      ]
    }
  ],

  "scales": [
    {
      "name": "angular",
      "type": "point",
      "range": {"signal": "[-PI, PI]"},
      "padding": 0.5,
      "domain": {"data": "table", "field": "key"}
    },
    {
      "name": "radial",
      "type": "linear",
      "range": {"signal": "[0, radius]"},
      "zero": true,
      "nice": false,
      "domain": {"data": "table", "field": "value"},
      "domainMin": 0
    },
    {
      "name": "color",
      "type": "ordinal",
      "domain": {"data": "table", "field": "category"},
      "range": {"scheme": "category10"}
    }
  ],

  "encode": {
    "enter": {
      "x": {"signal": "radius"},
      "y": {"signal": "radius"}
    }
  },

  "marks": [
    {
      "type": "group",
      "name": "categories",
      "zindex": 1,
      "from": {
        "facet": {"data": "table", "name": "facet", "groupby": ["category"]}
      },
      "marks": [
        {
          "type": "line",
          "name": "category-line",
          "from": {"data": "facet"},
          "encode": {
            "enter": {
              "interpolate": {"value": "linear-closed"},
              "x": {"signal": "scale('radial', datum.value) * cos(scale('angular', datum.key))"},
              "y": {"signal": "scale('radial', datum.value) * sin(scale('angular', datum.key))"},
              "stroke": {"scale": "color", "field": "category"},
              "strokeWidth": {"value": 1},
              "fill": {"scale": "color", "field": "category"},
              "fillOpacity": {"value": 0.1}
            }
          }
        },
        {
          "type": "text",
          "name": "value-text",
          "from": {"data": "category-line"},
          "encode": {
            "enter": {
              "x": {"signal": "datum.x"},
              "y": {"signal": "datum.y"},
              "text": {"signal": "datum.datum.value"},
              "align": {"value": "center"},
              "baseline": {"value": "middle"},
              "fill": {"value": "black"}
            }
          }
        }
      ]
    },
    {
      "type": "rule",
      "name": "radial-grid",
      "from": {"data": "keys"},
      "zindex": 0,
      "encode": {
        "enter": {
          "x": {"value": 0},
          "y": {"value": 0},
          "x2": {"signal": "radius * cos(scale('angular', datum.key))"},
          "y2": {"signal": "radius * sin(scale('angular', datum.key))"},
          "stroke": {"value": "lightgray"},
          "strokeWidth": {"value": 1}
        }
      }
    },
    {
      "type": "text",
      "name": "key-label",
      "from": {"data": "keys"},
      "zindex": 1,
      "encode": {
        "enter": {
          "x": {"signal": "(radius + 5) * cos(scale('angular', datum.key))"},
          "y": {"signal": "(radius + 5) * sin(scale('angular', datum.key))"},
          "text": {"field": "key"},
          "align": [
            {
              "test": "abs(scale('angular', datum.key)) > PI / 2",
              "value": "right"
            },
            {
              "value": "left"
            }
          ],
          "baseline": [
            {
              "test": "scale('angular', datum.key) > 0", "value": "top"
            },
            {
              "test": "scale('angular', datum.key) == 0", "value": "middle"
            },
            {
              "value": "bottom"
            }
          ],
          "fill": {"value": "black"},
          "fontWeight": {"value": "bold"}
        }
      }
    },
    {
      "type": "line",
      "name": "outer-line",
      "from": {"data": "radial-grid"},
      "encode": {
        "enter": {
          "interpolate": {"value": "linear-closed"},
          "x": {"field": "x2"},
          "y": {"field": "y2"},
          "stroke": {"value": "lightgray"},
          "strokeWidth": {"value": 1}
        }
      }
    }
  ]
}\nA radar chart is a graphical method of displaying multivariate data in the form of a two-dimensional chart of three or more quantitative variables represented on axes starting from the same point.\nView Source
  Export PNG
  Export SVG\nView Source
  Export PNG
  Export SVG\nView in Online Vega Editor\nView in Online Vega Editor\nVega JSON Specification <>\n{
  "$schema": "https://vega.github.io/schema/vega/v5.json",
  "description": "A radar chart example, showing multiple dimensions in a radial layout.",
  "width": 400,
  "height": 400,
  "padding": 40,
  "autosize": {"type": "none", "contains": "padding"},

  "signals": [
    {"name": "radius", "update": "width / 2"}
  ],

  "data": [
    {
      "name": "table",
      "values": [
        {"key": "key-0", "value": 19, "category": 0},
        {"key": "key-1", "value": 22, "category": 0},
        {"key": "key-2", "value": 14, "category": 0},
        {"key": "key-3", "value": 38, "category": 0},
        {"key": "key-4", "value": 23, "category": 0},
        {"key": "key-5", "value": 5, "category": 0},
        {"key": "key-6", "value": 27, "category": 0},
        {"key": "key-0", "value": 13, "category": 1},
        {"key": "key-1", "value": 12, "category": 1},
        {"key": "key-2", "value": 42, "category": 1},
        {"key": "key-3", "value": 13, "category": 1},
        {"key": "key-4", "value": 6, "category": 1},
        {"key": "key-5", "value": 15, "category": 1},
        {"key": "key-6", "value": 8, "category": 1}
      ]
    },
    {
      "name": "keys",
      "source": "table",
      "transform": [
        {
          "type": "aggregate",
          "groupby": ["key"]
        }
      ]
    }
  ],

  "scales": [
    {
      "name": "angular",
      "type": "point",
      "range": {"signal": "[-PI, PI]"},
      "padding": 0.5,
      "domain": {"data": "table", "field": "key"}
    },
    {
      "name": "radial",
      "type": "linear",
      "range": {"signal": "[0, radius]"},
      "zero": true,
      "nice": false,
      "domain": {"data": "table", "field": "value"},
      "domainMin": 0
    },
    {
      "name": "color",
      "type": "ordinal",
      "domain": {"data": "table", "field": "category"},
      "range": {"scheme": "category10"}
    }
  ],

  "encode": {
    "enter": {
      "x": {"signal": "radius"},
      "y": {"signal": "radius"}
    }
  },

  "marks": [
    {
      "type": "group",
      "name": "categories",
      "zindex": 1,
      "from": {
        "facet": {"data": "table", "name": "facet", "groupby": ["category"]}
      },
      "marks": [
        {
          "type": "line",
          "name": "category-line",
          "from": {"data": "facet"},
          "encode": {
            "enter": {
              "interpolate": {"value": "linear-closed"},
              "x": {"signal": "scale('radial', datum.value) * cos(scale('angular', datum.key))"},
              "y": {"signal": "scale('radial', datum.value) * sin(scale('angular', datum.key))"},
              "stroke": {"scale": "color", "field": "category"},
              "strokeWidth": {"value": 1},
              "fill": {"scale": "color", "field": "category"},
              "fillOpacity": {"value": 0.1}
            }
          }
        },
        {
          "type": "text",
          "name": "value-text",
          "from": {"data": "category-line"},
          "encode": {
            "enter": {
              "x": {"signal": "datum.x"},
              "y": {"signal": "datum.y"},
              "text": {"signal": "datum.datum.value"},
              "align": {"value": "center"},
              "baseline": {"value": "middle"},
              "fill": {"value": "black"}
            }
          }
        }
      ]
    },
    {
      "type": "rule",
      "name": "radial-grid",
      "from": {"data": "keys"},
      "zindex": 0,
      "encode": {
        "enter": {
          "x": {"value": 0},
          "y": {"value": 0},
          "x2": {"signal": "radius * cos(scale('angular', datum.key))"},
          "y2": {"signal": "radius * sin(scale('angular', datum.key))"},
          "stroke": {"value": "lightgray"},
          "strokeWidth": {"value": 1}
        }
      }
    },
    {
      "type": "text",
      "name": "key-label",
      "from": {"data": "keys"},
      "zindex": 1,
      "encode": {
        "enter": {
          "x": {"signal": "(radius + 5) * cos(scale('angular', datum.key))"},
          "y": {"signal": "(radius + 5) * sin(scale('angular', datum.key))"},
          "text": {"field": "key"},
          "align": [
            {
              "test": "abs(scale('angular', datum.key)) > PI / 2",
              "value": "right"
            },
            {
              "value": "left"
            }
          ],
          "baseline": [
            {
              "test": "scale('angular', datum.key) > 0", "value": "top"
            },
            {
              "test": "scale('angular', datum.key) == 0", "value": "middle"
            },
            {
              "value": "bottom"
            }
          ],
          "fill": {"value": "black"},
          "fontWeight": {"value": "bold"}
        }
      }
    },
    {
      "type": "line",
      "name": "outer-line",
      "from": {"data": "radial-grid"},
      "encode": {
        "enter": {
          "interpolate": {"value": "linear-closed"},
          "x": {"field": "x2"},
          "y": {"field": "y2"},
          "stroke": {"value": "lightgray"},
          "strokeWidth": {"value": 1}
        }
      }
    }
  ]
}\n{
  "$schema": "https://vega.github.io/schema/vega/v5.json",
  "description": "A radar chart example, showing multiple dimensions in a radial layout.",
  "width": 400,
  "height": 400,
  "padding": 40,
  "autosize": {"type": "none", "contains": "padding"},

  "signals": [
    {"name": "radius", "update": "width / 2"}
  ],

  "data": [
    {
      "name": "table",
      "values": [
        {"key": "key-0", "value": 19, "category": 0},
        {"key": "key-1", "value": 22, "category": 0},
        {"key": "key-2", "value": 14, "category": 0},
        {"key": "key-3", "value": 38, "category": 0},
        {"key": "key-4", "value": 23, "category": 0},
        {"key": "key-5", "value": 5, "category": 0},
        {"key": "key-6", "value": 27, "category": 0},
        {"key": "key-0", "value": 13, "category": 1},
        {"key": "key-1", "value": 12, "category": 1},
        {"key": "key-2", "value": 42, "category": 1},
        {"key": "key-3", "value": 13, "category": 1},
        {"key": "key-4", "value": 6, "category": 1},
        {"key": "key-5", "value": 15, "category": 1},
        {"key": "key-6", "value": 8, "category": 1}
      ]
    },
    {
      "name": "keys",
      "source": "table",
      "transform": [
        {
          "type": "aggregate",
          "groupby": ["key"]
        }
      ]
    }
  ],

  "scales": [
    {
      "name": "angular",
      "type": "point",
      "range": {"signal": "[-PI, PI]"},
      "padding": 0.5,
      "domain": {"data": "table", "field": "key"}
    },
    {
      "name": "radial",
      "type": "linear",
      "range": {"signal": "[0, radius]"},
      "zero": true,
      "nice": false,
      "domain": {"data": "table", "field": "value"},
      "domainMin": 0
    },
    {
      "name": "color",
      "type": "ordinal",
      "domain": {"data": "table", "field": "category"},
      "range": {"scheme": "category10"}
    }
  ],

  "encode": {
    "enter": {
      "x": {"signal": "radius"},
      "y": {"signal": "radius"}
    }
  },

  "marks": [
    {
      "type": "group",
      "name": "categories",
      "zindex": 1,
      "from": {
        "facet": {"data": "table", "name": "facet", "groupby": ["category"]}
      },
      "marks": [
        {
          "type": "line",
          "name": "category-line",
          "from": {"data": "facet"},
          "encode": {
            "enter": {
              "interpolate": {"value": "linear-closed"},
              "x": {"signal": "scale('radial', datum.value) * cos(scale('angular', datum.key))"},
              "y": {"signal": "scale('radial', datum.value) * sin(scale('angular', datum.key))"},
              "stroke": {"scale": "color", "field": "category"},
              "strokeWidth": {"value": 1},
              "fill": {"scale": "color", "field": "category"},
              "fillOpacity": {"value": 0.1}
            }
          }
        },
        {
          "type": "text",
          "name": "value-text",
          "from": {"data": "category-line"},
          "encode": {
            "enter": {
              "x": {"signal": "datum.x"},
              "y": {"signal": "datum.y"},
              "text": {"signal": "datum.datum.value"},
              "align": {"value": "center"},
              "baseline": {"value": "middle"},
              "fill": {"value": "black"}
            }
          }
        }
      ]
    },
    {
      "type": "rule",
      "name": "radial-grid",
      "from": {"data": "keys"},
      "zindex": 0,
      "encode": {
        "enter": {
          "x": {"value": 0},
          "y": {"value": 0},
          "x2": {"signal": "radius * cos(scale('angular', datum.key))"},
          "y2": {"signal": "radius * sin(scale('angular', datum.key))"},
          "stroke": {"value": "lightgray"},
          "strokeWidth": {"value": 1}
        }
      }
    },
    {
      "type": "text",
      "name": "key-label",
      "from": {"data": "keys"},
      "zindex": 1,
      "encode": {
        "enter": {
          "x": {"signal": "(radius + 5) * cos(scale('angular', datum.key))"},
          "y": {"signal": "(radius + 5) * sin(scale('angular', datum.key))"},
          "text": {"field": "key"},
          "align": [
            {
              "test": "abs(scale('angular', datum.key)) > PI / 2",
              "value": "right"
            },
            {
              "value": "left"
            }
          ],
          "baseline": [
            {
              "test": "scale('angular', datum.key) > 0", "value": "top"
            },
            {
              "test": "scale('angular', datum.key) == 0", "value": "middle"
            },
            {
              "value": "bottom"
            }
          ],
          "fill": {"value": "black"},
          "fontWeight": {"value": "bold"}
        }
      }
    },
    {
      "type": "line",
      "name": "outer-line",
      "from": {"data": "radial-grid"},
      "encode": {
        "enter": {
          "interpolate": {"value": "linear-closed"},
          "x": {"field": "x2"},
          "y": {"field": "y2"},
          "stroke": {"value": "lightgray"},
          "strokeWidth": {"value": 1}
        }
      }
    }
  ]
}\n"https://vega.github.io/schema/vega/v5.json"\n"A radar chart example, showing multiple dimensions in a radial layout."\n"scale('radial', datum.value) * cos(scale('angular', datum.key))"\n"scale('radial', datum.value) * sin(scale('angular', datum.key))"\n"radius * cos(scale('angular', datum.key))"\n"radius * sin(scale('angular', datum.key))"\n"(radius + 5) * cos(scale('angular', datum.key))"\n"(radius + 5) * sin(scale('angular', datum.key))"\n"abs(scale('angular', datum.key)) > PI / 2"\n"scale('angular', datum.key) > 0"\n"scale('angular', datum.key) == 0"\n\n\nVega
            
              Vega-Lite
              Altair
              Vega-Lite API
            
          
          
            
              Examples
              Tutorials
              Documentation
              Usage
              About
            
            
              GitHub
              Try Online
            
          
        
      

      
        

  
  
    Scatter Plot Example
    Scatter plots are ideal for visualizing the relationship between two quantitative variables. This example plots horsepower vs. mileage for a data set of cars. A size encoding is used to additionally depict acceleration.




  
  View Source
  Export PNG
  Export SVG






  View in Online Vega Editor


Vega JSON Specification <>

{
  "$schema": "https://vega.github.io/schema/vega/v5.json",
  "description": "A basic scatter plot example depicting automobile statistics.",
  "width": 200,
  "height": 200,
  "padding": 5,

  "data": [
    {
      "name": "source",
      "url": "data/cars.json",
      "transform": [
        {
          "type": "filter",
          "expr": "datum['Horsepower'] != null && datum['Miles_per_Gallon'] != null && datum['Acceleration'] != null"
        }
      ]
    }
  ],

  "scales": [
    {
      "name": "x",
      "type": "linear",
      "round": true,
      "nice": true,
      "zero": true,
      "domain": {"data": "source", "field": "Horsepower"},
      "range": "width"
    },
    {
      "name": "y",
      "type": "linear",
      "round": true,
      "nice": true,
      "zero": true,
      "domain": {"data": "source", "field": "Miles_per_Gallon"},
      "range": "height"
    },
    {
      "name": "size",
      "type": "linear",
      "round": true,
      "nice": false,
      "zero": true,
      "domain": {"data": "source", "field": "Acceleration"},
      "range": [4,361]
    }
  ],

  "axes": [
    {
      "scale": "x",
      "grid": true,
      "domain": false,
      "orient": "bottom",
      "tickCount": 5,
      "title": "Horsepower"
    },
    {
      "scale": "y",
      "grid": true,
      "domain": false,
      "orient": "left",
      "titlePadding": 5,
      "title": "Miles_per_Gallon"
    }
  ],

  "legends": [
    {
      "size": "size",
      "title": "Acceleration",
      "format": "s",
      "symbolStrokeColor": "#4682b4",
      "symbolStrokeWidth": 2,
      "symbolOpacity": 0.5,
      "symbolType": "circle"
    }
  ],

  "marks": [
    {
      "name": "marks",
      "type": "symbol",
      "from": {"data": "source"},
      "encode": {
        "update": {
          "x": {"scale": "x", "field": "Horsepower"},
          "y": {"scale": "y", "field": "Miles_per_Gallon"},
          "size": {"scale": "size", "field": "Acceleration"},
          "shape": {"value": "circle"},
          "strokeWidth": {"value": 2},
          "opacity": {"value": 0.5},
          "stroke": {"value": "#4682b4"},
          "fill": {"value": "transparent"}
        }
      }
    }
  ]
}\nVega
            
              Vega-Lite
              Altair
              Vega-Lite API\nVega-Lite
              Altair
              Vega-Lite API\nExamples
              Tutorials
              Documentation
              Usage
              About
            
            
              GitHub
              Try Online\nExamples
              Tutorials
              Documentation
              Usage
              About\nGitHub
              Try Online\nScatter Plot Example
    Scatter plots are ideal for visualizing the relationship between two quantitative variables. This example plots horsepower vs. mileage for a data set of cars. A size encoding is used to additionally depict acceleration.




  
  View Source
  Export PNG
  Export SVG






  View in Online Vega Editor


Vega JSON Specification <>

{
  "$schema": "https://vega.github.io/schema/vega/v5.json",
  "description": "A basic scatter plot example depicting automobile statistics.",
  "width": 200,
  "height": 200,
  "padding": 5,

  "data": [
    {
      "name": "source",
      "url": "data/cars.json",
      "transform": [
        {
          "type": "filter",
          "expr": "datum['Horsepower'] != null && datum['Miles_per_Gallon'] != null && datum['Acceleration'] != null"
        }
      ]
    }
  ],

  "scales": [
    {
      "name": "x",
      "type": "linear",
      "round": true,
      "nice": true,
      "zero": true,
      "domain": {"data": "source", "field": "Horsepower"},
      "range": "width"
    },
    {
      "name": "y",
      "type": "linear",
      "round": true,
      "nice": true,
      "zero": true,
      "domain": {"data": "source", "field": "Miles_per_Gallon"},
      "range": "height"
    },
    {
      "name": "size",
      "type": "linear",
      "round": true,
      "nice": false,
      "zero": true,
      "domain": {"data": "source", "field": "Acceleration"},
      "range": [4,361]
    }
  ],

  "axes": [
    {
      "scale": "x",
      "grid": true,
      "domain": false,
      "orient": "bottom",
      "tickCount": 5,
      "title": "Horsepower"
    },
    {
      "scale": "y",
      "grid": true,
      "domain": false,
      "orient": "left",
      "titlePadding": 5,
      "title": "Miles_per_Gallon"
    }
  ],

  "legends": [
    {
      "size": "size",
      "title": "Acceleration",
      "format": "s",
      "symbolStrokeColor": "#4682b4",
      "symbolStrokeWidth": 2,
      "symbolOpacity": 0.5,
      "symbolType": "circle"
    }
  ],

  "marks": [
    {
      "name": "marks",
      "type": "symbol",
      "from": {"data": "source"},
      "encode": {
        "update": {
          "x": {"scale": "x", "field": "Horsepower"},
          "y": {"scale": "y", "field": "Miles_per_Gallon"},
          "size": {"scale": "size", "field": "Acceleration"},
          "shape": {"value": "circle"},
          "strokeWidth": {"value": 2},
          "opacity": {"value": 0.5},
          "stroke": {"value": "#4682b4"},
          "fill": {"value": "transparent"}
        }
      }
    }
  ]
}\nScatter plots are ideal for visualizing the relationship between two quantitative variables. This example plots horsepower vs. mileage for a data set of cars. A size encoding is used to additionally depict acceleration.\nView Source
  Export PNG
  Export SVG\nView Source
  Export PNG
  Export SVG\nView in Online Vega Editor\nView in Online Vega Editor\nVega JSON Specification <>\n{
  "$schema": "https://vega.github.io/schema/vega/v5.json",
  "description": "A basic scatter plot example depicting automobile statistics.",
  "width": 200,
  "height": 200,
  "padding": 5,

  "data": [
    {
      "name": "source",
      "url": "data/cars.json",
      "transform": [
        {
          "type": "filter",
          "expr": "datum['Horsepower'] != null && datum['Miles_per_Gallon'] != null && datum['Acceleration'] != null"
        }
      ]
    }
  ],

  "scales": [
    {
      "name": "x",
      "type": "linear",
      "round": true,
      "nice": true,
      "zero": true,
      "domain": {"data": "source", "field": "Horsepower"},
      "range": "width"
    },
    {
      "name": "y",
      "type": "linear",
      "round": true,
      "nice": true,
      "zero": true,
      "domain": {"data": "source", "field": "Miles_per_Gallon"},
      "range": "height"
    },
    {
      "name": "size",
      "type": "linear",
      "round": true,
      "nice": false,
      "zero": true,
      "domain": {"data": "source", "field": "Acceleration"},
      "range": [4,361]
    }
  ],

  "axes": [
    {
      "scale": "x",
      "grid": true,
      "domain": false,
      "orient": "bottom",
      "tickCount": 5,
      "title": "Horsepower"
    },
    {
      "scale": "y",
      "grid": true,
      "domain": false,
      "orient": "left",
      "titlePadding": 5,
      "title": "Miles_per_Gallon"
    }
  ],

  "legends": [
    {
      "size": "size",
      "title": "Acceleration",
      "format": "s",
      "symbolStrokeColor": "#4682b4",
      "symbolStrokeWidth": 2,
      "symbolOpacity": 0.5,
      "symbolType": "circle"
    }
  ],

  "marks": [
    {
      "name": "marks",
      "type": "symbol",
      "from": {"data": "source"},
      "encode": {
        "update": {
          "x": {"scale": "x", "field": "Horsepower"},
          "y": {"scale": "y", "field": "Miles_per_Gallon"},
          "size": {"scale": "size", "field": "Acceleration"},
          "shape": {"value": "circle"},
          "strokeWidth": {"value": 2},
          "opacity": {"value": 0.5},
          "stroke": {"value": "#4682b4"},
          "fill": {"value": "transparent"}
        }
      }
    }
  ]
}\n{
  "$schema": "https://vega.github.io/schema/vega/v5.json",
  "description": "A basic scatter plot example depicting automobile statistics.",
  "width": 200,
  "height": 200,
  "padding": 5,

  "data": [
    {
      "name": "source",
      "url": "data/cars.json",
      "transform": [
        {
          "type": "filter",
          "expr": "datum['Horsepower'] != null && datum['Miles_per_Gallon'] != null && datum['Acceleration'] != null"
        }
      ]
    }
  ],

  "scales": [
    {
      "name": "x",
      "type": "linear",
      "round": true,
      "nice": true,
      "zero": true,
      "domain": {"data": "source", "field": "Horsepower"},
      "range": "width"
    },
    {
      "name": "y",
      "type": "linear",
      "round": true,
      "nice": true,
      "zero": true,
      "domain": {"data": "source", "field": "Miles_per_Gallon"},
      "range": "height"
    },
    {
      "name": "size",
      "type": "linear",
      "round": true,
      "nice": false,
      "zero": true,
      "domain": {"data": "source", "field": "Acceleration"},
      "range": [4,361]
    }
  ],

  "axes": [
    {
      "scale": "x",
      "grid": true,
      "domain": false,
      "orient": "bottom",
      "tickCount": 5,
      "title": "Horsepower"
    },
    {
      "scale": "y",
      "grid": true,
      "domain": false,
      "orient": "left",
      "titlePadding": 5,
      "title": "Miles_per_Gallon"
    }
  ],

  "legends": [
    {
      "size": "size",
      "title": "Acceleration",
      "format": "s",
      "symbolStrokeColor": "#4682b4",
      "symbolStrokeWidth": 2,
      "symbolOpacity": 0.5,
      "symbolType": "circle"
    }
  ],

  "marks": [
    {
      "name": "marks",
      "type": "symbol",
      "from": {"data": "source"},
      "encode": {
        "update": {
          "x": {"scale": "x", "field": "Horsepower"},
          "y": {"scale": "y", "field": "Miles_per_Gallon"},
          "size": {"scale": "size", "field": "Acceleration"},
          "shape": {"value": "circle"},
          "strokeWidth": {"value": 2},
          "opacity": {"value": 0.5},
          "stroke": {"value": "#4682b4"},
          "fill": {"value": "transparent"}
        }
      }
    }
  ]
}\n"https://vega.github.io/schema/vega/v5.json"\n"A basic scatter plot example depicting automobile statistics."\n"datum['Horsepower'] != null && datum['Miles_per_Gallon'] != null && datum['Acceleration'] != null"\n\n\nVega
            
              Vega-Lite
              Altair
              Vega-Lite API
            
          
          
            
              Examples
              Tutorials
              Documentation
              Usage
              About
            
            
              GitHub
              Try Online
            
          
        
      

      
        

  
  
    Scatter Plot Null Values Example
    A configurable scatter plot of movie statistics, including IMDB and Rotten Tomatoes review scores. Null values in one or more dimensions are depicted along the margins to better convey missing values. Tooltips are included for interactive inspection of individual movies.




  
  View Source
  Export PNG
  Export SVG






  View in Online Vega Editor


Vega JSON Specification <>

{
  "$schema": "https://vega.github.io/schema/vega/v5.json",
  "description": "A scatter plot of film statistics, with null values visualized along the axes.",
  "width": 450,
  "height": 450,
  "padding": 5,
  "autosize": {"type": "fit", "resize": true},

  "signals": [
    { "name": "yField", "value": "IMDB Rating",
      "bind": {"input": "select", "options": ["IMDB Rating", "Rotten Tomatoes Rating", "US Gross", "Worldwide Gross"]} },
    { "name": "xField", "value": "Rotten Tomatoes Rating",
      "bind": {"input": "select", "options": ["IMDB Rating", "Rotten Tomatoes Rating", "US Gross", "Worldwide Gross"]} },
    { "name": "nullSize", "value": 8 },
    { "name": "nullGap", "update": "nullSize + 10" }
  ],

  "data": [
    {
      "name": "movies",
      "url": "data/movies.json",
      "transform": [
        {
          "type": "formula",
          "expr": "datum.Title + ' (' + (year(datum['Release Date']) || '?') + ')'",
          "as":   "tooltip"
        }
      ]
    },
    {
      "name": "valid",
      "source": "movies",
      "transform": [
        {
          "type": "filter",
          "expr": "datum[xField] != null && datum[yField] != null"
        }
      ]
    },
    {
      "name": "nullXY",
      "source": "movies",
      "transform": [
        {
          "type": "filter",
          "expr": "datum[xField] == null && datum[yField] == null"
        },
        { "type": "aggregate" }
      ]
    },
    {
      "name": "nullY",
      "source": "movies",
      "transform": [
        {
          "type": "filter",
          "expr": "datum[xField] != null && datum[yField] == null"
        }
      ]
    },
    {
      "name": "nullX",
      "source": "movies",
      "transform": [
        {
          "type": "filter",
          "expr": "datum[xField] == null && datum[yField] != null"
        }
      ]
    }
  ],

  "scales": [
    {
      "name": "yscale",
      "type": "linear",
      "range": [{"signal": "height - nullGap"}, 0],
      "nice": true,
      "domain": {"data": "valid", "field": {"signal": "yField"}}
    },
    {
      "name": "xscale",
      "type": "linear",
      "range": [{"signal": "nullGap"}, {"signal": "width"}],
      "nice": true,
      "domain": {"data": "valid", "field": {"signal": "xField"}}
    }
  ],

  "axes": [
    {
      "orient": "bottom", "scale": "xscale", "offset": 5, "format": "s",
      "title": {"signal": "xField"}
    },
    {
      "orient": "left", "scale": "yscale", "offset": 5, "format": "s",
      "title": {"signal": "yField"}
    }
  ],

  "marks": [
    {
      "type": "symbol",
      "from": {"data": "valid"},
      "encode": {
        "enter": {
          "size": {"value": 50},
          "tooltip": {"field": "tooltip"}
        },
        "update": {
          "x": {"scale": "xscale", "field": {"signal": "xField"}},
          "y": {"scale": "yscale", "field": {"signal": "yField"}},
          "fill": {"value": "steelblue"},
          "fillOpacity": {"value": 0.5},
          "zindex": {"value": 0}
        },
        "hover": {
          "fill": {"value": "firebrick"},
          "fillOpacity": {"value": 1},
          "zindex": {"value": 1}
        }
      }
    },
    {
      "type": "symbol",
      "from": {"data": "nullY"},
      "encode": {
        "enter": {
          "size": {"value": 50},
          "tooltip": {"field": "tooltip"}
        },
        "update": {
          "x": {"scale": "xscale", "field": {"signal": "xField"}},
          "y": {"signal": "height - nullSize/2"},
          "fill": {"value": "#aaa"},
          "fillOpacity": {"value": 0.2}
        },
        "hover": {
          "fill": {"value": "firebrick"},
          "fillOpacity": {"value": 1}
        }
      }
    },
    {
      "type": "symbol",
      "from": {"data": "nullX"},
      "encode": {
        "enter": {
          "size": {"value": 50},
          "tooltip": {"field": "tooltip"}
        },
        "update": {
          "x": {"signal": "nullSize/2"},
          "y": {"scale": "yscale", "field": {"signal": "yField"}},
          "fill": {"value": "#aaa"},
          "fillOpacity": {"value": 0.2},
          "zindex": {"value": 0}
        },
        "hover": {
          "fill": {"value": "firebrick"},
          "fillOpacity": {"value": 1},
          "zindex": {"value": 1}
        }
      }
    },
    {
      "type": "text",
      "interactive": false,
      "from": {"data": "nullXY"},
      "encode": {
        "update": {
          "x": {"signal": "nullSize", "offset": -4},
          "y": {"signal": "height", "offset": 13},
          "text": {"signal": "datum.count + ' null'"},
          "align": {"value": "right"},
          "baseline": {"value": "top"},
          "fill": {"value": "#999"},
          "fontSize": {"value": 9}
        }
      }
    }
  ]
}\nVega
            
              Vega-Lite
              Altair
              Vega-Lite API\nVega-Lite
              Altair
              Vega-Lite API\nExamples
              Tutorials
              Documentation
              Usage
              About
            
            
              GitHub
              Try Online\nExamples
              Tutorials
              Documentation
              Usage
              About\nGitHub
              Try Online\nScatter Plot Null Values Example
    A configurable scatter plot of movie statistics, including IMDB and Rotten Tomatoes review scores. Null values in one or more dimensions are depicted along the margins to better convey missing values. Tooltips are included for interactive inspection of individual movies.




  
  View Source
  Export PNG
  Export SVG






  View in Online Vega Editor


Vega JSON Specification <>

{
  "$schema": "https://vega.github.io/schema/vega/v5.json",
  "description": "A scatter plot of film statistics, with null values visualized along the axes.",
  "width": 450,
  "height": 450,
  "padding": 5,
  "autosize": {"type": "fit", "resize": true},

  "signals": [
    { "name": "yField", "value": "IMDB Rating",
      "bind": {"input": "select", "options": ["IMDB Rating", "Rotten Tomatoes Rating", "US Gross", "Worldwide Gross"]} },
    { "name": "xField", "value": "Rotten Tomatoes Rating",
      "bind": {"input": "select", "options": ["IMDB Rating", "Rotten Tomatoes Rating", "US Gross", "Worldwide Gross"]} },
    { "name": "nullSize", "value": 8 },
    { "name": "nullGap", "update": "nullSize + 10" }
  ],

  "data": [
    {
      "name": "movies",
      "url": "data/movies.json",
      "transform": [
        {
          "type": "formula",
          "expr": "datum.Title + ' (' + (year(datum['Release Date']) || '?') + ')'",
          "as":   "tooltip"
        }
      ]
    },
    {
      "name": "valid",
      "source": "movies",
      "transform": [
        {
          "type": "filter",
          "expr": "datum[xField] != null && datum[yField] != null"
        }
      ]
    },
    {
      "name": "nullXY",
      "source": "movies",
      "transform": [
        {
          "type": "filter",
          "expr": "datum[xField] == null && datum[yField] == null"
        },
        { "type": "aggregate" }
      ]
    },
    {
      "name": "nullY",
      "source": "movies",
      "transform": [
        {
          "type": "filter",
          "expr": "datum[xField] != null && datum[yField] == null"
        }
      ]
    },
    {
      "name": "nullX",
      "source": "movies",
      "transform": [
        {
          "type": "filter",
          "expr": "datum[xField] == null && datum[yField] != null"
        }
      ]
    }
  ],

  "scales": [
    {
      "name": "yscale",
      "type": "linear",
      "range": [{"signal": "height - nullGap"}, 0],
      "nice": true,
      "domain": {"data": "valid", "field": {"signal": "yField"}}
    },
    {
      "name": "xscale",
      "type": "linear",
      "range": [{"signal": "nullGap"}, {"signal": "width"}],
      "nice": true,
      "domain": {"data": "valid", "field": {"signal": "xField"}}
    }
  ],

  "axes": [
    {
      "orient": "bottom", "scale": "xscale", "offset": 5, "format": "s",
      "title": {"signal": "xField"}
    },
    {
      "orient": "left", "scale": "yscale", "offset": 5, "format": "s",
      "title": {"signal": "yField"}
    }
  ],

  "marks": [
    {
      "type": "symbol",
      "from": {"data": "valid"},
      "encode": {
        "enter": {
          "size": {"value": 50},
          "tooltip": {"field": "tooltip"}
        },
        "update": {
          "x": {"scale": "xscale", "field": {"signal": "xField"}},
          "y": {"scale": "yscale", "field": {"signal": "yField"}},
          "fill": {"value": "steelblue"},
          "fillOpacity": {"value": 0.5},
          "zindex": {"value": 0}
        },
        "hover": {
          "fill": {"value": "firebrick"},
          "fillOpacity": {"value": 1},
          "zindex": {"value": 1}
        }
      }
    },
    {
      "type": "symbol",
      "from": {"data": "nullY"},
      "encode": {
        "enter": {
          "size": {"value": 50},
          "tooltip": {"field": "tooltip"}
        },
        "update": {
          "x": {"scale": "xscale", "field": {"signal": "xField"}},
          "y": {"signal": "height - nullSize/2"},
          "fill": {"value": "#aaa"},
          "fillOpacity": {"value": 0.2}
        },
        "hover": {
          "fill": {"value": "firebrick"},
          "fillOpacity": {"value": 1}
        }
      }
    },
    {
      "type": "symbol",
      "from": {"data": "nullX"},
      "encode": {
        "enter": {
          "size": {"value": 50},
          "tooltip": {"field": "tooltip"}
        },
        "update": {
          "x": {"signal": "nullSize/2"},
          "y": {"scale": "yscale", "field": {"signal": "yField"}},
          "fill": {"value": "#aaa"},
          "fillOpacity": {"value": 0.2},
          "zindex": {"value": 0}
        },
        "hover": {
          "fill": {"value": "firebrick"},
          "fillOpacity": {"value": 1},
          "zindex": {"value": 1}
        }
      }
    },
    {
      "type": "text",
      "interactive": false,
      "from": {"data": "nullXY"},
      "encode": {
        "update": {
          "x": {"signal": "nullSize", "offset": -4},
          "y": {"signal": "height", "offset": 13},
          "text": {"signal": "datum.count + ' null'"},
          "align": {"value": "right"},
          "baseline": {"value": "top"},
          "fill": {"value": "#999"},
          "fontSize": {"value": 9}
        }
      }
    }
  ]
}\nScatter Plot Null Values Example\nA configurable scatter plot of movie statistics, including IMDB and Rotten Tomatoes review scores. Null values in one or more dimensions are depicted along the margins to better convey missing values. Tooltips are included for interactive inspection of individual movies.\nView Source
  Export PNG
  Export SVG\nView Source
  Export PNG
  Export SVG\nView in Online Vega Editor\nView in Online Vega Editor\nVega JSON Specification <>\n{
  "$schema": "https://vega.github.io/schema/vega/v5.json",
  "description": "A scatter plot of film statistics, with null values visualized along the axes.",
  "width": 450,
  "height": 450,
  "padding": 5,
  "autosize": {"type": "fit", "resize": true},

  "signals": [
    { "name": "yField", "value": "IMDB Rating",
      "bind": {"input": "select", "options": ["IMDB Rating", "Rotten Tomatoes Rating", "US Gross", "Worldwide Gross"]} },
    { "name": "xField", "value": "Rotten Tomatoes Rating",
      "bind": {"input": "select", "options": ["IMDB Rating", "Rotten Tomatoes Rating", "US Gross", "Worldwide Gross"]} },
    { "name": "nullSize", "value": 8 },
    { "name": "nullGap", "update": "nullSize + 10" }
  ],

  "data": [
    {
      "name": "movies",
      "url": "data/movies.json",
      "transform": [
        {
          "type": "formula",
          "expr": "datum.Title + ' (' + (year(datum['Release Date']) || '?') + ')'",
          "as":   "tooltip"
        }
      ]
    },
    {
      "name": "valid",
      "source": "movies",
      "transform": [
        {
          "type": "filter",
          "expr": "datum[xField] != null && datum[yField] != null"
        }
      ]
    },
    {
      "name": "nullXY",
      "source": "movies",
      "transform": [
        {
          "type": "filter",
          "expr": "datum[xField] == null && datum[yField] == null"
        },
        { "type": "aggregate" }
      ]
    },
    {
      "name": "nullY",
      "source": "movies",
      "transform": [
        {
          "type": "filter",
          "expr": "datum[xField] != null && datum[yField] == null"
        }
      ]
    },
    {
      "name": "nullX",
      "source": "movies",
      "transform": [
        {
          "type": "filter",
          "expr": "datum[xField] == null && datum[yField] != null"
        }
      ]
    }
  ],

  "scales": [
    {
      "name": "yscale",
      "type": "linear",
      "range": [{"signal": "height - nullGap"}, 0],
      "nice": true,
      "domain": {"data": "valid", "field": {"signal": "yField"}}
    },
    {
      "name": "xscale",
      "type": "linear",
      "range": [{"signal": "nullGap"}, {"signal": "width"}],
      "nice": true,
      "domain": {"data": "valid", "field": {"signal": "xField"}}
    }
  ],

  "axes": [
    {
      "orient": "bottom", "scale": "xscale", "offset": 5, "format": "s",
      "title": {"signal": "xField"}
    },
    {
      "orient": "left", "scale": "yscale", "offset": 5, "format": "s",
      "title": {"signal": "yField"}
    }
  ],

  "marks": [
    {
      "type": "symbol",
      "from": {"data": "valid"},
      "encode": {
        "enter": {
          "size": {"value": 50},
          "tooltip": {"field": "tooltip"}
        },
        "update": {
          "x": {"scale": "xscale", "field": {"signal": "xField"}},
          "y": {"scale": "yscale", "field": {"signal": "yField"}},
          "fill": {"value": "steelblue"},
          "fillOpacity": {"value": 0.5},
          "zindex": {"value": 0}
        },
        "hover": {
          "fill": {"value": "firebrick"},
          "fillOpacity": {"value": 1},
          "zindex": {"value": 1}
        }
      }
    },
    {
      "type": "symbol",
      "from": {"data": "nullY"},
      "encode": {
        "enter": {
          "size": {"value": 50},
          "tooltip": {"field": "tooltip"}
        },
        "update": {
          "x": {"scale": "xscale", "field": {"signal": "xField"}},
          "y": {"signal": "height - nullSize/2"},
          "fill": {"value": "#aaa"},
          "fillOpacity": {"value": 0.2}
        },
        "hover": {
          "fill": {"value": "firebrick"},
          "fillOpacity": {"value": 1}
        }
      }
    },
    {
      "type": "symbol",
      "from": {"data": "nullX"},
      "encode": {
        "enter": {
          "size": {"value": 50},
          "tooltip": {"field": "tooltip"}
        },
        "update": {
          "x": {"signal": "nullSize/2"},
          "y": {"scale": "yscale", "field": {"signal": "yField"}},
          "fill": {"value": "#aaa"},
          "fillOpacity": {"value": 0.2},
          "zindex": {"value": 0}
        },
        "hover": {
          "fill": {"value": "firebrick"},
          "fillOpacity": {"value": 1},
          "zindex": {"value": 1}
        }
      }
    },
    {
      "type": "text",
      "interactive": false,
      "from": {"data": "nullXY"},
      "encode": {
        "update": {
          "x": {"signal": "nullSize", "offset": -4},
          "y": {"signal": "height", "offset": 13},
          "text": {"signal": "datum.count + ' null'"},
          "align": {"value": "right"},
          "baseline": {"value": "top"},
          "fill": {"value": "#999"},
          "fontSize": {"value": 9}
        }
      }
    }
  ]
}\n{
  "$schema": "https://vega.github.io/schema/vega/v5.json",
  "description": "A scatter plot of film statistics, with null values visualized along the axes.",
  "width": 450,
  "height": 450,
  "padding": 5,
  "autosize": {"type": "fit", "resize": true},

  "signals": [
    { "name": "yField", "value": "IMDB Rating",
      "bind": {"input": "select", "options": ["IMDB Rating", "Rotten Tomatoes Rating", "US Gross", "Worldwide Gross"]} },
    { "name": "xField", "value": "Rotten Tomatoes Rating",
      "bind": {"input": "select", "options": ["IMDB Rating", "Rotten Tomatoes Rating", "US Gross", "Worldwide Gross"]} },
    { "name": "nullSize", "value": 8 },
    { "name": "nullGap", "update": "nullSize + 10" }
  ],

  "data": [
    {
      "name": "movies",
      "url": "data/movies.json",
      "transform": [
        {
          "type": "formula",
          "expr": "datum.Title + ' (' + (year(datum['Release Date']) || '?') + ')'",
          "as":   "tooltip"
        }
      ]
    },
    {
      "name": "valid",
      "source": "movies",
      "transform": [
        {
          "type": "filter",
          "expr": "datum[xField] != null && datum[yField] != null"
        }
      ]
    },
    {
      "name": "nullXY",
      "source": "movies",
      "transform": [
        {
          "type": "filter",
          "expr": "datum[xField] == null && datum[yField] == null"
        },
        { "type": "aggregate" }
      ]
    },
    {
      "name": "nullY",
      "source": "movies",
      "transform": [
        {
          "type": "filter",
          "expr": "datum[xField] != null && datum[yField] == null"
        }
      ]
    },
    {
      "name": "nullX",
      "source": "movies",
      "transform": [
        {
          "type": "filter",
          "expr": "datum[xField] == null && datum[yField] != null"
        }
      ]
    }
  ],

  "scales": [
    {
      "name": "yscale",
      "type": "linear",
      "range": [{"signal": "height - nullGap"}, 0],
      "nice": true,
      "domain": {"data": "valid", "field": {"signal": "yField"}}
    },
    {
      "name": "xscale",
      "type": "linear",
      "range": [{"signal": "nullGap"}, {"signal": "width"}],
      "nice": true,
      "domain": {"data": "valid", "field": {"signal": "xField"}}
    }
  ],

  "axes": [
    {
      "orient": "bottom", "scale": "xscale", "offset": 5, "format": "s",
      "title": {"signal": "xField"}
    },
    {
      "orient": "left", "scale": "yscale", "offset": 5, "format": "s",
      "title": {"signal": "yField"}
    }
  ],

  "marks": [
    {
      "type": "symbol",
      "from": {"data": "valid"},
      "encode": {
        "enter": {
          "size": {"value": 50},
          "tooltip": {"field": "tooltip"}
        },
        "update": {
          "x": {"scale": "xscale", "field": {"signal": "xField"}},
          "y": {"scale": "yscale", "field": {"signal": "yField"}},
          "fill": {"value": "steelblue"},
          "fillOpacity": {"value": 0.5},
          "zindex": {"value": 0}
        },
        "hover": {
          "fill": {"value": "firebrick"},
          "fillOpacity": {"value": 1},
          "zindex": {"value": 1}
        }
      }
    },
    {
      "type": "symbol",
      "from": {"data": "nullY"},
      "encode": {
        "enter": {
          "size": {"value": 50},
          "tooltip": {"field": "tooltip"}
        },
        "update": {
          "x": {"scale": "xscale", "field": {"signal": "xField"}},
          "y": {"signal": "height - nullSize/2"},
          "fill": {"value": "#aaa"},
          "fillOpacity": {"value": 0.2}
        },
        "hover": {
          "fill": {"value": "firebrick"},
          "fillOpacity": {"value": 1}
        }
      }
    },
    {
      "type": "symbol",
      "from": {"data": "nullX"},
      "encode": {
        "enter": {
          "size": {"value": 50},
          "tooltip": {"field": "tooltip"}
        },
        "update": {
          "x": {"signal": "nullSize/2"},
          "y": {"scale": "yscale", "field": {"signal": "yField"}},
          "fill": {"value": "#aaa"},
          "fillOpacity": {"value": 0.2},
          "zindex": {"value": 0}
        },
        "hover": {
          "fill": {"value": "firebrick"},
          "fillOpacity": {"value": 1},
          "zindex": {"value": 1}
        }
      }
    },
    {
      "type": "text",
      "interactive": false,
      "from": {"data": "nullXY"},
      "encode": {
        "update": {
          "x": {"signal": "nullSize", "offset": -4},
          "y": {"signal": "height", "offset": 13},
          "text": {"signal": "datum.count + ' null'"},
          "align": {"value": "right"},
          "baseline": {"value": "top"},
          "fill": {"value": "#999"},
          "fontSize": {"value": 9}
        }
      }
    }
  ]
}\n"https://vega.github.io/schema/vega/v5.json"\n"A scatter plot of film statistics, with null values visualized along the axes."\n"Rotten Tomatoes Rating"\n"Rotten Tomatoes Rating"\n"Rotten Tomatoes Rating"\n"datum.Title + ' (' + (year(datum['Release Date']) || '?') + ')'"\n"datum[xField] != null && datum[yField] != null"\n"datum[xField] == null && datum[yField] == null"\n"datum[xField] != null && datum[yField] == null"\n"datum[xField] == null && datum[yField] != null"\n"height - nullSize/2"\n"datum.count + ' null'"\n\n\nVega
            
              Vega-Lite
              Altair
              Vega-Lite API
            
          
          
            
              Examples
              Tutorials
              Documentation
              Usage
              About
            
            
              GitHub
              Try Online
            
          
        
      

      
        

  
  
    Connected Scatter Plot Example
    A connected scatter plot uses line segments to connect consecutive scatter plot points, for example to illustrate trajectories over time. This example shows the shifting relationship between the price of gas and the average number of miles driven in a year, adapted from Driving Shifts Into Reverse by Hannah Fairfield, The New York Times (May 2, 2010).




  
  View Source
  Export PNG
  Export SVG






  View in Online Vega Editor


Vega JSON Specification <>

{
  "$schema": "https://vega.github.io/schema/vega/v5.json",
  "description": "An example of a connected scatter plot, tracking changes in miles driven versus the price of gasoline.",
  "width": 800,
  "height": 500,
  "padding": 5,

  "config": {
    "axis": {
      "domain": false,
      "labelFontSize": 12,
      "labelFontWeight": "bold",
      "tickSize": 0
    }
  },

  "data": [
    {
      "name": "drive",
      "url": "data/driving.json"
    }
  ],

  "scales": [
    {
      "name": "x",
      "type": "linear",
      "domain": {"data": "drive", "field": "miles"},
      "range": "width",
      "nice": true,
      "zero": false,
      "round": true
    },
    {
      "name": "y",
      "type": "linear",
      "domain": {"data": "drive", "field": "gas"},
      "range": "height",
      "nice": true,
      "zero": false,
      "round": true
    },
    {
      "name": "align",
      "type": "ordinal",
      "domain": ["left", "right", "top", "bottom"],
      "range": ["right", "left", "center", "center"]
    },
    {
      "name": "base",
      "type": "ordinal",
      "domain": ["left", "right", "top", "bottom"],
      "range": ["middle", "middle", "bottom", "top"]
    },
    {
      "name": "dx",
      "type": "ordinal",
      "domain": ["left", "right", "top", "bottom"],
      "range": [-7, 6, 0, 0]
    },
    {
      "name": "dy",
      "type": "ordinal",
      "domain": ["left", "right", "top", "bottom"],
      "range": [1, 1, -5, 6]
    }
  ],

  "axes": [
    {
      "orient": "top",
      "scale": "x",
      "tickCount": 5,
      "grid": true
    },
    {
      "orient": "bottom",
      "scale": "x",
      "title": "Miles driven per capita each year",
      "ticks": false,
      "labels": false
    },
    {
      "orient": "left",
      "scale": "y",
      "tickCount": 5,
      "grid": true,
      "format": "$0.2f"
    },
    {
      "orient": "right",
      "scale": "y",
      "title": "Price of a gallon of gasoline (adjusted for inflation)",
      "ticks": false,
      "labels": false
    }
  ],

  "marks": [
    {
      "type": "line",
      "from": {"data": "drive"},
      "encode": {
        "enter": {
          "interpolate": {"value": "cardinal"},
          "x": {"scale": "x", "field": "miles"},
          "y": {"scale": "y", "field": "gas"},
          "stroke": {"value": "#000"},
          "strokeWidth": {"value": 3}
        }
      }
    },
    {
      "type": "symbol",
      "from": {"data": "drive"},
      "encode": {
        "enter": {
          "x": {"scale": "x", "field": "miles"},
          "y": {"scale": "y", "field": "gas"},
          "fill": {"value": "#fff"},
          "stroke": {"value": "#000"},
          "strokeWidth": {"value": 1},
          "size": {"value": 49}
        }
      }
    },
    {
      "type": "text",
      "from": {"data": "drive"},
      "encode": {
        "enter": {
          "x": {"scale": "x", "field": "miles"},
          "y": {"scale": "y", "field": "gas"},
          "dx": {"scale": "dx", "field": "side"},
          "dy": {"scale": "dy", "field": "side"},
          "fill": {"value": "#000"},
          "text": {"field": "year"},
          "align": {"scale": "align", "field": "side"},
          "baseline": {"scale": "base", "field": "side"}
        }
      }
    }
  ]
}\nVega
            
              Vega-Lite
              Altair
              Vega-Lite API\nVega-Lite
              Altair
              Vega-Lite API\nExamples
              Tutorials
              Documentation
              Usage
              About
            
            
              GitHub
              Try Online\nExamples
              Tutorials
              Documentation
              Usage
              About\nGitHub
              Try Online\nConnected Scatter Plot Example
    A connected scatter plot uses line segments to connect consecutive scatter plot points, for example to illustrate trajectories over time. This example shows the shifting relationship between the price of gas and the average number of miles driven in a year, adapted from Driving Shifts Into Reverse by Hannah Fairfield, The New York Times (May 2, 2010).




  
  View Source
  Export PNG
  Export SVG






  View in Online Vega Editor


Vega JSON Specification <>

{
  "$schema": "https://vega.github.io/schema/vega/v5.json",
  "description": "An example of a connected scatter plot, tracking changes in miles driven versus the price of gasoline.",
  "width": 800,
  "height": 500,
  "padding": 5,

  "config": {
    "axis": {
      "domain": false,
      "labelFontSize": 12,
      "labelFontWeight": "bold",
      "tickSize": 0
    }
  },

  "data": [
    {
      "name": "drive",
      "url": "data/driving.json"
    }
  ],

  "scales": [
    {
      "name": "x",
      "type": "linear",
      "domain": {"data": "drive", "field": "miles"},
      "range": "width",
      "nice": true,
      "zero": false,
      "round": true
    },
    {
      "name": "y",
      "type": "linear",
      "domain": {"data": "drive", "field": "gas"},
      "range": "height",
      "nice": true,
      "zero": false,
      "round": true
    },
    {
      "name": "align",
      "type": "ordinal",
      "domain": ["left", "right", "top", "bottom"],
      "range": ["right", "left", "center", "center"]
    },
    {
      "name": "base",
      "type": "ordinal",
      "domain": ["left", "right", "top", "bottom"],
      "range": ["middle", "middle", "bottom", "top"]
    },
    {
      "name": "dx",
      "type": "ordinal",
      "domain": ["left", "right", "top", "bottom"],
      "range": [-7, 6, 0, 0]
    },
    {
      "name": "dy",
      "type": "ordinal",
      "domain": ["left", "right", "top", "bottom"],
      "range": [1, 1, -5, 6]
    }
  ],

  "axes": [
    {
      "orient": "top",
      "scale": "x",
      "tickCount": 5,
      "grid": true
    },
    {
      "orient": "bottom",
      "scale": "x",
      "title": "Miles driven per capita each year",
      "ticks": false,
      "labels": false
    },
    {
      "orient": "left",
      "scale": "y",
      "tickCount": 5,
      "grid": true,
      "format": "$0.2f"
    },
    {
      "orient": "right",
      "scale": "y",
      "title": "Price of a gallon of gasoline (adjusted for inflation)",
      "ticks": false,
      "labels": false
    }
  ],

  "marks": [
    {
      "type": "line",
      "from": {"data": "drive"},
      "encode": {
        "enter": {
          "interpolate": {"value": "cardinal"},
          "x": {"scale": "x", "field": "miles"},
          "y": {"scale": "y", "field": "gas"},
          "stroke": {"value": "#000"},
          "strokeWidth": {"value": 3}
        }
      }
    },
    {
      "type": "symbol",
      "from": {"data": "drive"},
      "encode": {
        "enter": {
          "x": {"scale": "x", "field": "miles"},
          "y": {"scale": "y", "field": "gas"},
          "fill": {"value": "#fff"},
          "stroke": {"value": "#000"},
          "strokeWidth": {"value": 1},
          "size": {"value": 49}
        }
      }
    },
    {
      "type": "text",
      "from": {"data": "drive"},
      "encode": {
        "enter": {
          "x": {"scale": "x", "field": "miles"},
          "y": {"scale": "y", "field": "gas"},
          "dx": {"scale": "dx", "field": "side"},
          "dy": {"scale": "dy", "field": "side"},
          "fill": {"value": "#000"},
          "text": {"field": "year"},
          "align": {"scale": "align", "field": "side"},
          "baseline": {"scale": "base", "field": "side"}
        }
      }
    }
  ]
}\nConnected Scatter Plot Example\nA connected scatter plot uses line segments to connect consecutive scatter plot points, for example to illustrate trajectories over time. This example shows the shifting relationship between the price of gas and the average number of miles driven in a year, adapted from Driving Shifts Into Reverse by Hannah Fairfield, The New York Times (May 2, 2010).\nDriving Shifts Into Reverse\nView Source
  Export PNG
  Export SVG\nView Source
  Export PNG
  Export SVG\nView in Online Vega Editor\nView in Online Vega Editor\nVega JSON Specification <>\n{
  "$schema": "https://vega.github.io/schema/vega/v5.json",
  "description": "An example of a connected scatter plot, tracking changes in miles driven versus the price of gasoline.",
  "width": 800,
  "height": 500,
  "padding": 5,

  "config": {
    "axis": {
      "domain": false,
      "labelFontSize": 12,
      "labelFontWeight": "bold",
      "tickSize": 0
    }
  },

  "data": [
    {
      "name": "drive",
      "url": "data/driving.json"
    }
  ],

  "scales": [
    {
      "name": "x",
      "type": "linear",
      "domain": {"data": "drive", "field": "miles"},
      "range": "width",
      "nice": true,
      "zero": false,
      "round": true
    },
    {
      "name": "y",
      "type": "linear",
      "domain": {"data": "drive", "field": "gas"},
      "range": "height",
      "nice": true,
      "zero": false,
      "round": true
    },
    {
      "name": "align",
      "type": "ordinal",
      "domain": ["left", "right", "top", "bottom"],
      "range": ["right", "left", "center", "center"]
    },
    {
      "name": "base",
      "type": "ordinal",
      "domain": ["left", "right", "top", "bottom"],
      "range": ["middle", "middle", "bottom", "top"]
    },
    {
      "name": "dx",
      "type": "ordinal",
      "domain": ["left", "right", "top", "bottom"],
      "range": [-7, 6, 0, 0]
    },
    {
      "name": "dy",
      "type": "ordinal",
      "domain": ["left", "right", "top", "bottom"],
      "range": [1, 1, -5, 6]
    }
  ],

  "axes": [
    {
      "orient": "top",
      "scale": "x",
      "tickCount": 5,
      "grid": true
    },
    {
      "orient": "bottom",
      "scale": "x",
      "title": "Miles driven per capita each year",
      "ticks": false,
      "labels": false
    },
    {
      "orient": "left",
      "scale": "y",
      "tickCount": 5,
      "grid": true,
      "format": "$0.2f"
    },
    {
      "orient": "right",
      "scale": "y",
      "title": "Price of a gallon of gasoline (adjusted for inflation)",
      "ticks": false,
      "labels": false
    }
  ],

  "marks": [
    {
      "type": "line",
      "from": {"data": "drive"},
      "encode": {
        "enter": {
          "interpolate": {"value": "cardinal"},
          "x": {"scale": "x", "field": "miles"},
          "y": {"scale": "y", "field": "gas"},
          "stroke": {"value": "#000"},
          "strokeWidth": {"value": 3}
        }
      }
    },
    {
      "type": "symbol",
      "from": {"data": "drive"},
      "encode": {
        "enter": {
          "x": {"scale": "x", "field": "miles"},
          "y": {"scale": "y", "field": "gas"},
          "fill": {"value": "#fff"},
          "stroke": {"value": "#000"},
          "strokeWidth": {"value": 1},
          "size": {"value": 49}
        }
      }
    },
    {
      "type": "text",
      "from": {"data": "drive"},
      "encode": {
        "enter": {
          "x": {"scale": "x", "field": "miles"},
          "y": {"scale": "y", "field": "gas"},
          "dx": {"scale": "dx", "field": "side"},
          "dy": {"scale": "dy", "field": "side"},
          "fill": {"value": "#000"},
          "text": {"field": "year"},
          "align": {"scale": "align", "field": "side"},
          "baseline": {"scale": "base", "field": "side"}
        }
      }
    }
  ]
}\n{
  "$schema": "https://vega.github.io/schema/vega/v5.json",
  "description": "An example of a connected scatter plot, tracking changes in miles driven versus the price of gasoline.",
  "width": 800,
  "height": 500,
  "padding": 5,

  "config": {
    "axis": {
      "domain": false,
      "labelFontSize": 12,
      "labelFontWeight": "bold",
      "tickSize": 0
    }
  },

  "data": [
    {
      "name": "drive",
      "url": "data/driving.json"
    }
  ],

  "scales": [
    {
      "name": "x",
      "type": "linear",
      "domain": {"data": "drive", "field": "miles"},
      "range": "width",
      "nice": true,
      "zero": false,
      "round": true
    },
    {
      "name": "y",
      "type": "linear",
      "domain": {"data": "drive", "field": "gas"},
      "range": "height",
      "nice": true,
      "zero": false,
      "round": true
    },
    {
      "name": "align",
      "type": "ordinal",
      "domain": ["left", "right", "top", "bottom"],
      "range": ["right", "left", "center", "center"]
    },
    {
      "name": "base",
      "type": "ordinal",
      "domain": ["left", "right", "top", "bottom"],
      "range": ["middle", "middle", "bottom", "top"]
    },
    {
      "name": "dx",
      "type": "ordinal",
      "domain": ["left", "right", "top", "bottom"],
      "range": [-7, 6, 0, 0]
    },
    {
      "name": "dy",
      "type": "ordinal",
      "domain": ["left", "right", "top", "bottom"],
      "range": [1, 1, -5, 6]
    }
  ],

  "axes": [
    {
      "orient": "top",
      "scale": "x",
      "tickCount": 5,
      "grid": true
    },
    {
      "orient": "bottom",
      "scale": "x",
      "title": "Miles driven per capita each year",
      "ticks": false,
      "labels": false
    },
    {
      "orient": "left",
      "scale": "y",
      "tickCount": 5,
      "grid": true,
      "format": "$0.2f"
    },
    {
      "orient": "right",
      "scale": "y",
      "title": "Price of a gallon of gasoline (adjusted for inflation)",
      "ticks": false,
      "labels": false
    }
  ],

  "marks": [
    {
      "type": "line",
      "from": {"data": "drive"},
      "encode": {
        "enter": {
          "interpolate": {"value": "cardinal"},
          "x": {"scale": "x", "field": "miles"},
          "y": {"scale": "y", "field": "gas"},
          "stroke": {"value": "#000"},
          "strokeWidth": {"value": 3}
        }
      }
    },
    {
      "type": "symbol",
      "from": {"data": "drive"},
      "encode": {
        "enter": {
          "x": {"scale": "x", "field": "miles"},
          "y": {"scale": "y", "field": "gas"},
          "fill": {"value": "#fff"},
          "stroke": {"value": "#000"},
          "strokeWidth": {"value": 1},
          "size": {"value": 49}
        }
      }
    },
    {
      "type": "text",
      "from": {"data": "drive"},
      "encode": {
        "enter": {
          "x": {"scale": "x", "field": "miles"},
          "y": {"scale": "y", "field": "gas"},
          "dx": {"scale": "dx", "field": "side"},
          "dy": {"scale": "dy", "field": "side"},
          "fill": {"value": "#000"},
          "text": {"field": "year"},
          "align": {"scale": "align", "field": "side"},
          "baseline": {"scale": "base", "field": "side"}
        }
      }
    }
  ]
}\n"https://vega.github.io/schema/vega/v5.json"\n"An example of a connected scatter plot, tracking changes in miles driven versus the price of gasoline."\n"Miles driven per capita each year"\n"Price of a gallon of gasoline (adjusted for inflation)"\n\n\nVega
            
              Vega-Lite
              Altair
              Vega-Lite API
            
          
          
            
              Examples
              Tutorials
              Documentation
              Usage
              About
            
            
              GitHub
              Try Online
            
          
        
      

      
        

  
  
    Error Bars Example
    A dot plot of average yields for a variety of barley strains, with error bars indicating the spread of values. Vega can visualize pre-calculated error ranges or apply a number of standard measures. Use the drop down menu to visualize different measures of spread, including the 95% confidence interval of the mean (calculated via bootstrapping), standard error, standard deviation, and the interquartile range.




  
  View Source
  Export PNG
  Export SVG






  View in Online Vega Editor


Vega JSON Specification <>

{
  "$schema": "https://vega.github.io/schema/vega/v5.json",
  "description": "A basic error bar visualization example.",
  "width": 500,
  "height": 160,
  "padding": 5,

  "config": {
    "axisBand": {
      "bandPosition": 1,
      "tickExtra": true,
      "tickOffset": 0
    }
  },

  "signals": [
    {
      "name": "errorMeasure", "value": "95% Confidence Interval",
      "bind": {"input": "select", "options": [
        "95% Confidence Interval",
        "Standard Error",
        "Standard Deviation",
        "Interquartile Range"
      ]}
    },
    {
      "name": "lookup",
      "value": {
        "95% Confidence Interval": "ci",
        "Standard Deviation": "stdev",
        "Standard Error": "stderr",
        "Interquartile Range": "iqr"
      }
    },
    {
      "name": "measure",
      "update": "lookup[errorMeasure]"
    }
  ],

  "data": [
    {
      "name": "barley",
      "url": "data/barley.json"
    },
    {
      "name": "summary",
      "source": "barley",
      "transform": [
        {
          "type": "aggregate",
          "groupby": ["variety"],
          "fields": ["yield", "yield", "yield", "yield", "yield", "yield", "yield"],
          "ops": ["mean", "stdev", "stderr", "ci0", "ci1", "q1", "q3"],
          "as": ["mean", "stdev", "stderr", "ci0", "ci1", "iqr0", "iqr1"]
        },
        {
          "type": "formula", "as": "stdev0",
          "expr": "datum.mean - datum.stdev"
        },
        {
          "type": "formula", "as": "stdev1",
          "expr": "datum.mean + datum.stdev"
        },
        {
          "type": "formula", "as": "stderr0",
          "expr": "datum.mean - datum.stderr"
        },
        {
          "type": "formula", "as": "stderr1",
          "expr": "datum.mean + datum.stderr"
        }
      ]
    }
  ],

  "scales": [
    {
      "name": "yscale",
      "type": "band",
      "range": "height",
      "domain": {
        "data": "summary",
        "field": "variety",
        "sort": {"op": "max", "field": "mean", "order": "descending"}
      }
    },
    {
      "name": "xscale",
      "type": "linear",
      "range": "width", "round": true,
      "domain": {"data": "summary", "fields": ["stdev0", "stdev1"]},
      "zero": false, "nice": true
    }
  ],

  "axes": [
    {"orient": "bottom", "scale": "xscale", "zindex": 1, "title": "Barley Yield"},
    {"orient": "left", "scale": "yscale", "tickCount": 5, "zindex": 1}
  ],

  "marks": [
    {
      "type": "rect",
      "from": {"data": "summary"},
      "encode": {
        "enter": {
          "fill": {"value": "black"},
          "height": {"value": 1}
        },
        "update": {
          "y": {"scale": "yscale", "field": "variety", "band": 0.5},
          "x": {"scale": "xscale", "signal": "datum[measure+'0']"},
          "x2": {"scale": "xscale", "signal": "datum[measure+'1']"}
        }
      }
    },
    {
      "type": "symbol",
      "from": {"data": "summary"},
      "encode": {
        "enter": {
          "fill": {"value": "black"},
          "size": {"value": 40}
        },
        "update": {
          "x": {"scale": "xscale", "field": "mean"},
          "y": {"scale": "yscale", "field": "variety", "band": 0.5}
        }
      }
    }
  ]
}\nVega
            
              Vega-Lite
              Altair
              Vega-Lite API\nVega-Lite
              Altair
              Vega-Lite API\nExamples
              Tutorials
              Documentation
              Usage
              About
            
            
              GitHub
              Try Online\nExamples
              Tutorials
              Documentation
              Usage
              About\nGitHub
              Try Online\nError Bars Example
    A dot plot of average yields for a variety of barley strains, with error bars indicating the spread of values. Vega can visualize pre-calculated error ranges or apply a number of standard measures. Use the drop down menu to visualize different measures of spread, including the 95% confidence interval of the mean (calculated via bootstrapping), standard error, standard deviation, and the interquartile range.




  
  View Source
  Export PNG
  Export SVG






  View in Online Vega Editor


Vega JSON Specification <>

{
  "$schema": "https://vega.github.io/schema/vega/v5.json",
  "description": "A basic error bar visualization example.",
  "width": 500,
  "height": 160,
  "padding": 5,

  "config": {
    "axisBand": {
      "bandPosition": 1,
      "tickExtra": true,
      "tickOffset": 0
    }
  },

  "signals": [
    {
      "name": "errorMeasure", "value": "95% Confidence Interval",
      "bind": {"input": "select", "options": [
        "95% Confidence Interval",
        "Standard Error",
        "Standard Deviation",
        "Interquartile Range"
      ]}
    },
    {
      "name": "lookup",
      "value": {
        "95% Confidence Interval": "ci",
        "Standard Deviation": "stdev",
        "Standard Error": "stderr",
        "Interquartile Range": "iqr"
      }
    },
    {
      "name": "measure",
      "update": "lookup[errorMeasure]"
    }
  ],

  "data": [
    {
      "name": "barley",
      "url": "data/barley.json"
    },
    {
      "name": "summary",
      "source": "barley",
      "transform": [
        {
          "type": "aggregate",
          "groupby": ["variety"],
          "fields": ["yield", "yield", "yield", "yield", "yield", "yield", "yield"],
          "ops": ["mean", "stdev", "stderr", "ci0", "ci1", "q1", "q3"],
          "as": ["mean", "stdev", "stderr", "ci0", "ci1", "iqr0", "iqr1"]
        },
        {
          "type": "formula", "as": "stdev0",
          "expr": "datum.mean - datum.stdev"
        },
        {
          "type": "formula", "as": "stdev1",
          "expr": "datum.mean + datum.stdev"
        },
        {
          "type": "formula", "as": "stderr0",
          "expr": "datum.mean - datum.stderr"
        },
        {
          "type": "formula", "as": "stderr1",
          "expr": "datum.mean + datum.stderr"
        }
      ]
    }
  ],

  "scales": [
    {
      "name": "yscale",
      "type": "band",
      "range": "height",
      "domain": {
        "data": "summary",
        "field": "variety",
        "sort": {"op": "max", "field": "mean", "order": "descending"}
      }
    },
    {
      "name": "xscale",
      "type": "linear",
      "range": "width", "round": true,
      "domain": {"data": "summary", "fields": ["stdev0", "stdev1"]},
      "zero": false, "nice": true
    }
  ],

  "axes": [
    {"orient": "bottom", "scale": "xscale", "zindex": 1, "title": "Barley Yield"},
    {"orient": "left", "scale": "yscale", "tickCount": 5, "zindex": 1}
  ],

  "marks": [
    {
      "type": "rect",
      "from": {"data": "summary"},
      "encode": {
        "enter": {
          "fill": {"value": "black"},
          "height": {"value": 1}
        },
        "update": {
          "y": {"scale": "yscale", "field": "variety", "band": 0.5},
          "x": {"scale": "xscale", "signal": "datum[measure+'0']"},
          "x2": {"scale": "xscale", "signal": "datum[measure+'1']"}
        }
      }
    },
    {
      "type": "symbol",
      "from": {"data": "summary"},
      "encode": {
        "enter": {
          "fill": {"value": "black"},
          "size": {"value": 40}
        },
        "update": {
          "x": {"scale": "xscale", "field": "mean"},
          "y": {"scale": "yscale", "field": "variety", "band": 0.5}
        }
      }
    }
  ]
}\nA dot plot of average yields for a variety of barley strains, with error bars indicating the spread of values. Vega can visualize pre-calculated error ranges or apply a number of standard measures. Use the drop down menu to visualize different measures of spread, including the 95% confidence interval of the mean (calculated via bootstrapping), standard error, standard deviation, and the interquartile range.\nView Source
  Export PNG
  Export SVG\nView Source
  Export PNG
  Export SVG\nView in Online Vega Editor\nView in Online Vega Editor\nVega JSON Specification <>\n{
  "$schema": "https://vega.github.io/schema/vega/v5.json",
  "description": "A basic error bar visualization example.",
  "width": 500,
  "height": 160,
  "padding": 5,

  "config": {
    "axisBand": {
      "bandPosition": 1,
      "tickExtra": true,
      "tickOffset": 0
    }
  },

  "signals": [
    {
      "name": "errorMeasure", "value": "95% Confidence Interval",
      "bind": {"input": "select", "options": [
        "95% Confidence Interval",
        "Standard Error",
        "Standard Deviation",
        "Interquartile Range"
      ]}
    },
    {
      "name": "lookup",
      "value": {
        "95% Confidence Interval": "ci",
        "Standard Deviation": "stdev",
        "Standard Error": "stderr",
        "Interquartile Range": "iqr"
      }
    },
    {
      "name": "measure",
      "update": "lookup[errorMeasure]"
    }
  ],

  "data": [
    {
      "name": "barley",
      "url": "data/barley.json"
    },
    {
      "name": "summary",
      "source": "barley",
      "transform": [
        {
          "type": "aggregate",
          "groupby": ["variety"],
          "fields": ["yield", "yield", "yield", "yield", "yield", "yield", "yield"],
          "ops": ["mean", "stdev", "stderr", "ci0", "ci1", "q1", "q3"],
          "as": ["mean", "stdev", "stderr", "ci0", "ci1", "iqr0", "iqr1"]
        },
        {
          "type": "formula", "as": "stdev0",
          "expr": "datum.mean - datum.stdev"
        },
        {
          "type": "formula", "as": "stdev1",
          "expr": "datum.mean + datum.stdev"
        },
        {
          "type": "formula", "as": "stderr0",
          "expr": "datum.mean - datum.stderr"
        },
        {
          "type": "formula", "as": "stderr1",
          "expr": "datum.mean + datum.stderr"
        }
      ]
    }
  ],

  "scales": [
    {
      "name": "yscale",
      "type": "band",
      "range": "height",
      "domain": {
        "data": "summary",
        "field": "variety",
        "sort": {"op": "max", "field": "mean", "order": "descending"}
      }
    },
    {
      "name": "xscale",
      "type": "linear",
      "range": "width", "round": true,
      "domain": {"data": "summary", "fields": ["stdev0", "stdev1"]},
      "zero": false, "nice": true
    }
  ],

  "axes": [
    {"orient": "bottom", "scale": "xscale", "zindex": 1, "title": "Barley Yield"},
    {"orient": "left", "scale": "yscale", "tickCount": 5, "zindex": 1}
  ],

  "marks": [
    {
      "type": "rect",
      "from": {"data": "summary"},
      "encode": {
        "enter": {
          "fill": {"value": "black"},
          "height": {"value": 1}
        },
        "update": {
          "y": {"scale": "yscale", "field": "variety", "band": 0.5},
          "x": {"scale": "xscale", "signal": "datum[measure+'0']"},
          "x2": {"scale": "xscale", "signal": "datum[measure+'1']"}
        }
      }
    },
    {
      "type": "symbol",
      "from": {"data": "summary"},
      "encode": {
        "enter": {
          "fill": {"value": "black"},
          "size": {"value": 40}
        },
        "update": {
          "x": {"scale": "xscale", "field": "mean"},
          "y": {"scale": "yscale", "field": "variety", "band": 0.5}
        }
      }
    }
  ]
}\n{
  "$schema": "https://vega.github.io/schema/vega/v5.json",
  "description": "A basic error bar visualization example.",
  "width": 500,
  "height": 160,
  "padding": 5,

  "config": {
    "axisBand": {
      "bandPosition": 1,
      "tickExtra": true,
      "tickOffset": 0
    }
  },

  "signals": [
    {
      "name": "errorMeasure", "value": "95% Confidence Interval",
      "bind": {"input": "select", "options": [
        "95% Confidence Interval",
        "Standard Error",
        "Standard Deviation",
        "Interquartile Range"
      ]}
    },
    {
      "name": "lookup",
      "value": {
        "95% Confidence Interval": "ci",
        "Standard Deviation": "stdev",
        "Standard Error": "stderr",
        "Interquartile Range": "iqr"
      }
    },
    {
      "name": "measure",
      "update": "lookup[errorMeasure]"
    }
  ],

  "data": [
    {
      "name": "barley",
      "url": "data/barley.json"
    },
    {
      "name": "summary",
      "source": "barley",
      "transform": [
        {
          "type": "aggregate",
          "groupby": ["variety"],
          "fields": ["yield", "yield", "yield", "yield", "yield", "yield", "yield"],
          "ops": ["mean", "stdev", "stderr", "ci0", "ci1", "q1", "q3"],
          "as": ["mean", "stdev", "stderr", "ci0", "ci1", "iqr0", "iqr1"]
        },
        {
          "type": "formula", "as": "stdev0",
          "expr": "datum.mean - datum.stdev"
        },
        {
          "type": "formula", "as": "stdev1",
          "expr": "datum.mean + datum.stdev"
        },
        {
          "type": "formula", "as": "stderr0",
          "expr": "datum.mean - datum.stderr"
        },
        {
          "type": "formula", "as": "stderr1",
          "expr": "datum.mean + datum.stderr"
        }
      ]
    }
  ],

  "scales": [
    {
      "name": "yscale",
      "type": "band",
      "range": "height",
      "domain": {
        "data": "summary",
        "field": "variety",
        "sort": {"op": "max", "field": "mean", "order": "descending"}
      }
    },
    {
      "name": "xscale",
      "type": "linear",
      "range": "width", "round": true,
      "domain": {"data": "summary", "fields": ["stdev0", "stdev1"]},
      "zero": false, "nice": true
    }
  ],

  "axes": [
    {"orient": "bottom", "scale": "xscale", "zindex": 1, "title": "Barley Yield"},
    {"orient": "left", "scale": "yscale", "tickCount": 5, "zindex": 1}
  ],

  "marks": [
    {
      "type": "rect",
      "from": {"data": "summary"},
      "encode": {
        "enter": {
          "fill": {"value": "black"},
          "height": {"value": 1}
        },
        "update": {
          "y": {"scale": "yscale", "field": "variety", "band": 0.5},
          "x": {"scale": "xscale", "signal": "datum[measure+'0']"},
          "x2": {"scale": "xscale", "signal": "datum[measure+'1']"}
        }
      }
    },
    {
      "type": "symbol",
      "from": {"data": "summary"},
      "encode": {
        "enter": {
          "fill": {"value": "black"},
          "size": {"value": 40}
        },
        "update": {
          "x": {"scale": "xscale", "field": "mean"},
          "y": {"scale": "yscale", "field": "variety", "band": 0.5}
        }
      }
    }
  ]
}\n"https://vega.github.io/schema/vega/v5.json"\n"A basic error bar visualization example."\n"95% Confidence Interval"\n"95% Confidence Interval"\n"Interquartile Range"\n"95% Confidence Interval"\n"Interquartile Range"\n"lookup[errorMeasure]"\n"datum.mean - datum.stdev"\n"datum.mean + datum.stdev"\n"datum.mean - datum.stderr"\n"datum.mean + datum.stderr"\n\n\nVega
            
              Vega-Lite
              Altair
              Vega-Lite API
            
          
          
            
              Examples
              Tutorials
              Documentation
              Usage
              About
            
            
              GitHub
              Try Online
            
          
        
      

      
        

  
  
    Barley Trellis Plot Example
    A trellis plot subdivides a chart into small multiples to isolate specific subsets and promote comparison. This example shows barley yields by variety at different sites, adapted from the original Trellis Display article by Becker et al.




  
  View Source
  Export PNG
  Export SVG






  View in Online Vega Editor


Vega JSON Specification <>

{
  "$schema": "https://vega.github.io/schema/vega/v5.json",
  "description": "A small multiples view of barley yields by site and variety.",
  "width": 200,
  "padding": 5,

  "signals": [
    {"name": "offset", "value": 15},
    {"name": "cellHeight", "value": 100},
    {"name": "height", "update": "6 * (offset + cellHeight)"}
  ],

  "data": [
    {
      "name": "barley",
      "url": "data/barley.json"
    }
  ],

  "scales": [
    {
      "name": "gscale",
      "type": "band",
      "range": [0, {"signal": "height"}],
      "round": true,
      "domain": {
        "data": "barley",
        "field": "site",
        "sort": {
          "field": "yield",
          "op": "median",
          "order": "descending"
        }
      }
    },
    {
      "name": "xscale",
      "type": "linear",
      "nice": true,
      "range": "width",
      "round": true,
      "domain": {"data": "barley", "field": "yield"}
    },
    {
      "name": "cscale",
      "type": "ordinal",
      "range": "category",
      "domain": {"data": "barley", "field": "year"}
    }
  ],

  "axes": [
    {"orient": "bottom", "scale": "xscale", "zindex": 1}
  ],

  "legends": [
    {
      "stroke": "cscale",
      "title": "Year",
      "padding": 4,
      "encode": {
        "symbols": {
          "enter": {
            "strokeWidth": {"value": 2},
            "size": {"value": 50}
          }
        }
      }
    }
  ],

  "marks": [
    {
      "name": "site",
      "type": "group",

      "from": {
        "facet": {
          "data": "barley",
          "name": "sites",
          "groupby": "site"
        }
      },

      "encode": {
        "enter": {
          "y": {"scale": "gscale", "field": "site", "offset": {"signal": "offset"}},
          "height": {"signal": "cellHeight"},
          "width": {"signal": "width"},
          "stroke": {"value": "#ccc"}
        }
      },

      "scales": [
        {
          "name": "yscale",
          "type": "point",
          "range": [0, {"signal": "cellHeight"}],
          "padding": 1,
          "round": true,
          "domain": {
            "data": "barley",
            "field": "variety",
            "sort": {
              "field": "yield",
              "op": "median",
              "order": "descending"
            }
          }
        }
      ],

      "axes": [
        {
          "orient": "left",
          "scale": "yscale",
          "tickSize": 0,
          "domain": false,
          "grid": true,
          "encode": {
            "grid": {
              "enter": {"strokeDash": {"value": [3,3]}}
            }
          }
        },
        {
          "orient": "right",
          "scale": "yscale",
          "tickSize": 0,
          "domain": false
        }
      ],

      "marks": [
        {
          "type": "symbol",
          "from": {"data": "sites"},
          "encode": {
            "enter": {
              "x": {"scale": "xscale", "field": "yield"},
              "y": {"scale": "yscale", "field": "variety"},
              "stroke": {"scale": "cscale", "field": "year"},
              "strokeWidth": {"value": 2},
              "size": {"value": 50}
            }
          }
        }
      ]
    },

    {
      "type": "text",
      "from": {"data": "site"},
      "encode": {
        "enter": {
          "x": {"field": "width", "mult": 0.5},
          "y": {"field": "y"},
          "fontSize": {"value": 11},
          "fontWeight": {"value": "bold"},
          "text": {"field": "datum.site"},
          "align": {"value": "center"},
          "baseline": {"value": "bottom"},
          "fill": {"value": "#000"}
        }
      }
    }
  ]
}\nVega
            
              Vega-Lite
              Altair
              Vega-Lite API\nVega-Lite
              Altair
              Vega-Lite API\nExamples
              Tutorials
              Documentation
              Usage
              About
            
            
              GitHub
              Try Online\nExamples
              Tutorials
              Documentation
              Usage
              About\nGitHub
              Try Online\nBarley Trellis Plot Example
    A trellis plot subdivides a chart into small multiples to isolate specific subsets and promote comparison. This example shows barley yields by variety at different sites, adapted from the original Trellis Display article by Becker et al.




  
  View Source
  Export PNG
  Export SVG






  View in Online Vega Editor


Vega JSON Specification <>

{
  "$schema": "https://vega.github.io/schema/vega/v5.json",
  "description": "A small multiples view of barley yields by site and variety.",
  "width": 200,
  "padding": 5,

  "signals": [
    {"name": "offset", "value": 15},
    {"name": "cellHeight", "value": 100},
    {"name": "height", "update": "6 * (offset + cellHeight)"}
  ],

  "data": [
    {
      "name": "barley",
      "url": "data/barley.json"
    }
  ],

  "scales": [
    {
      "name": "gscale",
      "type": "band",
      "range": [0, {"signal": "height"}],
      "round": true,
      "domain": {
        "data": "barley",
        "field": "site",
        "sort": {
          "field": "yield",
          "op": "median",
          "order": "descending"
        }
      }
    },
    {
      "name": "xscale",
      "type": "linear",
      "nice": true,
      "range": "width",
      "round": true,
      "domain": {"data": "barley", "field": "yield"}
    },
    {
      "name": "cscale",
      "type": "ordinal",
      "range": "category",
      "domain": {"data": "barley", "field": "year"}
    }
  ],

  "axes": [
    {"orient": "bottom", "scale": "xscale", "zindex": 1}
  ],

  "legends": [
    {
      "stroke": "cscale",
      "title": "Year",
      "padding": 4,
      "encode": {
        "symbols": {
          "enter": {
            "strokeWidth": {"value": 2},
            "size": {"value": 50}
          }
        }
      }
    }
  ],

  "marks": [
    {
      "name": "site",
      "type": "group",

      "from": {
        "facet": {
          "data": "barley",
          "name": "sites",
          "groupby": "site"
        }
      },

      "encode": {
        "enter": {
          "y": {"scale": "gscale", "field": "site", "offset": {"signal": "offset"}},
          "height": {"signal": "cellHeight"},
          "width": {"signal": "width"},
          "stroke": {"value": "#ccc"}
        }
      },

      "scales": [
        {
          "name": "yscale",
          "type": "point",
          "range": [0, {"signal": "cellHeight"}],
          "padding": 1,
          "round": true,
          "domain": {
            "data": "barley",
            "field": "variety",
            "sort": {
              "field": "yield",
              "op": "median",
              "order": "descending"
            }
          }
        }
      ],

      "axes": [
        {
          "orient": "left",
          "scale": "yscale",
          "tickSize": 0,
          "domain": false,
          "grid": true,
          "encode": {
            "grid": {
              "enter": {"strokeDash": {"value": [3,3]}}
            }
          }
        },
        {
          "orient": "right",
          "scale": "yscale",
          "tickSize": 0,
          "domain": false
        }
      ],

      "marks": [
        {
          "type": "symbol",
          "from": {"data": "sites"},
          "encode": {
            "enter": {
              "x": {"scale": "xscale", "field": "yield"},
              "y": {"scale": "yscale", "field": "variety"},
              "stroke": {"scale": "cscale", "field": "year"},
              "strokeWidth": {"value": 2},
              "size": {"value": 50}
            }
          }
        }
      ]
    },

    {
      "type": "text",
      "from": {"data": "site"},
      "encode": {
        "enter": {
          "x": {"field": "width", "mult": 0.5},
          "y": {"field": "y"},
          "fontSize": {"value": 11},
          "fontWeight": {"value": "bold"},
          "text": {"field": "datum.site"},
          "align": {"value": "center"},
          "baseline": {"value": "bottom"},
          "fill": {"value": "#000"}
        }
      }
    }
  ]
}\nBarley Trellis Plot Example\nA trellis plot subdivides a chart into small multiples to isolate specific subsets and promote comparison. This example shows barley yields by variety at different sites, adapted from the original Trellis Display article by Becker et al.\nView Source
  Export PNG
  Export SVG\nView Source
  Export PNG
  Export SVG\nView in Online Vega Editor\nView in Online Vega Editor\nVega JSON Specification <>\n{
  "$schema": "https://vega.github.io/schema/vega/v5.json",
  "description": "A small multiples view of barley yields by site and variety.",
  "width": 200,
  "padding": 5,

  "signals": [
    {"name": "offset", "value": 15},
    {"name": "cellHeight", "value": 100},
    {"name": "height", "update": "6 * (offset + cellHeight)"}
  ],

  "data": [
    {
      "name": "barley",
      "url": "data/barley.json"
    }
  ],

  "scales": [
    {
      "name": "gscale",
      "type": "band",
      "range": [0, {"signal": "height"}],
      "round": true,
      "domain": {
        "data": "barley",
        "field": "site",
        "sort": {
          "field": "yield",
          "op": "median",
          "order": "descending"
        }
      }
    },
    {
      "name": "xscale",
      "type": "linear",
      "nice": true,
      "range": "width",
      "round": true,
      "domain": {"data": "barley", "field": "yield"}
    },
    {
      "name": "cscale",
      "type": "ordinal",
      "range": "category",
      "domain": {"data": "barley", "field": "year"}
    }
  ],

  "axes": [
    {"orient": "bottom", "scale": "xscale", "zindex": 1}
  ],

  "legends": [
    {
      "stroke": "cscale",
      "title": "Year",
      "padding": 4,
      "encode": {
        "symbols": {
          "enter": {
            "strokeWidth": {"value": 2},
            "size": {"value": 50}
          }
        }
      }
    }
  ],

  "marks": [
    {
      "name": "site",
      "type": "group",

      "from": {
        "facet": {
          "data": "barley",
          "name": "sites",
          "groupby": "site"
        }
      },

      "encode": {
        "enter": {
          "y": {"scale": "gscale", "field": "site", "offset": {"signal": "offset"}},
          "height": {"signal": "cellHeight"},
          "width": {"signal": "width"},
          "stroke": {"value": "#ccc"}
        }
      },

      "scales": [
        {
          "name": "yscale",
          "type": "point",
          "range": [0, {"signal": "cellHeight"}],
          "padding": 1,
          "round": true,
          "domain": {
            "data": "barley",
            "field": "variety",
            "sort": {
              "field": "yield",
              "op": "median",
              "order": "descending"
            }
          }
        }
      ],

      "axes": [
        {
          "orient": "left",
          "scale": "yscale",
          "tickSize": 0,
          "domain": false,
          "grid": true,
          "encode": {
            "grid": {
              "enter": {"strokeDash": {"value": [3,3]}}
            }
          }
        },
        {
          "orient": "right",
          "scale": "yscale",
          "tickSize": 0,
          "domain": false
        }
      ],

      "marks": [
        {
          "type": "symbol",
          "from": {"data": "sites"},
          "encode": {
            "enter": {
              "x": {"scale": "xscale", "field": "yield"},
              "y": {"scale": "yscale", "field": "variety"},
              "stroke": {"scale": "cscale", "field": "year"},
              "strokeWidth": {"value": 2},
              "size": {"value": 50}
            }
          }
        }
      ]
    },

    {
      "type": "text",
      "from": {"data": "site"},
      "encode": {
        "enter": {
          "x": {"field": "width", "mult": 0.5},
          "y": {"field": "y"},
          "fontSize": {"value": 11},
          "fontWeight": {"value": "bold"},
          "text": {"field": "datum.site"},
          "align": {"value": "center"},
          "baseline": {"value": "bottom"},
          "fill": {"value": "#000"}
        }
      }
    }
  ]
}\n{
  "$schema": "https://vega.github.io/schema/vega/v5.json",
  "description": "A small multiples view of barley yields by site and variety.",
  "width": 200,
  "padding": 5,

  "signals": [
    {"name": "offset", "value": 15},
    {"name": "cellHeight", "value": 100},
    {"name": "height", "update": "6 * (offset + cellHeight)"}
  ],

  "data": [
    {
      "name": "barley",
      "url": "data/barley.json"
    }
  ],

  "scales": [
    {
      "name": "gscale",
      "type": "band",
      "range": [0, {"signal": "height"}],
      "round": true,
      "domain": {
        "data": "barley",
        "field": "site",
        "sort": {
          "field": "yield",
          "op": "median",
          "order": "descending"
        }
      }
    },
    {
      "name": "xscale",
      "type": "linear",
      "nice": true,
      "range": "width",
      "round": true,
      "domain": {"data": "barley", "field": "yield"}
    },
    {
      "name": "cscale",
      "type": "ordinal",
      "range": "category",
      "domain": {"data": "barley", "field": "year"}
    }
  ],

  "axes": [
    {"orient": "bottom", "scale": "xscale", "zindex": 1}
  ],

  "legends": [
    {
      "stroke": "cscale",
      "title": "Year",
      "padding": 4,
      "encode": {
        "symbols": {
          "enter": {
            "strokeWidth": {"value": 2},
            "size": {"value": 50}
          }
        }
      }
    }
  ],

  "marks": [
    {
      "name": "site",
      "type": "group",

      "from": {
        "facet": {
          "data": "barley",
          "name": "sites",
          "groupby": "site"
        }
      },

      "encode": {
        "enter": {
          "y": {"scale": "gscale", "field": "site", "offset": {"signal": "offset"}},
          "height": {"signal": "cellHeight"},
          "width": {"signal": "width"},
          "stroke": {"value": "#ccc"}
        }
      },

      "scales": [
        {
          "name": "yscale",
          "type": "point",
          "range": [0, {"signal": "cellHeight"}],
          "padding": 1,
          "round": true,
          "domain": {
            "data": "barley",
            "field": "variety",
            "sort": {
              "field": "yield",
              "op": "median",
              "order": "descending"
            }
          }
        }
      ],

      "axes": [
        {
          "orient": "left",
          "scale": "yscale",
          "tickSize": 0,
          "domain": false,
          "grid": true,
          "encode": {
            "grid": {
              "enter": {"strokeDash": {"value": [3,3]}}
            }
          }
        },
        {
          "orient": "right",
          "scale": "yscale",
          "tickSize": 0,
          "domain": false
        }
      ],

      "marks": [
        {
          "type": "symbol",
          "from": {"data": "sites"},
          "encode": {
            "enter": {
              "x": {"scale": "xscale", "field": "yield"},
              "y": {"scale": "yscale", "field": "variety"},
              "stroke": {"scale": "cscale", "field": "year"},
              "strokeWidth": {"value": 2},
              "size": {"value": 50}
            }
          }
        }
      ]
    },

    {
      "type": "text",
      "from": {"data": "site"},
      "encode": {
        "enter": {
          "x": {"field": "width", "mult": 0.5},
          "y": {"field": "y"},
          "fontSize": {"value": 11},
          "fontWeight": {"value": "bold"},
          "text": {"field": "datum.site"},
          "align": {"value": "center"},
          "baseline": {"value": "bottom"},
          "fill": {"value": "#000"}
        }
      }
    }
  ]
}\n"https://vega.github.io/schema/vega/v5.json"\n"A small multiples view of barley yields by site and variety."\n"6 * (offset + cellHeight)"\n\n\nVega
            
              Vega-Lite
              Altair
              Vega-Lite API
            
          
          
            
              Examples
              Tutorials
              Documentation
              Usage
              About
            
            
              GitHub
              Try Online
            
          
        
      

      
        

  
  
    Regression Example
    A two-dimensional regression analysis models one data variable as a function of another. The resulting model produces a trend line that summarizes and extrapolates observed data. This example uses parametric regression models to predict IMDB users’ film ratings based on Rotten Tomatoes critics’ ratings. The regression options range from linear regression to other functions such as logarithmic, quadratic, and polynomial regression. Alternatively, see the loess regression example for a non-parametric approach to scatter plot smoothing.




  
  View Source
  Export PNG
  Export SVG






  View in Online Vega Editor


Vega JSON Specification <>

{
  "$schema": "https://vega.github.io/schema/vega/v5.json",
  "description": "A scatter plot with trend line calculated via user-configurable regression methods.",
  "padding": 5,
  "width": 500,
  "height": 500,
  "autosize": "pad",

  "signals": [
    {
      "name": "method", "value": "linear",
      "bind": {"input": "select", "options": [
        "linear", "log", "exp", "pow", "quad", "poly"
      ]}
    },
    {
      "name": "polyOrder", "value": 3,
      "bind": {"input": "range", "min": 1, "max": 10, "step": 1}
    },
    {
      "name": "groupby", "value": "none",
      "bind": {"input": "select", "options": ["none", "genre"]}
    }
  ],

  "data": [
    {
      "name": "movies",
      "url": "data/movies.json",
      "transform": [
        {
          "type": "filter",
          "expr": "datum['Rotten Tomatoes Rating'] != null && datum['IMDB Rating'] != null"
        }
      ]
    },
    {
      "name": "trend",
      "source": "movies",
      "transform": [
        {
          "type": "regression",
          "groupby": [{"signal": "groupby === 'genre' ? 'Major Genre' : 'foo'"}],
          "method": {"signal": "method"},
          "order": {"signal": "polyOrder"},
          "extent": {"signal": "domain('x')"},
          "x": "Rotten Tomatoes Rating",
          "y": "IMDB Rating",
          "as": ["u", "v"]
        }
      ]
    }
  ],

  "scales": [
    {
      "name": "x",
      "type": "linear",
      "domain": {"data": "movies", "field": "Rotten Tomatoes Rating"},
      "range": "width"
    },
    {
      "name": "y",
      "type": "linear",
      "domain": {"data": "movies", "field": "IMDB Rating"},
      "range": "height"
    }
  ],

  "marks": [
    {
      "type": "symbol",
      "from": {"data": "movies"},
      "encode": {
        "enter": {
          "x": {"scale": "x", "field": "Rotten Tomatoes Rating"},
          "y": {"scale": "y", "field": "IMDB Rating"},
          "fillOpacity": {"value": 0.5},
          "size": {"value": 16}
        }
      }
    },
    {
      "type": "group",
      "from": {
        "facet": {
          "data": "trend",
          "name": "curve",
          "groupby": "Major Genre"
        }
      },
      "marks": [
        {
          "type": "line",
          "from": {"data": "curve"},
          "encode": {
            "enter": {
              "x": {"scale": "x", "field": "u"},
              "y": {"scale": "y", "field": "v"},
              "stroke": {"value": "firebrick"}
            }
          }
        }
      ]
    }
  ]
}\nVega
            
              Vega-Lite
              Altair
              Vega-Lite API\nVega-Lite
              Altair
              Vega-Lite API\nExamples
              Tutorials
              Documentation
              Usage
              About
            
            
              GitHub
              Try Online\nExamples
              Tutorials
              Documentation
              Usage
              About\nGitHub
              Try Online\nRegression Example
    A two-dimensional regression analysis models one data variable as a function of another. The resulting model produces a trend line that summarizes and extrapolates observed data. This example uses parametric regression models to predict IMDB users’ film ratings based on Rotten Tomatoes critics’ ratings. The regression options range from linear regression to other functions such as logarithmic, quadratic, and polynomial regression. Alternatively, see the loess regression example for a non-parametric approach to scatter plot smoothing.




  
  View Source
  Export PNG
  Export SVG






  View in Online Vega Editor


Vega JSON Specification <>

{
  "$schema": "https://vega.github.io/schema/vega/v5.json",
  "description": "A scatter plot with trend line calculated via user-configurable regression methods.",
  "padding": 5,
  "width": 500,
  "height": 500,
  "autosize": "pad",

  "signals": [
    {
      "name": "method", "value": "linear",
      "bind": {"input": "select", "options": [
        "linear", "log", "exp", "pow", "quad", "poly"
      ]}
    },
    {
      "name": "polyOrder", "value": 3,
      "bind": {"input": "range", "min": 1, "max": 10, "step": 1}
    },
    {
      "name": "groupby", "value": "none",
      "bind": {"input": "select", "options": ["none", "genre"]}
    }
  ],

  "data": [
    {
      "name": "movies",
      "url": "data/movies.json",
      "transform": [
        {
          "type": "filter",
          "expr": "datum['Rotten Tomatoes Rating'] != null && datum['IMDB Rating'] != null"
        }
      ]
    },
    {
      "name": "trend",
      "source": "movies",
      "transform": [
        {
          "type": "regression",
          "groupby": [{"signal": "groupby === 'genre' ? 'Major Genre' : 'foo'"}],
          "method": {"signal": "method"},
          "order": {"signal": "polyOrder"},
          "extent": {"signal": "domain('x')"},
          "x": "Rotten Tomatoes Rating",
          "y": "IMDB Rating",
          "as": ["u", "v"]
        }
      ]
    }
  ],

  "scales": [
    {
      "name": "x",
      "type": "linear",
      "domain": {"data": "movies", "field": "Rotten Tomatoes Rating"},
      "range": "width"
    },
    {
      "name": "y",
      "type": "linear",
      "domain": {"data": "movies", "field": "IMDB Rating"},
      "range": "height"
    }
  ],

  "marks": [
    {
      "type": "symbol",
      "from": {"data": "movies"},
      "encode": {
        "enter": {
          "x": {"scale": "x", "field": "Rotten Tomatoes Rating"},
          "y": {"scale": "y", "field": "IMDB Rating"},
          "fillOpacity": {"value": 0.5},
          "size": {"value": 16}
        }
      }
    },
    {
      "type": "group",
      "from": {
        "facet": {
          "data": "trend",
          "name": "curve",
          "groupby": "Major Genre"
        }
      },
      "marks": [
        {
          "type": "line",
          "from": {"data": "curve"},
          "encode": {
            "enter": {
              "x": {"scale": "x", "field": "u"},
              "y": {"scale": "y", "field": "v"},
              "stroke": {"value": "firebrick"}
            }
          }
        }
      ]
    }
  ]
}\nA two-dimensional regression analysis models one data variable as a function of another. The resulting model produces a trend line that summarizes and extrapolates observed data. This example uses parametric regression models to predict IMDB users’ film ratings based on Rotten Tomatoes critics’ ratings. The regression options range from linear regression to other functions such as logarithmic, quadratic, and polynomial regression. Alternatively, see the loess regression example for a non-parametric approach to scatter plot smoothing.\nView Source
  Export PNG
  Export SVG\nView Source
  Export PNG
  Export SVG\nView in Online Vega Editor\nView in Online Vega Editor\nVega JSON Specification <>\n{
  "$schema": "https://vega.github.io/schema/vega/v5.json",
  "description": "A scatter plot with trend line calculated via user-configurable regression methods.",
  "padding": 5,
  "width": 500,
  "height": 500,
  "autosize": "pad",

  "signals": [
    {
      "name": "method", "value": "linear",
      "bind": {"input": "select", "options": [
        "linear", "log", "exp", "pow", "quad", "poly"
      ]}
    },
    {
      "name": "polyOrder", "value": 3,
      "bind": {"input": "range", "min": 1, "max": 10, "step": 1}
    },
    {
      "name": "groupby", "value": "none",
      "bind": {"input": "select", "options": ["none", "genre"]}
    }
  ],

  "data": [
    {
      "name": "movies",
      "url": "data/movies.json",
      "transform": [
        {
          "type": "filter",
          "expr": "datum['Rotten Tomatoes Rating'] != null && datum['IMDB Rating'] != null"
        }
      ]
    },
    {
      "name": "trend",
      "source": "movies",
      "transform": [
        {
          "type": "regression",
          "groupby": [{"signal": "groupby === 'genre' ? 'Major Genre' : 'foo'"}],
          "method": {"signal": "method"},
          "order": {"signal": "polyOrder"},
          "extent": {"signal": "domain('x')"},
          "x": "Rotten Tomatoes Rating",
          "y": "IMDB Rating",
          "as": ["u", "v"]
        }
      ]
    }
  ],

  "scales": [
    {
      "name": "x",
      "type": "linear",
      "domain": {"data": "movies", "field": "Rotten Tomatoes Rating"},
      "range": "width"
    },
    {
      "name": "y",
      "type": "linear",
      "domain": {"data": "movies", "field": "IMDB Rating"},
      "range": "height"
    }
  ],

  "marks": [
    {
      "type": "symbol",
      "from": {"data": "movies"},
      "encode": {
        "enter": {
          "x": {"scale": "x", "field": "Rotten Tomatoes Rating"},
          "y": {"scale": "y", "field": "IMDB Rating"},
          "fillOpacity": {"value": 0.5},
          "size": {"value": 16}
        }
      }
    },
    {
      "type": "group",
      "from": {
        "facet": {
          "data": "trend",
          "name": "curve",
          "groupby": "Major Genre"
        }
      },
      "marks": [
        {
          "type": "line",
          "from": {"data": "curve"},
          "encode": {
            "enter": {
              "x": {"scale": "x", "field": "u"},
              "y": {"scale": "y", "field": "v"},
              "stroke": {"value": "firebrick"}
            }
          }
        }
      ]
    }
  ]
}\n{
  "$schema": "https://vega.github.io/schema/vega/v5.json",
  "description": "A scatter plot with trend line calculated via user-configurable regression methods.",
  "padding": 5,
  "width": 500,
  "height": 500,
  "autosize": "pad",

  "signals": [
    {
      "name": "method", "value": "linear",
      "bind": {"input": "select", "options": [
        "linear", "log", "exp", "pow", "quad", "poly"
      ]}
    },
    {
      "name": "polyOrder", "value": 3,
      "bind": {"input": "range", "min": 1, "max": 10, "step": 1}
    },
    {
      "name": "groupby", "value": "none",
      "bind": {"input": "select", "options": ["none", "genre"]}
    }
  ],

  "data": [
    {
      "name": "movies",
      "url": "data/movies.json",
      "transform": [
        {
          "type": "filter",
          "expr": "datum['Rotten Tomatoes Rating'] != null && datum['IMDB Rating'] != null"
        }
      ]
    },
    {
      "name": "trend",
      "source": "movies",
      "transform": [
        {
          "type": "regression",
          "groupby": [{"signal": "groupby === 'genre' ? 'Major Genre' : 'foo'"}],
          "method": {"signal": "method"},
          "order": {"signal": "polyOrder"},
          "extent": {"signal": "domain('x')"},
          "x": "Rotten Tomatoes Rating",
          "y": "IMDB Rating",
          "as": ["u", "v"]
        }
      ]
    }
  ],

  "scales": [
    {
      "name": "x",
      "type": "linear",
      "domain": {"data": "movies", "field": "Rotten Tomatoes Rating"},
      "range": "width"
    },
    {
      "name": "y",
      "type": "linear",
      "domain": {"data": "movies", "field": "IMDB Rating"},
      "range": "height"
    }
  ],

  "marks": [
    {
      "type": "symbol",
      "from": {"data": "movies"},
      "encode": {
        "enter": {
          "x": {"scale": "x", "field": "Rotten Tomatoes Rating"},
          "y": {"scale": "y", "field": "IMDB Rating"},
          "fillOpacity": {"value": 0.5},
          "size": {"value": 16}
        }
      }
    },
    {
      "type": "group",
      "from": {
        "facet": {
          "data": "trend",
          "name": "curve",
          "groupby": "Major Genre"
        }
      },
      "marks": [
        {
          "type": "line",
          "from": {"data": "curve"},
          "encode": {
            "enter": {
              "x": {"scale": "x", "field": "u"},
              "y": {"scale": "y", "field": "v"},
              "stroke": {"value": "firebrick"}
            }
          }
        }
      ]
    }
  ]
}\n"https://vega.github.io/schema/vega/v5.json"\n"A scatter plot with trend line calculated via user-configurable regression methods."\n"datum['Rotten Tomatoes Rating'] != null && datum['IMDB Rating'] != null"\n"groupby === 'genre' ? 'Major Genre' : 'foo'"\n"Rotten Tomatoes Rating"\n"Rotten Tomatoes Rating"\n"Rotten Tomatoes Rating"\n\n\nVega
            
              Vega-Lite
              Altair
              Vega-Lite API
            
          
          
            
              Examples
              Tutorials
              Documentation
              Usage
              About
            
            
              GitHub
              Try Online
            
          
        
      

      
        

  
  
    Loess Regression Example
    Locally-estimated regression produces a trend line by performing weighted regressions over a sliding window of points. The loess method (for locally-estimated scatterplot smoothing) computes a sequence of local linear regressions to estimate smoothed points. The bandwidth parameter determines the size of the sliding window of nearest-neighbor points, expressed as a fraction of the total number of points included. Alternatively, see the regression example for regression results using parametric functions.




  
  View Source
  Export PNG
  Export SVG






  View in Online Vega Editor


Vega JSON Specification <>

{
  "$schema": "https://vega.github.io/schema/vega/v5.json",
  "description": "A scatter plot with trend line calculated via locally-weighted (loess) regression.",
  "padding": 5,
  "width": 500,
  "height": 500,
  "autosize": "pad",

  "signals": [
    {
      "name": "loessBandwidth", "value": 0.3,
      "bind": {"input": "range", "min": 0.05, "max": 1}
    },
    {
      "name": "groupby", "value": "none",
      "bind": {"input": "select", "options": ["none", "genre"]}
    }
  ],

  "data": [
    {
      "name": "movies",
      "url": "data/movies.json",
      "transform": [
        {
          "type": "filter",
          "expr": "datum['Rotten Tomatoes Rating'] != null && datum['IMDB Rating'] != null"
        }
      ]
    },
    {
      "name": "trend",
      "source": "movies",
      "transform": [
        {
          "type": "loess",
          "groupby": [{"signal": "groupby === 'genre' ? 'Major Genre' : 'foo'"}],
          "bandwidth": {"signal": "loessBandwidth"},
          "x": "Rotten Tomatoes Rating",
          "y": "IMDB Rating",
          "as": ["u", "v"]
        }
      ]
    }
  ],

  "scales": [
    {
      "name": "x",
      "type": "linear",
      "domain": {"data": "movies", "field": "Rotten Tomatoes Rating"},
      "range": "width"
    },
    {
      "name": "y",
      "type": "linear",
      "domain": {"data": "movies", "field": "IMDB Rating"},
      "range": "height"
    }
  ],

  "marks": [
    {
      "type": "symbol",
      "from": {"data": "movies"},
      "encode": {
        "enter": {
          "x": {"scale": "x", "field": "Rotten Tomatoes Rating"},
          "y": {"scale": "y", "field": "IMDB Rating"},
          "fillOpacity": {"value": 0.5},
          "size": {"value": 16}
        }
      }
    },
    {
      "type": "group",
      "from": {
        "facet": {
          "data": "trend",
          "name": "curve",
          "groupby": "Major Genre"
        }
      },
      "marks": [
        {
          "type": "line",
          "from": {"data": "curve"},
          "encode": {
            "enter": {
              "x": {"scale": "x", "field": "u"},
              "y": {"scale": "y", "field": "v"},
              "stroke": {"value": "firebrick"}
            }
          }
        }
      ]
    }
  ]
}\nVega
            
              Vega-Lite
              Altair
              Vega-Lite API\nVega-Lite
              Altair
              Vega-Lite API\nExamples
              Tutorials
              Documentation
              Usage
              About
            
            
              GitHub
              Try Online\nExamples
              Tutorials
              Documentation
              Usage
              About\nGitHub
              Try Online\nLoess Regression Example
    Locally-estimated regression produces a trend line by performing weighted regressions over a sliding window of points. The loess method (for locally-estimated scatterplot smoothing) computes a sequence of local linear regressions to estimate smoothed points. The bandwidth parameter determines the size of the sliding window of nearest-neighbor points, expressed as a fraction of the total number of points included. Alternatively, see the regression example for regression results using parametric functions.




  
  View Source
  Export PNG
  Export SVG






  View in Online Vega Editor


Vega JSON Specification <>

{
  "$schema": "https://vega.github.io/schema/vega/v5.json",
  "description": "A scatter plot with trend line calculated via locally-weighted (loess) regression.",
  "padding": 5,
  "width": 500,
  "height": 500,
  "autosize": "pad",

  "signals": [
    {
      "name": "loessBandwidth", "value": 0.3,
      "bind": {"input": "range", "min": 0.05, "max": 1}
    },
    {
      "name": "groupby", "value": "none",
      "bind": {"input": "select", "options": ["none", "genre"]}
    }
  ],

  "data": [
    {
      "name": "movies",
      "url": "data/movies.json",
      "transform": [
        {
          "type": "filter",
          "expr": "datum['Rotten Tomatoes Rating'] != null && datum['IMDB Rating'] != null"
        }
      ]
    },
    {
      "name": "trend",
      "source": "movies",
      "transform": [
        {
          "type": "loess",
          "groupby": [{"signal": "groupby === 'genre' ? 'Major Genre' : 'foo'"}],
          "bandwidth": {"signal": "loessBandwidth"},
          "x": "Rotten Tomatoes Rating",
          "y": "IMDB Rating",
          "as": ["u", "v"]
        }
      ]
    }
  ],

  "scales": [
    {
      "name": "x",
      "type": "linear",
      "domain": {"data": "movies", "field": "Rotten Tomatoes Rating"},
      "range": "width"
    },
    {
      "name": "y",
      "type": "linear",
      "domain": {"data": "movies", "field": "IMDB Rating"},
      "range": "height"
    }
  ],

  "marks": [
    {
      "type": "symbol",
      "from": {"data": "movies"},
      "encode": {
        "enter": {
          "x": {"scale": "x", "field": "Rotten Tomatoes Rating"},
          "y": {"scale": "y", "field": "IMDB Rating"},
          "fillOpacity": {"value": 0.5},
          "size": {"value": 16}
        }
      }
    },
    {
      "type": "group",
      "from": {
        "facet": {
          "data": "trend",
          "name": "curve",
          "groupby": "Major Genre"
        }
      },
      "marks": [
        {
          "type": "line",
          "from": {"data": "curve"},
          "encode": {
            "enter": {
              "x": {"scale": "x", "field": "u"},
              "y": {"scale": "y", "field": "v"},
              "stroke": {"value": "firebrick"}
            }
          }
        }
      ]
    }
  ]
}\nLoess Regression Example\nLocally-estimated regression produces a trend line by performing weighted regressions over a sliding window of points. The loess method (for locally-estimated scatterplot smoothing) computes a sequence of local linear regressions to estimate smoothed points. The bandwidth parameter determines the size of the sliding window of nearest-neighbor points, expressed as a fraction of the total number of points included. Alternatively, see the regression example for regression results using parametric functions.\nLocally-estimated regression\nView Source
  Export PNG
  Export SVG\nView Source
  Export PNG
  Export SVG\nView in Online Vega Editor\nView in Online Vega Editor\nVega JSON Specification <>\n{
  "$schema": "https://vega.github.io/schema/vega/v5.json",
  "description": "A scatter plot with trend line calculated via locally-weighted (loess) regression.",
  "padding": 5,
  "width": 500,
  "height": 500,
  "autosize": "pad",

  "signals": [
    {
      "name": "loessBandwidth", "value": 0.3,
      "bind": {"input": "range", "min": 0.05, "max": 1}
    },
    {
      "name": "groupby", "value": "none",
      "bind": {"input": "select", "options": ["none", "genre"]}
    }
  ],

  "data": [
    {
      "name": "movies",
      "url": "data/movies.json",
      "transform": [
        {
          "type": "filter",
          "expr": "datum['Rotten Tomatoes Rating'] != null && datum['IMDB Rating'] != null"
        }
      ]
    },
    {
      "name": "trend",
      "source": "movies",
      "transform": [
        {
          "type": "loess",
          "groupby": [{"signal": "groupby === 'genre' ? 'Major Genre' : 'foo'"}],
          "bandwidth": {"signal": "loessBandwidth"},
          "x": "Rotten Tomatoes Rating",
          "y": "IMDB Rating",
          "as": ["u", "v"]
        }
      ]
    }
  ],

  "scales": [
    {
      "name": "x",
      "type": "linear",
      "domain": {"data": "movies", "field": "Rotten Tomatoes Rating"},
      "range": "width"
    },
    {
      "name": "y",
      "type": "linear",
      "domain": {"data": "movies", "field": "IMDB Rating"},
      "range": "height"
    }
  ],

  "marks": [
    {
      "type": "symbol",
      "from": {"data": "movies"},
      "encode": {
        "enter": {
          "x": {"scale": "x", "field": "Rotten Tomatoes Rating"},
          "y": {"scale": "y", "field": "IMDB Rating"},
          "fillOpacity": {"value": 0.5},
          "size": {"value": 16}
        }
      }
    },
    {
      "type": "group",
      "from": {
        "facet": {
          "data": "trend",
          "name": "curve",
          "groupby": "Major Genre"
        }
      },
      "marks": [
        {
          "type": "line",
          "from": {"data": "curve"},
          "encode": {
            "enter": {
              "x": {"scale": "x", "field": "u"},
              "y": {"scale": "y", "field": "v"},
              "stroke": {"value": "firebrick"}
            }
          }
        }
      ]
    }
  ]
}\n{
  "$schema": "https://vega.github.io/schema/vega/v5.json",
  "description": "A scatter plot with trend line calculated via locally-weighted (loess) regression.",
  "padding": 5,
  "width": 500,
  "height": 500,
  "autosize": "pad",

  "signals": [
    {
      "name": "loessBandwidth", "value": 0.3,
      "bind": {"input": "range", "min": 0.05, "max": 1}
    },
    {
      "name": "groupby", "value": "none",
      "bind": {"input": "select", "options": ["none", "genre"]}
    }
  ],

  "data": [
    {
      "name": "movies",
      "url": "data/movies.json",
      "transform": [
        {
          "type": "filter",
          "expr": "datum['Rotten Tomatoes Rating'] != null && datum['IMDB Rating'] != null"
        }
      ]
    },
    {
      "name": "trend",
      "source": "movies",
      "transform": [
        {
          "type": "loess",
          "groupby": [{"signal": "groupby === 'genre' ? 'Major Genre' : 'foo'"}],
          "bandwidth": {"signal": "loessBandwidth"},
          "x": "Rotten Tomatoes Rating",
          "y": "IMDB Rating",
          "as": ["u", "v"]
        }
      ]
    }
  ],

  "scales": [
    {
      "name": "x",
      "type": "linear",
      "domain": {"data": "movies", "field": "Rotten Tomatoes Rating"},
      "range": "width"
    },
    {
      "name": "y",
      "type": "linear",
      "domain": {"data": "movies", "field": "IMDB Rating"},
      "range": "height"
    }
  ],

  "marks": [
    {
      "type": "symbol",
      "from": {"data": "movies"},
      "encode": {
        "enter": {
          "x": {"scale": "x", "field": "Rotten Tomatoes Rating"},
          "y": {"scale": "y", "field": "IMDB Rating"},
          "fillOpacity": {"value": 0.5},
          "size": {"value": 16}
        }
      }
    },
    {
      "type": "group",
      "from": {
        "facet": {
          "data": "trend",
          "name": "curve",
          "groupby": "Major Genre"
        }
      },
      "marks": [
        {
          "type": "line",
          "from": {"data": "curve"},
          "encode": {
            "enter": {
              "x": {"scale": "x", "field": "u"},
              "y": {"scale": "y", "field": "v"},
              "stroke": {"value": "firebrick"}
            }
          }
        }
      ]
    }
  ]
}\n"https://vega.github.io/schema/vega/v5.json"\n"A scatter plot with trend line calculated via locally-weighted (loess) regression."\n"datum['Rotten Tomatoes Rating'] != null && datum['IMDB Rating'] != null"\n"groupby === 'genre' ? 'Major Genre' : 'foo'"\n"Rotten Tomatoes Rating"\n"Rotten Tomatoes Rating"\n"Rotten Tomatoes Rating"\n\n\nVega
            
              Vega-Lite
              Altair
              Vega-Lite API
            
          
          
            
              Examples
              Tutorials
              Documentation
              Usage
              About
            
            
              GitHub
              Try Online
            
          
        
      

      
        

  
  
    Labeled Scatter Plot Example
    A scatter plot of motion pictures, showing Rotten Tomatoes Ratings versus IMDB Ratings. The Vega label transform automatically labels points without overlapping any marks.




  
  View Source
  Export PNG
  Export SVG






  View in Online Vega Editor


Vega JSON Specification <>

{
  "$schema": "https://vega.github.io/schema/vega/v5.json",
  "description": "A labeled scatter plot of films showing Rotten Tomatoes ratings versus IMDB ratings.",
  "padding": 5,
  "width": 800,
  "height": 600,
  "autosize": "pad",

  "data": [
    {
      "name": "movies",
      "url": "data/movies.json",
      "transform": [
        {
          "type": "filter",
          "expr": "datum['Rotten Tomatoes Rating'] != null && datum['IMDB Rating'] != null"
        }
      ]
    },
    {
      "name": "fit",
      "source": "movies",
      "transform": [
        {
          "type": "regression",
          "method": "quad",
          "x": "Rotten Tomatoes Rating",
          "y": "IMDB Rating",
          "as": ["u", "v"]
        }
      ]
    }
  ],

  "scales": [
    {
      "name": "x",
      "type": "linear",
      "domain": {"data": "movies", "field": "Rotten Tomatoes Rating"},
      "range": "width"
    },
    {
      "name": "y",
      "type": "linear",
      "domain": {"data": "movies", "field": "IMDB Rating"},
      "range": "height"
    }
  ],

  "axes": [
    {"orient": "left", "scale": "y", "title": "IMDB Rating"},
    {"orient": "bottom", "scale": "x", "title": "Rotten Tomatoes Rating"}
  ],

  "marks": [
    {
      "name": "points",
      "type": "symbol",
      "from": {"data": "movies"},
      "encode": {
        "enter": {
          "x": {"scale": "x", "field": "Rotten Tomatoes Rating"},
          "y": {"scale": "y", "field": "IMDB Rating"},
          "size": {"value": 25},
          "fillOpacity": {"value": 0.5}
        }
      }
    },
    {
      "name": "trend",
      "type": "line",
      "from": {"data": "fit"},
      "encode": {
        "enter": {
          "x": {"scale": "x", "field": "u"},
          "y": {"scale": "y", "field": "v"},
          "stroke": {"value": "firebrick"}
        }
      }
    },
    {
      "type": "text",
      "from": {"data": "points"},
      "encode": {
        "enter": {
          "text": {"field": "datum.Title"},
          "fontSize": {"value": 8}
        }
      },
      "transform": [
        {
          "type": "label",
          "avoidMarks": ["trend"],
          "anchor": ["top", "bottom", "right", "left"],
          "offset": [1],
          "size": {"signal": "[width + 60, height]"}
        }
      ]
    }
  ]
}\nVega
            
              Vega-Lite
              Altair
              Vega-Lite API\nVega-Lite
              Altair
              Vega-Lite API\nExamples
              Tutorials
              Documentation
              Usage
              About
            
            
              GitHub
              Try Online\nExamples
              Tutorials
              Documentation
              Usage
              About\nGitHub
              Try Online\nLabeled Scatter Plot Example
    A scatter plot of motion pictures, showing Rotten Tomatoes Ratings versus IMDB Ratings. The Vega label transform automatically labels points without overlapping any marks.




  
  View Source
  Export PNG
  Export SVG






  View in Online Vega Editor


Vega JSON Specification <>

{
  "$schema": "https://vega.github.io/schema/vega/v5.json",
  "description": "A labeled scatter plot of films showing Rotten Tomatoes ratings versus IMDB ratings.",
  "padding": 5,
  "width": 800,
  "height": 600,
  "autosize": "pad",

  "data": [
    {
      "name": "movies",
      "url": "data/movies.json",
      "transform": [
        {
          "type": "filter",
          "expr": "datum['Rotten Tomatoes Rating'] != null && datum['IMDB Rating'] != null"
        }
      ]
    },
    {
      "name": "fit",
      "source": "movies",
      "transform": [
        {
          "type": "regression",
          "method": "quad",
          "x": "Rotten Tomatoes Rating",
          "y": "IMDB Rating",
          "as": ["u", "v"]
        }
      ]
    }
  ],

  "scales": [
    {
      "name": "x",
      "type": "linear",
      "domain": {"data": "movies", "field": "Rotten Tomatoes Rating"},
      "range": "width"
    },
    {
      "name": "y",
      "type": "linear",
      "domain": {"data": "movies", "field": "IMDB Rating"},
      "range": "height"
    }
  ],

  "axes": [
    {"orient": "left", "scale": "y", "title": "IMDB Rating"},
    {"orient": "bottom", "scale": "x", "title": "Rotten Tomatoes Rating"}
  ],

  "marks": [
    {
      "name": "points",
      "type": "symbol",
      "from": {"data": "movies"},
      "encode": {
        "enter": {
          "x": {"scale": "x", "field": "Rotten Tomatoes Rating"},
          "y": {"scale": "y", "field": "IMDB Rating"},
          "size": {"value": 25},
          "fillOpacity": {"value": 0.5}
        }
      }
    },
    {
      "name": "trend",
      "type": "line",
      "from": {"data": "fit"},
      "encode": {
        "enter": {
          "x": {"scale": "x", "field": "u"},
          "y": {"scale": "y", "field": "v"},
          "stroke": {"value": "firebrick"}
        }
      }
    },
    {
      "type": "text",
      "from": {"data": "points"},
      "encode": {
        "enter": {
          "text": {"field": "datum.Title"},
          "fontSize": {"value": 8}
        }
      },
      "transform": [
        {
          "type": "label",
          "avoidMarks": ["trend"],
          "anchor": ["top", "bottom", "right", "left"],
          "offset": [1],
          "size": {"signal": "[width + 60, height]"}
        }
      ]
    }
  ]
}\nLabeled Scatter Plot Example\nA scatter plot of motion pictures, showing Rotten Tomatoes Ratings versus IMDB Ratings. The Vega label transform automatically labels points without overlapping any marks.\nView Source
  Export PNG
  Export SVG\nView Source
  Export PNG
  Export SVG\nView in Online Vega Editor\nView in Online Vega Editor\nVega JSON Specification <>\n{
  "$schema": "https://vega.github.io/schema/vega/v5.json",
  "description": "A labeled scatter plot of films showing Rotten Tomatoes ratings versus IMDB ratings.",
  "padding": 5,
  "width": 800,
  "height": 600,
  "autosize": "pad",

  "data": [
    {
      "name": "movies",
      "url": "data/movies.json",
      "transform": [
        {
          "type": "filter",
          "expr": "datum['Rotten Tomatoes Rating'] != null && datum['IMDB Rating'] != null"
        }
      ]
    },
    {
      "name": "fit",
      "source": "movies",
      "transform": [
        {
          "type": "regression",
          "method": "quad",
          "x": "Rotten Tomatoes Rating",
          "y": "IMDB Rating",
          "as": ["u", "v"]
        }
      ]
    }
  ],

  "scales": [
    {
      "name": "x",
      "type": "linear",
      "domain": {"data": "movies", "field": "Rotten Tomatoes Rating"},
      "range": "width"
    },
    {
      "name": "y",
      "type": "linear",
      "domain": {"data": "movies", "field": "IMDB Rating"},
      "range": "height"
    }
  ],

  "axes": [
    {"orient": "left", "scale": "y", "title": "IMDB Rating"},
    {"orient": "bottom", "scale": "x", "title": "Rotten Tomatoes Rating"}
  ],

  "marks": [
    {
      "name": "points",
      "type": "symbol",
      "from": {"data": "movies"},
      "encode": {
        "enter": {
          "x": {"scale": "x", "field": "Rotten Tomatoes Rating"},
          "y": {"scale": "y", "field": "IMDB Rating"},
          "size": {"value": 25},
          "fillOpacity": {"value": 0.5}
        }
      }
    },
    {
      "name": "trend",
      "type": "line",
      "from": {"data": "fit"},
      "encode": {
        "enter": {
          "x": {"scale": "x", "field": "u"},
          "y": {"scale": "y", "field": "v"},
          "stroke": {"value": "firebrick"}
        }
      }
    },
    {
      "type": "text",
      "from": {"data": "points"},
      "encode": {
        "enter": {
          "text": {"field": "datum.Title"},
          "fontSize": {"value": 8}
        }
      },
      "transform": [
        {
          "type": "label",
          "avoidMarks": ["trend"],
          "anchor": ["top", "bottom", "right", "left"],
          "offset": [1],
          "size": {"signal": "[width + 60, height]"}
        }
      ]
    }
  ]
}\n{
  "$schema": "https://vega.github.io/schema/vega/v5.json",
  "description": "A labeled scatter plot of films showing Rotten Tomatoes ratings versus IMDB ratings.",
  "padding": 5,
  "width": 800,
  "height": 600,
  "autosize": "pad",

  "data": [
    {
      "name": "movies",
      "url": "data/movies.json",
      "transform": [
        {
          "type": "filter",
          "expr": "datum['Rotten Tomatoes Rating'] != null && datum['IMDB Rating'] != null"
        }
      ]
    },
    {
      "name": "fit",
      "source": "movies",
      "transform": [
        {
          "type": "regression",
          "method": "quad",
          "x": "Rotten Tomatoes Rating",
          "y": "IMDB Rating",
          "as": ["u", "v"]
        }
      ]
    }
  ],

  "scales": [
    {
      "name": "x",
      "type": "linear",
      "domain": {"data": "movies", "field": "Rotten Tomatoes Rating"},
      "range": "width"
    },
    {
      "name": "y",
      "type": "linear",
      "domain": {"data": "movies", "field": "IMDB Rating"},
      "range": "height"
    }
  ],

  "axes": [
    {"orient": "left", "scale": "y", "title": "IMDB Rating"},
    {"orient": "bottom", "scale": "x", "title": "Rotten Tomatoes Rating"}
  ],

  "marks": [
    {
      "name": "points",
      "type": "symbol",
      "from": {"data": "movies"},
      "encode": {
        "enter": {
          "x": {"scale": "x", "field": "Rotten Tomatoes Rating"},
          "y": {"scale": "y", "field": "IMDB Rating"},
          "size": {"value": 25},
          "fillOpacity": {"value": 0.5}
        }
      }
    },
    {
      "name": "trend",
      "type": "line",
      "from": {"data": "fit"},
      "encode": {
        "enter": {
          "x": {"scale": "x", "field": "u"},
          "y": {"scale": "y", "field": "v"},
          "stroke": {"value": "firebrick"}
        }
      }
    },
    {
      "type": "text",
      "from": {"data": "points"},
      "encode": {
        "enter": {
          "text": {"field": "datum.Title"},
          "fontSize": {"value": 8}
        }
      },
      "transform": [
        {
          "type": "label",
          "avoidMarks": ["trend"],
          "anchor": ["top", "bottom", "right", "left"],
          "offset": [1],
          "size": {"signal": "[width + 60, height]"}
        }
      ]
    }
  ]
}\n"https://vega.github.io/schema/vega/v5.json"\n"A labeled scatter plot of films showing Rotten Tomatoes ratings versus IMDB ratings."\n"datum['Rotten Tomatoes Rating'] != null && datum['IMDB Rating'] != null"\n"Rotten Tomatoes Rating"\n"Rotten Tomatoes Rating"\n"Rotten Tomatoes Rating"\n"Rotten Tomatoes Rating"\n"[width + 60, height]"\n\n\nVega
            
              Vega-Lite
              Altair
              Vega-Lite API
            
          
          
            
              Examples
              Tutorials
              Documentation
              Usage
              About
            
            
              GitHub
              Try Online
            
          
        
      

      
        

  
  
    Top-K Plot Example
    A plot of the top-k film directors by aggregate worldwide gross. Performs an aggregation of all directors, ranks them, and filters to only the top results. See the Top-K Plot With Others example to see a variant that combines all remaining directors into an “Others” category.




  
  View Source
  Export PNG
  Export SVG






  View in Online Vega Editor


Vega JSON Specification <>

{
  "$schema": "https://vega.github.io/schema/vega/v5.json",
  "description": "A top-k bar chart ranking film directors by revenue.",
  "width": 500,
  "height": 410,
  "padding": 5,
  "autosize": "fit",

  "signals": [
    {
      "name": "k", "value": 20,
      "bind": {"input": "range", "min": 10, "max": 30, "step": 1}
    },
    {
      "name": "op", "value": "average",
      "bind": {"input": "select", "options": ["average", "median", "sum"]}
    },
    {
      "name": "label",
      "value": {"average": "Average", "median": "Median", "sum": "Total"}
    }
  ],

  "title": {
    "text": {"signal": "'Top Directors by ' + label[op] + ' Worldwide Gross'"},
    "anchor": "start",
    "frame": "group"
  },

  "data": [
    {
      "name": "directors",
      "url": "data/movies.json",
      "transform": [
        {
          "type": "filter",
          "expr": "datum.Director != null && datum['Worldwide Gross'] != null"
        },
        {
          "type": "aggregate",
          "groupby": ["Director"],
          "ops": [{"signal": "op"}],
          "fields": ["Worldwide Gross"],
          "as": ["Gross"]
        },
        {
          "type": "window",
          "sort": {"field": "Gross", "order": "descending"},
          "ops": ["row_number"], "as": ["rank"]
        },
        {
          "type": "filter",
          "expr": "datum.rank <= k"
        }
      ]
    }
  ],

  "marks": [
    {
      "type": "rect",
      "from": {"data": "directors"},
      "encode": {
        "update": {
          "x": {"scale": "x", "value": 0},
          "x2": {"scale": "x", "field": "Gross"},
          "y": {"scale": "y", "field": "Director"},
          "height": {"scale": "y", "band": 1}
        }
      }
    }
  ],

  "scales": [
    {
      "name": "x",
      "type": "linear",
      "domain": {"data": "directors", "field": "Gross"},
      "range": "width",
      "nice": true
    },
    {
      "name": "y",
      "type": "band",
      "domain": {
        "data": "directors", "field": "Director",
        "sort": {"op": "max", "field": "Gross", "order": "descending"}
      },
      "range": "height",
      "padding": 0.1
    }
  ],

  "axes": [
    {
      "scale": "x",
      "orient": "bottom",
      "format": "$,d",
      "tickCount": 5
    },
    {
      "scale": "y",
      "orient": "left"
    }
  ]
}\nVega
            
              Vega-Lite
              Altair
              Vega-Lite API\nVega-Lite
              Altair
              Vega-Lite API\nExamples
              Tutorials
              Documentation
              Usage
              About
            
            
              GitHub
              Try Online\nExamples
              Tutorials
              Documentation
              Usage
              About\nGitHub
              Try Online\nTop-K Plot Example
    A plot of the top-k film directors by aggregate worldwide gross. Performs an aggregation of all directors, ranks them, and filters to only the top results. See the Top-K Plot With Others example to see a variant that combines all remaining directors into an “Others” category.




  
  View Source
  Export PNG
  Export SVG






  View in Online Vega Editor


Vega JSON Specification <>

{
  "$schema": "https://vega.github.io/schema/vega/v5.json",
  "description": "A top-k bar chart ranking film directors by revenue.",
  "width": 500,
  "height": 410,
  "padding": 5,
  "autosize": "fit",

  "signals": [
    {
      "name": "k", "value": 20,
      "bind": {"input": "range", "min": 10, "max": 30, "step": 1}
    },
    {
      "name": "op", "value": "average",
      "bind": {"input": "select", "options": ["average", "median", "sum"]}
    },
    {
      "name": "label",
      "value": {"average": "Average", "median": "Median", "sum": "Total"}
    }
  ],

  "title": {
    "text": {"signal": "'Top Directors by ' + label[op] + ' Worldwide Gross'"},
    "anchor": "start",
    "frame": "group"
  },

  "data": [
    {
      "name": "directors",
      "url": "data/movies.json",
      "transform": [
        {
          "type": "filter",
          "expr": "datum.Director != null && datum['Worldwide Gross'] != null"
        },
        {
          "type": "aggregate",
          "groupby": ["Director"],
          "ops": [{"signal": "op"}],
          "fields": ["Worldwide Gross"],
          "as": ["Gross"]
        },
        {
          "type": "window",
          "sort": {"field": "Gross", "order": "descending"},
          "ops": ["row_number"], "as": ["rank"]
        },
        {
          "type": "filter",
          "expr": "datum.rank <= k"
        }
      ]
    }
  ],

  "marks": [
    {
      "type": "rect",
      "from": {"data": "directors"},
      "encode": {
        "update": {
          "x": {"scale": "x", "value": 0},
          "x2": {"scale": "x", "field": "Gross"},
          "y": {"scale": "y", "field": "Director"},
          "height": {"scale": "y", "band": 1}
        }
      }
    }
  ],

  "scales": [
    {
      "name": "x",
      "type": "linear",
      "domain": {"data": "directors", "field": "Gross"},
      "range": "width",
      "nice": true
    },
    {
      "name": "y",
      "type": "band",
      "domain": {
        "data": "directors", "field": "Director",
        "sort": {"op": "max", "field": "Gross", "order": "descending"}
      },
      "range": "height",
      "padding": 0.1
    }
  ],

  "axes": [
    {
      "scale": "x",
      "orient": "bottom",
      "format": "$,d",
      "tickCount": 5
    },
    {
      "scale": "y",
      "orient": "left"
    }
  ]
}\nA plot of the top-k film directors by aggregate worldwide gross. Performs an aggregation of all directors, ranks them, and filters to only the top results. See the Top-K Plot With Others example to see a variant that combines all remaining directors into an “Others” category.\nTop-K Plot With Others\nView Source
  Export PNG
  Export SVG\nView Source
  Export PNG
  Export SVG\nView in Online Vega Editor\nView in Online Vega Editor\nVega JSON Specification <>\n{
  "$schema": "https://vega.github.io/schema/vega/v5.json",
  "description": "A top-k bar chart ranking film directors by revenue.",
  "width": 500,
  "height": 410,
  "padding": 5,
  "autosize": "fit",

  "signals": [
    {
      "name": "k", "value": 20,
      "bind": {"input": "range", "min": 10, "max": 30, "step": 1}
    },
    {
      "name": "op", "value": "average",
      "bind": {"input": "select", "options": ["average", "median", "sum"]}
    },
    {
      "name": "label",
      "value": {"average": "Average", "median": "Median", "sum": "Total"}
    }
  ],

  "title": {
    "text": {"signal": "'Top Directors by ' + label[op] + ' Worldwide Gross'"},
    "anchor": "start",
    "frame": "group"
  },

  "data": [
    {
      "name": "directors",
      "url": "data/movies.json",
      "transform": [
        {
          "type": "filter",
          "expr": "datum.Director != null && datum['Worldwide Gross'] != null"
        },
        {
          "type": "aggregate",
          "groupby": ["Director"],
          "ops": [{"signal": "op"}],
          "fields": ["Worldwide Gross"],
          "as": ["Gross"]
        },
        {
          "type": "window",
          "sort": {"field": "Gross", "order": "descending"},
          "ops": ["row_number"], "as": ["rank"]
        },
        {
          "type": "filter",
          "expr": "datum.rank <= k"
        }
      ]
    }
  ],

  "marks": [
    {
      "type": "rect",
      "from": {"data": "directors"},
      "encode": {
        "update": {
          "x": {"scale": "x", "value": 0},
          "x2": {"scale": "x", "field": "Gross"},
          "y": {"scale": "y", "field": "Director"},
          "height": {"scale": "y", "band": 1}
        }
      }
    }
  ],

  "scales": [
    {
      "name": "x",
      "type": "linear",
      "domain": {"data": "directors", "field": "Gross"},
      "range": "width",
      "nice": true
    },
    {
      "name": "y",
      "type": "band",
      "domain": {
        "data": "directors", "field": "Director",
        "sort": {"op": "max", "field": "Gross", "order": "descending"}
      },
      "range": "height",
      "padding": 0.1
    }
  ],

  "axes": [
    {
      "scale": "x",
      "orient": "bottom",
      "format": "$,d",
      "tickCount": 5
    },
    {
      "scale": "y",
      "orient": "left"
    }
  ]
}\n{
  "$schema": "https://vega.github.io/schema/vega/v5.json",
  "description": "A top-k bar chart ranking film directors by revenue.",
  "width": 500,
  "height": 410,
  "padding": 5,
  "autosize": "fit",

  "signals": [
    {
      "name": "k", "value": 20,
      "bind": {"input": "range", "min": 10, "max": 30, "step": 1}
    },
    {
      "name": "op", "value": "average",
      "bind": {"input": "select", "options": ["average", "median", "sum"]}
    },
    {
      "name": "label",
      "value": {"average": "Average", "median": "Median", "sum": "Total"}
    }
  ],

  "title": {
    "text": {"signal": "'Top Directors by ' + label[op] + ' Worldwide Gross'"},
    "anchor": "start",
    "frame": "group"
  },

  "data": [
    {
      "name": "directors",
      "url": "data/movies.json",
      "transform": [
        {
          "type": "filter",
          "expr": "datum.Director != null && datum['Worldwide Gross'] != null"
        },
        {
          "type": "aggregate",
          "groupby": ["Director"],
          "ops": [{"signal": "op"}],
          "fields": ["Worldwide Gross"],
          "as": ["Gross"]
        },
        {
          "type": "window",
          "sort": {"field": "Gross", "order": "descending"},
          "ops": ["row_number"], "as": ["rank"]
        },
        {
          "type": "filter",
          "expr": "datum.rank <= k"
        }
      ]
    }
  ],

  "marks": [
    {
      "type": "rect",
      "from": {"data": "directors"},
      "encode": {
        "update": {
          "x": {"scale": "x", "value": 0},
          "x2": {"scale": "x", "field": "Gross"},
          "y": {"scale": "y", "field": "Director"},
          "height": {"scale": "y", "band": 1}
        }
      }
    }
  ],

  "scales": [
    {
      "name": "x",
      "type": "linear",
      "domain": {"data": "directors", "field": "Gross"},
      "range": "width",
      "nice": true
    },
    {
      "name": "y",
      "type": "band",
      "domain": {
        "data": "directors", "field": "Director",
        "sort": {"op": "max", "field": "Gross", "order": "descending"}
      },
      "range": "height",
      "padding": 0.1
    }
  ],

  "axes": [
    {
      "scale": "x",
      "orient": "bottom",
      "format": "$,d",
      "tickCount": 5
    },
    {
      "scale": "y",
      "orient": "left"
    }
  ]
}\n"https://vega.github.io/schema/vega/v5.json"\n"A top-k bar chart ranking film directors by revenue."\n"'Top Directors by ' + label[op] + ' Worldwide Gross'"\n"datum.Director != null && datum['Worldwide Gross'] != null"\n\n\nVega
            
              Vega-Lite
              Altair
              Vega-Lite API
            
          
          
            
              Examples
              Tutorials
              Documentation
              Usage
              About
            
            
              GitHub
              Try Online
            
          
        
      

      
        

  
  
    Top-K Plot With Others Example
    A plot of the top-k film directors, plus all other directors, by aggregate worldwide gross. Unlike the Top-K Plot example, this chart includes a category of all other directors aggregated together. The visualization spec first computes aggregates for all directors and ranks them. It then copies these ranks back to the source data using a lookup transform, and determines which directors belong in the “other” category before performing a final aggregation.




  
  View Source
  Export PNG
  Export SVG






  View in Online Vega Editor


Vega JSON Specification <>

{
  "$schema": "https://vega.github.io/schema/vega/v5.json",
  "description": "A top-k bar chart ranking film directors by revenue, including an aggregate others category.",
  "width": 500,
  "height": 410,
  "padding": 5,
  "autosize": "fit",

  "signals": [
    {
      "name": "k", "value": 20,
      "bind": {"input": "range", "min": 10, "max": 30, "step": 1}
    },
    {
      "name": "op", "value": "average",
      "bind": {"input": "select", "options": ["average", "median", "sum"]}
    },
    {
      "name": "label",
      "value": {"average": "Average", "median": "Median", "sum": "Total"}
    }
  ],

  "title": {
    "text": {"signal": "'Top Directors by ' + label[op] + ' Worldwide Gross'"},
    "anchor": "start",
    "frame": "group"
  },

  "data": [
    {
      "name": "source",
      "url": "data/movies.json",
      "transform": [
        {
          "type": "filter",
          "expr": "datum.Director != null && datum['Worldwide Gross'] != null"
        }
      ]
    },
    {
      "name": "ranks",
      "source": "source",
      "transform": [
        {
          "type": "aggregate",
          "groupby": ["Director"],
          "ops": [{"signal": "op"}],
          "fields": ["Worldwide Gross"],
          "as": ["Gross"]
        },
        {
          "type": "window",
          "sort": {"field": "Gross", "order": "descending"},
          "ops": ["row_number"], "as": ["rank"]
        }
      ]
    },
    {
      "name": "directors",
      "source": "source",
      "transform": [
        {
          "type": "lookup",
          "from": "ranks",
          "key": "Director",
          "values": ["rank"],
          "fields": ["Director"]
        },
        {
          "type": "formula",
          "as": "Category",
          "expr": "datum.rank < k ? datum.Director : 'All Others'"
        },
        {
          "type": "aggregate",
          "groupby": ["Category"],
          "ops": [{"signal": "op"}],
          "fields": ["Worldwide Gross"],
          "as": ["Gross"]
        }
      ]
    }
  ],

  "marks": [
    {
      "type": "rect",
      "from": {"data": "directors"},
      "encode": {
        "update": {
          "x": {"scale": "x", "value": 0},
          "x2": {"scale": "x", "field": "Gross"},
          "y": {"scale": "y", "field": "Category"},
          "height": {"scale": "y", "band": 1}
        }
      }
    }
  ],

  "scales": [
    {
      "name": "x",
      "type": "linear",
      "domain": {"data": "directors", "field": "Gross"},
      "range": "width",
      "nice": true
    },
    {
      "name": "y",
      "type": "band",
      "domain": {
        "data": "directors", "field": "Category",
        "sort": {"op": "max", "field": "Gross", "order": "descending"}
      },
      "range": "height",
      "padding": 0.1
    }
  ],

  "axes": [
    {
      "scale": "x",
      "orient": "bottom",
      "format": "$,d",
      "tickCount": 5
    },
    {
      "scale": "y",
      "orient": "left"
    }
  ]
}\nVega
            
              Vega-Lite
              Altair
              Vega-Lite API\nVega-Lite
              Altair
              Vega-Lite API\nExamples
              Tutorials
              Documentation
              Usage
              About
            
            
              GitHub
              Try Online\nExamples
              Tutorials
              Documentation
              Usage
              About\nGitHub
              Try Online\nTop-K Plot With Others Example
    A plot of the top-k film directors, plus all other directors, by aggregate worldwide gross. Unlike the Top-K Plot example, this chart includes a category of all other directors aggregated together. The visualization spec first computes aggregates for all directors and ranks them. It then copies these ranks back to the source data using a lookup transform, and determines which directors belong in the “other” category before performing a final aggregation.




  
  View Source
  Export PNG
  Export SVG






  View in Online Vega Editor


Vega JSON Specification <>

{
  "$schema": "https://vega.github.io/schema/vega/v5.json",
  "description": "A top-k bar chart ranking film directors by revenue, including an aggregate others category.",
  "width": 500,
  "height": 410,
  "padding": 5,
  "autosize": "fit",

  "signals": [
    {
      "name": "k", "value": 20,
      "bind": {"input": "range", "min": 10, "max": 30, "step": 1}
    },
    {
      "name": "op", "value": "average",
      "bind": {"input": "select", "options": ["average", "median", "sum"]}
    },
    {
      "name": "label",
      "value": {"average": "Average", "median": "Median", "sum": "Total"}
    }
  ],

  "title": {
    "text": {"signal": "'Top Directors by ' + label[op] + ' Worldwide Gross'"},
    "anchor": "start",
    "frame": "group"
  },

  "data": [
    {
      "name": "source",
      "url": "data/movies.json",
      "transform": [
        {
          "type": "filter",
          "expr": "datum.Director != null && datum['Worldwide Gross'] != null"
        }
      ]
    },
    {
      "name": "ranks",
      "source": "source",
      "transform": [
        {
          "type": "aggregate",
          "groupby": ["Director"],
          "ops": [{"signal": "op"}],
          "fields": ["Worldwide Gross"],
          "as": ["Gross"]
        },
        {
          "type": "window",
          "sort": {"field": "Gross", "order": "descending"},
          "ops": ["row_number"], "as": ["rank"]
        }
      ]
    },
    {
      "name": "directors",
      "source": "source",
      "transform": [
        {
          "type": "lookup",
          "from": "ranks",
          "key": "Director",
          "values": ["rank"],
          "fields": ["Director"]
        },
        {
          "type": "formula",
          "as": "Category",
          "expr": "datum.rank < k ? datum.Director : 'All Others'"
        },
        {
          "type": "aggregate",
          "groupby": ["Category"],
          "ops": [{"signal": "op"}],
          "fields": ["Worldwide Gross"],
          "as": ["Gross"]
        }
      ]
    }
  ],

  "marks": [
    {
      "type": "rect",
      "from": {"data": "directors"},
      "encode": {
        "update": {
          "x": {"scale": "x", "value": 0},
          "x2": {"scale": "x", "field": "Gross"},
          "y": {"scale": "y", "field": "Category"},
          "height": {"scale": "y", "band": 1}
        }
      }
    }
  ],

  "scales": [
    {
      "name": "x",
      "type": "linear",
      "domain": {"data": "directors", "field": "Gross"},
      "range": "width",
      "nice": true
    },
    {
      "name": "y",
      "type": "band",
      "domain": {
        "data": "directors", "field": "Category",
        "sort": {"op": "max", "field": "Gross", "order": "descending"}
      },
      "range": "height",
      "padding": 0.1
    }
  ],

  "axes": [
    {
      "scale": "x",
      "orient": "bottom",
      "format": "$,d",
      "tickCount": 5
    },
    {
      "scale": "y",
      "orient": "left"
    }
  ]
}\nTop-K Plot With Others Example\nA plot of the top-k film directors, plus all other directors, by aggregate worldwide gross. Unlike the Top-K Plot example, this chart includes a category of all other directors aggregated together. The visualization spec first computes aggregates for all directors and ranks them. It then copies these ranks back to the source data using a lookup transform, and determines which directors belong in the “other” category before performing a final aggregation.\nView Source
  Export PNG
  Export SVG\nView Source
  Export PNG
  Export SVG\nView in Online Vega Editor\nView in Online Vega Editor\nVega JSON Specification <>\n{
  "$schema": "https://vega.github.io/schema/vega/v5.json",
  "description": "A top-k bar chart ranking film directors by revenue, including an aggregate others category.",
  "width": 500,
  "height": 410,
  "padding": 5,
  "autosize": "fit",

  "signals": [
    {
      "name": "k", "value": 20,
      "bind": {"input": "range", "min": 10, "max": 30, "step": 1}
    },
    {
      "name": "op", "value": "average",
      "bind": {"input": "select", "options": ["average", "median", "sum"]}
    },
    {
      "name": "label",
      "value": {"average": "Average", "median": "Median", "sum": "Total"}
    }
  ],

  "title": {
    "text": {"signal": "'Top Directors by ' + label[op] + ' Worldwide Gross'"},
    "anchor": "start",
    "frame": "group"
  },

  "data": [
    {
      "name": "source",
      "url": "data/movies.json",
      "transform": [
        {
          "type": "filter",
          "expr": "datum.Director != null && datum['Worldwide Gross'] != null"
        }
      ]
    },
    {
      "name": "ranks",
      "source": "source",
      "transform": [
        {
          "type": "aggregate",
          "groupby": ["Director"],
          "ops": [{"signal": "op"}],
          "fields": ["Worldwide Gross"],
          "as": ["Gross"]
        },
        {
          "type": "window",
          "sort": {"field": "Gross", "order": "descending"},
          "ops": ["row_number"], "as": ["rank"]
        }
      ]
    },
    {
      "name": "directors",
      "source": "source",
      "transform": [
        {
          "type": "lookup",
          "from": "ranks",
          "key": "Director",
          "values": ["rank"],
          "fields": ["Director"]
        },
        {
          "type": "formula",
          "as": "Category",
          "expr": "datum.rank < k ? datum.Director : 'All Others'"
        },
        {
          "type": "aggregate",
          "groupby": ["Category"],
          "ops": [{"signal": "op"}],
          "fields": ["Worldwide Gross"],
          "as": ["Gross"]
        }
      ]
    }
  ],

  "marks": [
    {
      "type": "rect",
      "from": {"data": "directors"},
      "encode": {
        "update": {
          "x": {"scale": "x", "value": 0},
          "x2": {"scale": "x", "field": "Gross"},
          "y": {"scale": "y", "field": "Category"},
          "height": {"scale": "y", "band": 1}
        }
      }
    }
  ],

  "scales": [
    {
      "name": "x",
      "type": "linear",
      "domain": {"data": "directors", "field": "Gross"},
      "range": "width",
      "nice": true
    },
    {
      "name": "y",
      "type": "band",
      "domain": {
        "data": "directors", "field": "Category",
        "sort": {"op": "max", "field": "Gross", "order": "descending"}
      },
      "range": "height",
      "padding": 0.1
    }
  ],

  "axes": [
    {
      "scale": "x",
      "orient": "bottom",
      "format": "$,d",
      "tickCount": 5
    },
    {
      "scale": "y",
      "orient": "left"
    }
  ]
}\n{
  "$schema": "https://vega.github.io/schema/vega/v5.json",
  "description": "A top-k bar chart ranking film directors by revenue, including an aggregate others category.",
  "width": 500,
  "height": 410,
  "padding": 5,
  "autosize": "fit",

  "signals": [
    {
      "name": "k", "value": 20,
      "bind": {"input": "range", "min": 10, "max": 30, "step": 1}
    },
    {
      "name": "op", "value": "average",
      "bind": {"input": "select", "options": ["average", "median", "sum"]}
    },
    {
      "name": "label",
      "value": {"average": "Average", "median": "Median", "sum": "Total"}
    }
  ],

  "title": {
    "text": {"signal": "'Top Directors by ' + label[op] + ' Worldwide Gross'"},
    "anchor": "start",
    "frame": "group"
  },

  "data": [
    {
      "name": "source",
      "url": "data/movies.json",
      "transform": [
        {
          "type": "filter",
          "expr": "datum.Director != null && datum['Worldwide Gross'] != null"
        }
      ]
    },
    {
      "name": "ranks",
      "source": "source",
      "transform": [
        {
          "type": "aggregate",
          "groupby": ["Director"],
          "ops": [{"signal": "op"}],
          "fields": ["Worldwide Gross"],
          "as": ["Gross"]
        },
        {
          "type": "window",
          "sort": {"field": "Gross", "order": "descending"},
          "ops": ["row_number"], "as": ["rank"]
        }
      ]
    },
    {
      "name": "directors",
      "source": "source",
      "transform": [
        {
          "type": "lookup",
          "from": "ranks",
          "key": "Director",
          "values": ["rank"],
          "fields": ["Director"]
        },
        {
          "type": "formula",
          "as": "Category",
          "expr": "datum.rank < k ? datum.Director : 'All Others'"
        },
        {
          "type": "aggregate",
          "groupby": ["Category"],
          "ops": [{"signal": "op"}],
          "fields": ["Worldwide Gross"],
          "as": ["Gross"]
        }
      ]
    }
  ],

  "marks": [
    {
      "type": "rect",
      "from": {"data": "directors"},
      "encode": {
        "update": {
          "x": {"scale": "x", "value": 0},
          "x2": {"scale": "x", "field": "Gross"},
          "y": {"scale": "y", "field": "Category"},
          "height": {"scale": "y", "band": 1}
        }
      }
    }
  ],

  "scales": [
    {
      "name": "x",
      "type": "linear",
      "domain": {"data": "directors", "field": "Gross"},
      "range": "width",
      "nice": true
    },
    {
      "name": "y",
      "type": "band",
      "domain": {
        "data": "directors", "field": "Category",
        "sort": {"op": "max", "field": "Gross", "order": "descending"}
      },
      "range": "height",
      "padding": 0.1
    }
  ],

  "axes": [
    {
      "scale": "x",
      "orient": "bottom",
      "format": "$,d",
      "tickCount": 5
    },
    {
      "scale": "y",
      "orient": "left"
    }
  ]
}\n"https://vega.github.io/schema/vega/v5.json"\n"A top-k bar chart ranking film directors by revenue, including an aggregate others category."\n"'Top Directors by ' + label[op] + ' Worldwide Gross'"\n"datum.Director != null && datum['Worldwide Gross'] != null"\n"datum.rank < k ? datum.Director : 'All Others'"\n\n\nVega
            
              Vega-Lite
              Altair
              Vega-Lite API
            
          
          
            
              Examples
              Tutorials
              Documentation
              Usage
              About
            
            
              GitHub
              Try Online
            
          
        
      

      
        

  
  
    Histogram Example
    A histogram subdivides a numerical range into bins, and counts the number of data points within each segment. The resulting bar chart provides a discrete estimate of the probability density function.




  
  View Source
  Export PNG
  Export SVG






  View in Online Vega Editor


Vega JSON Specification <>

{
  "$schema": "https://vega.github.io/schema/vega/v5.json",
  "description": "An interactive histogram for visualizing a univariate distribution.",
  "width": 500,
  "height": 100,
  "padding": 5,

  "signals": [
    { "name": "binOffset", "value": 0,
      "bind": {"input": "range", "min": -0.1, "max": 0.1} },
    { "name": "binStep", "value": 0.1,
      "bind": {"input": "range", "min": 0.001, "max": 0.4, "step": 0.001} }
  ],

  "data": [
    {
      "name": "points",
      "url": "data/normal-2d.json"
    },
    {
      "name": "binned",
      "source": "points",
      "transform": [
        {
          "type": "bin", "field": "u",
          "extent": [-1, 1],
          "anchor": {"signal": "binOffset"},
          "step": {"signal": "binStep"},
          "nice": false
        },
        {
          "type": "aggregate",
          "key": "bin0", "groupby": ["bin0", "bin1"],
          "fields": ["bin0"], "ops": ["count"], "as": ["count"]
        }
      ]
    }
  ],

  "scales": [
    {
      "name": "xscale",
      "type": "linear",
      "range": "width",
      "domain": [-1, 1]
    },
    {
      "name": "yscale",
      "type": "linear",
      "range": "height", "round": true,
      "domain": {"data": "binned", "field": "count"},
      "zero": true, "nice": true
    }
  ],

  "axes": [
    {"orient": "bottom", "scale": "xscale", "zindex": 1},
    {"orient": "left", "scale": "yscale", "tickCount": 5, "zindex": 1}
  ],

  "marks": [
    {
      "type": "rect",
      "from": {"data": "binned"},
      "encode": {
        "update": {
          "x": {"scale": "xscale", "field": "bin0"},
          "x2": {"scale": "xscale", "field": "bin1",
                 "offset": {"signal": "binStep > 0.02 ? -0.5 : 0"}},
          "y": {"scale": "yscale", "field": "count"},
          "y2": {"scale": "yscale", "value": 0},
          "fill": {"value": "steelblue"}
        },
        "hover": { "fill": {"value": "firebrick"} }
      }
    },
    {
      "type": "rect",
      "from": {"data": "points"},
      "encode": {
        "enter": {
          "x": {"scale": "xscale", "field": "u"},
          "width": {"value": 1},
          "y": {"value": 25, "offset": {"signal": "height"}},
          "height": {"value": 5},
          "fill": {"value": "steelblue"},
          "fillOpacity": {"value": 0.4}
        }
      }
    }
  ]
}\nVega
            
              Vega-Lite
              Altair
              Vega-Lite API\nVega-Lite
              Altair
              Vega-Lite API\nExamples
              Tutorials
              Documentation
              Usage
              About
            
            
              GitHub
              Try Online\nExamples
              Tutorials
              Documentation
              Usage
              About\nGitHub
              Try Online\nHistogram Example
    A histogram subdivides a numerical range into bins, and counts the number of data points within each segment. The resulting bar chart provides a discrete estimate of the probability density function.




  
  View Source
  Export PNG
  Export SVG






  View in Online Vega Editor


Vega JSON Specification <>

{
  "$schema": "https://vega.github.io/schema/vega/v5.json",
  "description": "An interactive histogram for visualizing a univariate distribution.",
  "width": 500,
  "height": 100,
  "padding": 5,

  "signals": [
    { "name": "binOffset", "value": 0,
      "bind": {"input": "range", "min": -0.1, "max": 0.1} },
    { "name": "binStep", "value": 0.1,
      "bind": {"input": "range", "min": 0.001, "max": 0.4, "step": 0.001} }
  ],

  "data": [
    {
      "name": "points",
      "url": "data/normal-2d.json"
    },
    {
      "name": "binned",
      "source": "points",
      "transform": [
        {
          "type": "bin", "field": "u",
          "extent": [-1, 1],
          "anchor": {"signal": "binOffset"},
          "step": {"signal": "binStep"},
          "nice": false
        },
        {
          "type": "aggregate",
          "key": "bin0", "groupby": ["bin0", "bin1"],
          "fields": ["bin0"], "ops": ["count"], "as": ["count"]
        }
      ]
    }
  ],

  "scales": [
    {
      "name": "xscale",
      "type": "linear",
      "range": "width",
      "domain": [-1, 1]
    },
    {
      "name": "yscale",
      "type": "linear",
      "range": "height", "round": true,
      "domain": {"data": "binned", "field": "count"},
      "zero": true, "nice": true
    }
  ],

  "axes": [
    {"orient": "bottom", "scale": "xscale", "zindex": 1},
    {"orient": "left", "scale": "yscale", "tickCount": 5, "zindex": 1}
  ],

  "marks": [
    {
      "type": "rect",
      "from": {"data": "binned"},
      "encode": {
        "update": {
          "x": {"scale": "xscale", "field": "bin0"},
          "x2": {"scale": "xscale", "field": "bin1",
                 "offset": {"signal": "binStep > 0.02 ? -0.5 : 0"}},
          "y": {"scale": "yscale", "field": "count"},
          "y2": {"scale": "yscale", "value": 0},
          "fill": {"value": "steelblue"}
        },
        "hover": { "fill": {"value": "firebrick"} }
      }
    },
    {
      "type": "rect",
      "from": {"data": "points"},
      "encode": {
        "enter": {
          "x": {"scale": "xscale", "field": "u"},
          "width": {"value": 1},
          "y": {"value": 25, "offset": {"signal": "height"}},
          "height": {"value": 5},
          "fill": {"value": "steelblue"},
          "fillOpacity": {"value": 0.4}
        }
      }
    }
  ]
}\nA histogram subdivides a numerical range into bins, and counts the number of data points within each segment. The resulting bar chart provides a discrete estimate of the probability density function.\nView Source
  Export PNG
  Export SVG\nView Source
  Export PNG
  Export SVG\nView in Online Vega Editor\nView in Online Vega Editor\nVega JSON Specification <>\n{
  "$schema": "https://vega.github.io/schema/vega/v5.json",
  "description": "An interactive histogram for visualizing a univariate distribution.",
  "width": 500,
  "height": 100,
  "padding": 5,

  "signals": [
    { "name": "binOffset", "value": 0,
      "bind": {"input": "range", "min": -0.1, "max": 0.1} },
    { "name": "binStep", "value": 0.1,
      "bind": {"input": "range", "min": 0.001, "max": 0.4, "step": 0.001} }
  ],

  "data": [
    {
      "name": "points",
      "url": "data/normal-2d.json"
    },
    {
      "name": "binned",
      "source": "points",
      "transform": [
        {
          "type": "bin", "field": "u",
          "extent": [-1, 1],
          "anchor": {"signal": "binOffset"},
          "step": {"signal": "binStep"},
          "nice": false
        },
        {
          "type": "aggregate",
          "key": "bin0", "groupby": ["bin0", "bin1"],
          "fields": ["bin0"], "ops": ["count"], "as": ["count"]
        }
      ]
    }
  ],

  "scales": [
    {
      "name": "xscale",
      "type": "linear",
      "range": "width",
      "domain": [-1, 1]
    },
    {
      "name": "yscale",
      "type": "linear",
      "range": "height", "round": true,
      "domain": {"data": "binned", "field": "count"},
      "zero": true, "nice": true
    }
  ],

  "axes": [
    {"orient": "bottom", "scale": "xscale", "zindex": 1},
    {"orient": "left", "scale": "yscale", "tickCount": 5, "zindex": 1}
  ],

  "marks": [
    {
      "type": "rect",
      "from": {"data": "binned"},
      "encode": {
        "update": {
          "x": {"scale": "xscale", "field": "bin0"},
          "x2": {"scale": "xscale", "field": "bin1",
                 "offset": {"signal": "binStep > 0.02 ? -0.5 : 0"}},
          "y": {"scale": "yscale", "field": "count"},
          "y2": {"scale": "yscale", "value": 0},
          "fill": {"value": "steelblue"}
        },
        "hover": { "fill": {"value": "firebrick"} }
      }
    },
    {
      "type": "rect",
      "from": {"data": "points"},
      "encode": {
        "enter": {
          "x": {"scale": "xscale", "field": "u"},
          "width": {"value": 1},
          "y": {"value": 25, "offset": {"signal": "height"}},
          "height": {"value": 5},
          "fill": {"value": "steelblue"},
          "fillOpacity": {"value": 0.4}
        }
      }
    }
  ]
}\n{
  "$schema": "https://vega.github.io/schema/vega/v5.json",
  "description": "An interactive histogram for visualizing a univariate distribution.",
  "width": 500,
  "height": 100,
  "padding": 5,

  "signals": [
    { "name": "binOffset", "value": 0,
      "bind": {"input": "range", "min": -0.1, "max": 0.1} },
    { "name": "binStep", "value": 0.1,
      "bind": {"input": "range", "min": 0.001, "max": 0.4, "step": 0.001} }
  ],

  "data": [
    {
      "name": "points",
      "url": "data/normal-2d.json"
    },
    {
      "name": "binned",
      "source": "points",
      "transform": [
        {
          "type": "bin", "field": "u",
          "extent": [-1, 1],
          "anchor": {"signal": "binOffset"},
          "step": {"signal": "binStep"},
          "nice": false
        },
        {
          "type": "aggregate",
          "key": "bin0", "groupby": ["bin0", "bin1"],
          "fields": ["bin0"], "ops": ["count"], "as": ["count"]
        }
      ]
    }
  ],

  "scales": [
    {
      "name": "xscale",
      "type": "linear",
      "range": "width",
      "domain": [-1, 1]
    },
    {
      "name": "yscale",
      "type": "linear",
      "range": "height", "round": true,
      "domain": {"data": "binned", "field": "count"},
      "zero": true, "nice": true
    }
  ],

  "axes": [
    {"orient": "bottom", "scale": "xscale", "zindex": 1},
    {"orient": "left", "scale": "yscale", "tickCount": 5, "zindex": 1}
  ],

  "marks": [
    {
      "type": "rect",
      "from": {"data": "binned"},
      "encode": {
        "update": {
          "x": {"scale": "xscale", "field": "bin0"},
          "x2": {"scale": "xscale", "field": "bin1",
                 "offset": {"signal": "binStep > 0.02 ? -0.5 : 0"}},
          "y": {"scale": "yscale", "field": "count"},
          "y2": {"scale": "yscale", "value": 0},
          "fill": {"value": "steelblue"}
        },
        "hover": { "fill": {"value": "firebrick"} }
      }
    },
    {
      "type": "rect",
      "from": {"data": "points"},
      "encode": {
        "enter": {
          "x": {"scale": "xscale", "field": "u"},
          "width": {"value": 1},
          "y": {"value": 25, "offset": {"signal": "height"}},
          "height": {"value": 5},
          "fill": {"value": "steelblue"},
          "fillOpacity": {"value": 0.4}
        }
      }
    }
  ]
}\n"https://vega.github.io/schema/vega/v5.json"\n"An interactive histogram for visualizing a univariate distribution."\n"data/normal-2d.json"\n"binStep > 0.02 ? -0.5 : 0"\n\n\nVega
            
              Vega-Lite
              Altair
              Vega-Lite API
            
          
          
            
              Examples
              Tutorials
              Documentation
              Usage
              About
            
            
              GitHub
              Try Online
            
          
        
      

      
        

  
  
    Histogram Null Values Example
    This example demonstrates a histogram over a numerical range, with a segment to show the prevalence of null values.




  
  View Source
  Export PNG
  Export SVG






  View in Online Vega Editor


Vega JSON Specification <>

{
  "$schema": "https://vega.github.io/schema/vega/v5.json",
  "description": "A histogram of film ratings, modified to include null values.",
  "width": 400,
  "height": 200,
  "padding": 5,
  "autosize": {"type": "fit", "resize": true},

  "signals": [
    {
      "name": "maxbins", "value": 10,
      "bind": {"input": "select", "options": [5, 10, 20]}
    },
    {
      "name": "binCount",
      "update": "(bins.stop - bins.start) / bins.step"
    },
    {
      "name": "nullGap", "value": 10
    },
    {
      "name": "barStep",
      "update": "(width - nullGap) / (1 + binCount)"
    }
  ],

  "data": [
    {
      "name": "table",
      "url": "data/movies.json",
      "transform": [
        {
          "type": "extent", "field": "IMDB Rating",
          "signal": "extent"
        },
        {
          "type": "bin", "signal": "bins",
          "field": "IMDB Rating", "extent": {"signal": "extent"},
          "maxbins": {"signal": "maxbins"}
        }
      ]
    },
    {
      "name": "counts",
      "source": "table",
      "transform": [
        {
          "type": "filter",
          "expr": "datum['IMDB Rating'] != null"
        },
        {
          "type": "aggregate",
          "groupby": ["bin0", "bin1"]
        }
      ]
    },
    {
      "name": "nulls",
      "source": "table",
      "transform": [
        {
          "type": "filter",
          "expr": "datum['IMDB Rating'] == null"
        },
        {
          "type": "aggregate"
        }
      ]
    }
  ],

  "scales": [
    {
      "name": "yscale",
      "type": "linear",
      "range": "height",
      "round": true, "nice": true,
      "domain": {
        "fields": [
          {"data": "counts", "field": "count"},
          {"data": "nulls", "field": "count"}
        ]
      }
    },
    {
      "name": "xscale",
      "type": "linear",
      "range": [{"signal": "barStep + nullGap"}, {"signal": "width"}],
      "round": true,
      "domain": {"signal": "[bins.start, bins.stop]"},
      "bins": {"signal": "bins"}
    },
    {
      "name": "xscale-null",
      "type": "band",
      "range": [0, {"signal": "barStep"}],
      "round": true,
      "domain": [null]
    }
  ],

  "axes": [
    {"orient": "bottom", "scale": "xscale", "tickMinStep": 0.5},
    {"orient": "bottom", "scale": "xscale-null"},
    {"orient": "left", "scale": "yscale", "tickCount": 5, "offset": 5}
  ],

  "marks": [
    {
      "type": "rect",
      "from": {"data": "counts"},
      "encode": {
        "update": {
          "x": {"scale": "xscale", "field": "bin0", "offset": 1},
          "x2": {"scale": "xscale", "field": "bin1"},
          "y": {"scale": "yscale", "field": "count"},
          "y2": {"scale": "yscale", "value": 0},
          "fill": {"value": "steelblue"}
        },
        "hover": {
          "fill": {"value": "firebrick"}
        }
      }
    },
    {
      "type": "rect",
      "from": {"data": "nulls"},
      "encode": {
        "update": {
          "x": {"scale": "xscale-null", "value": null, "offset": 1},
          "x2": {"scale": "xscale-null", "band": 1},
          "y": {"scale": "yscale", "field": "count"},
          "y2": {"scale": "yscale", "value": 0},
          "fill": {"value": "#aaa"}
        },
        "hover": {
          "fill": {"value": "firebrick"}
        }
      }
    }
  ]
}\nVega
            
              Vega-Lite
              Altair
              Vega-Lite API\nVega-Lite
              Altair
              Vega-Lite API\nExamples
              Tutorials
              Documentation
              Usage
              About
            
            
              GitHub
              Try Online\nExamples
              Tutorials
              Documentation
              Usage
              About\nGitHub
              Try Online\nHistogram Null Values Example
    This example demonstrates a histogram over a numerical range, with a segment to show the prevalence of null values.




  
  View Source
  Export PNG
  Export SVG






  View in Online Vega Editor


Vega JSON Specification <>

{
  "$schema": "https://vega.github.io/schema/vega/v5.json",
  "description": "A histogram of film ratings, modified to include null values.",
  "width": 400,
  "height": 200,
  "padding": 5,
  "autosize": {"type": "fit", "resize": true},

  "signals": [
    {
      "name": "maxbins", "value": 10,
      "bind": {"input": "select", "options": [5, 10, 20]}
    },
    {
      "name": "binCount",
      "update": "(bins.stop - bins.start) / bins.step"
    },
    {
      "name": "nullGap", "value": 10
    },
    {
      "name": "barStep",
      "update": "(width - nullGap) / (1 + binCount)"
    }
  ],

  "data": [
    {
      "name": "table",
      "url": "data/movies.json",
      "transform": [
        {
          "type": "extent", "field": "IMDB Rating",
          "signal": "extent"
        },
        {
          "type": "bin", "signal": "bins",
          "field": "IMDB Rating", "extent": {"signal": "extent"},
          "maxbins": {"signal": "maxbins"}
        }
      ]
    },
    {
      "name": "counts",
      "source": "table",
      "transform": [
        {
          "type": "filter",
          "expr": "datum['IMDB Rating'] != null"
        },
        {
          "type": "aggregate",
          "groupby": ["bin0", "bin1"]
        }
      ]
    },
    {
      "name": "nulls",
      "source": "table",
      "transform": [
        {
          "type": "filter",
          "expr": "datum['IMDB Rating'] == null"
        },
        {
          "type": "aggregate"
        }
      ]
    }
  ],

  "scales": [
    {
      "name": "yscale",
      "type": "linear",
      "range": "height",
      "round": true, "nice": true,
      "domain": {
        "fields": [
          {"data": "counts", "field": "count"},
          {"data": "nulls", "field": "count"}
        ]
      }
    },
    {
      "name": "xscale",
      "type": "linear",
      "range": [{"signal": "barStep + nullGap"}, {"signal": "width"}],
      "round": true,
      "domain": {"signal": "[bins.start, bins.stop]"},
      "bins": {"signal": "bins"}
    },
    {
      "name": "xscale-null",
      "type": "band",
      "range": [0, {"signal": "barStep"}],
      "round": true,
      "domain": [null]
    }
  ],

  "axes": [
    {"orient": "bottom", "scale": "xscale", "tickMinStep": 0.5},
    {"orient": "bottom", "scale": "xscale-null"},
    {"orient": "left", "scale": "yscale", "tickCount": 5, "offset": 5}
  ],

  "marks": [
    {
      "type": "rect",
      "from": {"data": "counts"},
      "encode": {
        "update": {
          "x": {"scale": "xscale", "field": "bin0", "offset": 1},
          "x2": {"scale": "xscale", "field": "bin1"},
          "y": {"scale": "yscale", "field": "count"},
          "y2": {"scale": "yscale", "value": 0},
          "fill": {"value": "steelblue"}
        },
        "hover": {
          "fill": {"value": "firebrick"}
        }
      }
    },
    {
      "type": "rect",
      "from": {"data": "nulls"},
      "encode": {
        "update": {
          "x": {"scale": "xscale-null", "value": null, "offset": 1},
          "x2": {"scale": "xscale-null", "band": 1},
          "y": {"scale": "yscale", "field": "count"},
          "y2": {"scale": "yscale", "value": 0},
          "fill": {"value": "#aaa"}
        },
        "hover": {
          "fill": {"value": "firebrick"}
        }
      }
    }
  ]
}\nHistogram Null Values Example\nThis example demonstrates a histogram over a numerical range, with a segment to show the prevalence of null values.\nView Source
  Export PNG
  Export SVG\nView Source
  Export PNG
  Export SVG\nView in Online Vega Editor\nView in Online Vega Editor\nVega JSON Specification <>\n{
  "$schema": "https://vega.github.io/schema/vega/v5.json",
  "description": "A histogram of film ratings, modified to include null values.",
  "width": 400,
  "height": 200,
  "padding": 5,
  "autosize": {"type": "fit", "resize": true},

  "signals": [
    {
      "name": "maxbins", "value": 10,
      "bind": {"input": "select", "options": [5, 10, 20]}
    },
    {
      "name": "binCount",
      "update": "(bins.stop - bins.start) / bins.step"
    },
    {
      "name": "nullGap", "value": 10
    },
    {
      "name": "barStep",
      "update": "(width - nullGap) / (1 + binCount)"
    }
  ],

  "data": [
    {
      "name": "table",
      "url": "data/movies.json",
      "transform": [
        {
          "type": "extent", "field": "IMDB Rating",
          "signal": "extent"
        },
        {
          "type": "bin", "signal": "bins",
          "field": "IMDB Rating", "extent": {"signal": "extent"},
          "maxbins": {"signal": "maxbins"}
        }
      ]
    },
    {
      "name": "counts",
      "source": "table",
      "transform": [
        {
          "type": "filter",
          "expr": "datum['IMDB Rating'] != null"
        },
        {
          "type": "aggregate",
          "groupby": ["bin0", "bin1"]
        }
      ]
    },
    {
      "name": "nulls",
      "source": "table",
      "transform": [
        {
          "type": "filter",
          "expr": "datum['IMDB Rating'] == null"
        },
        {
          "type": "aggregate"
        }
      ]
    }
  ],

  "scales": [
    {
      "name": "yscale",
      "type": "linear",
      "range": "height",
      "round": true, "nice": true,
      "domain": {
        "fields": [
          {"data": "counts", "field": "count"},
          {"data": "nulls", "field": "count"}
        ]
      }
    },
    {
      "name": "xscale",
      "type": "linear",
      "range": [{"signal": "barStep + nullGap"}, {"signal": "width"}],
      "round": true,
      "domain": {"signal": "[bins.start, bins.stop]"},
      "bins": {"signal": "bins"}
    },
    {
      "name": "xscale-null",
      "type": "band",
      "range": [0, {"signal": "barStep"}],
      "round": true,
      "domain": [null]
    }
  ],

  "axes": [
    {"orient": "bottom", "scale": "xscale", "tickMinStep": 0.5},
    {"orient": "bottom", "scale": "xscale-null"},
    {"orient": "left", "scale": "yscale", "tickCount": 5, "offset": 5}
  ],

  "marks": [
    {
      "type": "rect",
      "from": {"data": "counts"},
      "encode": {
        "update": {
          "x": {"scale": "xscale", "field": "bin0", "offset": 1},
          "x2": {"scale": "xscale", "field": "bin1"},
          "y": {"scale": "yscale", "field": "count"},
          "y2": {"scale": "yscale", "value": 0},
          "fill": {"value": "steelblue"}
        },
        "hover": {
          "fill": {"value": "firebrick"}
        }
      }
    },
    {
      "type": "rect",
      "from": {"data": "nulls"},
      "encode": {
        "update": {
          "x": {"scale": "xscale-null", "value": null, "offset": 1},
          "x2": {"scale": "xscale-null", "band": 1},
          "y": {"scale": "yscale", "field": "count"},
          "y2": {"scale": "yscale", "value": 0},
          "fill": {"value": "#aaa"}
        },
        "hover": {
          "fill": {"value": "firebrick"}
        }
      }
    }
  ]
}\n{
  "$schema": "https://vega.github.io/schema/vega/v5.json",
  "description": "A histogram of film ratings, modified to include null values.",
  "width": 400,
  "height": 200,
  "padding": 5,
  "autosize": {"type": "fit", "resize": true},

  "signals": [
    {
      "name": "maxbins", "value": 10,
      "bind": {"input": "select", "options": [5, 10, 20]}
    },
    {
      "name": "binCount",
      "update": "(bins.stop - bins.start) / bins.step"
    },
    {
      "name": "nullGap", "value": 10
    },
    {
      "name": "barStep",
      "update": "(width - nullGap) / (1 + binCount)"
    }
  ],

  "data": [
    {
      "name": "table",
      "url": "data/movies.json",
      "transform": [
        {
          "type": "extent", "field": "IMDB Rating",
          "signal": "extent"
        },
        {
          "type": "bin", "signal": "bins",
          "field": "IMDB Rating", "extent": {"signal": "extent"},
          "maxbins": {"signal": "maxbins"}
        }
      ]
    },
    {
      "name": "counts",
      "source": "table",
      "transform": [
        {
          "type": "filter",
          "expr": "datum['IMDB Rating'] != null"
        },
        {
          "type": "aggregate",
          "groupby": ["bin0", "bin1"]
        }
      ]
    },
    {
      "name": "nulls",
      "source": "table",
      "transform": [
        {
          "type": "filter",
          "expr": "datum['IMDB Rating'] == null"
        },
        {
          "type": "aggregate"
        }
      ]
    }
  ],

  "scales": [
    {
      "name": "yscale",
      "type": "linear",
      "range": "height",
      "round": true, "nice": true,
      "domain": {
        "fields": [
          {"data": "counts", "field": "count"},
          {"data": "nulls", "field": "count"}
        ]
      }
    },
    {
      "name": "xscale",
      "type": "linear",
      "range": [{"signal": "barStep + nullGap"}, {"signal": "width"}],
      "round": true,
      "domain": {"signal": "[bins.start, bins.stop]"},
      "bins": {"signal": "bins"}
    },
    {
      "name": "xscale-null",
      "type": "band",
      "range": [0, {"signal": "barStep"}],
      "round": true,
      "domain": [null]
    }
  ],

  "axes": [
    {"orient": "bottom", "scale": "xscale", "tickMinStep": 0.5},
    {"orient": "bottom", "scale": "xscale-null"},
    {"orient": "left", "scale": "yscale", "tickCount": 5, "offset": 5}
  ],

  "marks": [
    {
      "type": "rect",
      "from": {"data": "counts"},
      "encode": {
        "update": {
          "x": {"scale": "xscale", "field": "bin0", "offset": 1},
          "x2": {"scale": "xscale", "field": "bin1"},
          "y": {"scale": "yscale", "field": "count"},
          "y2": {"scale": "yscale", "value": 0},
          "fill": {"value": "steelblue"}
        },
        "hover": {
          "fill": {"value": "firebrick"}
        }
      }
    },
    {
      "type": "rect",
      "from": {"data": "nulls"},
      "encode": {
        "update": {
          "x": {"scale": "xscale-null", "value": null, "offset": 1},
          "x2": {"scale": "xscale-null", "band": 1},
          "y": {"scale": "yscale", "field": "count"},
          "y2": {"scale": "yscale", "value": 0},
          "fill": {"value": "#aaa"}
        },
        "hover": {
          "fill": {"value": "firebrick"}
        }
      }
    }
  ]
}\n"https://vega.github.io/schema/vega/v5.json"\n"A histogram of film ratings, modified to include null values."\n"(bins.stop - bins.start) / bins.step"\n"(width - nullGap) / (1 + binCount)"\n"datum['IMDB Rating'] != null"\n"datum['IMDB Rating'] == null"\n"[bins.start, bins.stop]"\n\n\nVega
            
              Vega-Lite
              Altair
              Vega-Lite API
            
          
          
            
              Examples
              Tutorials
              Documentation
              Usage
              About
            
            
              GitHub
              Try Online
            
          
        
      

      
        

  
  
    Dot Plot Example
    A dot plot visualizes a univariate distribution by showing each value as a dot and stacking dots that overlap. Dot positions may be determined using standard histogram binning or with a “dot density” estimator that tries to place dots close to their true values.

The example below includes both a density dot plot and a histogram dot plot, showing the hours of slow-wave (non-dreaming) sleep per day among 48 animals (from Allison & Cicchetti, 1976). The dot size is meaningful along both the x- and y-axes, and the dot area and y-axis scale are calculated according to the underlying bin step size (dot diameter). Depending on the dot plot type, either a dotbin or bin transform is used to determine the x-axis positions, followed by a stack transform to calculate the y-axis positions.




  
  View Source
  Export PNG
  Export SVG






  View in Online Vega Editor


Vega JSON Specification <>

{
  "$schema": "https://vega.github.io/schema/vega/v5.json",
  "description": "A dot plot example depicting the distribution of animal sleep times.",
  "width": 300,
  "padding": 5,

  "signals": [
    {
      "name": "step", "value": 0.65,
      "bind": {"input": "range", "min": 0.1, "max": 2, "step": 0.01}
    },
    {
      "name": "offset", "value": "zero",
      "bind": {"input": "radio", "options": ["zero", "center"]}
    },
    {
      "name": "smooth", "value": true,
      "bind": {"input": "checkbox"}
    },
    {"name": "size", "update": "scale('x', step) - scale('x', 0)"},
    {"name": "area", "update": "size * size"},
    {"name": "ddh", "update": "(span(ddext) + 1) * size"},
    {"name": "hdh", "update": "(span(hdext) + 1) * size"},
    {"name": "height", "update": "max(ddh, hdh)"}
  ],

  "data": [
    {
      "name": "points",
      "values": [
        6.3, 2.1, 9.1, 15.8, 5.2, 10.9, 8.3, 11.0, 3.2, 7.6, 6.3, 8.6, 6.6,
        9.5, 4.8, 12.0, 3.3, 11.0, 4.7, 10.4, 7.4, 2.1, 7.7, 17.9, 6.1, 8.2,
        8.4, 11.9, 10.8, 13.8, 14.3, 15.2, 10.0, 11.9, 6.5, 7.5, 10.6, 7.4,
        8.4, 5.7, 4.9, 3.2, 8.1, 11.0, 4.9, 13.2, 9.7, 12.8
      ],
      "transform": [
        {
          "type": "dotbin",
          "field": "data",
          "smooth": {"signal": "smooth"},
          "step": {"signal": "step"}
        },
        {
          "type": "stack",
          "groupby": ["bin"],
          "offset": {"signal": "offset"},
          "as": ["d0", "d1"]
        },
        {
          "type": "extent",
          "field": "d1",
          "signal": "ddext"
        },
        {
          "type": "extent",
          "field": "data",
          "signal": "ext"
        },
        {
          "type": "bin",
          "field": "data",
          "step": {"signal": "step"},
          "extent": {"signal": "ext"}
        },
        {
          "type": "stack",
          "offset": {"signal": "offset"},
          "groupby": ["bin0"]
        },
        {
          "type": "extent",
          "field": "y0",
          "signal": "hdext"
        }
      ]
    }
  ],

  "scales": [
    {
      "name": "x",
      "domain": [0, 20],
      "range": "width"
    },
    {
      "name": "ddy",
      "domain": {"signal": "[0, ddh / size]"},
      "range": {"signal": "[height, height - ddh]"}
    },
    {
      "name": "hdy",
      "domain": {"signal": "[0, hdh / size]"},
      "range": {"signal": "[height, height - hdh]"}
    }
  ],

  "marks": [
    {
      "type": "group",
      "encode": {
        "update": {
          "width": {"signal": "width"},
          "height": {"signal": "height"}
        }
      },
      "axes": [
        {"scale": "x", "orient": "bottom", "tickCount": 5, "title": "Density Dot Plot"}
      ],
      "marks": [
        {
          "type": "symbol",
          "from": {"data": "points"},
          "encode": {
            "update": {
              "x": {"scale": "x", "field": "bin"},
              "y": {"scale": "ddy", "signal": "datum.d0 + 0.5"},
              "size": {"signal": "area"},
              "fill": {"value": "steelblue"}
            }
          }
        }
      ]
    },
    {
      "type": "group",
      "encode": {
        "update": {
          "x": {"signal": "width + 10"},
          "width": {"signal": "width"},
          "height": {"signal": "height"}
        }
      },
      "axes": [
        {"scale": "x", "orient": "bottom", "tickCount": 5, "title": "Histogram Dot Plot"}
      ],
      "marks": [
        {
          "type": "symbol",
          "from": {"data": "points"},
          "encode": {
            "update": {
              "x": {"scale": "x", "signal": "(datum.bin0 + datum.bin1) / 2"},
              "y": {"scale": "hdy", "signal": "datum.y0 + 0.5"},
              "size": {"signal": "area"},
              "fill": {"value": "steelblue"}
            }
          }
        }
      ]
    }
  ]
}\nVega
            
              Vega-Lite
              Altair
              Vega-Lite API\nVega-Lite
              Altair
              Vega-Lite API\nExamples
              Tutorials
              Documentation
              Usage
              About
            
            
              GitHub
              Try Online\nExamples
              Tutorials
              Documentation
              Usage
              About\nGitHub
              Try Online\nDot Plot Example
    A dot plot visualizes a univariate distribution by showing each value as a dot and stacking dots that overlap. Dot positions may be determined using standard histogram binning or with a “dot density” estimator that tries to place dots close to their true values.

The example below includes both a density dot plot and a histogram dot plot, showing the hours of slow-wave (non-dreaming) sleep per day among 48 animals (from Allison & Cicchetti, 1976). The dot size is meaningful along both the x- and y-axes, and the dot area and y-axis scale are calculated according to the underlying bin step size (dot diameter). Depending on the dot plot type, either a dotbin or bin transform is used to determine the x-axis positions, followed by a stack transform to calculate the y-axis positions.




  
  View Source
  Export PNG
  Export SVG






  View in Online Vega Editor


Vega JSON Specification <>

{
  "$schema": "https://vega.github.io/schema/vega/v5.json",
  "description": "A dot plot example depicting the distribution of animal sleep times.",
  "width": 300,
  "padding": 5,

  "signals": [
    {
      "name": "step", "value": 0.65,
      "bind": {"input": "range", "min": 0.1, "max": 2, "step": 0.01}
    },
    {
      "name": "offset", "value": "zero",
      "bind": {"input": "radio", "options": ["zero", "center"]}
    },
    {
      "name": "smooth", "value": true,
      "bind": {"input": "checkbox"}
    },
    {"name": "size", "update": "scale('x', step) - scale('x', 0)"},
    {"name": "area", "update": "size * size"},
    {"name": "ddh", "update": "(span(ddext) + 1) * size"},
    {"name": "hdh", "update": "(span(hdext) + 1) * size"},
    {"name": "height", "update": "max(ddh, hdh)"}
  ],

  "data": [
    {
      "name": "points",
      "values": [
        6.3, 2.1, 9.1, 15.8, 5.2, 10.9, 8.3, 11.0, 3.2, 7.6, 6.3, 8.6, 6.6,
        9.5, 4.8, 12.0, 3.3, 11.0, 4.7, 10.4, 7.4, 2.1, 7.7, 17.9, 6.1, 8.2,
        8.4, 11.9, 10.8, 13.8, 14.3, 15.2, 10.0, 11.9, 6.5, 7.5, 10.6, 7.4,
        8.4, 5.7, 4.9, 3.2, 8.1, 11.0, 4.9, 13.2, 9.7, 12.8
      ],
      "transform": [
        {
          "type": "dotbin",
          "field": "data",
          "smooth": {"signal": "smooth"},
          "step": {"signal": "step"}
        },
        {
          "type": "stack",
          "groupby": ["bin"],
          "offset": {"signal": "offset"},
          "as": ["d0", "d1"]
        },
        {
          "type": "extent",
          "field": "d1",
          "signal": "ddext"
        },
        {
          "type": "extent",
          "field": "data",
          "signal": "ext"
        },
        {
          "type": "bin",
          "field": "data",
          "step": {"signal": "step"},
          "extent": {"signal": "ext"}
        },
        {
          "type": "stack",
          "offset": {"signal": "offset"},
          "groupby": ["bin0"]
        },
        {
          "type": "extent",
          "field": "y0",
          "signal": "hdext"
        }
      ]
    }
  ],

  "scales": [
    {
      "name": "x",
      "domain": [0, 20],
      "range": "width"
    },
    {
      "name": "ddy",
      "domain": {"signal": "[0, ddh / size]"},
      "range": {"signal": "[height, height - ddh]"}
    },
    {
      "name": "hdy",
      "domain": {"signal": "[0, hdh / size]"},
      "range": {"signal": "[height, height - hdh]"}
    }
  ],

  "marks": [
    {
      "type": "group",
      "encode": {
        "update": {
          "width": {"signal": "width"},
          "height": {"signal": "height"}
        }
      },
      "axes": [
        {"scale": "x", "orient": "bottom", "tickCount": 5, "title": "Density Dot Plot"}
      ],
      "marks": [
        {
          "type": "symbol",
          "from": {"data": "points"},
          "encode": {
            "update": {
              "x": {"scale": "x", "field": "bin"},
              "y": {"scale": "ddy", "signal": "datum.d0 + 0.5"},
              "size": {"signal": "area"},
              "fill": {"value": "steelblue"}
            }
          }
        }
      ]
    },
    {
      "type": "group",
      "encode": {
        "update": {
          "x": {"signal": "width + 10"},
          "width": {"signal": "width"},
          "height": {"signal": "height"}
        }
      },
      "axes": [
        {"scale": "x", "orient": "bottom", "tickCount": 5, "title": "Histogram Dot Plot"}
      ],
      "marks": [
        {
          "type": "symbol",
          "from": {"data": "points"},
          "encode": {
            "update": {
              "x": {"scale": "x", "signal": "(datum.bin0 + datum.bin1) / 2"},
              "y": {"scale": "hdy", "signal": "datum.y0 + 0.5"},
              "size": {"signal": "area"},
              "fill": {"value": "steelblue"}
            }
          }
        }
      ]
    }
  ]
}\nA dot plot visualizes a univariate distribution by showing each value as a dot and stacking dots that overlap. Dot positions may be determined using standard histogram binning or with a “dot density” estimator that tries to place dots close to their true values.\n“dot density” estimator\nThe example below includes both a density dot plot and a histogram dot plot, showing the hours of slow-wave (non-dreaming) sleep per day among 48 animals (from Allison & Cicchetti, 1976). The dot size is meaningful along both the x- and y-axes, and the dot area and y-axis scale are calculated according to the underlying bin step size (dot diameter). Depending on the dot plot type, either a dotbin or bin transform is used to determine the x-axis positions, followed by a stack transform to calculate the y-axis positions.\nAllison & Cicchetti, 1976\nView Source
  Export PNG
  Export SVG\nView Source
  Export PNG
  Export SVG\nView in Online Vega Editor\nView in Online Vega Editor\nVega JSON Specification <>\n{
  "$schema": "https://vega.github.io/schema/vega/v5.json",
  "description": "A dot plot example depicting the distribution of animal sleep times.",
  "width": 300,
  "padding": 5,

  "signals": [
    {
      "name": "step", "value": 0.65,
      "bind": {"input": "range", "min": 0.1, "max": 2, "step": 0.01}
    },
    {
      "name": "offset", "value": "zero",
      "bind": {"input": "radio", "options": ["zero", "center"]}
    },
    {
      "name": "smooth", "value": true,
      "bind": {"input": "checkbox"}
    },
    {"name": "size", "update": "scale('x', step) - scale('x', 0)"},
    {"name": "area", "update": "size * size"},
    {"name": "ddh", "update": "(span(ddext) + 1) * size"},
    {"name": "hdh", "update": "(span(hdext) + 1) * size"},
    {"name": "height", "update": "max(ddh, hdh)"}
  ],

  "data": [
    {
      "name": "points",
      "values": [
        6.3, 2.1, 9.1, 15.8, 5.2, 10.9, 8.3, 11.0, 3.2, 7.6, 6.3, 8.6, 6.6,
        9.5, 4.8, 12.0, 3.3, 11.0, 4.7, 10.4, 7.4, 2.1, 7.7, 17.9, 6.1, 8.2,
        8.4, 11.9, 10.8, 13.8, 14.3, 15.2, 10.0, 11.9, 6.5, 7.5, 10.6, 7.4,
        8.4, 5.7, 4.9, 3.2, 8.1, 11.0, 4.9, 13.2, 9.7, 12.8
      ],
      "transform": [
        {
          "type": "dotbin",
          "field": "data",
          "smooth": {"signal": "smooth"},
          "step": {"signal": "step"}
        },
        {
          "type": "stack",
          "groupby": ["bin"],
          "offset": {"signal": "offset"},
          "as": ["d0", "d1"]
        },
        {
          "type": "extent",
          "field": "d1",
          "signal": "ddext"
        },
        {
          "type": "extent",
          "field": "data",
          "signal": "ext"
        },
        {
          "type": "bin",
          "field": "data",
          "step": {"signal": "step"},
          "extent": {"signal": "ext"}
        },
        {
          "type": "stack",
          "offset": {"signal": "offset"},
          "groupby": ["bin0"]
        },
        {
          "type": "extent",
          "field": "y0",
          "signal": "hdext"
        }
      ]
    }
  ],

  "scales": [
    {
      "name": "x",
      "domain": [0, 20],
      "range": "width"
    },
    {
      "name": "ddy",
      "domain": {"signal": "[0, ddh / size]"},
      "range": {"signal": "[height, height - ddh]"}
    },
    {
      "name": "hdy",
      "domain": {"signal": "[0, hdh / size]"},
      "range": {"signal": "[height, height - hdh]"}
    }
  ],

  "marks": [
    {
      "type": "group",
      "encode": {
        "update": {
          "width": {"signal": "width"},
          "height": {"signal": "height"}
        }
      },
      "axes": [
        {"scale": "x", "orient": "bottom", "tickCount": 5, "title": "Density Dot Plot"}
      ],
      "marks": [
        {
          "type": "symbol",
          "from": {"data": "points"},
          "encode": {
            "update": {
              "x": {"scale": "x", "field": "bin"},
              "y": {"scale": "ddy", "signal": "datum.d0 + 0.5"},
              "size": {"signal": "area"},
              "fill": {"value": "steelblue"}
            }
          }
        }
      ]
    },
    {
      "type": "group",
      "encode": {
        "update": {
          "x": {"signal": "width + 10"},
          "width": {"signal": "width"},
          "height": {"signal": "height"}
        }
      },
      "axes": [
        {"scale": "x", "orient": "bottom", "tickCount": 5, "title": "Histogram Dot Plot"}
      ],
      "marks": [
        {
          "type": "symbol",
          "from": {"data": "points"},
          "encode": {
            "update": {
              "x": {"scale": "x", "signal": "(datum.bin0 + datum.bin1) / 2"},
              "y": {"scale": "hdy", "signal": "datum.y0 + 0.5"},
              "size": {"signal": "area"},
              "fill": {"value": "steelblue"}
            }
          }
        }
      ]
    }
  ]
}\n{
  "$schema": "https://vega.github.io/schema/vega/v5.json",
  "description": "A dot plot example depicting the distribution of animal sleep times.",
  "width": 300,
  "padding": 5,

  "signals": [
    {
      "name": "step", "value": 0.65,
      "bind": {"input": "range", "min": 0.1, "max": 2, "step": 0.01}
    },
    {
      "name": "offset", "value": "zero",
      "bind": {"input": "radio", "options": ["zero", "center"]}
    },
    {
      "name": "smooth", "value": true,
      "bind": {"input": "checkbox"}
    },
    {"name": "size", "update": "scale('x', step) - scale('x', 0)"},
    {"name": "area", "update": "size * size"},
    {"name": "ddh", "update": "(span(ddext) + 1) * size"},
    {"name": "hdh", "update": "(span(hdext) + 1) * size"},
    {"name": "height", "update": "max(ddh, hdh)"}
  ],

  "data": [
    {
      "name": "points",
      "values": [
        6.3, 2.1, 9.1, 15.8, 5.2, 10.9, 8.3, 11.0, 3.2, 7.6, 6.3, 8.6, 6.6,
        9.5, 4.8, 12.0, 3.3, 11.0, 4.7, 10.4, 7.4, 2.1, 7.7, 17.9, 6.1, 8.2,
        8.4, 11.9, 10.8, 13.8, 14.3, 15.2, 10.0, 11.9, 6.5, 7.5, 10.6, 7.4,
        8.4, 5.7, 4.9, 3.2, 8.1, 11.0, 4.9, 13.2, 9.7, 12.8
      ],
      "transform": [
        {
          "type": "dotbin",
          "field": "data",
          "smooth": {"signal": "smooth"},
          "step": {"signal": "step"}
        },
        {
          "type": "stack",
          "groupby": ["bin"],
          "offset": {"signal": "offset"},
          "as": ["d0", "d1"]
        },
        {
          "type": "extent",
          "field": "d1",
          "signal": "ddext"
        },
        {
          "type": "extent",
          "field": "data",
          "signal": "ext"
        },
        {
          "type": "bin",
          "field": "data",
          "step": {"signal": "step"},
          "extent": {"signal": "ext"}
        },
        {
          "type": "stack",
          "offset": {"signal": "offset"},
          "groupby": ["bin0"]
        },
        {
          "type": "extent",
          "field": "y0",
          "signal": "hdext"
        }
      ]
    }
  ],

  "scales": [
    {
      "name": "x",
      "domain": [0, 20],
      "range": "width"
    },
    {
      "name": "ddy",
      "domain": {"signal": "[0, ddh / size]"},
      "range": {"signal": "[height, height - ddh]"}
    },
    {
      "name": "hdy",
      "domain": {"signal": "[0, hdh / size]"},
      "range": {"signal": "[height, height - hdh]"}
    }
  ],

  "marks": [
    {
      "type": "group",
      "encode": {
        "update": {
          "width": {"signal": "width"},
          "height": {"signal": "height"}
        }
      },
      "axes": [
        {"scale": "x", "orient": "bottom", "tickCount": 5, "title": "Density Dot Plot"}
      ],
      "marks": [
        {
          "type": "symbol",
          "from": {"data": "points"},
          "encode": {
            "update": {
              "x": {"scale": "x", "field": "bin"},
              "y": {"scale": "ddy", "signal": "datum.d0 + 0.5"},
              "size": {"signal": "area"},
              "fill": {"value": "steelblue"}
            }
          }
        }
      ]
    },
    {
      "type": "group",
      "encode": {
        "update": {
          "x": {"signal": "width + 10"},
          "width": {"signal": "width"},
          "height": {"signal": "height"}
        }
      },
      "axes": [
        {"scale": "x", "orient": "bottom", "tickCount": 5, "title": "Histogram Dot Plot"}
      ],
      "marks": [
        {
          "type": "symbol",
          "from": {"data": "points"},
          "encode": {
            "update": {
              "x": {"scale": "x", "signal": "(datum.bin0 + datum.bin1) / 2"},
              "y": {"scale": "hdy", "signal": "datum.y0 + 0.5"},
              "size": {"signal": "area"},
              "fill": {"value": "steelblue"}
            }
          }
        }
      ]
    }
  ]
}\n"https://vega.github.io/schema/vega/v5.json"\n"A dot plot example depicting the distribution of animal sleep times."\n"scale('x', step) - scale('x', 0)"\n"(span(ddext) + 1) * size"\n"(span(hdext) + 1) * size"\n"[height, height - ddh]"\n"[height, height - hdh]"\n"(datum.bin0 + datum.bin1) / 2"\n\n\nVega
            
              Vega-Lite
              Altair
              Vega-Lite API
            
          
          
            
              Examples
              Tutorials
              Documentation
              Usage
              About
            
            
              GitHub
              Try Online
            
          
        
      

      
        

  
  
    Probability Density Example
    Visual comparison of estimated probability distributions for a sample of numeric values: a normal (Gaussian) distribution parameterized by the mean and standard deviation, and a kernel density estimate. This example supports estimates of either probability density functions (pdf) or cumulative distribution functions (cdf), using Vega’s density transform.




  
  View Source
  Export PNG
  Export SVG






  View in Online Vega Editor


Vega JSON Specification <>

{
  "$schema": "https://vega.github.io/schema/vega/v5.json",
  "description": "Area chart using density estimation to show a probability density or cumulative distribution.",
  "width": 500,
  "height": 100,
  "padding": 5,

  "signals": [
    { "name": "bandwidth", "value": 0,
      "bind": {"input": "range", "min": 0, "max": 0.1, "step": 0.001} },
    { "name": "method", "value": "pdf",
      "bind": {"input": "radio", "options": ["pdf", "cdf"]} }
  ],

  "data": [
    {
      "name": "points",
      "url": "data/normal-2d.json"
    },
    {
      "name": "summary",
      "source": "points",
      "transform": [
        {
          "type": "aggregate",
          "fields": ["u", "u"],
          "ops": ["mean", "stdev"],
          "as": ["mean", "stdev"]
        }
      ]
    },
    {
      "name": "density",
      "source": "points",
      "transform": [
        {
          "type": "density",
          "extent": {"signal": "domain('xscale')"},
          "method": {"signal": "method"},
          "distribution": {
            "function": "kde",
            "field": "u",
            "bandwidth": {"signal": "bandwidth"}
          }
        }
      ]
    },
    {
      "name": "normal",
      "transform": [
        {
          "type": "density",
          "extent": {"signal": "domain('xscale')"},
          "method": {"signal": "method"},
          "distribution": {
            "function": "normal",
            "mean": {"signal": "data('summary')[0].mean"},
            "stdev": {"signal": "data('summary')[0].stdev"}
          }
        }
      ]
    }
  ],

  "scales": [
    {
      "name": "xscale",
      "type": "linear",
      "range": "width",
      "domain": {"data": "points", "field": "u"},
      "nice": true
    },
    {
      "name": "yscale",
      "type": "linear",
      "range": "height", "round": true,
      "domain": {
        "fields": [
          {"data": "density", "field": "density"},
          {"data": "normal", "field": "density"}
        ]
      }
    },
    {
      "name": "color",
      "type": "ordinal",
      "domain": ["Normal Estimate", "Kernel Density Estimate"],
      "range": ["#444", "steelblue"]
    }
  ],

  "axes": [
    {"orient": "bottom", "scale": "xscale", "zindex": 1}
  ],

  "legends": [
    {"orient": "top-left", "fill": "color", "offset": 0, "zindex": 1}
  ],

  "marks": [
    {
      "type": "area",
      "from": {"data": "density"},
      "encode": {
        "update": {
          "x": {"scale": "xscale", "field": "value"},
          "y": {"scale": "yscale", "field": "density"},
          "y2": {"scale": "yscale", "value": 0},
          "fill": {"signal": "scale('color', 'Kernel Density Estimate')"}
        }
      }
    },
    {
      "type": "line",
      "from": {"data": "normal"},
      "encode": {
        "update": {
          "x": {"scale": "xscale", "field": "value"},
          "y": {"scale": "yscale", "field": "density"},
          "stroke": {"signal": "scale('color', 'Normal Estimate')"},
          "strokeWidth": {"value": 2}
        }
      }
    },
    {
      "type": "rect",
      "from": {"data": "points"},
      "encode": {
        "enter": {
          "x": {"scale": "xscale", "field": "u"},
          "width": {"value": 1},
          "y": {"value": 25, "offset": {"signal": "height"}},
          "height": {"value": 5},
          "fill": {"value": "steelblue"},
          "fillOpacity": {"value": 0.4}
        }
      }
    }
  ]
}\nVega
            
              Vega-Lite
              Altair
              Vega-Lite API\nVega-Lite
              Altair
              Vega-Lite API\nExamples
              Tutorials
              Documentation
              Usage
              About
            
            
              GitHub
              Try Online\nExamples
              Tutorials
              Documentation
              Usage
              About\nGitHub
              Try Online\nProbability Density Example
    Visual comparison of estimated probability distributions for a sample of numeric values: a normal (Gaussian) distribution parameterized by the mean and standard deviation, and a kernel density estimate. This example supports estimates of either probability density functions (pdf) or cumulative distribution functions (cdf), using Vega’s density transform.




  
  View Source
  Export PNG
  Export SVG






  View in Online Vega Editor


Vega JSON Specification <>

{
  "$schema": "https://vega.github.io/schema/vega/v5.json",
  "description": "Area chart using density estimation to show a probability density or cumulative distribution.",
  "width": 500,
  "height": 100,
  "padding": 5,

  "signals": [
    { "name": "bandwidth", "value": 0,
      "bind": {"input": "range", "min": 0, "max": 0.1, "step": 0.001} },
    { "name": "method", "value": "pdf",
      "bind": {"input": "radio", "options": ["pdf", "cdf"]} }
  ],

  "data": [
    {
      "name": "points",
      "url": "data/normal-2d.json"
    },
    {
      "name": "summary",
      "source": "points",
      "transform": [
        {
          "type": "aggregate",
          "fields": ["u", "u"],
          "ops": ["mean", "stdev"],
          "as": ["mean", "stdev"]
        }
      ]
    },
    {
      "name": "density",
      "source": "points",
      "transform": [
        {
          "type": "density",
          "extent": {"signal": "domain('xscale')"},
          "method": {"signal": "method"},
          "distribution": {
            "function": "kde",
            "field": "u",
            "bandwidth": {"signal": "bandwidth"}
          }
        }
      ]
    },
    {
      "name": "normal",
      "transform": [
        {
          "type": "density",
          "extent": {"signal": "domain('xscale')"},
          "method": {"signal": "method"},
          "distribution": {
            "function": "normal",
            "mean": {"signal": "data('summary')[0].mean"},
            "stdev": {"signal": "data('summary')[0].stdev"}
          }
        }
      ]
    }
  ],

  "scales": [
    {
      "name": "xscale",
      "type": "linear",
      "range": "width",
      "domain": {"data": "points", "field": "u"},
      "nice": true
    },
    {
      "name": "yscale",
      "type": "linear",
      "range": "height", "round": true,
      "domain": {
        "fields": [
          {"data": "density", "field": "density"},
          {"data": "normal", "field": "density"}
        ]
      }
    },
    {
      "name": "color",
      "type": "ordinal",
      "domain": ["Normal Estimate", "Kernel Density Estimate"],
      "range": ["#444", "steelblue"]
    }
  ],

  "axes": [
    {"orient": "bottom", "scale": "xscale", "zindex": 1}
  ],

  "legends": [
    {"orient": "top-left", "fill": "color", "offset": 0, "zindex": 1}
  ],

  "marks": [
    {
      "type": "area",
      "from": {"data": "density"},
      "encode": {
        "update": {
          "x": {"scale": "xscale", "field": "value"},
          "y": {"scale": "yscale", "field": "density"},
          "y2": {"scale": "yscale", "value": 0},
          "fill": {"signal": "scale('color', 'Kernel Density Estimate')"}
        }
      }
    },
    {
      "type": "line",
      "from": {"data": "normal"},
      "encode": {
        "update": {
          "x": {"scale": "xscale", "field": "value"},
          "y": {"scale": "yscale", "field": "density"},
          "stroke": {"signal": "scale('color', 'Normal Estimate')"},
          "strokeWidth": {"value": 2}
        }
      }
    },
    {
      "type": "rect",
      "from": {"data": "points"},
      "encode": {
        "enter": {
          "x": {"scale": "xscale", "field": "u"},
          "width": {"value": 1},
          "y": {"value": 25, "offset": {"signal": "height"}},
          "height": {"value": 5},
          "fill": {"value": "steelblue"},
          "fillOpacity": {"value": 0.4}
        }
      }
    }
  ]
}\nProbability Density Example\nVisual comparison of estimated probability distributions for a sample of numeric values: a normal (Gaussian) distribution parameterized by the mean and standard deviation, and a kernel density estimate. This example supports estimates of either probability density functions (pdf) or cumulative distribution functions (cdf), using Vega’s density transform.\nkernel density estimate\nprobability density functions (pdf)\ncumulative distribution functions (cdf)\nView Source
  Export PNG
  Export SVG\nView Source
  Export PNG
  Export SVG\nView in Online Vega Editor\nView in Online Vega Editor\nVega JSON Specification <>\n{
  "$schema": "https://vega.github.io/schema/vega/v5.json",
  "description": "Area chart using density estimation to show a probability density or cumulative distribution.",
  "width": 500,
  "height": 100,
  "padding": 5,

  "signals": [
    { "name": "bandwidth", "value": 0,
      "bind": {"input": "range", "min": 0, "max": 0.1, "step": 0.001} },
    { "name": "method", "value": "pdf",
      "bind": {"input": "radio", "options": ["pdf", "cdf"]} }
  ],

  "data": [
    {
      "name": "points",
      "url": "data/normal-2d.json"
    },
    {
      "name": "summary",
      "source": "points",
      "transform": [
        {
          "type": "aggregate",
          "fields": ["u", "u"],
          "ops": ["mean", "stdev"],
          "as": ["mean", "stdev"]
        }
      ]
    },
    {
      "name": "density",
      "source": "points",
      "transform": [
        {
          "type": "density",
          "extent": {"signal": "domain('xscale')"},
          "method": {"signal": "method"},
          "distribution": {
            "function": "kde",
            "field": "u",
            "bandwidth": {"signal": "bandwidth"}
          }
        }
      ]
    },
    {
      "name": "normal",
      "transform": [
        {
          "type": "density",
          "extent": {"signal": "domain('xscale')"},
          "method": {"signal": "method"},
          "distribution": {
            "function": "normal",
            "mean": {"signal": "data('summary')[0].mean"},
            "stdev": {"signal": "data('summary')[0].stdev"}
          }
        }
      ]
    }
  ],

  "scales": [
    {
      "name": "xscale",
      "type": "linear",
      "range": "width",
      "domain": {"data": "points", "field": "u"},
      "nice": true
    },
    {
      "name": "yscale",
      "type": "linear",
      "range": "height", "round": true,
      "domain": {
        "fields": [
          {"data": "density", "field": "density"},
          {"data": "normal", "field": "density"}
        ]
      }
    },
    {
      "name": "color",
      "type": "ordinal",
      "domain": ["Normal Estimate", "Kernel Density Estimate"],
      "range": ["#444", "steelblue"]
    }
  ],

  "axes": [
    {"orient": "bottom", "scale": "xscale", "zindex": 1}
  ],

  "legends": [
    {"orient": "top-left", "fill": "color", "offset": 0, "zindex": 1}
  ],

  "marks": [
    {
      "type": "area",
      "from": {"data": "density"},
      "encode": {
        "update": {
          "x": {"scale": "xscale", "field": "value"},
          "y": {"scale": "yscale", "field": "density"},
          "y2": {"scale": "yscale", "value": 0},
          "fill": {"signal": "scale('color', 'Kernel Density Estimate')"}
        }
      }
    },
    {
      "type": "line",
      "from": {"data": "normal"},
      "encode": {
        "update": {
          "x": {"scale": "xscale", "field": "value"},
          "y": {"scale": "yscale", "field": "density"},
          "stroke": {"signal": "scale('color', 'Normal Estimate')"},
          "strokeWidth": {"value": 2}
        }
      }
    },
    {
      "type": "rect",
      "from": {"data": "points"},
      "encode": {
        "enter": {
          "x": {"scale": "xscale", "field": "u"},
          "width": {"value": 1},
          "y": {"value": 25, "offset": {"signal": "height"}},
          "height": {"value": 5},
          "fill": {"value": "steelblue"},
          "fillOpacity": {"value": 0.4}
        }
      }
    }
  ]
}\n{
  "$schema": "https://vega.github.io/schema/vega/v5.json",
  "description": "Area chart using density estimation to show a probability density or cumulative distribution.",
  "width": 500,
  "height": 100,
  "padding": 5,

  "signals": [
    { "name": "bandwidth", "value": 0,
      "bind": {"input": "range", "min": 0, "max": 0.1, "step": 0.001} },
    { "name": "method", "value": "pdf",
      "bind": {"input": "radio", "options": ["pdf", "cdf"]} }
  ],

  "data": [
    {
      "name": "points",
      "url": "data/normal-2d.json"
    },
    {
      "name": "summary",
      "source": "points",
      "transform": [
        {
          "type": "aggregate",
          "fields": ["u", "u"],
          "ops": ["mean", "stdev"],
          "as": ["mean", "stdev"]
        }
      ]
    },
    {
      "name": "density",
      "source": "points",
      "transform": [
        {
          "type": "density",
          "extent": {"signal": "domain('xscale')"},
          "method": {"signal": "method"},
          "distribution": {
            "function": "kde",
            "field": "u",
            "bandwidth": {"signal": "bandwidth"}
          }
        }
      ]
    },
    {
      "name": "normal",
      "transform": [
        {
          "type": "density",
          "extent": {"signal": "domain('xscale')"},
          "method": {"signal": "method"},
          "distribution": {
            "function": "normal",
            "mean": {"signal": "data('summary')[0].mean"},
            "stdev": {"signal": "data('summary')[0].stdev"}
          }
        }
      ]
    }
  ],

  "scales": [
    {
      "name": "xscale",
      "type": "linear",
      "range": "width",
      "domain": {"data": "points", "field": "u"},
      "nice": true
    },
    {
      "name": "yscale",
      "type": "linear",
      "range": "height", "round": true,
      "domain": {
        "fields": [
          {"data": "density", "field": "density"},
          {"data": "normal", "field": "density"}
        ]
      }
    },
    {
      "name": "color",
      "type": "ordinal",
      "domain": ["Normal Estimate", "Kernel Density Estimate"],
      "range": ["#444", "steelblue"]
    }
  ],

  "axes": [
    {"orient": "bottom", "scale": "xscale", "zindex": 1}
  ],

  "legends": [
    {"orient": "top-left", "fill": "color", "offset": 0, "zindex": 1}
  ],

  "marks": [
    {
      "type": "area",
      "from": {"data": "density"},
      "encode": {
        "update": {
          "x": {"scale": "xscale", "field": "value"},
          "y": {"scale": "yscale", "field": "density"},
          "y2": {"scale": "yscale", "value": 0},
          "fill": {"signal": "scale('color', 'Kernel Density Estimate')"}
        }
      }
    },
    {
      "type": "line",
      "from": {"data": "normal"},
      "encode": {
        "update": {
          "x": {"scale": "xscale", "field": "value"},
          "y": {"scale": "yscale", "field": "density"},
          "stroke": {"signal": "scale('color', 'Normal Estimate')"},
          "strokeWidth": {"value": 2}
        }
      }
    },
    {
      "type": "rect",
      "from": {"data": "points"},
      "encode": {
        "enter": {
          "x": {"scale": "xscale", "field": "u"},
          "width": {"value": 1},
          "y": {"value": 25, "offset": {"signal": "height"}},
          "height": {"value": 5},
          "fill": {"value": "steelblue"},
          "fillOpacity": {"value": 0.4}
        }
      }
    }
  ]
}\n"https://vega.github.io/schema/vega/v5.json"\n"Area chart using density estimation to show a probability density or cumulative distribution."\n"data/normal-2d.json"\n"data('summary')[0].mean"\n"data('summary')[0].stdev"\n"Kernel Density Estimate"\n"scale('color', 'Kernel Density Estimate')"\n"scale('color', 'Normal Estimate')"\n\n\nVega
            
              Vega-Lite
              Altair
              Vega-Lite API
            
          
          
            
              Examples
              Tutorials
              Documentation
              Usage
              About
            
            
              GitHub
              Try Online
            
          
        
      

      
        

  
  
    Box Plot Example
    A box plot summarizes a distribution of quantitative values using a set of summary statistics. Here, the boxes show the interquartile range (IQR), with the white bar indicating the median value. The thin lines (“whiskers”) currently show the extent of the minimum and maximum values; other values, such as whiskers extending 1.5 * IQR from each end of the box, are often used as well. See the violin plot example for an alternative approach.




  
  View Source
  Export PNG
  Export SVG






  View in Online Vega Editor


Vega JSON Specification <>

{
  "$schema": "https://vega.github.io/schema/vega/v5.json",
  "description": "A box plot example showing aggregate statistics for penguin body mass.",
  "width": 500,
  "padding": 5,

  "config": {
    "axisBand": {
      "bandPosition": 1,
      "tickExtra": true,
      "tickOffset": 0
    }
  },

  "signals": [
    { "name": "plotWidth", "value": 60 },
    { "name": "height", "update": "(plotWidth + 10) * 3"}
  ],

  "data": [
    {
      "name": "penguins",
      "url": "data/penguins.json",
      "transform": [
        {
          "type": "filter",
          "expr": "datum.Species != null && datum['Body Mass (g)'] != null"
        }
      ]
    }
  ],

  "scales": [
    {
      "name": "layout",
      "type": "band",
      "range": "height",
      "domain": {"data": "penguins", "field": "Species"}
    },
    {
      "name": "xscale",
      "type": "linear",
      "range": "width", "round": true,
      "domain": {"data": "penguins", "field": "Body Mass (g)"},
      "domainMin": 2000,
      "zero": false, "nice": true
    }
  ],

  "axes": [
    {"orient": "bottom", "scale": "xscale", "zindex": 1},
    {"orient": "left", "scale": "layout", "tickCount": 5, "zindex": 1}
  ],

  "marks": [
    {
      "type": "group",
      "from": {
        "facet": {
          "data": "penguins",
          "name": "species",
          "groupby": "Species"
        }
      },

      "encode": {
        "enter": {
          "yc": {"scale": "layout", "field": "Species", "band": 0.5},
          "height": {"signal": "plotWidth"},
          "width": {"signal": "width"}
        }
      },

      "data": [
        {
          "name": "summary",
          "source": "species",
          "transform": [
            {
              "type": "aggregate",
              "fields": ["Body Mass (g)", "Body Mass (g)", "Body Mass (g)", "Body Mass (g)", "Body Mass (g)"],
              "ops": ["min", "q1", "median", "q3", "max"],
              "as": ["min", "q1", "median", "q3", "max"]
            }
          ]
        }
      ],

      "marks": [
        {
          "type": "rect",
          "from": {"data": "summary"},
          "encode": {
            "enter": {
              "fill": {"value": "black"},
              "height": {"value": 1}
            },
            "update": {
              "yc": {"signal": "plotWidth / 2", "offset": -0.5},
              "x": {"scale": "xscale", "field": "min"},
              "x2": {"scale": "xscale", "field": "max"}
            }
          }
        },
        {
          "type": "rect",
          "from": {"data": "summary"},
          "encode": {
            "enter": {
              "fill": {"value": "steelblue"},
              "cornerRadius": {"value": 4}
            },
            "update": {
              "yc": {"signal": "plotWidth / 2"},
              "height": {"signal": "plotWidth / 2"},
              "x": {"scale": "xscale", "field": "q1"},
              "x2": {"scale": "xscale", "field": "q3"}
            }
          }
        },
        {
          "type": "rect",
          "from": {"data": "summary"},
          "encode": {
            "enter": {
              "fill": {"value": "aliceblue"},
              "width": {"value": 2}
            },
            "update": {
              "yc": {"signal": "plotWidth / 2"},
              "height": {"signal": "plotWidth / 2"},
              "x": {"scale": "xscale", "field": "median"}
            }
          }
        }
      ]
    }
  ]
}\nVega
            
              Vega-Lite
              Altair
              Vega-Lite API\nVega-Lite
              Altair
              Vega-Lite API\nExamples
              Tutorials
              Documentation
              Usage
              About
            
            
              GitHub
              Try Online\nExamples
              Tutorials
              Documentation
              Usage
              About\nGitHub
              Try Online\nBox Plot Example
    A box plot summarizes a distribution of quantitative values using a set of summary statistics. Here, the boxes show the interquartile range (IQR), with the white bar indicating the median value. The thin lines (“whiskers”) currently show the extent of the minimum and maximum values; other values, such as whiskers extending 1.5 * IQR from each end of the box, are often used as well. See the violin plot example for an alternative approach.




  
  View Source
  Export PNG
  Export SVG






  View in Online Vega Editor


Vega JSON Specification <>

{
  "$schema": "https://vega.github.io/schema/vega/v5.json",
  "description": "A box plot example showing aggregate statistics for penguin body mass.",
  "width": 500,
  "padding": 5,

  "config": {
    "axisBand": {
      "bandPosition": 1,
      "tickExtra": true,
      "tickOffset": 0
    }
  },

  "signals": [
    { "name": "plotWidth", "value": 60 },
    { "name": "height", "update": "(plotWidth + 10) * 3"}
  ],

  "data": [
    {
      "name": "penguins",
      "url": "data/penguins.json",
      "transform": [
        {
          "type": "filter",
          "expr": "datum.Species != null && datum['Body Mass (g)'] != null"
        }
      ]
    }
  ],

  "scales": [
    {
      "name": "layout",
      "type": "band",
      "range": "height",
      "domain": {"data": "penguins", "field": "Species"}
    },
    {
      "name": "xscale",
      "type": "linear",
      "range": "width", "round": true,
      "domain": {"data": "penguins", "field": "Body Mass (g)"},
      "domainMin": 2000,
      "zero": false, "nice": true
    }
  ],

  "axes": [
    {"orient": "bottom", "scale": "xscale", "zindex": 1},
    {"orient": "left", "scale": "layout", "tickCount": 5, "zindex": 1}
  ],

  "marks": [
    {
      "type": "group",
      "from": {
        "facet": {
          "data": "penguins",
          "name": "species",
          "groupby": "Species"
        }
      },

      "encode": {
        "enter": {
          "yc": {"scale": "layout", "field": "Species", "band": 0.5},
          "height": {"signal": "plotWidth"},
          "width": {"signal": "width"}
        }
      },

      "data": [
        {
          "name": "summary",
          "source": "species",
          "transform": [
            {
              "type": "aggregate",
              "fields": ["Body Mass (g)", "Body Mass (g)", "Body Mass (g)", "Body Mass (g)", "Body Mass (g)"],
              "ops": ["min", "q1", "median", "q3", "max"],
              "as": ["min", "q1", "median", "q3", "max"]
            }
          ]
        }
      ],

      "marks": [
        {
          "type": "rect",
          "from": {"data": "summary"},
          "encode": {
            "enter": {
              "fill": {"value": "black"},
              "height": {"value": 1}
            },
            "update": {
              "yc": {"signal": "plotWidth / 2", "offset": -0.5},
              "x": {"scale": "xscale", "field": "min"},
              "x2": {"scale": "xscale", "field": "max"}
            }
          }
        },
        {
          "type": "rect",
          "from": {"data": "summary"},
          "encode": {
            "enter": {
              "fill": {"value": "steelblue"},
              "cornerRadius": {"value": 4}
            },
            "update": {
              "yc": {"signal": "plotWidth / 2"},
              "height": {"signal": "plotWidth / 2"},
              "x": {"scale": "xscale", "field": "q1"},
              "x2": {"scale": "xscale", "field": "q3"}
            }
          }
        },
        {
          "type": "rect",
          "from": {"data": "summary"},
          "encode": {
            "enter": {
              "fill": {"value": "aliceblue"},
              "width": {"value": 2}
            },
            "update": {
              "yc": {"signal": "plotWidth / 2"},
              "height": {"signal": "plotWidth / 2"},
              "x": {"scale": "xscale", "field": "median"}
            }
          }
        }
      ]
    }
  ]
}\nA box plot summarizes a distribution of quantitative values using a set of summary statistics. Here, the boxes show the interquartile range (IQR), with the white bar indicating the median value. The thin lines (“whiskers”) currently show the extent of the minimum and maximum values; other values, such as whiskers extending 1.5 * IQR from each end of the box, are often used as well. See the violin plot example for an alternative approach.\ninterquartile range (IQR)\nView Source
  Export PNG
  Export SVG\nView Source
  Export PNG
  Export SVG\nView in Online Vega Editor\nView in Online Vega Editor\nVega JSON Specification <>\n{
  "$schema": "https://vega.github.io/schema/vega/v5.json",
  "description": "A box plot example showing aggregate statistics for penguin body mass.",
  "width": 500,
  "padding": 5,

  "config": {
    "axisBand": {
      "bandPosition": 1,
      "tickExtra": true,
      "tickOffset": 0
    }
  },

  "signals": [
    { "name": "plotWidth", "value": 60 },
    { "name": "height", "update": "(plotWidth + 10) * 3"}
  ],

  "data": [
    {
      "name": "penguins",
      "url": "data/penguins.json",
      "transform": [
        {
          "type": "filter",
          "expr": "datum.Species != null && datum['Body Mass (g)'] != null"
        }
      ]
    }
  ],

  "scales": [
    {
      "name": "layout",
      "type": "band",
      "range": "height",
      "domain": {"data": "penguins", "field": "Species"}
    },
    {
      "name": "xscale",
      "type": "linear",
      "range": "width", "round": true,
      "domain": {"data": "penguins", "field": "Body Mass (g)"},
      "domainMin": 2000,
      "zero": false, "nice": true
    }
  ],

  "axes": [
    {"orient": "bottom", "scale": "xscale", "zindex": 1},
    {"orient": "left", "scale": "layout", "tickCount": 5, "zindex": 1}
  ],

  "marks": [
    {
      "type": "group",
      "from": {
        "facet": {
          "data": "penguins",
          "name": "species",
          "groupby": "Species"
        }
      },

      "encode": {
        "enter": {
          "yc": {"scale": "layout", "field": "Species", "band": 0.5},
          "height": {"signal": "plotWidth"},
          "width": {"signal": "width"}
        }
      },

      "data": [
        {
          "name": "summary",
          "source": "species",
          "transform": [
            {
              "type": "aggregate",
              "fields": ["Body Mass (g)", "Body Mass (g)", "Body Mass (g)", "Body Mass (g)", "Body Mass (g)"],
              "ops": ["min", "q1", "median", "q3", "max"],
              "as": ["min", "q1", "median", "q3", "max"]
            }
          ]
        }
      ],

      "marks": [
        {
          "type": "rect",
          "from": {"data": "summary"},
          "encode": {
            "enter": {
              "fill": {"value": "black"},
              "height": {"value": 1}
            },
            "update": {
              "yc": {"signal": "plotWidth / 2", "offset": -0.5},
              "x": {"scale": "xscale", "field": "min"},
              "x2": {"scale": "xscale", "field": "max"}
            }
          }
        },
        {
          "type": "rect",
          "from": {"data": "summary"},
          "encode": {
            "enter": {
              "fill": {"value": "steelblue"},
              "cornerRadius": {"value": 4}
            },
            "update": {
              "yc": {"signal": "plotWidth / 2"},
              "height": {"signal": "plotWidth / 2"},
              "x": {"scale": "xscale", "field": "q1"},
              "x2": {"scale": "xscale", "field": "q3"}
            }
          }
        },
        {
          "type": "rect",
          "from": {"data": "summary"},
          "encode": {
            "enter": {
              "fill": {"value": "aliceblue"},
              "width": {"value": 2}
            },
            "update": {
              "yc": {"signal": "plotWidth / 2"},
              "height": {"signal": "plotWidth / 2"},
              "x": {"scale": "xscale", "field": "median"}
            }
          }
        }
      ]
    }
  ]
}\n{
  "$schema": "https://vega.github.io/schema/vega/v5.json",
  "description": "A box plot example showing aggregate statistics for penguin body mass.",
  "width": 500,
  "padding": 5,

  "config": {
    "axisBand": {
      "bandPosition": 1,
      "tickExtra": true,
      "tickOffset": 0
    }
  },

  "signals": [
    { "name": "plotWidth", "value": 60 },
    { "name": "height", "update": "(plotWidth + 10) * 3"}
  ],

  "data": [
    {
      "name": "penguins",
      "url": "data/penguins.json",
      "transform": [
        {
          "type": "filter",
          "expr": "datum.Species != null && datum['Body Mass (g)'] != null"
        }
      ]
    }
  ],

  "scales": [
    {
      "name": "layout",
      "type": "band",
      "range": "height",
      "domain": {"data": "penguins", "field": "Species"}
    },
    {
      "name": "xscale",
      "type": "linear",
      "range": "width", "round": true,
      "domain": {"data": "penguins", "field": "Body Mass (g)"},
      "domainMin": 2000,
      "zero": false, "nice": true
    }
  ],

  "axes": [
    {"orient": "bottom", "scale": "xscale", "zindex": 1},
    {"orient": "left", "scale": "layout", "tickCount": 5, "zindex": 1}
  ],

  "marks": [
    {
      "type": "group",
      "from": {
        "facet": {
          "data": "penguins",
          "name": "species",
          "groupby": "Species"
        }
      },

      "encode": {
        "enter": {
          "yc": {"scale": "layout", "field": "Species", "band": 0.5},
          "height": {"signal": "plotWidth"},
          "width": {"signal": "width"}
        }
      },

      "data": [
        {
          "name": "summary",
          "source": "species",
          "transform": [
            {
              "type": "aggregate",
              "fields": ["Body Mass (g)", "Body Mass (g)", "Body Mass (g)", "Body Mass (g)", "Body Mass (g)"],
              "ops": ["min", "q1", "median", "q3", "max"],
              "as": ["min", "q1", "median", "q3", "max"]
            }
          ]
        }
      ],

      "marks": [
        {
          "type": "rect",
          "from": {"data": "summary"},
          "encode": {
            "enter": {
              "fill": {"value": "black"},
              "height": {"value": 1}
            },
            "update": {
              "yc": {"signal": "plotWidth / 2", "offset": -0.5},
              "x": {"scale": "xscale", "field": "min"},
              "x2": {"scale": "xscale", "field": "max"}
            }
          }
        },
        {
          "type": "rect",
          "from": {"data": "summary"},
          "encode": {
            "enter": {
              "fill": {"value": "steelblue"},
              "cornerRadius": {"value": 4}
            },
            "update": {
              "yc": {"signal": "plotWidth / 2"},
              "height": {"signal": "plotWidth / 2"},
              "x": {"scale": "xscale", "field": "q1"},
              "x2": {"scale": "xscale", "field": "q3"}
            }
          }
        },
        {
          "type": "rect",
          "from": {"data": "summary"},
          "encode": {
            "enter": {
              "fill": {"value": "aliceblue"},
              "width": {"value": 2}
            },
            "update": {
              "yc": {"signal": "plotWidth / 2"},
              "height": {"signal": "plotWidth / 2"},
              "x": {"scale": "xscale", "field": "median"}
            }
          }
        }
      ]
    }
  ]
}\n"https://vega.github.io/schema/vega/v5.json"\n"A box plot example showing aggregate statistics for penguin body mass."\n"(plotWidth + 10) * 3"\n"datum.Species != null && datum['Body Mass (g)'] != null"\n\n\nVega
            
              Vega-Lite
              Altair
              Vega-Lite API
            
          
          
            
              Examples
              Tutorials
              Documentation
              Usage
              About
            
            
              GitHub
              Try Online
            
          
        
      

      
        

  
  
    Violin Plot Example
    A violin plot visualizes a distribution of quantitative values as a continuous approximation of the probability density function, computed using kernel density estimation (KDE). The densities are additionally annotated with the median value and interquartile range, shown as black lines. Violin plots can be more informative than classical box plots.




  
  View Source
  Export PNG
  Export SVG






  View in Online Vega Editor


Vega JSON Specification <>

{
  "$schema": "https://vega.github.io/schema/vega/v5.json",
  "description": "A violin plot example showing distributions for pengiun body mass.",
  "width": 500,
  "padding": 5,

  "config": {
    "axisBand": {
      "bandPosition": 1,
      "tickExtra": true,
      "tickOffset": 0
    }
  },

  "signals": [
    { "name": "plotWidth", "value": 60 },
    { "name": "height", "update": "(plotWidth + 10) * 3"},
    { "name": "trim", "value": true,
      "bind": {"input": "checkbox"} },
    { "name": "bandwidth", "value": 0,
      "bind": {"input": "range", "min": 0, "max": 200, "step": 1} }
  ],

  "data": [
    {
      "name": "penguins",
      "url": "data/penguins.json",
      "transform": [
        {
          "type": "filter",
          "expr": "datum.Species != null && datum['Body Mass (g)'] != null"
        }
      ]
    },
    {
      "name": "density",
      "source": "penguins",
      "transform": [
        {
          "type": "kde",
          "field": "Body Mass (g)",
          "groupby": ["Species"],
          "bandwidth": {"signal": "bandwidth"},
          "extent": {"signal": "trim ? null : [2000, 6500]"}
        }
      ]
    },
    {
      "name": "stats",
      "source": "penguins",
      "transform": [
        {
          "type": "aggregate",
          "groupby": ["Species"],
          "fields": ["Body Mass (g)", "Body Mass (g)", "Body Mass (g)"],
          "ops": ["q1", "median", "q3"],
          "as": ["q1", "median", "q3"]
        }
      ]
    }
  ],

  "scales": [
    {
      "name": "layout",
      "type": "band",
      "range": "height",
      "domain": {"data": "penguins", "field": "Species"}
    },
    {
      "name": "xscale",
      "type": "linear",
      "range": "width", "round": true,
      "domain": {"data": "penguins", "field": "Body Mass (g)"},
      "domainMin": 2000,
      "zero": false, "nice": true
    },
    {
      "name": "hscale",
      "type": "linear",
      "range": [0, {"signal": "plotWidth"}],
      "domain": {"data": "density", "field": "density"}
    },
    {
      "name": "color",
      "type": "ordinal",
      "domain": {"data": "penguins", "field": "Species"},
      "range": "category"
    }
  ],

  "axes": [
    {"orient": "bottom", "scale": "xscale", "zindex": 1},
    {"orient": "left", "scale": "layout", "tickCount": 5, "zindex": 1}
  ],

  "marks": [
    {
      "type": "group",
      "from": {
        "facet": {
          "data": "density",
          "name": "violin",
          "groupby": "Species"
        }
      },

      "encode": {
        "enter": {
          "yc": {"scale": "layout", "field": "Species", "band": 0.5},
          "height": {"signal": "plotWidth"},
          "width": {"signal": "width"}
        }
      },

      "data": [
        {
          "name": "summary",
          "source": "stats",
          "transform": [
            {
              "type": "filter",
              "expr": "datum.Species === parent.Species"
            }
          ]
        }
      ],

      "marks": [
        {
          "type": "area",
          "from": {"data": "violin"},
          "encode": {
            "enter": {
              "fill": {"scale": "color", "field": {"parent": "Species"}}
            },
            "update": {
              "x": {"scale": "xscale", "field": "value"},
              "yc": {"signal": "plotWidth / 2"},
              "height": {"scale": "hscale", "field": "density"}
            }
          }
        },
        {
          "type": "rect",
          "from": {"data": "summary"},
          "encode": {
            "enter": {
              "fill": {"value": "black"},
              "height": {"value": 2}
            },
            "update": {
              "x": {"scale": "xscale", "field": "q1"},
              "x2": {"scale": "xscale", "field": "q3"},
              "yc": {"signal": "plotWidth / 2"}
            }
          }
        },
        {
          "type": "rect",
          "from": {"data": "summary"},
          "encode": {
            "enter": {
              "fill": {"value": "black"},
              "width": {"value": 2},
              "height": {"value": 8}
            },
            "update": {
              "x": {"scale": "xscale", "field": "median"},
              "yc": {"signal": "plotWidth / 2"}
            }
          }
        }
      ]
    }
  ]
}\nVega
            
              Vega-Lite
              Altair
              Vega-Lite API\nVega-Lite
              Altair
              Vega-Lite API\nExamples
              Tutorials
              Documentation
              Usage
              About
            
            
              GitHub
              Try Online\nExamples
              Tutorials
              Documentation
              Usage
              About\nGitHub
              Try Online\nViolin Plot Example
    A violin plot visualizes a distribution of quantitative values as a continuous approximation of the probability density function, computed using kernel density estimation (KDE). The densities are additionally annotated with the median value and interquartile range, shown as black lines. Violin plots can be more informative than classical box plots.




  
  View Source
  Export PNG
  Export SVG






  View in Online Vega Editor


Vega JSON Specification <>

{
  "$schema": "https://vega.github.io/schema/vega/v5.json",
  "description": "A violin plot example showing distributions for pengiun body mass.",
  "width": 500,
  "padding": 5,

  "config": {
    "axisBand": {
      "bandPosition": 1,
      "tickExtra": true,
      "tickOffset": 0
    }
  },

  "signals": [
    { "name": "plotWidth", "value": 60 },
    { "name": "height", "update": "(plotWidth + 10) * 3"},
    { "name": "trim", "value": true,
      "bind": {"input": "checkbox"} },
    { "name": "bandwidth", "value": 0,
      "bind": {"input": "range", "min": 0, "max": 200, "step": 1} }
  ],

  "data": [
    {
      "name": "penguins",
      "url": "data/penguins.json",
      "transform": [
        {
          "type": "filter",
          "expr": "datum.Species != null && datum['Body Mass (g)'] != null"
        }
      ]
    },
    {
      "name": "density",
      "source": "penguins",
      "transform": [
        {
          "type": "kde",
          "field": "Body Mass (g)",
          "groupby": ["Species"],
          "bandwidth": {"signal": "bandwidth"},
          "extent": {"signal": "trim ? null : [2000, 6500]"}
        }
      ]
    },
    {
      "name": "stats",
      "source": "penguins",
      "transform": [
        {
          "type": "aggregate",
          "groupby": ["Species"],
          "fields": ["Body Mass (g)", "Body Mass (g)", "Body Mass (g)"],
          "ops": ["q1", "median", "q3"],
          "as": ["q1", "median", "q3"]
        }
      ]
    }
  ],

  "scales": [
    {
      "name": "layout",
      "type": "band",
      "range": "height",
      "domain": {"data": "penguins", "field": "Species"}
    },
    {
      "name": "xscale",
      "type": "linear",
      "range": "width", "round": true,
      "domain": {"data": "penguins", "field": "Body Mass (g)"},
      "domainMin": 2000,
      "zero": false, "nice": true
    },
    {
      "name": "hscale",
      "type": "linear",
      "range": [0, {"signal": "plotWidth"}],
      "domain": {"data": "density", "field": "density"}
    },
    {
      "name": "color",
      "type": "ordinal",
      "domain": {"data": "penguins", "field": "Species"},
      "range": "category"
    }
  ],

  "axes": [
    {"orient": "bottom", "scale": "xscale", "zindex": 1},
    {"orient": "left", "scale": "layout", "tickCount": 5, "zindex": 1}
  ],

  "marks": [
    {
      "type": "group",
      "from": {
        "facet": {
          "data": "density",
          "name": "violin",
          "groupby": "Species"
        }
      },

      "encode": {
        "enter": {
          "yc": {"scale": "layout", "field": "Species", "band": 0.5},
          "height": {"signal": "plotWidth"},
          "width": {"signal": "width"}
        }
      },

      "data": [
        {
          "name": "summary",
          "source": "stats",
          "transform": [
            {
              "type": "filter",
              "expr": "datum.Species === parent.Species"
            }
          ]
        }
      ],

      "marks": [
        {
          "type": "area",
          "from": {"data": "violin"},
          "encode": {
            "enter": {
              "fill": {"scale": "color", "field": {"parent": "Species"}}
            },
            "update": {
              "x": {"scale": "xscale", "field": "value"},
              "yc": {"signal": "plotWidth / 2"},
              "height": {"scale": "hscale", "field": "density"}
            }
          }
        },
        {
          "type": "rect",
          "from": {"data": "summary"},
          "encode": {
            "enter": {
              "fill": {"value": "black"},
              "height": {"value": 2}
            },
            "update": {
              "x": {"scale": "xscale", "field": "q1"},
              "x2": {"scale": "xscale", "field": "q3"},
              "yc": {"signal": "plotWidth / 2"}
            }
          }
        },
        {
          "type": "rect",
          "from": {"data": "summary"},
          "encode": {
            "enter": {
              "fill": {"value": "black"},
              "width": {"value": 2},
              "height": {"value": 8}
            },
            "update": {
              "x": {"scale": "xscale", "field": "median"},
              "yc": {"signal": "plotWidth / 2"}
            }
          }
        }
      ]
    }
  ]
}\nA violin plot visualizes a distribution of quantitative values as a continuous approximation of the probability density function, computed using kernel density estimation (KDE). The densities are additionally annotated with the median value and interquartile range, shown as black lines. Violin plots can be more informative than classical box plots.\nkernel density estimation (KDE)\nView Source
  Export PNG
  Export SVG\nView Source
  Export PNG
  Export SVG\nView in Online Vega Editor\nView in Online Vega Editor\nVega JSON Specification <>\n{
  "$schema": "https://vega.github.io/schema/vega/v5.json",
  "description": "A violin plot example showing distributions for pengiun body mass.",
  "width": 500,
  "padding": 5,

  "config": {
    "axisBand": {
      "bandPosition": 1,
      "tickExtra": true,
      "tickOffset": 0
    }
  },

  "signals": [
    { "name": "plotWidth", "value": 60 },
    { "name": "height", "update": "(plotWidth + 10) * 3"},
    { "name": "trim", "value": true,
      "bind": {"input": "checkbox"} },
    { "name": "bandwidth", "value": 0,
      "bind": {"input": "range", "min": 0, "max": 200, "step": 1} }
  ],

  "data": [
    {
      "name": "penguins",
      "url": "data/penguins.json",
      "transform": [
        {
          "type": "filter",
          "expr": "datum.Species != null && datum['Body Mass (g)'] != null"
        }
      ]
    },
    {
      "name": "density",
      "source": "penguins",
      "transform": [
        {
          "type": "kde",
          "field": "Body Mass (g)",
          "groupby": ["Species"],
          "bandwidth": {"signal": "bandwidth"},
          "extent": {"signal": "trim ? null : [2000, 6500]"}
        }
      ]
    },
    {
      "name": "stats",
      "source": "penguins",
      "transform": [
        {
          "type": "aggregate",
          "groupby": ["Species"],
          "fields": ["Body Mass (g)", "Body Mass (g)", "Body Mass (g)"],
          "ops": ["q1", "median", "q3"],
          "as": ["q1", "median", "q3"]
        }
      ]
    }
  ],

  "scales": [
    {
      "name": "layout",
      "type": "band",
      "range": "height",
      "domain": {"data": "penguins", "field": "Species"}
    },
    {
      "name": "xscale",
      "type": "linear",
      "range": "width", "round": true,
      "domain": {"data": "penguins", "field": "Body Mass (g)"},
      "domainMin": 2000,
      "zero": false, "nice": true
    },
    {
      "name": "hscale",
      "type": "linear",
      "range": [0, {"signal": "plotWidth"}],
      "domain": {"data": "density", "field": "density"}
    },
    {
      "name": "color",
      "type": "ordinal",
      "domain": {"data": "penguins", "field": "Species"},
      "range": "category"
    }
  ],

  "axes": [
    {"orient": "bottom", "scale": "xscale", "zindex": 1},
    {"orient": "left", "scale": "layout", "tickCount": 5, "zindex": 1}
  ],

  "marks": [
    {
      "type": "group",
      "from": {
        "facet": {
          "data": "density",
          "name": "violin",
          "groupby": "Species"
        }
      },

      "encode": {
        "enter": {
          "yc": {"scale": "layout", "field": "Species", "band": 0.5},
          "height": {"signal": "plotWidth"},
          "width": {"signal": "width"}
        }
      },

      "data": [
        {
          "name": "summary",
          "source": "stats",
          "transform": [
            {
              "type": "filter",
              "expr": "datum.Species === parent.Species"
            }
          ]
        }
      ],

      "marks": [
        {
          "type": "area",
          "from": {"data": "violin"},
          "encode": {
            "enter": {
              "fill": {"scale": "color", "field": {"parent": "Species"}}
            },
            "update": {
              "x": {"scale": "xscale", "field": "value"},
              "yc": {"signal": "plotWidth / 2"},
              "height": {"scale": "hscale", "field": "density"}
            }
          }
        },
        {
          "type": "rect",
          "from": {"data": "summary"},
          "encode": {
            "enter": {
              "fill": {"value": "black"},
              "height": {"value": 2}
            },
            "update": {
              "x": {"scale": "xscale", "field": "q1"},
              "x2": {"scale": "xscale", "field": "q3"},
              "yc": {"signal": "plotWidth / 2"}
            }
          }
        },
        {
          "type": "rect",
          "from": {"data": "summary"},
          "encode": {
            "enter": {
              "fill": {"value": "black"},
              "width": {"value": 2},
              "height": {"value": 8}
            },
            "update": {
              "x": {"scale": "xscale", "field": "median"},
              "yc": {"signal": "plotWidth / 2"}
            }
          }
        }
      ]
    }
  ]
}\n{
  "$schema": "https://vega.github.io/schema/vega/v5.json",
  "description": "A violin plot example showing distributions for pengiun body mass.",
  "width": 500,
  "padding": 5,

  "config": {
    "axisBand": {
      "bandPosition": 1,
      "tickExtra": true,
      "tickOffset": 0
    }
  },

  "signals": [
    { "name": "plotWidth", "value": 60 },
    { "name": "height", "update": "(plotWidth + 10) * 3"},
    { "name": "trim", "value": true,
      "bind": {"input": "checkbox"} },
    { "name": "bandwidth", "value": 0,
      "bind": {"input": "range", "min": 0, "max": 200, "step": 1} }
  ],

  "data": [
    {
      "name": "penguins",
      "url": "data/penguins.json",
      "transform": [
        {
          "type": "filter",
          "expr": "datum.Species != null && datum['Body Mass (g)'] != null"
        }
      ]
    },
    {
      "name": "density",
      "source": "penguins",
      "transform": [
        {
          "type": "kde",
          "field": "Body Mass (g)",
          "groupby": ["Species"],
          "bandwidth": {"signal": "bandwidth"},
          "extent": {"signal": "trim ? null : [2000, 6500]"}
        }
      ]
    },
    {
      "name": "stats",
      "source": "penguins",
      "transform": [
        {
          "type": "aggregate",
          "groupby": ["Species"],
          "fields": ["Body Mass (g)", "Body Mass (g)", "Body Mass (g)"],
          "ops": ["q1", "median", "q3"],
          "as": ["q1", "median", "q3"]
        }
      ]
    }
  ],

  "scales": [
    {
      "name": "layout",
      "type": "band",
      "range": "height",
      "domain": {"data": "penguins", "field": "Species"}
    },
    {
      "name": "xscale",
      "type": "linear",
      "range": "width", "round": true,
      "domain": {"data": "penguins", "field": "Body Mass (g)"},
      "domainMin": 2000,
      "zero": false, "nice": true
    },
    {
      "name": "hscale",
      "type": "linear",
      "range": [0, {"signal": "plotWidth"}],
      "domain": {"data": "density", "field": "density"}
    },
    {
      "name": "color",
      "type": "ordinal",
      "domain": {"data": "penguins", "field": "Species"},
      "range": "category"
    }
  ],

  "axes": [
    {"orient": "bottom", "scale": "xscale", "zindex": 1},
    {"orient": "left", "scale": "layout", "tickCount": 5, "zindex": 1}
  ],

  "marks": [
    {
      "type": "group",
      "from": {
        "facet": {
          "data": "density",
          "name": "violin",
          "groupby": "Species"
        }
      },

      "encode": {
        "enter": {
          "yc": {"scale": "layout", "field": "Species", "band": 0.5},
          "height": {"signal": "plotWidth"},
          "width": {"signal": "width"}
        }
      },

      "data": [
        {
          "name": "summary",
          "source": "stats",
          "transform": [
            {
              "type": "filter",
              "expr": "datum.Species === parent.Species"
            }
          ]
        }
      ],

      "marks": [
        {
          "type": "area",
          "from": {"data": "violin"},
          "encode": {
            "enter": {
              "fill": {"scale": "color", "field": {"parent": "Species"}}
            },
            "update": {
              "x": {"scale": "xscale", "field": "value"},
              "yc": {"signal": "plotWidth / 2"},
              "height": {"scale": "hscale", "field": "density"}
            }
          }
        },
        {
          "type": "rect",
          "from": {"data": "summary"},
          "encode": {
            "enter": {
              "fill": {"value": "black"},
              "height": {"value": 2}
            },
            "update": {
              "x": {"scale": "xscale", "field": "q1"},
              "x2": {"scale": "xscale", "field": "q3"},
              "yc": {"signal": "plotWidth / 2"}
            }
          }
        },
        {
          "type": "rect",
          "from": {"data": "summary"},
          "encode": {
            "enter": {
              "fill": {"value": "black"},
              "width": {"value": 2},
              "height": {"value": 8}
            },
            "update": {
              "x": {"scale": "xscale", "field": "median"},
              "yc": {"signal": "plotWidth / 2"}
            }
          }
        }
      ]
    }
  ]
}\n"https://vega.github.io/schema/vega/v5.json"\n"A violin plot example showing distributions for pengiun body mass."\n"(plotWidth + 10) * 3"\n"datum.Species != null && datum['Body Mass (g)'] != null"\n"trim ? null : [2000, 6500]"\n"datum.Species === parent.Species"\n\n\nVega
            
              Vega-Lite
              Altair
              Vega-Lite API
            
          
          
            
              Examples
              Tutorials
              Documentation
              Usage
              About
            
            
              GitHub
              Try Online
            
          
        
      

      
        

  
  
    Binned Scatter Plot Example
    A binned scatter plot is a more scalable alternative to the standard scatter plot. The data points are grouped into bins, and an aggregate statistic is used to summarize each bin. Here we use a circular area encoding to depict the count of records, visualizing the density of data points. For higher bin counts color might instead be used, though with some loss of perceptual comparison accuracy.




  
  View Source
  Export PNG
  Export SVG






  View in Online Vega Editor


Vega JSON Specification <>

{
  "$schema": "https://vega.github.io/schema/vega/v5.json",
  "description": "A binned scatter plot example showing aggregate counts per binned cell.",
  "width": 200,
  "height": 200,
  "padding": 5,
  "autosize": "pad",

  "data": [
    {
      "name": "source",
      "url": "data/cars.json",
      "transform": [
        {
          "type": "filter",
          "expr": "datum['Horsepower'] != null && datum['Miles_per_Gallon'] != null && datum['Acceleration'] != null"
        }
      ]
    },
    {
      "name": "summary",
      "source": "source",
      "transform": [
        {
          "type": "extent", "field": "Horsepower",
          "signal": "hp_extent"
        },
        {
          "type": "bin", "field": "Horsepower", "maxbins": 10,
          "extent": {"signal": "hp_extent"},
          "as": ["hp0", "hp1"]
        },
        {
          "type": "extent", "field": "Miles_per_Gallon",
          "signal": "mpg_extent"
        },
        {
          "type": "bin", "field": "Miles_per_Gallon", "maxbins": 10,
          "extent": {"signal": "mpg_extent"},
          "as": ["mpg0", "mpg1"]
        },
        {
          "type": "aggregate",
          "groupby": ["hp0", "hp1", "mpg0", "mpg1"]
        }
      ]
    }
  ],

  "scales": [
    {
      "name": "x",
      "type": "linear",
      "round": true,
      "nice": true,
      "zero": true,
      "domain": {"data": "source", "field": "Horsepower"},
      "range": "width"
    },
    {
      "name": "y",
      "type": "linear",
      "round": true,
      "nice": true,
      "zero": true,
      "domain": {"data": "source", "field": "Miles_per_Gallon"},
      "range": "height"
    },
    {
      "name": "size",
      "type": "linear",
      "zero": true,
      "domain": {"data": "summary", "field": "count"},
      "range": [0,360]
    }
  ],

  "axes": [
    {
      "scale": "x",
      "grid": true,
      "domain": false,
      "orient": "bottom",
      "tickCount": 5,
      "title": "Horsepower"
    },
    {
      "scale": "y",
      "grid": true,
      "domain": false,
      "orient": "left",
      "titlePadding": 5,
      "title": "Miles_per_Gallon"
    }
  ],

  "legends": [
    {
      "size": "size",
      "title": "Count",
      "format": "s",
      "symbolFillColor": "#4682b4",
      "symbolStrokeColor": "transparent",
      "symbolType": "circle"
    }
  ],

  "marks": [
    {
      "name": "marks",
      "type": "symbol",
      "from": {"data": "summary"},
      "encode": {
        "update": {
          "x": {"scale": "x", "signal": "(datum.hp0 + datum.hp1) / 2"},
          "y": {"scale": "y", "signal": "(datum.mpg0 + datum.mpg1) / 2"},
          "size": {"scale": "size", "field": "count"},
          "shape": {"value": "circle"},
          "fill": {"value": "#4682b4"}
        }
      }
    }
  ]
}\nVega
            
              Vega-Lite
              Altair
              Vega-Lite API\nVega-Lite
              Altair
              Vega-Lite API\nExamples
              Tutorials
              Documentation
              Usage
              About
            
            
              GitHub
              Try Online\nExamples
              Tutorials
              Documentation
              Usage
              About\nGitHub
              Try Online\nBinned Scatter Plot Example
    A binned scatter plot is a more scalable alternative to the standard scatter plot. The data points are grouped into bins, and an aggregate statistic is used to summarize each bin. Here we use a circular area encoding to depict the count of records, visualizing the density of data points. For higher bin counts color might instead be used, though with some loss of perceptual comparison accuracy.




  
  View Source
  Export PNG
  Export SVG






  View in Online Vega Editor


Vega JSON Specification <>

{
  "$schema": "https://vega.github.io/schema/vega/v5.json",
  "description": "A binned scatter plot example showing aggregate counts per binned cell.",
  "width": 200,
  "height": 200,
  "padding": 5,
  "autosize": "pad",

  "data": [
    {
      "name": "source",
      "url": "data/cars.json",
      "transform": [
        {
          "type": "filter",
          "expr": "datum['Horsepower'] != null && datum['Miles_per_Gallon'] != null && datum['Acceleration'] != null"
        }
      ]
    },
    {
      "name": "summary",
      "source": "source",
      "transform": [
        {
          "type": "extent", "field": "Horsepower",
          "signal": "hp_extent"
        },
        {
          "type": "bin", "field": "Horsepower", "maxbins": 10,
          "extent": {"signal": "hp_extent"},
          "as": ["hp0", "hp1"]
        },
        {
          "type": "extent", "field": "Miles_per_Gallon",
          "signal": "mpg_extent"
        },
        {
          "type": "bin", "field": "Miles_per_Gallon", "maxbins": 10,
          "extent": {"signal": "mpg_extent"},
          "as": ["mpg0", "mpg1"]
        },
        {
          "type": "aggregate",
          "groupby": ["hp0", "hp1", "mpg0", "mpg1"]
        }
      ]
    }
  ],

  "scales": [
    {
      "name": "x",
      "type": "linear",
      "round": true,
      "nice": true,
      "zero": true,
      "domain": {"data": "source", "field": "Horsepower"},
      "range": "width"
    },
    {
      "name": "y",
      "type": "linear",
      "round": true,
      "nice": true,
      "zero": true,
      "domain": {"data": "source", "field": "Miles_per_Gallon"},
      "range": "height"
    },
    {
      "name": "size",
      "type": "linear",
      "zero": true,
      "domain": {"data": "summary", "field": "count"},
      "range": [0,360]
    }
  ],

  "axes": [
    {
      "scale": "x",
      "grid": true,
      "domain": false,
      "orient": "bottom",
      "tickCount": 5,
      "title": "Horsepower"
    },
    {
      "scale": "y",
      "grid": true,
      "domain": false,
      "orient": "left",
      "titlePadding": 5,
      "title": "Miles_per_Gallon"
    }
  ],

  "legends": [
    {
      "size": "size",
      "title": "Count",
      "format": "s",
      "symbolFillColor": "#4682b4",
      "symbolStrokeColor": "transparent",
      "symbolType": "circle"
    }
  ],

  "marks": [
    {
      "name": "marks",
      "type": "symbol",
      "from": {"data": "summary"},
      "encode": {
        "update": {
          "x": {"scale": "x", "signal": "(datum.hp0 + datum.hp1) / 2"},
          "y": {"scale": "y", "signal": "(datum.mpg0 + datum.mpg1) / 2"},
          "size": {"scale": "size", "field": "count"},
          "shape": {"value": "circle"},
          "fill": {"value": "#4682b4"}
        }
      }
    }
  ]
}\nBinned Scatter Plot Example\nA binned scatter plot is a more scalable alternative to the standard scatter plot. The data points are grouped into bins, and an aggregate statistic is used to summarize each bin. Here we use a circular area encoding to depict the count of records, visualizing the density of data points. For higher bin counts color might instead be used, though with some loss of perceptual comparison accuracy.\nstandard scatter plot\nView Source
  Export PNG
  Export SVG\nView Source
  Export PNG
  Export SVG\nView in Online Vega Editor\nView in Online Vega Editor\nVega JSON Specification <>\n{
  "$schema": "https://vega.github.io/schema/vega/v5.json",
  "description": "A binned scatter plot example showing aggregate counts per binned cell.",
  "width": 200,
  "height": 200,
  "padding": 5,
  "autosize": "pad",

  "data": [
    {
      "name": "source",
      "url": "data/cars.json",
      "transform": [
        {
          "type": "filter",
          "expr": "datum['Horsepower'] != null && datum['Miles_per_Gallon'] != null && datum['Acceleration'] != null"
        }
      ]
    },
    {
      "name": "summary",
      "source": "source",
      "transform": [
        {
          "type": "extent", "field": "Horsepower",
          "signal": "hp_extent"
        },
        {
          "type": "bin", "field": "Horsepower", "maxbins": 10,
          "extent": {"signal": "hp_extent"},
          "as": ["hp0", "hp1"]
        },
        {
          "type": "extent", "field": "Miles_per_Gallon",
          "signal": "mpg_extent"
        },
        {
          "type": "bin", "field": "Miles_per_Gallon", "maxbins": 10,
          "extent": {"signal": "mpg_extent"},
          "as": ["mpg0", "mpg1"]
        },
        {
          "type": "aggregate",
          "groupby": ["hp0", "hp1", "mpg0", "mpg1"]
        }
      ]
    }
  ],

  "scales": [
    {
      "name": "x",
      "type": "linear",
      "round": true,
      "nice": true,
      "zero": true,
      "domain": {"data": "source", "field": "Horsepower"},
      "range": "width"
    },
    {
      "name": "y",
      "type": "linear",
      "round": true,
      "nice": true,
      "zero": true,
      "domain": {"data": "source", "field": "Miles_per_Gallon"},
      "range": "height"
    },
    {
      "name": "size",
      "type": "linear",
      "zero": true,
      "domain": {"data": "summary", "field": "count"},
      "range": [0,360]
    }
  ],

  "axes": [
    {
      "scale": "x",
      "grid": true,
      "domain": false,
      "orient": "bottom",
      "tickCount": 5,
      "title": "Horsepower"
    },
    {
      "scale": "y",
      "grid": true,
      "domain": false,
      "orient": "left",
      "titlePadding": 5,
      "title": "Miles_per_Gallon"
    }
  ],

  "legends": [
    {
      "size": "size",
      "title": "Count",
      "format": "s",
      "symbolFillColor": "#4682b4",
      "symbolStrokeColor": "transparent",
      "symbolType": "circle"
    }
  ],

  "marks": [
    {
      "name": "marks",
      "type": "symbol",
      "from": {"data": "summary"},
      "encode": {
        "update": {
          "x": {"scale": "x", "signal": "(datum.hp0 + datum.hp1) / 2"},
          "y": {"scale": "y", "signal": "(datum.mpg0 + datum.mpg1) / 2"},
          "size": {"scale": "size", "field": "count"},
          "shape": {"value": "circle"},
          "fill": {"value": "#4682b4"}
        }
      }
    }
  ]
}\n{
  "$schema": "https://vega.github.io/schema/vega/v5.json",
  "description": "A binned scatter plot example showing aggregate counts per binned cell.",
  "width": 200,
  "height": 200,
  "padding": 5,
  "autosize": "pad",

  "data": [
    {
      "name": "source",
      "url": "data/cars.json",
      "transform": [
        {
          "type": "filter",
          "expr": "datum['Horsepower'] != null && datum['Miles_per_Gallon'] != null && datum['Acceleration'] != null"
        }
      ]
    },
    {
      "name": "summary",
      "source": "source",
      "transform": [
        {
          "type": "extent", "field": "Horsepower",
          "signal": "hp_extent"
        },
        {
          "type": "bin", "field": "Horsepower", "maxbins": 10,
          "extent": {"signal": "hp_extent"},
          "as": ["hp0", "hp1"]
        },
        {
          "type": "extent", "field": "Miles_per_Gallon",
          "signal": "mpg_extent"
        },
        {
          "type": "bin", "field": "Miles_per_Gallon", "maxbins": 10,
          "extent": {"signal": "mpg_extent"},
          "as": ["mpg0", "mpg1"]
        },
        {
          "type": "aggregate",
          "groupby": ["hp0", "hp1", "mpg0", "mpg1"]
        }
      ]
    }
  ],

  "scales": [
    {
      "name": "x",
      "type": "linear",
      "round": true,
      "nice": true,
      "zero": true,
      "domain": {"data": "source", "field": "Horsepower"},
      "range": "width"
    },
    {
      "name": "y",
      "type": "linear",
      "round": true,
      "nice": true,
      "zero": true,
      "domain": {"data": "source", "field": "Miles_per_Gallon"},
      "range": "height"
    },
    {
      "name": "size",
      "type": "linear",
      "zero": true,
      "domain": {"data": "summary", "field": "count"},
      "range": [0,360]
    }
  ],

  "axes": [
    {
      "scale": "x",
      "grid": true,
      "domain": false,
      "orient": "bottom",
      "tickCount": 5,
      "title": "Horsepower"
    },
    {
      "scale": "y",
      "grid": true,
      "domain": false,
      "orient": "left",
      "titlePadding": 5,
      "title": "Miles_per_Gallon"
    }
  ],

  "legends": [
    {
      "size": "size",
      "title": "Count",
      "format": "s",
      "symbolFillColor": "#4682b4",
      "symbolStrokeColor": "transparent",
      "symbolType": "circle"
    }
  ],

  "marks": [
    {
      "name": "marks",
      "type": "symbol",
      "from": {"data": "summary"},
      "encode": {
        "update": {
          "x": {"scale": "x", "signal": "(datum.hp0 + datum.hp1) / 2"},
          "y": {"scale": "y", "signal": "(datum.mpg0 + datum.mpg1) / 2"},
          "size": {"scale": "size", "field": "count"},
          "shape": {"value": "circle"},
          "fill": {"value": "#4682b4"}
        }
      }
    }
  ]
}\n"https://vega.github.io/schema/vega/v5.json"\n"A binned scatter plot example showing aggregate counts per binned cell."\n"datum['Horsepower'] != null && datum['Miles_per_Gallon'] != null && datum['Acceleration'] != null"\n"(datum.hp0 + datum.hp1) / 2"\n"(datum.mpg0 + datum.mpg1) / 2"\n\n\nVega
            
              Vega-Lite
              Altair
              Vega-Lite API
            
          
          
            
              Examples
              Tutorials
              Documentation
              Usage
              About
            
            
              GitHub
              Try Online
            
          
        
      

      
        

  
  
    Contour Plot Example
    A contour plot depicts the density of data points as a set of discrete levels. Akin to contour lines on topographic maps, each contour boundary is an isoline of constant density. Kernel density estimation is performed with the kde2d transform to generate a continuous approximation of the sample density for each group. The heatmap transform generates heatmap images to convey these density estimates directly. The isocontour transform analyzes the density estimates to generate level set contours in the form of GeoJSON polygons.




  
  View Source
  Export PNG
  Export SVG






  View in Online Vega Editor


Vega JSON Specification <>

{
  "$schema": "https://vega.github.io/schema/vega/v5.json",
  "description": "A contour plot example, overlaying a density estimate on scatter plot points.",
  "width": 500,
  "height": 400,
  "padding": 5,
  "autosize": "pad",

  "signals": [
    {
      "name": "bandwidth", "value": -1,
      "bind": {"input": "range", "min": -1, "max": 100, "step": 1}
    },
    {
      "name": "resolve", "value": "shared",
      "bind": {"input": "select", "options": ["independent", "shared"]}
    },
    {
      "name": "counts", "value": true,
      "bind": {"input": "checkbox"}
    }
  ],

  "data": [
    {
      "name": "source",
      "url": "data/cars.json",
      "transform": [
        {
          "type": "filter",
          "expr": "datum.Horsepower != null && datum.Miles_per_Gallon != null"
        }
      ]
    },
    {
      "name": "density",
      "source": "source",
      "transform": [
        {
          "type": "kde2d",
          "groupby": ["Origin"],
          "size": [{"signal": "width"}, {"signal": "height"}],
          "x": {"expr": "scale('x', datum.Horsepower)"},
          "y": {"expr": "scale('y', datum.Miles_per_Gallon)"},
          "bandwidth": {"signal": "[bandwidth, bandwidth]"},
          "counts": {"signal": "counts"}
        }
      ]
    },
    {
      "name": "contours",
      "source": "density",
      "transform": [
        {
          "type": "isocontour",
          "field": "grid",
          "resolve": {"signal": "resolve"},
          "levels": 3
        }
      ]
    }
  ],

  "scales": [
    {
      "name": "x",
      "type": "linear",
      "round": true,
      "nice": true,
      "zero": true,
      "domain": {"data": "source", "field": "Horsepower"},
      "range": "width"
    },
    {
      "name": "y",
      "type": "linear",
      "round": true,
      "nice": true,
      "zero": true,
      "domain": {"data": "source", "field": "Miles_per_Gallon"},
      "range": "height"
    },
    {
      "name": "color",
      "type": "ordinal",
      "domain": {
        "data": "source", "field": "Origin",
        "sort": {"order": "descending"}
      },
      "range": "category"
    }
  ],

  "axes": [
    {
      "scale": "x",
      "grid": true,
      "domain": false,
      "orient": "bottom",
      "tickCount": 5,
      "title": "Horsepower"
    },
    {
      "scale": "y",
      "grid": true,
      "domain": false,
      "orient": "left",
      "titlePadding": 5,
      "title": "Miles_per_Gallon"
    }
  ],

  "legends": [
    {"stroke": "color", "symbolType": "stroke"}
  ],

  "marks": [
    {
      "name": "marks",
      "type": "symbol",
      "from": {"data": "source"},
      "encode": {
        "update": {
          "x": {"scale": "x", "field": "Horsepower"},
          "y": {"scale": "y", "field": "Miles_per_Gallon"},
          "size": {"value": 4},
          "fill": {"value": "#ccc"}
        }
      }
    },
    {
      "type": "image",
      "from": {"data": "density"},
      "encode": {
        "update": {
          "x": {"value": 0},
          "y": {"value": 0},
          "width": {"signal": "width"},
          "height": {"signal": "height"},
          "aspect": {"value": false}
        }
      },
      "transform": [
        {
          "type": "heatmap",
          "field": "datum.grid",
          "resolve": {"signal": "resolve"},
          "color": {"expr": "scale('color', datum.datum.Origin)"}
        }
      ]
    },
    {
      "type": "path",
      "clip": true,
      "from": {"data": "contours"},
      "encode": {
        "enter": {
          "strokeWidth": {"value": 1},
          "strokeOpacity": {"value": 1},
          "stroke": {"scale": "color", "field": "Origin"}
        }
      },
      "transform": [
        { "type": "geopath", "field": "datum.contour" }
      ]
    }
  ]
}\nVega
            
              Vega-Lite
              Altair
              Vega-Lite API\nVega-Lite
              Altair
              Vega-Lite API\nExamples
              Tutorials
              Documentation
              Usage
              About
            
            
              GitHub
              Try Online\nExamples
              Tutorials
              Documentation
              Usage
              About\nGitHub
              Try Online\nContour Plot Example
    A contour plot depicts the density of data points as a set of discrete levels. Akin to contour lines on topographic maps, each contour boundary is an isoline of constant density. Kernel density estimation is performed with the kde2d transform to generate a continuous approximation of the sample density for each group. The heatmap transform generates heatmap images to convey these density estimates directly. The isocontour transform analyzes the density estimates to generate level set contours in the form of GeoJSON polygons.




  
  View Source
  Export PNG
  Export SVG






  View in Online Vega Editor


Vega JSON Specification <>

{
  "$schema": "https://vega.github.io/schema/vega/v5.json",
  "description": "A contour plot example, overlaying a density estimate on scatter plot points.",
  "width": 500,
  "height": 400,
  "padding": 5,
  "autosize": "pad",

  "signals": [
    {
      "name": "bandwidth", "value": -1,
      "bind": {"input": "range", "min": -1, "max": 100, "step": 1}
    },
    {
      "name": "resolve", "value": "shared",
      "bind": {"input": "select", "options": ["independent", "shared"]}
    },
    {
      "name": "counts", "value": true,
      "bind": {"input": "checkbox"}
    }
  ],

  "data": [
    {
      "name": "source",
      "url": "data/cars.json",
      "transform": [
        {
          "type": "filter",
          "expr": "datum.Horsepower != null && datum.Miles_per_Gallon != null"
        }
      ]
    },
    {
      "name": "density",
      "source": "source",
      "transform": [
        {
          "type": "kde2d",
          "groupby": ["Origin"],
          "size": [{"signal": "width"}, {"signal": "height"}],
          "x": {"expr": "scale('x', datum.Horsepower)"},
          "y": {"expr": "scale('y', datum.Miles_per_Gallon)"},
          "bandwidth": {"signal": "[bandwidth, bandwidth]"},
          "counts": {"signal": "counts"}
        }
      ]
    },
    {
      "name": "contours",
      "source": "density",
      "transform": [
        {
          "type": "isocontour",
          "field": "grid",
          "resolve": {"signal": "resolve"},
          "levels": 3
        }
      ]
    }
  ],

  "scales": [
    {
      "name": "x",
      "type": "linear",
      "round": true,
      "nice": true,
      "zero": true,
      "domain": {"data": "source", "field": "Horsepower"},
      "range": "width"
    },
    {
      "name": "y",
      "type": "linear",
      "round": true,
      "nice": true,
      "zero": true,
      "domain": {"data": "source", "field": "Miles_per_Gallon"},
      "range": "height"
    },
    {
      "name": "color",
      "type": "ordinal",
      "domain": {
        "data": "source", "field": "Origin",
        "sort": {"order": "descending"}
      },
      "range": "category"
    }
  ],

  "axes": [
    {
      "scale": "x",
      "grid": true,
      "domain": false,
      "orient": "bottom",
      "tickCount": 5,
      "title": "Horsepower"
    },
    {
      "scale": "y",
      "grid": true,
      "domain": false,
      "orient": "left",
      "titlePadding": 5,
      "title": "Miles_per_Gallon"
    }
  ],

  "legends": [
    {"stroke": "color", "symbolType": "stroke"}
  ],

  "marks": [
    {
      "name": "marks",
      "type": "symbol",
      "from": {"data": "source"},
      "encode": {
        "update": {
          "x": {"scale": "x", "field": "Horsepower"},
          "y": {"scale": "y", "field": "Miles_per_Gallon"},
          "size": {"value": 4},
          "fill": {"value": "#ccc"}
        }
      }
    },
    {
      "type": "image",
      "from": {"data": "density"},
      "encode": {
        "update": {
          "x": {"value": 0},
          "y": {"value": 0},
          "width": {"signal": "width"},
          "height": {"signal": "height"},
          "aspect": {"value": false}
        }
      },
      "transform": [
        {
          "type": "heatmap",
          "field": "datum.grid",
          "resolve": {"signal": "resolve"},
          "color": {"expr": "scale('color', datum.datum.Origin)"}
        }
      ]
    },
    {
      "type": "path",
      "clip": true,
      "from": {"data": "contours"},
      "encode": {
        "enter": {
          "strokeWidth": {"value": 1},
          "strokeOpacity": {"value": 1},
          "stroke": {"scale": "color", "field": "Origin"}
        }
      },
      "transform": [
        { "type": "geopath", "field": "datum.contour" }
      ]
    }
  ]
}\nA contour plot depicts the density of data points as a set of discrete levels. Akin to contour lines on topographic maps, each contour boundary is an isoline of constant density. Kernel density estimation is performed with the kde2d transform to generate a continuous approximation of the sample density for each group. The heatmap transform generates heatmap images to convey these density estimates directly. The isocontour transform analyzes the density estimates to generate level set contours in the form of GeoJSON polygons.\nView Source
  Export PNG
  Export SVG\nView Source
  Export PNG
  Export SVG\nView in Online Vega Editor\nView in Online Vega Editor\nVega JSON Specification <>\n{
  "$schema": "https://vega.github.io/schema/vega/v5.json",
  "description": "A contour plot example, overlaying a density estimate on scatter plot points.",
  "width": 500,
  "height": 400,
  "padding": 5,
  "autosize": "pad",

  "signals": [
    {
      "name": "bandwidth", "value": -1,
      "bind": {"input": "range", "min": -1, "max": 100, "step": 1}
    },
    {
      "name": "resolve", "value": "shared",
      "bind": {"input": "select", "options": ["independent", "shared"]}
    },
    {
      "name": "counts", "value": true,
      "bind": {"input": "checkbox"}
    }
  ],

  "data": [
    {
      "name": "source",
      "url": "data/cars.json",
      "transform": [
        {
          "type": "filter",
          "expr": "datum.Horsepower != null && datum.Miles_per_Gallon != null"
        }
      ]
    },
    {
      "name": "density",
      "source": "source",
      "transform": [
        {
          "type": "kde2d",
          "groupby": ["Origin"],
          "size": [{"signal": "width"}, {"signal": "height"}],
          "x": {"expr": "scale('x', datum.Horsepower)"},
          "y": {"expr": "scale('y', datum.Miles_per_Gallon)"},
          "bandwidth": {"signal": "[bandwidth, bandwidth]"},
          "counts": {"signal": "counts"}
        }
      ]
    },
    {
      "name": "contours",
      "source": "density",
      "transform": [
        {
          "type": "isocontour",
          "field": "grid",
          "resolve": {"signal": "resolve"},
          "levels": 3
        }
      ]
    }
  ],

  "scales": [
    {
      "name": "x",
      "type": "linear",
      "round": true,
      "nice": true,
      "zero": true,
      "domain": {"data": "source", "field": "Horsepower"},
      "range": "width"
    },
    {
      "name": "y",
      "type": "linear",
      "round": true,
      "nice": true,
      "zero": true,
      "domain": {"data": "source", "field": "Miles_per_Gallon"},
      "range": "height"
    },
    {
      "name": "color",
      "type": "ordinal",
      "domain": {
        "data": "source", "field": "Origin",
        "sort": {"order": "descending"}
      },
      "range": "category"
    }
  ],

  "axes": [
    {
      "scale": "x",
      "grid": true,
      "domain": false,
      "orient": "bottom",
      "tickCount": 5,
      "title": "Horsepower"
    },
    {
      "scale": "y",
      "grid": true,
      "domain": false,
      "orient": "left",
      "titlePadding": 5,
      "title": "Miles_per_Gallon"
    }
  ],

  "legends": [
    {"stroke": "color", "symbolType": "stroke"}
  ],

  "marks": [
    {
      "name": "marks",
      "type": "symbol",
      "from": {"data": "source"},
      "encode": {
        "update": {
          "x": {"scale": "x", "field": "Horsepower"},
          "y": {"scale": "y", "field": "Miles_per_Gallon"},
          "size": {"value": 4},
          "fill": {"value": "#ccc"}
        }
      }
    },
    {
      "type": "image",
      "from": {"data": "density"},
      "encode": {
        "update": {
          "x": {"value": 0},
          "y": {"value": 0},
          "width": {"signal": "width"},
          "height": {"signal": "height"},
          "aspect": {"value": false}
        }
      },
      "transform": [
        {
          "type": "heatmap",
          "field": "datum.grid",
          "resolve": {"signal": "resolve"},
          "color": {"expr": "scale('color', datum.datum.Origin)"}
        }
      ]
    },
    {
      "type": "path",
      "clip": true,
      "from": {"data": "contours"},
      "encode": {
        "enter": {
          "strokeWidth": {"value": 1},
          "strokeOpacity": {"value": 1},
          "stroke": {"scale": "color", "field": "Origin"}
        }
      },
      "transform": [
        { "type": "geopath", "field": "datum.contour" }
      ]
    }
  ]
}\n{
  "$schema": "https://vega.github.io/schema/vega/v5.json",
  "description": "A contour plot example, overlaying a density estimate on scatter plot points.",
  "width": 500,
  "height": 400,
  "padding": 5,
  "autosize": "pad",

  "signals": [
    {
      "name": "bandwidth", "value": -1,
      "bind": {"input": "range", "min": -1, "max": 100, "step": 1}
    },
    {
      "name": "resolve", "value": "shared",
      "bind": {"input": "select", "options": ["independent", "shared"]}
    },
    {
      "name": "counts", "value": true,
      "bind": {"input": "checkbox"}
    }
  ],

  "data": [
    {
      "name": "source",
      "url": "data/cars.json",
      "transform": [
        {
          "type": "filter",
          "expr": "datum.Horsepower != null && datum.Miles_per_Gallon != null"
        }
      ]
    },
    {
      "name": "density",
      "source": "source",
      "transform": [
        {
          "type": "kde2d",
          "groupby": ["Origin"],
          "size": [{"signal": "width"}, {"signal": "height"}],
          "x": {"expr": "scale('x', datum.Horsepower)"},
          "y": {"expr": "scale('y', datum.Miles_per_Gallon)"},
          "bandwidth": {"signal": "[bandwidth, bandwidth]"},
          "counts": {"signal": "counts"}
        }
      ]
    },
    {
      "name": "contours",
      "source": "density",
      "transform": [
        {
          "type": "isocontour",
          "field": "grid",
          "resolve": {"signal": "resolve"},
          "levels": 3
        }
      ]
    }
  ],

  "scales": [
    {
      "name": "x",
      "type": "linear",
      "round": true,
      "nice": true,
      "zero": true,
      "domain": {"data": "source", "field": "Horsepower"},
      "range": "width"
    },
    {
      "name": "y",
      "type": "linear",
      "round": true,
      "nice": true,
      "zero": true,
      "domain": {"data": "source", "field": "Miles_per_Gallon"},
      "range": "height"
    },
    {
      "name": "color",
      "type": "ordinal",
      "domain": {
        "data": "source", "field": "Origin",
        "sort": {"order": "descending"}
      },
      "range": "category"
    }
  ],

  "axes": [
    {
      "scale": "x",
      "grid": true,
      "domain": false,
      "orient": "bottom",
      "tickCount": 5,
      "title": "Horsepower"
    },
    {
      "scale": "y",
      "grid": true,
      "domain": false,
      "orient": "left",
      "titlePadding": 5,
      "title": "Miles_per_Gallon"
    }
  ],

  "legends": [
    {"stroke": "color", "symbolType": "stroke"}
  ],

  "marks": [
    {
      "name": "marks",
      "type": "symbol",
      "from": {"data": "source"},
      "encode": {
        "update": {
          "x": {"scale": "x", "field": "Horsepower"},
          "y": {"scale": "y", "field": "Miles_per_Gallon"},
          "size": {"value": 4},
          "fill": {"value": "#ccc"}
        }
      }
    },
    {
      "type": "image",
      "from": {"data": "density"},
      "encode": {
        "update": {
          "x": {"value": 0},
          "y": {"value": 0},
          "width": {"signal": "width"},
          "height": {"signal": "height"},
          "aspect": {"value": false}
        }
      },
      "transform": [
        {
          "type": "heatmap",
          "field": "datum.grid",
          "resolve": {"signal": "resolve"},
          "color": {"expr": "scale('color', datum.datum.Origin)"}
        }
      ]
    },
    {
      "type": "path",
      "clip": true,
      "from": {"data": "contours"},
      "encode": {
        "enter": {
          "strokeWidth": {"value": 1},
          "strokeOpacity": {"value": 1},
          "stroke": {"scale": "color", "field": "Origin"}
        }
      },
      "transform": [
        { "type": "geopath", "field": "datum.contour" }
      ]
    }
  ]
}\n"https://vega.github.io/schema/vega/v5.json"\n"A contour plot example, overlaying a density estimate on scatter plot points."\n"datum.Horsepower != null && datum.Miles_per_Gallon != null"\n"scale('x', datum.Horsepower)"\n"scale('y', datum.Miles_per_Gallon)"\n"[bandwidth, bandwidth]"\n"scale('color', datum.datum.Origin)"\n\n\nVega
            
              Vega-Lite
              Altair
              Vega-Lite API
            
          
          
            
              Examples
              Tutorials
              Documentation
              Usage
              About
            
            
              GitHub
              Try Online
            
          
        
      

      
        

  
  
    Wheat Plot Example
    A wheat plot is an alternative to standard dot plots and histograms that incorporates aspects of both. The x-coordinate of a point is based on its exact value. The y-coordinate is determined by grouping points into histogram bins, then stacking them based on their rank order within each bin. While not scalable to large numbers of data points, wheat plots allow inspection of (and interaction with) individual points without overplotting. For a related approach, see beeswarm plots.




  
  View Source
  Export PNG
  Export SVG






  View in Online Vega Editor


Vega JSON Specification <>

{
  "$schema": "https://vega.github.io/schema/vega/v5.json",
  "description": "A wheat plot example, which combines elements of dot plots and histograms.",
  "width": 500,
  "padding": 5,

  "signals": [
    { "name": "symbolDiameter", "value": 4,
      "bind": {"input": "range", "min": 1, "max": 8, "step": 0.25} },
    { "name": "binOffset", "value": 0,
      "bind": {"input": "range", "min": -0.1, "max": 0.1} },
    { "name": "binStep", "value": 0.075,
      "bind": {"input": "range", "min": 0.001, "max": 0.2, "step": 0.001} },
    { "name": "height", "update": "extent[1] * (1 + symbolDiameter)" }
  ],

  "data": [
    {
      "name": "points",
      "url": "data/normal-2d.json",
      "transform": [
        {
          "type": "bin", "field": "u",
          "extent": [-1, 1],
          "anchor": {"signal": "binOffset"},
          "step": {"signal": "binStep"},
          "nice": false,
          "signal": "bins"
        },
        {
          "type": "stack",
          "groupby": ["bin0"],
          "sort": {"field": "u"}
        },
        {
          "type": "extent", "signal": "extent",
          "field": "y1"
        }
      ]
    }
  ],

  "scales": [
    {
      "name": "xscale",
      "type": "linear",
      "range": "width",
      "domain": [-1, 1]
    },
    {
      "name": "yscale",
      "type": "linear",
      "range": "height",
      "domain": [0, {"signal": "extent[1]"}]
    }
  ],

  "axes": [
    { "orient": "bottom", "scale": "xscale",
      "values": {"signal": "sequence(bins.start, bins.stop + bins.step, bins.step)"},
      "domain": false, "ticks": false, "labels": false, "grid": true,
      "zindex": 0 },
    {"orient": "bottom", "scale": "xscale", "zindex": 1}
  ],

  "marks": [
    {
      "type": "symbol",
      "from": {"data": "points"},
      "encode": {
        "enter": {
          "fill": {"value": "transparent"},
          "strokeWidth": {"value": 0.5}
        },
        "update": {
          "x": {"scale": "xscale", "field": "u"},
          "y": {"scale": "yscale", "field": "y0"},
          "size": {"signal": "symbolDiameter * symbolDiameter"},
          "stroke": {"value": "steelblue"}
        },
        "hover": {
          "stroke": {"value": "firebrick"}
        }
      }
    }
  ]
}\nVega
            
              Vega-Lite
              Altair
              Vega-Lite API\nVega-Lite
              Altair
              Vega-Lite API\nExamples
              Tutorials
              Documentation
              Usage
              About
            
            
              GitHub
              Try Online\nExamples
              Tutorials
              Documentation
              Usage
              About\nGitHub
              Try Online\nWheat Plot Example
    A wheat plot is an alternative to standard dot plots and histograms that incorporates aspects of both. The x-coordinate of a point is based on its exact value. The y-coordinate is determined by grouping points into histogram bins, then stacking them based on their rank order within each bin. While not scalable to large numbers of data points, wheat plots allow inspection of (and interaction with) individual points without overplotting. For a related approach, see beeswarm plots.




  
  View Source
  Export PNG
  Export SVG






  View in Online Vega Editor


Vega JSON Specification <>

{
  "$schema": "https://vega.github.io/schema/vega/v5.json",
  "description": "A wheat plot example, which combines elements of dot plots and histograms.",
  "width": 500,
  "padding": 5,

  "signals": [
    { "name": "symbolDiameter", "value": 4,
      "bind": {"input": "range", "min": 1, "max": 8, "step": 0.25} },
    { "name": "binOffset", "value": 0,
      "bind": {"input": "range", "min": -0.1, "max": 0.1} },
    { "name": "binStep", "value": 0.075,
      "bind": {"input": "range", "min": 0.001, "max": 0.2, "step": 0.001} },
    { "name": "height", "update": "extent[1] * (1 + symbolDiameter)" }
  ],

  "data": [
    {
      "name": "points",
      "url": "data/normal-2d.json",
      "transform": [
        {
          "type": "bin", "field": "u",
          "extent": [-1, 1],
          "anchor": {"signal": "binOffset"},
          "step": {"signal": "binStep"},
          "nice": false,
          "signal": "bins"
        },
        {
          "type": "stack",
          "groupby": ["bin0"],
          "sort": {"field": "u"}
        },
        {
          "type": "extent", "signal": "extent",
          "field": "y1"
        }
      ]
    }
  ],

  "scales": [
    {
      "name": "xscale",
      "type": "linear",
      "range": "width",
      "domain": [-1, 1]
    },
    {
      "name": "yscale",
      "type": "linear",
      "range": "height",
      "domain": [0, {"signal": "extent[1]"}]
    }
  ],

  "axes": [
    { "orient": "bottom", "scale": "xscale",
      "values": {"signal": "sequence(bins.start, bins.stop + bins.step, bins.step)"},
      "domain": false, "ticks": false, "labels": false, "grid": true,
      "zindex": 0 },
    {"orient": "bottom", "scale": "xscale", "zindex": 1}
  ],

  "marks": [
    {
      "type": "symbol",
      "from": {"data": "points"},
      "encode": {
        "enter": {
          "fill": {"value": "transparent"},
          "strokeWidth": {"value": 0.5}
        },
        "update": {
          "x": {"scale": "xscale", "field": "u"},
          "y": {"scale": "yscale", "field": "y0"},
          "size": {"signal": "symbolDiameter * symbolDiameter"},
          "stroke": {"value": "steelblue"}
        },
        "hover": {
          "stroke": {"value": "firebrick"}
        }
      }
    }
  ]
}\nA wheat plot is an alternative to standard dot plots and histograms that incorporates aspects of both. The x-coordinate of a point is based on its exact value. The y-coordinate is determined by grouping points into histogram bins, then stacking them based on their rank order within each bin. While not scalable to large numbers of data points, wheat plots allow inspection of (and interaction with) individual points without overplotting. For a related approach, see beeswarm plots.\nView Source
  Export PNG
  Export SVG\nView Source
  Export PNG
  Export SVG\nView in Online Vega Editor\nView in Online Vega Editor\nVega JSON Specification <>\n{
  "$schema": "https://vega.github.io/schema/vega/v5.json",
  "description": "A wheat plot example, which combines elements of dot plots and histograms.",
  "width": 500,
  "padding": 5,

  "signals": [
    { "name": "symbolDiameter", "value": 4,
      "bind": {"input": "range", "min": 1, "max": 8, "step": 0.25} },
    { "name": "binOffset", "value": 0,
      "bind": {"input": "range", "min": -0.1, "max": 0.1} },
    { "name": "binStep", "value": 0.075,
      "bind": {"input": "range", "min": 0.001, "max": 0.2, "step": 0.001} },
    { "name": "height", "update": "extent[1] * (1 + symbolDiameter)" }
  ],

  "data": [
    {
      "name": "points",
      "url": "data/normal-2d.json",
      "transform": [
        {
          "type": "bin", "field": "u",
          "extent": [-1, 1],
          "anchor": {"signal": "binOffset"},
          "step": {"signal": "binStep"},
          "nice": false,
          "signal": "bins"
        },
        {
          "type": "stack",
          "groupby": ["bin0"],
          "sort": {"field": "u"}
        },
        {
          "type": "extent", "signal": "extent",
          "field": "y1"
        }
      ]
    }
  ],

  "scales": [
    {
      "name": "xscale",
      "type": "linear",
      "range": "width",
      "domain": [-1, 1]
    },
    {
      "name": "yscale",
      "type": "linear",
      "range": "height",
      "domain": [0, {"signal": "extent[1]"}]
    }
  ],

  "axes": [
    { "orient": "bottom", "scale": "xscale",
      "values": {"signal": "sequence(bins.start, bins.stop + bins.step, bins.step)"},
      "domain": false, "ticks": false, "labels": false, "grid": true,
      "zindex": 0 },
    {"orient": "bottom", "scale": "xscale", "zindex": 1}
  ],

  "marks": [
    {
      "type": "symbol",
      "from": {"data": "points"},
      "encode": {
        "enter": {
          "fill": {"value": "transparent"},
          "strokeWidth": {"value": 0.5}
        },
        "update": {
          "x": {"scale": "xscale", "field": "u"},
          "y": {"scale": "yscale", "field": "y0"},
          "size": {"signal": "symbolDiameter * symbolDiameter"},
          "stroke": {"value": "steelblue"}
        },
        "hover": {
          "stroke": {"value": "firebrick"}
        }
      }
    }
  ]
}\n{
  "$schema": "https://vega.github.io/schema/vega/v5.json",
  "description": "A wheat plot example, which combines elements of dot plots and histograms.",
  "width": 500,
  "padding": 5,

  "signals": [
    { "name": "symbolDiameter", "value": 4,
      "bind": {"input": "range", "min": 1, "max": 8, "step": 0.25} },
    { "name": "binOffset", "value": 0,
      "bind": {"input": "range", "min": -0.1, "max": 0.1} },
    { "name": "binStep", "value": 0.075,
      "bind": {"input": "range", "min": 0.001, "max": 0.2, "step": 0.001} },
    { "name": "height", "update": "extent[1] * (1 + symbolDiameter)" }
  ],

  "data": [
    {
      "name": "points",
      "url": "data/normal-2d.json",
      "transform": [
        {
          "type": "bin", "field": "u",
          "extent": [-1, 1],
          "anchor": {"signal": "binOffset"},
          "step": {"signal": "binStep"},
          "nice": false,
          "signal": "bins"
        },
        {
          "type": "stack",
          "groupby": ["bin0"],
          "sort": {"field": "u"}
        },
        {
          "type": "extent", "signal": "extent",
          "field": "y1"
        }
      ]
    }
  ],

  "scales": [
    {
      "name": "xscale",
      "type": "linear",
      "range": "width",
      "domain": [-1, 1]
    },
    {
      "name": "yscale",
      "type": "linear",
      "range": "height",
      "domain": [0, {"signal": "extent[1]"}]
    }
  ],

  "axes": [
    { "orient": "bottom", "scale": "xscale",
      "values": {"signal": "sequence(bins.start, bins.stop + bins.step, bins.step)"},
      "domain": false, "ticks": false, "labels": false, "grid": true,
      "zindex": 0 },
    {"orient": "bottom", "scale": "xscale", "zindex": 1}
  ],

  "marks": [
    {
      "type": "symbol",
      "from": {"data": "points"},
      "encode": {
        "enter": {
          "fill": {"value": "transparent"},
          "strokeWidth": {"value": 0.5}
        },
        "update": {
          "x": {"scale": "xscale", "field": "u"},
          "y": {"scale": "yscale", "field": "y0"},
          "size": {"signal": "symbolDiameter * symbolDiameter"},
          "stroke": {"value": "steelblue"}
        },
        "hover": {
          "stroke": {"value": "firebrick"}
        }
      }
    }
  ]
}\n"https://vega.github.io/schema/vega/v5.json"\n"A wheat plot example, which combines elements of dot plots and histograms."\n"extent[1] * (1 + symbolDiameter)"\n"data/normal-2d.json"\n"sequence(bins.start, bins.stop + bins.step, bins.step)"\n"symbolDiameter * symbolDiameter"\n\n\nVega
            
              Vega-Lite
              Altair
              Vega-Lite API
            
          
          
            
              Examples
              Tutorials
              Documentation
              Usage
              About
            
            
              GitHub
              Try Online
            
          
        
      

      
        

  
  
    Quantile-Quantile Plot Example
    A quantile-quantile (or Q-Q) plot visually compares two probability distributions by plotting a set of matching quantile values for both. For example, plotting the corresponding 1st, 2nd, 3rd, etc., percentiles for each distribution. Q-Q plots are often used to plot an empirical data distribution against a theoretical distribution. If the two distributions are similar, they will lie along a line; notable deviations from a line are evidence of different distribution functions.

This example compares an empirical sample against two theoretical distributions. Change the input data source (samples from normal or uniform distributions) to observe how different samples compare with the theoretical distributions. The quantile transform produces quantile values for input data; the quantileUniform and quantileNormal expression functions produce the theoretical quantile values.




  
  View Source
  Export PNG
  Export SVG






  View in Online Vega Editor


Vega JSON Specification <>

{
  "$schema": "https://vega.github.io/schema/vega/v5.json",
  "description": "A quantile-quantile plot example, comparing distributions by quantile values.",
  "padding": 5,

  "signals": [
    { "name": "plotWidth", "value": 250 },
    { "name": "height", "update": "plotWidth" },
    {
      "name": "numQuantiles", "value": 100,
      "bind": {"input": "range", "min": 20, "max": 200, "step": 1}
    },
    {
      "name": "url",
      "value": "data/normal-2d.json",
      "bind": {
        "input": "select",
        "options": [
          "data/normal-2d.json",
          "data/uniform-2d.json"
        ]
      }
    }
  ],

  "data": [
    {
      "name": "points",
      "url": {"signal": "url"}
    },
    {
      "name": "quantiles",
      "source": "points",
      "transform": [
        {
          "type": "quantile",
          "field": "u",
          "step": {"signal": "1 / (numQuantiles + 1)"}
        },
        {
          "type": "formula",
          "as": "quniform",
          "expr": "quantileUniform(datum.prob)"
        },
        {
          "type": "formula",
          "as": "qnormal",
          "expr": "quantileNormal(datum.prob)"
        }
      ]
    }
  ],

  "scales": [
    {
      "name": "y",
      "domain": {"data": "points", "field": "u"},
      "range": "height",
      "nice": true
    }
  ],

  "layout": {
    "columns": 2,
    "padding": 10
  },

  "marks": [
    {
      "type": "group",
      "encode": {
        "update": {
          "width": {"signal": "plotWidth"},
          "height": {"signal": "plotWidth"}
        }
      },
      "signals": [
        {"name": "width", "update": "plotWidth"}
      ],
      "scales": [
        {
          "name": "x",
          "domain": [0, 1],
          "range": "width"
        }
      ],
      "axes": [
        {
          "scale": "y",
          "orient": "left",
          "offset": 10,
          "grid": true,
          "title": "Empirical Data Quantiles"
        },
        {
          "scale": "x",
          "orient": "bottom",
          "grid": true,
          "title": "Theoretical Uniform Quantiles"
        }
      ],
      "marks": [
        {
          "type": "symbol",
          "from": {"data": "quantiles"},
          "encode": {
            "update": {
              "x": {"scale": "x", "field": "quniform"},
              "y": {"scale": "y", "field": "value"},
              "fill": {"value": "steelblue"},
              "size": {"value": 16}
            }
          }
        }
      ]
    },
    {
      "type": "group",
      "encode": {
        "update": {
          "width": {"signal": "plotWidth"},
          "height": {"signal": "plotWidth"}
        }
      },
      "signals": [
        {"name": "width", "update": "plotWidth"}
      ],
      "scales": [
        {
          "name": "x",
          "domain": [-3, 3],
          "range": "width"
        }
      ],
      "axes": [
        {
          "scale": "y",
          "orient": "left",
          "domain": false, "labels": false, "ticks": false, "grid": true
        },
        {
          "scale": "x",
          "orient": "bottom",
          "grid": true,
          "title": "Theoretical Normal Quantiles"
        }
      ],
      "marks": [
        {
          "type": "symbol",
          "from": {"data": "quantiles"},
          "encode": {
            "update": {
              "x": {"scale": "x", "field": "qnormal"},
              "y": {"scale": "y", "field": "value"},
              "fill": {"value": "steelblue"},
              "size": {"value": 16}
            }
          }
        }
      ]
    }
  ]
}\nVega
            
              Vega-Lite
              Altair
              Vega-Lite API\nVega-Lite
              Altair
              Vega-Lite API\nExamples
              Tutorials
              Documentation
              Usage
              About
            
            
              GitHub
              Try Online\nExamples
              Tutorials
              Documentation
              Usage
              About\nGitHub
              Try Online\nQuantile-Quantile Plot Example
    A quantile-quantile (or Q-Q) plot visually compares two probability distributions by plotting a set of matching quantile values for both. For example, plotting the corresponding 1st, 2nd, 3rd, etc., percentiles for each distribution. Q-Q plots are often used to plot an empirical data distribution against a theoretical distribution. If the two distributions are similar, they will lie along a line; notable deviations from a line are evidence of different distribution functions.

This example compares an empirical sample against two theoretical distributions. Change the input data source (samples from normal or uniform distributions) to observe how different samples compare with the theoretical distributions. The quantile transform produces quantile values for input data; the quantileUniform and quantileNormal expression functions produce the theoretical quantile values.




  
  View Source
  Export PNG
  Export SVG






  View in Online Vega Editor


Vega JSON Specification <>

{
  "$schema": "https://vega.github.io/schema/vega/v5.json",
  "description": "A quantile-quantile plot example, comparing distributions by quantile values.",
  "padding": 5,

  "signals": [
    { "name": "plotWidth", "value": 250 },
    { "name": "height", "update": "plotWidth" },
    {
      "name": "numQuantiles", "value": 100,
      "bind": {"input": "range", "min": 20, "max": 200, "step": 1}
    },
    {
      "name": "url",
      "value": "data/normal-2d.json",
      "bind": {
        "input": "select",
        "options": [
          "data/normal-2d.json",
          "data/uniform-2d.json"
        ]
      }
    }
  ],

  "data": [
    {
      "name": "points",
      "url": {"signal": "url"}
    },
    {
      "name": "quantiles",
      "source": "points",
      "transform": [
        {
          "type": "quantile",
          "field": "u",
          "step": {"signal": "1 / (numQuantiles + 1)"}
        },
        {
          "type": "formula",
          "as": "quniform",
          "expr": "quantileUniform(datum.prob)"
        },
        {
          "type": "formula",
          "as": "qnormal",
          "expr": "quantileNormal(datum.prob)"
        }
      ]
    }
  ],

  "scales": [
    {
      "name": "y",
      "domain": {"data": "points", "field": "u"},
      "range": "height",
      "nice": true
    }
  ],

  "layout": {
    "columns": 2,
    "padding": 10
  },

  "marks": [
    {
      "type": "group",
      "encode": {
        "update": {
          "width": {"signal": "plotWidth"},
          "height": {"signal": "plotWidth"}
        }
      },
      "signals": [
        {"name": "width", "update": "plotWidth"}
      ],
      "scales": [
        {
          "name": "x",
          "domain": [0, 1],
          "range": "width"
        }
      ],
      "axes": [
        {
          "scale": "y",
          "orient": "left",
          "offset": 10,
          "grid": true,
          "title": "Empirical Data Quantiles"
        },
        {
          "scale": "x",
          "orient": "bottom",
          "grid": true,
          "title": "Theoretical Uniform Quantiles"
        }
      ],
      "marks": [
        {
          "type": "symbol",
          "from": {"data": "quantiles"},
          "encode": {
            "update": {
              "x": {"scale": "x", "field": "quniform"},
              "y": {"scale": "y", "field": "value"},
              "fill": {"value": "steelblue"},
              "size": {"value": 16}
            }
          }
        }
      ]
    },
    {
      "type": "group",
      "encode": {
        "update": {
          "width": {"signal": "plotWidth"},
          "height": {"signal": "plotWidth"}
        }
      },
      "signals": [
        {"name": "width", "update": "plotWidth"}
      ],
      "scales": [
        {
          "name": "x",
          "domain": [-3, 3],
          "range": "width"
        }
      ],
      "axes": [
        {
          "scale": "y",
          "orient": "left",
          "domain": false, "labels": false, "ticks": false, "grid": true
        },
        {
          "scale": "x",
          "orient": "bottom",
          "grid": true,
          "title": "Theoretical Normal Quantiles"
        }
      ],
      "marks": [
        {
          "type": "symbol",
          "from": {"data": "quantiles"},
          "encode": {
            "update": {
              "x": {"scale": "x", "field": "qnormal"},
              "y": {"scale": "y", "field": "value"},
              "fill": {"value": "steelblue"},
              "size": {"value": 16}
            }
          }
        }
      ]
    }
  ]
}\nQuantile-Quantile Plot Example\nA quantile-quantile (or Q-Q) plot visually compares two probability distributions by plotting a set of matching quantile values for both. For example, plotting the corresponding 1st, 2nd, 3rd, etc., percentiles for each distribution. Q-Q plots are often used to plot an empirical data distribution against a theoretical distribution. If the two distributions are similar, they will lie along a line; notable deviations from a line are evidence of different distribution functions.\nquantile-quantile (or Q-Q) plot\nThis example compares an empirical sample against two theoretical distributions. Change the input data source (samples from normal or uniform distributions) to observe how different samples compare with the theoretical distributions. The quantile transform produces quantile values for input data; the quantileUniform and quantileNormal expression functions produce the theoretical quantile values.\nView Source
  Export PNG
  Export SVG\nView Source
  Export PNG
  Export SVG\nView in Online Vega Editor\nView in Online Vega Editor\nVega JSON Specification <>\n{
  "$schema": "https://vega.github.io/schema/vega/v5.json",
  "description": "A quantile-quantile plot example, comparing distributions by quantile values.",
  "padding": 5,

  "signals": [
    { "name": "plotWidth", "value": 250 },
    { "name": "height", "update": "plotWidth" },
    {
      "name": "numQuantiles", "value": 100,
      "bind": {"input": "range", "min": 20, "max": 200, "step": 1}
    },
    {
      "name": "url",
      "value": "data/normal-2d.json",
      "bind": {
        "input": "select",
        "options": [
          "data/normal-2d.json",
          "data/uniform-2d.json"
        ]
      }
    }
  ],

  "data": [
    {
      "name": "points",
      "url": {"signal": "url"}
    },
    {
      "name": "quantiles",
      "source": "points",
      "transform": [
        {
          "type": "quantile",
          "field": "u",
          "step": {"signal": "1 / (numQuantiles + 1)"}
        },
        {
          "type": "formula",
          "as": "quniform",
          "expr": "quantileUniform(datum.prob)"
        },
        {
          "type": "formula",
          "as": "qnormal",
          "expr": "quantileNormal(datum.prob)"
        }
      ]
    }
  ],

  "scales": [
    {
      "name": "y",
      "domain": {"data": "points", "field": "u"},
      "range": "height",
      "nice": true
    }
  ],

  "layout": {
    "columns": 2,
    "padding": 10
  },

  "marks": [
    {
      "type": "group",
      "encode": {
        "update": {
          "width": {"signal": "plotWidth"},
          "height": {"signal": "plotWidth"}
        }
      },
      "signals": [
        {"name": "width", "update": "plotWidth"}
      ],
      "scales": [
        {
          "name": "x",
          "domain": [0, 1],
          "range": "width"
        }
      ],
      "axes": [
        {
          "scale": "y",
          "orient": "left",
          "offset": 10,
          "grid": true,
          "title": "Empirical Data Quantiles"
        },
        {
          "scale": "x",
          "orient": "bottom",
          "grid": true,
          "title": "Theoretical Uniform Quantiles"
        }
      ],
      "marks": [
        {
          "type": "symbol",
          "from": {"data": "quantiles"},
          "encode": {
            "update": {
              "x": {"scale": "x", "field": "quniform"},
              "y": {"scale": "y", "field": "value"},
              "fill": {"value": "steelblue"},
              "size": {"value": 16}
            }
          }
        }
      ]
    },
    {
      "type": "group",
      "encode": {
        "update": {
          "width": {"signal": "plotWidth"},
          "height": {"signal": "plotWidth"}
        }
      },
      "signals": [
        {"name": "width", "update": "plotWidth"}
      ],
      "scales": [
        {
          "name": "x",
          "domain": [-3, 3],
          "range": "width"
        }
      ],
      "axes": [
        {
          "scale": "y",
          "orient": "left",
          "domain": false, "labels": false, "ticks": false, "grid": true
        },
        {
          "scale": "x",
          "orient": "bottom",
          "grid": true,
          "title": "Theoretical Normal Quantiles"
        }
      ],
      "marks": [
        {
          "type": "symbol",
          "from": {"data": "quantiles"},
          "encode": {
            "update": {
              "x": {"scale": "x", "field": "qnormal"},
              "y": {"scale": "y", "field": "value"},
              "fill": {"value": "steelblue"},
              "size": {"value": 16}
            }
          }
        }
      ]
    }
  ]
}\n{
  "$schema": "https://vega.github.io/schema/vega/v5.json",
  "description": "A quantile-quantile plot example, comparing distributions by quantile values.",
  "padding": 5,

  "signals": [
    { "name": "plotWidth", "value": 250 },
    { "name": "height", "update": "plotWidth" },
    {
      "name": "numQuantiles", "value": 100,
      "bind": {"input": "range", "min": 20, "max": 200, "step": 1}
    },
    {
      "name": "url",
      "value": "data/normal-2d.json",
      "bind": {
        "input": "select",
        "options": [
          "data/normal-2d.json",
          "data/uniform-2d.json"
        ]
      }
    }
  ],

  "data": [
    {
      "name": "points",
      "url": {"signal": "url"}
    },
    {
      "name": "quantiles",
      "source": "points",
      "transform": [
        {
          "type": "quantile",
          "field": "u",
          "step": {"signal": "1 / (numQuantiles + 1)"}
        },
        {
          "type": "formula",
          "as": "quniform",
          "expr": "quantileUniform(datum.prob)"
        },
        {
          "type": "formula",
          "as": "qnormal",
          "expr": "quantileNormal(datum.prob)"
        }
      ]
    }
  ],

  "scales": [
    {
      "name": "y",
      "domain": {"data": "points", "field": "u"},
      "range": "height",
      "nice": true
    }
  ],

  "layout": {
    "columns": 2,
    "padding": 10
  },

  "marks": [
    {
      "type": "group",
      "encode": {
        "update": {
          "width": {"signal": "plotWidth"},
          "height": {"signal": "plotWidth"}
        }
      },
      "signals": [
        {"name": "width", "update": "plotWidth"}
      ],
      "scales": [
        {
          "name": "x",
          "domain": [0, 1],
          "range": "width"
        }
      ],
      "axes": [
        {
          "scale": "y",
          "orient": "left",
          "offset": 10,
          "grid": true,
          "title": "Empirical Data Quantiles"
        },
        {
          "scale": "x",
          "orient": "bottom",
          "grid": true,
          "title": "Theoretical Uniform Quantiles"
        }
      ],
      "marks": [
        {
          "type": "symbol",
          "from": {"data": "quantiles"},
          "encode": {
            "update": {
              "x": {"scale": "x", "field": "quniform"},
              "y": {"scale": "y", "field": "value"},
              "fill": {"value": "steelblue"},
              "size": {"value": 16}
            }
          }
        }
      ]
    },
    {
      "type": "group",
      "encode": {
        "update": {
          "width": {"signal": "plotWidth"},
          "height": {"signal": "plotWidth"}
        }
      },
      "signals": [
        {"name": "width", "update": "plotWidth"}
      ],
      "scales": [
        {
          "name": "x",
          "domain": [-3, 3],
          "range": "width"
        }
      ],
      "axes": [
        {
          "scale": "y",
          "orient": "left",
          "domain": false, "labels": false, "ticks": false, "grid": true
        },
        {
          "scale": "x",
          "orient": "bottom",
          "grid": true,
          "title": "Theoretical Normal Quantiles"
        }
      ],
      "marks": [
        {
          "type": "symbol",
          "from": {"data": "quantiles"},
          "encode": {
            "update": {
              "x": {"scale": "x", "field": "qnormal"},
              "y": {"scale": "y", "field": "value"},
              "fill": {"value": "steelblue"},
              "size": {"value": 16}
            }
          }
        }
      ]
    }
  ]
}\n"https://vega.github.io/schema/vega/v5.json"\n"A quantile-quantile plot example, comparing distributions by quantile values."\n"data/normal-2d.json"\n"data/normal-2d.json"\n"data/uniform-2d.json"\n"1 / (numQuantiles + 1)"\n"quantileUniform(datum.prob)"\n"quantileNormal(datum.prob)"\n"Empirical Data Quantiles"\n"Theoretical Uniform Quantiles"\n"Theoretical Normal Quantiles"\n\n\nVega
            
              Vega-Lite
              Altair
              Vega-Lite API
            
          
          
            
              Examples
              Tutorials
              Documentation
              Usage
              About
            
            
              GitHub
              Try Online
            
          
        
      

      
        

  
  
    Quantile Dot Plot Example
    A quantile dot plot represents a probability distribution by taking a uniform sample of quantile values and plotting them in a dot plot. It visualizes a representative set of possible outcomes of a random process, and provides a discrete alternative to probability density and violin plots in which finding probability intervals reduces to counting dots in the display.

The plot below visualizes quantiles for a log-normal distribution that models hypothetical bus arrival times (in minutes from the current time), following the example of Kay, Kola, Hullman, & Munson, 2016. If we are willing to miss a bus 2 out of 20 times, given 20 quantiles we can count up 2 dots from the left to get the time we should arrive at the bus stop.

Click or drag on the chart to explore risk thresholds for arriving at the bus stop. Double-click to remove the threshold.




  
  View Source
  Export PNG
  Export SVG






  View in Online Vega Editor


Vega JSON Specification <>

{
  "$schema": "https://vega.github.io/schema/vega/v5.json",
  "description": "A quantile dot plot conveying the uncertainty of bus arrival times.",
  "width": 400,
  "height": 90,
  "padding": 5,

  "signals": [
    {
      "name": "quantiles", "value": 20,
      "bind": {"input": "range", "min": 10, "max": 200, "step": 1}
    },
    {"name": "mean", "update": "log(11.4)"},
    {"name": "sd", "value": 0.2},
    {"name": "step", "update": "1.25 * sqrt(20 / quantiles)"},
    {"name": "size", "update": "scale('x', step) - scale('x', 0)"},
    {"name": "area", "update": "size * size"},
    {
      "name": "select", "init": "quantileLogNormal(0.05, mean, sd)",
      "on": [
        {
          "events": "click, [pointerdown, window:pointerup] > pointermove",
          "update": "clamp(invert('x', x()), 0.0001, 30)"
        },
        {
          "events": "dblclick",
          "update": "0"
        }
      ]
    }
  ],

  "data": [
    {
      "name": "quantiles",
      "transform": [
        {
          "type": "sequence", "as": "p",
          "start": {"signal": "0.5 / quantiles"},
          "step": {"signal": "1 / quantiles"},
          "stop": 1
        },
        {
          "type": "formula", "as": "value",
          "expr": "quantileLogNormal(datum.p, mean, sd)"
        },
        {
          "type": "dotbin",
          "field": "value",
          "step": {"signal": "step"}
        },
        {
          "type": "stack",
          "groupby": ["bin"]
        },
        {
          "type": "extent",
          "field": "y1",
          "signal": "ext"
        }
      ]
    }
  ],

  "scales": [
    {
      "name": "x",
      "domain": [0, 30],
      "range": "width"
    },
    {
      "name": "y",
      "domain": {"signal": "[0, height / size]"},
      "range": "height"
    }
  ],

  "axes": [
    {"scale": "x", "orient": "bottom"}
  ],

  "marks": [
    {
      "type": "symbol",
      "from": {"data": "quantiles"},
      "encode": {
        "enter": {
          "x": {"scale": "x", "field": "bin"},
          "y": {"scale": "y", "signal": "datum.y0 + 0.5"},
          "size": {"signal": "area"}
        },
        "update": {
          "fill": {"signal": "datum.bin < select ? 'firebrick' : 'steelblue'"}
        }
      }
    },
    {
      "type": "rule",
      "interactive": false,
      "encode": {
        "update": {
          "x": {"scale": "x", "signal": "select"},
          "y": {"value": 0},
          "y2": {"signal": "height"},
          "stroke": {"signal": "select ? '#ccc': 'transparent'"}
        }
      }
    },
    {
      "type": "text",
      "interactive": false,
      "encode": {
        "enter": {
          "baseline": {"value": "top"},
          "dx": {"value": 3},
          "y": {"value": 2}
        },
        "update": {
          "x": {"scale": "x", "signal": "select"},
          "text": {"signal": "format(cumulativeLogNormal(select, mean, sd), '.1%')"},
          "fill": {"signal": "select ? '#000': 'transparent'"}
        }
      }
    }
  ]
}\nVega
            
              Vega-Lite
              Altair
              Vega-Lite API\nVega-Lite
              Altair
              Vega-Lite API\nExamples
              Tutorials
              Documentation
              Usage
              About
            
            
              GitHub
              Try Online\nExamples
              Tutorials
              Documentation
              Usage
              About\nGitHub
              Try Online\nQuantile Dot Plot Example
    A quantile dot plot represents a probability distribution by taking a uniform sample of quantile values and plotting them in a dot plot. It visualizes a representative set of possible outcomes of a random process, and provides a discrete alternative to probability density and violin plots in which finding probability intervals reduces to counting dots in the display.

The plot below visualizes quantiles for a log-normal distribution that models hypothetical bus arrival times (in minutes from the current time), following the example of Kay, Kola, Hullman, & Munson, 2016. If we are willing to miss a bus 2 out of 20 times, given 20 quantiles we can count up 2 dots from the left to get the time we should arrive at the bus stop.

Click or drag on the chart to explore risk thresholds for arriving at the bus stop. Double-click to remove the threshold.




  
  View Source
  Export PNG
  Export SVG






  View in Online Vega Editor


Vega JSON Specification <>

{
  "$schema": "https://vega.github.io/schema/vega/v5.json",
  "description": "A quantile dot plot conveying the uncertainty of bus arrival times.",
  "width": 400,
  "height": 90,
  "padding": 5,

  "signals": [
    {
      "name": "quantiles", "value": 20,
      "bind": {"input": "range", "min": 10, "max": 200, "step": 1}
    },
    {"name": "mean", "update": "log(11.4)"},
    {"name": "sd", "value": 0.2},
    {"name": "step", "update": "1.25 * sqrt(20 / quantiles)"},
    {"name": "size", "update": "scale('x', step) - scale('x', 0)"},
    {"name": "area", "update": "size * size"},
    {
      "name": "select", "init": "quantileLogNormal(0.05, mean, sd)",
      "on": [
        {
          "events": "click, [pointerdown, window:pointerup] > pointermove",
          "update": "clamp(invert('x', x()), 0.0001, 30)"
        },
        {
          "events": "dblclick",
          "update": "0"
        }
      ]
    }
  ],

  "data": [
    {
      "name": "quantiles",
      "transform": [
        {
          "type": "sequence", "as": "p",
          "start": {"signal": "0.5 / quantiles"},
          "step": {"signal": "1 / quantiles"},
          "stop": 1
        },
        {
          "type": "formula", "as": "value",
          "expr": "quantileLogNormal(datum.p, mean, sd)"
        },
        {
          "type": "dotbin",
          "field": "value",
          "step": {"signal": "step"}
        },
        {
          "type": "stack",
          "groupby": ["bin"]
        },
        {
          "type": "extent",
          "field": "y1",
          "signal": "ext"
        }
      ]
    }
  ],

  "scales": [
    {
      "name": "x",
      "domain": [0, 30],
      "range": "width"
    },
    {
      "name": "y",
      "domain": {"signal": "[0, height / size]"},
      "range": "height"
    }
  ],

  "axes": [
    {"scale": "x", "orient": "bottom"}
  ],

  "marks": [
    {
      "type": "symbol",
      "from": {"data": "quantiles"},
      "encode": {
        "enter": {
          "x": {"scale": "x", "field": "bin"},
          "y": {"scale": "y", "signal": "datum.y0 + 0.5"},
          "size": {"signal": "area"}
        },
        "update": {
          "fill": {"signal": "datum.bin < select ? 'firebrick' : 'steelblue'"}
        }
      }
    },
    {
      "type": "rule",
      "interactive": false,
      "encode": {
        "update": {
          "x": {"scale": "x", "signal": "select"},
          "y": {"value": 0},
          "y2": {"signal": "height"},
          "stroke": {"signal": "select ? '#ccc': 'transparent'"}
        }
      }
    },
    {
      "type": "text",
      "interactive": false,
      "encode": {
        "enter": {
          "baseline": {"value": "top"},
          "dx": {"value": 3},
          "y": {"value": 2}
        },
        "update": {
          "x": {"scale": "x", "signal": "select"},
          "text": {"signal": "format(cumulativeLogNormal(select, mean, sd), '.1%')"},
          "fill": {"signal": "select ? '#000': 'transparent'"}
        }
      }
    }
  ]
}\nQuantile Dot Plot Example\nA quantile dot plot represents a probability distribution by taking a uniform sample of quantile values and plotting them in a dot plot. It visualizes a representative set of possible outcomes of a random process, and provides a discrete alternative to probability density and violin plots in which finding probability intervals reduces to counting dots in the display.\nThe plot below visualizes quantiles for a log-normal distribution that models hypothetical bus arrival times (in minutes from the current time), following the example of Kay, Kola, Hullman, & Munson, 2016. If we are willing to miss a bus 2 out of 20 times, given 20 quantiles we can count up 2 dots from the left to get the time we should arrive at the bus stop.\nKay, Kola, Hullman, & Munson, 2016\nClick or drag on the chart to explore risk thresholds for arriving at the bus stop. Double-click to remove the threshold.\nView Source
  Export PNG
  Export SVG\nView Source
  Export PNG
  Export SVG\nView in Online Vega Editor\nView in Online Vega Editor\nVega JSON Specification <>\n{
  "$schema": "https://vega.github.io/schema/vega/v5.json",
  "description": "A quantile dot plot conveying the uncertainty of bus arrival times.",
  "width": 400,
  "height": 90,
  "padding": 5,

  "signals": [
    {
      "name": "quantiles", "value": 20,
      "bind": {"input": "range", "min": 10, "max": 200, "step": 1}
    },
    {"name": "mean", "update": "log(11.4)"},
    {"name": "sd", "value": 0.2},
    {"name": "step", "update": "1.25 * sqrt(20 / quantiles)"},
    {"name": "size", "update": "scale('x', step) - scale('x', 0)"},
    {"name": "area", "update": "size * size"},
    {
      "name": "select", "init": "quantileLogNormal(0.05, mean, sd)",
      "on": [
        {
          "events": "click, [pointerdown, window:pointerup] > pointermove",
          "update": "clamp(invert('x', x()), 0.0001, 30)"
        },
        {
          "events": "dblclick",
          "update": "0"
        }
      ]
    }
  ],

  "data": [
    {
      "name": "quantiles",
      "transform": [
        {
          "type": "sequence", "as": "p",
          "start": {"signal": "0.5 / quantiles"},
          "step": {"signal": "1 / quantiles"},
          "stop": 1
        },
        {
          "type": "formula", "as": "value",
          "expr": "quantileLogNormal(datum.p, mean, sd)"
        },
        {
          "type": "dotbin",
          "field": "value",
          "step": {"signal": "step"}
        },
        {
          "type": "stack",
          "groupby": ["bin"]
        },
        {
          "type": "extent",
          "field": "y1",
          "signal": "ext"
        }
      ]
    }
  ],

  "scales": [
    {
      "name": "x",
      "domain": [0, 30],
      "range": "width"
    },
    {
      "name": "y",
      "domain": {"signal": "[0, height / size]"},
      "range": "height"
    }
  ],

  "axes": [
    {"scale": "x", "orient": "bottom"}
  ],

  "marks": [
    {
      "type": "symbol",
      "from": {"data": "quantiles"},
      "encode": {
        "enter": {
          "x": {"scale": "x", "field": "bin"},
          "y": {"scale": "y", "signal": "datum.y0 + 0.5"},
          "size": {"signal": "area"}
        },
        "update": {
          "fill": {"signal": "datum.bin < select ? 'firebrick' : 'steelblue'"}
        }
      }
    },
    {
      "type": "rule",
      "interactive": false,
      "encode": {
        "update": {
          "x": {"scale": "x", "signal": "select"},
          "y": {"value": 0},
          "y2": {"signal": "height"},
          "stroke": {"signal": "select ? '#ccc': 'transparent'"}
        }
      }
    },
    {
      "type": "text",
      "interactive": false,
      "encode": {
        "enter": {
          "baseline": {"value": "top"},
          "dx": {"value": 3},
          "y": {"value": 2}
        },
        "update": {
          "x": {"scale": "x", "signal": "select"},
          "text": {"signal": "format(cumulativeLogNormal(select, mean, sd), '.1%')"},
          "fill": {"signal": "select ? '#000': 'transparent'"}
        }
      }
    }
  ]
}\n{
  "$schema": "https://vega.github.io/schema/vega/v5.json",
  "description": "A quantile dot plot conveying the uncertainty of bus arrival times.",
  "width": 400,
  "height": 90,
  "padding": 5,

  "signals": [
    {
      "name": "quantiles", "value": 20,
      "bind": {"input": "range", "min": 10, "max": 200, "step": 1}
    },
    {"name": "mean", "update": "log(11.4)"},
    {"name": "sd", "value": 0.2},
    {"name": "step", "update": "1.25 * sqrt(20 / quantiles)"},
    {"name": "size", "update": "scale('x', step) - scale('x', 0)"},
    {"name": "area", "update": "size * size"},
    {
      "name": "select", "init": "quantileLogNormal(0.05, mean, sd)",
      "on": [
        {
          "events": "click, [pointerdown, window:pointerup] > pointermove",
          "update": "clamp(invert('x', x()), 0.0001, 30)"
        },
        {
          "events": "dblclick",
          "update": "0"
        }
      ]
    }
  ],

  "data": [
    {
      "name": "quantiles",
      "transform": [
        {
          "type": "sequence", "as": "p",
          "start": {"signal": "0.5 / quantiles"},
          "step": {"signal": "1 / quantiles"},
          "stop": 1
        },
        {
          "type": "formula", "as": "value",
          "expr": "quantileLogNormal(datum.p, mean, sd)"
        },
        {
          "type": "dotbin",
          "field": "value",
          "step": {"signal": "step"}
        },
        {
          "type": "stack",
          "groupby": ["bin"]
        },
        {
          "type": "extent",
          "field": "y1",
          "signal": "ext"
        }
      ]
    }
  ],

  "scales": [
    {
      "name": "x",
      "domain": [0, 30],
      "range": "width"
    },
    {
      "name": "y",
      "domain": {"signal": "[0, height / size]"},
      "range": "height"
    }
  ],

  "axes": [
    {"scale": "x", "orient": "bottom"}
  ],

  "marks": [
    {
      "type": "symbol",
      "from": {"data": "quantiles"},
      "encode": {
        "enter": {
          "x": {"scale": "x", "field": "bin"},
          "y": {"scale": "y", "signal": "datum.y0 + 0.5"},
          "size": {"signal": "area"}
        },
        "update": {
          "fill": {"signal": "datum.bin < select ? 'firebrick' : 'steelblue'"}
        }
      }
    },
    {
      "type": "rule",
      "interactive": false,
      "encode": {
        "update": {
          "x": {"scale": "x", "signal": "select"},
          "y": {"value": 0},
          "y2": {"signal": "height"},
          "stroke": {"signal": "select ? '#ccc': 'transparent'"}
        }
      }
    },
    {
      "type": "text",
      "interactive": false,
      "encode": {
        "enter": {
          "baseline": {"value": "top"},
          "dx": {"value": 3},
          "y": {"value": 2}
        },
        "update": {
          "x": {"scale": "x", "signal": "select"},
          "text": {"signal": "format(cumulativeLogNormal(select, mean, sd), '.1%')"},
          "fill": {"signal": "select ? '#000': 'transparent'"}
        }
      }
    }
  ]
}\n"https://vega.github.io/schema/vega/v5.json"\n"A quantile dot plot conveying the uncertainty of bus arrival times."\n"1.25 * sqrt(20 / quantiles)"\n"scale('x', step) - scale('x', 0)"\n"quantileLogNormal(0.05, mean, sd)"\n"click, [pointerdown, window:pointerup] > pointermove"\n"clamp(invert('x', x()), 0.0001, 30)"\n"quantileLogNormal(datum.p, mean, sd)"\n"datum.bin < select ? 'firebrick' : 'steelblue'"\n"select ? '#ccc': 'transparent'"\n"format(cumulativeLogNormal(select, mean, sd), '.1%')"\n"select ? '#000': 'transparent'"\n\n\nVega
            
              Vega-Lite
              Altair
              Vega-Lite API
            
          
          
            
              Examples
              Tutorials
              Documentation
              Usage
              About
            
            
              GitHub
              Try Online
            
          
        
      

      
        

  
  
    Hypothetical Outcome Plots (HOPs) Example
    Rather than showing a continuous probability distribution, Hypothetical Outcome Plots (or HOPs) visualize a set of draws from a distribution, where each draw is shown as a new plot in either a small multiples or animated form. Here we use Vega’s timer event to produce animated frames.

This example – inspired by The New York Times – displays random draws for a simulated time-series of values (these could be sales or employment statistics). The noise signal determines the amount of random variation added to the signal. The trend signal determines the strength of a linear trend, where zero corresponds to no trend at all (a flat uniform distribution). When the noise is high enough, draws from a distribution without any underlying trend may cause us to “hallucinate” interesting variations! Viewing the different frames may help viewers get a more visceral sense of random variation.




  
  View Source
  Export PNG
  Export SVG






  View in Online Vega Editor


Vega JSON Specification <>

{
  "$schema": "https://vega.github.io/schema/vega/v5.json",
  "description": "A hypothetical outcome plot that uses animated samples to convey uncertainty.",
  "width": 300,
  "height": 200,

  "signals": [
    { "name": "baseline", "value": 5 },
    {
      "name": "noise", "value": 2,
      "bind": {"input": "range", "min": 0, "max": 4, "step": 0.1}
    },
    {
      "name": "trend", "value": 0,
      "bind": {"input": "range", "min": -1, "max": 1, "step": 0.1}
    },
    {
      "name": "sample", "value": 1,
      "on": [
        {
          "events": "timer{1000}",
          "update": "1 + ((sample + 1) % 3)"
        }
      ]
    }
  ],

  "data": [
    {
      "name": "steps",
      "transform": [
        {
          "type": "sequence",
          "start": 0, "stop": 12, "step": 1
        },
        {
          "type": "formula", "as": "month",
          "expr": "timeFormat(datetime(2015, datum.data, 1), '%b')"
        },
        {
          "type": "formula", "as": "value",
          "expr": "clamp(sample && (baseline - 0.5 * trend * (5.5 - datum.data) + noise * (2 * random() - 1)), 0, 10)"
        }
      ]
    }
  ],

  "scales": [
    {
      "name": "xscale", "type": "band",
      "domain": {"data": "steps", "field": "month"},
      "range": "width"
    },
    {
      "name": "yscale", "type": "linear",
      "domain": [0, 10],
      "range": "height"
    }
  ],

  "axes": [
    {"orient": "left", "scale": "yscale"},
    {"orient": "bottom", "scale": "xscale"}
  ],

  "marks": [
    {
      "type": "rect",
      "from": {"data": "steps"},
      "encode":{
        "enter": {
          "x": {"scale": "xscale", "field": "month"},
          "width": {"scale": "xscale", "band": 1, "offset": -1},
          "fill": {"value": "steelblue"}
        },
        "update": {
          "y": {"scale": "yscale", "field": "value"},
          "y2": {"scale": "yscale", "value": 0}
        }
      }
    }
  ]
}\nVega
            
              Vega-Lite
              Altair
              Vega-Lite API\nVega-Lite
              Altair
              Vega-Lite API\nExamples
              Tutorials
              Documentation
              Usage
              About
            
            
              GitHub
              Try Online\nExamples
              Tutorials
              Documentation
              Usage
              About\nGitHub
              Try Online\nHypothetical Outcome Plots (HOPs) Example
    Rather than showing a continuous probability distribution, Hypothetical Outcome Plots (or HOPs) visualize a set of draws from a distribution, where each draw is shown as a new plot in either a small multiples or animated form. Here we use Vega’s timer event to produce animated frames.

This example – inspired by The New York Times – displays random draws for a simulated time-series of values (these could be sales or employment statistics). The noise signal determines the amount of random variation added to the signal. The trend signal determines the strength of a linear trend, where zero corresponds to no trend at all (a flat uniform distribution). When the noise is high enough, draws from a distribution without any underlying trend may cause us to “hallucinate” interesting variations! Viewing the different frames may help viewers get a more visceral sense of random variation.




  
  View Source
  Export PNG
  Export SVG






  View in Online Vega Editor


Vega JSON Specification <>

{
  "$schema": "https://vega.github.io/schema/vega/v5.json",
  "description": "A hypothetical outcome plot that uses animated samples to convey uncertainty.",
  "width": 300,
  "height": 200,

  "signals": [
    { "name": "baseline", "value": 5 },
    {
      "name": "noise", "value": 2,
      "bind": {"input": "range", "min": 0, "max": 4, "step": 0.1}
    },
    {
      "name": "trend", "value": 0,
      "bind": {"input": "range", "min": -1, "max": 1, "step": 0.1}
    },
    {
      "name": "sample", "value": 1,
      "on": [
        {
          "events": "timer{1000}",
          "update": "1 + ((sample + 1) % 3)"
        }
      ]
    }
  ],

  "data": [
    {
      "name": "steps",
      "transform": [
        {
          "type": "sequence",
          "start": 0, "stop": 12, "step": 1
        },
        {
          "type": "formula", "as": "month",
          "expr": "timeFormat(datetime(2015, datum.data, 1), '%b')"
        },
        {
          "type": "formula", "as": "value",
          "expr": "clamp(sample && (baseline - 0.5 * trend * (5.5 - datum.data) + noise * (2 * random() - 1)), 0, 10)"
        }
      ]
    }
  ],

  "scales": [
    {
      "name": "xscale", "type": "band",
      "domain": {"data": "steps", "field": "month"},
      "range": "width"
    },
    {
      "name": "yscale", "type": "linear",
      "domain": [0, 10],
      "range": "height"
    }
  ],

  "axes": [
    {"orient": "left", "scale": "yscale"},
    {"orient": "bottom", "scale": "xscale"}
  ],

  "marks": [
    {
      "type": "rect",
      "from": {"data": "steps"},
      "encode":{
        "enter": {
          "x": {"scale": "xscale", "field": "month"},
          "width": {"scale": "xscale", "band": 1, "offset": -1},
          "fill": {"value": "steelblue"}
        },
        "update": {
          "y": {"scale": "yscale", "field": "value"},
          "y2": {"scale": "yscale", "value": 0}
        }
      }
    }
  ]
}\nHypothetical Outcome Plots (HOPs) Example\nRather than showing a continuous probability distribution, Hypothetical Outcome Plots (or HOPs) visualize a set of draws from a distribution, where each draw is shown as a new plot in either a small multiples or animated form. Here we use Vega’s timer event to produce animated frames.\nHypothetical Outcome Plots (or HOPs)\nThis example – inspired by The New York Times – displays random draws for a simulated time-series of values (these could be sales or employment statistics). The noise signal determines the amount of random variation added to the signal. The trend signal determines the strength of a linear trend, where zero corresponds to no trend at all (a flat uniform distribution). When the noise is high enough, draws from a distribution without any underlying trend may cause us to “hallucinate” interesting variations! Viewing the different frames may help viewers get a more visceral sense of random variation.\ninspired by The New York Times\nView Source
  Export PNG
  Export SVG\nView Source
  Export PNG
  Export SVG\nView in Online Vega Editor\nView in Online Vega Editor\nVega JSON Specification <>\n{
  "$schema": "https://vega.github.io/schema/vega/v5.json",
  "description": "A hypothetical outcome plot that uses animated samples to convey uncertainty.",
  "width": 300,
  "height": 200,

  "signals": [
    { "name": "baseline", "value": 5 },
    {
      "name": "noise", "value": 2,
      "bind": {"input": "range", "min": 0, "max": 4, "step": 0.1}
    },
    {
      "name": "trend", "value": 0,
      "bind": {"input": "range", "min": -1, "max": 1, "step": 0.1}
    },
    {
      "name": "sample", "value": 1,
      "on": [
        {
          "events": "timer{1000}",
          "update": "1 + ((sample + 1) % 3)"
        }
      ]
    }
  ],

  "data": [
    {
      "name": "steps",
      "transform": [
        {
          "type": "sequence",
          "start": 0, "stop": 12, "step": 1
        },
        {
          "type": "formula", "as": "month",
          "expr": "timeFormat(datetime(2015, datum.data, 1), '%b')"
        },
        {
          "type": "formula", "as": "value",
          "expr": "clamp(sample && (baseline - 0.5 * trend * (5.5 - datum.data) + noise * (2 * random() - 1)), 0, 10)"
        }
      ]
    }
  ],

  "scales": [
    {
      "name": "xscale", "type": "band",
      "domain": {"data": "steps", "field": "month"},
      "range": "width"
    },
    {
      "name": "yscale", "type": "linear",
      "domain": [0, 10],
      "range": "height"
    }
  ],

  "axes": [
    {"orient": "left", "scale": "yscale"},
    {"orient": "bottom", "scale": "xscale"}
  ],

  "marks": [
    {
      "type": "rect",
      "from": {"data": "steps"},
      "encode":{
        "enter": {
          "x": {"scale": "xscale", "field": "month"},
          "width": {"scale": "xscale", "band": 1, "offset": -1},
          "fill": {"value": "steelblue"}
        },
        "update": {
          "y": {"scale": "yscale", "field": "value"},
          "y2": {"scale": "yscale", "value": 0}
        }
      }
    }
  ]
}\n{
  "$schema": "https://vega.github.io/schema/vega/v5.json",
  "description": "A hypothetical outcome plot that uses animated samples to convey uncertainty.",
  "width": 300,
  "height": 200,

  "signals": [
    { "name": "baseline", "value": 5 },
    {
      "name": "noise", "value": 2,
      "bind": {"input": "range", "min": 0, "max": 4, "step": 0.1}
    },
    {
      "name": "trend", "value": 0,
      "bind": {"input": "range", "min": -1, "max": 1, "step": 0.1}
    },
    {
      "name": "sample", "value": 1,
      "on": [
        {
          "events": "timer{1000}",
          "update": "1 + ((sample + 1) % 3)"
        }
      ]
    }
  ],

  "data": [
    {
      "name": "steps",
      "transform": [
        {
          "type": "sequence",
          "start": 0, "stop": 12, "step": 1
        },
        {
          "type": "formula", "as": "month",
          "expr": "timeFormat(datetime(2015, datum.data, 1), '%b')"
        },
        {
          "type": "formula", "as": "value",
          "expr": "clamp(sample && (baseline - 0.5 * trend * (5.5 - datum.data) + noise * (2 * random() - 1)), 0, 10)"
        }
      ]
    }
  ],

  "scales": [
    {
      "name": "xscale", "type": "band",
      "domain": {"data": "steps", "field": "month"},
      "range": "width"
    },
    {
      "name": "yscale", "type": "linear",
      "domain": [0, 10],
      "range": "height"
    }
  ],

  "axes": [
    {"orient": "left", "scale": "yscale"},
    {"orient": "bottom", "scale": "xscale"}
  ],

  "marks": [
    {
      "type": "rect",
      "from": {"data": "steps"},
      "encode":{
        "enter": {
          "x": {"scale": "xscale", "field": "month"},
          "width": {"scale": "xscale", "band": 1, "offset": -1},
          "fill": {"value": "steelblue"}
        },
        "update": {
          "y": {"scale": "yscale", "field": "value"},
          "y2": {"scale": "yscale", "value": 0}
        }
      }
    }
  ]
}\n"https://vega.github.io/schema/vega/v5.json"\n"A hypothetical outcome plot that uses animated samples to convey uncertainty."\n"1 + ((sample + 1) % 3)"\n"timeFormat(datetime(2015, datum.data, 1), '%b')"\n"clamp(sample && (baseline - 0.5 * trend * (5.5 - datum.data) + noise * (2 * random() - 1)), 0, 10)"\n\n\nVega
            
              Vega-Lite
              Altair
              Vega-Lite API
            
          
          
            
              Examples
              Tutorials
              Documentation
              Usage
              About
            
            
              GitHub
              Try Online
            
          
        
      

      
        

  
  
    Time Units Example
    Summary statistics for U.S. flight data, interactively grouped by time unit. This example demonstrates the use of the timeunit transform, in conjunction with the timeSequence and timeUnitSpecifier expression functions, to flexibly process and format date-time data.




  
  View Source
  Export PNG
  Export SVG






  View in Online Vega Editor


Vega JSON Specification <>

{
  "$schema": "https://vega.github.io/schema/vega/v5.json",
  "description": "A bar chart of flight statistics, aggregated by the selected time unit.",
  "width": 600,
  "height": 300,
  "padding": 5,
  "autosize": {"type": "fit", "resize": true, "contains": "padding"},

  "title": {
    "text": "U.S. Flight Statistics",
    "subtitle": "20k Sample, January - March 2001",
    "subtitleFontStyle": "italic",
    "frame": "group",
    "anchor": "start",
    "offset": 10
  },

  "signals": [
    {
      "name": "timeunit", "value": ["day"],
      "bind": {"input": "select", "options": [
        ["year"], ["month"], ["date"], ["day"], ["hours"]
      ]}
    },
    {
      "name": "measure", "value": "delay",
      "bind": {"input": "select", "options": ["count", "delay"]}
    },
    {
      "name": "title",
      "update": "measure == 'delay' ? 'Average Delay (min)' : 'Number of Flights'"
    }
  ],

  "data": [
    {
      "name": "flights",
      "url": "data/flights-20k.json",
      "format": {"type": "json", "parse": "auto"},
      "transform": [
        {
          "type": "timeunit",
          "field": "date",
          "units": {"signal": "timeunit"},
          "signal": "tbin"
        },
        {
          "type": "aggregate",
          "groupby": ["unit0"],
          "ops": ["count", "average"],
          "fields": [null, "delay"],
          "as": ["count", "delay"]
        }
      ]
    }
  ],

  "scales": [
    {
      "name": "xscale",
      "type": "band",
      "range": "width",
      "padding": 0.05,
      "round": true,
      "domain": {"signal": "timeSequence(tbin.unit, tbin.start, tbin.stop)"}
    },
    {
      "name": "yscale",
      "type": "linear",
      "range": "height",
      "domain": {"data": "flights", "field": {"signal": "measure"}},
      "zero": true,
      "nice": true
    }
  ],

  "axes": [
    { "orient": "bottom", "scale": "xscale",
      "formatType": "time", "format": {"signal": "timeUnitSpecifier(tbin.units, {hours: '%H'})"} },
    { "orient": "left", "scale": "yscale", "tickCount": 7,
      "title": {"signal": "title"} }
  ],

  "marks": [
    {
      "type": "rect",
      "from": {"data": "flights"},
      "encode": {
        "update": {
          "x": {"scale": "xscale", "field": "unit0"},
          "width": {"scale": "xscale", "band": 1},
          "y": {"scale": "yscale", "field": {"signal": "measure"}},
          "y2": {"scale": "yscale", "value": 0},
          "fill": {"value": "steelblue"},
          "tooltip": {"signal": "{timeunit: timeFormat(datum.unit0, timeUnitSpecifier(tbin.units)), count: format(datum.count, ',') + ' flights', delay: format(datum.delay, '.1f') + ' min (avg)'}"}
        },
        "hover": {
          "fill": {"value": "firebrick"}
        }
      }
    }
  ]
}\nVega
            
              Vega-Lite
              Altair
              Vega-Lite API\nVega-Lite
              Altair
              Vega-Lite API\nExamples
              Tutorials
              Documentation
              Usage
              About
            
            
              GitHub
              Try Online\nExamples
              Tutorials
              Documentation
              Usage
              About\nGitHub
              Try Online\nTime Units Example
    Summary statistics for U.S. flight data, interactively grouped by time unit. This example demonstrates the use of the timeunit transform, in conjunction with the timeSequence and timeUnitSpecifier expression functions, to flexibly process and format date-time data.




  
  View Source
  Export PNG
  Export SVG






  View in Online Vega Editor


Vega JSON Specification <>

{
  "$schema": "https://vega.github.io/schema/vega/v5.json",
  "description": "A bar chart of flight statistics, aggregated by the selected time unit.",
  "width": 600,
  "height": 300,
  "padding": 5,
  "autosize": {"type": "fit", "resize": true, "contains": "padding"},

  "title": {
    "text": "U.S. Flight Statistics",
    "subtitle": "20k Sample, January - March 2001",
    "subtitleFontStyle": "italic",
    "frame": "group",
    "anchor": "start",
    "offset": 10
  },

  "signals": [
    {
      "name": "timeunit", "value": ["day"],
      "bind": {"input": "select", "options": [
        ["year"], ["month"], ["date"], ["day"], ["hours"]
      ]}
    },
    {
      "name": "measure", "value": "delay",
      "bind": {"input": "select", "options": ["count", "delay"]}
    },
    {
      "name": "title",
      "update": "measure == 'delay' ? 'Average Delay (min)' : 'Number of Flights'"
    }
  ],

  "data": [
    {
      "name": "flights",
      "url": "data/flights-20k.json",
      "format": {"type": "json", "parse": "auto"},
      "transform": [
        {
          "type": "timeunit",
          "field": "date",
          "units": {"signal": "timeunit"},
          "signal": "tbin"
        },
        {
          "type": "aggregate",
          "groupby": ["unit0"],
          "ops": ["count", "average"],
          "fields": [null, "delay"],
          "as": ["count", "delay"]
        }
      ]
    }
  ],

  "scales": [
    {
      "name": "xscale",
      "type": "band",
      "range": "width",
      "padding": 0.05,
      "round": true,
      "domain": {"signal": "timeSequence(tbin.unit, tbin.start, tbin.stop)"}
    },
    {
      "name": "yscale",
      "type": "linear",
      "range": "height",
      "domain": {"data": "flights", "field": {"signal": "measure"}},
      "zero": true,
      "nice": true
    }
  ],

  "axes": [
    { "orient": "bottom", "scale": "xscale",
      "formatType": "time", "format": {"signal": "timeUnitSpecifier(tbin.units, {hours: '%H'})"} },
    { "orient": "left", "scale": "yscale", "tickCount": 7,
      "title": {"signal": "title"} }
  ],

  "marks": [
    {
      "type": "rect",
      "from": {"data": "flights"},
      "encode": {
        "update": {
          "x": {"scale": "xscale", "field": "unit0"},
          "width": {"scale": "xscale", "band": 1},
          "y": {"scale": "yscale", "field": {"signal": "measure"}},
          "y2": {"scale": "yscale", "value": 0},
          "fill": {"value": "steelblue"},
          "tooltip": {"signal": "{timeunit: timeFormat(datum.unit0, timeUnitSpecifier(tbin.units)), count: format(datum.count, ',') + ' flights', delay: format(datum.delay, '.1f') + ' min (avg)'}"}
        },
        "hover": {
          "fill": {"value": "firebrick"}
        }
      }
    }
  ]
}\nSummary statistics for U.S. flight data, interactively grouped by time unit. This example demonstrates the use of the timeunit transform, in conjunction with the timeSequence and timeUnitSpecifier expression functions, to flexibly process and format date-time data.\nView Source
  Export PNG
  Export SVG\nView Source
  Export PNG
  Export SVG\nView in Online Vega Editor\nView in Online Vega Editor\nVega JSON Specification <>\n{
  "$schema": "https://vega.github.io/schema/vega/v5.json",
  "description": "A bar chart of flight statistics, aggregated by the selected time unit.",
  "width": 600,
  "height": 300,
  "padding": 5,
  "autosize": {"type": "fit", "resize": true, "contains": "padding"},

  "title": {
    "text": "U.S. Flight Statistics",
    "subtitle": "20k Sample, January - March 2001",
    "subtitleFontStyle": "italic",
    "frame": "group",
    "anchor": "start",
    "offset": 10
  },

  "signals": [
    {
      "name": "timeunit", "value": ["day"],
      "bind": {"input": "select", "options": [
        ["year"], ["month"], ["date"], ["day"], ["hours"]
      ]}
    },
    {
      "name": "measure", "value": "delay",
      "bind": {"input": "select", "options": ["count", "delay"]}
    },
    {
      "name": "title",
      "update": "measure == 'delay' ? 'Average Delay (min)' : 'Number of Flights'"
    }
  ],

  "data": [
    {
      "name": "flights",
      "url": "data/flights-20k.json",
      "format": {"type": "json", "parse": "auto"},
      "transform": [
        {
          "type": "timeunit",
          "field": "date",
          "units": {"signal": "timeunit"},
          "signal": "tbin"
        },
        {
          "type": "aggregate",
          "groupby": ["unit0"],
          "ops": ["count", "average"],
          "fields": [null, "delay"],
          "as": ["count", "delay"]
        }
      ]
    }
  ],

  "scales": [
    {
      "name": "xscale",
      "type": "band",
      "range": "width",
      "padding": 0.05,
      "round": true,
      "domain": {"signal": "timeSequence(tbin.unit, tbin.start, tbin.stop)"}
    },
    {
      "name": "yscale",
      "type": "linear",
      "range": "height",
      "domain": {"data": "flights", "field": {"signal": "measure"}},
      "zero": true,
      "nice": true
    }
  ],

  "axes": [
    { "orient": "bottom", "scale": "xscale",
      "formatType": "time", "format": {"signal": "timeUnitSpecifier(tbin.units, {hours: '%H'})"} },
    { "orient": "left", "scale": "yscale", "tickCount": 7,
      "title": {"signal": "title"} }
  ],

  "marks": [
    {
      "type": "rect",
      "from": {"data": "flights"},
      "encode": {
        "update": {
          "x": {"scale": "xscale", "field": "unit0"},
          "width": {"scale": "xscale", "band": 1},
          "y": {"scale": "yscale", "field": {"signal": "measure"}},
          "y2": {"scale": "yscale", "value": 0},
          "fill": {"value": "steelblue"},
          "tooltip": {"signal": "{timeunit: timeFormat(datum.unit0, timeUnitSpecifier(tbin.units)), count: format(datum.count, ',') + ' flights', delay: format(datum.delay, '.1f') + ' min (avg)'}"}
        },
        "hover": {
          "fill": {"value": "firebrick"}
        }
      }
    }
  ]
}\n{
  "$schema": "https://vega.github.io/schema/vega/v5.json",
  "description": "A bar chart of flight statistics, aggregated by the selected time unit.",
  "width": 600,
  "height": 300,
  "padding": 5,
  "autosize": {"type": "fit", "resize": true, "contains": "padding"},

  "title": {
    "text": "U.S. Flight Statistics",
    "subtitle": "20k Sample, January - March 2001",
    "subtitleFontStyle": "italic",
    "frame": "group",
    "anchor": "start",
    "offset": 10
  },

  "signals": [
    {
      "name": "timeunit", "value": ["day"],
      "bind": {"input": "select", "options": [
        ["year"], ["month"], ["date"], ["day"], ["hours"]
      ]}
    },
    {
      "name": "measure", "value": "delay",
      "bind": {"input": "select", "options": ["count", "delay"]}
    },
    {
      "name": "title",
      "update": "measure == 'delay' ? 'Average Delay (min)' : 'Number of Flights'"
    }
  ],

  "data": [
    {
      "name": "flights",
      "url": "data/flights-20k.json",
      "format": {"type": "json", "parse": "auto"},
      "transform": [
        {
          "type": "timeunit",
          "field": "date",
          "units": {"signal": "timeunit"},
          "signal": "tbin"
        },
        {
          "type": "aggregate",
          "groupby": ["unit0"],
          "ops": ["count", "average"],
          "fields": [null, "delay"],
          "as": ["count", "delay"]
        }
      ]
    }
  ],

  "scales": [
    {
      "name": "xscale",
      "type": "band",
      "range": "width",
      "padding": 0.05,
      "round": true,
      "domain": {"signal": "timeSequence(tbin.unit, tbin.start, tbin.stop)"}
    },
    {
      "name": "yscale",
      "type": "linear",
      "range": "height",
      "domain": {"data": "flights", "field": {"signal": "measure"}},
      "zero": true,
      "nice": true
    }
  ],

  "axes": [
    { "orient": "bottom", "scale": "xscale",
      "formatType": "time", "format": {"signal": "timeUnitSpecifier(tbin.units, {hours: '%H'})"} },
    { "orient": "left", "scale": "yscale", "tickCount": 7,
      "title": {"signal": "title"} }
  ],

  "marks": [
    {
      "type": "rect",
      "from": {"data": "flights"},
      "encode": {
        "update": {
          "x": {"scale": "xscale", "field": "unit0"},
          "width": {"scale": "xscale", "band": 1},
          "y": {"scale": "yscale", "field": {"signal": "measure"}},
          "y2": {"scale": "yscale", "value": 0},
          "fill": {"value": "steelblue"},
          "tooltip": {"signal": "{timeunit: timeFormat(datum.unit0, timeUnitSpecifier(tbin.units)), count: format(datum.count, ',') + ' flights', delay: format(datum.delay, '.1f') + ' min (avg)'}"}
        },
        "hover": {
          "fill": {"value": "firebrick"}
        }
      }
    }
  ]
}\n"https://vega.github.io/schema/vega/v5.json"\n"A bar chart of flight statistics, aggregated by the selected time unit."\n"U.S. Flight Statistics"\n"20k Sample, January - March 2001"\n"measure == 'delay' ? 'Average Delay (min)' : 'Number of Flights'"\n"data/flights-20k.json"\n"timeSequence(tbin.unit, tbin.start, tbin.stop)"\n"timeUnitSpecifier(tbin.units, {hours: '%H'})"\n"{timeunit: timeFormat(datum.unit0, timeUnitSpecifier(tbin.units)), count: format(datum.count, ',') + ' flights', delay: format(datum.delay, '.1f') + ' min (avg)'}"\n\n\nVega
            
              Vega-Lite
              Altair
              Vega-Lite API
            
          
          
            
              Examples
              Tutorials
              Documentation
              Usage
              About
            
            
              GitHub
              Try Online
            
          
        
      

      
        

  
  
    County Unemployment Example
    A choropleth map of 2009 U.S. unemployment rates by county. A quantize scale is used to divide the color range into seven discrete, uniformly-spaced bins.




  
  View Source
  Export PNG
  Export SVG






  View in Online Vega Editor


Vega JSON Specification <>

{
  "$schema": "https://vega.github.io/schema/vega/v5.json",
  "description": "A choropleth map depicting U.S. unemployment rates by county in 2009.",
  "width": 960,
  "height": 500,
  "autosize": "none",

  "data": [
    {
      "name": "unemp",
      "url": "data/unemployment.tsv",
      "format": {"type": "tsv", "parse": "auto"}
    },
    {
      "name": "counties",
      "url": "data/us-10m.json",
      "format": {"type": "topojson", "feature": "counties"},
      "transform": [
        { "type": "lookup", "from": "unemp", "key": "id", "fields": ["id"], "values": ["rate"] },
        { "type": "filter", "expr": "datum.rate != null" }
      ]
    }
  ],

  "projections": [
    {
      "name": "projection",
      "type": "albersUsa"
    }
  ],

  "scales": [
    {
      "name": "color",
      "type": "quantize",
      "domain": [0, 0.15],
      "range": {"scheme": "blues", "count": 7}
    }
  ],

  "legends": [
    {
      "fill": "color",
      "orient": "bottom-right",
      "title": "Unemployment",
      "format": "0.1%"
    }
  ],

  "marks": [
    {
      "type": "shape",
      "from": {"data": "counties"},
      "encode": {
        "enter": { "tooltip": {"signal": "format(datum.rate, '0.1%')"}},
        "update": { "fill": {"scale": "color", "field": "rate"} },
        "hover": { "fill": {"value": "red"} }
      },
      "transform": [
        { "type": "geoshape", "projection": "projection" }
      ]
    }
  ]
}\nVega
            
              Vega-Lite
              Altair
              Vega-Lite API\nVega-Lite
              Altair
              Vega-Lite API\nExamples
              Tutorials
              Documentation
              Usage
              About
            
            
              GitHub
              Try Online\nExamples
              Tutorials
              Documentation
              Usage
              About\nGitHub
              Try Online\nCounty Unemployment Example
    A choropleth map of 2009 U.S. unemployment rates by county. A quantize scale is used to divide the color range into seven discrete, uniformly-spaced bins.




  
  View Source
  Export PNG
  Export SVG






  View in Online Vega Editor


Vega JSON Specification <>

{
  "$schema": "https://vega.github.io/schema/vega/v5.json",
  "description": "A choropleth map depicting U.S. unemployment rates by county in 2009.",
  "width": 960,
  "height": 500,
  "autosize": "none",

  "data": [
    {
      "name": "unemp",
      "url": "data/unemployment.tsv",
      "format": {"type": "tsv", "parse": "auto"}
    },
    {
      "name": "counties",
      "url": "data/us-10m.json",
      "format": {"type": "topojson", "feature": "counties"},
      "transform": [
        { "type": "lookup", "from": "unemp", "key": "id", "fields": ["id"], "values": ["rate"] },
        { "type": "filter", "expr": "datum.rate != null" }
      ]
    }
  ],

  "projections": [
    {
      "name": "projection",
      "type": "albersUsa"
    }
  ],

  "scales": [
    {
      "name": "color",
      "type": "quantize",
      "domain": [0, 0.15],
      "range": {"scheme": "blues", "count": 7}
    }
  ],

  "legends": [
    {
      "fill": "color",
      "orient": "bottom-right",
      "title": "Unemployment",
      "format": "0.1%"
    }
  ],

  "marks": [
    {
      "type": "shape",
      "from": {"data": "counties"},
      "encode": {
        "enter": { "tooltip": {"signal": "format(datum.rate, '0.1%')"}},
        "update": { "fill": {"scale": "color", "field": "rate"} },
        "hover": { "fill": {"value": "red"} }
      },
      "transform": [
        { "type": "geoshape", "projection": "projection" }
      ]
    }
  ]
}\nCounty Unemployment Example\nA choropleth map of 2009 U.S. unemployment rates by county. A quantize scale is used to divide the color range into seven discrete, uniformly-spaced bins.\nView Source
  Export PNG
  Export SVG\nView Source
  Export PNG
  Export SVG\nView in Online Vega Editor\nView in Online Vega Editor\nVega JSON Specification <>\n{
  "$schema": "https://vega.github.io/schema/vega/v5.json",
  "description": "A choropleth map depicting U.S. unemployment rates by county in 2009.",
  "width": 960,
  "height": 500,
  "autosize": "none",

  "data": [
    {
      "name": "unemp",
      "url": "data/unemployment.tsv",
      "format": {"type": "tsv", "parse": "auto"}
    },
    {
      "name": "counties",
      "url": "data/us-10m.json",
      "format": {"type": "topojson", "feature": "counties"},
      "transform": [
        { "type": "lookup", "from": "unemp", "key": "id", "fields": ["id"], "values": ["rate"] },
        { "type": "filter", "expr": "datum.rate != null" }
      ]
    }
  ],

  "projections": [
    {
      "name": "projection",
      "type": "albersUsa"
    }
  ],

  "scales": [
    {
      "name": "color",
      "type": "quantize",
      "domain": [0, 0.15],
      "range": {"scheme": "blues", "count": 7}
    }
  ],

  "legends": [
    {
      "fill": "color",
      "orient": "bottom-right",
      "title": "Unemployment",
      "format": "0.1%"
    }
  ],

  "marks": [
    {
      "type": "shape",
      "from": {"data": "counties"},
      "encode": {
        "enter": { "tooltip": {"signal": "format(datum.rate, '0.1%')"}},
        "update": { "fill": {"scale": "color", "field": "rate"} },
        "hover": { "fill": {"value": "red"} }
      },
      "transform": [
        { "type": "geoshape", "projection": "projection" }
      ]
    }
  ]
}\n{
  "$schema": "https://vega.github.io/schema/vega/v5.json",
  "description": "A choropleth map depicting U.S. unemployment rates by county in 2009.",
  "width": 960,
  "height": 500,
  "autosize": "none",

  "data": [
    {
      "name": "unemp",
      "url": "data/unemployment.tsv",
      "format": {"type": "tsv", "parse": "auto"}
    },
    {
      "name": "counties",
      "url": "data/us-10m.json",
      "format": {"type": "topojson", "feature": "counties"},
      "transform": [
        { "type": "lookup", "from": "unemp", "key": "id", "fields": ["id"], "values": ["rate"] },
        { "type": "filter", "expr": "datum.rate != null" }
      ]
    }
  ],

  "projections": [
    {
      "name": "projection",
      "type": "albersUsa"
    }
  ],

  "scales": [
    {
      "name": "color",
      "type": "quantize",
      "domain": [0, 0.15],
      "range": {"scheme": "blues", "count": 7}
    }
  ],

  "legends": [
    {
      "fill": "color",
      "orient": "bottom-right",
      "title": "Unemployment",
      "format": "0.1%"
    }
  ],

  "marks": [
    {
      "type": "shape",
      "from": {"data": "counties"},
      "encode": {
        "enter": { "tooltip": {"signal": "format(datum.rate, '0.1%')"}},
        "update": { "fill": {"scale": "color", "field": "rate"} },
        "hover": { "fill": {"value": "red"} }
      },
      "transform": [
        { "type": "geoshape", "projection": "projection" }
      ]
    }
  ]
}\n"https://vega.github.io/schema/vega/v5.json"\n"A choropleth map depicting U.S. unemployment rates by county in 2009."\n"data/unemployment.tsv"\n"format(datum.rate, '0.1%')"\n\n\nVega
            
              Vega-Lite
              Altair
              Vega-Lite API
            
          
          
            
              Examples
              Tutorials
              Documentation
              Usage
              About
            
            
              GitHub
              Try Online
            
          
        
      

      
        

  
  
    Dorling Cartogram Example
    A Dorling cartogram is a thematic map that uses sized circles to represent a quantity of interest per geographic region. This example visualizes the ratio of obese adults (BMI >= 30) by U.S. state in 1995. A redundant encoding uses both circle area and fill color to convey the obesity rate. Vega’s force transform and geoCentroid expression function are used to compute the layout.




  
  View Source
  Export PNG
  Export SVG






  View in Online Vega Editor


Vega JSON Specification <>

{
  "$schema": "https://vega.github.io/schema/vega/v5.json",
  "description": "A Dorling cartogram depicting U.S. state obesity rates.",
  "width": 900,
  "height": 520,
  "autosize": "none",

  "config": {
    "legend": {
      "gradientDirection": "horizontal",
      "gradientLength": 120,
      "gradientThickness": 10
    }
  },

  "data": [
    {
      "name": "states",
      "url": "data/us-10m.json",
      "format": {"type": "topojson", "feature": "states"}
    },
    {
      "name": "obesity",
      "url": "data/obesity.json",
      "transform": [
        {
          "type": "lookup",
          "from": "states", "key": "id",
          "fields": ["id"], "as": ["geo"]
        },
        {
          "type": "filter",
          "expr": "datum.geo"
        },
        {
          "type": "formula", "as": "centroid",
          "expr": "geoCentroid('projection', datum.geo)"
        }
      ]
    }
  ],

  "projections": [
    {
      "name": "projection",
      "type": "albersUsa",
      "scale": 1100,
      "translate": [{"signal": "width / 2"}, {"signal": "height / 2"}]
    }
  ],

  "scales": [
    {
      "name": "size",
      "domain": {"data": "obesity", "field": "rate"},
      "zero": false,
      "range": [1000, 5000]
    },
    {
      "name": "color",
      "type": "linear",
      "nice": true,
      "domain": {"data": "obesity", "field": "rate"},
      "range": "ramp"
    }
  ],

  "legends": [
    {
      "title": "% of Obese Adults",
      "orient": "bottom-right",
      "type": "symbol",
      "size": "size",
      "fill": "color",
      "format": ".1%",
      "clipHeight": 16
    }
  ],

  "marks": [
    {
      "name": "circles",
      "type": "symbol",
      "from": {"data": "obesity"},
      "encode": {
        "enter": {
          "size": {"scale": "size", "field": "rate"},
          "fill": {"scale": "color", "field": "rate"},
          "stroke": {"value": "white"},
          "strokeWidth": {"value": 1.5},
          "x": {"field": "centroid[0]"},
          "y": {"field": "centroid[1]"},
          "tooltip": {"signal": "'Obesity Rate: ' + format(datum.rate, '.1%')"}
        }
      },
      "transform": [
        {
          "type": "force",
          "static": true,
          "forces": [
            {"force": "collide", "radius": {"expr": "1 + sqrt(datum.size) / 2"}},
            {"force": "x", "x": "datum.centroid[0]"},
            {"force": "y", "y": "datum.centroid[1]"}
          ]
        }
      ]
    },
    {
      "type": "text",
      "interactive": false,
      "from": {"data": "circles"},
      "encode": {
        "enter": {
          "align": {"value": "center"},
          "baseline": {"value": "middle"},
          "fontSize": {"value": 13},
          "fontWeight": {"value": "bold"},
          "text": {"field": "datum.state"}
        },
        "update": {
          "x": {"field": "x"},
          "y": {"field": "y"}
        }
      }
    }
  ]
}\nVega
            
              Vega-Lite
              Altair
              Vega-Lite API\nVega-Lite
              Altair
              Vega-Lite API\nExamples
              Tutorials
              Documentation
              Usage
              About
            
            
              GitHub
              Try Online\nExamples
              Tutorials
              Documentation
              Usage
              About\nGitHub
              Try Online\nDorling Cartogram Example
    A Dorling cartogram is a thematic map that uses sized circles to represent a quantity of interest per geographic region. This example visualizes the ratio of obese adults (BMI >= 30) by U.S. state in 1995. A redundant encoding uses both circle area and fill color to convey the obesity rate. Vega’s force transform and geoCentroid expression function are used to compute the layout.




  
  View Source
  Export PNG
  Export SVG






  View in Online Vega Editor


Vega JSON Specification <>

{
  "$schema": "https://vega.github.io/schema/vega/v5.json",
  "description": "A Dorling cartogram depicting U.S. state obesity rates.",
  "width": 900,
  "height": 520,
  "autosize": "none",

  "config": {
    "legend": {
      "gradientDirection": "horizontal",
      "gradientLength": 120,
      "gradientThickness": 10
    }
  },

  "data": [
    {
      "name": "states",
      "url": "data/us-10m.json",
      "format": {"type": "topojson", "feature": "states"}
    },
    {
      "name": "obesity",
      "url": "data/obesity.json",
      "transform": [
        {
          "type": "lookup",
          "from": "states", "key": "id",
          "fields": ["id"], "as": ["geo"]
        },
        {
          "type": "filter",
          "expr": "datum.geo"
        },
        {
          "type": "formula", "as": "centroid",
          "expr": "geoCentroid('projection', datum.geo)"
        }
      ]
    }
  ],

  "projections": [
    {
      "name": "projection",
      "type": "albersUsa",
      "scale": 1100,
      "translate": [{"signal": "width / 2"}, {"signal": "height / 2"}]
    }
  ],

  "scales": [
    {
      "name": "size",
      "domain": {"data": "obesity", "field": "rate"},
      "zero": false,
      "range": [1000, 5000]
    },
    {
      "name": "color",
      "type": "linear",
      "nice": true,
      "domain": {"data": "obesity", "field": "rate"},
      "range": "ramp"
    }
  ],

  "legends": [
    {
      "title": "% of Obese Adults",
      "orient": "bottom-right",
      "type": "symbol",
      "size": "size",
      "fill": "color",
      "format": ".1%",
      "clipHeight": 16
    }
  ],

  "marks": [
    {
      "name": "circles",
      "type": "symbol",
      "from": {"data": "obesity"},
      "encode": {
        "enter": {
          "size": {"scale": "size", "field": "rate"},
          "fill": {"scale": "color", "field": "rate"},
          "stroke": {"value": "white"},
          "strokeWidth": {"value": 1.5},
          "x": {"field": "centroid[0]"},
          "y": {"field": "centroid[1]"},
          "tooltip": {"signal": "'Obesity Rate: ' + format(datum.rate, '.1%')"}
        }
      },
      "transform": [
        {
          "type": "force",
          "static": true,
          "forces": [
            {"force": "collide", "radius": {"expr": "1 + sqrt(datum.size) / 2"}},
            {"force": "x", "x": "datum.centroid[0]"},
            {"force": "y", "y": "datum.centroid[1]"}
          ]
        }
      ]
    },
    {
      "type": "text",
      "interactive": false,
      "from": {"data": "circles"},
      "encode": {
        "enter": {
          "align": {"value": "center"},
          "baseline": {"value": "middle"},
          "fontSize": {"value": 13},
          "fontWeight": {"value": "bold"},
          "text": {"field": "datum.state"}
        },
        "update": {
          "x": {"field": "x"},
          "y": {"field": "y"}
        }
      }
    }
  ]
}\nDorling Cartogram Example\nA Dorling cartogram is a thematic map that uses sized circles to represent a quantity of interest per geographic region. This example visualizes the ratio of obese adults (BMI >= 30) by U.S. state in 1995. A redundant encoding uses both circle area and fill color to convey the obesity rate. Vega’s force transform and geoCentroid expression function are used to compute the layout.\nView Source
  Export PNG
  Export SVG\nView Source
  Export PNG
  Export SVG\nView in Online Vega Editor\nView in Online Vega Editor\nVega JSON Specification <>\n{
  "$schema": "https://vega.github.io/schema/vega/v5.json",
  "description": "A Dorling cartogram depicting U.S. state obesity rates.",
  "width": 900,
  "height": 520,
  "autosize": "none",

  "config": {
    "legend": {
      "gradientDirection": "horizontal",
      "gradientLength": 120,
      "gradientThickness": 10
    }
  },

  "data": [
    {
      "name": "states",
      "url": "data/us-10m.json",
      "format": {"type": "topojson", "feature": "states"}
    },
    {
      "name": "obesity",
      "url": "data/obesity.json",
      "transform": [
        {
          "type": "lookup",
          "from": "states", "key": "id",
          "fields": ["id"], "as": ["geo"]
        },
        {
          "type": "filter",
          "expr": "datum.geo"
        },
        {
          "type": "formula", "as": "centroid",
          "expr": "geoCentroid('projection', datum.geo)"
        }
      ]
    }
  ],

  "projections": [
    {
      "name": "projection",
      "type": "albersUsa",
      "scale": 1100,
      "translate": [{"signal": "width / 2"}, {"signal": "height / 2"}]
    }
  ],

  "scales": [
    {
      "name": "size",
      "domain": {"data": "obesity", "field": "rate"},
      "zero": false,
      "range": [1000, 5000]
    },
    {
      "name": "color",
      "type": "linear",
      "nice": true,
      "domain": {"data": "obesity", "field": "rate"},
      "range": "ramp"
    }
  ],

  "legends": [
    {
      "title": "% of Obese Adults",
      "orient": "bottom-right",
      "type": "symbol",
      "size": "size",
      "fill": "color",
      "format": ".1%",
      "clipHeight": 16
    }
  ],

  "marks": [
    {
      "name": "circles",
      "type": "symbol",
      "from": {"data": "obesity"},
      "encode": {
        "enter": {
          "size": {"scale": "size", "field": "rate"},
          "fill": {"scale": "color", "field": "rate"},
          "stroke": {"value": "white"},
          "strokeWidth": {"value": 1.5},
          "x": {"field": "centroid[0]"},
          "y": {"field": "centroid[1]"},
          "tooltip": {"signal": "'Obesity Rate: ' + format(datum.rate, '.1%')"}
        }
      },
      "transform": [
        {
          "type": "force",
          "static": true,
          "forces": [
            {"force": "collide", "radius": {"expr": "1 + sqrt(datum.size) / 2"}},
            {"force": "x", "x": "datum.centroid[0]"},
            {"force": "y", "y": "datum.centroid[1]"}
          ]
        }
      ]
    },
    {
      "type": "text",
      "interactive": false,
      "from": {"data": "circles"},
      "encode": {
        "enter": {
          "align": {"value": "center"},
          "baseline": {"value": "middle"},
          "fontSize": {"value": 13},
          "fontWeight": {"value": "bold"},
          "text": {"field": "datum.state"}
        },
        "update": {
          "x": {"field": "x"},
          "y": {"field": "y"}
        }
      }
    }
  ]
}\n{
  "$schema": "https://vega.github.io/schema/vega/v5.json",
  "description": "A Dorling cartogram depicting U.S. state obesity rates.",
  "width": 900,
  "height": 520,
  "autosize": "none",

  "config": {
    "legend": {
      "gradientDirection": "horizontal",
      "gradientLength": 120,
      "gradientThickness": 10
    }
  },

  "data": [
    {
      "name": "states",
      "url": "data/us-10m.json",
      "format": {"type": "topojson", "feature": "states"}
    },
    {
      "name": "obesity",
      "url": "data/obesity.json",
      "transform": [
        {
          "type": "lookup",
          "from": "states", "key": "id",
          "fields": ["id"], "as": ["geo"]
        },
        {
          "type": "filter",
          "expr": "datum.geo"
        },
        {
          "type": "formula", "as": "centroid",
          "expr": "geoCentroid('projection', datum.geo)"
        }
      ]
    }
  ],

  "projections": [
    {
      "name": "projection",
      "type": "albersUsa",
      "scale": 1100,
      "translate": [{"signal": "width / 2"}, {"signal": "height / 2"}]
    }
  ],

  "scales": [
    {
      "name": "size",
      "domain": {"data": "obesity", "field": "rate"},
      "zero": false,
      "range": [1000, 5000]
    },
    {
      "name": "color",
      "type": "linear",
      "nice": true,
      "domain": {"data": "obesity", "field": "rate"},
      "range": "ramp"
    }
  ],

  "legends": [
    {
      "title": "% of Obese Adults",
      "orient": "bottom-right",
      "type": "symbol",
      "size": "size",
      "fill": "color",
      "format": ".1%",
      "clipHeight": 16
    }
  ],

  "marks": [
    {
      "name": "circles",
      "type": "symbol",
      "from": {"data": "obesity"},
      "encode": {
        "enter": {
          "size": {"scale": "size", "field": "rate"},
          "fill": {"scale": "color", "field": "rate"},
          "stroke": {"value": "white"},
          "strokeWidth": {"value": 1.5},
          "x": {"field": "centroid[0]"},
          "y": {"field": "centroid[1]"},
          "tooltip": {"signal": "'Obesity Rate: ' + format(datum.rate, '.1%')"}
        }
      },
      "transform": [
        {
          "type": "force",
          "static": true,
          "forces": [
            {"force": "collide", "radius": {"expr": "1 + sqrt(datum.size) / 2"}},
            {"force": "x", "x": "datum.centroid[0]"},
            {"force": "y", "y": "datum.centroid[1]"}
          ]
        }
      ]
    },
    {
      "type": "text",
      "interactive": false,
      "from": {"data": "circles"},
      "encode": {
        "enter": {
          "align": {"value": "center"},
          "baseline": {"value": "middle"},
          "fontSize": {"value": 13},
          "fontWeight": {"value": "bold"},
          "text": {"field": "datum.state"}
        },
        "update": {
          "x": {"field": "x"},
          "y": {"field": "y"}
        }
      }
    }
  ]
}\n"https://vega.github.io/schema/vega/v5.json"\n"A Dorling cartogram depicting U.S. state obesity rates."\n"geoCentroid('projection', datum.geo)"\n"'Obesity Rate: ' + format(datum.rate, '.1%')"\n"1 + sqrt(datum.size) / 2"\n\n\nVega
            
              Vega-Lite
              Altair
              Vega-Lite API
            
          
          
            
              Examples
              Tutorials
              Documentation
              Usage
              About
            
            
              GitHub
              Try Online
            
          
        
      

      
        

  
  
    World Map Example
    A configurable map of world countries. Explore the results of applying different map projections and parameter settings! This example loads TopoJSON data and applies the Vega geoshape and graticule transforms.




  
  View Source
  Export PNG
  Export SVG






  View in Online Vega Editor


Vega JSON Specification <>

{
  "$schema": "https://vega.github.io/schema/vega/v5.json",
  "description": "A configurable map of countries of the world.",
  "width": 900,
  "height": 500,
  "autosize": "none",

  "signals": [
    {
      "name": "type",
      "value": "mercator",
      "bind": {
        "input": "select",
        "options": [
          "albers",
          "albersUsa",
          "azimuthalEqualArea",
          "azimuthalEquidistant",
          "conicConformal",
          "conicEqualArea",
          "conicEquidistant",
          "equalEarth",
          "equirectangular",
          "gnomonic",
          "mercator",
          "naturalEarth1",
          "orthographic",
          "stereographic",
          "transverseMercator"
        ]
      }
    },
    { "name": "scale", "value": 150,
      "bind": {"input": "range", "min": 50, "max": 2000, "step": 1} },
    { "name": "rotate0", "value": 0,
      "bind": {"input": "range", "min": -180, "max": 180, "step": 1} },
    { "name": "rotate1", "value": 0,
      "bind": {"input": "range", "min": -90, "max": 90, "step": 1} },
    { "name": "rotate2", "value": 0,
      "bind": {"input": "range", "min": -180, "max": 180, "step": 1} },
    { "name": "center0", "value": 0,
      "bind": {"input": "range", "min": -180, "max": 180, "step": 1} },
    { "name": "center1", "value": 0,
      "bind": {"input": "range", "min": -90, "max": 90, "step": 1} },
    { "name": "translate0", "update": "width / 2" },
    { "name": "translate1", "update": "height / 2" },

    { "name": "graticuleDash", "value": 0,
      "bind": {"input": "radio", "options": [0, 3, 5, 10]} },
    { "name": "borderWidth", "value": 1,
      "bind": {"input": "text"} },
    { "name": "background", "value": "#ffffff",
      "bind": {"input": "color"} },
    { "name": "invert", "value": false,
      "bind": {"input": "checkbox"} }
  ],

  "projections": [
    {
      "name": "projection",
      "type": {"signal": "type"},
      "scale": {"signal": "scale"},
      "rotate": [
        {"signal": "rotate0"},
        {"signal": "rotate1"},
        {"signal": "rotate2"}
      ],
      "center": [
        {"signal": "center0"},
        {"signal": "center1"}
      ],
      "translate": [
        {"signal": "translate0"},
        {"signal": "translate1"}
      ]
    }
  ],

  "data": [
    {
      "name": "world",
      "url": "data/world-110m.json",
      "format": {
        "type": "topojson",
        "feature": "countries"
      }
    },
    {
      "name": "graticule",
      "transform": [
        { "type": "graticule" }
      ]
    }
  ],

  "marks": [
    {
      "type": "shape",
      "from": {"data": "graticule"},
      "encode": {
        "update": {
          "strokeWidth": {"value": 1},
          "strokeDash": {"signal": "[+graticuleDash, +graticuleDash]"},
          "stroke": {"signal": "invert ? '#444' : '#ddd'"},
          "fill": {"value": null}
        }
      },
      "transform": [
        { "type": "geoshape", "projection": "projection" }
      ]
    },
    {
      "type": "shape",
      "from": {"data": "world"},
      "encode": {
        "update": {
          "strokeWidth": {"signal": "+borderWidth"},
          "stroke": {"signal": "invert ? '#777' : '#bbb'"},
          "fill": {"signal": "invert ? '#fff' : '#000'"},
          "zindex": {"value": 0}
        },
        "hover": {
          "strokeWidth": {"signal": "+borderWidth + 1"},
          "stroke": {"value": "firebrick"},
          "zindex": {"value": 1}
        }
      },
      "transform": [
        { "type": "geoshape", "projection": "projection" }
      ]
    }
  ]
}\nVega
            
              Vega-Lite
              Altair
              Vega-Lite API\nVega-Lite
              Altair
              Vega-Lite API\nExamples
              Tutorials
              Documentation
              Usage
              About
            
            
              GitHub
              Try Online\nExamples
              Tutorials
              Documentation
              Usage
              About\nGitHub
              Try Online\nWorld Map Example
    A configurable map of world countries. Explore the results of applying different map projections and parameter settings! This example loads TopoJSON data and applies the Vega geoshape and graticule transforms.




  
  View Source
  Export PNG
  Export SVG






  View in Online Vega Editor


Vega JSON Specification <>

{
  "$schema": "https://vega.github.io/schema/vega/v5.json",
  "description": "A configurable map of countries of the world.",
  "width": 900,
  "height": 500,
  "autosize": "none",

  "signals": [
    {
      "name": "type",
      "value": "mercator",
      "bind": {
        "input": "select",
        "options": [
          "albers",
          "albersUsa",
          "azimuthalEqualArea",
          "azimuthalEquidistant",
          "conicConformal",
          "conicEqualArea",
          "conicEquidistant",
          "equalEarth",
          "equirectangular",
          "gnomonic",
          "mercator",
          "naturalEarth1",
          "orthographic",
          "stereographic",
          "transverseMercator"
        ]
      }
    },
    { "name": "scale", "value": 150,
      "bind": {"input": "range", "min": 50, "max": 2000, "step": 1} },
    { "name": "rotate0", "value": 0,
      "bind": {"input": "range", "min": -180, "max": 180, "step": 1} },
    { "name": "rotate1", "value": 0,
      "bind": {"input": "range", "min": -90, "max": 90, "step": 1} },
    { "name": "rotate2", "value": 0,
      "bind": {"input": "range", "min": -180, "max": 180, "step": 1} },
    { "name": "center0", "value": 0,
      "bind": {"input": "range", "min": -180, "max": 180, "step": 1} },
    { "name": "center1", "value": 0,
      "bind": {"input": "range", "min": -90, "max": 90, "step": 1} },
    { "name": "translate0", "update": "width / 2" },
    { "name": "translate1", "update": "height / 2" },

    { "name": "graticuleDash", "value": 0,
      "bind": {"input": "radio", "options": [0, 3, 5, 10]} },
    { "name": "borderWidth", "value": 1,
      "bind": {"input": "text"} },
    { "name": "background", "value": "#ffffff",
      "bind": {"input": "color"} },
    { "name": "invert", "value": false,
      "bind": {"input": "checkbox"} }
  ],

  "projections": [
    {
      "name": "projection",
      "type": {"signal": "type"},
      "scale": {"signal": "scale"},
      "rotate": [
        {"signal": "rotate0"},
        {"signal": "rotate1"},
        {"signal": "rotate2"}
      ],
      "center": [
        {"signal": "center0"},
        {"signal": "center1"}
      ],
      "translate": [
        {"signal": "translate0"},
        {"signal": "translate1"}
      ]
    }
  ],

  "data": [
    {
      "name": "world",
      "url": "data/world-110m.json",
      "format": {
        "type": "topojson",
        "feature": "countries"
      }
    },
    {
      "name": "graticule",
      "transform": [
        { "type": "graticule" }
      ]
    }
  ],

  "marks": [
    {
      "type": "shape",
      "from": {"data": "graticule"},
      "encode": {
        "update": {
          "strokeWidth": {"value": 1},
          "strokeDash": {"signal": "[+graticuleDash, +graticuleDash]"},
          "stroke": {"signal": "invert ? '#444' : '#ddd'"},
          "fill": {"value": null}
        }
      },
      "transform": [
        { "type": "geoshape", "projection": "projection" }
      ]
    },
    {
      "type": "shape",
      "from": {"data": "world"},
      "encode": {
        "update": {
          "strokeWidth": {"signal": "+borderWidth"},
          "stroke": {"signal": "invert ? '#777' : '#bbb'"},
          "fill": {"signal": "invert ? '#fff' : '#000'"},
          "zindex": {"value": 0}
        },
        "hover": {
          "strokeWidth": {"signal": "+borderWidth + 1"},
          "stroke": {"value": "firebrick"},
          "zindex": {"value": 1}
        }
      },
      "transform": [
        { "type": "geoshape", "projection": "projection" }
      ]
    }
  ]
}\nA configurable map of world countries. Explore the results of applying different map projections and parameter settings! This example loads TopoJSON data and applies the Vega geoshape and graticule transforms.\nView Source
  Export PNG
  Export SVG\nView Source
  Export PNG
  Export SVG\nView in Online Vega Editor\nView in Online Vega Editor\nVega JSON Specification <>\n{
  "$schema": "https://vega.github.io/schema/vega/v5.json",
  "description": "A configurable map of countries of the world.",
  "width": 900,
  "height": 500,
  "autosize": "none",

  "signals": [
    {
      "name": "type",
      "value": "mercator",
      "bind": {
        "input": "select",
        "options": [
          "albers",
          "albersUsa",
          "azimuthalEqualArea",
          "azimuthalEquidistant",
          "conicConformal",
          "conicEqualArea",
          "conicEquidistant",
          "equalEarth",
          "equirectangular",
          "gnomonic",
          "mercator",
          "naturalEarth1",
          "orthographic",
          "stereographic",
          "transverseMercator"
        ]
      }
    },
    { "name": "scale", "value": 150,
      "bind": {"input": "range", "min": 50, "max": 2000, "step": 1} },
    { "name": "rotate0", "value": 0,
      "bind": {"input": "range", "min": -180, "max": 180, "step": 1} },
    { "name": "rotate1", "value": 0,
      "bind": {"input": "range", "min": -90, "max": 90, "step": 1} },
    { "name": "rotate2", "value": 0,
      "bind": {"input": "range", "min": -180, "max": 180, "step": 1} },
    { "name": "center0", "value": 0,
      "bind": {"input": "range", "min": -180, "max": 180, "step": 1} },
    { "name": "center1", "value": 0,
      "bind": {"input": "range", "min": -90, "max": 90, "step": 1} },
    { "name": "translate0", "update": "width / 2" },
    { "name": "translate1", "update": "height / 2" },

    { "name": "graticuleDash", "value": 0,
      "bind": {"input": "radio", "options": [0, 3, 5, 10]} },
    { "name": "borderWidth", "value": 1,
      "bind": {"input": "text"} },
    { "name": "background", "value": "#ffffff",
      "bind": {"input": "color"} },
    { "name": "invert", "value": false,
      "bind": {"input": "checkbox"} }
  ],

  "projections": [
    {
      "name": "projection",
      "type": {"signal": "type"},
      "scale": {"signal": "scale"},
      "rotate": [
        {"signal": "rotate0"},
        {"signal": "rotate1"},
        {"signal": "rotate2"}
      ],
      "center": [
        {"signal": "center0"},
        {"signal": "center1"}
      ],
      "translate": [
        {"signal": "translate0"},
        {"signal": "translate1"}
      ]
    }
  ],

  "data": [
    {
      "name": "world",
      "url": "data/world-110m.json",
      "format": {
        "type": "topojson",
        "feature": "countries"
      }
    },
    {
      "name": "graticule",
      "transform": [
        { "type": "graticule" }
      ]
    }
  ],

  "marks": [
    {
      "type": "shape",
      "from": {"data": "graticule"},
      "encode": {
        "update": {
          "strokeWidth": {"value": 1},
          "strokeDash": {"signal": "[+graticuleDash, +graticuleDash]"},
          "stroke": {"signal": "invert ? '#444' : '#ddd'"},
          "fill": {"value": null}
        }
      },
      "transform": [
        { "type": "geoshape", "projection": "projection" }
      ]
    },
    {
      "type": "shape",
      "from": {"data": "world"},
      "encode": {
        "update": {
          "strokeWidth": {"signal": "+borderWidth"},
          "stroke": {"signal": "invert ? '#777' : '#bbb'"},
          "fill": {"signal": "invert ? '#fff' : '#000'"},
          "zindex": {"value": 0}
        },
        "hover": {
          "strokeWidth": {"signal": "+borderWidth + 1"},
          "stroke": {"value": "firebrick"},
          "zindex": {"value": 1}
        }
      },
      "transform": [
        { "type": "geoshape", "projection": "projection" }
      ]
    }
  ]
}\n{
  "$schema": "https://vega.github.io/schema/vega/v5.json",
  "description": "A configurable map of countries of the world.",
  "width": 900,
  "height": 500,
  "autosize": "none",

  "signals": [
    {
      "name": "type",
      "value": "mercator",
      "bind": {
        "input": "select",
        "options": [
          "albers",
          "albersUsa",
          "azimuthalEqualArea",
          "azimuthalEquidistant",
          "conicConformal",
          "conicEqualArea",
          "conicEquidistant",
          "equalEarth",
          "equirectangular",
          "gnomonic",
          "mercator",
          "naturalEarth1",
          "orthographic",
          "stereographic",
          "transverseMercator"
        ]
      }
    },
    { "name": "scale", "value": 150,
      "bind": {"input": "range", "min": 50, "max": 2000, "step": 1} },
    { "name": "rotate0", "value": 0,
      "bind": {"input": "range", "min": -180, "max": 180, "step": 1} },
    { "name": "rotate1", "value": 0,
      "bind": {"input": "range", "min": -90, "max": 90, "step": 1} },
    { "name": "rotate2", "value": 0,
      "bind": {"input": "range", "min": -180, "max": 180, "step": 1} },
    { "name": "center0", "value": 0,
      "bind": {"input": "range", "min": -180, "max": 180, "step": 1} },
    { "name": "center1", "value": 0,
      "bind": {"input": "range", "min": -90, "max": 90, "step": 1} },
    { "name": "translate0", "update": "width / 2" },
    { "name": "translate1", "update": "height / 2" },

    { "name": "graticuleDash", "value": 0,
      "bind": {"input": "radio", "options": [0, 3, 5, 10]} },
    { "name": "borderWidth", "value": 1,
      "bind": {"input": "text"} },
    { "name": "background", "value": "#ffffff",
      "bind": {"input": "color"} },
    { "name": "invert", "value": false,
      "bind": {"input": "checkbox"} }
  ],

  "projections": [
    {
      "name": "projection",
      "type": {"signal": "type"},
      "scale": {"signal": "scale"},
      "rotate": [
        {"signal": "rotate0"},
        {"signal": "rotate1"},
        {"signal": "rotate2"}
      ],
      "center": [
        {"signal": "center0"},
        {"signal": "center1"}
      ],
      "translate": [
        {"signal": "translate0"},
        {"signal": "translate1"}
      ]
    }
  ],

  "data": [
    {
      "name": "world",
      "url": "data/world-110m.json",
      "format": {
        "type": "topojson",
        "feature": "countries"
      }
    },
    {
      "name": "graticule",
      "transform": [
        { "type": "graticule" }
      ]
    }
  ],

  "marks": [
    {
      "type": "shape",
      "from": {"data": "graticule"},
      "encode": {
        "update": {
          "strokeWidth": {"value": 1},
          "strokeDash": {"signal": "[+graticuleDash, +graticuleDash]"},
          "stroke": {"signal": "invert ? '#444' : '#ddd'"},
          "fill": {"value": null}
        }
      },
      "transform": [
        { "type": "geoshape", "projection": "projection" }
      ]
    },
    {
      "type": "shape",
      "from": {"data": "world"},
      "encode": {
        "update": {
          "strokeWidth": {"signal": "+borderWidth"},
          "stroke": {"signal": "invert ? '#777' : '#bbb'"},
          "fill": {"signal": "invert ? '#fff' : '#000'"},
          "zindex": {"value": 0}
        },
        "hover": {
          "strokeWidth": {"signal": "+borderWidth + 1"},
          "stroke": {"value": "firebrick"},
          "zindex": {"value": 1}
        }
      },
      "transform": [
        { "type": "geoshape", "projection": "projection" }
      ]
    }
  ]
}\n"https://vega.github.io/schema/vega/v5.json"\n"A configurable map of countries of the world."\n"azimuthalEquidistant"\n"data/world-110m.json"\n"[+graticuleDash, +graticuleDash]"\n"invert ? '#444' : '#ddd'"\n"invert ? '#777' : '#bbb'"\n"invert ? '#fff' : '#000'"\n\n\n