Selections and transitionsCreate, update, and animate the DOM based on data without the overhead of a virtual DOM.Scales and axesEncode abstract data into visual values such as position, size, and color. Explain position encodings with axes.ShapesRender arcs, areas, curves, lines, links, pies, stacks, symbols… and any geometric primitive you might need to visualize data.InteractionsFacilitate exploration with reusable interactive behaviors, including panning, zooming, brushing, and dragging.LayoutsTreemaps, trees, force-directed graphs, Voronoi, contours, chords, circle-packing… a library of layout algorithms at the ready.Geographic mapsMore spherical projections than you can shake a stick at, with arbitrary aspects, adaptive sampling, and flexible clipping.… and much more!CSV parsing, localized date parsing and formatting, color spaces, calendar math, statistics, and can I stop listing features now?Powering Observable PlotThe D3 team also builds Observable Plot, a high-level API for quick charts built on top of D3.Try Observable Plot Built by ObservableD3 is developed by Observable, the platform for collaborative data analysis.Visit Observable\n\nSearchK7.9.0GitHub️ 110.0k\n\nD3The JavaScript library for bespoke data visualizationCreate custom dynamic visualizations with unparalleled flexibilityGet startedWhat is D3?Examples\n\n\n\nSelections and transitionsCreate, update, and animate the DOM based on data without the overhead of a virtual DOM.Scales and axesEncode abstract data into visual values such as position, size, and color. Explain position encodings with axes.ShapesRender arcs, areas, curves, lines, links, pies, stacks, symbols… and any geometric primitive you might need to visualize data.InteractionsFacilitate exploration with reusable interactive behaviors, including panning, zooming, brushing, and dragging.LayoutsTreemaps, trees, force-directed graphs, Voronoi, contours, chords, circle-packing… a library of layout algorithms at the ready.Geographic mapsMore spherical projections than you can shake a stick at, with arbitrary aspects, adaptive sampling, and flexible clipping.… and much more!CSV parsing, localized date parsing and formatting, color spaces, calendar math, statistics, and can I stop listing features now?Powering Observable PlotThe D3 team also builds Observable Plot, a high-level API for quick charts built on top of D3.Try Observable Plot Built by ObservableD3 is developed by Observable, the platform for collaborative data analysis.Visit Observable\n\nSearchK7.9.0GitHub️ 110.0k\n\nD3The JavaScript library for bespoke data visualizationCreate custom dynamic visualizations with unparalleled flexibilityGet startedWhat is D3?Examples\n\n\n\nGetting started ​D3 works in any JavaScript environment.Try D3 online ​The fastest way to get started (and get help) with D3 is on Observable! D3 is available by default in notebooks as part of Observable’s standard library. To create something with D3, return the generated DOM element from a cell. Here is a blank chart to get you started:js{
  // Declare the chart dimensions and margins.
  const width = 640;
  const height = 400;
  const marginTop = 20;
  const marginRight = 20;
  const marginBottom = 30;
  const marginLeft = 40;

  // Declare the x (horizontal position) scale.
  const x = d3.scaleUtc()
      .domain([new Date("2023-01-01"), new Date("2024-01-01")])
      .range([marginLeft, width - marginRight]);

  // Declare the y (vertical position) scale.
  const y = d3.scaleLinear()
      .domain([0, 100])
      .range([height - marginBottom, marginTop]);

  // Create the SVG container.
  const svg = d3.create("svg")
      .attr("width", width)
      .attr("height", height);

  // Add the x-axis.
  svg.append("g")
      .attr("transform", `translate(0,${height - marginBottom})`)
      .call(d3.axisBottom(x));

  // Add the y-axis.
  svg.append("g")
      .attr("transform", `translate(${marginLeft},0)`)
      .call(d3.axisLeft(y));

  // Return the SVG element.
  return svg.node();
}As a more complete example, try one of these starter templates:Area chartBar chartDonut chartHistogramLine chartSee the D3 gallery for more forkable examples.Observable includes a few D3 snippets when you click + to add a cell (type “d3” when the cell menu is open to filter), as well as convenient sample datasets to try out D3 features. Or upload a CSV or JSON file to start playing with your data. You can also fork any of the hundreds of notebooks we’ve published for a head start.Observable is free for public use. Sign up for a Pro account to connect to private databases, collaborate on private notebooks, and more.D3 in vanilla HTML ​In vanilla HTML, you can load D3 from a CDN such as jsDelivr or you can download it locally. We recommend using the CDN-hosted ES module bundle. But for those who need it, we also provide a UMD bundle that exports the d3 global when loaded as a plain script.ESM + CDNUMD + CDNUMD + localhtml<!DOCTYPE html>
<div id="container"></div>
<script type="module">

import * as d3 from "https://cdn.jsdelivr.net/npm/d3@7/+esm";

// Declare the chart dimensions and margins.
const width = 640;
const height = 400;
const marginTop = 20;
const marginRight = 20;
const marginBottom = 30;
const marginLeft = 40;

// Declare the x (horizontal position) scale.
const x = d3.scaleUtc()
    .domain([new Date("2023-01-01"), new Date("2024-01-01")])
    .range([marginLeft, width - marginRight]);

// Declare the y (vertical position) scale.
const y = d3.scaleLinear()
    .domain([0, 100])
    .range([height - marginBottom, marginTop]);

// Create the SVG container.
const svg = d3.create("svg")
    .attr("width", width)
    .attr("height", height);

// Add the x-axis.
svg.append("g")
    .attr("transform", `translate(0,${height - marginBottom})`)
    .call(d3.axisBottom(x));

// Add the y-axis.
svg.append("g")
    .attr("transform", `translate(${marginLeft},0)`)
    .call(d3.axisLeft(y));

// Append the SVG element.
container.append(svg.node());

</script>html<!DOCTYPE html>
<div id="container"></div>
<script src="https://cdn.jsdelivr.net/npm/d3@7"></script>
<script type="module">

// Declare the chart dimensions and margins.
const width = 640;
const height = 400;
const marginTop = 20;
const marginRight = 20;
const marginBottom = 30;
const marginLeft = 40;

// Declare the x (horizontal position) scale.
const x = d3.scaleUtc()
    .domain([new Date("2023-01-01"), new Date("2024-01-01")])
    .range([marginLeft, width - marginRight]);

// Declare the y (vertical position) scale.
const y = d3.scaleLinear()
    .domain([0, 100])
    .range([height - marginBottom, marginTop]);

// Create the SVG container.
const svg = d3.create("svg")
    .attr("width", width)
    .attr("height", height);

// Add the x-axis.
svg.append("g")
    .attr("transform", `translate(0,${height - marginBottom})`)
    .call(d3.axisBottom(x));

// Add the y-axis.
svg.append("g")
    .attr("transform", `translate(${marginLeft},0)`)
    .call(d3.axisLeft(y));

// Append the SVG element.
container.append(svg.node());

</script>html<!DOCTYPE html>
<div id="container"></div>
<script src="d3.js"></script>
<script type="module">

// Declare the chart dimensions and margins.
const width = 640;
const height = 400;
const marginTop = 20;
const marginRight = 20;
const marginBottom = 30;
const marginLeft = 40;

// Declare the x (horizontal position) scale.
const x = d3.scaleUtc()
    .domain([new Date("2023-01-01"), new Date("2024-01-01")])
    .range([marginLeft, width - marginRight]);

// Declare the y (vertical position) scale.
const y = d3.scaleLinear()
    .domain([0, 100])
    .range([height - marginBottom, marginTop]);

// Create the SVG container.
const svg = d3.create("svg")
    .attr("width", width)
    .attr("height", height);

// Add the x-axis.
svg.append("g")
    .attr("transform", `translate(0,${height - marginBottom})`)
    .call(d3.axisBottom(x));

// Add the y-axis.
svg.append("g")
    .attr("transform", `translate(${marginLeft},0)`)
    .call(d3.axisLeft(y));

// Append the SVG element.
container.append(svg.node());

</script>You can also import and destructure individual D3 modules like so:html<script type="module">

import {forceSimulation, forceCollide, forceX} from "https://cdn.jsdelivr.net/npm/d3-force@3/+esm";

const nodes = [{}, {}];
const simulation = forceSimulation(nodes)
    .force("x", forceX())
    .force("collide", forceCollide(5))
    .on("tick", () => console.log(nodes[0].x));

</script>If you’d prefer to run D3 locally (or offline), you can download the UMD bundles of D3 here:d3.v7.jsd3.v7.min.jsThen, create an index.html file as shown above in the UMD + local tab. Use the non-minified bundle for debugging, and the minified bundle for faster performance in production.Installing from npm ​If you’re developing a web application using Node, you can install D3 via yarn, npm, pnpm, or your preferred package manager.yarnnpmpnpmbashyarn add d3bashnpm install d3bashpnpm add d3You can then load D3 into your app as:jsimport * as d3 from "d3";You can instead import specific symbols if you prefer:jsimport {select, selectAll} from "d3";Alternatively you can install and import from D3 submodules:jsimport {mean, median} from "d3-array";TypeScript declarations are available via DefinitelyTyped.D3 in React ​Most D3 modules (including d3-scale, d3-array, d3-interpolate, and d3-format) don’t interact with the DOM, so there is no difference when using them in React. You can use them in JSX for purely declarative visualization, such as the line plot below.LinePlot.jsxjsximport * as d3 from "d3";

export default function LinePlot({
  data,
  width = 640,
  height = 400,
  marginTop = 20,
  marginRight = 20,
  marginBottom = 20,
  marginLeft = 20
}) {
  const x = d3.scaleLinear([0, data.length - 1], [marginLeft, width - marginRight]);
  const y = d3.scaleLinear(d3.extent(data), [height - marginBottom, marginTop]);
  const line = d3.line((d, i) => x(i), y);
  return (
    <svg width={width} height={height}>
      <path fill="none" stroke="currentColor" strokeWidth="1.5" d={line(data)} />
      <g fill="white" stroke="currentColor" strokeWidth="1.5">
        {data.map((d, i) => (<circle key={i} cx={x(i)} cy={y(d)} r="2.5" />))}
      </g>
    </svg>
  );
}Sandbox ↗︎D3 modules that operate on selections (including d3-selection, d3-transition, and d3-axis) do manipulate the DOM, which competes with React’s virtual DOM. In those cases, you can attach a ref to an element and pass it to D3 in a useEffect hook.LinePlot.jsxjsximport * as d3 from "d3";
import {useRef, useEffect} from "react";

export default function LinePlot({
  data,
  width = 640,
  height = 400,
  marginTop = 20,
  marginRight = 20,
  marginBottom = 30,
  marginLeft = 40
}) {
  const gx = useRef();
  const gy = useRef();
  const x = d3.scaleLinear([0, data.length - 1], [marginLeft, width - marginRight]);
  const y = d3.scaleLinear(d3.extent(data), [height - marginBottom, marginTop]);
  const line = d3.line((d, i) => x(i), y);
  useEffect(() => void d3.select(gx.current).call(d3.axisBottom(x)), [gx, x]);
  useEffect(() => void d3.select(gy.current).call(d3.axisLeft(y)), [gy, y]);
  return (
    <svg width={width} height={height}>
      <g ref={gx} transform={`translate(0,${height - marginBottom})`} />
      <g ref={gy} transform={`translate(${marginLeft},0)`} />
      <path fill="none" stroke="currentColor" strokeWidth="1.5" d={line(data)} />
      <g fill="white" stroke="currentColor" strokeWidth="1.5">
        {data.map((d, i) => (<circle key={i} cx={x(i)} cy={y(d)} r="2.5" />))}
      </g>
    </svg>
  );
}Sandbox ↗︎For more guidance using D3 in React, see Amelia Wattenberger’s post.D3 in Svelte ​As with React, you can use Svelte exclusively for rendering if you like, and only use D3 modules that don’t manipulate the DOM. Here is a line plot of an array of numbers that uses d3-shape and d3-scale.LinePlot.sveltesvelte<script>
  import * as d3 from 'd3';

  export let data;
  export let width = 640;
  export let height = 400;
  export let marginTop = 20;
  export let marginRight = 20;
  export let marginBottom = 20;
  export let marginLeft = 20;

  $: x = d3.scaleLinear([0, data.length - 1], [marginLeft, width - marginRight]);
  $: y = d3.scaleLinear(d3.extent(data), [height - marginBottom, marginTop]);
  $: line = d3.line((d, i) => x(i), y);
</script>
<svg width={width} height={height}>
  <path fill="none" stroke="currentColor" stroke-width="1.5" d={line(data)} />
  <g fill="white" stroke="currentColor" stroke-width="1.5">
    {#each data as d, i}
      <circle key={i} cx={x(i)} cy={y(d)} r="2.5" />
    {/each}
  </g>
</svg>REPL ↗︎Svelte’s reactive statements ($:) pair nicely with D3 data joins for efficient updates. Below, we use them to render dynamic axes as the data changes.LinePlot.sveltesvelte<script>
  import * as d3 from 'd3';

  export let data;
  export let width = 640;
  export let height = 400;
  export let marginTop = 20;
  export let marginRight = 20;
  export let marginBottom = 30;
  export let marginLeft = 40;

  let gx;
  let gy;

  $: x = d3.scaleLinear([0, data.length - 1], [marginLeft, width - marginRight]);
  $: y = d3.scaleLinear(d3.extent(data), [height - marginBottom, marginTop]);
  $: line = d3.line((d, i) => x(i), y);
  $: d3.select(gy).call(d3.axisLeft(y));
  $: d3.select(gx).call(d3.axisBottom(x));
</script>
<svg width={width} height={height}>
  <g bind:this={gx} transform="translate(0,{height - marginBottom})" />
  <g bind:this={gy} transform="translate({marginLeft},0)" />
  <path fill="none" stroke="currentColor" stroke-width="1.5" d={line(data)} />
  <g fill="white" stroke="currentColor" stroke-width="1.5">
    {#each data as d, i}
      <circle key={i} cx={x(i)} cy={y(d)} r="2.5" />
    {/each}
  </g>
</svg>REPL ↗︎\n\nSearchK7.9.0GitHub️ 110.0kOn this pageGetting started ​D3 works in any JavaScript environment.Try D3 online ​The fastest way to get started (and get help) with D3 is on Observable! D3 is available by default in notebooks as part of Observable’s standard library. To create something with D3, return the generated DOM element from a cell. Here is a blank chart to get you started:js{
  // Declare the chart dimensions and margins.
  const width = 640;
  const height = 400;
  const marginTop = 20;
  const marginRight = 20;
  const marginBottom = 30;
  const marginLeft = 40;

  // Declare the x (horizontal position) scale.
  const x = d3.scaleUtc()
      .domain([new Date("2023-01-01"), new Date("2024-01-01")])
      .range([marginLeft, width - marginRight]);

  // Declare the y (vertical position) scale.
  const y = d3.scaleLinear()
      .domain([0, 100])
      .range([height - marginBottom, marginTop]);

  // Create the SVG container.
  const svg = d3.create("svg")
      .attr("width", width)
      .attr("height", height);

  // Add the x-axis.
  svg.append("g")
      .attr("transform", `translate(0,${height - marginBottom})`)
      .call(d3.axisBottom(x));

  // Add the y-axis.
  svg.append("g")
      .attr("transform", `translate(${marginLeft},0)`)
      .call(d3.axisLeft(y));

  // Return the SVG element.
  return svg.node();
}As a more complete example, try one of these starter templates:Area chartBar chartDonut chartHistogramLine chartSee the D3 gallery for more forkable examples.Observable includes a few D3 snippets when you click + to add a cell (type “d3” when the cell menu is open to filter), as well as convenient sample datasets to try out D3 features. Or upload a CSV or JSON file to start playing with your data. You can also fork any of the hundreds of notebooks we’ve published for a head start.Observable is free for public use. Sign up for a Pro account to connect to private databases, collaborate on private notebooks, and more.D3 in vanilla HTML ​In vanilla HTML, you can load D3 from a CDN such as jsDelivr or you can download it locally. We recommend using the CDN-hosted ES module bundle. But for those who need it, we also provide a UMD bundle that exports the d3 global when loaded as a plain script.ESM + CDNUMD + CDNUMD + localhtml<!DOCTYPE html>
<div id="container"></div>
<script type="module">

import * as d3 from "https://cdn.jsdelivr.net/npm/d3@7/+esm";

// Declare the chart dimensions and margins.
const width = 640;
const height = 400;
const marginTop = 20;
const marginRight = 20;
const marginBottom = 30;
const marginLeft = 40;

// Declare the x (horizontal position) scale.
const x = d3.scaleUtc()
    .domain([new Date("2023-01-01"), new Date("2024-01-01")])
    .range([marginLeft, width - marginRight]);

// Declare the y (vertical position) scale.
const y = d3.scaleLinear()
    .domain([0, 100])
    .range([height - marginBottom, marginTop]);

// Create the SVG container.
const svg = d3.create("svg")
    .attr("width", width)
    .attr("height", height);

// Add the x-axis.
svg.append("g")
    .attr("transform", `translate(0,${height - marginBottom})`)
    .call(d3.axisBottom(x));

// Add the y-axis.
svg.append("g")
    .attr("transform", `translate(${marginLeft},0)`)
    .call(d3.axisLeft(y));

// Append the SVG element.
container.append(svg.node());

</script>html<!DOCTYPE html>
<div id="container"></div>
<script src="https://cdn.jsdelivr.net/npm/d3@7"></script>
<script type="module">

// Declare the chart dimensions and margins.
const width = 640;
const height = 400;
const marginTop = 20;
const marginRight = 20;
const marginBottom = 30;
const marginLeft = 40;

// Declare the x (horizontal position) scale.
const x = d3.scaleUtc()
    .domain([new Date("2023-01-01"), new Date("2024-01-01")])
    .range([marginLeft, width - marginRight]);

// Declare the y (vertical position) scale.
const y = d3.scaleLinear()
    .domain([0, 100])
    .range([height - marginBottom, marginTop]);

// Create the SVG container.
const svg = d3.create("svg")
    .attr("width", width)
    .attr("height", height);

// Add the x-axis.
svg.append("g")
    .attr("transform", `translate(0,${height - marginBottom})`)
    .call(d3.axisBottom(x));

// Add the y-axis.
svg.append("g")
    .attr("transform", `translate(${marginLeft},0)`)
    .call(d3.axisLeft(y));

// Append the SVG element.
container.append(svg.node());

</script>html<!DOCTYPE html>
<div id="container"></div>
<script src="d3.js"></script>
<script type="module">

// Declare the chart dimensions and margins.
const width = 640;
const height = 400;
const marginTop = 20;
const marginRight = 20;
const marginBottom = 30;
const marginLeft = 40;

// Declare the x (horizontal position) scale.
const x = d3.scaleUtc()
    .domain([new Date("2023-01-01"), new Date("2024-01-01")])
    .range([marginLeft, width - marginRight]);

// Declare the y (vertical position) scale.
const y = d3.scaleLinear()
    .domain([0, 100])
    .range([height - marginBottom, marginTop]);

// Create the SVG container.
const svg = d3.create("svg")
    .attr("width", width)
    .attr("height", height);

// Add the x-axis.
svg.append("g")
    .attr("transform", `translate(0,${height - marginBottom})`)
    .call(d3.axisBottom(x));

// Add the y-axis.
svg.append("g")
    .attr("transform", `translate(${marginLeft},0)`)
    .call(d3.axisLeft(y));

// Append the SVG element.
container.append(svg.node());

</script>You can also import and destructure individual D3 modules like so:html<script type="module">

import {forceSimulation, forceCollide, forceX} from "https://cdn.jsdelivr.net/npm/d3-force@3/+esm";

const nodes = [{}, {}];
const simulation = forceSimulation(nodes)
    .force("x", forceX())
    .force("collide", forceCollide(5))
    .on("tick", () => console.log(nodes[0].x));

</script>If you’d prefer to run D3 locally (or offline), you can download the UMD bundles of D3 here:d3.v7.jsd3.v7.min.jsThen, create an index.html file as shown above in the UMD + local tab. Use the non-minified bundle for debugging, and the minified bundle for faster performance in production.Installing from npm ​If you’re developing a web application using Node, you can install D3 via yarn, npm, pnpm, or your preferred package manager.yarnnpmpnpmbashyarn add d3bashnpm install d3bashpnpm add d3You can then load D3 into your app as:jsimport * as d3 from "d3";You can instead import specific symbols if you prefer:jsimport {select, selectAll} from "d3";Alternatively you can install and import from D3 submodules:jsimport {mean, median} from "d3-array";TypeScript declarations are available via DefinitelyTyped.D3 in React ​Most D3 modules (including d3-scale, d3-array, d3-interpolate, and d3-format) don’t interact with the DOM, so there is no difference when using them in React. You can use them in JSX for purely declarative visualization, such as the line plot below.LinePlot.jsxjsximport * as d3 from "d3";

export default function LinePlot({
  data,
  width = 640,
  height = 400,
  marginTop = 20,
  marginRight = 20,
  marginBottom = 20,
  marginLeft = 20
}) {
  const x = d3.scaleLinear([0, data.length - 1], [marginLeft, width - marginRight]);
  const y = d3.scaleLinear(d3.extent(data), [height - marginBottom, marginTop]);
  const line = d3.line((d, i) => x(i), y);
  return (
    <svg width={width} height={height}>
      <path fill="none" stroke="currentColor" strokeWidth="1.5" d={line(data)} />
      <g fill="white" stroke="currentColor" strokeWidth="1.5">
        {data.map((d, i) => (<circle key={i} cx={x(i)} cy={y(d)} r="2.5" />))}
      </g>
    </svg>
  );
}Sandbox ↗︎D3 modules that operate on selections (including d3-selection, d3-transition, and d3-axis) do manipulate the DOM, which competes with React’s virtual DOM. In those cases, you can attach a ref to an element and pass it to D3 in a useEffect hook.LinePlot.jsxjsximport * as d3 from "d3";
import {useRef, useEffect} from "react";

export default function LinePlot({
  data,
  width = 640,
  height = 400,
  marginTop = 20,
  marginRight = 20,
  marginBottom = 30,
  marginLeft = 40
}) {
  const gx = useRef();
  const gy = useRef();
  const x = d3.scaleLinear([0, data.length - 1], [marginLeft, width - marginRight]);
  const y = d3.scaleLinear(d3.extent(data), [height - marginBottom, marginTop]);
  const line = d3.line((d, i) => x(i), y);
  useEffect(() => void d3.select(gx.current).call(d3.axisBottom(x)), [gx, x]);
  useEffect(() => void d3.select(gy.current).call(d3.axisLeft(y)), [gy, y]);
  return (
    <svg width={width} height={height}>
      <g ref={gx} transform={`translate(0,${height - marginBottom})`} />
      <g ref={gy} transform={`translate(${marginLeft},0)`} />
      <path fill="none" stroke="currentColor" strokeWidth="1.5" d={line(data)} />
      <g fill="white" stroke="currentColor" strokeWidth="1.5">
        {data.map((d, i) => (<circle key={i} cx={x(i)} cy={y(d)} r="2.5" />))}
      </g>
    </svg>
  );
}Sandbox ↗︎For more guidance using D3 in React, see Amelia Wattenberger’s post.D3 in Svelte ​As with React, you can use Svelte exclusively for rendering if you like, and only use D3 modules that don’t manipulate the DOM. Here is a line plot of an array of numbers that uses d3-shape and d3-scale.LinePlot.sveltesvelte<script>
  import * as d3 from 'd3';

  export let data;
  export let width = 640;
  export let height = 400;
  export let marginTop = 20;
  export let marginRight = 20;
  export let marginBottom = 20;
  export let marginLeft = 20;

  $: x = d3.scaleLinear([0, data.length - 1], [marginLeft, width - marginRight]);
  $: y = d3.scaleLinear(d3.extent(data), [height - marginBottom, marginTop]);
  $: line = d3.line((d, i) => x(i), y);
</script>
<svg width={width} height={height}>
  <path fill="none" stroke="currentColor" stroke-width="1.5" d={line(data)} />
  <g fill="white" stroke="currentColor" stroke-width="1.5">
    {#each data as d, i}
      <circle key={i} cx={x(i)} cy={y(d)} r="2.5" />
    {/each}
  </g>
</svg>REPL ↗︎Svelte’s reactive statements ($:) pair nicely with D3 data joins for efficient updates. Below, we use them to render dynamic axes as the data changes.LinePlot.sveltesvelte<script>
  import * as d3 from 'd3';

  export let data;
  export let width = 640;
  export let height = 400;
  export let marginTop = 20;
  export let marginRight = 20;
  export let marginBottom = 30;
  export let marginLeft = 40;

  let gx;
  let gy;

  $: x = d3.scaleLinear([0, data.length - 1], [marginLeft, width - marginRight]);
  $: y = d3.scaleLinear(d3.extent(data), [height - marginBottom, marginTop]);
  $: line = d3.line((d, i) => x(i), y);
  $: d3.select(gy).call(d3.axisLeft(y));
  $: d3.select(gx).call(d3.axisBottom(x));
</script>
<svg width={width} height={height}>
  <g bind:this={gx} transform="translate(0,{height - marginBottom})" />
  <g bind:this={gy} transform="translate({marginLeft},0)" />
  <path fill="none" stroke="currentColor" stroke-width="1.5" d={line(data)} />
  <g fill="white" stroke="currentColor" stroke-width="1.5">
    {#each data as d, i}
      <circle key={i} cx={x(i)} cy={y(d)} r="2.5" />
    {/each}
  </g>
</svg>REPL ↗︎PagerPrevious pageWhat is D3?Next pageAPI index\n\nGetting started ​D3 works in any JavaScript environment.Try D3 online ​The fastest way to get started (and get help) with D3 is on Observable! D3 is available by default in notebooks as part of Observable’s standard library. To create something with D3, return the generated DOM element from a cell. Here is a blank chart to get you started:js{
  // Declare the chart dimensions and margins.
  const width = 640;
  const height = 400;
  const marginTop = 20;
  const marginRight = 20;
  const marginBottom = 30;
  const marginLeft = 40;

  // Declare the x (horizontal position) scale.
  const x = d3.scaleUtc()
      .domain([new Date("2023-01-01"), new Date("2024-01-01")])
      .range([marginLeft, width - marginRight]);

  // Declare the y (vertical position) scale.
  const y = d3.scaleLinear()
      .domain([0, 100])
      .range([height - marginBottom, marginTop]);

  // Create the SVG container.
  const svg = d3.create("svg")
      .attr("width", width)
      .attr("height", height);

  // Add the x-axis.
  svg.append("g")
      .attr("transform", `translate(0,${height - marginBottom})`)
      .call(d3.axisBottom(x));

  // Add the y-axis.
  svg.append("g")
      .attr("transform", `translate(${marginLeft},0)`)
      .call(d3.axisLeft(y));

  // Return the SVG element.
  return svg.node();
}As a more complete example, try one of these starter templates:Area chartBar chartDonut chartHistogramLine chartSee the D3 gallery for more forkable examples.Observable includes a few D3 snippets when you click + to add a cell (type “d3” when the cell menu is open to filter), as well as convenient sample datasets to try out D3 features. Or upload a CSV or JSON file to start playing with your data. You can also fork any of the hundreds of notebooks we’ve published for a head start.Observable is free for public use. Sign up for a Pro account to connect to private databases, collaborate on private notebooks, and more.D3 in vanilla HTML ​In vanilla HTML, you can load D3 from a CDN such as jsDelivr or you can download it locally. We recommend using the CDN-hosted ES module bundle. But for those who need it, we also provide a UMD bundle that exports the d3 global when loaded as a plain script.ESM + CDNUMD + CDNUMD + localhtml<!DOCTYPE html>
<div id="container"></div>
<script type="module">

import * as d3 from "https://cdn.jsdelivr.net/npm/d3@7/+esm";

// Declare the chart dimensions and margins.
const width = 640;
const height = 400;
const marginTop = 20;
const marginRight = 20;
const marginBottom = 30;
const marginLeft = 40;

// Declare the x (horizontal position) scale.
const x = d3.scaleUtc()
    .domain([new Date("2023-01-01"), new Date("2024-01-01")])
    .range([marginLeft, width - marginRight]);

// Declare the y (vertical position) scale.
const y = d3.scaleLinear()
    .domain([0, 100])
    .range([height - marginBottom, marginTop]);

// Create the SVG container.
const svg = d3.create("svg")
    .attr("width", width)
    .attr("height", height);

// Add the x-axis.
svg.append("g")
    .attr("transform", `translate(0,${height - marginBottom})`)
    .call(d3.axisBottom(x));

// Add the y-axis.
svg.append("g")
    .attr("transform", `translate(${marginLeft},0)`)
    .call(d3.axisLeft(y));

// Append the SVG element.
container.append(svg.node());

</script>html<!DOCTYPE html>
<div id="container"></div>
<script src="https://cdn.jsdelivr.net/npm/d3@7"></script>
<script type="module">

// Declare the chart dimensions and margins.
const width = 640;
const height = 400;
const marginTop = 20;
const marginRight = 20;
const marginBottom = 30;
const marginLeft = 40;

// Declare the x (horizontal position) scale.
const x = d3.scaleUtc()
    .domain([new Date("2023-01-01"), new Date("2024-01-01")])
    .range([marginLeft, width - marginRight]);

// Declare the y (vertical position) scale.
const y = d3.scaleLinear()
    .domain([0, 100])
    .range([height - marginBottom, marginTop]);

// Create the SVG container.
const svg = d3.create("svg")
    .attr("width", width)
    .attr("height", height);

// Add the x-axis.
svg.append("g")
    .attr("transform", `translate(0,${height - marginBottom})`)
    .call(d3.axisBottom(x));

// Add the y-axis.
svg.append("g")
    .attr("transform", `translate(${marginLeft},0)`)
    .call(d3.axisLeft(y));

// Append the SVG element.
container.append(svg.node());

</script>html<!DOCTYPE html>
<div id="container"></div>
<script src="d3.js"></script>
<script type="module">

// Declare the chart dimensions and margins.
const width = 640;
const height = 400;
const marginTop = 20;
const marginRight = 20;
const marginBottom = 30;
const marginLeft = 40;

// Declare the x (horizontal position) scale.
const x = d3.scaleUtc()
    .domain([new Date("2023-01-01"), new Date("2024-01-01")])
    .range([marginLeft, width - marginRight]);

// Declare the y (vertical position) scale.
const y = d3.scaleLinear()
    .domain([0, 100])
    .range([height - marginBottom, marginTop]);

// Create the SVG container.
const svg = d3.create("svg")
    .attr("width", width)
    .attr("height", height);

// Add the x-axis.
svg.append("g")
    .attr("transform", `translate(0,${height - marginBottom})`)
    .call(d3.axisBottom(x));

// Add the y-axis.
svg.append("g")
    .attr("transform", `translate(${marginLeft},0)`)
    .call(d3.axisLeft(y));

// Append the SVG element.
container.append(svg.node());

</script>You can also import and destructure individual D3 modules like so:html<script type="module">

import {forceSimulation, forceCollide, forceX} from "https://cdn.jsdelivr.net/npm/d3-force@3/+esm";

const nodes = [{}, {}];
const simulation = forceSimulation(nodes)
    .force("x", forceX())
    .force("collide", forceCollide(5))
    .on("tick", () => console.log(nodes[0].x));

</script>If you’d prefer to run D3 locally (or offline), you can download the UMD bundles of D3 here:d3.v7.jsd3.v7.min.jsThen, create an index.html file as shown above in the UMD + local tab. Use the non-minified bundle for debugging, and the minified bundle for faster performance in production.Installing from npm ​If you’re developing a web application using Node, you can install D3 via yarn, npm, pnpm, or your preferred package manager.yarnnpmpnpmbashyarn add d3bashnpm install d3bashpnpm add d3You can then load D3 into your app as:jsimport * as d3 from "d3";You can instead import specific symbols if you prefer:jsimport {select, selectAll} from "d3";Alternatively you can install and import from D3 submodules:jsimport {mean, median} from "d3-array";TypeScript declarations are available via DefinitelyTyped.D3 in React ​Most D3 modules (including d3-scale, d3-array, d3-interpolate, and d3-format) don’t interact with the DOM, so there is no difference when using them in React. You can use them in JSX for purely declarative visualization, such as the line plot below.LinePlot.jsxjsximport * as d3 from "d3";

export default function LinePlot({
  data,
  width = 640,
  height = 400,
  marginTop = 20,
  marginRight = 20,
  marginBottom = 20,
  marginLeft = 20
}) {
  const x = d3.scaleLinear([0, data.length - 1], [marginLeft, width - marginRight]);
  const y = d3.scaleLinear(d3.extent(data), [height - marginBottom, marginTop]);
  const line = d3.line((d, i) => x(i), y);
  return (
    <svg width={width} height={height}>
      <path fill="none" stroke="currentColor" strokeWidth="1.5" d={line(data)} />
      <g fill="white" stroke="currentColor" strokeWidth="1.5">
        {data.map((d, i) => (<circle key={i} cx={x(i)} cy={y(d)} r="2.5" />))}
      </g>
    </svg>
  );
}Sandbox ↗︎D3 modules that operate on selections (including d3-selection, d3-transition, and d3-axis) do manipulate the DOM, which competes with React’s virtual DOM. In those cases, you can attach a ref to an element and pass it to D3 in a useEffect hook.LinePlot.jsxjsximport * as d3 from "d3";
import {useRef, useEffect} from "react";

export default function LinePlot({
  data,
  width = 640,
  height = 400,
  marginTop = 20,
  marginRight = 20,
  marginBottom = 30,
  marginLeft = 40
}) {
  const gx = useRef();
  const gy = useRef();
  const x = d3.scaleLinear([0, data.length - 1], [marginLeft, width - marginRight]);
  const y = d3.scaleLinear(d3.extent(data), [height - marginBottom, marginTop]);
  const line = d3.line((d, i) => x(i), y);
  useEffect(() => void d3.select(gx.current).call(d3.axisBottom(x)), [gx, x]);
  useEffect(() => void d3.select(gy.current).call(d3.axisLeft(y)), [gy, y]);
  return (
    <svg width={width} height={height}>
      <g ref={gx} transform={`translate(0,${height - marginBottom})`} />
      <g ref={gy} transform={`translate(${marginLeft},0)`} />
      <path fill="none" stroke="currentColor" strokeWidth="1.5" d={line(data)} />
      <g fill="white" stroke="currentColor" strokeWidth="1.5">
        {data.map((d, i) => (<circle key={i} cx={x(i)} cy={y(d)} r="2.5" />))}
      </g>
    </svg>
  );
}Sandbox ↗︎For more guidance using D3 in React, see Amelia Wattenberger’s post.D3 in Svelte ​As with React, you can use Svelte exclusively for rendering if you like, and only use D3 modules that don’t manipulate the DOM. Here is a line plot of an array of numbers that uses d3-shape and d3-scale.LinePlot.sveltesvelte<script>
  import * as d3 from 'd3';

  export let data;
  export let width = 640;
  export let height = 400;
  export let marginTop = 20;
  export let marginRight = 20;
  export let marginBottom = 20;
  export let marginLeft = 20;

  $: x = d3.scaleLinear([0, data.length - 1], [marginLeft, width - marginRight]);
  $: y = d3.scaleLinear(d3.extent(data), [height - marginBottom, marginTop]);
  $: line = d3.line((d, i) => x(i), y);
</script>
<svg width={width} height={height}>
  <path fill="none" stroke="currentColor" stroke-width="1.5" d={line(data)} />
  <g fill="white" stroke="currentColor" stroke-width="1.5">
    {#each data as d, i}
      <circle key={i} cx={x(i)} cy={y(d)} r="2.5" />
    {/each}
  </g>
</svg>REPL ↗︎Svelte’s reactive statements ($:) pair nicely with D3 data joins for efficient updates. Below, we use them to render dynamic axes as the data changes.LinePlot.sveltesvelte<script>
  import * as d3 from 'd3';

  export let data;
  export let width = 640;
  export let height = 400;
  export let marginTop = 20;
  export let marginRight = 20;
  export let marginBottom = 30;
  export let marginLeft = 40;

  let gx;
  let gy;

  $: x = d3.scaleLinear([0, data.length - 1], [marginLeft, width - marginRight]);
  $: y = d3.scaleLinear(d3.extent(data), [height - marginBottom, marginTop]);
  $: line = d3.line((d, i) => x(i), y);
  $: d3.select(gy).call(d3.axisLeft(y));
  $: d3.select(gx).call(d3.axisBottom(x));
</script>
<svg width={width} height={height}>
  <g bind:this={gx} transform="translate(0,{height - marginBottom})" />
  <g bind:this={gy} transform="translate({marginLeft},0)" />
  <path fill="none" stroke="currentColor" stroke-width="1.5" d={line(data)} />
  <g fill="white" stroke="currentColor" stroke-width="1.5">
    {#each data as d, i}
      <circle key={i} cx={x(i)} cy={y(d)} r="2.5" />
    {/each}
  </g>
</svg>REPL ↗︎\n\n\n\nWhat is D3? ​D3 (or D3.js) is a free, open-source JavaScript library for visualizing data. Its low-level approach built on web standards offers unparalleled flexibility in authoring dynamic, data-driven graphics. For more than a decade D3 has powered groundbreaking and award-winning visualizations, become a foundational building block of higher-level chart libraries, and fostered a vibrant community of data practitioners around the world.D3 “slingshotted the field into growth, diversification and creativity that has been unprecedented” and “changed how millions of data visualizations are created across newsrooms, websites, and personal portfolios,” remarked the Information is Beautiful 2022 Test of Time Award. The IEEE VIS 2021 Test of Time Award noted, “By creating a framework that was compelling and easy for web developers to use to author interactive visualizations, the authors have undeniably helped to bring data visualization to the mainstream. [D3] is a cornerstone contribution to this conference specifically and more generally to the success of our field as a whole.”D3 was created by Mike Bostock in 2011. Mike co-authored the D3 paper with Jeff Heer and Vadim Ogievetsky at Stanford. Jason Davies made major contributions to D3 from 2011 to 2013, most notably to D3’s geographic projection system. Philippe Rivière has been a major contributor to D3 and its documentation since 2016. Over the years, countless kind individuals have contributed to D3 by sharing code and ideas, by teaching and answering questions, and by bringing people together to further the practice of visualization. Mike and Philippe now maintain D3 and Observable Plot at Observable.D3 is a low-level toolbox ​D3 is not a charting library in the traditional sense. It has no concept of “charts”. When you visualize data with D3, you compose a variety of primitives.To make a stacked area chart, you might usea CSV parser to load data,a time scale for horizontal position (x),a linear scale for vertical position (y),an ordinal scale and categorical scheme for color,a stack layout for arranging values,an area shape with a linear curve for generating SVG path data,axes for documenting the position encodings, andselections for creating SVG elements.That’s a lot to take in, right? But take a deep breath — you don’t have to learn everything at once. Each piece can be used independently, so you can learn them individually before you fit them together. D3 is not a single monolith but rather a suite of 30 discrete libraries (or “modules”). We bundle these modules together for convenience rather than necessity so your tools are within reach as you iterate on your design.What all’s in the D3 toolbox? We recommend exploring the documentation and examples to get a sense of what’s relevant to you.TIPUnless you need D3’s low-level control, we recommend our high-level sister library: Observable Plot. Whereas a histogram in D3 might require 50 lines of code, Plot can do it in one! Plot’s concise yet expressive API lets you focus more on analyzing and visualizing data instead of web development. You can even combine Plot and D3 for the best of both.D3 is flexible ​Because D3 has no overarching “chart” abstraction, even a basic chart may require a few dozen lines of code. On the upside, all the pieces are laid out in front of you and you have complete control over what happens. You can tailor the visualization to achieve exactly what you want. D3 has no default presentation of your data — there’s just the code you write yourself. (Or copy from an example.)Consider D3 an alternative to “doing everything yourself”, not an alternative to a high-level charting library. If you aren’t satisfied with other tools and you’re thinking of rolling your own charts using SVG or Canvas (or even WebGL), you might as well peruse D3’s toolbox! There’s almost certainly something here that will help you build the chart of your dreams without imposing on your creativity.D3 works with the web ​D3 doesn’t introduce a new graphical representation; instead, you use D3 directly with web standards such as SVG and Canvas.The name “D3” is short for data-driven documents, where documents refers to the Document Object Model (DOM) standard that represents the contents of a webpage. While some of D3’s modules (such as selections and transitions) touch the DOM, others (including scales and shapes) only operate on data. D3 can also be paired with web frameworks such as React, Vue, and Svelte; see the getting started guide for recommendations.D3’s embrace of web standards brings many benefits. For example, you can use external stylesheets to alter the appearance of charts (even in response to media queries, say for responsive charts or dark mode); you can use the debugger and element inspector to review what your code is doing; and D3’s synchronous, imperative evaluation model — calling selection.attr immediately mutates the DOM — can make it easier to debug than frameworks with complex asynchronous runtimes.D3 is for bespoke visualization ​D3 makes things possible, not necessarily easy; even simple things that should be easy are often not. To paraphrase Amanda Cox: “Use D3 if you think it’s perfectly normal to write a hundred lines of code for a bar chart.”If you need maximal expressiveness for your bespoke visualization, you should consider D3. D3 makes sense for media organizations such as The New York Times or The Pudding, where a single graphic may be seen by a million readers, and where a team of editors can work together to advance the state of the art in visual communication.On the other hand, D3 is overkill for throwing together a private dashboard or a one-off analysis. Don’t get seduced by whizbang examples: many of them took an immense effort to implement! If you’re constrained by time (and who isn’t?), you’d likely produce a better visualization or analysis with Observable Plot.D3 is for dynamic visualization ​D3’s most novel concept is its data join: given a set of data and a set of DOM elements, the data join allows you to apply separate operations for entering, updating, and exiting elements. If you’re only creating static charts (charts that don’t animate or respond to user input), you may find this concept unintuitive or even bizarre because it’s not needed.The data join exists so that you can control exactly what happens when your data changes and update the display in response. This direct control allows extremely performant updates — you only touch the elements and attributes that need changing, without diffing the DOM — and smooth animated transitions between states. D3 shines for dynamic, interactive visualizations. (Try option-clicking the state toggles in “512 Paths to the White House” from 2012. Really.)\n\nSearchK7.9.0GitHub️ 110.0kOn this pageWhat is D3? ​D3 (or D3.js) is a free, open-source JavaScript library for visualizing data. Its low-level approach built on web standards offers unparalleled flexibility in authoring dynamic, data-driven graphics. For more than a decade D3 has powered groundbreaking and award-winning visualizations, become a foundational building block of higher-level chart libraries, and fostered a vibrant community of data practitioners around the world.D3 “slingshotted the field into growth, diversification and creativity that has been unprecedented” and “changed how millions of data visualizations are created across newsrooms, websites, and personal portfolios,” remarked the Information is Beautiful 2022 Test of Time Award. The IEEE VIS 2021 Test of Time Award noted, “By creating a framework that was compelling and easy for web developers to use to author interactive visualizations, the authors have undeniably helped to bring data visualization to the mainstream. [D3] is a cornerstone contribution to this conference specifically and more generally to the success of our field as a whole.”D3 was created by Mike Bostock in 2011. Mike co-authored the D3 paper with Jeff Heer and Vadim Ogievetsky at Stanford. Jason Davies made major contributions to D3 from 2011 to 2013, most notably to D3’s geographic projection system. Philippe Rivière has been a major contributor to D3 and its documentation since 2016. Over the years, countless kind individuals have contributed to D3 by sharing code and ideas, by teaching and answering questions, and by bringing people together to further the practice of visualization. Mike and Philippe now maintain D3 and Observable Plot at Observable.D3 is a low-level toolbox ​D3 is not a charting library in the traditional sense. It has no concept of “charts”. When you visualize data with D3, you compose a variety of primitives.To make a stacked area chart, you might usea CSV parser to load data,a time scale for horizontal position (x),a linear scale for vertical position (y),an ordinal scale and categorical scheme for color,a stack layout for arranging values,an area shape with a linear curve for generating SVG path data,axes for documenting the position encodings, andselections for creating SVG elements.That’s a lot to take in, right? But take a deep breath — you don’t have to learn everything at once. Each piece can be used independently, so you can learn them individually before you fit them together. D3 is not a single monolith but rather a suite of 30 discrete libraries (or “modules”). We bundle these modules together for convenience rather than necessity so your tools are within reach as you iterate on your design.What all’s in the D3 toolbox? We recommend exploring the documentation and examples to get a sense of what’s relevant to you.TIPUnless you need D3’s low-level control, we recommend our high-level sister library: Observable Plot. Whereas a histogram in D3 might require 50 lines of code, Plot can do it in one! Plot’s concise yet expressive API lets you focus more on analyzing and visualizing data instead of web development. You can even combine Plot and D3 for the best of both.D3 is flexible ​Because D3 has no overarching “chart” abstraction, even a basic chart may require a few dozen lines of code. On the upside, all the pieces are laid out in front of you and you have complete control over what happens. You can tailor the visualization to achieve exactly what you want. D3 has no default presentation of your data — there’s just the code you write yourself. (Or copy from an example.)Consider D3 an alternative to “doing everything yourself”, not an alternative to a high-level charting library. If you aren’t satisfied with other tools and you’re thinking of rolling your own charts using SVG or Canvas (or even WebGL), you might as well peruse D3’s toolbox! There’s almost certainly something here that will help you build the chart of your dreams without imposing on your creativity.D3 works with the web ​D3 doesn’t introduce a new graphical representation; instead, you use D3 directly with web standards such as SVG and Canvas.The name “D3” is short for data-driven documents, where documents refers to the Document Object Model (DOM) standard that represents the contents of a webpage. While some of D3’s modules (such as selections and transitions) touch the DOM, others (including scales and shapes) only operate on data. D3 can also be paired with web frameworks such as React, Vue, and Svelte; see the getting started guide for recommendations.D3’s embrace of web standards brings many benefits. For example, you can use external stylesheets to alter the appearance of charts (even in response to media queries, say for responsive charts or dark mode); you can use the debugger and element inspector to review what your code is doing; and D3’s synchronous, imperative evaluation model — calling selection.attr immediately mutates the DOM — can make it easier to debug than frameworks with complex asynchronous runtimes.D3 is for bespoke visualization ​D3 makes things possible, not necessarily easy; even simple things that should be easy are often not. To paraphrase Amanda Cox: “Use D3 if you think it’s perfectly normal to write a hundred lines of code for a bar chart.”If you need maximal expressiveness for your bespoke visualization, you should consider D3. D3 makes sense for media organizations such as The New York Times or The Pudding, where a single graphic may be seen by a million readers, and where a team of editors can work together to advance the state of the art in visual communication.On the other hand, D3 is overkill for throwing together a private dashboard or a one-off analysis. Don’t get seduced by whizbang examples: many of them took an immense effort to implement! If you’re constrained by time (and who isn’t?), you’d likely produce a better visualization or analysis with Observable Plot.D3 is for dynamic visualization ​D3’s most novel concept is its data join: given a set of data and a set of DOM elements, the data join allows you to apply separate operations for entering, updating, and exiting elements. If you’re only creating static charts (charts that don’t animate or respond to user input), you may find this concept unintuitive or even bizarre because it’s not needed.The data join exists so that you can control exactly what happens when your data changes and update the display in response. This direct control allows extremely performant updates — you only touch the elements and attributes that need changing, without diffing the DOM — and smooth animated transitions between states. D3 shines for dynamic, interactive visualizations. (Try option-clicking the state toggles in “512 Paths to the White House” from 2012. Really.)PagerNext pageGetting started\n\nWhat is D3? ​D3 (or D3.js) is a free, open-source JavaScript library for visualizing data. Its low-level approach built on web standards offers unparalleled flexibility in authoring dynamic, data-driven graphics. For more than a decade D3 has powered groundbreaking and award-winning visualizations, become a foundational building block of higher-level chart libraries, and fostered a vibrant community of data practitioners around the world.D3 “slingshotted the field into growth, diversification and creativity that has been unprecedented” and “changed how millions of data visualizations are created across newsrooms, websites, and personal portfolios,” remarked the Information is Beautiful 2022 Test of Time Award. The IEEE VIS 2021 Test of Time Award noted, “By creating a framework that was compelling and easy for web developers to use to author interactive visualizations, the authors have undeniably helped to bring data visualization to the mainstream. [D3] is a cornerstone contribution to this conference specifically and more generally to the success of our field as a whole.”D3 was created by Mike Bostock in 2011. Mike co-authored the D3 paper with Jeff Heer and Vadim Ogievetsky at Stanford. Jason Davies made major contributions to D3 from 2011 to 2013, most notably to D3’s geographic projection system. Philippe Rivière has been a major contributor to D3 and its documentation since 2016. Over the years, countless kind individuals have contributed to D3 by sharing code and ideas, by teaching and answering questions, and by bringing people together to further the practice of visualization. Mike and Philippe now maintain D3 and Observable Plot at Observable.D3 is a low-level toolbox ​D3 is not a charting library in the traditional sense. It has no concept of “charts”. When you visualize data with D3, you compose a variety of primitives.To make a stacked area chart, you might usea CSV parser to load data,a time scale for horizontal position (x),a linear scale for vertical position (y),an ordinal scale and categorical scheme for color,a stack layout for arranging values,an area shape with a linear curve for generating SVG path data,axes for documenting the position encodings, andselections for creating SVG elements.That’s a lot to take in, right? But take a deep breath — you don’t have to learn everything at once. Each piece can be used independently, so you can learn them individually before you fit them together. D3 is not a single monolith but rather a suite of 30 discrete libraries (or “modules”). We bundle these modules together for convenience rather than necessity so your tools are within reach as you iterate on your design.What all’s in the D3 toolbox? We recommend exploring the documentation and examples to get a sense of what’s relevant to you.TIPUnless you need D3’s low-level control, we recommend our high-level sister library: Observable Plot. Whereas a histogram in D3 might require 50 lines of code, Plot can do it in one! Plot’s concise yet expressive API lets you focus more on analyzing and visualizing data instead of web development. You can even combine Plot and D3 for the best of both.D3 is flexible ​Because D3 has no overarching “chart” abstraction, even a basic chart may require a few dozen lines of code. On the upside, all the pieces are laid out in front of you and you have complete control over what happens. You can tailor the visualization to achieve exactly what you want. D3 has no default presentation of your data — there’s just the code you write yourself. (Or copy from an example.)Consider D3 an alternative to “doing everything yourself”, not an alternative to a high-level charting library. If you aren’t satisfied with other tools and you’re thinking of rolling your own charts using SVG or Canvas (or even WebGL), you might as well peruse D3’s toolbox! There’s almost certainly something here that will help you build the chart of your dreams without imposing on your creativity.D3 works with the web ​D3 doesn’t introduce a new graphical representation; instead, you use D3 directly with web standards such as SVG and Canvas.The name “D3” is short for data-driven documents, where documents refers to the Document Object Model (DOM) standard that represents the contents of a webpage. While some of D3’s modules (such as selections and transitions) touch the DOM, others (including scales and shapes) only operate on data. D3 can also be paired with web frameworks such as React, Vue, and Svelte; see the getting started guide for recommendations.D3’s embrace of web standards brings many benefits. For example, you can use external stylesheets to alter the appearance of charts (even in response to media queries, say for responsive charts or dark mode); you can use the debugger and element inspector to review what your code is doing; and D3’s synchronous, imperative evaluation model — calling selection.attr immediately mutates the DOM — can make it easier to debug than frameworks with complex asynchronous runtimes.D3 is for bespoke visualization ​D3 makes things possible, not necessarily easy; even simple things that should be easy are often not. To paraphrase Amanda Cox: “Use D3 if you think it’s perfectly normal to write a hundred lines of code for a bar chart.”If you need maximal expressiveness for your bespoke visualization, you should consider D3. D3 makes sense for media organizations such as The New York Times or The Pudding, where a single graphic may be seen by a million readers, and where a team of editors can work together to advance the state of the art in visual communication.On the other hand, D3 is overkill for throwing together a private dashboard or a one-off analysis. Don’t get seduced by whizbang examples: many of them took an immense effort to implement! If you’re constrained by time (and who isn’t?), you’d likely produce a better visualization or analysis with Observable Plot.D3 is for dynamic visualization ​D3’s most novel concept is its data join: given a set of data and a set of DOM elements, the data join allows you to apply separate operations for entering, updating, and exiting elements. If you’re only creating static charts (charts that don’t animate or respond to user input), you may find this concept unintuitive or even bizarre because it’s not needed.The data join exists so that you can control exactly what happens when your data changes and update the display in response. This direct control allows extremely performant updates — you only touch the elements and attributes that need changing, without diffing the DOM — and smooth animated transitions between states. D3 shines for dynamic, interactive visualizations. (Try option-clicking the state toggles in “512 Paths to the White House” from 2012. Really.)\n\n\n\nd3-selection ​Selections allow powerful data-driven transformation of the document object model (DOM): set attributes, styles, properties, HTML or text content, and more. Using the data join’s enter and exit selections, you can also add or remove elements to correspond to data.See one of:Selecting elements - querying for DOM elements.Modifying elements - modifying attributes of selected elements.Joining data - joining data to selected elements for visualization.Handling events - declaring event listeners for interaction.Control flow - iterating over selected elements.Local variables - attaching state to elements.Namespaces - dealing with XML namespaces.For more, see the d3-selection collection on Observable.\n\nSearchK7.9.0GitHub️ 110.0kOn this paged3-selection ​Selections allow powerful data-driven transformation of the document object model (DOM): set attributes, styles, properties, HTML or text content, and more. Using the data join’s enter and exit selections, you can also add or remove elements to correspond to data.See one of:Selecting elements - querying for DOM elements.Modifying elements - modifying attributes of selected elements.Joining data - joining data to selected elements for visualization.Handling events - declaring event listeners for interaction.Control flow - iterating over selected elements.Local variables - attaching state to elements.Namespaces - dealing with XML namespaces.For more, see the d3-selection collection on Observable.PagerPrevious pageSequential schemesNext pageSelecting elements\n\nd3-selection ​Selections allow powerful data-driven transformation of the document object model (DOM): set attributes, styles, properties, HTML or text content, and more. Using the data join’s enter and exit selections, you can also add or remove elements to correspond to data.See one of:Selecting elements - querying for DOM elements.Modifying elements - modifying attributes of selected elements.Joining data - joining data to selected elements for visualization.Handling events - declaring event listeners for interaction.Control flow - iterating over selected elements.Local variables - attaching state to elements.Namespaces - dealing with XML namespaces.For more, see the d3-selection collection on Observable.\n\n\n\nd3-scale ​Scales map a dimension of abstract data to a visual representation. Although most often used for encoding data as position, say to map time and temperature to a horizontal and vertical position in a scatterplot, scales can represent virtually any visual encoding, such as color, stroke width, or symbol size. Scales can also be used with virtually any type of data, such as named categorical data or discrete data that requires sensible breaks.See one of:Linear scales - for quantitative dataTime scales - for time-series dataPow scales - for quantitative data (that has a wide range)Log scales - for quantitative data (that has a wide range)Symlog scales - for quantitative data (that has a wide range)Ordinal scales - for categorical or ordinal dataBand scales - for categorical or ordinal data as a position encodingPoint scales - for categorical or ordinal data as a position encodingSequential scales - for quantitative data as a sequential color encodingDiverging scales - for quantitative data as a diverging color encodingQuantile scales - for quantitative data as a discrete encodingQuantize scales - for quantitative data as a discrete encodingThreshold scales - for quantitative data as a discrete encodingFor visualizing the scale’s encoding, see d3-axis, as well as scale.ticks and scale.tickFormat. For color schemes, see d3-scale-chromatic.\n\nSearchK7.9.0GitHub️ 110.0kOn this paged3-scale ​Scales map a dimension of abstract data to a visual representation. Although most often used for encoding data as position, say to map time and temperature to a horizontal and vertical position in a scatterplot, scales can represent virtually any visual encoding, such as color, stroke width, or symbol size. Scales can also be used with virtually any type of data, such as named categorical data or discrete data that requires sensible breaks.See one of:Linear scales - for quantitative dataTime scales - for time-series dataPow scales - for quantitative data (that has a wide range)Log scales - for quantitative data (that has a wide range)Symlog scales - for quantitative data (that has a wide range)Ordinal scales - for categorical or ordinal dataBand scales - for categorical or ordinal data as a position encodingPoint scales - for categorical or ordinal data as a position encodingSequential scales - for quantitative data as a sequential color encodingDiverging scales - for quantitative data as a diverging color encodingQuantile scales - for quantitative data as a discrete encodingQuantize scales - for quantitative data as a discrete encodingThreshold scales - for quantitative data as a discrete encodingFor visualizing the scale’s encoding, see d3-axis, as well as scale.ticks and scale.tickFormat. For color schemes, see d3-scale-chromatic.PagerPrevious paged3-quadtreeNext pageLinear scales\n\nd3-scale ​Scales map a dimension of abstract data to a visual representation. Although most often used for encoding data as position, say to map time and temperature to a horizontal and vertical position in a scatterplot, scales can represent virtually any visual encoding, such as color, stroke width, or symbol size. Scales can also be used with virtually any type of data, such as named categorical data or discrete data that requires sensible breaks.See one of:Linear scales - for quantitative dataTime scales - for time-series dataPow scales - for quantitative data (that has a wide range)Log scales - for quantitative data (that has a wide range)Symlog scales - for quantitative data (that has a wide range)Ordinal scales - for categorical or ordinal dataBand scales - for categorical or ordinal data as a position encodingPoint scales - for categorical or ordinal data as a position encodingSequential scales - for quantitative data as a sequential color encodingDiverging scales - for quantitative data as a diverging color encodingQuantile scales - for quantitative data as a discrete encodingQuantize scales - for quantitative data as a discrete encodingThreshold scales - for quantitative data as a discrete encodingFor visualizing the scale’s encoding, see d3-axis, as well as scale.ticks and scale.tickFormat. For color schemes, see d3-scale-chromatic.\n\n\n\nd3-shape ​Visualizations can be represented by discrete graphical marks such as symbols, arcs, lines, and areas. While the rectangles of a bar chart may sometimes be simple, other shapes are complex, such as rounded annular sectors and Catmull–Rom splines. The d3-shape module provides a variety of shape generators for your convenience.As with other aspects of D3, these shapes are driven by data: each shape generator exposes accessors that control how the input data are mapped to a visual representation. For example, you might define a line generator for a time series by scaling fields of your data to fit the chart:jsconst line = d3.line()
    .x((d) => x(d.date))
    .y((d) => y(d.value));This line generator can then be used to compute the d attribute of an SVG path element:jspath.datum(data).attr("d", line);Or you can use it to render to a Canvas 2D context:jsline.context(context)(data);See one of:Arcs - circular or annular sectors, as in a pie or donut chart.Areas - an area defined by a bounding topline and baseline, as in an area chart.Curves - interpolate between points to produce a continuous shape.Lines - a spline or polyline, as in a line chart.Links - a smooth cubic Bézier curve from a source to a target.Pies - compute angles for a pie or donut chart.Stacks - stack adjacent shapes, as in a stacked bar chart.Symbols - a categorical shape encoding, as in a scatterplot.Radial areas - like area, but in polar coordinates.Radial lines - like line, but in polar coordinates.Radial links - like link, but in polar coordinates.\n\nSearchK7.9.0GitHub️ 110.0kOn this paged3-shape ​Visualizations can be represented by discrete graphical marks such as symbols, arcs, lines, and areas. While the rectangles of a bar chart may sometimes be simple, other shapes are complex, such as rounded annular sectors and Catmull–Rom splines. The d3-shape module provides a variety of shape generators for your convenience.As with other aspects of D3, these shapes are driven by data: each shape generator exposes accessors that control how the input data are mapped to a visual representation. For example, you might define a line generator for a time series by scaling fields of your data to fit the chart:jsconst line = d3.line()
    .x((d) => x(d.date))
    .y((d) => y(d.value));This line generator can then be used to compute the d attribute of an SVG path element:jspath.datum(data).attr("d", line);Or you can use it to render to a Canvas 2D context:jsline.context(context)(data);See one of:Arcs - circular or annular sectors, as in a pie or donut chart.Areas - an area defined by a bounding topline and baseline, as in an area chart.Curves - interpolate between points to produce a continuous shape.Lines - a spline or polyline, as in a line chart.Links - a smooth cubic Bézier curve from a source to a target.Pies - compute angles for a pie or donut chart.Stacks - stack adjacent shapes, as in a stacked bar chart.Symbols - a categorical shape encoding, as in a scatterplot.Radial areas - like area, but in polar coordinates.Radial lines - like line, but in polar coordinates.Radial links - like link, but in polar coordinates.PagerPrevious pageNamespacesNext pageArcs\n\nd3-shape ​Visualizations can be represented by discrete graphical marks such as symbols, arcs, lines, and areas. While the rectangles of a bar chart may sometimes be simple, other shapes are complex, such as rounded annular sectors and Catmull–Rom splines. The d3-shape module provides a variety of shape generators for your convenience.As with other aspects of D3, these shapes are driven by data: each shape generator exposes accessors that control how the input data are mapped to a visual representation. For example, you might define a line generator for a time series by scaling fields of your data to fit the chart:jsconst line = d3.line()
    .x((d) => x(d.date))
    .y((d) => y(d.value));This line generator can then be used to compute the d attribute of an SVG path element:jspath.datum(data).attr("d", line);Or you can use it to render to a Canvas 2D context:jsline.context(context)(data);See one of:Arcs - circular or annular sectors, as in a pie or donut chart.Areas - an area defined by a bounding topline and baseline, as in an area chart.Curves - interpolate between points to produce a continuous shape.Lines - a spline or polyline, as in a line chart.Links - a smooth cubic Bézier curve from a source to a target.Pies - compute angles for a pie or donut chart.Stacks - stack adjacent shapes, as in a stacked bar chart.Symbols - a categorical shape encoding, as in a scatterplot.Radial areas - like area, but in polar coordinates.Radial lines - like line, but in polar coordinates.Radial links - like link, but in polar coordinates.\n\n\n\nd3-brush ​Brushing is the interactive specification a one- or two-dimensional selected region using a pointing gesture, such as by clicking and dragging the mouse. Brushing is often used to select discrete elements, such as dots in a scatterplot or files on a desktop. It can also be used to zoom-in to a region of interest, or to select continuous regions for cross-filtering data or live histograms:The d3-brush module implements brushing for mouse and touch events using SVG. Click and drag on the brush selection to translate the selection. Click and drag on one of the selection handles to move the corresponding edge (or edges) of the selection. Click and drag on the invisible overlay to define a new brush selection, or click anywhere within the brushable region while holding down the META (⌘) key. Holding down the ALT (⌥) key while moving the brush causes it to reposition around its center, while holding down SPACE locks the current brush size, allowing only translation.Brushes also support programmatic control. For example, you can listen to end events, and then initiate a transition with brush.move to snap the brush selection to semantic boundaries:Or you can have the brush recenter when you click outside the current selection:brush() ​Examples · Source · Creates a new two-dimensional brush.brushX() ​Examples · Source · Creates a new one-dimensional brush along the x-dimension.brushY() ​Source · Creates a new one-dimensional brush along the y-dimension.brush(group) ​Examples · Source · Applies the brush to the specified group, which must be a selection of SVG G elements. This function is typically not invoked directly, and is instead invoked via selection.call. For example, to render a brush:jssvg.append("g")
    .attr("class", "brush")
    .call(d3.brush().on("brush", brushed));Internally, the brush uses selection.on to bind the necessary event listeners for dragging. The listeners use the name .brush, so you can subsequently unbind the brush event listeners as follows:jsgroup.on(".brush", null);The brush also creates the SVG elements necessary to display the brush selection and to receive input events for interaction. You can add, remove or modify these elements as desired to change the brush appearance; you can also apply stylesheets to modify the brush appearance. The structure of a two-dimensional brush is as follows:html<g class="brush" fill="none" pointer-events="all" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);">
  <rect class="overlay" pointer-events="all" cursor="crosshair" x="0" y="0" width="960" height="500"></rect>
  <rect class="selection" cursor="move" fill="#777" fill-opacity="0.3" stroke="#fff" shape-rendering="crispEdges" x="112" y="194" width="182" height="83"></rect>
  <rect class="handle handle--n" cursor="ns-resize" x="107" y="189" width="192" height="10"></rect>
  <rect class="handle handle--e" cursor="ew-resize" x="289" y="189" width="10" height="93"></rect>
  <rect class="handle handle--s" cursor="ns-resize" x="107" y="272" width="192" height="10"></rect>
  <rect class="handle handle--w" cursor="ew-resize" x="107" y="189" width="10" height="93"></rect>
  <rect class="handle handle--nw" cursor="nwse-resize" x="107" y="189" width="10" height="10"></rect>
  <rect class="handle handle--ne" cursor="nesw-resize" x="289" y="189" width="10" height="10"></rect>
  <rect class="handle handle--se" cursor="nwse-resize" x="289" y="272" width="10" height="10"></rect>
  <rect class="handle handle--sw" cursor="nesw-resize" x="107" y="272" width="10" height="10"></rect>
</g>The overlay rect covers the brushable area defined by brush.extent. The selection rect covers the area defined by the current brush selection. The handle rects cover the edges and corners of the brush selection, allowing the corresponding value in the brush selection to be modified interactively. To modify the brush selection programmatically, use brush.move.brush.move(group, selection, event) ​Examples · Source · Sets the active selection of the brush on the specified group, which must be a selection or a transition of SVG G elements. The selection must be defined as an array of numbers, or null to clear the brush selection. For a two-dimensional brush, it must be defined as [[x0, y0], [x1, y1]], where x0 is the minimum x-value, y0 is the minimum y-value, x1 is the maximum x-value, and y1 is the maximum y-value. For an x-brush, it must be defined as [x0, x1]; for a y-brush, it must be defined as [y0, y1]. The selection may also be specified as a function which returns such an array; if a function, it is invoked for each selected element, being passed the current datum d and index i, with the this context as the current DOM element. The returned array defines the brush selection for that element.brush.clear(group, event) ​Examples · Source · An alias for brush.move with the null selection.brush.extent(extent) ​Examples · Source · If extent is specified, sets the brushable extent to the specified array of points [[x0, y0], [x1, y1]], where [x0, y0] is the top-left corner and [x1, y1] is the bottom-right corner, and returns this brush. The extent may also be specified as a function which returns such an array; if a function, it is invoked for each selected element, being passed the current datum d and index i, with the this context as the current DOM element. If extent is not specified, returns the current extent accessor, which defaults to:jsfunction defaultExtent() {
  var svg = this.ownerSVGElement || this;
  if (svg.hasAttribute("viewBox")) {
    svg = svg.viewBox.baseVal;
    return [[svg.x, svg.y], [svg.x + svg.width, svg.y + svg.height]];
  }
  return [[0, 0], [svg.width.baseVal.value, svg.height.baseVal.value]];
}This default implementation requires that the owner SVG element have a defined viewBox, or width and height attributes. Alternatively, consider using element.getBoundingClientRect. (In Firefox, element.clientWidth and element.clientHeight is zero for SVG elements!)The brush extent determines the size of the invisible overlay and also constrains the brush selection; the brush selection cannot go outside the brush extent.brush.filter(filter) ​Examples · Source · If filter is specified, sets the filter to the specified function and returns the brush. If filter is not specified, returns the current filter, which defaults to:jsfunction filter(event) {
  return !event.ctrlKey && !event.button;
}If the filter returns falsey, the initiating event is ignored and no brush gesture is started. Thus, the filter determines which input events are ignored. The default filter ignores mousedown events on secondary buttons, since those buttons are typically intended for other purposes, such as the context menu.brush.touchable(touchable) ​Source · If touchable is specified, sets the touch support detector to the specified function and returns the brush. If touchable is not specified, returns the current touch support detector, which defaults to:jsfunction touchable() {
  return navigator.maxTouchPoints || ("ontouchstart" in this);
}Touch event listeners are only registered if the detector returns truthy for the corresponding element when the brush is applied. The default detector works well for most browsers that are capable of touch input, but not all; Chrome’s mobile device emulator, for example, fails detection.brush.keyModifiers(modifiers) ​Source · If modifiers is specified, sets whether the brush listens to key events during brushing and returns the brush. If modifiers is not specified, returns the current behavior, which defaults to true.brush.handleSize(size) ​Source · If size is specified, sets the size of the brush handles to the specified number and returns the brush. If size is not specified, returns the current handle size, which defaults to six. This method must be called before applying the brush to a selection; changing the handle size does not affect brushes that were previously rendered.brush.on(typenames, listener) ​Source · If listener is specified, sets the event listener for the specified typenames and returns the brush. If an event listener was already registered for the same type and name, the existing listener is removed before the new listener is added. If listener is null, removes the current event listeners for the specified typenames, if any. If listener is not specified, returns the first currently-assigned listener matching the specified typenames, if any. When a specified event is dispatched, each listener will be invoked with the same context and arguments as selection.on listeners: the current event event and datum d, with the this context as the current DOM element.The typenames is a string containing one or more typename separated by whitespace. Each typename is a type, optionally followed by a period (.) and a name, such as brush.foo and brush.bar; the name allows multiple listeners to be registered for the same type. The type must be one of the following:start - at the start of a brush gesture, such as on mousedown.brush - when the brush moves, such as on mousemove.end - at the end of a brush gesture, such as on mouseup.See dispatch.on and brush events for more.brushSelection(node) ​Examples · Source · Returns the current brush selection for the specified node. Internally, an element’s brush state is stored as element.__brush; however, you should use this method rather than accessing it directly. If the given node has no selection, returns null. Otherwise, the selection is defined as an array of numbers. For a two-dimensional brush, it is [[x0, y0], [x1, y1]], where x0 is the minimum x-value, y0 is the minimum y-value, x1 is the maximum x-value, and y1 is the maximum y-value. For an x-brush, it is [x0, x1]; for a y-brush, it is [y0, y1].Brush events ​When a brush event listener is invoked, it receives the current brush event. The event object exposes several fields:target - the associated brush behavior.type - the string “start”, “brush” or “end”; see brush.on.selection - the current brush selection.sourceEvent - the underlying input event, such as mousemove or touchmove.mode - the string “drag”, “space”, “handle” or “center”; the mode of the brush.\n\nSearchK7.9.0GitHub️ 110.0kOn this paged3-brush ​Brushing is the interactive specification a one- or two-dimensional selected region using a pointing gesture, such as by clicking and dragging the mouse. Brushing is often used to select discrete elements, such as dots in a scatterplot or files on a desktop. It can also be used to zoom-in to a region of interest, or to select continuous regions for cross-filtering data or live histograms:The d3-brush module implements brushing for mouse and touch events using SVG. Click and drag on the brush selection to translate the selection. Click and drag on one of the selection handles to move the corresponding edge (or edges) of the selection. Click and drag on the invisible overlay to define a new brush selection, or click anywhere within the brushable region while holding down the META (⌘) key. Holding down the ALT (⌥) key while moving the brush causes it to reposition around its center, while holding down SPACE locks the current brush size, allowing only translation.Brushes also support programmatic control. For example, you can listen to end events, and then initiate a transition with brush.move to snap the brush selection to semantic boundaries:Or you can have the brush recenter when you click outside the current selection:brush() ​Examples · Source · Creates a new two-dimensional brush.brushX() ​Examples · Source · Creates a new one-dimensional brush along the x-dimension.brushY() ​Source · Creates a new one-dimensional brush along the y-dimension.brush(group) ​Examples · Source · Applies the brush to the specified group, which must be a selection of SVG G elements. This function is typically not invoked directly, and is instead invoked via selection.call. For example, to render a brush:jssvg.append("g")
    .attr("class", "brush")
    .call(d3.brush().on("brush", brushed));Internally, the brush uses selection.on to bind the necessary event listeners for dragging. The listeners use the name .brush, so you can subsequently unbind the brush event listeners as follows:jsgroup.on(".brush", null);The brush also creates the SVG elements necessary to display the brush selection and to receive input events for interaction. You can add, remove or modify these elements as desired to change the brush appearance; you can also apply stylesheets to modify the brush appearance. The structure of a two-dimensional brush is as follows:html<g class="brush" fill="none" pointer-events="all" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);">
  <rect class="overlay" pointer-events="all" cursor="crosshair" x="0" y="0" width="960" height="500"></rect>
  <rect class="selection" cursor="move" fill="#777" fill-opacity="0.3" stroke="#fff" shape-rendering="crispEdges" x="112" y="194" width="182" height="83"></rect>
  <rect class="handle handle--n" cursor="ns-resize" x="107" y="189" width="192" height="10"></rect>
  <rect class="handle handle--e" cursor="ew-resize" x="289" y="189" width="10" height="93"></rect>
  <rect class="handle handle--s" cursor="ns-resize" x="107" y="272" width="192" height="10"></rect>
  <rect class="handle handle--w" cursor="ew-resize" x="107" y="189" width="10" height="93"></rect>
  <rect class="handle handle--nw" cursor="nwse-resize" x="107" y="189" width="10" height="10"></rect>
  <rect class="handle handle--ne" cursor="nesw-resize" x="289" y="189" width="10" height="10"></rect>
  <rect class="handle handle--se" cursor="nwse-resize" x="289" y="272" width="10" height="10"></rect>
  <rect class="handle handle--sw" cursor="nesw-resize" x="107" y="272" width="10" height="10"></rect>
</g>The overlay rect covers the brushable area defined by brush.extent. The selection rect covers the area defined by the current brush selection. The handle rects cover the edges and corners of the brush selection, allowing the corresponding value in the brush selection to be modified interactively. To modify the brush selection programmatically, use brush.move.brush.move(group, selection, event) ​Examples · Source · Sets the active selection of the brush on the specified group, which must be a selection or a transition of SVG G elements. The selection must be defined as an array of numbers, or null to clear the brush selection. For a two-dimensional brush, it must be defined as [[x0, y0], [x1, y1]], where x0 is the minimum x-value, y0 is the minimum y-value, x1 is the maximum x-value, and y1 is the maximum y-value. For an x-brush, it must be defined as [x0, x1]; for a y-brush, it must be defined as [y0, y1]. The selection may also be specified as a function which returns such an array; if a function, it is invoked for each selected element, being passed the current datum d and index i, with the this context as the current DOM element. The returned array defines the brush selection for that element.brush.clear(group, event) ​Examples · Source · An alias for brush.move with the null selection.brush.extent(extent) ​Examples · Source · If extent is specified, sets the brushable extent to the specified array of points [[x0, y0], [x1, y1]], where [x0, y0] is the top-left corner and [x1, y1] is the bottom-right corner, and returns this brush. The extent may also be specified as a function which returns such an array; if a function, it is invoked for each selected element, being passed the current datum d and index i, with the this context as the current DOM element. If extent is not specified, returns the current extent accessor, which defaults to:jsfunction defaultExtent() {
  var svg = this.ownerSVGElement || this;
  if (svg.hasAttribute("viewBox")) {
    svg = svg.viewBox.baseVal;
    return [[svg.x, svg.y], [svg.x + svg.width, svg.y + svg.height]];
  }
  return [[0, 0], [svg.width.baseVal.value, svg.height.baseVal.value]];
}This default implementation requires that the owner SVG element have a defined viewBox, or width and height attributes. Alternatively, consider using element.getBoundingClientRect. (In Firefox, element.clientWidth and element.clientHeight is zero for SVG elements!)The brush extent determines the size of the invisible overlay and also constrains the brush selection; the brush selection cannot go outside the brush extent.brush.filter(filter) ​Examples · Source · If filter is specified, sets the filter to the specified function and returns the brush. If filter is not specified, returns the current filter, which defaults to:jsfunction filter(event) {
  return !event.ctrlKey && !event.button;
}If the filter returns falsey, the initiating event is ignored and no brush gesture is started. Thus, the filter determines which input events are ignored. The default filter ignores mousedown events on secondary buttons, since those buttons are typically intended for other purposes, such as the context menu.brush.touchable(touchable) ​Source · If touchable is specified, sets the touch support detector to the specified function and returns the brush. If touchable is not specified, returns the current touch support detector, which defaults to:jsfunction touchable() {
  return navigator.maxTouchPoints || ("ontouchstart" in this);
}Touch event listeners are only registered if the detector returns truthy for the corresponding element when the brush is applied. The default detector works well for most browsers that are capable of touch input, but not all; Chrome’s mobile device emulator, for example, fails detection.brush.keyModifiers(modifiers) ​Source · If modifiers is specified, sets whether the brush listens to key events during brushing and returns the brush. If modifiers is not specified, returns the current behavior, which defaults to true.brush.handleSize(size) ​Source · If size is specified, sets the size of the brush handles to the specified number and returns the brush. If size is not specified, returns the current handle size, which defaults to six. This method must be called before applying the brush to a selection; changing the handle size does not affect brushes that were previously rendered.brush.on(typenames, listener) ​Source · If listener is specified, sets the event listener for the specified typenames and returns the brush. If an event listener was already registered for the same type and name, the existing listener is removed before the new listener is added. If listener is null, removes the current event listeners for the specified typenames, if any. If listener is not specified, returns the first currently-assigned listener matching the specified typenames, if any. When a specified event is dispatched, each listener will be invoked with the same context and arguments as selection.on listeners: the current event event and datum d, with the this context as the current DOM element.The typenames is a string containing one or more typename separated by whitespace. Each typename is a type, optionally followed by a period (.) and a name, such as brush.foo and brush.bar; the name allows multiple listeners to be registered for the same type. The type must be one of the following:start - at the start of a brush gesture, such as on mousedown.brush - when the brush moves, such as on mousemove.end - at the end of a brush gesture, such as on mouseup.See dispatch.on and brush events for more.brushSelection(node) ​Examples · Source · Returns the current brush selection for the specified node. Internally, an element’s brush state is stored as element.__brush; however, you should use this method rather than accessing it directly. If the given node has no selection, returns null. Otherwise, the selection is defined as an array of numbers. For a two-dimensional brush, it is [[x0, y0], [x1, y1]], where x0 is the minimum x-value, y0 is the minimum y-value, x1 is the maximum x-value, and y1 is the maximum y-value. For an x-brush, it is [x0, x1]; for a y-brush, it is [y0, y1].Brush events ​When a brush event listener is invoked, it receives the current brush event. The event object exposes several fields:target - the associated brush behavior.type - the string “start”, “brush” or “end”; see brush.on.selection - the current brush selection.sourceEvent - the underlying input event, such as mousemove or touchmove.mode - the string “drag”, “space”, “handle” or “center”; the mode of the brush.PagerPrevious pageControl flowNext paged3-dispatch\n\nd3-brush ​Brushing is the interactive specification a one- or two-dimensional selected region using a pointing gesture, such as by clicking and dragging the mouse. Brushing is often used to select discrete elements, such as dots in a scatterplot or files on a desktop. It can also be used to zoom-in to a region of interest, or to select continuous regions for cross-filtering data or live histograms:The d3-brush module implements brushing for mouse and touch events using SVG. Click and drag on the brush selection to translate the selection. Click and drag on one of the selection handles to move the corresponding edge (or edges) of the selection. Click and drag on the invisible overlay to define a new brush selection, or click anywhere within the brushable region while holding down the META (⌘) key. Holding down the ALT (⌥) key while moving the brush causes it to reposition around its center, while holding down SPACE locks the current brush size, allowing only translation.Brushes also support programmatic control. For example, you can listen to end events, and then initiate a transition with brush.move to snap the brush selection to semantic boundaries:Or you can have the brush recenter when you click outside the current selection:brush() ​Examples · Source · Creates a new two-dimensional brush.brushX() ​Examples · Source · Creates a new one-dimensional brush along the x-dimension.brushY() ​Source · Creates a new one-dimensional brush along the y-dimension.brush(group) ​Examples · Source · Applies the brush to the specified group, which must be a selection of SVG G elements. This function is typically not invoked directly, and is instead invoked via selection.call. For example, to render a brush:jssvg.append("g")
    .attr("class", "brush")
    .call(d3.brush().on("brush", brushed));Internally, the brush uses selection.on to bind the necessary event listeners for dragging. The listeners use the name .brush, so you can subsequently unbind the brush event listeners as follows:jsgroup.on(".brush", null);The brush also creates the SVG elements necessary to display the brush selection and to receive input events for interaction. You can add, remove or modify these elements as desired to change the brush appearance; you can also apply stylesheets to modify the brush appearance. The structure of a two-dimensional brush is as follows:html<g class="brush" fill="none" pointer-events="all" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);">
  <rect class="overlay" pointer-events="all" cursor="crosshair" x="0" y="0" width="960" height="500"></rect>
  <rect class="selection" cursor="move" fill="#777" fill-opacity="0.3" stroke="#fff" shape-rendering="crispEdges" x="112" y="194" width="182" height="83"></rect>
  <rect class="handle handle--n" cursor="ns-resize" x="107" y="189" width="192" height="10"></rect>
  <rect class="handle handle--e" cursor="ew-resize" x="289" y="189" width="10" height="93"></rect>
  <rect class="handle handle--s" cursor="ns-resize" x="107" y="272" width="192" height="10"></rect>
  <rect class="handle handle--w" cursor="ew-resize" x="107" y="189" width="10" height="93"></rect>
  <rect class="handle handle--nw" cursor="nwse-resize" x="107" y="189" width="10" height="10"></rect>
  <rect class="handle handle--ne" cursor="nesw-resize" x="289" y="189" width="10" height="10"></rect>
  <rect class="handle handle--se" cursor="nwse-resize" x="289" y="272" width="10" height="10"></rect>
  <rect class="handle handle--sw" cursor="nesw-resize" x="107" y="272" width="10" height="10"></rect>
</g>The overlay rect covers the brushable area defined by brush.extent. The selection rect covers the area defined by the current brush selection. The handle rects cover the edges and corners of the brush selection, allowing the corresponding value in the brush selection to be modified interactively. To modify the brush selection programmatically, use brush.move.brush.move(group, selection, event) ​Examples · Source · Sets the active selection of the brush on the specified group, which must be a selection or a transition of SVG G elements. The selection must be defined as an array of numbers, or null to clear the brush selection. For a two-dimensional brush, it must be defined as [[x0, y0], [x1, y1]], where x0 is the minimum x-value, y0 is the minimum y-value, x1 is the maximum x-value, and y1 is the maximum y-value. For an x-brush, it must be defined as [x0, x1]; for a y-brush, it must be defined as [y0, y1]. The selection may also be specified as a function which returns such an array; if a function, it is invoked for each selected element, being passed the current datum d and index i, with the this context as the current DOM element. The returned array defines the brush selection for that element.brush.clear(group, event) ​Examples · Source · An alias for brush.move with the null selection.brush.extent(extent) ​Examples · Source · If extent is specified, sets the brushable extent to the specified array of points [[x0, y0], [x1, y1]], where [x0, y0] is the top-left corner and [x1, y1] is the bottom-right corner, and returns this brush. The extent may also be specified as a function which returns such an array; if a function, it is invoked for each selected element, being passed the current datum d and index i, with the this context as the current DOM element. If extent is not specified, returns the current extent accessor, which defaults to:jsfunction defaultExtent() {
  var svg = this.ownerSVGElement || this;
  if (svg.hasAttribute("viewBox")) {
    svg = svg.viewBox.baseVal;
    return [[svg.x, svg.y], [svg.x + svg.width, svg.y + svg.height]];
  }
  return [[0, 0], [svg.width.baseVal.value, svg.height.baseVal.value]];
}This default implementation requires that the owner SVG element have a defined viewBox, or width and height attributes. Alternatively, consider using element.getBoundingClientRect. (In Firefox, element.clientWidth and element.clientHeight is zero for SVG elements!)The brush extent determines the size of the invisible overlay and also constrains the brush selection; the brush selection cannot go outside the brush extent.brush.filter(filter) ​Examples · Source · If filter is specified, sets the filter to the specified function and returns the brush. If filter is not specified, returns the current filter, which defaults to:jsfunction filter(event) {
  return !event.ctrlKey && !event.button;
}If the filter returns falsey, the initiating event is ignored and no brush gesture is started. Thus, the filter determines which input events are ignored. The default filter ignores mousedown events on secondary buttons, since those buttons are typically intended for other purposes, such as the context menu.brush.touchable(touchable) ​Source · If touchable is specified, sets the touch support detector to the specified function and returns the brush. If touchable is not specified, returns the current touch support detector, which defaults to:jsfunction touchable() {
  return navigator.maxTouchPoints || ("ontouchstart" in this);
}Touch event listeners are only registered if the detector returns truthy for the corresponding element when the brush is applied. The default detector works well for most browsers that are capable of touch input, but not all; Chrome’s mobile device emulator, for example, fails detection.brush.keyModifiers(modifiers) ​Source · If modifiers is specified, sets whether the brush listens to key events during brushing and returns the brush. If modifiers is not specified, returns the current behavior, which defaults to true.brush.handleSize(size) ​Source · If size is specified, sets the size of the brush handles to the specified number and returns the brush. If size is not specified, returns the current handle size, which defaults to six. This method must be called before applying the brush to a selection; changing the handle size does not affect brushes that were previously rendered.brush.on(typenames, listener) ​Source · If listener is specified, sets the event listener for the specified typenames and returns the brush. If an event listener was already registered for the same type and name, the existing listener is removed before the new listener is added. If listener is null, removes the current event listeners for the specified typenames, if any. If listener is not specified, returns the first currently-assigned listener matching the specified typenames, if any. When a specified event is dispatched, each listener will be invoked with the same context and arguments as selection.on listeners: the current event event and datum d, with the this context as the current DOM element.The typenames is a string containing one or more typename separated by whitespace. Each typename is a type, optionally followed by a period (.) and a name, such as brush.foo and brush.bar; the name allows multiple listeners to be registered for the same type. The type must be one of the following:start - at the start of a brush gesture, such as on mousedown.brush - when the brush moves, such as on mousemove.end - at the end of a brush gesture, such as on mouseup.See dispatch.on and brush events for more.brushSelection(node) ​Examples · Source · Returns the current brush selection for the specified node. Internally, an element’s brush state is stored as element.__brush; however, you should use this method rather than accessing it directly. If the given node has no selection, returns null. Otherwise, the selection is defined as an array of numbers. For a two-dimensional brush, it is [[x0, y0], [x1, y1]], where x0 is the minimum x-value, y0 is the minimum y-value, x1 is the maximum x-value, and y1 is the maximum y-value. For an x-brush, it is [x0, x1]; for a y-brush, it is [y0, y1].Brush events ​When a brush event listener is invoked, it receives the current brush event. The event object exposes several fields:target - the associated brush behavior.type - the string “start”, “brush” or “end”; see brush.on.selection - the current brush selection.sourceEvent - the underlying input event, such as mousemove or touchmove.mode - the string “drag”, “space”, “handle” or “center”; the mode of the brush.\n\n\n\nd3-hierarchy ​Many datasets are intrinsically hierarchical: geographic entities, such as census blocks, census tracts, counties and states; the command structure of businesses and governments; file systems; software packages. And even non-hierarchical data may be arranged hierarchically as with k-means clustering or phylogenetic trees. A good hierarchical visualization facilitates rapid multiscale inference: micro-observations of individual elements and macro-observations of large groups.This module implements several popular techniques for visualizing hierarchical data:Node-link diagrams show topology using discrete marks for nodes and links, such as a circle for each node and a line connecting each parent and child. The “tidy” tree is delightfully compact, while the dendrogram places leaves at the same level. (These have both polar and Cartesian forms.) Indented trees are useful for interactive browsing.Adjacency diagrams show topology through the relative placement of nodes. They may also encode a quantitative dimension in the area of each node, for example to show revenue or file size. The “icicle” diagram uses rectangles, while the “sunburst” uses annular segments.Enclosure diagrams also use an area encoding, but show topology through containment. A treemap recursively subdivides area into rectangles. Circle-packing tightly nests circles; this is not as space-efficient as a treemap, but perhaps more readily shows topology.See one of:Hierarchies - represent and manipulate hierarchical dataStratify - organize tabular data into a hierarchyTree - construct “tidy” tree diagrams of hierarchiesCluster - construct tree diagrams that place leaf nodes at the same depthPartition - construct space-filling adjacency diagramsPack - construct enclosure diagrams by tightly nesting circlesTreemap - recursively subdivide rectangles by quantitative value\n\nSearchK7.9.0GitHub️ 110.0kOn this paged3-hierarchy ​Many datasets are intrinsically hierarchical: geographic entities, such as census blocks, census tracts, counties and states; the command structure of businesses and governments; file systems; software packages. And even non-hierarchical data may be arranged hierarchically as with k-means clustering or phylogenetic trees. A good hierarchical visualization facilitates rapid multiscale inference: micro-observations of individual elements and macro-observations of large groups.This module implements several popular techniques for visualizing hierarchical data:Node-link diagrams show topology using discrete marks for nodes and links, such as a circle for each node and a line connecting each parent and child. The “tidy” tree is delightfully compact, while the dendrogram places leaves at the same level. (These have both polar and Cartesian forms.) Indented trees are useful for interactive browsing.Adjacency diagrams show topology through the relative placement of nodes. They may also encode a quantitative dimension in the area of each node, for example to show revenue or file size. The “icicle” diagram uses rectangles, while the “sunburst” uses annular segments.Enclosure diagrams also use an area encoding, but show topology through containment. A treemap recursively subdivides area into rectangles. Circle-packing tightly nests circles; this is not as space-efficient as a treemap, but perhaps more readily shows topology.See one of:Hierarchies - represent and manipulate hierarchical dataStratify - organize tabular data into a hierarchyTree - construct “tidy” tree diagrams of hierarchiesCluster - construct tree diagrams that place leaf nodes at the same depthPartition - construct space-filling adjacency diagramsPack - construct enclosure diagrams by tightly nesting circlesTreemap - recursively subdivide rectangles by quantitative valuePagerPrevious pageSpherical mathNext pageHierarchies\n\nd3-hierarchy ​Many datasets are intrinsically hierarchical: geographic entities, such as census blocks, census tracts, counties and states; the command structure of businesses and governments; file systems; software packages. And even non-hierarchical data may be arranged hierarchically as with k-means clustering or phylogenetic trees. A good hierarchical visualization facilitates rapid multiscale inference: micro-observations of individual elements and macro-observations of large groups.This module implements several popular techniques for visualizing hierarchical data:Node-link diagrams show topology using discrete marks for nodes and links, such as a circle for each node and a line connecting each parent and child. The “tidy” tree is delightfully compact, while the dendrogram places leaves at the same level. (These have both polar and Cartesian forms.) Indented trees are useful for interactive browsing.Adjacency diagrams show topology through the relative placement of nodes. They may also encode a quantitative dimension in the area of each node, for example to show revenue or file size. The “icicle” diagram uses rectangles, while the “sunburst” uses annular segments.Enclosure diagrams also use an area encoding, but show topology through containment. A treemap recursively subdivides area into rectangles. Circle-packing tightly nests circles; this is not as space-efficient as a treemap, but perhaps more readily shows topology.See one of:Hierarchies - represent and manipulate hierarchical dataStratify - organize tabular data into a hierarchyTree - construct “tidy” tree diagrams of hierarchiesCluster - construct tree diagrams that place leaf nodes at the same depthPartition - construct space-filling adjacency diagramsPack - construct enclosure diagrams by tightly nesting circlesTreemap - recursively subdivide rectangles by quantitative value\n\n\n\nd3-geo ​Map projections are sometimes implemented as point transformations: a function that takes a given longitude lambda and latitude phi, and returns the corresponding xy position on the plane. For instance, here is the spherical Mercator projection (in radians):jsfunction mercator(lambda, phi) {
  const x = lambda;
  const y = Math.log(Math.tan(Math.PI / 4 + phi / 2));
  return [x, y];
}This is a reasonable approach if your geometry consists only of points. But what about discrete geometry such as polygons and polylines?Discrete geometry introduces new challenges when projecting from the sphere to the plane. The edges of a spherical polygon are geodesics (segments of great circles), not straight lines. Geodesics become curves in all map projections except gnomonic, and thus accurate projection requires interpolation along each arc. D3 uses adaptive sampling inspired by Visvalingam’s line simplification method to balance accuracy and performance.The projection of polygons and polylines must also deal with the topological differences between the sphere and the plane. Some projections require cutting geometry that crosses the antimeridian, while others require clipping geometry to a great circle. Spherical polygons also require a winding order convention to determine which side of the polygon is the inside: the exterior ring for polygons smaller than a hemisphere must be clockwise, while the exterior ring for polygons larger than a hemisphere must be anticlockwise. Interior rings representing holes must use the opposite winding order of their exterior ring.D3 uses spherical GeoJSON to represent geographic features in JavaScript. D3 supports a wide variety of common and unusual map projections. And because D3 uses spherical geometry to represent data, you can apply any aspect to any projection by rotating geometry.See one of:Paths - generate SVG path data from GeoJSONProjections - project spherical geometry to the planeStreams - transform (either spherical or planar) geometryShapes - generate circles, lines, and other spherical geometrySpherical math - low-level methods for spherical geometryTIPTo convert shapefiles to GeoJSON, use shp2json, part of the shapefile package. See Command-Line Cartography for an introduction to d3-geo and related tools. See also TopoJSON, an extension of GeoJSON that is significantly more compact and encodes topology.CAUTIOND3’s winding order convention is also used by TopoJSON and ESRI shapefiles; however, it is the opposite convention of GeoJSON’s RFC 7946. Also note that standard GeoJSON WGS84 uses planar equirectangular coordinates, not spherical coordinates, and thus may require stitching to remove antimeridian cuts.\n\nSearchK7.9.0GitHub️ 110.0kOn this paged3-geo ​Map projections are sometimes implemented as point transformations: a function that takes a given longitude lambda and latitude phi, and returns the corresponding xy position on the plane. For instance, here is the spherical Mercator projection (in radians):jsfunction mercator(lambda, phi) {
  const x = lambda;
  const y = Math.log(Math.tan(Math.PI / 4 + phi / 2));
  return [x, y];
}This is a reasonable approach if your geometry consists only of points. But what about discrete geometry such as polygons and polylines?Discrete geometry introduces new challenges when projecting from the sphere to the plane. The edges of a spherical polygon are geodesics (segments of great circles), not straight lines. Geodesics become curves in all map projections except gnomonic, and thus accurate projection requires interpolation along each arc. D3 uses adaptive sampling inspired by Visvalingam’s line simplification method to balance accuracy and performance.The projection of polygons and polylines must also deal with the topological differences between the sphere and the plane. Some projections require cutting geometry that crosses the antimeridian, while others require clipping geometry to a great circle. Spherical polygons also require a winding order convention to determine which side of the polygon is the inside: the exterior ring for polygons smaller than a hemisphere must be clockwise, while the exterior ring for polygons larger than a hemisphere must be anticlockwise. Interior rings representing holes must use the opposite winding order of their exterior ring.D3 uses spherical GeoJSON to represent geographic features in JavaScript. D3 supports a wide variety of common and unusual map projections. And because D3 uses spherical geometry to represent data, you can apply any aspect to any projection by rotating geometry.See one of:Paths - generate SVG path data from GeoJSONProjections - project spherical geometry to the planeStreams - transform (either spherical or planar) geometryShapes - generate circles, lines, and other spherical geometrySpherical math - low-level methods for spherical geometryTIPTo convert shapefiles to GeoJSON, use shp2json, part of the shapefile package. See Command-Line Cartography for an introduction to d3-geo and related tools. See also TopoJSON, an extension of GeoJSON that is significantly more compact and encodes topology.CAUTIOND3’s winding order convention is also used by TopoJSON and ESRI shapefiles; however, it is the opposite convention of GeoJSON’s RFC 7946. Also note that standard GeoJSON WGS84 uses planar equirectangular coordinates, not spherical coordinates, and thus may require stitching to remove antimeridian cuts.PagerPrevious pagePosition forcesNext pagePaths\n\nd3-geo ​Map projections are sometimes implemented as point transformations: a function that takes a given longitude lambda and latitude phi, and returns the corresponding xy position on the plane. For instance, here is the spherical Mercator projection (in radians):jsfunction mercator(lambda, phi) {
  const x = lambda;
  const y = Math.log(Math.tan(Math.PI / 4 + phi / 2));
  return [x, y];
}This is a reasonable approach if your geometry consists only of points. But what about discrete geometry such as polygons and polylines?Discrete geometry introduces new challenges when projecting from the sphere to the plane. The edges of a spherical polygon are geodesics (segments of great circles), not straight lines. Geodesics become curves in all map projections except gnomonic, and thus accurate projection requires interpolation along each arc. D3 uses adaptive sampling inspired by Visvalingam’s line simplification method to balance accuracy and performance.The projection of polygons and polylines must also deal with the topological differences between the sphere and the plane. Some projections require cutting geometry that crosses the antimeridian, while others require clipping geometry to a great circle. Spherical polygons also require a winding order convention to determine which side of the polygon is the inside: the exterior ring for polygons smaller than a hemisphere must be clockwise, while the exterior ring for polygons larger than a hemisphere must be anticlockwise. Interior rings representing holes must use the opposite winding order of their exterior ring.D3 uses spherical GeoJSON to represent geographic features in JavaScript. D3 supports a wide variety of common and unusual map projections. And because D3 uses spherical geometry to represent data, you can apply any aspect to any projection by rotating geometry.See one of:Paths - generate SVG path data from GeoJSONProjections - project spherical geometry to the planeStreams - transform (either spherical or planar) geometryShapes - generate circles, lines, and other spherical geometrySpherical math - low-level methods for spherical geometryTIPTo convert shapefiles to GeoJSON, use shp2json, part of the shapefile package. See Command-Line Cartography for an introduction to d3-geo and related tools. See also TopoJSON, an extension of GeoJSON that is significantly more compact and encodes topology.CAUTIOND3’s winding order convention is also used by TopoJSON and ESRI shapefiles; however, it is the opposite convention of GeoJSON’s RFC 7946. Also note that standard GeoJSON WGS84 uses planar equirectangular coordinates, not spherical coordinates, and thus may require stitching to remove antimeridian cuts.\n\n\n\nd3-array ​Array manipulation, ordering, searching, summarizing, etc.See one of:Adding numbers - Add floating point values with full precision.Binning data - Bin discrete samples into continuous, non-overlapping intervals.Bisecting data - Quickly find a value in a sorted array.Blurring data - Blur quantitative values in one or two dimensions.Grouping data - Group discrete values.Interning values - Create maps and sets with non-primitive values such as dates.Set operations - Logical operations on sets.Sorting data - Sort and reorder arrays of values.Summarizing data - Compute summary statistics.Ticks - Generate representative values from a continuous interval.Transforming data - Derive new arrays.\n\nSearchK7.9.0GitHub️ 110.0kOn this paged3-array ​Array manipulation, ordering, searching, summarizing, etc.See one of:Adding numbers - Add floating point values with full precision.Binning data - Bin discrete samples into continuous, non-overlapping intervals.Bisecting data - Quickly find a value in a sorted array.Blurring data - Blur quantitative values in one or two dimensions.Grouping data - Group discrete values.Interning values - Create maps and sets with non-primitive values such as dates.Set operations - Logical operations on sets.Sorting data - Sort and reorder arrays of values.Summarizing data - Compute summary statistics.Ticks - Generate representative values from a continuous interval.Transforming data - Derive new arrays.PagerPrevious paged3-zoomNext pageAdding numbers\n\nd3-array ​Array manipulation, ordering, searching, summarizing, etc.See one of:Adding numbers - Add floating point values with full precision.Binning data - Bin discrete samples into continuous, non-overlapping intervals.Bisecting data - Quickly find a value in a sorted array.Blurring data - Blur quantitative values in one or two dimensions.Grouping data - Group discrete values.Interning values - Create maps and sets with non-primitive values such as dates.Set operations - Logical operations on sets.Sorting data - Sort and reorder arrays of values.Summarizing data - Compute summary statistics.Ticks - Generate representative values from a continuous interval.Transforming data - Derive new arrays.\n\n\n\nGetting started ​D3 works in any JavaScript environment.Try D3 online ​The fastest way to get started (and get help) with D3 is on Observable! D3 is available by default in notebooks as part of Observable’s standard library. To create something with D3, return the generated DOM element from a cell. Here is a blank chart to get you started:js{
  // Declare the chart dimensions and margins.
  const width = 640;
  const height = 400;
  const marginTop = 20;
  const marginRight = 20;
  const marginBottom = 30;
  const marginLeft = 40;

  // Declare the x (horizontal position) scale.
  const x = d3.scaleUtc()
      .domain([new Date("2023-01-01"), new Date("2024-01-01")])
      .range([marginLeft, width - marginRight]);

  // Declare the y (vertical position) scale.
  const y = d3.scaleLinear()
      .domain([0, 100])
      .range([height - marginBottom, marginTop]);

  // Create the SVG container.
  const svg = d3.create("svg")
      .attr("width", width)
      .attr("height", height);

  // Add the x-axis.
  svg.append("g")
      .attr("transform", `translate(0,${height - marginBottom})`)
      .call(d3.axisBottom(x));

  // Add the y-axis.
  svg.append("g")
      .attr("transform", `translate(${marginLeft},0)`)
      .call(d3.axisLeft(y));

  // Return the SVG element.
  return svg.node();
}As a more complete example, try one of these starter templates:Area chartBar chartDonut chartHistogramLine chartSee the D3 gallery for more forkable examples.Observable includes a few D3 snippets when you click + to add a cell (type “d3” when the cell menu is open to filter), as well as convenient sample datasets to try out D3 features. Or upload a CSV or JSON file to start playing with your data. You can also fork any of the hundreds of notebooks we’ve published for a head start.Observable is free for public use. Sign up for a Pro account to connect to private databases, collaborate on private notebooks, and more.D3 in vanilla HTML ​In vanilla HTML, you can load D3 from a CDN such as jsDelivr or you can download it locally. We recommend using the CDN-hosted ES module bundle. But for those who need it, we also provide a UMD bundle that exports the d3 global when loaded as a plain script.ESM + CDNUMD + CDNUMD + localhtml<!DOCTYPE html>
<div id="container"></div>
<script type="module">

import * as d3 from "https://cdn.jsdelivr.net/npm/d3@7/+esm";

// Declare the chart dimensions and margins.
const width = 640;
const height = 400;
const marginTop = 20;
const marginRight = 20;
const marginBottom = 30;
const marginLeft = 40;

// Declare the x (horizontal position) scale.
const x = d3.scaleUtc()
    .domain([new Date("2023-01-01"), new Date("2024-01-01")])
    .range([marginLeft, width - marginRight]);

// Declare the y (vertical position) scale.
const y = d3.scaleLinear()
    .domain([0, 100])
    .range([height - marginBottom, marginTop]);

// Create the SVG container.
const svg = d3.create("svg")
    .attr("width", width)
    .attr("height", height);

// Add the x-axis.
svg.append("g")
    .attr("transform", `translate(0,${height - marginBottom})`)
    .call(d3.axisBottom(x));

// Add the y-axis.
svg.append("g")
    .attr("transform", `translate(${marginLeft},0)`)
    .call(d3.axisLeft(y));

// Append the SVG element.
container.append(svg.node());

</script>html<!DOCTYPE html>
<div id="container"></div>
<script src="https://cdn.jsdelivr.net/npm/d3@7"></script>
<script type="module">

// Declare the chart dimensions and margins.
const width = 640;
const height = 400;
const marginTop = 20;
const marginRight = 20;
const marginBottom = 30;
const marginLeft = 40;

// Declare the x (horizontal position) scale.
const x = d3.scaleUtc()
    .domain([new Date("2023-01-01"), new Date("2024-01-01")])
    .range([marginLeft, width - marginRight]);

// Declare the y (vertical position) scale.
const y = d3.scaleLinear()
    .domain([0, 100])
    .range([height - marginBottom, marginTop]);

// Create the SVG container.
const svg = d3.create("svg")
    .attr("width", width)
    .attr("height", height);

// Add the x-axis.
svg.append("g")
    .attr("transform", `translate(0,${height - marginBottom})`)
    .call(d3.axisBottom(x));

// Add the y-axis.
svg.append("g")
    .attr("transform", `translate(${marginLeft},0)`)
    .call(d3.axisLeft(y));

// Append the SVG element.
container.append(svg.node());

</script>html<!DOCTYPE html>
<div id="container"></div>
<script src="d3.js"></script>
<script type="module">

// Declare the chart dimensions and margins.
const width = 640;
const height = 400;
const marginTop = 20;
const marginRight = 20;
const marginBottom = 30;
const marginLeft = 40;

// Declare the x (horizontal position) scale.
const x = d3.scaleUtc()
    .domain([new Date("2023-01-01"), new Date("2024-01-01")])
    .range([marginLeft, width - marginRight]);

// Declare the y (vertical position) scale.
const y = d3.scaleLinear()
    .domain([0, 100])
    .range([height - marginBottom, marginTop]);

// Create the SVG container.
const svg = d3.create("svg")
    .attr("width", width)
    .attr("height", height);

// Add the x-axis.
svg.append("g")
    .attr("transform", `translate(0,${height - marginBottom})`)
    .call(d3.axisBottom(x));

// Add the y-axis.
svg.append("g")
    .attr("transform", `translate(${marginLeft},0)`)
    .call(d3.axisLeft(y));

// Append the SVG element.
container.append(svg.node());

</script>You can also import and destructure individual D3 modules like so:html<script type="module">

import {forceSimulation, forceCollide, forceX} from "https://cdn.jsdelivr.net/npm/d3-force@3/+esm";

const nodes = [{}, {}];
const simulation = forceSimulation(nodes)
    .force("x", forceX())
    .force("collide", forceCollide(5))
    .on("tick", () => console.log(nodes[0].x));

</script>If you’d prefer to run D3 locally (or offline), you can download the UMD bundles of D3 here:d3.v7.jsd3.v7.min.jsThen, create an index.html file as shown above in the UMD + local tab. Use the non-minified bundle for debugging, and the minified bundle for faster performance in production.Installing from npm ​If you’re developing a web application using Node, you can install D3 via yarn, npm, pnpm, or your preferred package manager.yarnnpmpnpmbashyarn add d3bashnpm install d3bashpnpm add d3You can then load D3 into your app as:jsimport * as d3 from "d3";You can instead import specific symbols if you prefer:jsimport {select, selectAll} from "d3";Alternatively you can install and import from D3 submodules:jsimport {mean, median} from "d3-array";TypeScript declarations are available via DefinitelyTyped.D3 in React ​Most D3 modules (including d3-scale, d3-array, d3-interpolate, and d3-format) don’t interact with the DOM, so there is no difference when using them in React. You can use them in JSX for purely declarative visualization, such as the line plot below.LinePlot.jsxjsximport * as d3 from "d3";

export default function LinePlot({
  data,
  width = 640,
  height = 400,
  marginTop = 20,
  marginRight = 20,
  marginBottom = 20,
  marginLeft = 20
}) {
  const x = d3.scaleLinear([0, data.length - 1], [marginLeft, width - marginRight]);
  const y = d3.scaleLinear(d3.extent(data), [height - marginBottom, marginTop]);
  const line = d3.line((d, i) => x(i), y);
  return (
    <svg width={width} height={height}>
      <path fill="none" stroke="currentColor" strokeWidth="1.5" d={line(data)} />
      <g fill="white" stroke="currentColor" strokeWidth="1.5">
        {data.map((d, i) => (<circle key={i} cx={x(i)} cy={y(d)} r="2.5" />))}
      </g>
    </svg>
  );
}Sandbox ↗︎D3 modules that operate on selections (including d3-selection, d3-transition, and d3-axis) do manipulate the DOM, which competes with React’s virtual DOM. In those cases, you can attach a ref to an element and pass it to D3 in a useEffect hook.LinePlot.jsxjsximport * as d3 from "d3";
import {useRef, useEffect} from "react";

export default function LinePlot({
  data,
  width = 640,
  height = 400,
  marginTop = 20,
  marginRight = 20,
  marginBottom = 30,
  marginLeft = 40
}) {
  const gx = useRef();
  const gy = useRef();
  const x = d3.scaleLinear([0, data.length - 1], [marginLeft, width - marginRight]);
  const y = d3.scaleLinear(d3.extent(data), [height - marginBottom, marginTop]);
  const line = d3.line((d, i) => x(i), y);
  useEffect(() => void d3.select(gx.current).call(d3.axisBottom(x)), [gx, x]);
  useEffect(() => void d3.select(gy.current).call(d3.axisLeft(y)), [gy, y]);
  return (
    <svg width={width} height={height}>
      <g ref={gx} transform={`translate(0,${height - marginBottom})`} />
      <g ref={gy} transform={`translate(${marginLeft},0)`} />
      <path fill="none" stroke="currentColor" strokeWidth="1.5" d={line(data)} />
      <g fill="white" stroke="currentColor" strokeWidth="1.5">
        {data.map((d, i) => (<circle key={i} cx={x(i)} cy={y(d)} r="2.5" />))}
      </g>
    </svg>
  );
}Sandbox ↗︎For more guidance using D3 in React, see Amelia Wattenberger’s post.D3 in Svelte ​As with React, you can use Svelte exclusively for rendering if you like, and only use D3 modules that don’t manipulate the DOM. Here is a line plot of an array of numbers that uses d3-shape and d3-scale.LinePlot.sveltesvelte<script>
  import * as d3 from 'd3';

  export let data;
  export let width = 640;
  export let height = 400;
  export let marginTop = 20;
  export let marginRight = 20;
  export let marginBottom = 20;
  export let marginLeft = 20;

  $: x = d3.scaleLinear([0, data.length - 1], [marginLeft, width - marginRight]);
  $: y = d3.scaleLinear(d3.extent(data), [height - marginBottom, marginTop]);
  $: line = d3.line((d, i) => x(i), y);
</script>
<svg width={width} height={height}>
  <path fill="none" stroke="currentColor" stroke-width="1.5" d={line(data)} />
  <g fill="white" stroke="currentColor" stroke-width="1.5">
    {#each data as d, i}
      <circle key={i} cx={x(i)} cy={y(d)} r="2.5" />
    {/each}
  </g>
</svg>REPL ↗︎Svelte’s reactive statements ($:) pair nicely with D3 data joins for efficient updates. Below, we use them to render dynamic axes as the data changes.LinePlot.sveltesvelte<script>
  import * as d3 from 'd3';

  export let data;
  export let width = 640;
  export let height = 400;
  export let marginTop = 20;
  export let marginRight = 20;
  export let marginBottom = 30;
  export let marginLeft = 40;

  let gx;
  let gy;

  $: x = d3.scaleLinear([0, data.length - 1], [marginLeft, width - marginRight]);
  $: y = d3.scaleLinear(d3.extent(data), [height - marginBottom, marginTop]);
  $: line = d3.line((d, i) => x(i), y);
  $: d3.select(gy).call(d3.axisLeft(y));
  $: d3.select(gx).call(d3.axisBottom(x));
</script>
<svg width={width} height={height}>
  <g bind:this={gx} transform="translate(0,{height - marginBottom})" />
  <g bind:this={gy} transform="translate({marginLeft},0)" />
  <path fill="none" stroke="currentColor" stroke-width="1.5" d={line(data)} />
  <g fill="white" stroke="currentColor" stroke-width="1.5">
    {#each data as d, i}
      <circle key={i} cx={x(i)} cy={y(d)} r="2.5" />
    {/each}
  </g>
</svg>REPL ↗︎\n\nSearchK7.9.0GitHub️ 110.0kOn this pageGetting started ​D3 works in any JavaScript environment.Try D3 online ​The fastest way to get started (and get help) with D3 is on Observable! D3 is available by default in notebooks as part of Observable’s standard library. To create something with D3, return the generated DOM element from a cell. Here is a blank chart to get you started:js{
  // Declare the chart dimensions and margins.
  const width = 640;
  const height = 400;
  const marginTop = 20;
  const marginRight = 20;
  const marginBottom = 30;
  const marginLeft = 40;

  // Declare the x (horizontal position) scale.
  const x = d3.scaleUtc()
      .domain([new Date("2023-01-01"), new Date("2024-01-01")])
      .range([marginLeft, width - marginRight]);

  // Declare the y (vertical position) scale.
  const y = d3.scaleLinear()
      .domain([0, 100])
      .range([height - marginBottom, marginTop]);

  // Create the SVG container.
  const svg = d3.create("svg")
      .attr("width", width)
      .attr("height", height);

  // Add the x-axis.
  svg.append("g")
      .attr("transform", `translate(0,${height - marginBottom})`)
      .call(d3.axisBottom(x));

  // Add the y-axis.
  svg.append("g")
      .attr("transform", `translate(${marginLeft},0)`)
      .call(d3.axisLeft(y));

  // Return the SVG element.
  return svg.node();
}As a more complete example, try one of these starter templates:Area chartBar chartDonut chartHistogramLine chartSee the D3 gallery for more forkable examples.Observable includes a few D3 snippets when you click + to add a cell (type “d3” when the cell menu is open to filter), as well as convenient sample datasets to try out D3 features. Or upload a CSV or JSON file to start playing with your data. You can also fork any of the hundreds of notebooks we’ve published for a head start.Observable is free for public use. Sign up for a Pro account to connect to private databases, collaborate on private notebooks, and more.D3 in vanilla HTML ​In vanilla HTML, you can load D3 from a CDN such as jsDelivr or you can download it locally. We recommend using the CDN-hosted ES module bundle. But for those who need it, we also provide a UMD bundle that exports the d3 global when loaded as a plain script.ESM + CDNUMD + CDNUMD + localhtml<!DOCTYPE html>
<div id="container"></div>
<script type="module">

import * as d3 from "https://cdn.jsdelivr.net/npm/d3@7/+esm";

// Declare the chart dimensions and margins.
const width = 640;
const height = 400;
const marginTop = 20;
const marginRight = 20;
const marginBottom = 30;
const marginLeft = 40;

// Declare the x (horizontal position) scale.
const x = d3.scaleUtc()
    .domain([new Date("2023-01-01"), new Date("2024-01-01")])
    .range([marginLeft, width - marginRight]);

// Declare the y (vertical position) scale.
const y = d3.scaleLinear()
    .domain([0, 100])
    .range([height - marginBottom, marginTop]);

// Create the SVG container.
const svg = d3.create("svg")
    .attr("width", width)
    .attr("height", height);

// Add the x-axis.
svg.append("g")
    .attr("transform", `translate(0,${height - marginBottom})`)
    .call(d3.axisBottom(x));

// Add the y-axis.
svg.append("g")
    .attr("transform", `translate(${marginLeft},0)`)
    .call(d3.axisLeft(y));

// Append the SVG element.
container.append(svg.node());

</script>html<!DOCTYPE html>
<div id="container"></div>
<script src="https://cdn.jsdelivr.net/npm/d3@7"></script>
<script type="module">

// Declare the chart dimensions and margins.
const width = 640;
const height = 400;
const marginTop = 20;
const marginRight = 20;
const marginBottom = 30;
const marginLeft = 40;

// Declare the x (horizontal position) scale.
const x = d3.scaleUtc()
    .domain([new Date("2023-01-01"), new Date("2024-01-01")])
    .range([marginLeft, width - marginRight]);

// Declare the y (vertical position) scale.
const y = d3.scaleLinear()
    .domain([0, 100])
    .range([height - marginBottom, marginTop]);

// Create the SVG container.
const svg = d3.create("svg")
    .attr("width", width)
    .attr("height", height);

// Add the x-axis.
svg.append("g")
    .attr("transform", `translate(0,${height - marginBottom})`)
    .call(d3.axisBottom(x));

// Add the y-axis.
svg.append("g")
    .attr("transform", `translate(${marginLeft},0)`)
    .call(d3.axisLeft(y));

// Append the SVG element.
container.append(svg.node());

</script>html<!DOCTYPE html>
<div id="container"></div>
<script src="d3.js"></script>
<script type="module">

// Declare the chart dimensions and margins.
const width = 640;
const height = 400;
const marginTop = 20;
const marginRight = 20;
const marginBottom = 30;
const marginLeft = 40;

// Declare the x (horizontal position) scale.
const x = d3.scaleUtc()
    .domain([new Date("2023-01-01"), new Date("2024-01-01")])
    .range([marginLeft, width - marginRight]);

// Declare the y (vertical position) scale.
const y = d3.scaleLinear()
    .domain([0, 100])
    .range([height - marginBottom, marginTop]);

// Create the SVG container.
const svg = d3.create("svg")
    .attr("width", width)
    .attr("height", height);

// Add the x-axis.
svg.append("g")
    .attr("transform", `translate(0,${height - marginBottom})`)
    .call(d3.axisBottom(x));

// Add the y-axis.
svg.append("g")
    .attr("transform", `translate(${marginLeft},0)`)
    .call(d3.axisLeft(y));

// Append the SVG element.
container.append(svg.node());

</script>You can also import and destructure individual D3 modules like so:html<script type="module">

import {forceSimulation, forceCollide, forceX} from "https://cdn.jsdelivr.net/npm/d3-force@3/+esm";

const nodes = [{}, {}];
const simulation = forceSimulation(nodes)
    .force("x", forceX())
    .force("collide", forceCollide(5))
    .on("tick", () => console.log(nodes[0].x));

</script>If you’d prefer to run D3 locally (or offline), you can download the UMD bundles of D3 here:d3.v7.jsd3.v7.min.jsThen, create an index.html file as shown above in the UMD + local tab. Use the non-minified bundle for debugging, and the minified bundle for faster performance in production.Installing from npm ​If you’re developing a web application using Node, you can install D3 via yarn, npm, pnpm, or your preferred package manager.yarnnpmpnpmbashyarn add d3bashnpm install d3bashpnpm add d3You can then load D3 into your app as:jsimport * as d3 from "d3";You can instead import specific symbols if you prefer:jsimport {select, selectAll} from "d3";Alternatively you can install and import from D3 submodules:jsimport {mean, median} from "d3-array";TypeScript declarations are available via DefinitelyTyped.D3 in React ​Most D3 modules (including d3-scale, d3-array, d3-interpolate, and d3-format) don’t interact with the DOM, so there is no difference when using them in React. You can use them in JSX for purely declarative visualization, such as the line plot below.LinePlot.jsxjsximport * as d3 from "d3";

export default function LinePlot({
  data,
  width = 640,
  height = 400,
  marginTop = 20,
  marginRight = 20,
  marginBottom = 20,
  marginLeft = 20
}) {
  const x = d3.scaleLinear([0, data.length - 1], [marginLeft, width - marginRight]);
  const y = d3.scaleLinear(d3.extent(data), [height - marginBottom, marginTop]);
  const line = d3.line((d, i) => x(i), y);
  return (
    <svg width={width} height={height}>
      <path fill="none" stroke="currentColor" strokeWidth="1.5" d={line(data)} />
      <g fill="white" stroke="currentColor" strokeWidth="1.5">
        {data.map((d, i) => (<circle key={i} cx={x(i)} cy={y(d)} r="2.5" />))}
      </g>
    </svg>
  );
}Sandbox ↗︎D3 modules that operate on selections (including d3-selection, d3-transition, and d3-axis) do manipulate the DOM, which competes with React’s virtual DOM. In those cases, you can attach a ref to an element and pass it to D3 in a useEffect hook.LinePlot.jsxjsximport * as d3 from "d3";
import {useRef, useEffect} from "react";

export default function LinePlot({
  data,
  width = 640,
  height = 400,
  marginTop = 20,
  marginRight = 20,
  marginBottom = 30,
  marginLeft = 40
}) {
  const gx = useRef();
  const gy = useRef();
  const x = d3.scaleLinear([0, data.length - 1], [marginLeft, width - marginRight]);
  const y = d3.scaleLinear(d3.extent(data), [height - marginBottom, marginTop]);
  const line = d3.line((d, i) => x(i), y);
  useEffect(() => void d3.select(gx.current).call(d3.axisBottom(x)), [gx, x]);
  useEffect(() => void d3.select(gy.current).call(d3.axisLeft(y)), [gy, y]);
  return (
    <svg width={width} height={height}>
      <g ref={gx} transform={`translate(0,${height - marginBottom})`} />
      <g ref={gy} transform={`translate(${marginLeft},0)`} />
      <path fill="none" stroke="currentColor" strokeWidth="1.5" d={line(data)} />
      <g fill="white" stroke="currentColor" strokeWidth="1.5">
        {data.map((d, i) => (<circle key={i} cx={x(i)} cy={y(d)} r="2.5" />))}
      </g>
    </svg>
  );
}Sandbox ↗︎For more guidance using D3 in React, see Amelia Wattenberger’s post.D3 in Svelte ​As with React, you can use Svelte exclusively for rendering if you like, and only use D3 modules that don’t manipulate the DOM. Here is a line plot of an array of numbers that uses d3-shape and d3-scale.LinePlot.sveltesvelte<script>
  import * as d3 from 'd3';

  export let data;
  export let width = 640;
  export let height = 400;
  export let marginTop = 20;
  export let marginRight = 20;
  export let marginBottom = 20;
  export let marginLeft = 20;

  $: x = d3.scaleLinear([0, data.length - 1], [marginLeft, width - marginRight]);
  $: y = d3.scaleLinear(d3.extent(data), [height - marginBottom, marginTop]);
  $: line = d3.line((d, i) => x(i), y);
</script>
<svg width={width} height={height}>
  <path fill="none" stroke="currentColor" stroke-width="1.5" d={line(data)} />
  <g fill="white" stroke="currentColor" stroke-width="1.5">
    {#each data as d, i}
      <circle key={i} cx={x(i)} cy={y(d)} r="2.5" />
    {/each}
  </g>
</svg>REPL ↗︎Svelte’s reactive statements ($:) pair nicely with D3 data joins for efficient updates. Below, we use them to render dynamic axes as the data changes.LinePlot.sveltesvelte<script>
  import * as d3 from 'd3';

  export let data;
  export let width = 640;
  export let height = 400;
  export let marginTop = 20;
  export let marginRight = 20;
  export let marginBottom = 30;
  export let marginLeft = 40;

  let gx;
  let gy;

  $: x = d3.scaleLinear([0, data.length - 1], [marginLeft, width - marginRight]);
  $: y = d3.scaleLinear(d3.extent(data), [height - marginBottom, marginTop]);
  $: line = d3.line((d, i) => x(i), y);
  $: d3.select(gy).call(d3.axisLeft(y));
  $: d3.select(gx).call(d3.axisBottom(x));
</script>
<svg width={width} height={height}>
  <g bind:this={gx} transform="translate(0,{height - marginBottom})" />
  <g bind:this={gy} transform="translate({marginLeft},0)" />
  <path fill="none" stroke="currentColor" stroke-width="1.5" d={line(data)} />
  <g fill="white" stroke="currentColor" stroke-width="1.5">
    {#each data as d, i}
      <circle key={i} cx={x(i)} cy={y(d)} r="2.5" />
    {/each}
  </g>
</svg>REPL ↗︎PagerPrevious pageWhat is D3?Next pageAPI index\n\nGetting started ​D3 works in any JavaScript environment.Try D3 online ​The fastest way to get started (and get help) with D3 is on Observable! D3 is available by default in notebooks as part of Observable’s standard library. To create something with D3, return the generated DOM element from a cell. Here is a blank chart to get you started:js{
  // Declare the chart dimensions and margins.
  const width = 640;
  const height = 400;
  const marginTop = 20;
  const marginRight = 20;
  const marginBottom = 30;
  const marginLeft = 40;

  // Declare the x (horizontal position) scale.
  const x = d3.scaleUtc()
      .domain([new Date("2023-01-01"), new Date("2024-01-01")])
      .range([marginLeft, width - marginRight]);

  // Declare the y (vertical position) scale.
  const y = d3.scaleLinear()
      .domain([0, 100])
      .range([height - marginBottom, marginTop]);

  // Create the SVG container.
  const svg = d3.create("svg")
      .attr("width", width)
      .attr("height", height);

  // Add the x-axis.
  svg.append("g")
      .attr("transform", `translate(0,${height - marginBottom})`)
      .call(d3.axisBottom(x));

  // Add the y-axis.
  svg.append("g")
      .attr("transform", `translate(${marginLeft},0)`)
      .call(d3.axisLeft(y));

  // Return the SVG element.
  return svg.node();
}As a more complete example, try one of these starter templates:Area chartBar chartDonut chartHistogramLine chartSee the D3 gallery for more forkable examples.Observable includes a few D3 snippets when you click + to add a cell (type “d3” when the cell menu is open to filter), as well as convenient sample datasets to try out D3 features. Or upload a CSV or JSON file to start playing with your data. You can also fork any of the hundreds of notebooks we’ve published for a head start.Observable is free for public use. Sign up for a Pro account to connect to private databases, collaborate on private notebooks, and more.D3 in vanilla HTML ​In vanilla HTML, you can load D3 from a CDN such as jsDelivr or you can download it locally. We recommend using the CDN-hosted ES module bundle. But for those who need it, we also provide a UMD bundle that exports the d3 global when loaded as a plain script.ESM + CDNUMD + CDNUMD + localhtml<!DOCTYPE html>
<div id="container"></div>
<script type="module">

import * as d3 from "https://cdn.jsdelivr.net/npm/d3@7/+esm";

// Declare the chart dimensions and margins.
const width = 640;
const height = 400;
const marginTop = 20;
const marginRight = 20;
const marginBottom = 30;
const marginLeft = 40;

// Declare the x (horizontal position) scale.
const x = d3.scaleUtc()
    .domain([new Date("2023-01-01"), new Date("2024-01-01")])
    .range([marginLeft, width - marginRight]);

// Declare the y (vertical position) scale.
const y = d3.scaleLinear()
    .domain([0, 100])
    .range([height - marginBottom, marginTop]);

// Create the SVG container.
const svg = d3.create("svg")
    .attr("width", width)
    .attr("height", height);

// Add the x-axis.
svg.append("g")
    .attr("transform", `translate(0,${height - marginBottom})`)
    .call(d3.axisBottom(x));

// Add the y-axis.
svg.append("g")
    .attr("transform", `translate(${marginLeft},0)`)
    .call(d3.axisLeft(y));

// Append the SVG element.
container.append(svg.node());

</script>html<!DOCTYPE html>
<div id="container"></div>
<script src="https://cdn.jsdelivr.net/npm/d3@7"></script>
<script type="module">

// Declare the chart dimensions and margins.
const width = 640;
const height = 400;
const marginTop = 20;
const marginRight = 20;
const marginBottom = 30;
const marginLeft = 40;

// Declare the x (horizontal position) scale.
const x = d3.scaleUtc()
    .domain([new Date("2023-01-01"), new Date("2024-01-01")])
    .range([marginLeft, width - marginRight]);

// Declare the y (vertical position) scale.
const y = d3.scaleLinear()
    .domain([0, 100])
    .range([height - marginBottom, marginTop]);

// Create the SVG container.
const svg = d3.create("svg")
    .attr("width", width)
    .attr("height", height);

// Add the x-axis.
svg.append("g")
    .attr("transform", `translate(0,${height - marginBottom})`)
    .call(d3.axisBottom(x));

// Add the y-axis.
svg.append("g")
    .attr("transform", `translate(${marginLeft},0)`)
    .call(d3.axisLeft(y));

// Append the SVG element.
container.append(svg.node());

</script>html<!DOCTYPE html>
<div id="container"></div>
<script src="d3.js"></script>
<script type="module">

// Declare the chart dimensions and margins.
const width = 640;
const height = 400;
const marginTop = 20;
const marginRight = 20;
const marginBottom = 30;
const marginLeft = 40;

// Declare the x (horizontal position) scale.
const x = d3.scaleUtc()
    .domain([new Date("2023-01-01"), new Date("2024-01-01")])
    .range([marginLeft, width - marginRight]);

// Declare the y (vertical position) scale.
const y = d3.scaleLinear()
    .domain([0, 100])
    .range([height - marginBottom, marginTop]);

// Create the SVG container.
const svg = d3.create("svg")
    .attr("width", width)
    .attr("height", height);

// Add the x-axis.
svg.append("g")
    .attr("transform", `translate(0,${height - marginBottom})`)
    .call(d3.axisBottom(x));

// Add the y-axis.
svg.append("g")
    .attr("transform", `translate(${marginLeft},0)`)
    .call(d3.axisLeft(y));

// Append the SVG element.
container.append(svg.node());

</script>You can also import and destructure individual D3 modules like so:html<script type="module">

import {forceSimulation, forceCollide, forceX} from "https://cdn.jsdelivr.net/npm/d3-force@3/+esm";

const nodes = [{}, {}];
const simulation = forceSimulation(nodes)
    .force("x", forceX())
    .force("collide", forceCollide(5))
    .on("tick", () => console.log(nodes[0].x));

</script>If you’d prefer to run D3 locally (or offline), you can download the UMD bundles of D3 here:d3.v7.jsd3.v7.min.jsThen, create an index.html file as shown above in the UMD + local tab. Use the non-minified bundle for debugging, and the minified bundle for faster performance in production.Installing from npm ​If you’re developing a web application using Node, you can install D3 via yarn, npm, pnpm, or your preferred package manager.yarnnpmpnpmbashyarn add d3bashnpm install d3bashpnpm add d3You can then load D3 into your app as:jsimport * as d3 from "d3";You can instead import specific symbols if you prefer:jsimport {select, selectAll} from "d3";Alternatively you can install and import from D3 submodules:jsimport {mean, median} from "d3-array";TypeScript declarations are available via DefinitelyTyped.D3 in React ​Most D3 modules (including d3-scale, d3-array, d3-interpolate, and d3-format) don’t interact with the DOM, so there is no difference when using them in React. You can use them in JSX for purely declarative visualization, such as the line plot below.LinePlot.jsxjsximport * as d3 from "d3";

export default function LinePlot({
  data,
  width = 640,
  height = 400,
  marginTop = 20,
  marginRight = 20,
  marginBottom = 20,
  marginLeft = 20
}) {
  const x = d3.scaleLinear([0, data.length - 1], [marginLeft, width - marginRight]);
  const y = d3.scaleLinear(d3.extent(data), [height - marginBottom, marginTop]);
  const line = d3.line((d, i) => x(i), y);
  return (
    <svg width={width} height={height}>
      <path fill="none" stroke="currentColor" strokeWidth="1.5" d={line(data)} />
      <g fill="white" stroke="currentColor" strokeWidth="1.5">
        {data.map((d, i) => (<circle key={i} cx={x(i)} cy={y(d)} r="2.5" />))}
      </g>
    </svg>
  );
}Sandbox ↗︎D3 modules that operate on selections (including d3-selection, d3-transition, and d3-axis) do manipulate the DOM, which competes with React’s virtual DOM. In those cases, you can attach a ref to an element and pass it to D3 in a useEffect hook.LinePlot.jsxjsximport * as d3 from "d3";
import {useRef, useEffect} from "react";

export default function LinePlot({
  data,
  width = 640,
  height = 400,
  marginTop = 20,
  marginRight = 20,
  marginBottom = 30,
  marginLeft = 40
}) {
  const gx = useRef();
  const gy = useRef();
  const x = d3.scaleLinear([0, data.length - 1], [marginLeft, width - marginRight]);
  const y = d3.scaleLinear(d3.extent(data), [height - marginBottom, marginTop]);
  const line = d3.line((d, i) => x(i), y);
  useEffect(() => void d3.select(gx.current).call(d3.axisBottom(x)), [gx, x]);
  useEffect(() => void d3.select(gy.current).call(d3.axisLeft(y)), [gy, y]);
  return (
    <svg width={width} height={height}>
      <g ref={gx} transform={`translate(0,${height - marginBottom})`} />
      <g ref={gy} transform={`translate(${marginLeft},0)`} />
      <path fill="none" stroke="currentColor" strokeWidth="1.5" d={line(data)} />
      <g fill="white" stroke="currentColor" strokeWidth="1.5">
        {data.map((d, i) => (<circle key={i} cx={x(i)} cy={y(d)} r="2.5" />))}
      </g>
    </svg>
  );
}Sandbox ↗︎For more guidance using D3 in React, see Amelia Wattenberger’s post.D3 in Svelte ​As with React, you can use Svelte exclusively for rendering if you like, and only use D3 modules that don’t manipulate the DOM. Here is a line plot of an array of numbers that uses d3-shape and d3-scale.LinePlot.sveltesvelte<script>
  import * as d3 from 'd3';

  export let data;
  export let width = 640;
  export let height = 400;
  export let marginTop = 20;
  export let marginRight = 20;
  export let marginBottom = 20;
  export let marginLeft = 20;

  $: x = d3.scaleLinear([0, data.length - 1], [marginLeft, width - marginRight]);
  $: y = d3.scaleLinear(d3.extent(data), [height - marginBottom, marginTop]);
  $: line = d3.line((d, i) => x(i), y);
</script>
<svg width={width} height={height}>
  <path fill="none" stroke="currentColor" stroke-width="1.5" d={line(data)} />
  <g fill="white" stroke="currentColor" stroke-width="1.5">
    {#each data as d, i}
      <circle key={i} cx={x(i)} cy={y(d)} r="2.5" />
    {/each}
  </g>
</svg>REPL ↗︎Svelte’s reactive statements ($:) pair nicely with D3 data joins for efficient updates. Below, we use them to render dynamic axes as the data changes.LinePlot.sveltesvelte<script>
  import * as d3 from 'd3';

  export let data;
  export let width = 640;
  export let height = 400;
  export let marginTop = 20;
  export let marginRight = 20;
  export let marginBottom = 30;
  export let marginLeft = 40;

  let gx;
  let gy;

  $: x = d3.scaleLinear([0, data.length - 1], [marginLeft, width - marginRight]);
  $: y = d3.scaleLinear(d3.extent(data), [height - marginBottom, marginTop]);
  $: line = d3.line((d, i) => x(i), y);
  $: d3.select(gy).call(d3.axisLeft(y));
  $: d3.select(gx).call(d3.axisBottom(x));
</script>
<svg width={width} height={height}>
  <g bind:this={gx} transform="translate(0,{height - marginBottom})" />
  <g bind:this={gy} transform="translate({marginLeft},0)" />
  <path fill="none" stroke="currentColor" stroke-width="1.5" d={line(data)} />
  <g fill="white" stroke="currentColor" stroke-width="1.5">
    {#each data as d, i}
      <circle key={i} cx={x(i)} cy={y(d)} r="2.5" />
    {/each}
  </g>
</svg>REPL ↗︎\n\n\n\nAPI index ​D3 is a collection of modules that are designed to work together; you can use the modules independently, or you can use them together as part of the default build.d3-array ​Array manipulation, ordering, searching, summarizing, etc.Add ​Add floating point values with full precision.new Adder - create a full precision adder.adder.add - add a value to an adder.adder.valueOf - get the double-precision representation of an adder’s value.fcumsum - compute a full precision cumulative summation of numbers.fsum - compute a full precision summation of an iterable of numbers.Bin ​Bin discrete samples into continuous, non-overlapping intervals.bin - create a new bin generator.bin - bins a given array of samples.bin.value - specify a value accessor for each sample.bin.domain - specify the interval of observable values.bin.thresholds - specify how values are divided into bins.thresholdFreedmanDiaconis - the Freedman–Diaconis binning rule.thresholdScott - Scott’s normal reference binning rule.thresholdSturges - Sturges’ binning formula.Bisect ​Quickly find a value in a sorted array.bisector - bisect using an accessor or comparator.bisector.right - bisectRight, with the given comparator.bisector.left - bisectLeft, with the given comparator.bisector.center - binary search for a value in a sorted array.bisect - binary search for a value in a sorted array.bisectRight - binary search for a value in a sorted array.bisectLeft - binary search for a value in a sorted array.bisectCenter - binary search for a value in a sorted array.Blur ​Blur quantitative values in one or two dimensions.d3.blur - blur an array of numbers in place.d3.blur2 - blur a two-dimensional array of numbers in place.d3.blurImage - blur an RGBA ImageData in place.Group ​Group discrete values.d3.group - group an iterable into a nested Map.d3.groups - group an iterable into a nested array.d3.rollup - reduce an iterable into a nested Map.d3.rollups - reduce an iterable into a nested array.d3.index - index an iterable into a nested Map.d3.indexes - index an iterable into a nested array.d3.flatGroup - group an iterable into a flat array.d3.flatRollup - reduce an iterable into a flat array.d3.groupSort - sort keys according to grouped values.Intern ​Create maps and sets with non-primitive values such as dates.new InternMap - a key-interning Map.new InternSet - a value-interning Set.Sets ​Logical operations on sets.d3.difference - compute a set difference.d3.disjoint - test whether two sets are disjoint.d3.intersection - compute a set intersection.d3.superset - test whether a set is a superset of another.d3.subset - test whether a set is a subset of another.d3.union - compute a set union.Sort ​Sort and reorder arrays of values.d3.ascending - compute the natural order of two values.d3.descending - compute the natural order of two values.d3.permute - reorder an iterable of elements according to an iterable of indexes.d3.quickselect - reorder an array of numbers.d3.reverse - reverse the order of values.d3.shuffle - randomize the order of an iterable.d3.shuffler - randomize the order of an iterable.d3.sort - sort values.Summarize ​Compute summary statistics.d3.count - count valid number values in an iterable.d3.min - compute the minimum value in an iterable.d3.minIndex - compute the index of the minimum value in an iterable.d3.max - compute the maximum value in an iterable.d3.maxIndex - compute the index of the maximum value in an iterable.d3.least - returns the least element of an iterable.d3.leastIndex - returns the index of the least element of an iterable.d3.greatest - returns the greatest element of an iterable.d3.greatestIndex - returns the index of the greatest element of an iterable.d3.extent - compute the minimum and maximum value in an iterable.d3.mode - compute the mode (the most common value) of an iterable of numbers.d3.sum - compute the sum of an iterable of numbers.d3.mean - compute the arithmetic mean of an iterable of numbers.d3.median - compute the median of an iterable of numbers (the 0.5-quantile).d3.medianIndex - compute the median index of an iterable of numbers (the 0.5-quantile).d3.cumsum - compute the cumulative sum of an iterable.d3.quantile - compute a quantile for an iterable of numbers.d3.quantileIndex - compute a quantile index for an iterable of numbers.d3.quantileSorted - compute a quantile for a sorted array of numbers.d3.rank - compute the rank order of an iterable.d3.variance - compute the variance of an iterable of numbers.d3.deviation - compute the standard deviation of an iterable of numbers.d3.every - test if all values satisfy a condition.d3.some - test if any value satisfies a condition.Ticks ​Generate representative values from a continuous interval.d3.ticks - generate representative values from a numeric interval.d3.tickIncrement - generate representative values from a numeric interval.d3.tickStep - generate representative values from a numeric interval.d3.nice - extend an interval to align with ticks.d3.range - generate a range of numeric values.Transform ​Derive new arrays.d3.cross - compute the Cartesian product of two iterables.d3.merge - merge multiple iterables into one array.d3.pairs - create an array of adjacent pairs of elements.d3.transpose - transpose an array of arrays.d3.zip - transpose a variable number of arrays.d3.filter - filter values.d3.map - map values.d3.reduce - reduce values.d3-axis ​Human-readable reference marks for scales.d3.axisTop - create a new top-oriented axis generator.d3.axisRight - create a new right-oriented axis generator.d3.axisBottom - create a new bottom-oriented axis generator.d3.axisLeft - create a new left-oriented axis generator.axis - generate an axis for the given selection.axis.scale - set the scale.axis.ticks - customize how ticks are generated and formatted.axis.tickArguments - customize how ticks are generated and formatted.axis.tickValues - set the tick values explicitly.axis.tickFormat - set the tick format explicitly.axis.tickSize - set the size of the ticks.axis.tickSizeInner - set the size of inner ticks.axis.tickSizeOuter - set the size of outer (extent) ticks.axis.tickPadding - set the padding between ticks and labels.axis.offset - set the pixel offset for crisp edges.d3-brush ​Select a one- or two-dimensional region using the mouse or touch.d3.brush - create a new two-dimensional brush.d3.brushX - create a brush along the x-dimension.d3.brushY - create a brush along the y-dimension.brush - apply the brush to a selection.brush.move - move the brush selection.brush.clear - clear the brush selection.brush.extent - define the brushable region.brush.filter - control which input events initiate brushing.brush.touchable - set the touch support detector.brush.keyModifiers - enable or disable key interaction.brush.handleSize - set the size of the brush handles.brush.on - listen for brush events.d3.brushSelection - get the brush selection for a given node.d3-chord ​d3.chord - create a new chord layout.chord - compute the layout for the given matrix.chord.padAngle - set the padding between adjacent groups.chord.sortGroups - define the group order.chord.sortSubgroups - define the source and target order within groups.chord.sortChords - define the chord order across groups.d3.chordDirected - create a directed chord generator.d3.chordTranspose - create a transposed chord generator.d3.ribbon - create a ribbon shape generator.ribbon - generate a ribbon shape.ribbon.source - set the source accessor.ribbon.target - set the target accessor.ribbon.radius - set the ribbon source and target radius.ribbon.sourceRadius - set the ribbon source radius.ribbon.targetRadius - set the ribbon target radius.ribbon.startAngle - set the ribbon source or target start angle.ribbon.endAngle - set the ribbon source or target end angle.ribbon.padAngle - set the pad angle accessor.ribbon.context - set the render context.d3.ribbonArrow - create an arrow ribbon generator.ribbonArrow.headRadius - set the arrowhead radius accessor.d3-color ​Color manipulation and color space conversion.d3.color - parse the given CSS color specifier.color.opacity - the color’s opacity.color.rgb - compute the RGB equivalent of this color.color.copy - return a copy of this color.color.brighter - create a brighter copy of this color.color.darker - create a darker copy of this color.color.displayable - returns true if the color is displayable on standard hardware.color.formatHex - returns the hexadecimal RRGGBB string representation of this color.color.formatHex8 - returns the hexadecimal RRGGBBAA string representation of this color.color.formatHsl - returns the RGB string representation of this color.color.formatRgb - returns the HSL string representation of this color.color.toString - returns the RGB string representation of this color.d3.rgb - create a new RGB color.rgb.clamp - returns copy of this color clamped to the RGB color space.d3.hsl - create a new HSL color.hsl.clamp - returns copy of this color clamped to the HSL color space.d3.lab - create a new Lab color.d3.gray - create a new Lab gray.d3.hcl - create a new HCL color.d3.lch - create a new HCL color.d3.cubehelix - create a new Cubehelix color.d3-contour ​Compute contour polygons using marching squares.d3.contours - create a new contour generator.contours - compute the contours for a given grid of values.contours.contour - compute a contour for a given value.contours.size - set the size of a contour generator.contours.smooth - set whether or not the generated contours are smoothed.contours.thresholds - set the thresholds of a contour generator.d3.contourDensity - create a new density estimator.density - estimate the density of a given array of samples.density.x - set the x accessor of the density estimator.density.y - set the y accessor of the density estimator.density.weight - set the weight accessor of the density estimator.density.size - set the size of the density estimator.density.cellSize - set the cell size of the density estimator.density.thresholds - set the thresholds of the density estimator.density.bandwidth - set the bandwidth of the density estimator.density.contours - compute density contours.d3-delaunay ​Compute the Voronoi diagram of a set of two-dimensional points.new Delaunay - create a delaunay triangulation for an array of point coordinates.Delaunay.from - create a delaunay triangulation for an iterable of points.delaunay.points - the coordinates of the points.delaunay.halfedges - the delaunay halfedges.delaunay.hull - the convex hull as point indices.delaunay.triangles - the delaunay triangles.delaunay.inedges - the delaunay inedgesdelaunay.find - find the closest point in the delaunay triangulation.delaunay.neighbors - the neighbors of a point in the delaunay triangulation.delaunay.render - render the edges of the delaunay triangulation.delaunay.renderHull - render the convex hull.delaunay.renderTriangle - render a triangle.delaunay.renderPoints - render the points.delaunay.hullPolygon - the closed convex hull as point coordinates.delaunay.trianglePolygons - iterate over all the triangles as polygons.delaunay.trianglePolygon - return a triangle as a polygon.delaunay.update - update a delaunay triangulation in place.delaunay.voronoi - compute the voronoi diagram associated with a delaunay triangulation.voronoi.delaunay - the voronoi diagram’s source delaunay triangulation.voronoi.circumcenters - the triangles’ circumcenters.voronoi.vectors - directions for the outer (infinite) cells of the voronoi diagram.voronoi.xmin - set the xmin bound of the extent.voronoi.ymin - set the ymin bound of the extent.voronoi.xmax - set the xmax bound of the extent.voronoi.ymax - set the ymax bound of the extent.voronoi.contains - test whether a point is inside a voronoi cell.voronoi.neighbors - the neighbors of a point in the voronoi diagram.voronoi.render - render the mesh of voronoi cells.voronoi.renderBounds - render the extent.voronoi.renderCell - render a voronoi cell.voronoi.cellPolygons - iterate over all the cells as polygons.voronoi.cellPolygon - return a cell as a polygon.voronoi.update - update a voronoi diagram in place.d3-dispatch ​Separate concerns using named callbacks.d3.dispatch - create a custom event dispatcher.dispatch.on - register or unregister an event listener.dispatch.copy - create a copy of a dispatcher.dispatch.call - dispatch an event to registered listeners.dispatch.apply - dispatch an event to registered listeners.d3-drag ​Drag and drop SVG, HTML or Canvas using mouse or touch input.d3.drag - create a drag behavior.drag - apply the drag behavior to a selection.drag.container - set the coordinate system.drag.filter - ignore some initiating input events.drag.touchable - set the touch support detector.drag.subject - set the thing being dragged.drag.clickDistance - set the click distance threshold.drag.on - listen for drag events.d3.dragDisable - prevent native drag-and-drop and text selection.d3.dragEnable - enable native drag-and-drop and text selection.event.on - listen for drag events on the current gesture.d3-dsv ​Parse and format delimiter-separated values, most commonly CSV and TSV.d3.csvParse - parse the given CSV string, returning an array of objects.d3.csvParseRows - parse the given CSV string, returning an array of rows.d3.csvFormat - format the given array of objects as CSV.d3.csvFormatBody - format the given array of objects as CSV.d3.csvFormatRows - format the given array of rows as CSV.d3.csvFormatRow - format the given row as CSV.d3.csvFormatValue - format the given value as CSV.d3.tsvParse - parse the given TSV string, returning an array of objects.d3.tsvParseRows - parse the given TSV string, returning an array of rows.d3.tsvFormat - format the given array of objects as TSV.d3.tsvFormatBody - format the given array of objects as TSV.d3.tsvFormatRows - format the given array of rows as TSV.d3.tsvFormatRow - format the given row as TSV.d3.tsvFormatValue - format the given value as TSV.d3.dsvFormat - create a new parser and formatter for the given delimiter.dsv.parse - parse the given string, returning an array of objects.dsv.parseRows - parse the given string, returning an array of rows.dsv.format - format the given array of objects.dsv.formatBody - format the given array of objects.dsv.formatRows - format the given array of rows.dsv.formatRow - format the given row.dsv.formatValue - format the given value.d3.autoType - automatically infer value types for the given object.d3-ease ​Easing functions for smooth animation.ease - ease the given normalized time.d3.easeLinear - linear easing; the identity function.d3.easePolyIn - polynomial easing; raises time to the given power.d3.easePolyOut - reverse polynomial easing.d3.easePoly - an alias for easePolyInOut.d3.easePolyInOut - symmetric polynomial easing.poly.exponent - specify the polynomial exponent.d3.easeQuadIn - quadratic easing; squares time.d3.easeQuadOut - reverse quadratic easing.d3.easeQuad - an alias for easeQuadInOut.d3.easeQuadInOut - symmetric quadratic easing.d3.easeCubicIn - cubic easing; cubes time.d3.easeCubicOut - reverse cubic easing.d3.easeCubic - an alias for easeCubicInOut.d3.easeCubicInOut - symmetric cubic easing.d3.easeSinIn - sinusoidal easing.d3.easeSinOut - reverse sinusoidal easing.d3.easeSin - an alias for easeSinInOut.d3.easeSinInOut - symmetric sinusoidal easing.d3.easeExpIn - exponential easing.d3.easeExpOut - reverse exponential easing.d3.easeExp - an alias for easeExpInOut.d3.easeExpInOut - symmetric exponential easing.d3.easeCircleIn - circular easing.d3.easeCircleOut - reverse circular easing.d3.easeCircle - an alias for easeCircleInOut.d3.easeCircleInOut - symmetric circular easing.d3.easeElasticIn - elastic easing, like a rubber band.d3.easeElastic - an alias for easeElasticOut.d3.easeElasticOut - reverse elastic easing.d3.easeElasticInOut - symmetric elastic easing.elastic.amplitude - specify the elastic amplitude.elastic.period - specify the elastic period.d3.easeBackIn - anticipatory easing, like a dancer bending his knees before jumping.d3.easeBackOut - reverse anticipatory easing.d3.easeBack - an alias for easeBackInOut.d3.easeBackInOut - symmetric anticipatory easing.back.overshoot - specify the amount of overshoot.d3.easeBounceIn - bounce easing, like a rubber ball.d3.easeBounce - an alias for easeBounceOut.d3.easeBounceOut - reverse bounce easing.d3.easeBounceInOut - symmetric bounce easing.d3-fetch ​Convenience methods on top of the Fetch API.d3.blob - get a file as a blob.d3.buffer - get a file as an array buffer.d3.csv - get a comma-separated values (CSV) file.d3.dsv - get a delimiter-separated values (CSV) file.d3.html - get an HTML file.d3.image - get an image.d3.json - get a JSON file.d3.svg - get an SVG file.d3.text - get a plain text file.d3.tsv - get a tab-separated values (TSV) file.d3.xml - get an XML file.d3-force ​Force-directed graph layout using velocity Verlet integration.d3.forceSimulation - create a new force simulation.simulation.restart - reheat and restart the simulation’s timer.simulation.stop - stop the simulation’s timer.simulation.tick - advance the simulation one step.simulation.nodes - set the simulation’s nodes.simulation.alpha - set the current alpha.simulation.alphaMin - set the minimum alpha threshold.simulation.alphaDecay - set the alpha exponential decay rate.simulation.alphaTarget - set the target alpha.simulation.velocityDecay - set the velocity decay rate.simulation.force - add or remove a force.simulation.find - find the closest node to the given position.simulation.randomSource - set the simulation’s random source.simulation.on - add or remove an event listener.force - apply the force.force.initialize - initialize the force with the given nodes.d3.forceCenter - create a centering force.center.x - set the center x-coordinate.center.y - set the center y coordinate.center.strength - set the strength of the centering force.d3.forceCollide - create a circle collision force.collide.radius - set the circle radius.collide.strength - set the collision resolution strength.collide.iterations - set the number of iterations.d3.forceLink - create a link force.link.links - set the array of links.link.id - link nodes by numeric index or string identifier.link.distance - set the link distance.link.strength - set the link strength.link.iterations - set the number of iterations.d3.forceManyBody - create a many-body force.manyBody.strength - set the force strength.manyBody.theta - set the Barnes–Hut approximation accuracy.manyBody.distanceMin - limit the force when nodes are close.manyBody.distanceMax - limit the force when nodes are far.d3.forceX - create an x-positioning force.x.strength - set the force strength.x.x - set the target x-coordinate.d3.forceY - create an y-positioning force.y.strength - set the force strength.y.y - set the target y coordinate.d3.forceRadial - create a radial positioning force.radial.strength - set the force strength.radial.radius - set the target radius.radial.x - set the target center x-coordinate.radial.y - set the target center y coordinate.d3-format ​Format numbers for human consumption.d3.format - alias for locale.format on the default locale.d3.formatPrefix - alias for locale.formatPrefix on the default locale.locale.format - create a number format.locale.formatPrefix - create a SI-prefix number format.d3.formatSpecifier - parse a number format specifier.new d3.FormatSpecifier - augments a number format specifier object.d3.precisionFixed - compute decimal precision for fixed-point notation.d3.precisionPrefix - compute decimal precision for SI-prefix notation.d3.precisionRound - compute significant digits for rounded notation.d3.formatLocale - define a custom locale.d3.formatDefaultLocale - define the default locale.d3-geo ​Geographic projections, shapes and math.Paths ​d3.geoPath - create a new geographic path generator.path - project and render the specified feature.path.area - compute the projected planar area of a given feature.path.bounds - compute the projected planar bounding box of a given feature.path.centroid - compute the projected planar centroid of a given feature.path.digits - set the output precision.path.measure - compute the projected planar length of a given feature.path.projection - set the geographic projection.path.context - set the render context.path.pointRadius - set the radius to display point features.Projections ​projection - project the specified point from the sphere to the plane.projection.invert - unproject the specified point from the plane to the sphere.projection.stream - wrap the specified stream to project geometry.projection.preclip - set the projection’s spherical clipping function.projection.postclip - set the projection’s cartesian clipping function.projection.clipAngle - set the radius of the clip circle.projection.clipExtent - set the viewport clip extent, in pixels.projection.scale - set the scale factor.projection.translate - set the translation offset.projection.center - set the center point.projection.angle - set the post-projection rotation.projection.reflectX - reflect the x-dimension.projection.reflectY - reflect the y-dimension.projection.rotate - set the three-axis spherical rotation angles.projection.precision - set the precision threshold for adaptive sampling.projection.fitExtent - set the scale and translate to fit a GeoJSON object.projection.fitSize - set the scale and translate to fit a GeoJSON object.projection.fitWidth - set the scale and translate to fit a GeoJSON object.projection.fitHeight - set the scale and translate to fit a GeoJSON object.Raw projections ​project - project the specified point from the sphere to the plane.project.invert - unproject the specified point from the plane to the sphere.d3.geoProjection - create a custom projection.d3.geoProjectionMutator - create a custom configurable projection.d3.geoTransform - define a custom geometry transform.d3.geoIdentity - scale, translate or clip planar geometry.d3.geoClipAntimeridian - cuts spherical geometries that cross the antimeridian.d3.geoClipCircle - clips spherical geometries to a small circle.d3.geoClipRectangle - clips planar geometries to a rectangular viewport.Azimuthal projections ​d3.geoAzimuthalEqualArea - the azimuthal equal-area projection.d3.geoAzimuthalEquidistant - the azimuthal equidistant projection.d3.geoGnomonic - the gnomonic projection.d3.geoOrthographic - the azimuthal orthographic projection.d3.geoStereographic - the azimuthal stereographic projection.Conic projections ​conic.parallels - set the two standard parallels.d3.geoConicConformal - the conic conformal projection.d3.geoConicEqualArea - the conic equal-area (Albers) projection.d3.geoConicEquidistant - the conic equidistant projection.d3.geoAlbers - the Albers equal-area conic projection.d3.geoAlbersUsa - a composite Albers projection for the United States.Cylindrical projections ​d3.geoEquirectangular - the equirectangular (plate carreé) projection.d3.geoMercator - the spherical Mercator projection.d3.geoTransverseMercator - the transverse spherical Mercator projection.d3.geoEqualEarth - the Equal Earth projection.d3.geoNaturalEarth1 - the Equal Earth projection, version 1.Streams ​d3.geoStream - convert a GeoJSON object to a geometry stream.stream.point - indicates a point with the specified coordinates.stream.lineStart - indicates the start of a line or ring.stream.lineEnd - indicates the end of a line or ring.stream.polygonStart - indicates the start of a polygon.stream.polygonEnd - indicates the end of a polygon.stream.sphere - indicates the sphere.Spherical shapes ​d3.geoGraticule - create a graticule generator.graticule - generate a MultiLineString of meridians and parallels.graticule.lines - generate an array of LineStrings of meridians and parallels.graticule.outline - generate a Polygon of the graticule’s extent.graticule.extent - get or set the major & minor extents.graticule.extentMajor - get or set the major extent.graticule.extentMinor - get or set the minor extent.graticule.step - get or set the major & minor step intervals.graticule.stepMajor - get or set the major step intervals.graticule.stepMinor - get or set the minor step intervals.graticule.precision - get or set the latitudinal precision.d3.geoGraticule10 - generate the default 10° global graticule.d3.geoCircle - create a circle generator.circle - generate a piecewise circle as a Polygon.circle.center - specify the circle center in latitude and longitude.circle.radius - specify the angular radius in degrees.circle.precision - specify the precision of the piecewise circle.Spherical math ​d3.geoArea - compute the spherical area of a given feature.d3.geoBounds - compute the latitude-longitude bounding box for a given feature.d3.geoCentroid - compute the spherical centroid of a given feature.d3.geoDistance - compute the great-arc distance between two points.d3.geoLength - compute the length of a line string or the perimeter of a polygon.d3.geoInterpolate - interpolate between two points along a great arc.d3.geoContains - test whether a point is inside a given feature.d3.geoRotation - create a rotation function for the specified angles.d3-hierarchy ​Layout algorithms for visualizing hierarchical data.d3.hierarchy - constructs a root node from hierarchical data.node.ancestors - generate an array of ancestors.node.descendants - generate an array of descendants.node.leaves - generate an array of leaves.node.find - find a node in the hierarchy.node.path - generate the shortest path to another node.node.links - generate an array of links.node.sum - evaluate and aggregate quantitative values.node.count - count the number of leaves.node.sort - sort all descendant siblings.node[Symbol.iterator] - iterate on a hierarchy.node.each - breadth-first traversal.node.eachAfter - post-order traversal.node.eachBefore - pre-order traversal.node.copy - copy a hierarchy.d3.stratify - create a new stratify operator.stratify - construct a root node from tabular data.stratify.id - set the node id accessor.stratify.parentId - set the parent node id accessor.stratify.path - set the path accessor.d3.cluster - create a new cluster (dendrogram) layout.cluster - layout the specified hierarchy in a dendrogram.cluster.size - set the layout size.cluster.nodeSize - set the node size.cluster.separation - set the separation between leaves.d3.tree - create a new tidy tree layout.tree - layout the specified hierarchy in a tidy tree.tree.size - set the layout size.tree.nodeSize - set the node size.tree.separation - set the separation between nodes.d3.treemap - create a new treemap layout.treemap - layout the specified hierarchy as a treemap.treemap.tile - set the tiling method.treemap.size - set the layout size.treemap.round - set whether the output coordinates are rounded.treemap.padding - set the padding.treemap.paddingInner - set the padding between siblings.treemap.paddingOuter - set the padding between parent and children.treemap.paddingTop - set the padding between the parent’s top edge and children.treemap.paddingRight - set the padding between the parent’s right edge and children.treemap.paddingBottom - set the padding between the parent’s bottom edge and children.treemap.paddingLeft - set the padding between the parent’s left edge and children.d3.treemapBinary - tile using a balanced binary tree.d3.treemapDice - tile into a horizontal row.d3.treemapSlice - tile into a vertical column.d3.treemapSliceDice - alternate between slicing and dicing.d3.treemapSquarify - tile using squarified rows per Bruls et. al.d3.treemapResquarify - like d3.treemapSquarify, but performs stable updates.squarify.ratio - set the desired rectangle aspect ratio.d3.partition - create a new partition (icicle or sunburst) layout.partition - layout the specified hierarchy as a partition diagram.partition.size - set the layout size.partition.round - set whether the output coordinates are rounded.partition.padding - set the padding.d3.pack - create a new circle-packing layout.pack - layout the specified hierarchy using circle-packing.pack.radius - set the radius accessor.pack.size - set the layout size.pack.padding - set the padding.d3.packSiblings - pack the specified array of circles.d3.packEnclose - enclose the specified array of circles.d3-interpolate ​Interpolate numbers, colors, strings, arrays, objects, whatever!Value interpolation ​d3.interpolate - interpolate arbitrary values.d3.interpolateNumber - interpolate numbers.d3.interpolateRound - interpolate integers.d3.interpolateString - interpolate strings with embedded numbers.d3.interpolateDate - interpolate dates.d3.interpolateArray - interpolate arrays of arbitrary values.d3.interpolateNumberArray - interpolate arrays of numbers.d3.interpolateObject - interpolate arbitrary objects.d3.interpolateBasis - generate a B-spline through a set of values.d3.interpolateBasisClosed - generate a closed B-spline through a set of values.d3.interpolateDiscrete - generate a discrete interpolator from a set of values.d3.quantize - generate uniformly-spaced samples from an interpolator.d3.piecewise - generate a piecewise linear interpolator from a set of values.Color interpolation ​d3.interpolateRgb - interpolate RGB colors.d3.interpolateRgbBasis - generate a B-spline through a set of colors.d3.interpolateRgbBasisClosed - generate a closed B-spline through a set of colors.d3.interpolateHsl - interpolate HSL colors.d3.interpolateHslLong - interpolate HSL colors, the long way.d3.interpolateLab - interpolate Lab colors.d3.interpolateHcl - interpolate HCL colors.d3.interpolateHclLong - interpolate HCL colors, the long way.d3.interpolateCubehelix - interpolate Cubehelix colors.d3.interpolateCubehelixLong - interpolate Cubehelix colors, the long way.interpolateColor.gamma - apply gamma correction during interpolation.d3.interpolateHue - interpolate a hue angle.Transform interpolation ​d3.interpolateTransformCss - interpolate 2D CSS transforms.d3.interpolateTransformSvg - interpolate 2D SVG transforms.Zoom interpolation ​d3.interpolateZoom - zoom and pan between two views.interpolateZoom.rho - set the curvature rho of the zoom interpolator.d3-path ​Serialize Canvas path commands to SVG.d3.path - create a new path serializer.path.moveTo - move to the given point.path.closePath - close the current subpath.path.lineTo - draw a straight line segment.path.quadraticCurveTo - draw a quadratic Bézier segment.path.bezierCurveTo - draw a cubic Bézier segment.path.arcTo - draw a circular arc segment.path.arc - draw a circular arc segment.path.rect - draw a rectangle.path.toString - serialize to an SVG path data string.d3.pathRound - create a new path serializer with fixed output precision.d3-polygon ​Geometric operations for two-dimensional polygons.d3.polygonArea - compute the area of the given polygon.d3.polygonCentroid - compute the centroid of the given polygon.d3.polygonHull - compute the convex hull of the given points.d3.polygonContains - test whether a point is inside a polygon.d3.polygonLength - compute the length of the given polygon’s perimeter.d3-quadtree ​Two-dimensional recursive spatial subdivision.d3.quadtree - create a new, empty quadtree.quadtree.x - set the x accessor.quadtree.y - set the y accessor.quadtree.extent - extend the quadtree to cover an extent.quadtree.cover - extend the quadtree to cover a point.quadtree.add - add a datum to a quadtree.quadtree.addAll - add an array of data to a quadtree.quadtree.remove - remove a datum from a quadtree.quadtree.removeAll - remove an array of data from a quadtree.quadtree.copy - create a copy of a quadtree.quadtree.root - get the quadtree’s root node.quadtree.data - retrieve all data from the quadtree.quadtree.size - count the number of data in the quadtree.quadtree.find - quickly find the closest datum in a quadtree.quadtree.visit - selectively visit nodes in a quadtree.quadtree.visitAfter - visit all nodes in a quadtree.d3-random ​Generate random numbers from various distributions.d3.randomUniform - from a uniform distribution.d3.randomInt - from a uniform integer distribution.d3.randomNormal - from a normal distribution.d3.randomLogNormal - from a log-normal distribution.d3.randomBates - from a Bates distribution.d3.randomIrwinHall - from an Irwin–Hall distribution.d3.randomExponential - from an exponential distribution.d3.randomPareto - from a Pareto distribution.d3.randomBernoulli - from a Bernoulli distribution.d3.randomGeometric - from a geometric distribution.d3.randomBinomial - from a binomial distribution.d3.randomGamma - from a gamma distribution.d3.randomBeta - from a beta distribution.d3.randomWeibull - from a Weibull, Gumbel or Fréchet distribution.d3.randomCauchy - from a Cauchy distribution.d3.randomLogistic - from a logistic distribution.d3.randomPoisson - from a Poisson distribution.random.source - set the source of randomness.d3.randomLcg - a seeded pseudorandom number generator.d3-scale ​Encodings that map abstract data to visual representation.Linear scales ​Map a continuous, quantitative domain to a continuous range.d3.scaleLinear - create a quantitative linear scale.linear - compute the range value corresponding to a given domain value.linear.invert - compute the domain value corresponding to a given range value.linear.domain - set the input domain.linear.range - set the output range.linear.rangeRound - set the output range and enable rounding.linear.clamp - enable clamping to the domain or range.linear.unknown - set the output value for unknown inputs.linear.interpolate - set the output interpolator.linear.ticks - compute representative values from the domain.linear.tickFormat - format ticks for human consumption.linear.nice - extend the domain to nice round numbers.linear.copy - create a copy of this scale.d3.tickFormat - format ticks for human consumption.d3.scaleIdentity - creates an identity scale.d3.scaleRadial - creates a radial scale.Pow scales ​d3.scalePow - create a quantitative power scale.d3.scaleSqrt - create a quantitative power scale with exponent 0.5.pow.exponent - set the power exponent.Log scales ​d3.scaleLog - create a quantitative logarithmic scale.log.base - set the logarithm base.log.ticks - compute representative values from the domain.log.tickFormat - format ticks for human consumption.log.nice - extend the domain to nice round numbers.Symlog scales ​d3.scaleSymlog - create a symmetric logarithmic scale.symlog.constant - set the constant of a symlog scale.Time scales ​d3.scaleTime - create a linear scale for time.time.ticks - compute representative values from the domain.time.tickFormat - format ticks for human consumption.time.nice - extend the domain to nice round times.d3.scaleUtc - create a linear scale for UTC.Sequential scales ​Map a continuous, quantitative domain to a continuous, fixed interpolator.d3.scaleSequential - create a sequential scale.sequential.interpolator - set the scale’s output interpolator.sequential.range - set the output range.sequential.rangeRound - set the output range and enable rounding.d3.scaleSequentialLog - create a logarithmic sequential scale.d3.scaleSequentialPow - create a power sequential scale.d3.scaleSequentialSqrt - create a power sequential scale with exponent 0.5.d3.scaleSequentialSymlog - create a symmetric logarithmic sequential scale.d3.scaleSequentialQuantile - create a sequential scale using a p-quantile transform.sequentialQuantile.quantiles - return the scale’s quantiles.Diverging scales ​Map a continuous, quantitative domain to a continuous, fixed interpolator.d3.scaleDiverging - create a diverging scale.diverging.interpolator - set the scale’s output interpolator.diverging.range - set the output range.diverging.rangeRound - set the output range and enable rounding.d3.scaleDivergingLog - create a diverging logarithmic scale.d3.scaleDivergingPow - create a diverging power scale.d3.scaleDivergingSqrt - create a diverging power scale with exponent 0.5.d3.scaleDivergingSymlog - create a diverging symmetric logarithmic scale.Quantize scales ​Map a continuous, quantitative domain to a discrete range.d3.scaleQuantize - create a uniform quantizing linear scale.quantize - compute the range value corresponding to a given domain value.quantize.invertExtent - compute the domain values corresponding to a given range value.quantize.domain - set the input domain.quantize.range - set the output range.quantize.thresholds - return the array of computed thresholds within the domain.quantize.copy - create a copy of this scale.Quantile scales ​d3.scaleQuantile - create a quantile quantizing linear scale.quantile - compute the range value corresponding to a given domain value.quantile.invertExtent - compute the domain values corresponding to a given range value.quantile.domain - set the input domain.quantile.range - set the output range.quantile.quantiles - get the quantile thresholds.quantile.copy - create a copy of this scale.Threshold scales ​d3.scaleThreshold - create an arbitrary quantizing linear scale.threshold - compute the range value corresponding to a given domain value.threshold.invertExtent - compute the domain values corresponding to a given range value.threshold.domain - set the input domain.threshold.range - set the output range.threshold.copy - create a copy of this scale.Ordinal scales ​Map a discrete domain to a discrete range.d3.scaleOrdinal - create an ordinal scale.ordinal - compute the range value corresponding to a given domain value.ordinal.domain - set the input domain.ordinal.range - set the output range.ordinal.unknown - set the output value for unknown inputs.ordinal.copy - create a copy of this scale.d3.scaleImplicit - a special unknown value for implicit domains.Band scales ​d3.scaleBand - create an ordinal band scale.band - compute the band start corresponding to a given domain value.band.domain - set the input domain.band.range - set the output range.band.rangeRound - set the output range and enable rounding.band.round - enable rounding.band.paddingInner - set padding between bands.band.paddingOuter - set padding outside the first and last bands.band.padding - set padding outside and between bands.band.align - set band alignment, if there is extra space.band.bandwidth - get the width of each band.band.step - get the distance between the starts of adjacent bands.band.copy - create a copy of this scale.Point scales ​d3.scalePoint - create an ordinal point scale.point - compute the point corresponding to a given domain value.point.domain - set the input domain.point.range - set the output range.point.rangeRound - set the output range and enable rounding.point.round - enable rounding.point.padding - set padding outside the first and last point.point.align - set point alignment, if there is extra space.point.bandwidth - returns zero.point.step - get the distance between the starts of adjacent points.point.copy - create a copy of this scale.d3-scale-chromatic ​Color ramps and palettes for quantitative, ordinal and categorical scales.Categorical ​d3.schemeCategory10 - an array of ten categorical colors.d3.schemeAccent - an array of eight categorical colors.d3.schemeDark2 - an array of eight categorical colors.d3.schemeObservable10 - an array of ten categorical colors.d3.schemePaired - an array of twelve categorical colors.d3.schemePastel1 - an array of nine categorical colors.d3.schemePastel2 - an array of eight categorical colors.d3.schemeSet1 - an array of nine categorical colors.d3.schemeSet2 - an array of eight categorical colors.d3.schemeSet3 - an array of twelve categorical colors.d3.schemeTableau10 - an array of ten categorical colors.Cyclical ​d3.interpolateRainbow - the “less-angry” rainbowd3.interpolateSinebow - the “sinebow” smooth rainbowDiverging ​d3.interpolateBrBG - ColorBrewer BrBG interpolator.d3.interpolatePiYG - ColorBrewer PiYG interpolator.d3.interpolatePRGn - ColorBrewer PRGn interpolator.d3.interpolatePuOr - ColorBrewer PuOr interpolator.d3.interpolateRdBu - ColorBrewer RdBu interpolator.d3.interpolateRdGy - ColorBrewer RdGy interpolator.d3.interpolateRdYlBu - ColorBrewer RdYlBu interpolator.d3.interpolateRdYlGn - ColorBrewer RdYlGn interpolator.d3.interpolateSpectral - ColorBrewer spectral interpolator.d3.schemeBrBG - ColorBrewer BrBG scheme.d3.schemePiYG - ColorBrewer PiYG scheme.d3.schemePRGn - ColorBrewer PRGn scheme.d3.schemePuOr - ColorBrewer PuOr scheme.d3.schemeRdBu - ColorBrewer RdBu scheme.d3.schemeRdGy - ColorBrewer RdGy scheme.d3.schemeRdYlBu - ColorBrewer RdYlBu scheme.d3.schemeRdYlGn - ColorBrewer RdYlGn scheme.d3.schemeSpectral - ColorBrewer spectral scheme.Sequential ​d3.interpolateBlues -d3.interpolateGreens -d3.interpolateGreys -d3.interpolateOranges -d3.interpolatePurples -d3.interpolateReds -d3.schemeBlues -d3.schemeGreens -d3.schemeGreys -d3.schemeOranges -d3.schemePurples -d3.schemeReds -d3.interpolateBuGn - ColorBrewer BuGn interpolator.d3.interpolateBuPu - ColorBrewer BuPu interpolator.d3.interpolateCividis - cividis interpolator.d3.interpolateCool - cool interpolator.d3.interpolateCubehelixDefault - cubehelix interpolator.d3.interpolateGnBu - ColorBrewer GnBu interpolator.d3.interpolateInferno - inferno interpolator.d3.interpolateMagma - magma interpolator.d3.interpolateOrRd - ColorBrewer OrRd interpolator.d3.interpolatePlasma - plasma interpolator.d3.interpolatePuBu - ColorBrewer PuBu interpolator.d3.interpolatePuBuGn - ColorBrewer PuBuGn interpolator.d3.interpolatePuRd - ColorBrewer PuRd interpolator.d3.interpolateRdPu - ColorBrewer RdPu interpolator.d3.interpolateTurbo - turbo interpolator.d3.interpolateViridis - viridis interpolator.d3.interpolateWarm - warm interpolator.d3.interpolateYlGn - ColorBrewer YlGn interpolator.d3.interpolateYlGnBu - ColorBrewer YlGnBu interpolator.d3.interpolateYlOrBr - ColorBrewer YlOrBr interpolator.d3.interpolateYlOrRd - ColorBrewer YlOrRd interpolator.d3.schemeBuGn - ColorBrewer BuGn scheme.d3.schemeBuPu - ColorBrewer BuPu scheme.d3.schemeGnBu - ColorBrewer GnBu scheme.d3.schemeOrRd - ColorBrewer OrRd scheme.d3.schemePuBu - ColorBrewer PuBu scheme.d3.schemePuBuGn - ColorBrewer PuBuGn scheme.d3.schemePuRd - ColorBrewer PuRd scheme.d3.schemeRdPu - ColorBrewer RdPu scheme.d3.schemeYlGn - ColorBrewer YlGn scheme.d3.schemeYlGnBu - ColorBrewer YlGnBu scheme.d3.schemeYlOrBr - ColorBrewer YlOrBr scheme.d3.schemeYlOrRd - ColorBrewer YlOrRd scheme.d3-selection ​Transform the DOM by selecting elements and joining to data.Selecting elements ​d3.selection - select the root document element.d3.select - select an element from the document.d3.selectAll - select multiple elements from the document.selection.select - select a descendant element for each selected element.selection.selectAll - select multiple descendants for each selected element.selection.filter - filter elements based on data.selection.merge - merge this selection with another.selection.selectChild - select a child element for each selected element.selection.selectChildren - select the children elements for each selected element.selection.selection - return the selection.d3.matcher - test whether an element matches a selector.d3.selector - select an element.d3.selectorAll - select elements.d3.window - get a node’s owner window.d3.style - get a node’s current style value.Modifying elements ​selection.attr - get or set an attribute.selection.classed - get, add or remove CSS classes.selection.style - get or set a style property.selection.property - get or set a (raw) property.selection.text - get or set the text content.selection.html - get or set the inner HTML.selection.append - create, append and select new elements.selection.insert - create, insert and select new elements.selection.remove - remove elements from the document.selection.clone - insert clones of selected elements.selection.sort - sort elements in the document based on data.selection.order - reorders elements in the document to match the selection.selection.raise - reorders each element as the last child of its parent.selection.lower - reorders each element as the first child of its parent.d3.create - create and select a detached element.d3.creator - create an element by name.Joining data ​selection.data - bind elements to data.selection.join - enter, update or exit elements based on data.selection.enter - get the enter selection (data missing elements).selection.exit - get the exit selection (elements missing data).selection.datum - get or set element data (without joining).Handling events ​selection.on - add or remove event listeners.selection.dispatch - dispatch a custom event.d3.pointer - get the pointer’s position of an event.d3.pointers - get the pointers’ positions of an event.Control flow ​selection.each - call a function for each element.selection.call - call a function with this selection.selection.empty - returns true if this selection is empty.selection.nodes - returns an array of all selected elements.selection.node - returns the first (non-null) element.selection.size - returns the count of elements.selection[Symbol.iterator] - iterate over the selection’s nodes.Local variables ​d3.local - declares a new local variable.local.set - set a local variable’s value.local.get - get a local variable’s value.local.remove - delete a local variable.local.toString - get the property identifier of a local variable.Namespaces ​d3.namespace - qualify a prefixed XML name, such as “xlink:href”.d3.namespaces - the built-in XML namespaces.d3-shape ​Graphical primitives for visualization.Arcs ​Circular or annular sectors, as in a pie or donut chart.d3.arc - create a new arc generator.arc - generate an arc for the given datum.arc.centroid - compute an arc’s midpoint.arc.innerRadius - set the inner radius.arc.outerRadius - set the outer radius.arc.cornerRadius - set the corner radius, for rounded corners.arc.startAngle - set the start angle.arc.endAngle - set the end angle.arc.padAngle - set the angle between adjacent arcs, for padded arcs.arc.padRadius - set the radius at which to linearize padding.arc.context - set the rendering context.arc.digits - set the output precision.Pies ​Compute the necessary angles to represent a tabular dataset as a pie or donut chart.d3.pie - create a new pie generator.pie - compute the arc angles for the given dataset.pie.value - set the value accessor.pie.sort - set the sort order comparator.pie.sortValues - set the sort order comparator.pie.startAngle - set the overall start angle.pie.endAngle - set the overall end angle.pie.padAngle - set the pad angle between adjacent arcs.Lines ​A spline or polyline, as in a line chart.d3.line - create a new line generator.line - generate a line for the given dataset.line.x - set the x accessor.line.y - set the y accessor.line.defined - set the defined accessor.line.curve - set the curve interpolator.line.context - set the rendering context.line.digits - set the output precision.d3.lineRadial - create a new radial line generator.lineRadial - generate a line for the given dataset.lineRadial.angle - set the angle accessor.lineRadial.radius - set the radius accessor.lineRadial.defined - set the defined accessor.lineRadial.curve - set the curve interpolator.lineRadial.context - set the rendering context.Areas ​An area, defined by a bounding topline and baseline, as in an area chart.d3.area - create a new area generator.area - generate an area for the given dataset.area.x - set the x0 and x1 accessors.area.x0 - set the baseline x accessor.area.x1 - set the topline x accessor.area.y - set the y0 and y1 accessors.area.y0 - set the baseline y accessor.area.y1 - set the topline y accessor.area.defined - set the defined accessor.area.curve - set the curve interpolator.area.context - set the rendering context.area.digits - set the output precision.area.lineX0 - derive a line for the left edge of an area.area.lineY0 - derive a line for the top edge of an area.area.lineX1 - derive a line for the right edge of an area.area.lineY1 - derive a line for the bottom edge of an area.d3.areaRadial - create a new radial area generator.areaRadial - generate an area for the given dataset.areaRadial.angle - set the start and end angle accessors.areaRadial.startAngle - set the start angle accessor.areaRadial.endAngle - set the end angle accessor.areaRadial.radius - set the inner and outer radius accessors.areaRadial.innerRadius - set the inner radius accessor.areaRadial.outerRadius - set the outer radius accessor.areaRadial.defined - set the defined accessor.areaRadial.curve - set the curve interpolator.areaRadial.context - set the rendering context.areaRadial.lineStartAngle - derive a line for the start edge of an area.areaRadial.lineInnerRadius - derive a line for the inner edge of an area.areaRadial.lineEndAngle - derive a line for the end edge of an area.areaRadial.lineOuterRadius - derive a line for the outer edge of an area.Curves ​Interpolate between points to produce a continuous shape.d3.curveBasis - a cubic basis spline, repeating the end points.d3.curveBasisClosed - a closed cubic basis spline.d3.curveBasisOpen - a cubic basis spline.d3.curveBundle - a straightened cubic basis spline.bundle.beta - set the bundle tension beta.d3.curveBumpX - a cubic Bézier spline with horizontal tangents.d3.curveBumpY - a cubic Bézier spline with vertical tangents.d3.curveCardinal - a cubic cardinal spline, with one-sided difference at each end.d3.curveCardinalClosed - a closed cubic cardinal spline.d3.curveCardinalOpen - a cubic cardinal spline.cardinal.tension - set the cardinal spline tension.d3.curveCatmullRom - a cubic Catmull–Rom spline, with one-sided difference at each end.d3.curveCatmullRomClosed - a closed cubic Catmull–Rom spline.d3.curveCatmullRomOpen - a cubic Catmull–Rom spline.catmullRom.alpha - set the Catmull–Rom parameter alpha.d3.curveLinear - a polyline.d3.curveLinearClosed - a closed polyline.d3.curveMonotoneX - a cubic spline that, given monotonicity in x, preserves it in y.d3.curveMonotoneY - a cubic spline that, given monotonicity in y, preserves it in x.d3.curveNatural - a natural cubic spline.d3.curveStep - a piecewise constant function.d3.curveStepAfter - a piecewise constant function.d3.curveStepBefore - a piecewise constant function.curve.areaStart - start a new area segment.curve.areaEnd - end the current area segment.curve.lineStart - start a new line segment.curve.lineEnd - end the current line segment.curve.point - add a point to the current line segment.Links ​A smooth cubic Bézier curve from a source to a target.d3.link - create a new link generator.d3.linkVertical - create a new vertical link generator.d3.linkHorizontal - create a new horizontal link generator.link - generate a link.link.source - set the source accessor.link.target - set the target accessor.link.x - set the point x-accessor.link.y - set the point y-accessor.link.context - set the rendering context.link.digits - set the output precision.d3.linkRadial - create a new radial link generator.linkRadial.angle - set the point angle accessor.linkRadial.radius - set the point radius accessor.Symbols ​A categorical shape encoding, as in a scatterplot.d3.symbol - create a new symbol generator.symbol - generate a symbol for the given datum.symbol.type - set the symbol type.symbol.size - set the size of the symbol in square pixels.symbol.context - set the rendering context.symbol.digits - set the output precision.d3.symbolsFill - an array of built-in symbol types for filling.d3.symbolsStroke - an array of built-in symbol types for stroking.d3.symbolAsterisk - an asterisk; for stroke.d3.symbolCircle - a circle; for fill or stroke.d3.symbolCross - a Greek cross with arms of equal length; for fill.d3.symbolDiamond - a rhombus; for fill.d3.symbolDiamond2 - a rotated square; for stroke.d3.symbolPlus - a plus sign; for stroke.d3.symbolSquare - a square; for fill.d3.symbolSquare2 - a square; for stroke.d3.symbolStar - a pentagonal star (pentagram); for fill.d3.symbolTriangle - an up-pointing triangle; for fill.d3.symbolTriangle2 - an up-pointing triangle; for stroke.d3.symbolWye - a Y shape; for fill.d3.pointRadial - relative coordinates of a point given an angle and radius.symbolType.draw - draw this symbol to the given context.Stacks ​Stack shapes, placing one adjacent to another, as in a stacked bar chart.d3.stack - create a new stack generator.stack - generate a stack for the given dataset.stack.keys - set the keys accessor.stack.value - set the value accessor.stack.order - set the order accessor.stack.offset - set the offset accessor.d3.stackOrderAppearance - put the earliest series on bottom.d3.stackOrderAscending - put the smallest series on bottom.d3.stackOrderDescending - put the largest series on bottom.d3.stackOrderInsideOut - put earlier series in the middle.d3.stackOrderNone - use the given series order.d3.stackOrderReverse - use the reverse of the given series order.d3.stackOffsetExpand - normalize the baseline to zero and topline to one.d3.stackOffsetDiverging - positive above zero; negative below zero.d3.stackOffsetNone - apply a zero baseline.d3.stackOffsetSilhouette - center the streamgraph around zero.d3.stackOffsetWiggle - minimize streamgraph wiggling.d3-time ​A calculator for humanity’s peculiar conventions of time.d3.timeInterval - implement a new custom time interval.interval - alias for interval.floor.interval.floor - round down to the nearest boundary.interval.round - round to the nearest boundary.interval.ceil - round up to the nearest boundary.interval.offset - offset a date by some number of intervals.interval.range - generate a range of dates at interval boundaries.interval.filter - create a filtered subset of this interval.interval.every - create a filtered subset of this interval.interval.count - count interval boundaries between two dates.d3.timeMillisecond - the millisecond interval, local time.d3.timeSecond - the second interval, local time.d3.timeMinute - the minute interval, local time.d3.timeHour - the hour interval, local time.d3.timeDay - the day interval, local time.d3.timeWeek - the Sunday-based week interval, local time.d3.timeSunday - the Sunday-based week interval, local time.d3.timeMonday - the Monday-based week interval, local time.d3.timeTuesday - the Tuesday-based week interval, local time.d3.timeWednesday - the Wednesday-based week interval, local time.d3.timeThursday - the Thursday-based week interval, local time.d3.timeFriday - the Friday-based week interval, local time.d3.timeSaturday - the Saturday-based week interval, local time.d3.timeMonth - the month interval, local time.d3.timeYear - the year interval, local time.d3.utcMillisecond - the millisecond interval, UTC time.d3.utcSecond - the second interval, UTC time.d3.utcMinute - the minute interval, UTC time.d3.utcHour - the hour interval, UTC time.d3.utcDay - the day interval, UTC time.d3.utcWeek - the Sunday-based week interval, UTC time.d3.utcSunday - the Sunday-based week interval, UTC time.d3.utcMonday - the Monday-based week interval, UTC time.d3.utcTuesday - the Tuesday-based week interval, UTC time.d3.utcWednesday - the Wednesday-based week interval, UTC time.d3.utcThursday - the Thursday-based week interval, UTC time.d3.utcFriday - the Friday-based week interval, UTC time.d3.utcSaturday - the Saturday-based week interval, UTC time.d3.utcMonth - the month interval, UTC time.d3.utcYear - the year interval, UTC time.d3.unixDay - the day interval, UTC time, not month-aligned.d3.timeMilliseconds - alias for d3.timeMillisecond.range.d3.timeSeconds - alias for d3.timeSecond.range.d3.timeMinutes - alias for d3.timeMinute.range.d3.timeHours - alias for d3.timeHour.range.d3.timeDays - alias for d3.timeDay.range.d3.timeWeeks - alias for d3.timeWeek.range.d3.timeSundays - alias for d3.timeSunday.range.d3.timeMondays - alias for d3.timeMonday.range.d3.timeTuesdays - alias for d3.timeTuesday.range.d3.timeWednesdays - alias for d3.timeWednesday.range.d3.timeThursdays - alias for d3.timeThursday.range.d3.timeFridays - alias for d3.timeFriday.range.d3.timeSaturdays - alias for d3.timeSaturday.range.d3.timeMonths - alias for d3.timeMonth.range.d3.timeYears - alias for d3.timeYear.range.d3.utcMilliseconds - alias for d3.utcMillisecond.range.d3.utcSeconds - alias for d3.utcSecond.range.d3.utcMinutes - alias for d3.utcMinute.range.d3.utcHours - alias for d3.utcHour.range.d3.utcDays - alias for d3.utcDay.range.d3.utcWeeks - alias for d3.utcWeek.range.d3.utcSundays - alias for d3.utcSunday.range.d3.utcMondays - alias for d3.utcMonday.range.d3.utcTuesdays - alias for d3.utcTuesday.range.d3.utcWednesdays - alias for d3.utcWednesday.range.d3.utcThursdays - alias for d3.utcThursday.range.d3.utcFridays - alias for d3.utcFriday.range.d3.utcSaturdays - alias for d3.utcSaturday.range.d3.utcMonths - alias for d3.utcMonth.range.d3.utcYears - alias for d3.utcYear.range.d3.unixDays - alias for d3.unixDay.range.d3.timeTicks - generate representative values from a time interval.d3.utcTicks - generate representative values from a time interval.d3.timeTickInterval - generate representative values from a time interval.d3.utcTickInterval - generate representative values from a time interval.d3-time-format ​Parse and format times, inspired by strptime and strftime.d3.timeFormat - alias for locale.format on the default locale.d3.timeParse - alias for locale.parse on the default locale.d3.utcFormat - alias for locale.utcFormat on the default locale.d3.utcParse - alias for locale.utcParse on the default locale.d3.isoFormat - an ISO 8601 UTC formatter.d3.isoParse - an ISO 8601 UTC parser.locale.format - create a time formatter.locale.parse - create a time parser.locale.utcFormat - create a UTC formatter.locale.utcParse - create a UTC parser.d3.timeFormatLocale - define a custom locale.d3.timeFormatDefaultLocale - define the default locale.d3-timer ​An efficient queue for managing thousands of concurrent animations.d3.now - get the current high-resolution time.d3.timer - schedule a new timer.timer.restart - reset the timer’s start time and callback.timer.stop - stop the timer.d3.timerFlush - immediately execute any eligible timers.d3.timeout - schedule a timer that stops on its first callback.d3.interval - schedule a timer that is called with a configurable period.d3-transition ​Animated transitions for selections.selection.transition - schedule a transition for the selected elements.selection.interrupt - interrupt and cancel transitions on the selected elements.d3.interrupt - interrupt the active transition for a given node.d3.transition - schedule a transition on the root document element.transition.select - schedule a transition on the selected elements.transition.selectAll - schedule a transition on the selected elements.transition.selectChild - select a child element for each selected element.transition.selectChildren - select the children elements for each selected element.transition.selection - returns a selection for this transition.transition.filter - filter elements based on data.transition.merge - merge this transition with another.transition.transition - schedule a new transition following this one.d3.active - select the active transition for a given node.transition.attr - tween the given attribute using the default interpolator.transition.attrTween - tween the given attribute using a custom interpolator.transition.style - tween the given style property using the default interpolator.transition.styleTween - tween the given style property using a custom interpolator.transition.text - set the text content when the transition starts.transition.textTween - tween the text using a custom interpolator.transition.remove - remove the selected elements when the transition ends.transition.tween - run custom code during the transition.transition.delay - specify per-element delay in milliseconds.transition.duration - specify per-element duration in milliseconds.transition.ease - specify the easing function.transition.easeVarying - specify an easing function factory.transition.end - a promise that resolves when a transition ends.transition.on - await the end of a transition.transition.each - call a function for each element.transition.call - call a function with this transition.transition.empty - returns true if this transition is empty.transition.nodes - returns an array of all selected elements.transition.node - returns the first (non-null) element.transition.size - returns the count of elements.d3-zoom ​Pan and zoom SVG, HTML or Canvas using mouse or touch input.d3.zoom - create a zoom behavior.zoom - apply the zoom behavior to the selected elements.zoom.transform - change the transform for the selected elements.zoom.translateBy - translate the transform for the selected elements.zoom.translateTo - translate the transform for the selected elements.zoom.scaleBy - scale the transform for the selected elements.zoom.scaleTo - scale the transform for the selected elements.zoom.constrain - override the transform constraint logic.zoom.filter - control which input events initiate zooming.zoom.touchable - set the touch support detector.zoom.wheelDelta - override scaling for wheel events.zoom.extent - set the extent of the viewport.zoom.scaleExtent - set the allowed scale range.zoom.translateExtent - set the extent of the zoomable world.zoom.clickDistance - set the click distance threshold.zoom.tapDistance - set the tap distance threshold.zoom.duration - set the duration of zoom transitions.zoom.interpolate - control the interpolation of zoom transitions.zoom.on - listen for zoom events.d3.zoomTransform - get the zoom transform for a given element.transform.scale - scale a transform by the specified amount.transform.translate - translate a transform by the specified amount.transform.apply - apply the transform to the given point.transform.applyX - apply the transform to the given x-coordinate.transform.applyY - apply the transform to the given y coordinate.transform.invert - unapply the transform to the given point.transform.invertX - unapply the transform to the given x-coordinate.transform.invertY - unapply the transform to the given y coordinate.transform.rescaleX - apply the transform to an x scale’s domain.transform.rescaleY - apply the transform to a y scale’s domain.transform.toString - format the transform as an SVG transform string.d3.zoomIdentity - the identity transform.\n\nSearchK7.9.0GitHub️ 110.0kOn this pageAPI index ​D3 is a collection of modules that are designed to work together; you can use the modules independently, or you can use them together as part of the default build.d3-array ​Array manipulation, ordering, searching, summarizing, etc.Add ​Add floating point values with full precision.new Adder - create a full precision adder.adder.add - add a value to an adder.adder.valueOf - get the double-precision representation of an adder’s value.fcumsum - compute a full precision cumulative summation of numbers.fsum - compute a full precision summation of an iterable of numbers.Bin ​Bin discrete samples into continuous, non-overlapping intervals.bin - create a new bin generator.bin - bins a given array of samples.bin.value - specify a value accessor for each sample.bin.domain - specify the interval of observable values.bin.thresholds - specify how values are divided into bins.thresholdFreedmanDiaconis - the Freedman–Diaconis binning rule.thresholdScott - Scott’s normal reference binning rule.thresholdSturges - Sturges’ binning formula.Bisect ​Quickly find a value in a sorted array.bisector - bisect using an accessor or comparator.bisector.right - bisectRight, with the given comparator.bisector.left - bisectLeft, with the given comparator.bisector.center - binary search for a value in a sorted array.bisect - binary search for a value in a sorted array.bisectRight - binary search for a value in a sorted array.bisectLeft - binary search for a value in a sorted array.bisectCenter - binary search for a value in a sorted array.Blur ​Blur quantitative values in one or two dimensions.d3.blur - blur an array of numbers in place.d3.blur2 - blur a two-dimensional array of numbers in place.d3.blurImage - blur an RGBA ImageData in place.Group ​Group discrete values.d3.group - group an iterable into a nested Map.d3.groups - group an iterable into a nested array.d3.rollup - reduce an iterable into a nested Map.d3.rollups - reduce an iterable into a nested array.d3.index - index an iterable into a nested Map.d3.indexes - index an iterable into a nested array.d3.flatGroup - group an iterable into a flat array.d3.flatRollup - reduce an iterable into a flat array.d3.groupSort - sort keys according to grouped values.Intern ​Create maps and sets with non-primitive values such as dates.new InternMap - a key-interning Map.new InternSet - a value-interning Set.Sets ​Logical operations on sets.d3.difference - compute a set difference.d3.disjoint - test whether two sets are disjoint.d3.intersection - compute a set intersection.d3.superset - test whether a set is a superset of another.d3.subset - test whether a set is a subset of another.d3.union - compute a set union.Sort ​Sort and reorder arrays of values.d3.ascending - compute the natural order of two values.d3.descending - compute the natural order of two values.d3.permute - reorder an iterable of elements according to an iterable of indexes.d3.quickselect - reorder an array of numbers.d3.reverse - reverse the order of values.d3.shuffle - randomize the order of an iterable.d3.shuffler - randomize the order of an iterable.d3.sort - sort values.Summarize ​Compute summary statistics.d3.count - count valid number values in an iterable.d3.min - compute the minimum value in an iterable.d3.minIndex - compute the index of the minimum value in an iterable.d3.max - compute the maximum value in an iterable.d3.maxIndex - compute the index of the maximum value in an iterable.d3.least - returns the least element of an iterable.d3.leastIndex - returns the index of the least element of an iterable.d3.greatest - returns the greatest element of an iterable.d3.greatestIndex - returns the index of the greatest element of an iterable.d3.extent - compute the minimum and maximum value in an iterable.d3.mode - compute the mode (the most common value) of an iterable of numbers.d3.sum - compute the sum of an iterable of numbers.d3.mean - compute the arithmetic mean of an iterable of numbers.d3.median - compute the median of an iterable of numbers (the 0.5-quantile).d3.medianIndex - compute the median index of an iterable of numbers (the 0.5-quantile).d3.cumsum - compute the cumulative sum of an iterable.d3.quantile - compute a quantile for an iterable of numbers.d3.quantileIndex - compute a quantile index for an iterable of numbers.d3.quantileSorted - compute a quantile for a sorted array of numbers.d3.rank - compute the rank order of an iterable.d3.variance - compute the variance of an iterable of numbers.d3.deviation - compute the standard deviation of an iterable of numbers.d3.every - test if all values satisfy a condition.d3.some - test if any value satisfies a condition.Ticks ​Generate representative values from a continuous interval.d3.ticks - generate representative values from a numeric interval.d3.tickIncrement - generate representative values from a numeric interval.d3.tickStep - generate representative values from a numeric interval.d3.nice - extend an interval to align with ticks.d3.range - generate a range of numeric values.Transform ​Derive new arrays.d3.cross - compute the Cartesian product of two iterables.d3.merge - merge multiple iterables into one array.d3.pairs - create an array of adjacent pairs of elements.d3.transpose - transpose an array of arrays.d3.zip - transpose a variable number of arrays.d3.filter - filter values.d3.map - map values.d3.reduce - reduce values.d3-axis ​Human-readable reference marks for scales.d3.axisTop - create a new top-oriented axis generator.d3.axisRight - create a new right-oriented axis generator.d3.axisBottom - create a new bottom-oriented axis generator.d3.axisLeft - create a new left-oriented axis generator.axis - generate an axis for the given selection.axis.scale - set the scale.axis.ticks - customize how ticks are generated and formatted.axis.tickArguments - customize how ticks are generated and formatted.axis.tickValues - set the tick values explicitly.axis.tickFormat - set the tick format explicitly.axis.tickSize - set the size of the ticks.axis.tickSizeInner - set the size of inner ticks.axis.tickSizeOuter - set the size of outer (extent) ticks.axis.tickPadding - set the padding between ticks and labels.axis.offset - set the pixel offset for crisp edges.d3-brush ​Select a one- or two-dimensional region using the mouse or touch.d3.brush - create a new two-dimensional brush.d3.brushX - create a brush along the x-dimension.d3.brushY - create a brush along the y-dimension.brush - apply the brush to a selection.brush.move - move the brush selection.brush.clear - clear the brush selection.brush.extent - define the brushable region.brush.filter - control which input events initiate brushing.brush.touchable - set the touch support detector.brush.keyModifiers - enable or disable key interaction.brush.handleSize - set the size of the brush handles.brush.on - listen for brush events.d3.brushSelection - get the brush selection for a given node.d3-chord ​d3.chord - create a new chord layout.chord - compute the layout for the given matrix.chord.padAngle - set the padding between adjacent groups.chord.sortGroups - define the group order.chord.sortSubgroups - define the source and target order within groups.chord.sortChords - define the chord order across groups.d3.chordDirected - create a directed chord generator.d3.chordTranspose - create a transposed chord generator.d3.ribbon - create a ribbon shape generator.ribbon - generate a ribbon shape.ribbon.source - set the source accessor.ribbon.target - set the target accessor.ribbon.radius - set the ribbon source and target radius.ribbon.sourceRadius - set the ribbon source radius.ribbon.targetRadius - set the ribbon target radius.ribbon.startAngle - set the ribbon source or target start angle.ribbon.endAngle - set the ribbon source or target end angle.ribbon.padAngle - set the pad angle accessor.ribbon.context - set the render context.d3.ribbonArrow - create an arrow ribbon generator.ribbonArrow.headRadius - set the arrowhead radius accessor.d3-color ​Color manipulation and color space conversion.d3.color - parse the given CSS color specifier.color.opacity - the color’s opacity.color.rgb - compute the RGB equivalent of this color.color.copy - return a copy of this color.color.brighter - create a brighter copy of this color.color.darker - create a darker copy of this color.color.displayable - returns true if the color is displayable on standard hardware.color.formatHex - returns the hexadecimal RRGGBB string representation of this color.color.formatHex8 - returns the hexadecimal RRGGBBAA string representation of this color.color.formatHsl - returns the RGB string representation of this color.color.formatRgb - returns the HSL string representation of this color.color.toString - returns the RGB string representation of this color.d3.rgb - create a new RGB color.rgb.clamp - returns copy of this color clamped to the RGB color space.d3.hsl - create a new HSL color.hsl.clamp - returns copy of this color clamped to the HSL color space.d3.lab - create a new Lab color.d3.gray - create a new Lab gray.d3.hcl - create a new HCL color.d3.lch - create a new HCL color.d3.cubehelix - create a new Cubehelix color.d3-contour ​Compute contour polygons using marching squares.d3.contours - create a new contour generator.contours - compute the contours for a given grid of values.contours.contour - compute a contour for a given value.contours.size - set the size of a contour generator.contours.smooth - set whether or not the generated contours are smoothed.contours.thresholds - set the thresholds of a contour generator.d3.contourDensity - create a new density estimator.density - estimate the density of a given array of samples.density.x - set the x accessor of the density estimator.density.y - set the y accessor of the density estimator.density.weight - set the weight accessor of the density estimator.density.size - set the size of the density estimator.density.cellSize - set the cell size of the density estimator.density.thresholds - set the thresholds of the density estimator.density.bandwidth - set the bandwidth of the density estimator.density.contours - compute density contours.d3-delaunay ​Compute the Voronoi diagram of a set of two-dimensional points.new Delaunay - create a delaunay triangulation for an array of point coordinates.Delaunay.from - create a delaunay triangulation for an iterable of points.delaunay.points - the coordinates of the points.delaunay.halfedges - the delaunay halfedges.delaunay.hull - the convex hull as point indices.delaunay.triangles - the delaunay triangles.delaunay.inedges - the delaunay inedgesdelaunay.find - find the closest point in the delaunay triangulation.delaunay.neighbors - the neighbors of a point in the delaunay triangulation.delaunay.render - render the edges of the delaunay triangulation.delaunay.renderHull - render the convex hull.delaunay.renderTriangle - render a triangle.delaunay.renderPoints - render the points.delaunay.hullPolygon - the closed convex hull as point coordinates.delaunay.trianglePolygons - iterate over all the triangles as polygons.delaunay.trianglePolygon - return a triangle as a polygon.delaunay.update - update a delaunay triangulation in place.delaunay.voronoi - compute the voronoi diagram associated with a delaunay triangulation.voronoi.delaunay - the voronoi diagram’s source delaunay triangulation.voronoi.circumcenters - the triangles’ circumcenters.voronoi.vectors - directions for the outer (infinite) cells of the voronoi diagram.voronoi.xmin - set the xmin bound of the extent.voronoi.ymin - set the ymin bound of the extent.voronoi.xmax - set the xmax bound of the extent.voronoi.ymax - set the ymax bound of the extent.voronoi.contains - test whether a point is inside a voronoi cell.voronoi.neighbors - the neighbors of a point in the voronoi diagram.voronoi.render - render the mesh of voronoi cells.voronoi.renderBounds - render the extent.voronoi.renderCell - render a voronoi cell.voronoi.cellPolygons - iterate over all the cells as polygons.voronoi.cellPolygon - return a cell as a polygon.voronoi.update - update a voronoi diagram in place.d3-dispatch ​Separate concerns using named callbacks.d3.dispatch - create a custom event dispatcher.dispatch.on - register or unregister an event listener.dispatch.copy - create a copy of a dispatcher.dispatch.call - dispatch an event to registered listeners.dispatch.apply - dispatch an event to registered listeners.d3-drag ​Drag and drop SVG, HTML or Canvas using mouse or touch input.d3.drag - create a drag behavior.drag - apply the drag behavior to a selection.drag.container - set the coordinate system.drag.filter - ignore some initiating input events.drag.touchable - set the touch support detector.drag.subject - set the thing being dragged.drag.clickDistance - set the click distance threshold.drag.on - listen for drag events.d3.dragDisable - prevent native drag-and-drop and text selection.d3.dragEnable - enable native drag-and-drop and text selection.event.on - listen for drag events on the current gesture.d3-dsv ​Parse and format delimiter-separated values, most commonly CSV and TSV.d3.csvParse - parse the given CSV string, returning an array of objects.d3.csvParseRows - parse the given CSV string, returning an array of rows.d3.csvFormat - format the given array of objects as CSV.d3.csvFormatBody - format the given array of objects as CSV.d3.csvFormatRows - format the given array of rows as CSV.d3.csvFormatRow - format the given row as CSV.d3.csvFormatValue - format the given value as CSV.d3.tsvParse - parse the given TSV string, returning an array of objects.d3.tsvParseRows - parse the given TSV string, returning an array of rows.d3.tsvFormat - format the given array of objects as TSV.d3.tsvFormatBody - format the given array of objects as TSV.d3.tsvFormatRows - format the given array of rows as TSV.d3.tsvFormatRow - format the given row as TSV.d3.tsvFormatValue - format the given value as TSV.d3.dsvFormat - create a new parser and formatter for the given delimiter.dsv.parse - parse the given string, returning an array of objects.dsv.parseRows - parse the given string, returning an array of rows.dsv.format - format the given array of objects.dsv.formatBody - format the given array of objects.dsv.formatRows - format the given array of rows.dsv.formatRow - format the given row.dsv.formatValue - format the given value.d3.autoType - automatically infer value types for the given object.d3-ease ​Easing functions for smooth animation.ease - ease the given normalized time.d3.easeLinear - linear easing; the identity function.d3.easePolyIn - polynomial easing; raises time to the given power.d3.easePolyOut - reverse polynomial easing.d3.easePoly - an alias for easePolyInOut.d3.easePolyInOut - symmetric polynomial easing.poly.exponent - specify the polynomial exponent.d3.easeQuadIn - quadratic easing; squares time.d3.easeQuadOut - reverse quadratic easing.d3.easeQuad - an alias for easeQuadInOut.d3.easeQuadInOut - symmetric quadratic easing.d3.easeCubicIn - cubic easing; cubes time.d3.easeCubicOut - reverse cubic easing.d3.easeCubic - an alias for easeCubicInOut.d3.easeCubicInOut - symmetric cubic easing.d3.easeSinIn - sinusoidal easing.d3.easeSinOut - reverse sinusoidal easing.d3.easeSin - an alias for easeSinInOut.d3.easeSinInOut - symmetric sinusoidal easing.d3.easeExpIn - exponential easing.d3.easeExpOut - reverse exponential easing.d3.easeExp - an alias for easeExpInOut.d3.easeExpInOut - symmetric exponential easing.d3.easeCircleIn - circular easing.d3.easeCircleOut - reverse circular easing.d3.easeCircle - an alias for easeCircleInOut.d3.easeCircleInOut - symmetric circular easing.d3.easeElasticIn - elastic easing, like a rubber band.d3.easeElastic - an alias for easeElasticOut.d3.easeElasticOut - reverse elastic easing.d3.easeElasticInOut - symmetric elastic easing.elastic.amplitude - specify the elastic amplitude.elastic.period - specify the elastic period.d3.easeBackIn - anticipatory easing, like a dancer bending his knees before jumping.d3.easeBackOut - reverse anticipatory easing.d3.easeBack - an alias for easeBackInOut.d3.easeBackInOut - symmetric anticipatory easing.back.overshoot - specify the amount of overshoot.d3.easeBounceIn - bounce easing, like a rubber ball.d3.easeBounce - an alias for easeBounceOut.d3.easeBounceOut - reverse bounce easing.d3.easeBounceInOut - symmetric bounce easing.d3-fetch ​Convenience methods on top of the Fetch API.d3.blob - get a file as a blob.d3.buffer - get a file as an array buffer.d3.csv - get a comma-separated values (CSV) file.d3.dsv - get a delimiter-separated values (CSV) file.d3.html - get an HTML file.d3.image - get an image.d3.json - get a JSON file.d3.svg - get an SVG file.d3.text - get a plain text file.d3.tsv - get a tab-separated values (TSV) file.d3.xml - get an XML file.d3-force ​Force-directed graph layout using velocity Verlet integration.d3.forceSimulation - create a new force simulation.simulation.restart - reheat and restart the simulation’s timer.simulation.stop - stop the simulation’s timer.simulation.tick - advance the simulation one step.simulation.nodes - set the simulation’s nodes.simulation.alpha - set the current alpha.simulation.alphaMin - set the minimum alpha threshold.simulation.alphaDecay - set the alpha exponential decay rate.simulation.alphaTarget - set the target alpha.simulation.velocityDecay - set the velocity decay rate.simulation.force - add or remove a force.simulation.find - find the closest node to the given position.simulation.randomSource - set the simulation’s random source.simulation.on - add or remove an event listener.force - apply the force.force.initialize - initialize the force with the given nodes.d3.forceCenter - create a centering force.center.x - set the center x-coordinate.center.y - set the center y coordinate.center.strength - set the strength of the centering force.d3.forceCollide - create a circle collision force.collide.radius - set the circle radius.collide.strength - set the collision resolution strength.collide.iterations - set the number of iterations.d3.forceLink - create a link force.link.links - set the array of links.link.id - link nodes by numeric index or string identifier.link.distance - set the link distance.link.strength - set the link strength.link.iterations - set the number of iterations.d3.forceManyBody - create a many-body force.manyBody.strength - set the force strength.manyBody.theta - set the Barnes–Hut approximation accuracy.manyBody.distanceMin - limit the force when nodes are close.manyBody.distanceMax - limit the force when nodes are far.d3.forceX - create an x-positioning force.x.strength - set the force strength.x.x - set the target x-coordinate.d3.forceY - create an y-positioning force.y.strength - set the force strength.y.y - set the target y coordinate.d3.forceRadial - create a radial positioning force.radial.strength - set the force strength.radial.radius - set the target radius.radial.x - set the target center x-coordinate.radial.y - set the target center y coordinate.d3-format ​Format numbers for human consumption.d3.format - alias for locale.format on the default locale.d3.formatPrefix - alias for locale.formatPrefix on the default locale.locale.format - create a number format.locale.formatPrefix - create a SI-prefix number format.d3.formatSpecifier - parse a number format specifier.new d3.FormatSpecifier - augments a number format specifier object.d3.precisionFixed - compute decimal precision for fixed-point notation.d3.precisionPrefix - compute decimal precision for SI-prefix notation.d3.precisionRound - compute significant digits for rounded notation.d3.formatLocale - define a custom locale.d3.formatDefaultLocale - define the default locale.d3-geo ​Geographic projections, shapes and math.Paths ​d3.geoPath - create a new geographic path generator.path - project and render the specified feature.path.area - compute the projected planar area of a given feature.path.bounds - compute the projected planar bounding box of a given feature.path.centroid - compute the projected planar centroid of a given feature.path.digits - set the output precision.path.measure - compute the projected planar length of a given feature.path.projection - set the geographic projection.path.context - set the render context.path.pointRadius - set the radius to display point features.Projections ​projection - project the specified point from the sphere to the plane.projection.invert - unproject the specified point from the plane to the sphere.projection.stream - wrap the specified stream to project geometry.projection.preclip - set the projection’s spherical clipping function.projection.postclip - set the projection’s cartesian clipping function.projection.clipAngle - set the radius of the clip circle.projection.clipExtent - set the viewport clip extent, in pixels.projection.scale - set the scale factor.projection.translate - set the translation offset.projection.center - set the center point.projection.angle - set the post-projection rotation.projection.reflectX - reflect the x-dimension.projection.reflectY - reflect the y-dimension.projection.rotate - set the three-axis spherical rotation angles.projection.precision - set the precision threshold for adaptive sampling.projection.fitExtent - set the scale and translate to fit a GeoJSON object.projection.fitSize - set the scale and translate to fit a GeoJSON object.projection.fitWidth - set the scale and translate to fit a GeoJSON object.projection.fitHeight - set the scale and translate to fit a GeoJSON object.Raw projections ​project - project the specified point from the sphere to the plane.project.invert - unproject the specified point from the plane to the sphere.d3.geoProjection - create a custom projection.d3.geoProjectionMutator - create a custom configurable projection.d3.geoTransform - define a custom geometry transform.d3.geoIdentity - scale, translate or clip planar geometry.d3.geoClipAntimeridian - cuts spherical geometries that cross the antimeridian.d3.geoClipCircle - clips spherical geometries to a small circle.d3.geoClipRectangle - clips planar geometries to a rectangular viewport.Azimuthal projections ​d3.geoAzimuthalEqualArea - the azimuthal equal-area projection.d3.geoAzimuthalEquidistant - the azimuthal equidistant projection.d3.geoGnomonic - the gnomonic projection.d3.geoOrthographic - the azimuthal orthographic projection.d3.geoStereographic - the azimuthal stereographic projection.Conic projections ​conic.parallels - set the two standard parallels.d3.geoConicConformal - the conic conformal projection.d3.geoConicEqualArea - the conic equal-area (Albers) projection.d3.geoConicEquidistant - the conic equidistant projection.d3.geoAlbers - the Albers equal-area conic projection.d3.geoAlbersUsa - a composite Albers projection for the United States.Cylindrical projections ​d3.geoEquirectangular - the equirectangular (plate carreé) projection.d3.geoMercator - the spherical Mercator projection.d3.geoTransverseMercator - the transverse spherical Mercator projection.d3.geoEqualEarth - the Equal Earth projection.d3.geoNaturalEarth1 - the Equal Earth projection, version 1.Streams ​d3.geoStream - convert a GeoJSON object to a geometry stream.stream.point - indicates a point with the specified coordinates.stream.lineStart - indicates the start of a line or ring.stream.lineEnd - indicates the end of a line or ring.stream.polygonStart - indicates the start of a polygon.stream.polygonEnd - indicates the end of a polygon.stream.sphere - indicates the sphere.Spherical shapes ​d3.geoGraticule - create a graticule generator.graticule - generate a MultiLineString of meridians and parallels.graticule.lines - generate an array of LineStrings of meridians and parallels.graticule.outline - generate a Polygon of the graticule’s extent.graticule.extent - get or set the major & minor extents.graticule.extentMajor - get or set the major extent.graticule.extentMinor - get or set the minor extent.graticule.step - get or set the major & minor step intervals.graticule.stepMajor - get or set the major step intervals.graticule.stepMinor - get or set the minor step intervals.graticule.precision - get or set the latitudinal precision.d3.geoGraticule10 - generate the default 10° global graticule.d3.geoCircle - create a circle generator.circle - generate a piecewise circle as a Polygon.circle.center - specify the circle center in latitude and longitude.circle.radius - specify the angular radius in degrees.circle.precision - specify the precision of the piecewise circle.Spherical math ​d3.geoArea - compute the spherical area of a given feature.d3.geoBounds - compute the latitude-longitude bounding box for a given feature.d3.geoCentroid - compute the spherical centroid of a given feature.d3.geoDistance - compute the great-arc distance between two points.d3.geoLength - compute the length of a line string or the perimeter of a polygon.d3.geoInterpolate - interpolate between two points along a great arc.d3.geoContains - test whether a point is inside a given feature.d3.geoRotation - create a rotation function for the specified angles.d3-hierarchy ​Layout algorithms for visualizing hierarchical data.d3.hierarchy - constructs a root node from hierarchical data.node.ancestors - generate an array of ancestors.node.descendants - generate an array of descendants.node.leaves - generate an array of leaves.node.find - find a node in the hierarchy.node.path - generate the shortest path to another node.node.links - generate an array of links.node.sum - evaluate and aggregate quantitative values.node.count - count the number of leaves.node.sort - sort all descendant siblings.node[Symbol.iterator] - iterate on a hierarchy.node.each - breadth-first traversal.node.eachAfter - post-order traversal.node.eachBefore - pre-order traversal.node.copy - copy a hierarchy.d3.stratify - create a new stratify operator.stratify - construct a root node from tabular data.stratify.id - set the node id accessor.stratify.parentId - set the parent node id accessor.stratify.path - set the path accessor.d3.cluster - create a new cluster (dendrogram) layout.cluster - layout the specified hierarchy in a dendrogram.cluster.size - set the layout size.cluster.nodeSize - set the node size.cluster.separation - set the separation between leaves.d3.tree - create a new tidy tree layout.tree - layout the specified hierarchy in a tidy tree.tree.size - set the layout size.tree.nodeSize - set the node size.tree.separation - set the separation between nodes.d3.treemap - create a new treemap layout.treemap - layout the specified hierarchy as a treemap.treemap.tile - set the tiling method.treemap.size - set the layout size.treemap.round - set whether the output coordinates are rounded.treemap.padding - set the padding.treemap.paddingInner - set the padding between siblings.treemap.paddingOuter - set the padding between parent and children.treemap.paddingTop - set the padding between the parent’s top edge and children.treemap.paddingRight - set the padding between the parent’s right edge and children.treemap.paddingBottom - set the padding between the parent’s bottom edge and children.treemap.paddingLeft - set the padding between the parent’s left edge and children.d3.treemapBinary - tile using a balanced binary tree.d3.treemapDice - tile into a horizontal row.d3.treemapSlice - tile into a vertical column.d3.treemapSliceDice - alternate between slicing and dicing.d3.treemapSquarify - tile using squarified rows per Bruls et. al.d3.treemapResquarify - like d3.treemapSquarify, but performs stable updates.squarify.ratio - set the desired rectangle aspect ratio.d3.partition - create a new partition (icicle or sunburst) layout.partition - layout the specified hierarchy as a partition diagram.partition.size - set the layout size.partition.round - set whether the output coordinates are rounded.partition.padding - set the padding.d3.pack - create a new circle-packing layout.pack - layout the specified hierarchy using circle-packing.pack.radius - set the radius accessor.pack.size - set the layout size.pack.padding - set the padding.d3.packSiblings - pack the specified array of circles.d3.packEnclose - enclose the specified array of circles.d3-interpolate ​Interpolate numbers, colors, strings, arrays, objects, whatever!Value interpolation ​d3.interpolate - interpolate arbitrary values.d3.interpolateNumber - interpolate numbers.d3.interpolateRound - interpolate integers.d3.interpolateString - interpolate strings with embedded numbers.d3.interpolateDate - interpolate dates.d3.interpolateArray - interpolate arrays of arbitrary values.d3.interpolateNumberArray - interpolate arrays of numbers.d3.interpolateObject - interpolate arbitrary objects.d3.interpolateBasis - generate a B-spline through a set of values.d3.interpolateBasisClosed - generate a closed B-spline through a set of values.d3.interpolateDiscrete - generate a discrete interpolator from a set of values.d3.quantize - generate uniformly-spaced samples from an interpolator.d3.piecewise - generate a piecewise linear interpolator from a set of values.Color interpolation ​d3.interpolateRgb - interpolate RGB colors.d3.interpolateRgbBasis - generate a B-spline through a set of colors.d3.interpolateRgbBasisClosed - generate a closed B-spline through a set of colors.d3.interpolateHsl - interpolate HSL colors.d3.interpolateHslLong - interpolate HSL colors, the long way.d3.interpolateLab - interpolate Lab colors.d3.interpolateHcl - interpolate HCL colors.d3.interpolateHclLong - interpolate HCL colors, the long way.d3.interpolateCubehelix - interpolate Cubehelix colors.d3.interpolateCubehelixLong - interpolate Cubehelix colors, the long way.interpolateColor.gamma - apply gamma correction during interpolation.d3.interpolateHue - interpolate a hue angle.Transform interpolation ​d3.interpolateTransformCss - interpolate 2D CSS transforms.d3.interpolateTransformSvg - interpolate 2D SVG transforms.Zoom interpolation ​d3.interpolateZoom - zoom and pan between two views.interpolateZoom.rho - set the curvature rho of the zoom interpolator.d3-path ​Serialize Canvas path commands to SVG.d3.path - create a new path serializer.path.moveTo - move to the given point.path.closePath - close the current subpath.path.lineTo - draw a straight line segment.path.quadraticCurveTo - draw a quadratic Bézier segment.path.bezierCurveTo - draw a cubic Bézier segment.path.arcTo - draw a circular arc segment.path.arc - draw a circular arc segment.path.rect - draw a rectangle.path.toString - serialize to an SVG path data string.d3.pathRound - create a new path serializer with fixed output precision.d3-polygon ​Geometric operations for two-dimensional polygons.d3.polygonArea - compute the area of the given polygon.d3.polygonCentroid - compute the centroid of the given polygon.d3.polygonHull - compute the convex hull of the given points.d3.polygonContains - test whether a point is inside a polygon.d3.polygonLength - compute the length of the given polygon’s perimeter.d3-quadtree ​Two-dimensional recursive spatial subdivision.d3.quadtree - create a new, empty quadtree.quadtree.x - set the x accessor.quadtree.y - set the y accessor.quadtree.extent - extend the quadtree to cover an extent.quadtree.cover - extend the quadtree to cover a point.quadtree.add - add a datum to a quadtree.quadtree.addAll - add an array of data to a quadtree.quadtree.remove - remove a datum from a quadtree.quadtree.removeAll - remove an array of data from a quadtree.quadtree.copy - create a copy of a quadtree.quadtree.root - get the quadtree’s root node.quadtree.data - retrieve all data from the quadtree.quadtree.size - count the number of data in the quadtree.quadtree.find - quickly find the closest datum in a quadtree.quadtree.visit - selectively visit nodes in a quadtree.quadtree.visitAfter - visit all nodes in a quadtree.d3-random ​Generate random numbers from various distributions.d3.randomUniform - from a uniform distribution.d3.randomInt - from a uniform integer distribution.d3.randomNormal - from a normal distribution.d3.randomLogNormal - from a log-normal distribution.d3.randomBates - from a Bates distribution.d3.randomIrwinHall - from an Irwin–Hall distribution.d3.randomExponential - from an exponential distribution.d3.randomPareto - from a Pareto distribution.d3.randomBernoulli - from a Bernoulli distribution.d3.randomGeometric - from a geometric distribution.d3.randomBinomial - from a binomial distribution.d3.randomGamma - from a gamma distribution.d3.randomBeta - from a beta distribution.d3.randomWeibull - from a Weibull, Gumbel or Fréchet distribution.d3.randomCauchy - from a Cauchy distribution.d3.randomLogistic - from a logistic distribution.d3.randomPoisson - from a Poisson distribution.random.source - set the source of randomness.d3.randomLcg - a seeded pseudorandom number generator.d3-scale ​Encodings that map abstract data to visual representation.Linear scales ​Map a continuous, quantitative domain to a continuous range.d3.scaleLinear - create a quantitative linear scale.linear - compute the range value corresponding to a given domain value.linear.invert - compute the domain value corresponding to a given range value.linear.domain - set the input domain.linear.range - set the output range.linear.rangeRound - set the output range and enable rounding.linear.clamp - enable clamping to the domain or range.linear.unknown - set the output value for unknown inputs.linear.interpolate - set the output interpolator.linear.ticks - compute representative values from the domain.linear.tickFormat - format ticks for human consumption.linear.nice - extend the domain to nice round numbers.linear.copy - create a copy of this scale.d3.tickFormat - format ticks for human consumption.d3.scaleIdentity - creates an identity scale.d3.scaleRadial - creates a radial scale.Pow scales ​d3.scalePow - create a quantitative power scale.d3.scaleSqrt - create a quantitative power scale with exponent 0.5.pow.exponent - set the power exponent.Log scales ​d3.scaleLog - create a quantitative logarithmic scale.log.base - set the logarithm base.log.ticks - compute representative values from the domain.log.tickFormat - format ticks for human consumption.log.nice - extend the domain to nice round numbers.Symlog scales ​d3.scaleSymlog - create a symmetric logarithmic scale.symlog.constant - set the constant of a symlog scale.Time scales ​d3.scaleTime - create a linear scale for time.time.ticks - compute representative values from the domain.time.tickFormat - format ticks for human consumption.time.nice - extend the domain to nice round times.d3.scaleUtc - create a linear scale for UTC.Sequential scales ​Map a continuous, quantitative domain to a continuous, fixed interpolator.d3.scaleSequential - create a sequential scale.sequential.interpolator - set the scale’s output interpolator.sequential.range - set the output range.sequential.rangeRound - set the output range and enable rounding.d3.scaleSequentialLog - create a logarithmic sequential scale.d3.scaleSequentialPow - create a power sequential scale.d3.scaleSequentialSqrt - create a power sequential scale with exponent 0.5.d3.scaleSequentialSymlog - create a symmetric logarithmic sequential scale.d3.scaleSequentialQuantile - create a sequential scale using a p-quantile transform.sequentialQuantile.quantiles - return the scale’s quantiles.Diverging scales ​Map a continuous, quantitative domain to a continuous, fixed interpolator.d3.scaleDiverging - create a diverging scale.diverging.interpolator - set the scale’s output interpolator.diverging.range - set the output range.diverging.rangeRound - set the output range and enable rounding.d3.scaleDivergingLog - create a diverging logarithmic scale.d3.scaleDivergingPow - create a diverging power scale.d3.scaleDivergingSqrt - create a diverging power scale with exponent 0.5.d3.scaleDivergingSymlog - create a diverging symmetric logarithmic scale.Quantize scales ​Map a continuous, quantitative domain to a discrete range.d3.scaleQuantize - create a uniform quantizing linear scale.quantize - compute the range value corresponding to a given domain value.quantize.invertExtent - compute the domain values corresponding to a given range value.quantize.domain - set the input domain.quantize.range - set the output range.quantize.thresholds - return the array of computed thresholds within the domain.quantize.copy - create a copy of this scale.Quantile scales ​d3.scaleQuantile - create a quantile quantizing linear scale.quantile - compute the range value corresponding to a given domain value.quantile.invertExtent - compute the domain values corresponding to a given range value.quantile.domain - set the input domain.quantile.range - set the output range.quantile.quantiles - get the quantile thresholds.quantile.copy - create a copy of this scale.Threshold scales ​d3.scaleThreshold - create an arbitrary quantizing linear scale.threshold - compute the range value corresponding to a given domain value.threshold.invertExtent - compute the domain values corresponding to a given range value.threshold.domain - set the input domain.threshold.range - set the output range.threshold.copy - create a copy of this scale.Ordinal scales ​Map a discrete domain to a discrete range.d3.scaleOrdinal - create an ordinal scale.ordinal - compute the range value corresponding to a given domain value.ordinal.domain - set the input domain.ordinal.range - set the output range.ordinal.unknown - set the output value for unknown inputs.ordinal.copy - create a copy of this scale.d3.scaleImplicit - a special unknown value for implicit domains.Band scales ​d3.scaleBand - create an ordinal band scale.band - compute the band start corresponding to a given domain value.band.domain - set the input domain.band.range - set the output range.band.rangeRound - set the output range and enable rounding.band.round - enable rounding.band.paddingInner - set padding between bands.band.paddingOuter - set padding outside the first and last bands.band.padding - set padding outside and between bands.band.align - set band alignment, if there is extra space.band.bandwidth - get the width of each band.band.step - get the distance between the starts of adjacent bands.band.copy - create a copy of this scale.Point scales ​d3.scalePoint - create an ordinal point scale.point - compute the point corresponding to a given domain value.point.domain - set the input domain.point.range - set the output range.point.rangeRound - set the output range and enable rounding.point.round - enable rounding.point.padding - set padding outside the first and last point.point.align - set point alignment, if there is extra space.point.bandwidth - returns zero.point.step - get the distance between the starts of adjacent points.point.copy - create a copy of this scale.d3-scale-chromatic ​Color ramps and palettes for quantitative, ordinal and categorical scales.Categorical ​d3.schemeCategory10 - an array of ten categorical colors.d3.schemeAccent - an array of eight categorical colors.d3.schemeDark2 - an array of eight categorical colors.d3.schemeObservable10 - an array of ten categorical colors.d3.schemePaired - an array of twelve categorical colors.d3.schemePastel1 - an array of nine categorical colors.d3.schemePastel2 - an array of eight categorical colors.d3.schemeSet1 - an array of nine categorical colors.d3.schemeSet2 - an array of eight categorical colors.d3.schemeSet3 - an array of twelve categorical colors.d3.schemeTableau10 - an array of ten categorical colors.Cyclical ​d3.interpolateRainbow - the “less-angry” rainbowd3.interpolateSinebow - the “sinebow” smooth rainbowDiverging ​d3.interpolateBrBG - ColorBrewer BrBG interpolator.d3.interpolatePiYG - ColorBrewer PiYG interpolator.d3.interpolatePRGn - ColorBrewer PRGn interpolator.d3.interpolatePuOr - ColorBrewer PuOr interpolator.d3.interpolateRdBu - ColorBrewer RdBu interpolator.d3.interpolateRdGy - ColorBrewer RdGy interpolator.d3.interpolateRdYlBu - ColorBrewer RdYlBu interpolator.d3.interpolateRdYlGn - ColorBrewer RdYlGn interpolator.d3.interpolateSpectral - ColorBrewer spectral interpolator.d3.schemeBrBG - ColorBrewer BrBG scheme.d3.schemePiYG - ColorBrewer PiYG scheme.d3.schemePRGn - ColorBrewer PRGn scheme.d3.schemePuOr - ColorBrewer PuOr scheme.d3.schemeRdBu - ColorBrewer RdBu scheme.d3.schemeRdGy - ColorBrewer RdGy scheme.d3.schemeRdYlBu - ColorBrewer RdYlBu scheme.d3.schemeRdYlGn - ColorBrewer RdYlGn scheme.d3.schemeSpectral - ColorBrewer spectral scheme.Sequential ​d3.interpolateBlues -d3.interpolateGreens -d3.interpolateGreys -d3.interpolateOranges -d3.interpolatePurples -d3.interpolateReds -d3.schemeBlues -d3.schemeGreens -d3.schemeGreys -d3.schemeOranges -d3.schemePurples -d3.schemeReds -d3.interpolateBuGn - ColorBrewer BuGn interpolator.d3.interpolateBuPu - ColorBrewer BuPu interpolator.d3.interpolateCividis - cividis interpolator.d3.interpolateCool - cool interpolator.d3.interpolateCubehelixDefault - cubehelix interpolator.d3.interpolateGnBu - ColorBrewer GnBu interpolator.d3.interpolateInferno - inferno interpolator.d3.interpolateMagma - magma interpolator.d3.interpolateOrRd - ColorBrewer OrRd interpolator.d3.interpolatePlasma - plasma interpolator.d3.interpolatePuBu - ColorBrewer PuBu interpolator.d3.interpolatePuBuGn - ColorBrewer PuBuGn interpolator.d3.interpolatePuRd - ColorBrewer PuRd interpolator.d3.interpolateRdPu - ColorBrewer RdPu interpolator.d3.interpolateTurbo - turbo interpolator.d3.interpolateViridis - viridis interpolator.d3.interpolateWarm - warm interpolator.d3.interpolateYlGn - ColorBrewer YlGn interpolator.d3.interpolateYlGnBu - ColorBrewer YlGnBu interpolator.d3.interpolateYlOrBr - ColorBrewer YlOrBr interpolator.d3.interpolateYlOrRd - ColorBrewer YlOrRd interpolator.d3.schemeBuGn - ColorBrewer BuGn scheme.d3.schemeBuPu - ColorBrewer BuPu scheme.d3.schemeGnBu - ColorBrewer GnBu scheme.d3.schemeOrRd - ColorBrewer OrRd scheme.d3.schemePuBu - ColorBrewer PuBu scheme.d3.schemePuBuGn - ColorBrewer PuBuGn scheme.d3.schemePuRd - ColorBrewer PuRd scheme.d3.schemeRdPu - ColorBrewer RdPu scheme.d3.schemeYlGn - ColorBrewer YlGn scheme.d3.schemeYlGnBu - ColorBrewer YlGnBu scheme.d3.schemeYlOrBr - ColorBrewer YlOrBr scheme.d3.schemeYlOrRd - ColorBrewer YlOrRd scheme.d3-selection ​Transform the DOM by selecting elements and joining to data.Selecting elements ​d3.selection - select the root document element.d3.select - select an element from the document.d3.selectAll - select multiple elements from the document.selection.select - select a descendant element for each selected element.selection.selectAll - select multiple descendants for each selected element.selection.filter - filter elements based on data.selection.merge - merge this selection with another.selection.selectChild - select a child element for each selected element.selection.selectChildren - select the children elements for each selected element.selection.selection - return the selection.d3.matcher - test whether an element matches a selector.d3.selector - select an element.d3.selectorAll - select elements.d3.window - get a node’s owner window.d3.style - get a node’s current style value.Modifying elements ​selection.attr - get or set an attribute.selection.classed - get, add or remove CSS classes.selection.style - get or set a style property.selection.property - get or set a (raw) property.selection.text - get or set the text content.selection.html - get or set the inner HTML.selection.append - create, append and select new elements.selection.insert - create, insert and select new elements.selection.remove - remove elements from the document.selection.clone - insert clones of selected elements.selection.sort - sort elements in the document based on data.selection.order - reorders elements in the document to match the selection.selection.raise - reorders each element as the last child of its parent.selection.lower - reorders each element as the first child of its parent.d3.create - create and select a detached element.d3.creator - create an element by name.Joining data ​selection.data - bind elements to data.selection.join - enter, update or exit elements based on data.selection.enter - get the enter selection (data missing elements).selection.exit - get the exit selection (elements missing data).selection.datum - get or set element data (without joining).Handling events ​selection.on - add or remove event listeners.selection.dispatch - dispatch a custom event.d3.pointer - get the pointer’s position of an event.d3.pointers - get the pointers’ positions of an event.Control flow ​selection.each - call a function for each element.selection.call - call a function with this selection.selection.empty - returns true if this selection is empty.selection.nodes - returns an array of all selected elements.selection.node - returns the first (non-null) element.selection.size - returns the count of elements.selection[Symbol.iterator] - iterate over the selection’s nodes.Local variables ​d3.local - declares a new local variable.local.set - set a local variable’s value.local.get - get a local variable’s value.local.remove - delete a local variable.local.toString - get the property identifier of a local variable.Namespaces ​d3.namespace - qualify a prefixed XML name, such as “xlink:href”.d3.namespaces - the built-in XML namespaces.d3-shape ​Graphical primitives for visualization.Arcs ​Circular or annular sectors, as in a pie or donut chart.d3.arc - create a new arc generator.arc - generate an arc for the given datum.arc.centroid - compute an arc’s midpoint.arc.innerRadius - set the inner radius.arc.outerRadius - set the outer radius.arc.cornerRadius - set the corner radius, for rounded corners.arc.startAngle - set the start angle.arc.endAngle - set the end angle.arc.padAngle - set the angle between adjacent arcs, for padded arcs.arc.padRadius - set the radius at which to linearize padding.arc.context - set the rendering context.arc.digits - set the output precision.Pies ​Compute the necessary angles to represent a tabular dataset as a pie or donut chart.d3.pie - create a new pie generator.pie - compute the arc angles for the given dataset.pie.value - set the value accessor.pie.sort - set the sort order comparator.pie.sortValues - set the sort order comparator.pie.startAngle - set the overall start angle.pie.endAngle - set the overall end angle.pie.padAngle - set the pad angle between adjacent arcs.Lines ​A spline or polyline, as in a line chart.d3.line - create a new line generator.line - generate a line for the given dataset.line.x - set the x accessor.line.y - set the y accessor.line.defined - set the defined accessor.line.curve - set the curve interpolator.line.context - set the rendering context.line.digits - set the output precision.d3.lineRadial - create a new radial line generator.lineRadial - generate a line for the given dataset.lineRadial.angle - set the angle accessor.lineRadial.radius - set the radius accessor.lineRadial.defined - set the defined accessor.lineRadial.curve - set the curve interpolator.lineRadial.context - set the rendering context.Areas ​An area, defined by a bounding topline and baseline, as in an area chart.d3.area - create a new area generator.area - generate an area for the given dataset.area.x - set the x0 and x1 accessors.area.x0 - set the baseline x accessor.area.x1 - set the topline x accessor.area.y - set the y0 and y1 accessors.area.y0 - set the baseline y accessor.area.y1 - set the topline y accessor.area.defined - set the defined accessor.area.curve - set the curve interpolator.area.context - set the rendering context.area.digits - set the output precision.area.lineX0 - derive a line for the left edge of an area.area.lineY0 - derive a line for the top edge of an area.area.lineX1 - derive a line for the right edge of an area.area.lineY1 - derive a line for the bottom edge of an area.d3.areaRadial - create a new radial area generator.areaRadial - generate an area for the given dataset.areaRadial.angle - set the start and end angle accessors.areaRadial.startAngle - set the start angle accessor.areaRadial.endAngle - set the end angle accessor.areaRadial.radius - set the inner and outer radius accessors.areaRadial.innerRadius - set the inner radius accessor.areaRadial.outerRadius - set the outer radius accessor.areaRadial.defined - set the defined accessor.areaRadial.curve - set the curve interpolator.areaRadial.context - set the rendering context.areaRadial.lineStartAngle - derive a line for the start edge of an area.areaRadial.lineInnerRadius - derive a line for the inner edge of an area.areaRadial.lineEndAngle - derive a line for the end edge of an area.areaRadial.lineOuterRadius - derive a line for the outer edge of an area.Curves ​Interpolate between points to produce a continuous shape.d3.curveBasis - a cubic basis spline, repeating the end points.d3.curveBasisClosed - a closed cubic basis spline.d3.curveBasisOpen - a cubic basis spline.d3.curveBundle - a straightened cubic basis spline.bundle.beta - set the bundle tension beta.d3.curveBumpX - a cubic Bézier spline with horizontal tangents.d3.curveBumpY - a cubic Bézier spline with vertical tangents.d3.curveCardinal - a cubic cardinal spline, with one-sided difference at each end.d3.curveCardinalClosed - a closed cubic cardinal spline.d3.curveCardinalOpen - a cubic cardinal spline.cardinal.tension - set the cardinal spline tension.d3.curveCatmullRom - a cubic Catmull–Rom spline, with one-sided difference at each end.d3.curveCatmullRomClosed - a closed cubic Catmull–Rom spline.d3.curveCatmullRomOpen - a cubic Catmull–Rom spline.catmullRom.alpha - set the Catmull–Rom parameter alpha.d3.curveLinear - a polyline.d3.curveLinearClosed - a closed polyline.d3.curveMonotoneX - a cubic spline that, given monotonicity in x, preserves it in y.d3.curveMonotoneY - a cubic spline that, given monotonicity in y, preserves it in x.d3.curveNatural - a natural cubic spline.d3.curveStep - a piecewise constant function.d3.curveStepAfter - a piecewise constant function.d3.curveStepBefore - a piecewise constant function.curve.areaStart - start a new area segment.curve.areaEnd - end the current area segment.curve.lineStart - start a new line segment.curve.lineEnd - end the current line segment.curve.point - add a point to the current line segment.Links ​A smooth cubic Bézier curve from a source to a target.d3.link - create a new link generator.d3.linkVertical - create a new vertical link generator.d3.linkHorizontal - create a new horizontal link generator.link - generate a link.link.source - set the source accessor.link.target - set the target accessor.link.x - set the point x-accessor.link.y - set the point y-accessor.link.context - set the rendering context.link.digits - set the output precision.d3.linkRadial - create a new radial link generator.linkRadial.angle - set the point angle accessor.linkRadial.radius - set the point radius accessor.Symbols ​A categorical shape encoding, as in a scatterplot.d3.symbol - create a new symbol generator.symbol - generate a symbol for the given datum.symbol.type - set the symbol type.symbol.size - set the size of the symbol in square pixels.symbol.context - set the rendering context.symbol.digits - set the output precision.d3.symbolsFill - an array of built-in symbol types for filling.d3.symbolsStroke - an array of built-in symbol types for stroking.d3.symbolAsterisk - an asterisk; for stroke.d3.symbolCircle - a circle; for fill or stroke.d3.symbolCross - a Greek cross with arms of equal length; for fill.d3.symbolDiamond - a rhombus; for fill.d3.symbolDiamond2 - a rotated square; for stroke.d3.symbolPlus - a plus sign; for stroke.d3.symbolSquare - a square; for fill.d3.symbolSquare2 - a square; for stroke.d3.symbolStar - a pentagonal star (pentagram); for fill.d3.symbolTriangle - an up-pointing triangle; for fill.d3.symbolTriangle2 - an up-pointing triangle; for stroke.d3.symbolWye - a Y shape; for fill.d3.pointRadial - relative coordinates of a point given an angle and radius.symbolType.draw - draw this symbol to the given context.Stacks ​Stack shapes, placing one adjacent to another, as in a stacked bar chart.d3.stack - create a new stack generator.stack - generate a stack for the given dataset.stack.keys - set the keys accessor.stack.value - set the value accessor.stack.order - set the order accessor.stack.offset - set the offset accessor.d3.stackOrderAppearance - put the earliest series on bottom.d3.stackOrderAscending - put the smallest series on bottom.d3.stackOrderDescending - put the largest series on bottom.d3.stackOrderInsideOut - put earlier series in the middle.d3.stackOrderNone - use the given series order.d3.stackOrderReverse - use the reverse of the given series order.d3.stackOffsetExpand - normalize the baseline to zero and topline to one.d3.stackOffsetDiverging - positive above zero; negative below zero.d3.stackOffsetNone - apply a zero baseline.d3.stackOffsetSilhouette - center the streamgraph around zero.d3.stackOffsetWiggle - minimize streamgraph wiggling.d3-time ​A calculator for humanity’s peculiar conventions of time.d3.timeInterval - implement a new custom time interval.interval - alias for interval.floor.interval.floor - round down to the nearest boundary.interval.round - round to the nearest boundary.interval.ceil - round up to the nearest boundary.interval.offset - offset a date by some number of intervals.interval.range - generate a range of dates at interval boundaries.interval.filter - create a filtered subset of this interval.interval.every - create a filtered subset of this interval.interval.count - count interval boundaries between two dates.d3.timeMillisecond - the millisecond interval, local time.d3.timeSecond - the second interval, local time.d3.timeMinute - the minute interval, local time.d3.timeHour - the hour interval, local time.d3.timeDay - the day interval, local time.d3.timeWeek - the Sunday-based week interval, local time.d3.timeSunday - the Sunday-based week interval, local time.d3.timeMonday - the Monday-based week interval, local time.d3.timeTuesday - the Tuesday-based week interval, local time.d3.timeWednesday - the Wednesday-based week interval, local time.d3.timeThursday - the Thursday-based week interval, local time.d3.timeFriday - the Friday-based week interval, local time.d3.timeSaturday - the Saturday-based week interval, local time.d3.timeMonth - the month interval, local time.d3.timeYear - the year interval, local time.d3.utcMillisecond - the millisecond interval, UTC time.d3.utcSecond - the second interval, UTC time.d3.utcMinute - the minute interval, UTC time.d3.utcHour - the hour interval, UTC time.d3.utcDay - the day interval, UTC time.d3.utcWeek - the Sunday-based week interval, UTC time.d3.utcSunday - the Sunday-based week interval, UTC time.d3.utcMonday - the Monday-based week interval, UTC time.d3.utcTuesday - the Tuesday-based week interval, UTC time.d3.utcWednesday - the Wednesday-based week interval, UTC time.d3.utcThursday - the Thursday-based week interval, UTC time.d3.utcFriday - the Friday-based week interval, UTC time.d3.utcSaturday - the Saturday-based week interval, UTC time.d3.utcMonth - the month interval, UTC time.d3.utcYear - the year interval, UTC time.d3.unixDay - the day interval, UTC time, not month-aligned.d3.timeMilliseconds - alias for d3.timeMillisecond.range.d3.timeSeconds - alias for d3.timeSecond.range.d3.timeMinutes - alias for d3.timeMinute.range.d3.timeHours - alias for d3.timeHour.range.d3.timeDays - alias for d3.timeDay.range.d3.timeWeeks - alias for d3.timeWeek.range.d3.timeSundays - alias for d3.timeSunday.range.d3.timeMondays - alias for d3.timeMonday.range.d3.timeTuesdays - alias for d3.timeTuesday.range.d3.timeWednesdays - alias for d3.timeWednesday.range.d3.timeThursdays - alias for d3.timeThursday.range.d3.timeFridays - alias for d3.timeFriday.range.d3.timeSaturdays - alias for d3.timeSaturday.range.d3.timeMonths - alias for d3.timeMonth.range.d3.timeYears - alias for d3.timeYear.range.d3.utcMilliseconds - alias for d3.utcMillisecond.range.d3.utcSeconds - alias for d3.utcSecond.range.d3.utcMinutes - alias for d3.utcMinute.range.d3.utcHours - alias for d3.utcHour.range.d3.utcDays - alias for d3.utcDay.range.d3.utcWeeks - alias for d3.utcWeek.range.d3.utcSundays - alias for d3.utcSunday.range.d3.utcMondays - alias for d3.utcMonday.range.d3.utcTuesdays - alias for d3.utcTuesday.range.d3.utcWednesdays - alias for d3.utcWednesday.range.d3.utcThursdays - alias for d3.utcThursday.range.d3.utcFridays - alias for d3.utcFriday.range.d3.utcSaturdays - alias for d3.utcSaturday.range.d3.utcMonths - alias for d3.utcMonth.range.d3.utcYears - alias for d3.utcYear.range.d3.unixDays - alias for d3.unixDay.range.d3.timeTicks - generate representative values from a time interval.d3.utcTicks - generate representative values from a time interval.d3.timeTickInterval - generate representative values from a time interval.d3.utcTickInterval - generate representative values from a time interval.d3-time-format ​Parse and format times, inspired by strptime and strftime.d3.timeFormat - alias for locale.format on the default locale.d3.timeParse - alias for locale.parse on the default locale.d3.utcFormat - alias for locale.utcFormat on the default locale.d3.utcParse - alias for locale.utcParse on the default locale.d3.isoFormat - an ISO 8601 UTC formatter.d3.isoParse - an ISO 8601 UTC parser.locale.format - create a time formatter.locale.parse - create a time parser.locale.utcFormat - create a UTC formatter.locale.utcParse - create a UTC parser.d3.timeFormatLocale - define a custom locale.d3.timeFormatDefaultLocale - define the default locale.d3-timer ​An efficient queue for managing thousands of concurrent animations.d3.now - get the current high-resolution time.d3.timer - schedule a new timer.timer.restart - reset the timer’s start time and callback.timer.stop - stop the timer.d3.timerFlush - immediately execute any eligible timers.d3.timeout - schedule a timer that stops on its first callback.d3.interval - schedule a timer that is called with a configurable period.d3-transition ​Animated transitions for selections.selection.transition - schedule a transition for the selected elements.selection.interrupt - interrupt and cancel transitions on the selected elements.d3.interrupt - interrupt the active transition for a given node.d3.transition - schedule a transition on the root document element.transition.select - schedule a transition on the selected elements.transition.selectAll - schedule a transition on the selected elements.transition.selectChild - select a child element for each selected element.transition.selectChildren - select the children elements for each selected element.transition.selection - returns a selection for this transition.transition.filter - filter elements based on data.transition.merge - merge this transition with another.transition.transition - schedule a new transition following this one.d3.active - select the active transition for a given node.transition.attr - tween the given attribute using the default interpolator.transition.attrTween - tween the given attribute using a custom interpolator.transition.style - tween the given style property using the default interpolator.transition.styleTween - tween the given style property using a custom interpolator.transition.text - set the text content when the transition starts.transition.textTween - tween the text using a custom interpolator.transition.remove - remove the selected elements when the transition ends.transition.tween - run custom code during the transition.transition.delay - specify per-element delay in milliseconds.transition.duration - specify per-element duration in milliseconds.transition.ease - specify the easing function.transition.easeVarying - specify an easing function factory.transition.end - a promise that resolves when a transition ends.transition.on - await the end of a transition.transition.each - call a function for each element.transition.call - call a function with this transition.transition.empty - returns true if this transition is empty.transition.nodes - returns an array of all selected elements.transition.node - returns the first (non-null) element.transition.size - returns the count of elements.d3-zoom ​Pan and zoom SVG, HTML or Canvas using mouse or touch input.d3.zoom - create a zoom behavior.zoom - apply the zoom behavior to the selected elements.zoom.transform - change the transform for the selected elements.zoom.translateBy - translate the transform for the selected elements.zoom.translateTo - translate the transform for the selected elements.zoom.scaleBy - scale the transform for the selected elements.zoom.scaleTo - scale the transform for the selected elements.zoom.constrain - override the transform constraint logic.zoom.filter - control which input events initiate zooming.zoom.touchable - set the touch support detector.zoom.wheelDelta - override scaling for wheel events.zoom.extent - set the extent of the viewport.zoom.scaleExtent - set the allowed scale range.zoom.translateExtent - set the extent of the zoomable world.zoom.clickDistance - set the click distance threshold.zoom.tapDistance - set the tap distance threshold.zoom.duration - set the duration of zoom transitions.zoom.interpolate - control the interpolation of zoom transitions.zoom.on - listen for zoom events.d3.zoomTransform - get the zoom transform for a given element.transform.scale - scale a transform by the specified amount.transform.translate - translate a transform by the specified amount.transform.apply - apply the transform to the given point.transform.applyX - apply the transform to the given x-coordinate.transform.applyY - apply the transform to the given y coordinate.transform.invert - unapply the transform to the given point.transform.invertX - unapply the transform to the given x-coordinate.transform.invertY - unapply the transform to the given y coordinate.transform.rescaleX - apply the transform to an x scale’s domain.transform.rescaleY - apply the transform to a y scale’s domain.transform.toString - format the transform as an SVG transform string.d3.zoomIdentity - the identity transform.PagerPrevious pageGetting started\n\nAPI index ​D3 is a collection of modules that are designed to work together; you can use the modules independently, or you can use them together as part of the default build.d3-array ​Array manipulation, ordering, searching, summarizing, etc.Add ​Add floating point values with full precision.new Adder - create a full precision adder.adder.add - add a value to an adder.adder.valueOf - get the double-precision representation of an adder’s value.fcumsum - compute a full precision cumulative summation of numbers.fsum - compute a full precision summation of an iterable of numbers.Bin ​Bin discrete samples into continuous, non-overlapping intervals.bin - create a new bin generator.bin - bins a given array of samples.bin.value - specify a value accessor for each sample.bin.domain - specify the interval of observable values.bin.thresholds - specify how values are divided into bins.thresholdFreedmanDiaconis - the Freedman–Diaconis binning rule.thresholdScott - Scott’s normal reference binning rule.thresholdSturges - Sturges’ binning formula.Bisect ​Quickly find a value in a sorted array.bisector - bisect using an accessor or comparator.bisector.right - bisectRight, with the given comparator.bisector.left - bisectLeft, with the given comparator.bisector.center - binary search for a value in a sorted array.bisect - binary search for a value in a sorted array.bisectRight - binary search for a value in a sorted array.bisectLeft - binary search for a value in a sorted array.bisectCenter - binary search for a value in a sorted array.Blur ​Blur quantitative values in one or two dimensions.d3.blur - blur an array of numbers in place.d3.blur2 - blur a two-dimensional array of numbers in place.d3.blurImage - blur an RGBA ImageData in place.Group ​Group discrete values.d3.group - group an iterable into a nested Map.d3.groups - group an iterable into a nested array.d3.rollup - reduce an iterable into a nested Map.d3.rollups - reduce an iterable into a nested array.d3.index - index an iterable into a nested Map.d3.indexes - index an iterable into a nested array.d3.flatGroup - group an iterable into a flat array.d3.flatRollup - reduce an iterable into a flat array.d3.groupSort - sort keys according to grouped values.Intern ​Create maps and sets with non-primitive values such as dates.new InternMap - a key-interning Map.new InternSet - a value-interning Set.Sets ​Logical operations on sets.d3.difference - compute a set difference.d3.disjoint - test whether two sets are disjoint.d3.intersection - compute a set intersection.d3.superset - test whether a set is a superset of another.d3.subset - test whether a set is a subset of another.d3.union - compute a set union.Sort ​Sort and reorder arrays of values.d3.ascending - compute the natural order of two values.d3.descending - compute the natural order of two values.d3.permute - reorder an iterable of elements according to an iterable of indexes.d3.quickselect - reorder an array of numbers.d3.reverse - reverse the order of values.d3.shuffle - randomize the order of an iterable.d3.shuffler - randomize the order of an iterable.d3.sort - sort values.Summarize ​Compute summary statistics.d3.count - count valid number values in an iterable.d3.min - compute the minimum value in an iterable.d3.minIndex - compute the index of the minimum value in an iterable.d3.max - compute the maximum value in an iterable.d3.maxIndex - compute the index of the maximum value in an iterable.d3.least - returns the least element of an iterable.d3.leastIndex - returns the index of the least element of an iterable.d3.greatest - returns the greatest element of an iterable.d3.greatestIndex - returns the index of the greatest element of an iterable.d3.extent - compute the minimum and maximum value in an iterable.d3.mode - compute the mode (the most common value) of an iterable of numbers.d3.sum - compute the sum of an iterable of numbers.d3.mean - compute the arithmetic mean of an iterable of numbers.d3.median - compute the median of an iterable of numbers (the 0.5-quantile).d3.medianIndex - compute the median index of an iterable of numbers (the 0.5-quantile).d3.cumsum - compute the cumulative sum of an iterable.d3.quantile - compute a quantile for an iterable of numbers.d3.quantileIndex - compute a quantile index for an iterable of numbers.d3.quantileSorted - compute a quantile for a sorted array of numbers.d3.rank - compute the rank order of an iterable.d3.variance - compute the variance of an iterable of numbers.d3.deviation - compute the standard deviation of an iterable of numbers.d3.every - test if all values satisfy a condition.d3.some - test if any value satisfies a condition.Ticks ​Generate representative values from a continuous interval.d3.ticks - generate representative values from a numeric interval.d3.tickIncrement - generate representative values from a numeric interval.d3.tickStep - generate representative values from a numeric interval.d3.nice - extend an interval to align with ticks.d3.range - generate a range of numeric values.Transform ​Derive new arrays.d3.cross - compute the Cartesian product of two iterables.d3.merge - merge multiple iterables into one array.d3.pairs - create an array of adjacent pairs of elements.d3.transpose - transpose an array of arrays.d3.zip - transpose a variable number of arrays.d3.filter - filter values.d3.map - map values.d3.reduce - reduce values.d3-axis ​Human-readable reference marks for scales.d3.axisTop - create a new top-oriented axis generator.d3.axisRight - create a new right-oriented axis generator.d3.axisBottom - create a new bottom-oriented axis generator.d3.axisLeft - create a new left-oriented axis generator.axis - generate an axis for the given selection.axis.scale - set the scale.axis.ticks - customize how ticks are generated and formatted.axis.tickArguments - customize how ticks are generated and formatted.axis.tickValues - set the tick values explicitly.axis.tickFormat - set the tick format explicitly.axis.tickSize - set the size of the ticks.axis.tickSizeInner - set the size of inner ticks.axis.tickSizeOuter - set the size of outer (extent) ticks.axis.tickPadding - set the padding between ticks and labels.axis.offset - set the pixel offset for crisp edges.d3-brush ​Select a one- or two-dimensional region using the mouse or touch.d3.brush - create a new two-dimensional brush.d3.brushX - create a brush along the x-dimension.d3.brushY - create a brush along the y-dimension.brush - apply the brush to a selection.brush.move - move the brush selection.brush.clear - clear the brush selection.brush.extent - define the brushable region.brush.filter - control which input events initiate brushing.brush.touchable - set the touch support detector.brush.keyModifiers - enable or disable key interaction.brush.handleSize - set the size of the brush handles.brush.on - listen for brush events.d3.brushSelection - get the brush selection for a given node.d3-chord ​d3.chord - create a new chord layout.chord - compute the layout for the given matrix.chord.padAngle - set the padding between adjacent groups.chord.sortGroups - define the group order.chord.sortSubgroups - define the source and target order within groups.chord.sortChords - define the chord order across groups.d3.chordDirected - create a directed chord generator.d3.chordTranspose - create a transposed chord generator.d3.ribbon - create a ribbon shape generator.ribbon - generate a ribbon shape.ribbon.source - set the source accessor.ribbon.target - set the target accessor.ribbon.radius - set the ribbon source and target radius.ribbon.sourceRadius - set the ribbon source radius.ribbon.targetRadius - set the ribbon target radius.ribbon.startAngle - set the ribbon source or target start angle.ribbon.endAngle - set the ribbon source or target end angle.ribbon.padAngle - set the pad angle accessor.ribbon.context - set the render context.d3.ribbonArrow - create an arrow ribbon generator.ribbonArrow.headRadius - set the arrowhead radius accessor.d3-color ​Color manipulation and color space conversion.d3.color - parse the given CSS color specifier.color.opacity - the color’s opacity.color.rgb - compute the RGB equivalent of this color.color.copy - return a copy of this color.color.brighter - create a brighter copy of this color.color.darker - create a darker copy of this color.color.displayable - returns true if the color is displayable on standard hardware.color.formatHex - returns the hexadecimal RRGGBB string representation of this color.color.formatHex8 - returns the hexadecimal RRGGBBAA string representation of this color.color.formatHsl - returns the RGB string representation of this color.color.formatRgb - returns the HSL string representation of this color.color.toString - returns the RGB string representation of this color.d3.rgb - create a new RGB color.rgb.clamp - returns copy of this color clamped to the RGB color space.d3.hsl - create a new HSL color.hsl.clamp - returns copy of this color clamped to the HSL color space.d3.lab - create a new Lab color.d3.gray - create a new Lab gray.d3.hcl - create a new HCL color.d3.lch - create a new HCL color.d3.cubehelix - create a new Cubehelix color.d3-contour ​Compute contour polygons using marching squares.d3.contours - create a new contour generator.contours - compute the contours for a given grid of values.contours.contour - compute a contour for a given value.contours.size - set the size of a contour generator.contours.smooth - set whether or not the generated contours are smoothed.contours.thresholds - set the thresholds of a contour generator.d3.contourDensity - create a new density estimator.density - estimate the density of a given array of samples.density.x - set the x accessor of the density estimator.density.y - set the y accessor of the density estimator.density.weight - set the weight accessor of the density estimator.density.size - set the size of the density estimator.density.cellSize - set the cell size of the density estimator.density.thresholds - set the thresholds of the density estimator.density.bandwidth - set the bandwidth of the density estimator.density.contours - compute density contours.d3-delaunay ​Compute the Voronoi diagram of a set of two-dimensional points.new Delaunay - create a delaunay triangulation for an array of point coordinates.Delaunay.from - create a delaunay triangulation for an iterable of points.delaunay.points - the coordinates of the points.delaunay.halfedges - the delaunay halfedges.delaunay.hull - the convex hull as point indices.delaunay.triangles - the delaunay triangles.delaunay.inedges - the delaunay inedgesdelaunay.find - find the closest point in the delaunay triangulation.delaunay.neighbors - the neighbors of a point in the delaunay triangulation.delaunay.render - render the edges of the delaunay triangulation.delaunay.renderHull - render the convex hull.delaunay.renderTriangle - render a triangle.delaunay.renderPoints - render the points.delaunay.hullPolygon - the closed convex hull as point coordinates.delaunay.trianglePolygons - iterate over all the triangles as polygons.delaunay.trianglePolygon - return a triangle as a polygon.delaunay.update - update a delaunay triangulation in place.delaunay.voronoi - compute the voronoi diagram associated with a delaunay triangulation.voronoi.delaunay - the voronoi diagram’s source delaunay triangulation.voronoi.circumcenters - the triangles’ circumcenters.voronoi.vectors - directions for the outer (infinite) cells of the voronoi diagram.voronoi.xmin - set the xmin bound of the extent.voronoi.ymin - set the ymin bound of the extent.voronoi.xmax - set the xmax bound of the extent.voronoi.ymax - set the ymax bound of the extent.voronoi.contains - test whether a point is inside a voronoi cell.voronoi.neighbors - the neighbors of a point in the voronoi diagram.voronoi.render - render the mesh of voronoi cells.voronoi.renderBounds - render the extent.voronoi.renderCell - render a voronoi cell.voronoi.cellPolygons - iterate over all the cells as polygons.voronoi.cellPolygon - return a cell as a polygon.voronoi.update - update a voronoi diagram in place.d3-dispatch ​Separate concerns using named callbacks.d3.dispatch - create a custom event dispatcher.dispatch.on - register or unregister an event listener.dispatch.copy - create a copy of a dispatcher.dispatch.call - dispatch an event to registered listeners.dispatch.apply - dispatch an event to registered listeners.d3-drag ​Drag and drop SVG, HTML or Canvas using mouse or touch input.d3.drag - create a drag behavior.drag - apply the drag behavior to a selection.drag.container - set the coordinate system.drag.filter - ignore some initiating input events.drag.touchable - set the touch support detector.drag.subject - set the thing being dragged.drag.clickDistance - set the click distance threshold.drag.on - listen for drag events.d3.dragDisable - prevent native drag-and-drop and text selection.d3.dragEnable - enable native drag-and-drop and text selection.event.on - listen for drag events on the current gesture.d3-dsv ​Parse and format delimiter-separated values, most commonly CSV and TSV.d3.csvParse - parse the given CSV string, returning an array of objects.d3.csvParseRows - parse the given CSV string, returning an array of rows.d3.csvFormat - format the given array of objects as CSV.d3.csvFormatBody - format the given array of objects as CSV.d3.csvFormatRows - format the given array of rows as CSV.d3.csvFormatRow - format the given row as CSV.d3.csvFormatValue - format the given value as CSV.d3.tsvParse - parse the given TSV string, returning an array of objects.d3.tsvParseRows - parse the given TSV string, returning an array of rows.d3.tsvFormat - format the given array of objects as TSV.d3.tsvFormatBody - format the given array of objects as TSV.d3.tsvFormatRows - format the given array of rows as TSV.d3.tsvFormatRow - format the given row as TSV.d3.tsvFormatValue - format the given value as TSV.d3.dsvFormat - create a new parser and formatter for the given delimiter.dsv.parse - parse the given string, returning an array of objects.dsv.parseRows - parse the given string, returning an array of rows.dsv.format - format the given array of objects.dsv.formatBody - format the given array of objects.dsv.formatRows - format the given array of rows.dsv.formatRow - format the given row.dsv.formatValue - format the given value.d3.autoType - automatically infer value types for the given object.d3-ease ​Easing functions for smooth animation.ease - ease the given normalized time.d3.easeLinear - linear easing; the identity function.d3.easePolyIn - polynomial easing; raises time to the given power.d3.easePolyOut - reverse polynomial easing.d3.easePoly - an alias for easePolyInOut.d3.easePolyInOut - symmetric polynomial easing.poly.exponent - specify the polynomial exponent.d3.easeQuadIn - quadratic easing; squares time.d3.easeQuadOut - reverse quadratic easing.d3.easeQuad - an alias for easeQuadInOut.d3.easeQuadInOut - symmetric quadratic easing.d3.easeCubicIn - cubic easing; cubes time.d3.easeCubicOut - reverse cubic easing.d3.easeCubic - an alias for easeCubicInOut.d3.easeCubicInOut - symmetric cubic easing.d3.easeSinIn - sinusoidal easing.d3.easeSinOut - reverse sinusoidal easing.d3.easeSin - an alias for easeSinInOut.d3.easeSinInOut - symmetric sinusoidal easing.d3.easeExpIn - exponential easing.d3.easeExpOut - reverse exponential easing.d3.easeExp - an alias for easeExpInOut.d3.easeExpInOut - symmetric exponential easing.d3.easeCircleIn - circular easing.d3.easeCircleOut - reverse circular easing.d3.easeCircle - an alias for easeCircleInOut.d3.easeCircleInOut - symmetric circular easing.d3.easeElasticIn - elastic easing, like a rubber band.d3.easeElastic - an alias for easeElasticOut.d3.easeElasticOut - reverse elastic easing.d3.easeElasticInOut - symmetric elastic easing.elastic.amplitude - specify the elastic amplitude.elastic.period - specify the elastic period.d3.easeBackIn - anticipatory easing, like a dancer bending his knees before jumping.d3.easeBackOut - reverse anticipatory easing.d3.easeBack - an alias for easeBackInOut.d3.easeBackInOut - symmetric anticipatory easing.back.overshoot - specify the amount of overshoot.d3.easeBounceIn - bounce easing, like a rubber ball.d3.easeBounce - an alias for easeBounceOut.d3.easeBounceOut - reverse bounce easing.d3.easeBounceInOut - symmetric bounce easing.d3-fetch ​Convenience methods on top of the Fetch API.d3.blob - get a file as a blob.d3.buffer - get a file as an array buffer.d3.csv - get a comma-separated values (CSV) file.d3.dsv - get a delimiter-separated values (CSV) file.d3.html - get an HTML file.d3.image - get an image.d3.json - get a JSON file.d3.svg - get an SVG file.d3.text - get a plain text file.d3.tsv - get a tab-separated values (TSV) file.d3.xml - get an XML file.d3-force ​Force-directed graph layout using velocity Verlet integration.d3.forceSimulation - create a new force simulation.simulation.restart - reheat and restart the simulation’s timer.simulation.stop - stop the simulation’s timer.simulation.tick - advance the simulation one step.simulation.nodes - set the simulation’s nodes.simulation.alpha - set the current alpha.simulation.alphaMin - set the minimum alpha threshold.simulation.alphaDecay - set the alpha exponential decay rate.simulation.alphaTarget - set the target alpha.simulation.velocityDecay - set the velocity decay rate.simulation.force - add or remove a force.simulation.find - find the closest node to the given position.simulation.randomSource - set the simulation’s random source.simulation.on - add or remove an event listener.force - apply the force.force.initialize - initialize the force with the given nodes.d3.forceCenter - create a centering force.center.x - set the center x-coordinate.center.y - set the center y coordinate.center.strength - set the strength of the centering force.d3.forceCollide - create a circle collision force.collide.radius - set the circle radius.collide.strength - set the collision resolution strength.collide.iterations - set the number of iterations.d3.forceLink - create a link force.link.links - set the array of links.link.id - link nodes by numeric index or string identifier.link.distance - set the link distance.link.strength - set the link strength.link.iterations - set the number of iterations.d3.forceManyBody - create a many-body force.manyBody.strength - set the force strength.manyBody.theta - set the Barnes–Hut approximation accuracy.manyBody.distanceMin - limit the force when nodes are close.manyBody.distanceMax - limit the force when nodes are far.d3.forceX - create an x-positioning force.x.strength - set the force strength.x.x - set the target x-coordinate.d3.forceY - create an y-positioning force.y.strength - set the force strength.y.y - set the target y coordinate.d3.forceRadial - create a radial positioning force.radial.strength - set the force strength.radial.radius - set the target radius.radial.x - set the target center x-coordinate.radial.y - set the target center y coordinate.d3-format ​Format numbers for human consumption.d3.format - alias for locale.format on the default locale.d3.formatPrefix - alias for locale.formatPrefix on the default locale.locale.format - create a number format.locale.formatPrefix - create a SI-prefix number format.d3.formatSpecifier - parse a number format specifier.new d3.FormatSpecifier - augments a number format specifier object.d3.precisionFixed - compute decimal precision for fixed-point notation.d3.precisionPrefix - compute decimal precision for SI-prefix notation.d3.precisionRound - compute significant digits for rounded notation.d3.formatLocale - define a custom locale.d3.formatDefaultLocale - define the default locale.d3-geo ​Geographic projections, shapes and math.Paths ​d3.geoPath - create a new geographic path generator.path - project and render the specified feature.path.area - compute the projected planar area of a given feature.path.bounds - compute the projected planar bounding box of a given feature.path.centroid - compute the projected planar centroid of a given feature.path.digits - set the output precision.path.measure - compute the projected planar length of a given feature.path.projection - set the geographic projection.path.context - set the render context.path.pointRadius - set the radius to display point features.Projections ​projection - project the specified point from the sphere to the plane.projection.invert - unproject the specified point from the plane to the sphere.projection.stream - wrap the specified stream to project geometry.projection.preclip - set the projection’s spherical clipping function.projection.postclip - set the projection’s cartesian clipping function.projection.clipAngle - set the radius of the clip circle.projection.clipExtent - set the viewport clip extent, in pixels.projection.scale - set the scale factor.projection.translate - set the translation offset.projection.center - set the center point.projection.angle - set the post-projection rotation.projection.reflectX - reflect the x-dimension.projection.reflectY - reflect the y-dimension.projection.rotate - set the three-axis spherical rotation angles.projection.precision - set the precision threshold for adaptive sampling.projection.fitExtent - set the scale and translate to fit a GeoJSON object.projection.fitSize - set the scale and translate to fit a GeoJSON object.projection.fitWidth - set the scale and translate to fit a GeoJSON object.projection.fitHeight - set the scale and translate to fit a GeoJSON object.Raw projections ​project - project the specified point from the sphere to the plane.project.invert - unproject the specified point from the plane to the sphere.d3.geoProjection - create a custom projection.d3.geoProjectionMutator - create a custom configurable projection.d3.geoTransform - define a custom geometry transform.d3.geoIdentity - scale, translate or clip planar geometry.d3.geoClipAntimeridian - cuts spherical geometries that cross the antimeridian.d3.geoClipCircle - clips spherical geometries to a small circle.d3.geoClipRectangle - clips planar geometries to a rectangular viewport.Azimuthal projections ​d3.geoAzimuthalEqualArea - the azimuthal equal-area projection.d3.geoAzimuthalEquidistant - the azimuthal equidistant projection.d3.geoGnomonic - the gnomonic projection.d3.geoOrthographic - the azimuthal orthographic projection.d3.geoStereographic - the azimuthal stereographic projection.Conic projections ​conic.parallels - set the two standard parallels.d3.geoConicConformal - the conic conformal projection.d3.geoConicEqualArea - the conic equal-area (Albers) projection.d3.geoConicEquidistant - the conic equidistant projection.d3.geoAlbers - the Albers equal-area conic projection.d3.geoAlbersUsa - a composite Albers projection for the United States.Cylindrical projections ​d3.geoEquirectangular - the equirectangular (plate carreé) projection.d3.geoMercator - the spherical Mercator projection.d3.geoTransverseMercator - the transverse spherical Mercator projection.d3.geoEqualEarth - the Equal Earth projection.d3.geoNaturalEarth1 - the Equal Earth projection, version 1.Streams ​d3.geoStream - convert a GeoJSON object to a geometry stream.stream.point - indicates a point with the specified coordinates.stream.lineStart - indicates the start of a line or ring.stream.lineEnd - indicates the end of a line or ring.stream.polygonStart - indicates the start of a polygon.stream.polygonEnd - indicates the end of a polygon.stream.sphere - indicates the sphere.Spherical shapes ​d3.geoGraticule - create a graticule generator.graticule - generate a MultiLineString of meridians and parallels.graticule.lines - generate an array of LineStrings of meridians and parallels.graticule.outline - generate a Polygon of the graticule’s extent.graticule.extent - get or set the major & minor extents.graticule.extentMajor - get or set the major extent.graticule.extentMinor - get or set the minor extent.graticule.step - get or set the major & minor step intervals.graticule.stepMajor - get or set the major step intervals.graticule.stepMinor - get or set the minor step intervals.graticule.precision - get or set the latitudinal precision.d3.geoGraticule10 - generate the default 10° global graticule.d3.geoCircle - create a circle generator.circle - generate a piecewise circle as a Polygon.circle.center - specify the circle center in latitude and longitude.circle.radius - specify the angular radius in degrees.circle.precision - specify the precision of the piecewise circle.Spherical math ​d3.geoArea - compute the spherical area of a given feature.d3.geoBounds - compute the latitude-longitude bounding box for a given feature.d3.geoCentroid - compute the spherical centroid of a given feature.d3.geoDistance - compute the great-arc distance between two points.d3.geoLength - compute the length of a line string or the perimeter of a polygon.d3.geoInterpolate - interpolate between two points along a great arc.d3.geoContains - test whether a point is inside a given feature.d3.geoRotation - create a rotation function for the specified angles.d3-hierarchy ​Layout algorithms for visualizing hierarchical data.d3.hierarchy - constructs a root node from hierarchical data.node.ancestors - generate an array of ancestors.node.descendants - generate an array of descendants.node.leaves - generate an array of leaves.node.find - find a node in the hierarchy.node.path - generate the shortest path to another node.node.links - generate an array of links.node.sum - evaluate and aggregate quantitative values.node.count - count the number of leaves.node.sort - sort all descendant siblings.node[Symbol.iterator] - iterate on a hierarchy.node.each - breadth-first traversal.node.eachAfter - post-order traversal.node.eachBefore - pre-order traversal.node.copy - copy a hierarchy.d3.stratify - create a new stratify operator.stratify - construct a root node from tabular data.stratify.id - set the node id accessor.stratify.parentId - set the parent node id accessor.stratify.path - set the path accessor.d3.cluster - create a new cluster (dendrogram) layout.cluster - layout the specified hierarchy in a dendrogram.cluster.size - set the layout size.cluster.nodeSize - set the node size.cluster.separation - set the separation between leaves.d3.tree - create a new tidy tree layout.tree - layout the specified hierarchy in a tidy tree.tree.size - set the layout size.tree.nodeSize - set the node size.tree.separation - set the separation between nodes.d3.treemap - create a new treemap layout.treemap - layout the specified hierarchy as a treemap.treemap.tile - set the tiling method.treemap.size - set the layout size.treemap.round - set whether the output coordinates are rounded.treemap.padding - set the padding.treemap.paddingInner - set the padding between siblings.treemap.paddingOuter - set the padding between parent and children.treemap.paddingTop - set the padding between the parent’s top edge and children.treemap.paddingRight - set the padding between the parent’s right edge and children.treemap.paddingBottom - set the padding between the parent’s bottom edge and children.treemap.paddingLeft - set the padding between the parent’s left edge and children.d3.treemapBinary - tile using a balanced binary tree.d3.treemapDice - tile into a horizontal row.d3.treemapSlice - tile into a vertical column.d3.treemapSliceDice - alternate between slicing and dicing.d3.treemapSquarify - tile using squarified rows per Bruls et. al.d3.treemapResquarify - like d3.treemapSquarify, but performs stable updates.squarify.ratio - set the desired rectangle aspect ratio.d3.partition - create a new partition (icicle or sunburst) layout.partition - layout the specified hierarchy as a partition diagram.partition.size - set the layout size.partition.round - set whether the output coordinates are rounded.partition.padding - set the padding.d3.pack - create a new circle-packing layout.pack - layout the specified hierarchy using circle-packing.pack.radius - set the radius accessor.pack.size - set the layout size.pack.padding - set the padding.d3.packSiblings - pack the specified array of circles.d3.packEnclose - enclose the specified array of circles.d3-interpolate ​Interpolate numbers, colors, strings, arrays, objects, whatever!Value interpolation ​d3.interpolate - interpolate arbitrary values.d3.interpolateNumber - interpolate numbers.d3.interpolateRound - interpolate integers.d3.interpolateString - interpolate strings with embedded numbers.d3.interpolateDate - interpolate dates.d3.interpolateArray - interpolate arrays of arbitrary values.d3.interpolateNumberArray - interpolate arrays of numbers.d3.interpolateObject - interpolate arbitrary objects.d3.interpolateBasis - generate a B-spline through a set of values.d3.interpolateBasisClosed - generate a closed B-spline through a set of values.d3.interpolateDiscrete - generate a discrete interpolator from a set of values.d3.quantize - generate uniformly-spaced samples from an interpolator.d3.piecewise - generate a piecewise linear interpolator from a set of values.Color interpolation ​d3.interpolateRgb - interpolate RGB colors.d3.interpolateRgbBasis - generate a B-spline through a set of colors.d3.interpolateRgbBasisClosed - generate a closed B-spline through a set of colors.d3.interpolateHsl - interpolate HSL colors.d3.interpolateHslLong - interpolate HSL colors, the long way.d3.interpolateLab - interpolate Lab colors.d3.interpolateHcl - interpolate HCL colors.d3.interpolateHclLong - interpolate HCL colors, the long way.d3.interpolateCubehelix - interpolate Cubehelix colors.d3.interpolateCubehelixLong - interpolate Cubehelix colors, the long way.interpolateColor.gamma - apply gamma correction during interpolation.d3.interpolateHue - interpolate a hue angle.Transform interpolation ​d3.interpolateTransformCss - interpolate 2D CSS transforms.d3.interpolateTransformSvg - interpolate 2D SVG transforms.Zoom interpolation ​d3.interpolateZoom - zoom and pan between two views.interpolateZoom.rho - set the curvature rho of the zoom interpolator.d3-path ​Serialize Canvas path commands to SVG.d3.path - create a new path serializer.path.moveTo - move to the given point.path.closePath - close the current subpath.path.lineTo - draw a straight line segment.path.quadraticCurveTo - draw a quadratic Bézier segment.path.bezierCurveTo - draw a cubic Bézier segment.path.arcTo - draw a circular arc segment.path.arc - draw a circular arc segment.path.rect - draw a rectangle.path.toString - serialize to an SVG path data string.d3.pathRound - create a new path serializer with fixed output precision.d3-polygon ​Geometric operations for two-dimensional polygons.d3.polygonArea - compute the area of the given polygon.d3.polygonCentroid - compute the centroid of the given polygon.d3.polygonHull - compute the convex hull of the given points.d3.polygonContains - test whether a point is inside a polygon.d3.polygonLength - compute the length of the given polygon’s perimeter.d3-quadtree ​Two-dimensional recursive spatial subdivision.d3.quadtree - create a new, empty quadtree.quadtree.x - set the x accessor.quadtree.y - set the y accessor.quadtree.extent - extend the quadtree to cover an extent.quadtree.cover - extend the quadtree to cover a point.quadtree.add - add a datum to a quadtree.quadtree.addAll - add an array of data to a quadtree.quadtree.remove - remove a datum from a quadtree.quadtree.removeAll - remove an array of data from a quadtree.quadtree.copy - create a copy of a quadtree.quadtree.root - get the quadtree’s root node.quadtree.data - retrieve all data from the quadtree.quadtree.size - count the number of data in the quadtree.quadtree.find - quickly find the closest datum in a quadtree.quadtree.visit - selectively visit nodes in a quadtree.quadtree.visitAfter - visit all nodes in a quadtree.d3-random ​Generate random numbers from various distributions.d3.randomUniform - from a uniform distribution.d3.randomInt - from a uniform integer distribution.d3.randomNormal - from a normal distribution.d3.randomLogNormal - from a log-normal distribution.d3.randomBates - from a Bates distribution.d3.randomIrwinHall - from an Irwin–Hall distribution.d3.randomExponential - from an exponential distribution.d3.randomPareto - from a Pareto distribution.d3.randomBernoulli - from a Bernoulli distribution.d3.randomGeometric - from a geometric distribution.d3.randomBinomial - from a binomial distribution.d3.randomGamma - from a gamma distribution.d3.randomBeta - from a beta distribution.d3.randomWeibull - from a Weibull, Gumbel or Fréchet distribution.d3.randomCauchy - from a Cauchy distribution.d3.randomLogistic - from a logistic distribution.d3.randomPoisson - from a Poisson distribution.random.source - set the source of randomness.d3.randomLcg - a seeded pseudorandom number generator.d3-scale ​Encodings that map abstract data to visual representation.Linear scales ​Map a continuous, quantitative domain to a continuous range.d3.scaleLinear - create a quantitative linear scale.linear - compute the range value corresponding to a given domain value.linear.invert - compute the domain value corresponding to a given range value.linear.domain - set the input domain.linear.range - set the output range.linear.rangeRound - set the output range and enable rounding.linear.clamp - enable clamping to the domain or range.linear.unknown - set the output value for unknown inputs.linear.interpolate - set the output interpolator.linear.ticks - compute representative values from the domain.linear.tickFormat - format ticks for human consumption.linear.nice - extend the domain to nice round numbers.linear.copy - create a copy of this scale.d3.tickFormat - format ticks for human consumption.d3.scaleIdentity - creates an identity scale.d3.scaleRadial - creates a radial scale.Pow scales ​d3.scalePow - create a quantitative power scale.d3.scaleSqrt - create a quantitative power scale with exponent 0.5.pow.exponent - set the power exponent.Log scales ​d3.scaleLog - create a quantitative logarithmic scale.log.base - set the logarithm base.log.ticks - compute representative values from the domain.log.tickFormat - format ticks for human consumption.log.nice - extend the domain to nice round numbers.Symlog scales ​d3.scaleSymlog - create a symmetric logarithmic scale.symlog.constant - set the constant of a symlog scale.Time scales ​d3.scaleTime - create a linear scale for time.time.ticks - compute representative values from the domain.time.tickFormat - format ticks for human consumption.time.nice - extend the domain to nice round times.d3.scaleUtc - create a linear scale for UTC.Sequential scales ​Map a continuous, quantitative domain to a continuous, fixed interpolator.d3.scaleSequential - create a sequential scale.sequential.interpolator - set the scale’s output interpolator.sequential.range - set the output range.sequential.rangeRound - set the output range and enable rounding.d3.scaleSequentialLog - create a logarithmic sequential scale.d3.scaleSequentialPow - create a power sequential scale.d3.scaleSequentialSqrt - create a power sequential scale with exponent 0.5.d3.scaleSequentialSymlog - create a symmetric logarithmic sequential scale.d3.scaleSequentialQuantile - create a sequential scale using a p-quantile transform.sequentialQuantile.quantiles - return the scale’s quantiles.Diverging scales ​Map a continuous, quantitative domain to a continuous, fixed interpolator.d3.scaleDiverging - create a diverging scale.diverging.interpolator - set the scale’s output interpolator.diverging.range - set the output range.diverging.rangeRound - set the output range and enable rounding.d3.scaleDivergingLog - create a diverging logarithmic scale.d3.scaleDivergingPow - create a diverging power scale.d3.scaleDivergingSqrt - create a diverging power scale with exponent 0.5.d3.scaleDivergingSymlog - create a diverging symmetric logarithmic scale.Quantize scales ​Map a continuous, quantitative domain to a discrete range.d3.scaleQuantize - create a uniform quantizing linear scale.quantize - compute the range value corresponding to a given domain value.quantize.invertExtent - compute the domain values corresponding to a given range value.quantize.domain - set the input domain.quantize.range - set the output range.quantize.thresholds - return the array of computed thresholds within the domain.quantize.copy - create a copy of this scale.Quantile scales ​d3.scaleQuantile - create a quantile quantizing linear scale.quantile - compute the range value corresponding to a given domain value.quantile.invertExtent - compute the domain values corresponding to a given range value.quantile.domain - set the input domain.quantile.range - set the output range.quantile.quantiles - get the quantile thresholds.quantile.copy - create a copy of this scale.Threshold scales ​d3.scaleThreshold - create an arbitrary quantizing linear scale.threshold - compute the range value corresponding to a given domain value.threshold.invertExtent - compute the domain values corresponding to a given range value.threshold.domain - set the input domain.threshold.range - set the output range.threshold.copy - create a copy of this scale.Ordinal scales ​Map a discrete domain to a discrete range.d3.scaleOrdinal - create an ordinal scale.ordinal - compute the range value corresponding to a given domain value.ordinal.domain - set the input domain.ordinal.range - set the output range.ordinal.unknown - set the output value for unknown inputs.ordinal.copy - create a copy of this scale.d3.scaleImplicit - a special unknown value for implicit domains.Band scales ​d3.scaleBand - create an ordinal band scale.band - compute the band start corresponding to a given domain value.band.domain - set the input domain.band.range - set the output range.band.rangeRound - set the output range and enable rounding.band.round - enable rounding.band.paddingInner - set padding between bands.band.paddingOuter - set padding outside the first and last bands.band.padding - set padding outside and between bands.band.align - set band alignment, if there is extra space.band.bandwidth - get the width of each band.band.step - get the distance between the starts of adjacent bands.band.copy - create a copy of this scale.Point scales ​d3.scalePoint - create an ordinal point scale.point - compute the point corresponding to a given domain value.point.domain - set the input domain.point.range - set the output range.point.rangeRound - set the output range and enable rounding.point.round - enable rounding.point.padding - set padding outside the first and last point.point.align - set point alignment, if there is extra space.point.bandwidth - returns zero.point.step - get the distance between the starts of adjacent points.point.copy - create a copy of this scale.d3-scale-chromatic ​Color ramps and palettes for quantitative, ordinal and categorical scales.Categorical ​d3.schemeCategory10 - an array of ten categorical colors.d3.schemeAccent - an array of eight categorical colors.d3.schemeDark2 - an array of eight categorical colors.d3.schemeObservable10 - an array of ten categorical colors.d3.schemePaired - an array of twelve categorical colors.d3.schemePastel1 - an array of nine categorical colors.d3.schemePastel2 - an array of eight categorical colors.d3.schemeSet1 - an array of nine categorical colors.d3.schemeSet2 - an array of eight categorical colors.d3.schemeSet3 - an array of twelve categorical colors.d3.schemeTableau10 - an array of ten categorical colors.Cyclical ​d3.interpolateRainbow - the “less-angry” rainbowd3.interpolateSinebow - the “sinebow” smooth rainbowDiverging ​d3.interpolateBrBG - ColorBrewer BrBG interpolator.d3.interpolatePiYG - ColorBrewer PiYG interpolator.d3.interpolatePRGn - ColorBrewer PRGn interpolator.d3.interpolatePuOr - ColorBrewer PuOr interpolator.d3.interpolateRdBu - ColorBrewer RdBu interpolator.d3.interpolateRdGy - ColorBrewer RdGy interpolator.d3.interpolateRdYlBu - ColorBrewer RdYlBu interpolator.d3.interpolateRdYlGn - ColorBrewer RdYlGn interpolator.d3.interpolateSpectral - ColorBrewer spectral interpolator.d3.schemeBrBG - ColorBrewer BrBG scheme.d3.schemePiYG - ColorBrewer PiYG scheme.d3.schemePRGn - ColorBrewer PRGn scheme.d3.schemePuOr - ColorBrewer PuOr scheme.d3.schemeRdBu - ColorBrewer RdBu scheme.d3.schemeRdGy - ColorBrewer RdGy scheme.d3.schemeRdYlBu - ColorBrewer RdYlBu scheme.d3.schemeRdYlGn - ColorBrewer RdYlGn scheme.d3.schemeSpectral - ColorBrewer spectral scheme.Sequential ​d3.interpolateBlues -d3.interpolateGreens -d3.interpolateGreys -d3.interpolateOranges -d3.interpolatePurples -d3.interpolateReds -d3.schemeBlues -d3.schemeGreens -d3.schemeGreys -d3.schemeOranges -d3.schemePurples -d3.schemeReds -d3.interpolateBuGn - ColorBrewer BuGn interpolator.d3.interpolateBuPu - ColorBrewer BuPu interpolator.d3.interpolateCividis - cividis interpolator.d3.interpolateCool - cool interpolator.d3.interpolateCubehelixDefault - cubehelix interpolator.d3.interpolateGnBu - ColorBrewer GnBu interpolator.d3.interpolateInferno - inferno interpolator.d3.interpolateMagma - magma interpolator.d3.interpolateOrRd - ColorBrewer OrRd interpolator.d3.interpolatePlasma - plasma interpolator.d3.interpolatePuBu - ColorBrewer PuBu interpolator.d3.interpolatePuBuGn - ColorBrewer PuBuGn interpolator.d3.interpolatePuRd - ColorBrewer PuRd interpolator.d3.interpolateRdPu - ColorBrewer RdPu interpolator.d3.interpolateTurbo - turbo interpolator.d3.interpolateViridis - viridis interpolator.d3.interpolateWarm - warm interpolator.d3.interpolateYlGn - ColorBrewer YlGn interpolator.d3.interpolateYlGnBu - ColorBrewer YlGnBu interpolator.d3.interpolateYlOrBr - ColorBrewer YlOrBr interpolator.d3.interpolateYlOrRd - ColorBrewer YlOrRd interpolator.d3.schemeBuGn - ColorBrewer BuGn scheme.d3.schemeBuPu - ColorBrewer BuPu scheme.d3.schemeGnBu - ColorBrewer GnBu scheme.d3.schemeOrRd - ColorBrewer OrRd scheme.d3.schemePuBu - ColorBrewer PuBu scheme.d3.schemePuBuGn - ColorBrewer PuBuGn scheme.d3.schemePuRd - ColorBrewer PuRd scheme.d3.schemeRdPu - ColorBrewer RdPu scheme.d3.schemeYlGn - ColorBrewer YlGn scheme.d3.schemeYlGnBu - ColorBrewer YlGnBu scheme.d3.schemeYlOrBr - ColorBrewer YlOrBr scheme.d3.schemeYlOrRd - ColorBrewer YlOrRd scheme.d3-selection ​Transform the DOM by selecting elements and joining to data.Selecting elements ​d3.selection - select the root document element.d3.select - select an element from the document.d3.selectAll - select multiple elements from the document.selection.select - select a descendant element for each selected element.selection.selectAll - select multiple descendants for each selected element.selection.filter - filter elements based on data.selection.merge - merge this selection with another.selection.selectChild - select a child element for each selected element.selection.selectChildren - select the children elements for each selected element.selection.selection - return the selection.d3.matcher - test whether an element matches a selector.d3.selector - select an element.d3.selectorAll - select elements.d3.window - get a node’s owner window.d3.style - get a node’s current style value.Modifying elements ​selection.attr - get or set an attribute.selection.classed - get, add or remove CSS classes.selection.style - get or set a style property.selection.property - get or set a (raw) property.selection.text - get or set the text content.selection.html - get or set the inner HTML.selection.append - create, append and select new elements.selection.insert - create, insert and select new elements.selection.remove - remove elements from the document.selection.clone - insert clones of selected elements.selection.sort - sort elements in the document based on data.selection.order - reorders elements in the document to match the selection.selection.raise - reorders each element as the last child of its parent.selection.lower - reorders each element as the first child of its parent.d3.create - create and select a detached element.d3.creator - create an element by name.Joining data ​selection.data - bind elements to data.selection.join - enter, update or exit elements based on data.selection.enter - get the enter selection (data missing elements).selection.exit - get the exit selection (elements missing data).selection.datum - get or set element data (without joining).Handling events ​selection.on - add or remove event listeners.selection.dispatch - dispatch a custom event.d3.pointer - get the pointer’s position of an event.d3.pointers - get the pointers’ positions of an event.Control flow ​selection.each - call a function for each element.selection.call - call a function with this selection.selection.empty - returns true if this selection is empty.selection.nodes - returns an array of all selected elements.selection.node - returns the first (non-null) element.selection.size - returns the count of elements.selection[Symbol.iterator] - iterate over the selection’s nodes.Local variables ​d3.local - declares a new local variable.local.set - set a local variable’s value.local.get - get a local variable’s value.local.remove - delete a local variable.local.toString - get the property identifier of a local variable.Namespaces ​d3.namespace - qualify a prefixed XML name, such as “xlink:href”.d3.namespaces - the built-in XML namespaces.d3-shape ​Graphical primitives for visualization.Arcs ​Circular or annular sectors, as in a pie or donut chart.d3.arc - create a new arc generator.arc - generate an arc for the given datum.arc.centroid - compute an arc’s midpoint.arc.innerRadius - set the inner radius.arc.outerRadius - set the outer radius.arc.cornerRadius - set the corner radius, for rounded corners.arc.startAngle - set the start angle.arc.endAngle - set the end angle.arc.padAngle - set the angle between adjacent arcs, for padded arcs.arc.padRadius - set the radius at which to linearize padding.arc.context - set the rendering context.arc.digits - set the output precision.Pies ​Compute the necessary angles to represent a tabular dataset as a pie or donut chart.d3.pie - create a new pie generator.pie - compute the arc angles for the given dataset.pie.value - set the value accessor.pie.sort - set the sort order comparator.pie.sortValues - set the sort order comparator.pie.startAngle - set the overall start angle.pie.endAngle - set the overall end angle.pie.padAngle - set the pad angle between adjacent arcs.Lines ​A spline or polyline, as in a line chart.d3.line - create a new line generator.line - generate a line for the given dataset.line.x - set the x accessor.line.y - set the y accessor.line.defined - set the defined accessor.line.curve - set the curve interpolator.line.context - set the rendering context.line.digits - set the output precision.d3.lineRadial - create a new radial line generator.lineRadial - generate a line for the given dataset.lineRadial.angle - set the angle accessor.lineRadial.radius - set the radius accessor.lineRadial.defined - set the defined accessor.lineRadial.curve - set the curve interpolator.lineRadial.context - set the rendering context.Areas ​An area, defined by a bounding topline and baseline, as in an area chart.d3.area - create a new area generator.area - generate an area for the given dataset.area.x - set the x0 and x1 accessors.area.x0 - set the baseline x accessor.area.x1 - set the topline x accessor.area.y - set the y0 and y1 accessors.area.y0 - set the baseline y accessor.area.y1 - set the topline y accessor.area.defined - set the defined accessor.area.curve - set the curve interpolator.area.context - set the rendering context.area.digits - set the output precision.area.lineX0 - derive a line for the left edge of an area.area.lineY0 - derive a line for the top edge of an area.area.lineX1 - derive a line for the right edge of an area.area.lineY1 - derive a line for the bottom edge of an area.d3.areaRadial - create a new radial area generator.areaRadial - generate an area for the given dataset.areaRadial.angle - set the start and end angle accessors.areaRadial.startAngle - set the start angle accessor.areaRadial.endAngle - set the end angle accessor.areaRadial.radius - set the inner and outer radius accessors.areaRadial.innerRadius - set the inner radius accessor.areaRadial.outerRadius - set the outer radius accessor.areaRadial.defined - set the defined accessor.areaRadial.curve - set the curve interpolator.areaRadial.context - set the rendering context.areaRadial.lineStartAngle - derive a line for the start edge of an area.areaRadial.lineInnerRadius - derive a line for the inner edge of an area.areaRadial.lineEndAngle - derive a line for the end edge of an area.areaRadial.lineOuterRadius - derive a line for the outer edge of an area.Curves ​Interpolate between points to produce a continuous shape.d3.curveBasis - a cubic basis spline, repeating the end points.d3.curveBasisClosed - a closed cubic basis spline.d3.curveBasisOpen - a cubic basis spline.d3.curveBundle - a straightened cubic basis spline.bundle.beta - set the bundle tension beta.d3.curveBumpX - a cubic Bézier spline with horizontal tangents.d3.curveBumpY - a cubic Bézier spline with vertical tangents.d3.curveCardinal - a cubic cardinal spline, with one-sided difference at each end.d3.curveCardinalClosed - a closed cubic cardinal spline.d3.curveCardinalOpen - a cubic cardinal spline.cardinal.tension - set the cardinal spline tension.d3.curveCatmullRom - a cubic Catmull–Rom spline, with one-sided difference at each end.d3.curveCatmullRomClosed - a closed cubic Catmull–Rom spline.d3.curveCatmullRomOpen - a cubic Catmull–Rom spline.catmullRom.alpha - set the Catmull–Rom parameter alpha.d3.curveLinear - a polyline.d3.curveLinearClosed - a closed polyline.d3.curveMonotoneX - a cubic spline that, given monotonicity in x, preserves it in y.d3.curveMonotoneY - a cubic spline that, given monotonicity in y, preserves it in x.d3.curveNatural - a natural cubic spline.d3.curveStep - a piecewise constant function.d3.curveStepAfter - a piecewise constant function.d3.curveStepBefore - a piecewise constant function.curve.areaStart - start a new area segment.curve.areaEnd - end the current area segment.curve.lineStart - start a new line segment.curve.lineEnd - end the current line segment.curve.point - add a point to the current line segment.Links ​A smooth cubic Bézier curve from a source to a target.d3.link - create a new link generator.d3.linkVertical - create a new vertical link generator.d3.linkHorizontal - create a new horizontal link generator.link - generate a link.link.source - set the source accessor.link.target - set the target accessor.link.x - set the point x-accessor.link.y - set the point y-accessor.link.context - set the rendering context.link.digits - set the output precision.d3.linkRadial - create a new radial link generator.linkRadial.angle - set the point angle accessor.linkRadial.radius - set the point radius accessor.Symbols ​A categorical shape encoding, as in a scatterplot.d3.symbol - create a new symbol generator.symbol - generate a symbol for the given datum.symbol.type - set the symbol type.symbol.size - set the size of the symbol in square pixels.symbol.context - set the rendering context.symbol.digits - set the output precision.d3.symbolsFill - an array of built-in symbol types for filling.d3.symbolsStroke - an array of built-in symbol types for stroking.d3.symbolAsterisk - an asterisk; for stroke.d3.symbolCircle - a circle; for fill or stroke.d3.symbolCross - a Greek cross with arms of equal length; for fill.d3.symbolDiamond - a rhombus; for fill.d3.symbolDiamond2 - a rotated square; for stroke.d3.symbolPlus - a plus sign; for stroke.d3.symbolSquare - a square; for fill.d3.symbolSquare2 - a square; for stroke.d3.symbolStar - a pentagonal star (pentagram); for fill.d3.symbolTriangle - an up-pointing triangle; for fill.d3.symbolTriangle2 - an up-pointing triangle; for stroke.d3.symbolWye - a Y shape; for fill.d3.pointRadial - relative coordinates of a point given an angle and radius.symbolType.draw - draw this symbol to the given context.Stacks ​Stack shapes, placing one adjacent to another, as in a stacked bar chart.d3.stack - create a new stack generator.stack - generate a stack for the given dataset.stack.keys - set the keys accessor.stack.value - set the value accessor.stack.order - set the order accessor.stack.offset - set the offset accessor.d3.stackOrderAppearance - put the earliest series on bottom.d3.stackOrderAscending - put the smallest series on bottom.d3.stackOrderDescending - put the largest series on bottom.d3.stackOrderInsideOut - put earlier series in the middle.d3.stackOrderNone - use the given series order.d3.stackOrderReverse - use the reverse of the given series order.d3.stackOffsetExpand - normalize the baseline to zero and topline to one.d3.stackOffsetDiverging - positive above zero; negative below zero.d3.stackOffsetNone - apply a zero baseline.d3.stackOffsetSilhouette - center the streamgraph around zero.d3.stackOffsetWiggle - minimize streamgraph wiggling.d3-time ​A calculator for humanity’s peculiar conventions of time.d3.timeInterval - implement a new custom time interval.interval - alias for interval.floor.interval.floor - round down to the nearest boundary.interval.round - round to the nearest boundary.interval.ceil - round up to the nearest boundary.interval.offset - offset a date by some number of intervals.interval.range - generate a range of dates at interval boundaries.interval.filter - create a filtered subset of this interval.interval.every - create a filtered subset of this interval.interval.count - count interval boundaries between two dates.d3.timeMillisecond - the millisecond interval, local time.d3.timeSecond - the second interval, local time.d3.timeMinute - the minute interval, local time.d3.timeHour - the hour interval, local time.d3.timeDay - the day interval, local time.d3.timeWeek - the Sunday-based week interval, local time.d3.timeSunday - the Sunday-based week interval, local time.d3.timeMonday - the Monday-based week interval, local time.d3.timeTuesday - the Tuesday-based week interval, local time.d3.timeWednesday - the Wednesday-based week interval, local time.d3.timeThursday - the Thursday-based week interval, local time.d3.timeFriday - the Friday-based week interval, local time.d3.timeSaturday - the Saturday-based week interval, local time.d3.timeMonth - the month interval, local time.d3.timeYear - the year interval, local time.d3.utcMillisecond - the millisecond interval, UTC time.d3.utcSecond - the second interval, UTC time.d3.utcMinute - the minute interval, UTC time.d3.utcHour - the hour interval, UTC time.d3.utcDay - the day interval, UTC time.d3.utcWeek - the Sunday-based week interval, UTC time.d3.utcSunday - the Sunday-based week interval, UTC time.d3.utcMonday - the Monday-based week interval, UTC time.d3.utcTuesday - the Tuesday-based week interval, UTC time.d3.utcWednesday - the Wednesday-based week interval, UTC time.d3.utcThursday - the Thursday-based week interval, UTC time.d3.utcFriday - the Friday-based week interval, UTC time.d3.utcSaturday - the Saturday-based week interval, UTC time.d3.utcMonth - the month interval, UTC time.d3.utcYear - the year interval, UTC time.d3.unixDay - the day interval, UTC time, not month-aligned.d3.timeMilliseconds - alias for d3.timeMillisecond.range.d3.timeSeconds - alias for d3.timeSecond.range.d3.timeMinutes - alias for d3.timeMinute.range.d3.timeHours - alias for d3.timeHour.range.d3.timeDays - alias for d3.timeDay.range.d3.timeWeeks - alias for d3.timeWeek.range.d3.timeSundays - alias for d3.timeSunday.range.d3.timeMondays - alias for d3.timeMonday.range.d3.timeTuesdays - alias for d3.timeTuesday.range.d3.timeWednesdays - alias for d3.timeWednesday.range.d3.timeThursdays - alias for d3.timeThursday.range.d3.timeFridays - alias for d3.timeFriday.range.d3.timeSaturdays - alias for d3.timeSaturday.range.d3.timeMonths - alias for d3.timeMonth.range.d3.timeYears - alias for d3.timeYear.range.d3.utcMilliseconds - alias for d3.utcMillisecond.range.d3.utcSeconds - alias for d3.utcSecond.range.d3.utcMinutes - alias for d3.utcMinute.range.d3.utcHours - alias for d3.utcHour.range.d3.utcDays - alias for d3.utcDay.range.d3.utcWeeks - alias for d3.utcWeek.range.d3.utcSundays - alias for d3.utcSunday.range.d3.utcMondays - alias for d3.utcMonday.range.d3.utcTuesdays - alias for d3.utcTuesday.range.d3.utcWednesdays - alias for d3.utcWednesday.range.d3.utcThursdays - alias for d3.utcThursday.range.d3.utcFridays - alias for d3.utcFriday.range.d3.utcSaturdays - alias for d3.utcSaturday.range.d3.utcMonths - alias for d3.utcMonth.range.d3.utcYears - alias for d3.utcYear.range.d3.unixDays - alias for d3.unixDay.range.d3.timeTicks - generate representative values from a time interval.d3.utcTicks - generate representative values from a time interval.d3.timeTickInterval - generate representative values from a time interval.d3.utcTickInterval - generate representative values from a time interval.d3-time-format ​Parse and format times, inspired by strptime and strftime.d3.timeFormat - alias for locale.format on the default locale.d3.timeParse - alias for locale.parse on the default locale.d3.utcFormat - alias for locale.utcFormat on the default locale.d3.utcParse - alias for locale.utcParse on the default locale.d3.isoFormat - an ISO 8601 UTC formatter.d3.isoParse - an ISO 8601 UTC parser.locale.format - create a time formatter.locale.parse - create a time parser.locale.utcFormat - create a UTC formatter.locale.utcParse - create a UTC parser.d3.timeFormatLocale - define a custom locale.d3.timeFormatDefaultLocale - define the default locale.d3-timer ​An efficient queue for managing thousands of concurrent animations.d3.now - get the current high-resolution time.d3.timer - schedule a new timer.timer.restart - reset the timer’s start time and callback.timer.stop - stop the timer.d3.timerFlush - immediately execute any eligible timers.d3.timeout - schedule a timer that stops on its first callback.d3.interval - schedule a timer that is called with a configurable period.d3-transition ​Animated transitions for selections.selection.transition - schedule a transition for the selected elements.selection.interrupt - interrupt and cancel transitions on the selected elements.d3.interrupt - interrupt the active transition for a given node.d3.transition - schedule a transition on the root document element.transition.select - schedule a transition on the selected elements.transition.selectAll - schedule a transition on the selected elements.transition.selectChild - select a child element for each selected element.transition.selectChildren - select the children elements for each selected element.transition.selection - returns a selection for this transition.transition.filter - filter elements based on data.transition.merge - merge this transition with another.transition.transition - schedule a new transition following this one.d3.active - select the active transition for a given node.transition.attr - tween the given attribute using the default interpolator.transition.attrTween - tween the given attribute using a custom interpolator.transition.style - tween the given style property using the default interpolator.transition.styleTween - tween the given style property using a custom interpolator.transition.text - set the text content when the transition starts.transition.textTween - tween the text using a custom interpolator.transition.remove - remove the selected elements when the transition ends.transition.tween - run custom code during the transition.transition.delay - specify per-element delay in milliseconds.transition.duration - specify per-element duration in milliseconds.transition.ease - specify the easing function.transition.easeVarying - specify an easing function factory.transition.end - a promise that resolves when a transition ends.transition.on - await the end of a transition.transition.each - call a function for each element.transition.call - call a function with this transition.transition.empty - returns true if this transition is empty.transition.nodes - returns an array of all selected elements.transition.node - returns the first (non-null) element.transition.size - returns the count of elements.d3-zoom ​Pan and zoom SVG, HTML or Canvas using mouse or touch input.d3.zoom - create a zoom behavior.zoom - apply the zoom behavior to the selected elements.zoom.transform - change the transform for the selected elements.zoom.translateBy - translate the transform for the selected elements.zoom.translateTo - translate the transform for the selected elements.zoom.scaleBy - scale the transform for the selected elements.zoom.scaleTo - scale the transform for the selected elements.zoom.constrain - override the transform constraint logic.zoom.filter - control which input events initiate zooming.zoom.touchable - set the touch support detector.zoom.wheelDelta - override scaling for wheel events.zoom.extent - set the extent of the viewport.zoom.scaleExtent - set the allowed scale range.zoom.translateExtent - set the extent of the zoomable world.zoom.clickDistance - set the click distance threshold.zoom.tapDistance - set the tap distance threshold.zoom.duration - set the duration of zoom transitions.zoom.interpolate - control the interpolation of zoom transitions.zoom.on - listen for zoom events.d3.zoomTransform - get the zoom transform for a given element.transform.scale - scale a transform by the specified amount.transform.translate - translate a transform by the specified amount.transform.apply - apply the transform to the given point.transform.applyX - apply the transform to the given x-coordinate.transform.applyY - apply the transform to the given y coordinate.transform.invert - unapply the transform to the given point.transform.invertX - unapply the transform to the given x-coordinate.transform.invertY - unapply the transform to the given y coordinate.transform.rescaleX - apply the transform to an x scale’s domain.transform.rescaleY - apply the transform to a y scale’s domain.transform.toString - format the transform as an SVG transform string.d3.zoomIdentity - the identity transform.\n\n\n\nd3-axis ​The axis component renders human-readable reference marks for position scales. It works with most scale types, including linear, log, band, and time scales as shown above.Calling the axis component on a selection of SVG containers (usually a single G element) populates the axes. Axes are rendered at the origin. To change the position of the axis with respect to the chart, specify a transform attribute on the containing element.jsconst gx = svg.append("g")
    .attr("transform", `translate(0,${height - marginBottom})`)
    .call(d3.axisBottom(x));If the scale has changed, call the axis component a second time to update. For smooth animations, you can call it on a transition.jsgx.transition()
    .duration(750)
    .call(d3.axisBottom(x));The elements created by the axis are considered part of its public API. You can apply external stylesheets or modify the generated axis elements to customize the axis appearance. An axis consists of a path element of class “domain” representing the extent of the scale’s domain, followed by transformed g elements of class “tick” representing each of the scale’s ticks. Each tick has a line element to draw the tick line, and a text element for the tick label. For example, here is a typical bottom-oriented axis:html<g fill="none" font-size="10" font-family="sans-serif" text-anchor="middle">
  <path class="domain" stroke="currentColor" d="M0.5,6V0.5H880.5V6"></path>
  <g class="tick" opacity="1" transform="translate(0.5,0)">
    <line stroke="currentColor" y2="6"></line>
    <text fill="currentColor" y="9" dy="0.71em">0.0</text>
  </g>
  <g class="tick" opacity="1" transform="translate(176.5,0)">
    <line stroke="currentColor" y2="6"></line>
    <text fill="currentColor" y="9" dy="0.71em">0.2</text>
  </g>
  <g class="tick" opacity="1" transform="translate(352.5,0)">
    <line stroke="currentColor" y2="6"></line>
    <text fill="currentColor" y="9" dy="0.71em">0.4</text>
  </g>
  <g class="tick" opacity="1" transform="translate(528.5,0)">
    <line stroke="currentColor" y2="6"></line>
    <text fill="currentColor" y="9" dy="0.71em">0.6</text>
  </g>
  <g class="tick" opacity="1" transform="translate(704.5,0)">
    <line stroke="currentColor" y2="6"></line>
    <text fill="currentColor" y="9" dy="0.71em">0.8</text>
  </g>
  <g class="tick" opacity="1" transform="translate(880.5,0)">
    <line stroke="currentColor" y2="6"></line>
    <text fill="currentColor" y="9" dy="0.71em">1.0</text>
  </g>
</g>The orientation of an axis is fixed; to change the orientation, remove the old axis and create a new axis.axisTop(scale) ​Source · Constructs a new top-oriented axis generator for the given scale, with empty tick arguments, a tick size of 6 and padding of 3. In this orientation, ticks are drawn above the horizontal domain path.axisRight(scale) ​Source · Constructs a new right-oriented axis generator for the given scale, with empty tick arguments, a tick size of 6 and padding of 3. In this orientation, ticks are drawn to the right of the vertical domain path.axisBottom(scale) ​Source · Constructs a new bottom-oriented axis generator for the given scale, with empty tick arguments, a tick size of 6 and padding of 3. In this orientation, ticks are drawn below the horizontal domain path.axisLeft(scale) ​Source · Constructs a new left-oriented axis generator for the given scale, with empty tick arguments, a tick size of 6 and padding of 3. In this orientation, ticks are drawn to the left of the vertical domain path.axis(context) ​Source · Render the axis to the given context, which may be either a selection of SVG containers (either SVG or G elements) or a corresponding transition.jssvg.append("g")
    .attr("transform", `translate(0,${height - marginBottom})`)
    .call(d3.axisBottom(x));axis.scale(scale) ​Source · If scale is specified, sets the scale and returns the axis. If scale is not specified, returns the current scale.jsconst xAxis = d3.axisBottom().scale(x);axis.ticks(...arguments) ​Sets the arguments that will be passed to scale.ticks and scale.tickFormat when the axis is rendered, and returns the axis generator.The meaning of the arguments depends on the axis’ scale type: most commonly, the arguments are a suggested count for the number of ticks (or a time interval for time scales), and an optional format specifier to customize how the tick values are formatted. For example, to generate twenty ticks with SI-prefix formatting on a linear scale, say:jsaxis.ticks(20, "s");To generate ticks every fifteen minutes with a time scale, say:jsaxis.ticks(d3.timeMinute.every(15));This method is a convenience function for axis.tickArguments. For example, this:jsaxis.ticks(10);Is equivalent to:jsaxis.tickArguments([10]);This method has no effect if the scale does not implement scale.ticks, as with band and point scales. To set the tick values explicitly, use axis.tickValues. To set the tick format explicitly, use axis.tickFormat. To generate tick values directly, use scale.ticks.axis.tickArguments(arguments) ​Source · If arguments is specified, sets the arguments that will be passed to scale.ticks and scale.tickFormat when the axis is rendered, and returns the axis generator. See also axis.ticks, which is used more commonly.The meaning of the arguments depends on the axis’ scale type: most commonly, the arguments are a suggested count for the number of ticks (or a time interval for time scales), and an optional format specifier to customize how the tick values are formatted. For example, to generate twenty ticks with SI-prefix formatting on a linear scale, say:jsaxis.tickArguments([20, "s"]);To generate ticks every fifteen minutes with a time scale, say:jsaxis.tickArguments([d3.timeMinute.every(15)]);If arguments is not specified, returns the current tick arguments, which defaults to the empty array. If arguments is specified, this method has no effect if the scale does not implement scale.ticks, as with band and point scales. To set the tick values explicitly, use axis.tickValues. To set the tick format explicitly, use axis.tickFormat.axis.tickValues(values) ​Source · If a values iterable is specified, the specified values are used for ticks rather than the scale’s automatic tick generator. For example, to generate ticks at specific values:jsconst axis = d3.axisBottom(x).tickValues([1, 2, 3, 5, 8, 13, 21]);The explicit tick values take precedence over the tick arguments set by axis.tickArguments. However, any tick arguments will still be passed to the scale’s tickFormat function if a tick format is not also set.If values is null, clears any previously-set explicit tick values and reverts back to the scale’s tick generator. If values is not specified, returns the current tick values, which defaults to null.axis.tickFormat(format) ​Source · If format is specified, sets the tick format function and returns the axis. For example, to display integers with comma-grouping for thousands:jsaxis.tickFormat(d3.format(",.0f"));More commonly, a format specifier is passed to axis.ticks, which has the advantage of setting the format precision automatically based on the tick interval:jsaxis.ticks(10, ",f");See d3-format and d3-time-format for help creating formatters.If format is not specified, returns the current format function, which defaults to null. A null format indicates that the scale’s default formatter should be used, which is generated by calling scale.tickFormat. In this case, the arguments specified by axis.tickArguments are likewise passed to scale.tickFormat.axis.tickSize(size) ​Source · If size is specified, sets the inner and outer tick size to the specified value and returns the axis.jsconst axis = d3.axisBottom(x).tickSize(0);If size is not specified, returns the current inner tick size, which defaults to 6.jsaxis.tickSize() // 0, as specified aboveaxis.tickSizeInner(size) ​Source · If size is specified, sets the inner tick size to the specified value and returns the axis.jsconst axis = d3.axisBottom(x).tickSizeInner(0);If size is not specified, returns the current inner tick size, which defaults to 6.jsaxis.tickSizeInner() // 0, as specified aboveThe inner tick size controls the length of the tick lines, offset from the native position of the axis.axis.tickSizeOuter(size) ​Source · If size is specified, sets the outer tick size to the specified value and returns the axis.jsconst axis = d3.axisBottom(x).tickSizeOuter(0);If size is not specified, returns the current outer tick size, which defaults to 6.jsaxis.tickSizeOuter() // 0, as specified aboveThe outer tick size controls the length of the square ends of the domain path, offset from the native position of the axis. Thus, the “outer ticks” are not actually ticks but part of the domain path, and their position is determined by the associated scale’s domain extent. Thus, outer ticks may overlap with the first or last inner tick. An outer tick size of 0 suppresses the square ends of the domain path, instead producing a straight line.axis.tickPadding(padding) ​Source · If padding is specified, sets the padding to the specified value in pixels and returns the axis.jsconst axis = d3.axisBottom(x).tickPadding(0);If padding is not specified, returns the current padding which defaults to 3 pixels.jsaxis.tickPadding() // 0, as specified aboveaxis.offset(offset) ​Source · If offset is specified, sets the pixel offset to the specified value in pixels and returns the axis.jsconst axis = d3.axisBottom(x).offset(0);If offset is not specified, returns the current pixel offset.jsaxis.offset() // 0The pixel offset defaults to 0 on devices with a devicePixelRatio greater than 1, and 0.5 otherwise. This default pixel offset ensures crisp edges on low-resolution devices.\n\nSearchK7.9.0GitHub️ 110.0kOn this paged3-axis ​The axis component renders human-readable reference marks for position scales. It works with most scale types, including linear, log, band, and time scales as shown above.Calling the axis component on a selection of SVG containers (usually a single G element) populates the axes. Axes are rendered at the origin. To change the position of the axis with respect to the chart, specify a transform attribute on the containing element.jsconst gx = svg.append("g")
    .attr("transform", `translate(0,${height - marginBottom})`)
    .call(d3.axisBottom(x));If the scale has changed, call the axis component a second time to update. For smooth animations, you can call it on a transition.jsgx.transition()
    .duration(750)
    .call(d3.axisBottom(x));The elements created by the axis are considered part of its public API. You can apply external stylesheets or modify the generated axis elements to customize the axis appearance. An axis consists of a path element of class “domain” representing the extent of the scale’s domain, followed by transformed g elements of class “tick” representing each of the scale’s ticks. Each tick has a line element to draw the tick line, and a text element for the tick label. For example, here is a typical bottom-oriented axis:html<g fill="none" font-size="10" font-family="sans-serif" text-anchor="middle">
  <path class="domain" stroke="currentColor" d="M0.5,6V0.5H880.5V6"></path>
  <g class="tick" opacity="1" transform="translate(0.5,0)">
    <line stroke="currentColor" y2="6"></line>
    <text fill="currentColor" y="9" dy="0.71em">0.0</text>
  </g>
  <g class="tick" opacity="1" transform="translate(176.5,0)">
    <line stroke="currentColor" y2="6"></line>
    <text fill="currentColor" y="9" dy="0.71em">0.2</text>
  </g>
  <g class="tick" opacity="1" transform="translate(352.5,0)">
    <line stroke="currentColor" y2="6"></line>
    <text fill="currentColor" y="9" dy="0.71em">0.4</text>
  </g>
  <g class="tick" opacity="1" transform="translate(528.5,0)">
    <line stroke="currentColor" y2="6"></line>
    <text fill="currentColor" y="9" dy="0.71em">0.6</text>
  </g>
  <g class="tick" opacity="1" transform="translate(704.5,0)">
    <line stroke="currentColor" y2="6"></line>
    <text fill="currentColor" y="9" dy="0.71em">0.8</text>
  </g>
  <g class="tick" opacity="1" transform="translate(880.5,0)">
    <line stroke="currentColor" y2="6"></line>
    <text fill="currentColor" y="9" dy="0.71em">1.0</text>
  </g>
</g>The orientation of an axis is fixed; to change the orientation, remove the old axis and create a new axis.axisTop(scale) ​Source · Constructs a new top-oriented axis generator for the given scale, with empty tick arguments, a tick size of 6 and padding of 3. In this orientation, ticks are drawn above the horizontal domain path.axisRight(scale) ​Source · Constructs a new right-oriented axis generator for the given scale, with empty tick arguments, a tick size of 6 and padding of 3. In this orientation, ticks are drawn to the right of the vertical domain path.axisBottom(scale) ​Source · Constructs a new bottom-oriented axis generator for the given scale, with empty tick arguments, a tick size of 6 and padding of 3. In this orientation, ticks are drawn below the horizontal domain path.axisLeft(scale) ​Source · Constructs a new left-oriented axis generator for the given scale, with empty tick arguments, a tick size of 6 and padding of 3. In this orientation, ticks are drawn to the left of the vertical domain path.axis(context) ​Source · Render the axis to the given context, which may be either a selection of SVG containers (either SVG or G elements) or a corresponding transition.jssvg.append("g")
    .attr("transform", `translate(0,${height - marginBottom})`)
    .call(d3.axisBottom(x));axis.scale(scale) ​Source · If scale is specified, sets the scale and returns the axis. If scale is not specified, returns the current scale.jsconst xAxis = d3.axisBottom().scale(x);axis.ticks(...arguments) ​Sets the arguments that will be passed to scale.ticks and scale.tickFormat when the axis is rendered, and returns the axis generator.The meaning of the arguments depends on the axis’ scale type: most commonly, the arguments are a suggested count for the number of ticks (or a time interval for time scales), and an optional format specifier to customize how the tick values are formatted. For example, to generate twenty ticks with SI-prefix formatting on a linear scale, say:jsaxis.ticks(20, "s");To generate ticks every fifteen minutes with a time scale, say:jsaxis.ticks(d3.timeMinute.every(15));This method is a convenience function for axis.tickArguments. For example, this:jsaxis.ticks(10);Is equivalent to:jsaxis.tickArguments([10]);This method has no effect if the scale does not implement scale.ticks, as with band and point scales. To set the tick values explicitly, use axis.tickValues. To set the tick format explicitly, use axis.tickFormat. To generate tick values directly, use scale.ticks.axis.tickArguments(arguments) ​Source · If arguments is specified, sets the arguments that will be passed to scale.ticks and scale.tickFormat when the axis is rendered, and returns the axis generator. See also axis.ticks, which is used more commonly.The meaning of the arguments depends on the axis’ scale type: most commonly, the arguments are a suggested count for the number of ticks (or a time interval for time scales), and an optional format specifier to customize how the tick values are formatted. For example, to generate twenty ticks with SI-prefix formatting on a linear scale, say:jsaxis.tickArguments([20, "s"]);To generate ticks every fifteen minutes with a time scale, say:jsaxis.tickArguments([d3.timeMinute.every(15)]);If arguments is not specified, returns the current tick arguments, which defaults to the empty array. If arguments is specified, this method has no effect if the scale does not implement scale.ticks, as with band and point scales. To set the tick values explicitly, use axis.tickValues. To set the tick format explicitly, use axis.tickFormat.axis.tickValues(values) ​Source · If a values iterable is specified, the specified values are used for ticks rather than the scale’s automatic tick generator. For example, to generate ticks at specific values:jsconst axis = d3.axisBottom(x).tickValues([1, 2, 3, 5, 8, 13, 21]);The explicit tick values take precedence over the tick arguments set by axis.tickArguments. However, any tick arguments will still be passed to the scale’s tickFormat function if a tick format is not also set.If values is null, clears any previously-set explicit tick values and reverts back to the scale’s tick generator. If values is not specified, returns the current tick values, which defaults to null.axis.tickFormat(format) ​Source · If format is specified, sets the tick format function and returns the axis. For example, to display integers with comma-grouping for thousands:jsaxis.tickFormat(d3.format(",.0f"));More commonly, a format specifier is passed to axis.ticks, which has the advantage of setting the format precision automatically based on the tick interval:jsaxis.ticks(10, ",f");See d3-format and d3-time-format for help creating formatters.If format is not specified, returns the current format function, which defaults to null. A null format indicates that the scale’s default formatter should be used, which is generated by calling scale.tickFormat. In this case, the arguments specified by axis.tickArguments are likewise passed to scale.tickFormat.axis.tickSize(size) ​Source · If size is specified, sets the inner and outer tick size to the specified value and returns the axis.jsconst axis = d3.axisBottom(x).tickSize(0);If size is not specified, returns the current inner tick size, which defaults to 6.jsaxis.tickSize() // 0, as specified aboveaxis.tickSizeInner(size) ​Source · If size is specified, sets the inner tick size to the specified value and returns the axis.jsconst axis = d3.axisBottom(x).tickSizeInner(0);If size is not specified, returns the current inner tick size, which defaults to 6.jsaxis.tickSizeInner() // 0, as specified aboveThe inner tick size controls the length of the tick lines, offset from the native position of the axis.axis.tickSizeOuter(size) ​Source · If size is specified, sets the outer tick size to the specified value and returns the axis.jsconst axis = d3.axisBottom(x).tickSizeOuter(0);If size is not specified, returns the current outer tick size, which defaults to 6.jsaxis.tickSizeOuter() // 0, as specified aboveThe outer tick size controls the length of the square ends of the domain path, offset from the native position of the axis. Thus, the “outer ticks” are not actually ticks but part of the domain path, and their position is determined by the associated scale’s domain extent. Thus, outer ticks may overlap with the first or last inner tick. An outer tick size of 0 suppresses the square ends of the domain path, instead producing a straight line.axis.tickPadding(padding) ​Source · If padding is specified, sets the padding to the specified value in pixels and returns the axis.jsconst axis = d3.axisBottom(x).tickPadding(0);If padding is not specified, returns the current padding which defaults to 3 pixels.jsaxis.tickPadding() // 0, as specified aboveaxis.offset(offset) ​Source · If offset is specified, sets the pixel offset to the specified value in pixels and returns the axis.jsconst axis = d3.axisBottom(x).offset(0);If offset is not specified, returns the current pixel offset.jsaxis.offset() // 0The pixel offset defaults to 0 on devices with a devicePixelRatio greater than 1, and 0.5 otherwise. This default pixel offset ensures crisp edges on low-resolution devices.PagerNext paged3-chord\n\nd3-axis ​The axis component renders human-readable reference marks for position scales. It works with most scale types, including linear, log, band, and time scales as shown above.Calling the axis component on a selection of SVG containers (usually a single G element) populates the axes. Axes are rendered at the origin. To change the position of the axis with respect to the chart, specify a transform attribute on the containing element.jsconst gx = svg.append("g")
    .attr("transform", `translate(0,${height - marginBottom})`)
    .call(d3.axisBottom(x));If the scale has changed, call the axis component a second time to update. For smooth animations, you can call it on a transition.jsgx.transition()
    .duration(750)
    .call(d3.axisBottom(x));The elements created by the axis are considered part of its public API. You can apply external stylesheets or modify the generated axis elements to customize the axis appearance. An axis consists of a path element of class “domain” representing the extent of the scale’s domain, followed by transformed g elements of class “tick” representing each of the scale’s ticks. Each tick has a line element to draw the tick line, and a text element for the tick label. For example, here is a typical bottom-oriented axis:html<g fill="none" font-size="10" font-family="sans-serif" text-anchor="middle">
  <path class="domain" stroke="currentColor" d="M0.5,6V0.5H880.5V6"></path>
  <g class="tick" opacity="1" transform="translate(0.5,0)">
    <line stroke="currentColor" y2="6"></line>
    <text fill="currentColor" y="9" dy="0.71em">0.0</text>
  </g>
  <g class="tick" opacity="1" transform="translate(176.5,0)">
    <line stroke="currentColor" y2="6"></line>
    <text fill="currentColor" y="9" dy="0.71em">0.2</text>
  </g>
  <g class="tick" opacity="1" transform="translate(352.5,0)">
    <line stroke="currentColor" y2="6"></line>
    <text fill="currentColor" y="9" dy="0.71em">0.4</text>
  </g>
  <g class="tick" opacity="1" transform="translate(528.5,0)">
    <line stroke="currentColor" y2="6"></line>
    <text fill="currentColor" y="9" dy="0.71em">0.6</text>
  </g>
  <g class="tick" opacity="1" transform="translate(704.5,0)">
    <line stroke="currentColor" y2="6"></line>
    <text fill="currentColor" y="9" dy="0.71em">0.8</text>
  </g>
  <g class="tick" opacity="1" transform="translate(880.5,0)">
    <line stroke="currentColor" y2="6"></line>
    <text fill="currentColor" y="9" dy="0.71em">1.0</text>
  </g>
</g>The orientation of an axis is fixed; to change the orientation, remove the old axis and create a new axis.axisTop(scale) ​Source · Constructs a new top-oriented axis generator for the given scale, with empty tick arguments, a tick size of 6 and padding of 3. In this orientation, ticks are drawn above the horizontal domain path.axisRight(scale) ​Source · Constructs a new right-oriented axis generator for the given scale, with empty tick arguments, a tick size of 6 and padding of 3. In this orientation, ticks are drawn to the right of the vertical domain path.axisBottom(scale) ​Source · Constructs a new bottom-oriented axis generator for the given scale, with empty tick arguments, a tick size of 6 and padding of 3. In this orientation, ticks are drawn below the horizontal domain path.axisLeft(scale) ​Source · Constructs a new left-oriented axis generator for the given scale, with empty tick arguments, a tick size of 6 and padding of 3. In this orientation, ticks are drawn to the left of the vertical domain path.axis(context) ​Source · Render the axis to the given context, which may be either a selection of SVG containers (either SVG or G elements) or a corresponding transition.jssvg.append("g")
    .attr("transform", `translate(0,${height - marginBottom})`)
    .call(d3.axisBottom(x));axis.scale(scale) ​Source · If scale is specified, sets the scale and returns the axis. If scale is not specified, returns the current scale.jsconst xAxis = d3.axisBottom().scale(x);axis.ticks(...arguments) ​Sets the arguments that will be passed to scale.ticks and scale.tickFormat when the axis is rendered, and returns the axis generator.The meaning of the arguments depends on the axis’ scale type: most commonly, the arguments are a suggested count for the number of ticks (or a time interval for time scales), and an optional format specifier to customize how the tick values are formatted. For example, to generate twenty ticks with SI-prefix formatting on a linear scale, say:jsaxis.ticks(20, "s");To generate ticks every fifteen minutes with a time scale, say:jsaxis.ticks(d3.timeMinute.every(15));This method is a convenience function for axis.tickArguments. For example, this:jsaxis.ticks(10);Is equivalent to:jsaxis.tickArguments([10]);This method has no effect if the scale does not implement scale.ticks, as with band and point scales. To set the tick values explicitly, use axis.tickValues. To set the tick format explicitly, use axis.tickFormat. To generate tick values directly, use scale.ticks.axis.tickArguments(arguments) ​Source · If arguments is specified, sets the arguments that will be passed to scale.ticks and scale.tickFormat when the axis is rendered, and returns the axis generator. See also axis.ticks, which is used more commonly.The meaning of the arguments depends on the axis’ scale type: most commonly, the arguments are a suggested count for the number of ticks (or a time interval for time scales), and an optional format specifier to customize how the tick values are formatted. For example, to generate twenty ticks with SI-prefix formatting on a linear scale, say:jsaxis.tickArguments([20, "s"]);To generate ticks every fifteen minutes with a time scale, say:jsaxis.tickArguments([d3.timeMinute.every(15)]);If arguments is not specified, returns the current tick arguments, which defaults to the empty array. If arguments is specified, this method has no effect if the scale does not implement scale.ticks, as with band and point scales. To set the tick values explicitly, use axis.tickValues. To set the tick format explicitly, use axis.tickFormat.axis.tickValues(values) ​Source · If a values iterable is specified, the specified values are used for ticks rather than the scale’s automatic tick generator. For example, to generate ticks at specific values:jsconst axis = d3.axisBottom(x).tickValues([1, 2, 3, 5, 8, 13, 21]);The explicit tick values take precedence over the tick arguments set by axis.tickArguments. However, any tick arguments will still be passed to the scale’s tickFormat function if a tick format is not also set.If values is null, clears any previously-set explicit tick values and reverts back to the scale’s tick generator. If values is not specified, returns the current tick values, which defaults to null.axis.tickFormat(format) ​Source · If format is specified, sets the tick format function and returns the axis. For example, to display integers with comma-grouping for thousands:jsaxis.tickFormat(d3.format(",.0f"));More commonly, a format specifier is passed to axis.ticks, which has the advantage of setting the format precision automatically based on the tick interval:jsaxis.ticks(10, ",f");See d3-format and d3-time-format for help creating formatters.If format is not specified, returns the current format function, which defaults to null. A null format indicates that the scale’s default formatter should be used, which is generated by calling scale.tickFormat. In this case, the arguments specified by axis.tickArguments are likewise passed to scale.tickFormat.axis.tickSize(size) ​Source · If size is specified, sets the inner and outer tick size to the specified value and returns the axis.jsconst axis = d3.axisBottom(x).tickSize(0);If size is not specified, returns the current inner tick size, which defaults to 6.jsaxis.tickSize() // 0, as specified aboveaxis.tickSizeInner(size) ​Source · If size is specified, sets the inner tick size to the specified value and returns the axis.jsconst axis = d3.axisBottom(x).tickSizeInner(0);If size is not specified, returns the current inner tick size, which defaults to 6.jsaxis.tickSizeInner() // 0, as specified aboveThe inner tick size controls the length of the tick lines, offset from the native position of the axis.axis.tickSizeOuter(size) ​Source · If size is specified, sets the outer tick size to the specified value and returns the axis.jsconst axis = d3.axisBottom(x).tickSizeOuter(0);If size is not specified, returns the current outer tick size, which defaults to 6.jsaxis.tickSizeOuter() // 0, as specified aboveThe outer tick size controls the length of the square ends of the domain path, offset from the native position of the axis. Thus, the “outer ticks” are not actually ticks but part of the domain path, and their position is determined by the associated scale’s domain extent. Thus, outer ticks may overlap with the first or last inner tick. An outer tick size of 0 suppresses the square ends of the domain path, instead producing a straight line.axis.tickPadding(padding) ​Source · If padding is specified, sets the padding to the specified value in pixels and returns the axis.jsconst axis = d3.axisBottom(x).tickPadding(0);If padding is not specified, returns the current padding which defaults to 3 pixels.jsaxis.tickPadding() // 0, as specified aboveaxis.offset(offset) ​Source · If offset is specified, sets the pixel offset to the specified value in pixels and returns the axis.jsconst axis = d3.axisBottom(x).offset(0);If offset is not specified, returns the current pixel offset.jsaxis.offset() // 0The pixel offset defaults to 0 on devices with a devicePixelRatio greater than 1, and 0.5 otherwise. This default pixel offset ensures crisp edges on low-resolution devices.\n\n\n\nd3-chord ​Fork ↗︎Chord diagrams visualize flow between a set of nodes in a graph, such as transition probabilities between finite states. The diagram above shows a fake dataset from Circos of people who dyed their hair.D3’s chord layout represents flow using a square matrix of size n×n, where n is the number of nodes in the graph. Each value matrix[i][j] represents the flow from the ith node to the jth node. (Each number matrix[i][j] must be nonnegative, though it can be zero if there is no flow from node i to node j.)Above, each row and column represents a hair color (black, blond, brown, red); each value represents a number of people who dyed their hair from one color to another color. For example, 5,871 people had black hair and dyed it blond, while 1,951 people had blond hair and dyed it black. The matrix diagonal represents people who kept the same color.jsconst matrix = [
  // to black, blond, brown, red
  [11975,  5871, 8916, 2868], // from black
  [ 1951, 10048, 2060, 6171], // from blond
  [ 8010, 16145, 8090, 8045], // from brown
  [ 1013,   990,  940, 6907]  // from red
];A chord diagram visualizes these transitions by arranging the population by starting color along the circumference of a circle and drawing ribbons between each color. The starting and ending width of the ribbon is proportional to the number of people that had the respective starting and ending color. The color of the ribbon, arbitrarily, is the color with the larger of the two values.See one of:Chords - a layout for chord diagramsRibbons - a shape primitive for chord diagrams\n\nSearchK7.9.0GitHub️ 110.0kOn this paged3-chord ​Fork ↗︎Chord diagrams visualize flow between a set of nodes in a graph, such as transition probabilities between finite states. The diagram above shows a fake dataset from Circos of people who dyed their hair.D3’s chord layout represents flow using a square matrix of size n×n, where n is the number of nodes in the graph. Each value matrix[i][j] represents the flow from the ith node to the jth node. (Each number matrix[i][j] must be nonnegative, though it can be zero if there is no flow from node i to node j.)Above, each row and column represents a hair color (black, blond, brown, red); each value represents a number of people who dyed their hair from one color to another color. For example, 5,871 people had black hair and dyed it blond, while 1,951 people had blond hair and dyed it black. The matrix diagonal represents people who kept the same color.jsconst matrix = [
  // to black, blond, brown, red
  [11975,  5871, 8916, 2868], // from black
  [ 1951, 10048, 2060, 6171], // from blond
  [ 8010, 16145, 8090, 8045], // from brown
  [ 1013,   990,  940, 6907]  // from red
];A chord diagram visualizes these transitions by arranging the population by starting color along the circumference of a circle and drawing ribbons between each color. The starting and ending width of the ribbon is proportional to the number of people that had the respective starting and ending color. The color of the ribbon, arbitrarily, is the color with the larger of the two values.See one of:Chords - a layout for chord diagramsRibbons - a shape primitive for chord diagramsPagerPrevious paged3-axisNext pageChords\n\nd3-chord ​Fork ↗︎Chord diagrams visualize flow between a set of nodes in a graph, such as transition probabilities between finite states. The diagram above shows a fake dataset from Circos of people who dyed their hair.D3’s chord layout represents flow using a square matrix of size n×n, where n is the number of nodes in the graph. Each value matrix[i][j] represents the flow from the ith node to the jth node. (Each number matrix[i][j] must be nonnegative, though it can be zero if there is no flow from node i to node j.)Above, each row and column represents a hair color (black, blond, brown, red); each value represents a number of people who dyed their hair from one color to another color. For example, 5,871 people had black hair and dyed it blond, while 1,951 people had blond hair and dyed it black. The matrix diagonal represents people who kept the same color.jsconst matrix = [
  // to black, blond, brown, red
  [11975,  5871, 8916, 2868], // from black
  [ 1951, 10048, 2060, 6171], // from blond
  [ 8010, 16145, 8090, 8045], // from brown
  [ 1013,   990,  940, 6907]  // from red
];A chord diagram visualizes these transitions by arranging the population by starting color along the circumference of a circle and drawing ribbons between each color. The starting and ending width of the ribbon is proportional to the number of people that had the respective starting and ending color. The color of the ribbon, arbitrarily, is the color with the larger of the two values.See one of:Chords - a layout for chord diagramsRibbons - a shape primitive for chord diagrams\n\n\n\nChords ​The chord layout computes angles to generate a chord diagram.chord() ​Source · Constructs a new chord layout with the default settings.jsconst chord = d3.chord();chord(matrix) ​Source · Computes the chord layout for the specified square matrix of size n×n, where the matrix represents the directed flow amongst a network (a complete digraph) of n nodes.The return value of chord(matrix) is an array of chords, where each chord represents the combined bidirectional flow between two nodes i and j (where i may be equal to j) and is an object with the following properties:source - the source subgrouptarget - the target subgroupEach source and target subgroup is also an object with the following properties:startAngle - the start angle in radiansendAngle - the end angle in radiansvalue - the flow value matrix[i][j]index - the node index iThe chords are typically passed to ribbon to display the network relationships.The returned array includes only chord objects for which the value matrix[i][j] or matrix[j][i] is non-zero. Furthermore, the returned array only contains unique chords: a given chord ij represents the bidirectional flow from i to j and from j to i, and does not contain a duplicate chord ji; i and j are chosen such that the chord’s source always represents the larger of matrix[i][j] and matrix[j][i].The chords array also defines a secondary array of length n, chords.groups, where each group represents the combined outflow for node i, corresponding to the elements matrix[i][0 … n - 1], and is an object with the following properties:startAngle - the start angle in radiansendAngle - the end angle in radiansvalue - the total outgoing flow value for node iindex - the node index iThe groups are typically passed to arc to produce a donut chart around the circumference of the chord layout.chord.padAngle(angle) ​Source · If angle is specified, sets the pad angle between adjacent groups to the specified number in radians and returns this chord layout. If angle is not specified, returns the current pad angle, which defaults to zero.chord.sortGroups(compare) ​Source · If compare is specified, sets the group comparator to the specified function or null and returns this chord layout. If compare is not specified, returns the current group comparator, which defaults to null. If the group comparator is non-null, it is used to sort the groups by their total outflow. See also ascending and descending.chord.sortSubgroups(compare) ​Source · If compare is specified, sets the subgroup comparator to the specified function or null and returns this chord layout. If compare is not specified, returns the current subgroup comparator, which defaults to null. If the subgroup comparator is non-null, it is used to sort the subgroups corresponding to matrix[i][0 … n - 1] for a given group i by their total outflow. See also ascending and descending.chord.sortChords(compare) ​Source · If compare is specified, sets the chord comparator to the specified function or null and returns this chord layout. If compare is not specified, returns the current chord comparator, which defaults to null. If the chord comparator is non-null, it is used to sort the chords by their combined flow; this only affects the z-order of the chords. See also ascending and descending.chordDirected() ​Examples · Source · A chord layout for unidirectional flows. The chord from i to j is generated from the value in matrix[i][j] only.chordTranspose() ​Source · A transposed chord layout. Useful to highlight outgoing (rather than incoming) flows.\n\nSearchK7.9.0GitHub️ 110.0kOn this pageChords ​The chord layout computes angles to generate a chord diagram.chord() ​Source · Constructs a new chord layout with the default settings.jsconst chord = d3.chord();chord(matrix) ​Source · Computes the chord layout for the specified square matrix of size n×n, where the matrix represents the directed flow amongst a network (a complete digraph) of n nodes.The return value of chord(matrix) is an array of chords, where each chord represents the combined bidirectional flow between two nodes i and j (where i may be equal to j) and is an object with the following properties:source - the source subgrouptarget - the target subgroupEach source and target subgroup is also an object with the following properties:startAngle - the start angle in radiansendAngle - the end angle in radiansvalue - the flow value matrix[i][j]index - the node index iThe chords are typically passed to ribbon to display the network relationships.The returned array includes only chord objects for which the value matrix[i][j] or matrix[j][i] is non-zero. Furthermore, the returned array only contains unique chords: a given chord ij represents the bidirectional flow from i to j and from j to i, and does not contain a duplicate chord ji; i and j are chosen such that the chord’s source always represents the larger of matrix[i][j] and matrix[j][i].The chords array also defines a secondary array of length n, chords.groups, where each group represents the combined outflow for node i, corresponding to the elements matrix[i][0 … n - 1], and is an object with the following properties:startAngle - the start angle in radiansendAngle - the end angle in radiansvalue - the total outgoing flow value for node iindex - the node index iThe groups are typically passed to arc to produce a donut chart around the circumference of the chord layout.chord.padAngle(angle) ​Source · If angle is specified, sets the pad angle between adjacent groups to the specified number in radians and returns this chord layout. If angle is not specified, returns the current pad angle, which defaults to zero.chord.sortGroups(compare) ​Source · If compare is specified, sets the group comparator to the specified function or null and returns this chord layout. If compare is not specified, returns the current group comparator, which defaults to null. If the group comparator is non-null, it is used to sort the groups by their total outflow. See also ascending and descending.chord.sortSubgroups(compare) ​Source · If compare is specified, sets the subgroup comparator to the specified function or null and returns this chord layout. If compare is not specified, returns the current subgroup comparator, which defaults to null. If the subgroup comparator is non-null, it is used to sort the subgroups corresponding to matrix[i][0 … n - 1] for a given group i by their total outflow. See also ascending and descending.chord.sortChords(compare) ​Source · If compare is specified, sets the chord comparator to the specified function or null and returns this chord layout. If compare is not specified, returns the current chord comparator, which defaults to null. If the chord comparator is non-null, it is used to sort the chords by their combined flow; this only affects the z-order of the chords. See also ascending and descending.chordDirected() ​Examples · Source · A chord layout for unidirectional flows. The chord from i to j is generated from the value in matrix[i][j] only.chordTranspose() ​Source · A transposed chord layout. Useful to highlight outgoing (rather than incoming) flows.PagerPrevious paged3-chordNext pageRibbons\n\nChords ​The chord layout computes angles to generate a chord diagram.chord() ​Source · Constructs a new chord layout with the default settings.jsconst chord = d3.chord();chord(matrix) ​Source · Computes the chord layout for the specified square matrix of size n×n, where the matrix represents the directed flow amongst a network (a complete digraph) of n nodes.The return value of chord(matrix) is an array of chords, where each chord represents the combined bidirectional flow between two nodes i and j (where i may be equal to j) and is an object with the following properties:source - the source subgrouptarget - the target subgroupEach source and target subgroup is also an object with the following properties:startAngle - the start angle in radiansendAngle - the end angle in radiansvalue - the flow value matrix[i][j]index - the node index iThe chords are typically passed to ribbon to display the network relationships.The returned array includes only chord objects for which the value matrix[i][j] or matrix[j][i] is non-zero. Furthermore, the returned array only contains unique chords: a given chord ij represents the bidirectional flow from i to j and from j to i, and does not contain a duplicate chord ji; i and j are chosen such that the chord’s source always represents the larger of matrix[i][j] and matrix[j][i].The chords array also defines a secondary array of length n, chords.groups, where each group represents the combined outflow for node i, corresponding to the elements matrix[i][0 … n - 1], and is an object with the following properties:startAngle - the start angle in radiansendAngle - the end angle in radiansvalue - the total outgoing flow value for node iindex - the node index iThe groups are typically passed to arc to produce a donut chart around the circumference of the chord layout.chord.padAngle(angle) ​Source · If angle is specified, sets the pad angle between adjacent groups to the specified number in radians and returns this chord layout. If angle is not specified, returns the current pad angle, which defaults to zero.chord.sortGroups(compare) ​Source · If compare is specified, sets the group comparator to the specified function or null and returns this chord layout. If compare is not specified, returns the current group comparator, which defaults to null. If the group comparator is non-null, it is used to sort the groups by their total outflow. See also ascending and descending.chord.sortSubgroups(compare) ​Source · If compare is specified, sets the subgroup comparator to the specified function or null and returns this chord layout. If compare is not specified, returns the current subgroup comparator, which defaults to null. If the subgroup comparator is non-null, it is used to sort the subgroups corresponding to matrix[i][0 … n - 1] for a given group i by their total outflow. See also ascending and descending.chord.sortChords(compare) ​Source · If compare is specified, sets the chord comparator to the specified function or null and returns this chord layout. If compare is not specified, returns the current chord comparator, which defaults to null. If the chord comparator is non-null, it is used to sort the chords by their combined flow; this only affects the z-order of the chords. See also ascending and descending.chordDirected() ​Examples · Source · A chord layout for unidirectional flows. The chord from i to j is generated from the value in matrix[i][j] only.chordTranspose() ​Source · A transposed chord layout. Useful to highlight outgoing (rather than incoming) flows.\n\n\n\nRibbons ​A ribbon visually represents the volume of flow between two nodes in a chord diagram. Ribbons come in two varieties: ribbon represents a bidirectional flow, while ribbonArrow represents a unidirectional flow. The latter is suitable for chordDirected.ribbon() ​Source · Creates a new ribbon generator with the default settings.jsconst ribbon = d3.ribbon();ribbon(...arguments) ​Source · Generates a ribbon for the given arguments. The arguments are arbitrary; they are propagated to the ribbon generator’s accessor functions along with the this object. For example, with the default settings, a chord object is expected:jsribbon({
  source: {startAngle: 0.7524114, endAngle: 1.1212972, radius: 240},
  target: {startAngle: 1.8617078, endAngle: 1.9842927, radius: 240}
}) // "M164.0162810494058,-175.21032946354026A240,240,0,0,1,216.1595644740915,-104.28347273835429Q0,0,229.9158815306728,68.8381247563705A240,240,0,0,1,219.77316791012538,96.43523560788266Q0,0,164.0162810494058,-175.21032946354026Z"If the ribbon generator has a context, then the ribbon is rendered to this context as a sequence of path method calls and this function returns void. Otherwise, a path data string is returned.ribbon.source(source) ​Source · If source is specified, sets the source accessor to the specified function and returns this ribbon generator. If source is not specified, returns the current source accessor, which defaults to:jsfunction source(d) {
  return d.source;
}ribbon.target(target) ​Source · If target is specified, sets the target accessor to the specified function and returns this ribbon generator. If target is not specified, returns the current target accessor, which defaults to:jsfunction target(d) {
  return d.target;
}ribbon.radius(radius) ​Source · If radius is specified, sets the source and target radius accessor to the specified function and returns this ribbon generator. For example to set a fixed radius of 240 pixels:jsconst ribbon = d3.ribbon().radius(240);Now the arguments you pass to ribbon do not need to specify a radius property on the source and target.jsribbon({
  source: {startAngle: 0.7524114, endAngle: 1.1212972},
  target: {startAngle: 1.8617078, endAngle: 1.9842927}
}) // "M164.0162810494058,-175.21032946354026A240,240,0,0,1,216.1595644740915,-104.28347273835429Q0,0,229.9158815306728,68.8381247563705A240,240,0,0,1,219.77316791012538,96.43523560788266Q0,0,164.0162810494058,-175.21032946354026Z"If radius is not specified, returns the current source radius accessor, which defaults to:jsfunction radius(d) {
  return d.radius;
}ribbon.sourceRadius(radius) ​Source · If radius is specified, sets the source radius accessor to the specified function and returns this ribbon generator. If radius is not specified, returns the current source radius accessor, which defaults to:jsfunction radius(d) {
  return d.radius;
}ribbon.targetRadius(radius) ​Source · If radius is specified, sets the target radius accessor to the specified function and returns this ribbon generator. If radius is not specified, returns the current target radius accessor, which defaults to:jsfunction radius(d) {
  return d.radius;
}By convention, the target radius in asymmetric chord diagrams is typically inset from the source radius, resulting in a gap between the end of the directed link and its associated group arc.ribbon.startAngle(angle) ​Source · If angle is specified, sets the start angle accessor to the specified function and returns this ribbon generator. If angle is not specified, returns the current start angle accessor, which defaults to:jsfunction startAngle(d) {
  return d.startAngle;
}The angle is specified in radians, with 0 at -y (12 o’clock) and positive angles proceeding clockwise.ribbon.endAngle(angle) ​Source · If angle is specified, sets the end angle accessor to the specified function and returns this ribbon generator. If angle is not specified, returns the current end angle accessor, which defaults to:jsfunction endAngle(d) {
  return d.endAngle;
}The angle is specified in radians, with 0 at -y (12 o’clock) and positive angles proceeding clockwise.ribbon.padAngle(angle) ​Source · If angle is specified, sets the pad angle accessor to the specified function and returns this ribbon generator. If angle is not specified, returns the current pad angle accessor, which defaults to:jsfunction padAngle() {
  return 0;
}The pad angle specifies the angular gap between adjacent ribbons.ribbon.context(context) ​Source · If context is specified, sets the context and returns this ribbon generator. If context is not specified, returns the current context, which defaults to null. If the context is not null, then the generated ribbon is rendered to this context as a sequence of path method calls. Otherwise, a path data string representing the generated ribbon is returned. See also d3-path.ribbonArrow() ​Source · Creates a new arrow ribbon generator with the default settings. See also chordDirected.ribbonArrow.headRadius(radius) ​Source · If radius is specified, sets the arrowhead radius accessor to the specified function and returns this ribbon generator. If radius is not specified, returns the current arrowhead radius accessor, which defaults to:jsfunction headRadius() {
  return 10;
}\n\nSearchK7.9.0GitHub️ 110.0kOn this pageRibbons ​A ribbon visually represents the volume of flow between two nodes in a chord diagram. Ribbons come in two varieties: ribbon represents a bidirectional flow, while ribbonArrow represents a unidirectional flow. The latter is suitable for chordDirected.ribbon() ​Source · Creates a new ribbon generator with the default settings.jsconst ribbon = d3.ribbon();ribbon(...arguments) ​Source · Generates a ribbon for the given arguments. The arguments are arbitrary; they are propagated to the ribbon generator’s accessor functions along with the this object. For example, with the default settings, a chord object is expected:jsribbon({
  source: {startAngle: 0.7524114, endAngle: 1.1212972, radius: 240},
  target: {startAngle: 1.8617078, endAngle: 1.9842927, radius: 240}
}) // "M164.0162810494058,-175.21032946354026A240,240,0,0,1,216.1595644740915,-104.28347273835429Q0,0,229.9158815306728,68.8381247563705A240,240,0,0,1,219.77316791012538,96.43523560788266Q0,0,164.0162810494058,-175.21032946354026Z"If the ribbon generator has a context, then the ribbon is rendered to this context as a sequence of path method calls and this function returns void. Otherwise, a path data string is returned.ribbon.source(source) ​Source · If source is specified, sets the source accessor to the specified function and returns this ribbon generator. If source is not specified, returns the current source accessor, which defaults to:jsfunction source(d) {
  return d.source;
}ribbon.target(target) ​Source · If target is specified, sets the target accessor to the specified function and returns this ribbon generator. If target is not specified, returns the current target accessor, which defaults to:jsfunction target(d) {
  return d.target;
}ribbon.radius(radius) ​Source · If radius is specified, sets the source and target radius accessor to the specified function and returns this ribbon generator. For example to set a fixed radius of 240 pixels:jsconst ribbon = d3.ribbon().radius(240);Now the arguments you pass to ribbon do not need to specify a radius property on the source and target.jsribbon({
  source: {startAngle: 0.7524114, endAngle: 1.1212972},
  target: {startAngle: 1.8617078, endAngle: 1.9842927}
}) // "M164.0162810494058,-175.21032946354026A240,240,0,0,1,216.1595644740915,-104.28347273835429Q0,0,229.9158815306728,68.8381247563705A240,240,0,0,1,219.77316791012538,96.43523560788266Q0,0,164.0162810494058,-175.21032946354026Z"If radius is not specified, returns the current source radius accessor, which defaults to:jsfunction radius(d) {
  return d.radius;
}ribbon.sourceRadius(radius) ​Source · If radius is specified, sets the source radius accessor to the specified function and returns this ribbon generator. If radius is not specified, returns the current source radius accessor, which defaults to:jsfunction radius(d) {
  return d.radius;
}ribbon.targetRadius(radius) ​Source · If radius is specified, sets the target radius accessor to the specified function and returns this ribbon generator. If radius is not specified, returns the current target radius accessor, which defaults to:jsfunction radius(d) {
  return d.radius;
}By convention, the target radius in asymmetric chord diagrams is typically inset from the source radius, resulting in a gap between the end of the directed link and its associated group arc.ribbon.startAngle(angle) ​Source · If angle is specified, sets the start angle accessor to the specified function and returns this ribbon generator. If angle is not specified, returns the current start angle accessor, which defaults to:jsfunction startAngle(d) {
  return d.startAngle;
}The angle is specified in radians, with 0 at -y (12 o’clock) and positive angles proceeding clockwise.ribbon.endAngle(angle) ​Source · If angle is specified, sets the end angle accessor to the specified function and returns this ribbon generator. If angle is not specified, returns the current end angle accessor, which defaults to:jsfunction endAngle(d) {
  return d.endAngle;
}The angle is specified in radians, with 0 at -y (12 o’clock) and positive angles proceeding clockwise.ribbon.padAngle(angle) ​Source · If angle is specified, sets the pad angle accessor to the specified function and returns this ribbon generator. If angle is not specified, returns the current pad angle accessor, which defaults to:jsfunction padAngle() {
  return 0;
}The pad angle specifies the angular gap between adjacent ribbons.ribbon.context(context) ​Source · If context is specified, sets the context and returns this ribbon generator. If context is not specified, returns the current context, which defaults to null. If the context is not null, then the generated ribbon is rendered to this context as a sequence of path method calls. Otherwise, a path data string representing the generated ribbon is returned. See also d3-path.ribbonArrow() ​Source · Creates a new arrow ribbon generator with the default settings. See also chordDirected.ribbonArrow.headRadius(radius) ​Source · If radius is specified, sets the arrowhead radius accessor to the specified function and returns this ribbon generator. If radius is not specified, returns the current arrowhead radius accessor, which defaults to:jsfunction headRadius() {
  return 10;
}PagerPrevious pageChordsNext paged3-color\n\nRibbons ​A ribbon visually represents the volume of flow between two nodes in a chord diagram. Ribbons come in two varieties: ribbon represents a bidirectional flow, while ribbonArrow represents a unidirectional flow. The latter is suitable for chordDirected.ribbon() ​Source · Creates a new ribbon generator with the default settings.jsconst ribbon = d3.ribbon();ribbon(...arguments) ​Source · Generates a ribbon for the given arguments. The arguments are arbitrary; they are propagated to the ribbon generator’s accessor functions along with the this object. For example, with the default settings, a chord object is expected:jsribbon({
  source: {startAngle: 0.7524114, endAngle: 1.1212972, radius: 240},
  target: {startAngle: 1.8617078, endAngle: 1.9842927, radius: 240}
}) // "M164.0162810494058,-175.21032946354026A240,240,0,0,1,216.1595644740915,-104.28347273835429Q0,0,229.9158815306728,68.8381247563705A240,240,0,0,1,219.77316791012538,96.43523560788266Q0,0,164.0162810494058,-175.21032946354026Z"If the ribbon generator has a context, then the ribbon is rendered to this context as a sequence of path method calls and this function returns void. Otherwise, a path data string is returned.ribbon.source(source) ​Source · If source is specified, sets the source accessor to the specified function and returns this ribbon generator. If source is not specified, returns the current source accessor, which defaults to:jsfunction source(d) {
  return d.source;
}ribbon.target(target) ​Source · If target is specified, sets the target accessor to the specified function and returns this ribbon generator. If target is not specified, returns the current target accessor, which defaults to:jsfunction target(d) {
  return d.target;
}ribbon.radius(radius) ​Source · If radius is specified, sets the source and target radius accessor to the specified function and returns this ribbon generator. For example to set a fixed radius of 240 pixels:jsconst ribbon = d3.ribbon().radius(240);Now the arguments you pass to ribbon do not need to specify a radius property on the source and target.jsribbon({
  source: {startAngle: 0.7524114, endAngle: 1.1212972},
  target: {startAngle: 1.8617078, endAngle: 1.9842927}
}) // "M164.0162810494058,-175.21032946354026A240,240,0,0,1,216.1595644740915,-104.28347273835429Q0,0,229.9158815306728,68.8381247563705A240,240,0,0,1,219.77316791012538,96.43523560788266Q0,0,164.0162810494058,-175.21032946354026Z"If radius is not specified, returns the current source radius accessor, which defaults to:jsfunction radius(d) {
  return d.radius;
}ribbon.sourceRadius(radius) ​Source · If radius is specified, sets the source radius accessor to the specified function and returns this ribbon generator. If radius is not specified, returns the current source radius accessor, which defaults to:jsfunction radius(d) {
  return d.radius;
}ribbon.targetRadius(radius) ​Source · If radius is specified, sets the target radius accessor to the specified function and returns this ribbon generator. If radius is not specified, returns the current target radius accessor, which defaults to:jsfunction radius(d) {
  return d.radius;
}By convention, the target radius in asymmetric chord diagrams is typically inset from the source radius, resulting in a gap between the end of the directed link and its associated group arc.ribbon.startAngle(angle) ​Source · If angle is specified, sets the start angle accessor to the specified function and returns this ribbon generator. If angle is not specified, returns the current start angle accessor, which defaults to:jsfunction startAngle(d) {
  return d.startAngle;
}The angle is specified in radians, with 0 at -y (12 o’clock) and positive angles proceeding clockwise.ribbon.endAngle(angle) ​Source · If angle is specified, sets the end angle accessor to the specified function and returns this ribbon generator. If angle is not specified, returns the current end angle accessor, which defaults to:jsfunction endAngle(d) {
  return d.endAngle;
}The angle is specified in radians, with 0 at -y (12 o’clock) and positive angles proceeding clockwise.ribbon.padAngle(angle) ​Source · If angle is specified, sets the pad angle accessor to the specified function and returns this ribbon generator. If angle is not specified, returns the current pad angle accessor, which defaults to:jsfunction padAngle() {
  return 0;
}The pad angle specifies the angular gap between adjacent ribbons.ribbon.context(context) ​Source · If context is specified, sets the context and returns this ribbon generator. If context is not specified, returns the current context, which defaults to null. If the context is not null, then the generated ribbon is rendered to this context as a sequence of path method calls. Otherwise, a path data string representing the generated ribbon is returned. See also d3-path.ribbonArrow() ​Source · Creates a new arrow ribbon generator with the default settings. See also chordDirected.ribbonArrow.headRadius(radius) ​Source · If radius is specified, sets the arrowhead radius accessor to the specified function and returns this ribbon generator. If radius is not specified, returns the current arrowhead radius accessor, which defaults to:jsfunction headRadius() {
  return 10;
}\n\n\n\nd3-color ​Even though your browser understands a lot about colors, it doesn’t offer much help in manipulating colors through JavaScript. The d3-color module therefore provides representations for various color spaces, allowing specification, conversion and manipulation. (Also see d3-interpolate for color interpolation.)For example, take the named color steelblue, which is rgb(70, 130, 180) in RGB:jslet c = d3.color("steelblue"); // {r: 70, g: 130, b: 180, opacity: 1}To convert to HSL hsl(207.3, 44%, 49%):jsc = d3.hsl(c); // {h: 207.27…, s: 0.44, l: 0.4902…, opacity: 1}To then rotate the hue by 90° hsl(297.3, 44%, 49%), increase the saturation by 20% hsl(297.3, 64%, 49%), and format as an RGB string rgb(198, 45, 205):jsc.h += 90;
c.s += 0.2;
c + ""; // rgb(198, 45, 205)To fade the color slightly rgba(198, 45, 205, 0.8):jsc.opacity = 0.8;
c + ""; // rgba(198, 45, 205, 0.8)In addition to the ubiquitous and machine-friendly RGB and HSL color space, d3-color supports color spaces that are designed for humans:CIELAB (a.k.a. “Lab”)CIELChab (a.k.a. “LCh” or “HCL”)Dave Green’s CubehelixCubehelix features monotonic lightness, while CIELAB and its polar form CIELChab are perceptually uniform.For additional color spaces, see:d3-cam16d3-cam02d3-hsvd3-hcgd3-hsluvTo measure color differences, see:d3-color-differencecolor(specifier) ​jsd3.color("steelblue") // {r: 70, g: 130, b: 180, opacity: 1}Source · Parses the specified CSS Color Module Level 3 specifier string, returning an RGB or HSL color, along with CSS Color Module Level 4 hex specifier strings. If the specifier was not valid, null is returned. Some examples:rgb(255, 255, 255)rgb(10%, 20%, 30%)rgba(255, 255, 255, 0.4)rgba(10%, 20%, 30%, 0.4)hsl(120, 50%, 20%)hsla(120, 50%, 20%, 0.4)#ffeeaa#fea#ffeeaa22#fea2steelblueThe list of supported named colors is specified by CSS.Note: this function may also be used with instanceof to test if an object is a color instance. The same is true of color subclasses, allowing you to test whether a color is in a particular color space.color.opacity ​jsd3.color("steelblue").opacity // 1This color’s opacity, typically in the range [0, 1].color.rgb() ​jsd3.color("hsl(120, 50%, 20%)").rgb() // {r: 25.5, g: 76.5, b: 25.5, opacity: 1}Source · Returns the RGB equivalent of this color. For RGB colors, that’s this.color.copy(values) ​jsd3.color("steelblue").copy({opacity: 0.5}) // {r: 70, g: 130, b: 180, opacity: 0.5}Source · Returns a copy of this color. If values is specified, any enumerable own properties of values are assigned to the new returned color.color.brighter(k) ​jsd3.color("steelblue").brighter(1) // {r: 100, g: 185.71428571428572, b: 257.14285714285717, opacity: 1}Source · Returns a brighter copy of this color. For example, if k is 1, steelblue in RGB color space becomes rgb(100, 186, 255). The parameter k controls how much brighter the returned color should be (in arbitrary units); if k is not specified, it defaults to 1. The behavior of this method is dependent on the implementing color space.color.darker(k) ​jsd3.color("steelblue").darker(1) // {r: 49, g: 91, b: 126, opacity: 1}Source · Returns a darker copy of this color. For example, if k is 1, steelblue in RGB color space becomes rgb(49, 91, 126). The parameter k controls how much darker the returned color should be (in arbitrary units); if k is not specified, it defaults to 1. The behavior of this method is dependent on the implementing color space.color.displayable() ​jsd3.color("steelblue").displayable(1) // trueSource · Returns true if and only if the color is displayable on standard hardware. For example, this returns false for an RGB color if any channel value is less than zero or greater than 255 when rounded, or if the opacity is not in the range [0, 1].color.formatHex() ​jsd3.color("steelblue").formatHex() // "#4682b4"Source · Returns a hexadecimal string representing this color in RGB space, such as #4682b4. If this color is not displayable, a suitable displayable color is returned instead. For example, RGB channel values greater than 255 are clamped to 255.color.formatHex8() ​jsd3.color("steelblue").formatHex8() // "#4682b4ff"Source · Returns a hexadecimal string representing this color in RGBA space, such as #4682b4cc. If this color is not displayable, a suitable displayable color is returned instead. For example, RGB channel values greater than 255 are clamped to 255.color.formatHsl() ​jsd3.color("yellow").formatHsl() // "hsl(60, 100%, 50%)"Source · Returns a string representing this color according to the CSS Color Module Level 3 specification, such as hsl(257, 50%, 80%) or hsla(257, 50%, 80%, 0.2). If this color is not displayable, a suitable displayable color is returned instead by clamping S and L channel values to the interval [0, 100].color.formatRgb() ​jsd3.color("yellow").formatRgb() // "rgb(255, 255, 0)"Source · Returns a string representing this color according to the CSS Object Model specification, such as rgb(247, 234, 186) or rgba(247, 234, 186, 0.2). If this color is not displayable, a suitable displayable color is returned instead by clamping RGB channel values to the interval [0, 255].color.toString() ​jsd3.color("yellow").toString() // "rgb(255, 255, 0)"Source · An alias for color.formatRgb.rgb(color) ​jsd3.rgb("hsl(60, 100%, 50%)") // {r: 255, g: 255, b: 0, opacity: 1}Source · Constructs a new RGB color. The channel values are exposed as r, g and b properties on the returned instance. Use the RGB color picker to explore this color space.If r, g and b are specified, these represent the channel values of the returned color; an opacity may also be specified. If a CSS Color Module Level 3 specifier string is specified, it is parsed and then converted to the RGB color space. See color for examples. If a color instance is specified, it is converted to the RGB color space using color.rgb. Note that unlike color.rgb this method always returns a new instance, even if color is already an RGB color.rgb.clamp() ​jsd3.rgb(300, 200, 100).clamp() // {r: 255, g: 200, b: 100, opacity: 1}Source · Returns a new RGB color where the r, g, and b channels are clamped to the range [0, 255] and rounded to the nearest integer value, and the opacity is clamped to the range [0, 1].hsl(color) ​jsd3.hsl("yellow") // {h: 60, s: 1, l: 0.5, opacity: 1}Source · Constructs a new HSL color. The channel values are exposed as h, s and l properties on the returned instance. Use the HSL color picker to explore this color space.If h, s and l are specified, these represent the channel values of the returned color; an opacity may also be specified. If a CSS Color Module Level 3 specifier string is specified, it is parsed and then converted to the HSL color space. See color for examples. If a color instance is specified, it is converted to the RGB color space using color.rgb and then converted to HSL. (Colors already in the HSL color space skip the conversion to RGB.)hsl.clamp() ​jsd3.hsl(400, 2, 0.5).clamp() // {h: 40, s: 1, l: 0.5, opacity: 1}Source · Returns a new HSL color where the h channel is clamped to the range [0, 360), and the s, l, and opacity channels are clamped to the range [0, 1].lab(color) ​jsd3.lab("red") // {l: 54.29173376861782, a: 80.8124553179771, b: 69.88504032350531, opacity: 1}Source · Constructs a new CIELAB color. The channel values are exposed as l, a and b properties on the returned instance. Use the CIELAB color picker to explore this color space. The value of l is typically in the range [0, 100], while a and b are typically in [-160, +160].If l, a and b are specified, these represent the channel values of the returned color; an opacity may also be specified. If a CSS Color Module Level 3 specifier string is specified, it is parsed and then converted to the CIELAB color space. See color for examples. If a color instance is specified, it is converted to the RGB color space using color.rgb and then converted to CIELAB. (Colors already in the CIELAB color space skip the conversion to RGB, and colors in the HCL color space are converted directly to CIELAB.)gray(l, opacity) ​jsd3.gray(50) // {l: 50, a: 0, b: 0, opacity: 1}Source · Constructs a new CIELAB color with the specified l value and a = b = 0.hcl(color) ​jsd3.hcl("yellow") // {h: 99.57458688693687, c: 94.70776566727464, l: 97.60712516622824, opacity: 1}Source · Equivalent to d3.lch, but with reversed argument order.lch(color) ​jsd3.lch("yellow") // {h: 99.57458688693687, c: 94.70776566727464, l: 97.60712516622824, opacity: 1}Source · Constructs a new CIELChab color. The channel values are exposed as l, c and h properties on the returned instance. Use the CIELChab color picker to explore this color space. The value of l is typically in the range [0, 100], c is typically in [0, 230], and h is typically in [0, 360).If l, c, and h are specified, these represent the channel values of the returned color; an opacity may also be specified. If a CSS Color Module Level 3 specifier string is specified, it is parsed and then converted to CIELChab color space. See color for examples. If a color instance is specified, it is converted to the RGB color space using color.rgb and then converted to CIELChab. (Colors already in CIELChab color space skip the conversion to RGB, and colors in CIELAB color space are converted directly to CIELChab.)cubehelix(color) ​jsd3.cubehelix("yellow") // {h: 56.942171677321085, s: 4.614386868039714, l: 0.8900004504279901, opacity: 1}Source · Constructs a new Cubehelix color. The channel values are exposed as h, s and l properties on the returned instance.If h, s and l are specified, these represent the channel values of the returned color; an opacity may also be specified. If a CSS Color Module Level 3 specifier string is specified, it is parsed and then converted to the Cubehelix color space. See color for examples. If a color instance is specified, it is converted to the RGB color space using color.rgb and then converted to Cubehelix. (Colors already in the Cubehelix color space skip the conversion to RGB.)\n\nSearchK7.9.0GitHub️ 110.0kOn this paged3-color ​Even though your browser understands a lot about colors, it doesn’t offer much help in manipulating colors through JavaScript. The d3-color module therefore provides representations for various color spaces, allowing specification, conversion and manipulation. (Also see d3-interpolate for color interpolation.)For example, take the named color steelblue, which is rgb(70, 130, 180) in RGB:jslet c = d3.color("steelblue"); // {r: 70, g: 130, b: 180, opacity: 1}To convert to HSL hsl(207.3, 44%, 49%):jsc = d3.hsl(c); // {h: 207.27…, s: 0.44, l: 0.4902…, opacity: 1}To then rotate the hue by 90° hsl(297.3, 44%, 49%), increase the saturation by 20% hsl(297.3, 64%, 49%), and format as an RGB string rgb(198, 45, 205):jsc.h += 90;
c.s += 0.2;
c + ""; // rgb(198, 45, 205)To fade the color slightly rgba(198, 45, 205, 0.8):jsc.opacity = 0.8;
c + ""; // rgba(198, 45, 205, 0.8)In addition to the ubiquitous and machine-friendly RGB and HSL color space, d3-color supports color spaces that are designed for humans:CIELAB (a.k.a. “Lab”)CIELChab (a.k.a. “LCh” or “HCL”)Dave Green’s CubehelixCubehelix features monotonic lightness, while CIELAB and its polar form CIELChab are perceptually uniform.For additional color spaces, see:d3-cam16d3-cam02d3-hsvd3-hcgd3-hsluvTo measure color differences, see:d3-color-differencecolor(specifier) ​jsd3.color("steelblue") // {r: 70, g: 130, b: 180, opacity: 1}Source · Parses the specified CSS Color Module Level 3 specifier string, returning an RGB or HSL color, along with CSS Color Module Level 4 hex specifier strings. If the specifier was not valid, null is returned. Some examples:rgb(255, 255, 255)rgb(10%, 20%, 30%)rgba(255, 255, 255, 0.4)rgba(10%, 20%, 30%, 0.4)hsl(120, 50%, 20%)hsla(120, 50%, 20%, 0.4)#ffeeaa#fea#ffeeaa22#fea2steelblueThe list of supported named colors is specified by CSS.Note: this function may also be used with instanceof to test if an object is a color instance. The same is true of color subclasses, allowing you to test whether a color is in a particular color space.color.opacity ​jsd3.color("steelblue").opacity // 1This color’s opacity, typically in the range [0, 1].color.rgb() ​jsd3.color("hsl(120, 50%, 20%)").rgb() // {r: 25.5, g: 76.5, b: 25.5, opacity: 1}Source · Returns the RGB equivalent of this color. For RGB colors, that’s this.color.copy(values) ​jsd3.color("steelblue").copy({opacity: 0.5}) // {r: 70, g: 130, b: 180, opacity: 0.5}Source · Returns a copy of this color. If values is specified, any enumerable own properties of values are assigned to the new returned color.color.brighter(k) ​jsd3.color("steelblue").brighter(1) // {r: 100, g: 185.71428571428572, b: 257.14285714285717, opacity: 1}Source · Returns a brighter copy of this color. For example, if k is 1, steelblue in RGB color space becomes rgb(100, 186, 255). The parameter k controls how much brighter the returned color should be (in arbitrary units); if k is not specified, it defaults to 1. The behavior of this method is dependent on the implementing color space.color.darker(k) ​jsd3.color("steelblue").darker(1) // {r: 49, g: 91, b: 126, opacity: 1}Source · Returns a darker copy of this color. For example, if k is 1, steelblue in RGB color space becomes rgb(49, 91, 126). The parameter k controls how much darker the returned color should be (in arbitrary units); if k is not specified, it defaults to 1. The behavior of this method is dependent on the implementing color space.color.displayable() ​jsd3.color("steelblue").displayable(1) // trueSource · Returns true if and only if the color is displayable on standard hardware. For example, this returns false for an RGB color if any channel value is less than zero or greater than 255 when rounded, or if the opacity is not in the range [0, 1].color.formatHex() ​jsd3.color("steelblue").formatHex() // "#4682b4"Source · Returns a hexadecimal string representing this color in RGB space, such as #4682b4. If this color is not displayable, a suitable displayable color is returned instead. For example, RGB channel values greater than 255 are clamped to 255.color.formatHex8() ​jsd3.color("steelblue").formatHex8() // "#4682b4ff"Source · Returns a hexadecimal string representing this color in RGBA space, such as #4682b4cc. If this color is not displayable, a suitable displayable color is returned instead. For example, RGB channel values greater than 255 are clamped to 255.color.formatHsl() ​jsd3.color("yellow").formatHsl() // "hsl(60, 100%, 50%)"Source · Returns a string representing this color according to the CSS Color Module Level 3 specification, such as hsl(257, 50%, 80%) or hsla(257, 50%, 80%, 0.2). If this color is not displayable, a suitable displayable color is returned instead by clamping S and L channel values to the interval [0, 100].color.formatRgb() ​jsd3.color("yellow").formatRgb() // "rgb(255, 255, 0)"Source · Returns a string representing this color according to the CSS Object Model specification, such as rgb(247, 234, 186) or rgba(247, 234, 186, 0.2). If this color is not displayable, a suitable displayable color is returned instead by clamping RGB channel values to the interval [0, 255].color.toString() ​jsd3.color("yellow").toString() // "rgb(255, 255, 0)"Source · An alias for color.formatRgb.rgb(color) ​jsd3.rgb("hsl(60, 100%, 50%)") // {r: 255, g: 255, b: 0, opacity: 1}Source · Constructs a new RGB color. The channel values are exposed as r, g and b properties on the returned instance. Use the RGB color picker to explore this color space.If r, g and b are specified, these represent the channel values of the returned color; an opacity may also be specified. If a CSS Color Module Level 3 specifier string is specified, it is parsed and then converted to the RGB color space. See color for examples. If a color instance is specified, it is converted to the RGB color space using color.rgb. Note that unlike color.rgb this method always returns a new instance, even if color is already an RGB color.rgb.clamp() ​jsd3.rgb(300, 200, 100).clamp() // {r: 255, g: 200, b: 100, opacity: 1}Source · Returns a new RGB color where the r, g, and b channels are clamped to the range [0, 255] and rounded to the nearest integer value, and the opacity is clamped to the range [0, 1].hsl(color) ​jsd3.hsl("yellow") // {h: 60, s: 1, l: 0.5, opacity: 1}Source · Constructs a new HSL color. The channel values are exposed as h, s and l properties on the returned instance. Use the HSL color picker to explore this color space.If h, s and l are specified, these represent the channel values of the returned color; an opacity may also be specified. If a CSS Color Module Level 3 specifier string is specified, it is parsed and then converted to the HSL color space. See color for examples. If a color instance is specified, it is converted to the RGB color space using color.rgb and then converted to HSL. (Colors already in the HSL color space skip the conversion to RGB.)hsl.clamp() ​jsd3.hsl(400, 2, 0.5).clamp() // {h: 40, s: 1, l: 0.5, opacity: 1}Source · Returns a new HSL color where the h channel is clamped to the range [0, 360), and the s, l, and opacity channels are clamped to the range [0, 1].lab(color) ​jsd3.lab("red") // {l: 54.29173376861782, a: 80.8124553179771, b: 69.88504032350531, opacity: 1}Source · Constructs a new CIELAB color. The channel values are exposed as l, a and b properties on the returned instance. Use the CIELAB color picker to explore this color space. The value of l is typically in the range [0, 100], while a and b are typically in [-160, +160].If l, a and b are specified, these represent the channel values of the returned color; an opacity may also be specified. If a CSS Color Module Level 3 specifier string is specified, it is parsed and then converted to the CIELAB color space. See color for examples. If a color instance is specified, it is converted to the RGB color space using color.rgb and then converted to CIELAB. (Colors already in the CIELAB color space skip the conversion to RGB, and colors in the HCL color space are converted directly to CIELAB.)gray(l, opacity) ​jsd3.gray(50) // {l: 50, a: 0, b: 0, opacity: 1}Source · Constructs a new CIELAB color with the specified l value and a = b = 0.hcl(color) ​jsd3.hcl("yellow") // {h: 99.57458688693687, c: 94.70776566727464, l: 97.60712516622824, opacity: 1}Source · Equivalent to d3.lch, but with reversed argument order.lch(color) ​jsd3.lch("yellow") // {h: 99.57458688693687, c: 94.70776566727464, l: 97.60712516622824, opacity: 1}Source · Constructs a new CIELChab color. The channel values are exposed as l, c and h properties on the returned instance. Use the CIELChab color picker to explore this color space. The value of l is typically in the range [0, 100], c is typically in [0, 230], and h is typically in [0, 360).If l, c, and h are specified, these represent the channel values of the returned color; an opacity may also be specified. If a CSS Color Module Level 3 specifier string is specified, it is parsed and then converted to CIELChab color space. See color for examples. If a color instance is specified, it is converted to the RGB color space using color.rgb and then converted to CIELChab. (Colors already in CIELChab color space skip the conversion to RGB, and colors in CIELAB color space are converted directly to CIELChab.)cubehelix(color) ​jsd3.cubehelix("yellow") // {h: 56.942171677321085, s: 4.614386868039714, l: 0.8900004504279901, opacity: 1}Source · Constructs a new Cubehelix color. The channel values are exposed as h, s and l properties on the returned instance.If h, s and l are specified, these represent the channel values of the returned color; an opacity may also be specified. If a CSS Color Module Level 3 specifier string is specified, it is parsed and then converted to the Cubehelix color space. See color for examples. If a color instance is specified, it is converted to the RGB color space using color.rgb and then converted to Cubehelix. (Colors already in the Cubehelix color space skip the conversion to RGB.)PagerPrevious pageRibbonsNext paged3-interpolate\n\nd3-color ​Even though your browser understands a lot about colors, it doesn’t offer much help in manipulating colors through JavaScript. The d3-color module therefore provides representations for various color spaces, allowing specification, conversion and manipulation. (Also see d3-interpolate for color interpolation.)For example, take the named color steelblue, which is rgb(70, 130, 180) in RGB:jslet c = d3.color("steelblue"); // {r: 70, g: 130, b: 180, opacity: 1}To convert to HSL hsl(207.3, 44%, 49%):jsc = d3.hsl(c); // {h: 207.27…, s: 0.44, l: 0.4902…, opacity: 1}To then rotate the hue by 90° hsl(297.3, 44%, 49%), increase the saturation by 20% hsl(297.3, 64%, 49%), and format as an RGB string rgb(198, 45, 205):jsc.h += 90;
c.s += 0.2;
c + ""; // rgb(198, 45, 205)To fade the color slightly rgba(198, 45, 205, 0.8):jsc.opacity = 0.8;
c + ""; // rgba(198, 45, 205, 0.8)In addition to the ubiquitous and machine-friendly RGB and HSL color space, d3-color supports color spaces that are designed for humans:CIELAB (a.k.a. “Lab”)CIELChab (a.k.a. “LCh” or “HCL”)Dave Green’s CubehelixCubehelix features monotonic lightness, while CIELAB and its polar form CIELChab are perceptually uniform.For additional color spaces, see:d3-cam16d3-cam02d3-hsvd3-hcgd3-hsluvTo measure color differences, see:d3-color-differencecolor(specifier) ​jsd3.color("steelblue") // {r: 70, g: 130, b: 180, opacity: 1}Source · Parses the specified CSS Color Module Level 3 specifier string, returning an RGB or HSL color, along with CSS Color Module Level 4 hex specifier strings. If the specifier was not valid, null is returned. Some examples:rgb(255, 255, 255)rgb(10%, 20%, 30%)rgba(255, 255, 255, 0.4)rgba(10%, 20%, 30%, 0.4)hsl(120, 50%, 20%)hsla(120, 50%, 20%, 0.4)#ffeeaa#fea#ffeeaa22#fea2steelblueThe list of supported named colors is specified by CSS.Note: this function may also be used with instanceof to test if an object is a color instance. The same is true of color subclasses, allowing you to test whether a color is in a particular color space.color.opacity ​jsd3.color("steelblue").opacity // 1This color’s opacity, typically in the range [0, 1].color.rgb() ​jsd3.color("hsl(120, 50%, 20%)").rgb() // {r: 25.5, g: 76.5, b: 25.5, opacity: 1}Source · Returns the RGB equivalent of this color. For RGB colors, that’s this.color.copy(values) ​jsd3.color("steelblue").copy({opacity: 0.5}) // {r: 70, g: 130, b: 180, opacity: 0.5}Source · Returns a copy of this color. If values is specified, any enumerable own properties of values are assigned to the new returned color.color.brighter(k) ​jsd3.color("steelblue").brighter(1) // {r: 100, g: 185.71428571428572, b: 257.14285714285717, opacity: 1}Source · Returns a brighter copy of this color. For example, if k is 1, steelblue in RGB color space becomes rgb(100, 186, 255). The parameter k controls how much brighter the returned color should be (in arbitrary units); if k is not specified, it defaults to 1. The behavior of this method is dependent on the implementing color space.color.darker(k) ​jsd3.color("steelblue").darker(1) // {r: 49, g: 91, b: 126, opacity: 1}Source · Returns a darker copy of this color. For example, if k is 1, steelblue in RGB color space becomes rgb(49, 91, 126). The parameter k controls how much darker the returned color should be (in arbitrary units); if k is not specified, it defaults to 1. The behavior of this method is dependent on the implementing color space.color.displayable() ​jsd3.color("steelblue").displayable(1) // trueSource · Returns true if and only if the color is displayable on standard hardware. For example, this returns false for an RGB color if any channel value is less than zero or greater than 255 when rounded, or if the opacity is not in the range [0, 1].color.formatHex() ​jsd3.color("steelblue").formatHex() // "#4682b4"Source · Returns a hexadecimal string representing this color in RGB space, such as #4682b4. If this color is not displayable, a suitable displayable color is returned instead. For example, RGB channel values greater than 255 are clamped to 255.color.formatHex8() ​jsd3.color("steelblue").formatHex8() // "#4682b4ff"Source · Returns a hexadecimal string representing this color in RGBA space, such as #4682b4cc. If this color is not displayable, a suitable displayable color is returned instead. For example, RGB channel values greater than 255 are clamped to 255.color.formatHsl() ​jsd3.color("yellow").formatHsl() // "hsl(60, 100%, 50%)"Source · Returns a string representing this color according to the CSS Color Module Level 3 specification, such as hsl(257, 50%, 80%) or hsla(257, 50%, 80%, 0.2). If this color is not displayable, a suitable displayable color is returned instead by clamping S and L channel values to the interval [0, 100].color.formatRgb() ​jsd3.color("yellow").formatRgb() // "rgb(255, 255, 0)"Source · Returns a string representing this color according to the CSS Object Model specification, such as rgb(247, 234, 186) or rgba(247, 234, 186, 0.2). If this color is not displayable, a suitable displayable color is returned instead by clamping RGB channel values to the interval [0, 255].color.toString() ​jsd3.color("yellow").toString() // "rgb(255, 255, 0)"Source · An alias for color.formatRgb.rgb(color) ​jsd3.rgb("hsl(60, 100%, 50%)") // {r: 255, g: 255, b: 0, opacity: 1}Source · Constructs a new RGB color. The channel values are exposed as r, g and b properties on the returned instance. Use the RGB color picker to explore this color space.If r, g and b are specified, these represent the channel values of the returned color; an opacity may also be specified. If a CSS Color Module Level 3 specifier string is specified, it is parsed and then converted to the RGB color space. See color for examples. If a color instance is specified, it is converted to the RGB color space using color.rgb. Note that unlike color.rgb this method always returns a new instance, even if color is already an RGB color.rgb.clamp() ​jsd3.rgb(300, 200, 100).clamp() // {r: 255, g: 200, b: 100, opacity: 1}Source · Returns a new RGB color where the r, g, and b channels are clamped to the range [0, 255] and rounded to the nearest integer value, and the opacity is clamped to the range [0, 1].hsl(color) ​jsd3.hsl("yellow") // {h: 60, s: 1, l: 0.5, opacity: 1}Source · Constructs a new HSL color. The channel values are exposed as h, s and l properties on the returned instance. Use the HSL color picker to explore this color space.If h, s and l are specified, these represent the channel values of the returned color; an opacity may also be specified. If a CSS Color Module Level 3 specifier string is specified, it is parsed and then converted to the HSL color space. See color for examples. If a color instance is specified, it is converted to the RGB color space using color.rgb and then converted to HSL. (Colors already in the HSL color space skip the conversion to RGB.)hsl.clamp() ​jsd3.hsl(400, 2, 0.5).clamp() // {h: 40, s: 1, l: 0.5, opacity: 1}Source · Returns a new HSL color where the h channel is clamped to the range [0, 360), and the s, l, and opacity channels are clamped to the range [0, 1].lab(color) ​jsd3.lab("red") // {l: 54.29173376861782, a: 80.8124553179771, b: 69.88504032350531, opacity: 1}Source · Constructs a new CIELAB color. The channel values are exposed as l, a and b properties on the returned instance. Use the CIELAB color picker to explore this color space. The value of l is typically in the range [0, 100], while a and b are typically in [-160, +160].If l, a and b are specified, these represent the channel values of the returned color; an opacity may also be specified. If a CSS Color Module Level 3 specifier string is specified, it is parsed and then converted to the CIELAB color space. See color for examples. If a color instance is specified, it is converted to the RGB color space using color.rgb and then converted to CIELAB. (Colors already in the CIELAB color space skip the conversion to RGB, and colors in the HCL color space are converted directly to CIELAB.)gray(l, opacity) ​jsd3.gray(50) // {l: 50, a: 0, b: 0, opacity: 1}Source · Constructs a new CIELAB color with the specified l value and a = b = 0.hcl(color) ​jsd3.hcl("yellow") // {h: 99.57458688693687, c: 94.70776566727464, l: 97.60712516622824, opacity: 1}Source · Equivalent to d3.lch, but with reversed argument order.lch(color) ​jsd3.lch("yellow") // {h: 99.57458688693687, c: 94.70776566727464, l: 97.60712516622824, opacity: 1}Source · Constructs a new CIELChab color. The channel values are exposed as l, c and h properties on the returned instance. Use the CIELChab color picker to explore this color space. The value of l is typically in the range [0, 100], c is typically in [0, 230], and h is typically in [0, 360).If l, c, and h are specified, these represent the channel values of the returned color; an opacity may also be specified. If a CSS Color Module Level 3 specifier string is specified, it is parsed and then converted to CIELChab color space. See color for examples. If a color instance is specified, it is converted to the RGB color space using color.rgb and then converted to CIELChab. (Colors already in CIELChab color space skip the conversion to RGB, and colors in CIELAB color space are converted directly to CIELChab.)cubehelix(color) ​jsd3.cubehelix("yellow") // {h: 56.942171677321085, s: 4.614386868039714, l: 0.8900004504279901, opacity: 1}Source · Constructs a new Cubehelix color. The channel values are exposed as h, s and l properties on the returned instance.If h, s and l are specified, these represent the channel values of the returned color; an opacity may also be specified. If a CSS Color Module Level 3 specifier string is specified, it is parsed and then converted to the Cubehelix color space. See color for examples. If a color instance is specified, it is converted to the RGB color space using color.rgb and then converted to Cubehelix. (Colors already in the Cubehelix color space skip the conversion to RGB.)\n\n\n\nd3-interpolate ​This module provides a variety of interpolation methods for blending between two values. Values may be numbers, colors, strings, arrays, or even deeply-nested objects. For example:jsconst i = d3.interpolateNumber(10, 20);
i(0.0); // 10
i(0.2); // 12
i(0.5); // 15
i(1.0); // 20The returned function i is an interpolator. Given a starting value a and an ending value b, it takes a parameter t typically in [0, 1] and returns the corresponding interpolated value. An interpolator typically returns a value equivalent to a at t = 0 and a value equivalent to b at t = 1.You can interpolate more than just numbers. To find the perceptual midpoint between steelblue and brown:jsd3.interpolateLab("steelblue", "brown")(0.5); // "rgb(142, 92, 109)"Or, as a color ramp from t = 0 to t = 1:Here’s a more elaborate example demonstrating type inference used by interpolate:jsconst i = d3.interpolate({colors: ["red", "blue"]}, {colors: ["white", "black"]});
i(0.0); // {colors: ["rgb(255, 0, 0)", "rgb(0, 0, 255)"]}
i(0.5); // {colors: ["rgb(255, 128, 128)", "rgb(0, 0, 128)"]}
i(1.0); // {colors: ["rgb(255, 255, 255)", "rgb(0, 0, 0)"]}Note that the generic value interpolator detects not only nested objects and arrays, but also color strings and numbers embedded in strings!See one of:Value interpolationColor interpolationTransform interpolationZoom interpolation\n\nSearchK7.9.0GitHub️ 110.0kOn this paged3-interpolate ​This module provides a variety of interpolation methods for blending between two values. Values may be numbers, colors, strings, arrays, or even deeply-nested objects. For example:jsconst i = d3.interpolateNumber(10, 20);
i(0.0); // 10
i(0.2); // 12
i(0.5); // 15
i(1.0); // 20The returned function i is an interpolator. Given a starting value a and an ending value b, it takes a parameter t typically in [0, 1] and returns the corresponding interpolated value. An interpolator typically returns a value equivalent to a at t = 0 and a value equivalent to b at t = 1.You can interpolate more than just numbers. To find the perceptual midpoint between steelblue and brown:jsd3.interpolateLab("steelblue", "brown")(0.5); // "rgb(142, 92, 109)"Or, as a color ramp from t = 0 to t = 1:Here’s a more elaborate example demonstrating type inference used by interpolate:jsconst i = d3.interpolate({colors: ["red", "blue"]}, {colors: ["white", "black"]});
i(0.0); // {colors: ["rgb(255, 0, 0)", "rgb(0, 0, 255)"]}
i(0.5); // {colors: ["rgb(255, 128, 128)", "rgb(0, 0, 128)"]}
i(1.0); // {colors: ["rgb(255, 255, 255)", "rgb(0, 0, 0)"]}Note that the generic value interpolator detects not only nested objects and arrays, but also color strings and numbers embedded in strings!See one of:Value interpolationColor interpolationTransform interpolationZoom interpolationPagerPrevious paged3-colorNext pageValue interpolation\n\nd3-interpolate ​This module provides a variety of interpolation methods for blending between two values. Values may be numbers, colors, strings, arrays, or even deeply-nested objects. For example:jsconst i = d3.interpolateNumber(10, 20);
i(0.0); // 10
i(0.2); // 12
i(0.5); // 15
i(1.0); // 20The returned function i is an interpolator. Given a starting value a and an ending value b, it takes a parameter t typically in [0, 1] and returns the corresponding interpolated value. An interpolator typically returns a value equivalent to a at t = 0 and a value equivalent to b at t = 1.You can interpolate more than just numbers. To find the perceptual midpoint between steelblue and brown:jsd3.interpolateLab("steelblue", "brown")(0.5); // "rgb(142, 92, 109)"Or, as a color ramp from t = 0 to t = 1:Here’s a more elaborate example demonstrating type inference used by interpolate:jsconst i = d3.interpolate({colors: ["red", "blue"]}, {colors: ["white", "black"]});
i(0.0); // {colors: ["rgb(255, 0, 0)", "rgb(0, 0, 255)"]}
i(0.5); // {colors: ["rgb(255, 128, 128)", "rgb(0, 0, 128)"]}
i(1.0); // {colors: ["rgb(255, 255, 255)", "rgb(0, 0, 0)"]}Note that the generic value interpolator detects not only nested objects and arrays, but also color strings and numbers embedded in strings!See one of:Value interpolationColor interpolationTransform interpolationZoom interpolation\n\n\n\nValue interpolation ​These are the most general interpolators, suitable for most values.interpolate(a, b) ​Examples · Source · Returns an interpolator between the two arbitrary values a and b.jsd3.interpolate("red", "blue")(0.5) // "rgb(128, 0, 128)"The interpolator implementation is based on the type of the end value b, using the following algorithm:If b is null, undefined or a boolean, use the constant b.If b is a number, use interpolateNumber.If b is a color or a string coercible to a color, use interpolateRgb.If b is a date, use interpolateDate.If b is a string, use interpolateString.If b is a typed array of numbers, use interpolateNumberArray.If b is a generic array, use interpolateArray.If b is coercible to a number, use interpolateNumber.Use interpolateObject.Based on the chosen interpolator, a is coerced to the suitable corresponding type.interpolateNumber(a, b) ​Examples · Source · Returns an interpolator between the two numbers a and b.jsd3.interpolateNumber(20, 620)(0.8) // 500The returned interpolator is equivalent to:jsfunction interpolator(t) {
  return a * (1 - t) + b * t;
}CAUTIONAvoid interpolating to or from the number zero when the interpolator is used to generate a string. When very small values are stringified, they may be converted to scientific notation, which is an invalid attribute or style property value in older browsers. For example, the number 0.0000001 is converted to the string "1e-7". This is particularly noticeable with interpolating opacity. To avoid scientific notation, start or end the transition at 1e-6: the smallest value that is not stringified in scientific notation.interpolateRound(a, b) ​Examples · Source · Returns an interpolator between the two numbers a and b.jsd3.interpolateRound(20, 620)(0.821) // 513The interpolator is similar to interpolateNumber except it will round the resulting value to the nearest integer.interpolateString(a, b) ​Examples · Source · Returns an interpolator between the two strings a and b.jsd3.interpolateString("20px", "32px")(0.5) // "26px"The string interpolator finds numbers embedded in a and b, where each number is of the form understood by JavaScript. A few examples of numbers that will be detected within a string: -1, 42, 3.14159, and 6.0221413e+23.For each number embedded in b, the interpolator will attempt to find a corresponding number in a. If a corresponding number is found, a numeric interpolator is created using interpolateNumber. The remaining parts of the string b are used as a template: the static parts of the string b remain constant for the interpolation, with the interpolated numeric values embedded in the template.For example, if a is "300 12px sans-serif", and b is "500 36px Comic-Sans", two embedded numbers are found. The remaining static parts (of string b) are a space between the two numbers (" "), and the suffix ("px Comic-Sans"). The result of the interpolator at t = 0.5 is "400 24px Comic-Sans".interpolateDate(a, b) ​Examples · Source · Returns an interpolator between the two dates a and b.jsd3.interpolateDate(new Date("2014-01-01"), new Date("2024-01-01"))(0.5) // 2019-01-01CAUTIONNo defensive copy of the returned date is created; the same Date instance is returned for every evaluation of the interpolator. No copy is made for performance reasons, as interpolators are often part of the inner loop of animated transitions.interpolateArray(a, b) ​Examples · Source · Returns an interpolator between the two arrays a and b.jsd3.interpolateArray([0, 0, 0], [1, 2, 3])(0.5) // [0.5, 1, 1.5]If b is a typed array (e.g., Float64Array), interpolateNumberArray is called instead.Internally, an array template is created that is the same length as b. For each element in b, if there exists a corresponding element in a, a generic interpolator is created for the two elements using interpolate. If there is no such element, the static value from b is used in the template. Then, for the given parameter t, the template’s embedded interpolators are evaluated. The updated array template is then returned.For example, if a is the array [0, 1] and b is the array [1, 10, 100], then the result of the interpolator for t = 0.5 is the array [0.5, 5.5, 100].CAUTIONNo defensive copy of the template array is created; modifications of the returned array may adversely affect subsequent evaluation of the interpolator. No copy is made for performance reasons; interpolators are often part of the inner loop of animated transitions.interpolateNumberArray(a, b) ​Examples · Source · Returns an interpolator between the two arrays of numbers a and b.jsd3.interpolateNumberArray([0, 1], Float64Array.of(1, 3))(0.5) // [0.5, 2]Internally, an array template is created that is the same type and length as b. For each element in b, if there exists a corresponding element in a, the values are directly interpolated in the array template. If there is no such element, the static value from b is copied. The updated array template is then returned.CAUTIONNo defensive copy is made of the template array and the arguments a and b; modifications of these arrays may affect subsequent evaluation of the interpolator.interpolateObject(a, b) ​Examples · Source · Returns an interpolator between the two objects a and b.jsd3.interpolateObject({x: 0, y: 1}, {x: 1, y: 10, z: 100})(0.5) // {x: 0.5, y: 5.5, z: 100}Internally, an object template is created that has the same properties as b. For each property in b, if there exists a corresponding property in a, a generic interpolator is created for the two elements using interpolate. If there is no such property, the static value from b is used in the template. Then, for the given parameter t, the template's embedded interpolators are evaluated and the updated object template is then returned.For example, if a is the object {x: 0, y: 1} and b is the object {x: 1, y: 10, z: 100}, the result of the interpolator for t = 0.5 is the object {x: 0.5, y: 5.5, z: 100}.Object interpolation is particularly useful for dataspace interpolation, where data is interpolated rather than attribute values. For example, you can interpolate an object which describes an arc in a pie chart, and then use arc to compute the new SVG path data.CAUTIONNo defensive copy of the template object is created; modifications of the returned object may adversely affect subsequent evaluation of the interpolator. No copy is made for performance reasons; interpolators are often part of the inner loop of animated transitions.interpolateBasis(values) ​Examples · Source · Returns a uniform nonrational B-spline interpolator through the specified array of values, which must be numbers.jsd3.interpolateBasis([0, 0.1, 0.4, 1])(0.5) // 0.2604166666666667Implicit control points are generated such that the interpolator returns values[0] at t = 0 and values[values.length - 1] at t = 1. See also curveBasis and interpolateRgbBasis.interpolateBasisClosed(values) ​Examples · Source · Returns a uniform nonrational B-spline interpolator through the specified array of values, which must be numbers.jsd3.interpolateBasisClosed([0, 0.1, 0.4, 1])(0.5) // 0.45The control points are implicitly repeated such that the resulting one-dimensional spline has cyclical C² continuity when repeated around t in [0,1]. See also curveBasisClosed and interpolateRgbBasisClosed.interpolateDiscrete(values) ​Examples · Source · Returns a discrete interpolator for the given array of values.jsd3.interpolateDiscrete(["red", "blue", "green"])(0.5) // "blue"The returned interpolator maps t in [0, 1 / n) to values[0], t in [1 / n, 2 / n) to values[1], and so on, where n = values.length. In effect, this is a lightweight quantize scale with a fixed domain of [0, 1].quantize(interpolator, n) ​Examples · Source · Returns n uniformly-spaced samples from the specified interpolator, where n is an integer greater than one.jsd3.quantize(d3.interpolate("red", "blue"), 4) // ["rgb(255, 0, 0)", "rgb(170, 0, 85)", "rgb(85, 0, 170)", "rgb(0, 0, 255)"]The first sample is always at t = 0, and the last sample is always at t = 1. This can be useful in generating a fixed number of samples from a given interpolator, such as to derive the range of a quantize scale from a continuous interpolator.CAUTIONThis method will not work with interpolators that do not return defensive copies of their output, such as interpolateArray, interpolateDate and interpolateObject. For those interpolators, you must wrap the interpolator and create a copy for each returned value.piecewise(interpolate, values) ​Examples · Source · Returns a piecewise interpolator, composing interpolators for each adjacent pair of values.jsd3.piecewise(d3.interpolateRgb.gamma(2.2), ["red", "green", "blue"])If interpolate is not specified, defaults to interpolate.jsd3.piecewise(["red", "green", "blue"])The returned interpolator maps t in [0, 1 / (n - 1)] to interpolate(values[0], values[1]), t in [1 / (n - 1), 2 / (n - 1)] to interpolate(values[1], values[2]), and so on, where n = values.length. In effect, this is a lightweight linear scale.\n\nSearchK7.9.0GitHub️ 110.0kOn this pageValue interpolation ​These are the most general interpolators, suitable for most values.interpolate(a, b) ​Examples · Source · Returns an interpolator between the two arbitrary values a and b.jsd3.interpolate("red", "blue")(0.5) // "rgb(128, 0, 128)"The interpolator implementation is based on the type of the end value b, using the following algorithm:If b is null, undefined or a boolean, use the constant b.If b is a number, use interpolateNumber.If b is a color or a string coercible to a color, use interpolateRgb.If b is a date, use interpolateDate.If b is a string, use interpolateString.If b is a typed array of numbers, use interpolateNumberArray.If b is a generic array, use interpolateArray.If b is coercible to a number, use interpolateNumber.Use interpolateObject.Based on the chosen interpolator, a is coerced to the suitable corresponding type.interpolateNumber(a, b) ​Examples · Source · Returns an interpolator between the two numbers a and b.jsd3.interpolateNumber(20, 620)(0.8) // 500The returned interpolator is equivalent to:jsfunction interpolator(t) {
  return a * (1 - t) + b * t;
}CAUTIONAvoid interpolating to or from the number zero when the interpolator is used to generate a string. When very small values are stringified, they may be converted to scientific notation, which is an invalid attribute or style property value in older browsers. For example, the number 0.0000001 is converted to the string "1e-7". This is particularly noticeable with interpolating opacity. To avoid scientific notation, start or end the transition at 1e-6: the smallest value that is not stringified in scientific notation.interpolateRound(a, b) ​Examples · Source · Returns an interpolator between the two numbers a and b.jsd3.interpolateRound(20, 620)(0.821) // 513The interpolator is similar to interpolateNumber except it will round the resulting value to the nearest integer.interpolateString(a, b) ​Examples · Source · Returns an interpolator between the two strings a and b.jsd3.interpolateString("20px", "32px")(0.5) // "26px"The string interpolator finds numbers embedded in a and b, where each number is of the form understood by JavaScript. A few examples of numbers that will be detected within a string: -1, 42, 3.14159, and 6.0221413e+23.For each number embedded in b, the interpolator will attempt to find a corresponding number in a. If a corresponding number is found, a numeric interpolator is created using interpolateNumber. The remaining parts of the string b are used as a template: the static parts of the string b remain constant for the interpolation, with the interpolated numeric values embedded in the template.For example, if a is "300 12px sans-serif", and b is "500 36px Comic-Sans", two embedded numbers are found. The remaining static parts (of string b) are a space between the two numbers (" "), and the suffix ("px Comic-Sans"). The result of the interpolator at t = 0.5 is "400 24px Comic-Sans".interpolateDate(a, b) ​Examples · Source · Returns an interpolator between the two dates a and b.jsd3.interpolateDate(new Date("2014-01-01"), new Date("2024-01-01"))(0.5) // 2019-01-01CAUTIONNo defensive copy of the returned date is created; the same Date instance is returned for every evaluation of the interpolator. No copy is made for performance reasons, as interpolators are often part of the inner loop of animated transitions.interpolateArray(a, b) ​Examples · Source · Returns an interpolator between the two arrays a and b.jsd3.interpolateArray([0, 0, 0], [1, 2, 3])(0.5) // [0.5, 1, 1.5]If b is a typed array (e.g., Float64Array), interpolateNumberArray is called instead.Internally, an array template is created that is the same length as b. For each element in b, if there exists a corresponding element in a, a generic interpolator is created for the two elements using interpolate. If there is no such element, the static value from b is used in the template. Then, for the given parameter t, the template’s embedded interpolators are evaluated. The updated array template is then returned.For example, if a is the array [0, 1] and b is the array [1, 10, 100], then the result of the interpolator for t = 0.5 is the array [0.5, 5.5, 100].CAUTIONNo defensive copy of the template array is created; modifications of the returned array may adversely affect subsequent evaluation of the interpolator. No copy is made for performance reasons; interpolators are often part of the inner loop of animated transitions.interpolateNumberArray(a, b) ​Examples · Source · Returns an interpolator between the two arrays of numbers a and b.jsd3.interpolateNumberArray([0, 1], Float64Array.of(1, 3))(0.5) // [0.5, 2]Internally, an array template is created that is the same type and length as b. For each element in b, if there exists a corresponding element in a, the values are directly interpolated in the array template. If there is no such element, the static value from b is copied. The updated array template is then returned.CAUTIONNo defensive copy is made of the template array and the arguments a and b; modifications of these arrays may affect subsequent evaluation of the interpolator.interpolateObject(a, b) ​Examples · Source · Returns an interpolator between the two objects a and b.jsd3.interpolateObject({x: 0, y: 1}, {x: 1, y: 10, z: 100})(0.5) // {x: 0.5, y: 5.5, z: 100}Internally, an object template is created that has the same properties as b. For each property in b, if there exists a corresponding property in a, a generic interpolator is created for the two elements using interpolate. If there is no such property, the static value from b is used in the template. Then, for the given parameter t, the template's embedded interpolators are evaluated and the updated object template is then returned.For example, if a is the object {x: 0, y: 1} and b is the object {x: 1, y: 10, z: 100}, the result of the interpolator for t = 0.5 is the object {x: 0.5, y: 5.5, z: 100}.Object interpolation is particularly useful for dataspace interpolation, where data is interpolated rather than attribute values. For example, you can interpolate an object which describes an arc in a pie chart, and then use arc to compute the new SVG path data.CAUTIONNo defensive copy of the template object is created; modifications of the returned object may adversely affect subsequent evaluation of the interpolator. No copy is made for performance reasons; interpolators are often part of the inner loop of animated transitions.interpolateBasis(values) ​Examples · Source · Returns a uniform nonrational B-spline interpolator through the specified array of values, which must be numbers.jsd3.interpolateBasis([0, 0.1, 0.4, 1])(0.5) // 0.2604166666666667Implicit control points are generated such that the interpolator returns values[0] at t = 0 and values[values.length - 1] at t = 1. See also curveBasis and interpolateRgbBasis.interpolateBasisClosed(values) ​Examples · Source · Returns a uniform nonrational B-spline interpolator through the specified array of values, which must be numbers.jsd3.interpolateBasisClosed([0, 0.1, 0.4, 1])(0.5) // 0.45The control points are implicitly repeated such that the resulting one-dimensional spline has cyclical C² continuity when repeated around t in [0,1]. See also curveBasisClosed and interpolateRgbBasisClosed.interpolateDiscrete(values) ​Examples · Source · Returns a discrete interpolator for the given array of values.jsd3.interpolateDiscrete(["red", "blue", "green"])(0.5) // "blue"The returned interpolator maps t in [0, 1 / n) to values[0], t in [1 / n, 2 / n) to values[1], and so on, where n = values.length. In effect, this is a lightweight quantize scale with a fixed domain of [0, 1].quantize(interpolator, n) ​Examples · Source · Returns n uniformly-spaced samples from the specified interpolator, where n is an integer greater than one.jsd3.quantize(d3.interpolate("red", "blue"), 4) // ["rgb(255, 0, 0)", "rgb(170, 0, 85)", "rgb(85, 0, 170)", "rgb(0, 0, 255)"]The first sample is always at t = 0, and the last sample is always at t = 1. This can be useful in generating a fixed number of samples from a given interpolator, such as to derive the range of a quantize scale from a continuous interpolator.CAUTIONThis method will not work with interpolators that do not return defensive copies of their output, such as interpolateArray, interpolateDate and interpolateObject. For those interpolators, you must wrap the interpolator and create a copy for each returned value.piecewise(interpolate, values) ​Examples · Source · Returns a piecewise interpolator, composing interpolators for each adjacent pair of values.jsd3.piecewise(d3.interpolateRgb.gamma(2.2), ["red", "green", "blue"])If interpolate is not specified, defaults to interpolate.jsd3.piecewise(["red", "green", "blue"])The returned interpolator maps t in [0, 1 / (n - 1)] to interpolate(values[0], values[1]), t in [1 / (n - 1), 2 / (n - 1)] to interpolate(values[1], values[2]), and so on, where n = values.length. In effect, this is a lightweight linear scale.PagerPrevious paged3-interpolateNext pageColor interpolation\n\nValue interpolation ​These are the most general interpolators, suitable for most values.interpolate(a, b) ​Examples · Source · Returns an interpolator between the two arbitrary values a and b.jsd3.interpolate("red", "blue")(0.5) // "rgb(128, 0, 128)"The interpolator implementation is based on the type of the end value b, using the following algorithm:If b is null, undefined or a boolean, use the constant b.If b is a number, use interpolateNumber.If b is a color or a string coercible to a color, use interpolateRgb.If b is a date, use interpolateDate.If b is a string, use interpolateString.If b is a typed array of numbers, use interpolateNumberArray.If b is a generic array, use interpolateArray.If b is coercible to a number, use interpolateNumber.Use interpolateObject.Based on the chosen interpolator, a is coerced to the suitable corresponding type.interpolateNumber(a, b) ​Examples · Source · Returns an interpolator between the two numbers a and b.jsd3.interpolateNumber(20, 620)(0.8) // 500The returned interpolator is equivalent to:jsfunction interpolator(t) {
  return a * (1 - t) + b * t;
}CAUTIONAvoid interpolating to or from the number zero when the interpolator is used to generate a string. When very small values are stringified, they may be converted to scientific notation, which is an invalid attribute or style property value in older browsers. For example, the number 0.0000001 is converted to the string "1e-7". This is particularly noticeable with interpolating opacity. To avoid scientific notation, start or end the transition at 1e-6: the smallest value that is not stringified in scientific notation.interpolateRound(a, b) ​Examples · Source · Returns an interpolator between the two numbers a and b.jsd3.interpolateRound(20, 620)(0.821) // 513The interpolator is similar to interpolateNumber except it will round the resulting value to the nearest integer.interpolateString(a, b) ​Examples · Source · Returns an interpolator between the two strings a and b.jsd3.interpolateString("20px", "32px")(0.5) // "26px"The string interpolator finds numbers embedded in a and b, where each number is of the form understood by JavaScript. A few examples of numbers that will be detected within a string: -1, 42, 3.14159, and 6.0221413e+23.For each number embedded in b, the interpolator will attempt to find a corresponding number in a. If a corresponding number is found, a numeric interpolator is created using interpolateNumber. The remaining parts of the string b are used as a template: the static parts of the string b remain constant for the interpolation, with the interpolated numeric values embedded in the template.For example, if a is "300 12px sans-serif", and b is "500 36px Comic-Sans", two embedded numbers are found. The remaining static parts (of string b) are a space between the two numbers (" "), and the suffix ("px Comic-Sans"). The result of the interpolator at t = 0.5 is "400 24px Comic-Sans".interpolateDate(a, b) ​Examples · Source · Returns an interpolator between the two dates a and b.jsd3.interpolateDate(new Date("2014-01-01"), new Date("2024-01-01"))(0.5) // 2019-01-01CAUTIONNo defensive copy of the returned date is created; the same Date instance is returned for every evaluation of the interpolator. No copy is made for performance reasons, as interpolators are often part of the inner loop of animated transitions.interpolateArray(a, b) ​Examples · Source · Returns an interpolator between the two arrays a and b.jsd3.interpolateArray([0, 0, 0], [1, 2, 3])(0.5) // [0.5, 1, 1.5]If b is a typed array (e.g., Float64Array), interpolateNumberArray is called instead.Internally, an array template is created that is the same length as b. For each element in b, if there exists a corresponding element in a, a generic interpolator is created for the two elements using interpolate. If there is no such element, the static value from b is used in the template. Then, for the given parameter t, the template’s embedded interpolators are evaluated. The updated array template is then returned.For example, if a is the array [0, 1] and b is the array [1, 10, 100], then the result of the interpolator for t = 0.5 is the array [0.5, 5.5, 100].CAUTIONNo defensive copy of the template array is created; modifications of the returned array may adversely affect subsequent evaluation of the interpolator. No copy is made for performance reasons; interpolators are often part of the inner loop of animated transitions.interpolateNumberArray(a, b) ​Examples · Source · Returns an interpolator between the two arrays of numbers a and b.jsd3.interpolateNumberArray([0, 1], Float64Array.of(1, 3))(0.5) // [0.5, 2]Internally, an array template is created that is the same type and length as b. For each element in b, if there exists a corresponding element in a, the values are directly interpolated in the array template. If there is no such element, the static value from b is copied. The updated array template is then returned.CAUTIONNo defensive copy is made of the template array and the arguments a and b; modifications of these arrays may affect subsequent evaluation of the interpolator.interpolateObject(a, b) ​Examples · Source · Returns an interpolator between the two objects a and b.jsd3.interpolateObject({x: 0, y: 1}, {x: 1, y: 10, z: 100})(0.5) // {x: 0.5, y: 5.5, z: 100}Internally, an object template is created that has the same properties as b. For each property in b, if there exists a corresponding property in a, a generic interpolator is created for the two elements using interpolate. If there is no such property, the static value from b is used in the template. Then, for the given parameter t, the template's embedded interpolators are evaluated and the updated object template is then returned.For example, if a is the object {x: 0, y: 1} and b is the object {x: 1, y: 10, z: 100}, the result of the interpolator for t = 0.5 is the object {x: 0.5, y: 5.5, z: 100}.Object interpolation is particularly useful for dataspace interpolation, where data is interpolated rather than attribute values. For example, you can interpolate an object which describes an arc in a pie chart, and then use arc to compute the new SVG path data.CAUTIONNo defensive copy of the template object is created; modifications of the returned object may adversely affect subsequent evaluation of the interpolator. No copy is made for performance reasons; interpolators are often part of the inner loop of animated transitions.interpolateBasis(values) ​Examples · Source · Returns a uniform nonrational B-spline interpolator through the specified array of values, which must be numbers.jsd3.interpolateBasis([0, 0.1, 0.4, 1])(0.5) // 0.2604166666666667Implicit control points are generated such that the interpolator returns values[0] at t = 0 and values[values.length - 1] at t = 1. See also curveBasis and interpolateRgbBasis.interpolateBasisClosed(values) ​Examples · Source · Returns a uniform nonrational B-spline interpolator through the specified array of values, which must be numbers.jsd3.interpolateBasisClosed([0, 0.1, 0.4, 1])(0.5) // 0.45The control points are implicitly repeated such that the resulting one-dimensional spline has cyclical C² continuity when repeated around t in [0,1]. See also curveBasisClosed and interpolateRgbBasisClosed.interpolateDiscrete(values) ​Examples · Source · Returns a discrete interpolator for the given array of values.jsd3.interpolateDiscrete(["red", "blue", "green"])(0.5) // "blue"The returned interpolator maps t in [0, 1 / n) to values[0], t in [1 / n, 2 / n) to values[1], and so on, where n = values.length. In effect, this is a lightweight quantize scale with a fixed domain of [0, 1].quantize(interpolator, n) ​Examples · Source · Returns n uniformly-spaced samples from the specified interpolator, where n is an integer greater than one.jsd3.quantize(d3.interpolate("red", "blue"), 4) // ["rgb(255, 0, 0)", "rgb(170, 0, 85)", "rgb(85, 0, 170)", "rgb(0, 0, 255)"]The first sample is always at t = 0, and the last sample is always at t = 1. This can be useful in generating a fixed number of samples from a given interpolator, such as to derive the range of a quantize scale from a continuous interpolator.CAUTIONThis method will not work with interpolators that do not return defensive copies of their output, such as interpolateArray, interpolateDate and interpolateObject. For those interpolators, you must wrap the interpolator and create a copy for each returned value.piecewise(interpolate, values) ​Examples · Source · Returns a piecewise interpolator, composing interpolators for each adjacent pair of values.jsd3.piecewise(d3.interpolateRgb.gamma(2.2), ["red", "green", "blue"])If interpolate is not specified, defaults to interpolate.jsd3.piecewise(["red", "green", "blue"])The returned interpolator maps t in [0, 1 / (n - 1)] to interpolate(values[0], values[1]), t in [1 / (n - 1), 2 / (n - 1)] to interpolate(values[1], values[2]), and so on, where n = values.length. In effect, this is a lightweight linear scale.\n\n\n\nColor interpolation ​Interpolators for colors in various color spaces.interpolateRgb(a, b) ​jsd3.interpolateRgb("purple", "orange")Examples · Source · Returns an RGB color space interpolator between the two colors a and b with a configurable gamma. If the gamma is not specified, it defaults to 1.0. The colors a and b need not be in RGB; they will be converted to RGB using d3.rgb. The return value of the interpolator is an RGB string.interpolateRgbBasis(colors) ​jsd3.interpolateRgbBasis(["purple", "green", "orange"])Examples · Source · Returns a uniform nonrational B-spline interpolator through the specified array of colors, which are converted to RGB color space. Implicit control points are generated such that the interpolator returns colors[0] at t = 0 and colors[colors.length - 1] at t = 1. Opacity interpolation is not currently supported. See also d3.interpolateBasis, and see d3-scale-chromatic for examples.interpolateRgbBasisClosed(colors) ​jsd3.interpolateRgbBasisClosed(["purple", "green", "orange"])Examples · Source · Returns a uniform nonrational B-spline interpolator through the specified array of colors, which are converted to RGB color space. The control points are implicitly repeated such that the resulting spline has cyclical C² continuity when repeated around t in [0,1]; this is useful, for example, to create cyclical color scales. Opacity interpolation is not currently supported. See also d3.interpolateBasisClosed, and see d3-scale-chromatic for examples.interpolateHsl(a, b) ​jsd3.interpolateHsl("purple", "orange")Examples · Source · Returns an HSL color space interpolator between the two colors a and b. The colors a and b need not be in HSL; they will be converted to HSL using d3.hsl. If either color’s hue or saturation is NaN, the opposing color’s channel value is used. The shortest path between hues is used. The return value of the interpolator is an RGB string.interpolateHslLong(a, b) ​jsd3.interpolateHslLong("purple", "orange")Examples · Source · Like interpolateHsl, but does not use the shortest path between hues.interpolateLab(a, b) ​jsd3.interpolateLab("purple", "orange")Examples · Source · Returns a CIELAB color space interpolator between the two colors a and b. The colors a and b need not be in CIELAB; they will be converted to CIELAB using d3.lab. The return value of the interpolator is an RGB string.interpolateHcl(a, b) ​jsd3.interpolateHcl("purple", "orange")Examples · Source · Returns a CIELChab color space interpolator between the two colors a and b. The colors a and b need not be in CIELChab; they will be converted to CIELChab using d3.hcl. If either color’s hue or chroma is NaN, the opposing color’s channel value is used. The shortest path between hues is used. The return value of the interpolator is an RGB string.interpolateHclLong(a, b) ​jsd3.interpolateHclLong("purple", "orange")Examples · Source · Like interpolateHcl, but does not use the shortest path between hues.interpolateCubehelix(a, b) ​jsd3.interpolateCubehelix("purple", "orange")jsd3.interpolateCubehelix.gamma(3)("purple", "orange")Examples · Source · Returns a Cubehelix color space interpolator between the two colors a and b using a configurable gamma. If the gamma is not specified, it defaults to 1.0. The colors a and b need not be in Cubehelix; they will be converted to Cubehelix using d3.cubehelix. If either color’s hue or saturation is NaN, the opposing color’s channel value is used. The shortest path between hues is used. The return value of the interpolator is an RGB string.interpolateCubehelixLong(a, b) ​jsd3.interpolateCubehelixLong("purple", "orange")jsd3.interpolateCubehelixLong.gamma(3)("purple", "orange")Examples · Source · Like interpolateCubehelix, but does not use the shortest path between hues.interpolateColor.gamma(gamma) ​jsd3.interpolateRgb.gamma(2.2)("purple", "orange")Given that interpolate is one of interpolateRgb, interpolateCubehelix or interpolateCubehelixLong, returns a new interpolator factory of the same type using the specified gamma. See Eric Brasseur’s article, Gamma error in picture scaling, for more on gamma correction.interpolateHue(a, b) ​jsd3.interpolateHue(20, 340)(0.5) // 0Examples · Source · Returns an interpolator between the two hue angles a and b. If either hue is NaN, the opposing value is used. The shortest path between hues is used. The return value of the interpolator is a number in [0, 360).Whereas standard interpolators blend from a starting value a at t = 0 to an ending value b at t = 1, spline interpolators smoothly blend multiple input values for t in [0,1] using piecewise polynomial functions. Only cubic uniform nonrational B-splines are currently supported, also known as basis splines.\n\nSearchK7.9.0GitHub️ 110.0kOn this pageColor interpolation ​Interpolators for colors in various color spaces.interpolateRgb(a, b) ​jsd3.interpolateRgb("purple", "orange")Examples · Source · Returns an RGB color space interpolator between the two colors a and b with a configurable gamma. If the gamma is not specified, it defaults to 1.0. The colors a and b need not be in RGB; they will be converted to RGB using d3.rgb. The return value of the interpolator is an RGB string.interpolateRgbBasis(colors) ​jsd3.interpolateRgbBasis(["purple", "green", "orange"])Examples · Source · Returns a uniform nonrational B-spline interpolator through the specified array of colors, which are converted to RGB color space. Implicit control points are generated such that the interpolator returns colors[0] at t = 0 and colors[colors.length - 1] at t = 1. Opacity interpolation is not currently supported. See also d3.interpolateBasis, and see d3-scale-chromatic for examples.interpolateRgbBasisClosed(colors) ​jsd3.interpolateRgbBasisClosed(["purple", "green", "orange"])Examples · Source · Returns a uniform nonrational B-spline interpolator through the specified array of colors, which are converted to RGB color space. The control points are implicitly repeated such that the resulting spline has cyclical C² continuity when repeated around t in [0,1]; this is useful, for example, to create cyclical color scales. Opacity interpolation is not currently supported. See also d3.interpolateBasisClosed, and see d3-scale-chromatic for examples.interpolateHsl(a, b) ​jsd3.interpolateHsl("purple", "orange")Examples · Source · Returns an HSL color space interpolator between the two colors a and b. The colors a and b need not be in HSL; they will be converted to HSL using d3.hsl. If either color’s hue or saturation is NaN, the opposing color’s channel value is used. The shortest path between hues is used. The return value of the interpolator is an RGB string.interpolateHslLong(a, b) ​jsd3.interpolateHslLong("purple", "orange")Examples · Source · Like interpolateHsl, but does not use the shortest path between hues.interpolateLab(a, b) ​jsd3.interpolateLab("purple", "orange")Examples · Source · Returns a CIELAB color space interpolator between the two colors a and b. The colors a and b need not be in CIELAB; they will be converted to CIELAB using d3.lab. The return value of the interpolator is an RGB string.interpolateHcl(a, b) ​jsd3.interpolateHcl("purple", "orange")Examples · Source · Returns a CIELChab color space interpolator between the two colors a and b. The colors a and b need not be in CIELChab; they will be converted to CIELChab using d3.hcl. If either color’s hue or chroma is NaN, the opposing color’s channel value is used. The shortest path between hues is used. The return value of the interpolator is an RGB string.interpolateHclLong(a, b) ​jsd3.interpolateHclLong("purple", "orange")Examples · Source · Like interpolateHcl, but does not use the shortest path between hues.interpolateCubehelix(a, b) ​jsd3.interpolateCubehelix("purple", "orange")jsd3.interpolateCubehelix.gamma(3)("purple", "orange")Examples · Source · Returns a Cubehelix color space interpolator between the two colors a and b using a configurable gamma. If the gamma is not specified, it defaults to 1.0. The colors a and b need not be in Cubehelix; they will be converted to Cubehelix using d3.cubehelix. If either color’s hue or saturation is NaN, the opposing color’s channel value is used. The shortest path between hues is used. The return value of the interpolator is an RGB string.interpolateCubehelixLong(a, b) ​jsd3.interpolateCubehelixLong("purple", "orange")jsd3.interpolateCubehelixLong.gamma(3)("purple", "orange")Examples · Source · Like interpolateCubehelix, but does not use the shortest path between hues.interpolateColor.gamma(gamma) ​jsd3.interpolateRgb.gamma(2.2)("purple", "orange")Given that interpolate is one of interpolateRgb, interpolateCubehelix or interpolateCubehelixLong, returns a new interpolator factory of the same type using the specified gamma. See Eric Brasseur’s article, Gamma error in picture scaling, for more on gamma correction.interpolateHue(a, b) ​jsd3.interpolateHue(20, 340)(0.5) // 0Examples · Source · Returns an interpolator between the two hue angles a and b. If either hue is NaN, the opposing value is used. The shortest path between hues is used. The return value of the interpolator is a number in [0, 360).Whereas standard interpolators blend from a starting value a at t = 0 to an ending value b at t = 1, spline interpolators smoothly blend multiple input values for t in [0,1] using piecewise polynomial functions. Only cubic uniform nonrational B-splines are currently supported, also known as basis splines.PagerPrevious pageValue interpolationNext pageTransform interpolation\n\nColor interpolation ​Interpolators for colors in various color spaces.interpolateRgb(a, b) ​jsd3.interpolateRgb("purple", "orange")Examples · Source · Returns an RGB color space interpolator between the two colors a and b with a configurable gamma. If the gamma is not specified, it defaults to 1.0. The colors a and b need not be in RGB; they will be converted to RGB using d3.rgb. The return value of the interpolator is an RGB string.interpolateRgbBasis(colors) ​jsd3.interpolateRgbBasis(["purple", "green", "orange"])Examples · Source · Returns a uniform nonrational B-spline interpolator through the specified array of colors, which are converted to RGB color space. Implicit control points are generated such that the interpolator returns colors[0] at t = 0 and colors[colors.length - 1] at t = 1. Opacity interpolation is not currently supported. See also d3.interpolateBasis, and see d3-scale-chromatic for examples.interpolateRgbBasisClosed(colors) ​jsd3.interpolateRgbBasisClosed(["purple", "green", "orange"])Examples · Source · Returns a uniform nonrational B-spline interpolator through the specified array of colors, which are converted to RGB color space. The control points are implicitly repeated such that the resulting spline has cyclical C² continuity when repeated around t in [0,1]; this is useful, for example, to create cyclical color scales. Opacity interpolation is not currently supported. See also d3.interpolateBasisClosed, and see d3-scale-chromatic for examples.interpolateHsl(a, b) ​jsd3.interpolateHsl("purple", "orange")Examples · Source · Returns an HSL color space interpolator between the two colors a and b. The colors a and b need not be in HSL; they will be converted to HSL using d3.hsl. If either color’s hue or saturation is NaN, the opposing color’s channel value is used. The shortest path between hues is used. The return value of the interpolator is an RGB string.interpolateHslLong(a, b) ​jsd3.interpolateHslLong("purple", "orange")Examples · Source · Like interpolateHsl, but does not use the shortest path between hues.interpolateLab(a, b) ​jsd3.interpolateLab("purple", "orange")Examples · Source · Returns a CIELAB color space interpolator between the two colors a and b. The colors a and b need not be in CIELAB; they will be converted to CIELAB using d3.lab. The return value of the interpolator is an RGB string.interpolateHcl(a, b) ​jsd3.interpolateHcl("purple", "orange")Examples · Source · Returns a CIELChab color space interpolator between the two colors a and b. The colors a and b need not be in CIELChab; they will be converted to CIELChab using d3.hcl. If either color’s hue or chroma is NaN, the opposing color’s channel value is used. The shortest path between hues is used. The return value of the interpolator is an RGB string.interpolateHclLong(a, b) ​jsd3.interpolateHclLong("purple", "orange")Examples · Source · Like interpolateHcl, but does not use the shortest path between hues.interpolateCubehelix(a, b) ​jsd3.interpolateCubehelix("purple", "orange")jsd3.interpolateCubehelix.gamma(3)("purple", "orange")Examples · Source · Returns a Cubehelix color space interpolator between the two colors a and b using a configurable gamma. If the gamma is not specified, it defaults to 1.0. The colors a and b need not be in Cubehelix; they will be converted to Cubehelix using d3.cubehelix. If either color’s hue or saturation is NaN, the opposing color’s channel value is used. The shortest path between hues is used. The return value of the interpolator is an RGB string.interpolateCubehelixLong(a, b) ​jsd3.interpolateCubehelixLong("purple", "orange")jsd3.interpolateCubehelixLong.gamma(3)("purple", "orange")Examples · Source · Like interpolateCubehelix, but does not use the shortest path between hues.interpolateColor.gamma(gamma) ​jsd3.interpolateRgb.gamma(2.2)("purple", "orange")Given that interpolate is one of interpolateRgb, interpolateCubehelix or interpolateCubehelixLong, returns a new interpolator factory of the same type using the specified gamma. See Eric Brasseur’s article, Gamma error in picture scaling, for more on gamma correction.interpolateHue(a, b) ​jsd3.interpolateHue(20, 340)(0.5) // 0Examples · Source · Returns an interpolator between the two hue angles a and b. If either hue is NaN, the opposing value is used. The shortest path between hues is used. The return value of the interpolator is a number in [0, 360).Whereas standard interpolators blend from a starting value a at t = 0 to an ending value b at t = 1, spline interpolators smoothly blend multiple input values for t in [0,1] using piecewise polynomial functions. Only cubic uniform nonrational B-splines are currently supported, also known as basis splines.\n\n\n\nTransform interpolation ​Interpolators for CSS and SVG transforms. The interpolation method is standardized by CSS: see matrix decomposition for animation.interpolateTransformCss(a, b) ​jsd3.interpolateTransformCss("translateY(12px) scale(2)", "translateX(30px) rotate(5deg)")(0.5) // "translate(15px,6px) rotate(2.5deg) scale(1.5,1.5)"Examples · Source · Returns an interpolator between the two 2D CSS transforms represented by a and b. Each transform is decomposed to a standard representation of translate, rotate, x-skew and scale; these component transformations are then interpolated.interpolateTransformSvg(a, b) ​jsd3.interpolateTransformSvg("skewX(-60)", "skewX(60) translate(280,0)") // "translate(140,0) skewX(0)"Examples · Source · Returns an interpolator between the two 2D SVG transforms represented by a and b. Each transform is decomposed to a standard representation of translate, rotate, x-skew and scale; these component transformations are then interpolated.\n\nSearchK7.9.0GitHub️ 110.0kOn this pageTransform interpolation ​Interpolators for CSS and SVG transforms. The interpolation method is standardized by CSS: see matrix decomposition for animation.interpolateTransformCss(a, b) ​jsd3.interpolateTransformCss("translateY(12px) scale(2)", "translateX(30px) rotate(5deg)")(0.5) // "translate(15px,6px) rotate(2.5deg) scale(1.5,1.5)"Examples · Source · Returns an interpolator between the two 2D CSS transforms represented by a and b. Each transform is decomposed to a standard representation of translate, rotate, x-skew and scale; these component transformations are then interpolated.interpolateTransformSvg(a, b) ​jsd3.interpolateTransformSvg("skewX(-60)", "skewX(60) translate(280,0)") // "translate(140,0) skewX(0)"Examples · Source · Returns an interpolator between the two 2D SVG transforms represented by a and b. Each transform is decomposed to a standard representation of translate, rotate, x-skew and scale; these component transformations are then interpolated.PagerPrevious pageColor interpolationNext pageZoom interpolation\n\nTransform interpolation ​Interpolators for CSS and SVG transforms. The interpolation method is standardized by CSS: see matrix decomposition for animation.interpolateTransformCss(a, b) ​jsd3.interpolateTransformCss("translateY(12px) scale(2)", "translateX(30px) rotate(5deg)")(0.5) // "translate(15px,6px) rotate(2.5deg) scale(1.5,1.5)"Examples · Source · Returns an interpolator between the two 2D CSS transforms represented by a and b. Each transform is decomposed to a standard representation of translate, rotate, x-skew and scale; these component transformations are then interpolated.interpolateTransformSvg(a, b) ​jsd3.interpolateTransformSvg("skewX(-60)", "skewX(60) translate(280,0)") // "translate(140,0) skewX(0)"Examples · Source · Returns an interpolator between the two 2D SVG transforms represented by a and b. Each transform is decomposed to a standard representation of translate, rotate, x-skew and scale; these component transformations are then interpolated.\n\n\n\nZoom interpolation ​An interpolator for zooming smoothly between two views of a two-dimensional plane based on “Smooth and efficient zooming and panning” by Jarke J. van Wijk and Wim A.A. Nuij.interpolateZoom(a, b) ​jsd3.interpolateZoom([30, 30, 40], [135, 85, 60])(0.5) // [72, 52, 126.04761005270991]Examples · Source · Returns an interpolator between the two views a and b. Each view is defined as an array of three numbers: cx, cy and width. The first two coordinates cx, cy represent the center of the viewport; the last coordinate width represents the size of the viewport.The returned interpolator exposes a interpolate.duration property which encodes the recommended transition duration in milliseconds. This duration is based on the path length of the curved trajectory through xy space. If you want a slower or faster transition, multiply this by an arbitrary scale factor (V as described in the original paper).interpolateZoom.rho(rho) ​jsd3.interpolateZoom.rho(0.5)([30, 30, 40], [135, 85, 60])(0.5) // [72, 52, 51.09549882328188]Source · Given a zoom interpolator, returns a new zoom interpolator using the specified curvature rho. When rho is close to 0, the interpolator is almost linear. The default curvature is sqrt(2).\n\nSearchK7.9.0GitHub️ 110.0kOn this pageZoom interpolation ​An interpolator for zooming smoothly between two views of a two-dimensional plane based on “Smooth and efficient zooming and panning” by Jarke J. van Wijk and Wim A.A. Nuij.interpolateZoom(a, b) ​jsd3.interpolateZoom([30, 30, 40], [135, 85, 60])(0.5) // [72, 52, 126.04761005270991]Examples · Source · Returns an interpolator between the two views a and b. Each view is defined as an array of three numbers: cx, cy and width. The first two coordinates cx, cy represent the center of the viewport; the last coordinate width represents the size of the viewport.The returned interpolator exposes a interpolate.duration property which encodes the recommended transition duration in milliseconds. This duration is based on the path length of the curved trajectory through xy space. If you want a slower or faster transition, multiply this by an arbitrary scale factor (V as described in the original paper).interpolateZoom.rho(rho) ​jsd3.interpolateZoom.rho(0.5)([30, 30, 40], [135, 85, 60])(0.5) // [72, 52, 51.09549882328188]Source · Given a zoom interpolator, returns a new zoom interpolator using the specified curvature rho. When rho is close to 0, the interpolator is almost linear. The default curvature is sqrt(2).PagerPrevious pageTransform interpolationNext paged3-contour\n\nZoom interpolation ​An interpolator for zooming smoothly between two views of a two-dimensional plane based on “Smooth and efficient zooming and panning” by Jarke J. van Wijk and Wim A.A. Nuij.interpolateZoom(a, b) ​jsd3.interpolateZoom([30, 30, 40], [135, 85, 60])(0.5) // [72, 52, 126.04761005270991]Examples · Source · Returns an interpolator between the two views a and b. Each view is defined as an array of three numbers: cx, cy and width. The first two coordinates cx, cy represent the center of the viewport; the last coordinate width represents the size of the viewport.The returned interpolator exposes a interpolate.duration property which encodes the recommended transition duration in milliseconds. This duration is based on the path length of the curved trajectory through xy space. If you want a slower or faster transition, multiply this by an arbitrary scale factor (V as described in the original paper).interpolateZoom.rho(rho) ​jsd3.interpolateZoom.rho(0.5)([30, 30, 40], [135, 85, 60])(0.5) // [72, 52, 51.09549882328188]Source · Given a zoom interpolator, returns a new zoom interpolator using the specified curvature rho. When rho is close to 0, the interpolator is almost linear. The default curvature is sqrt(2).\n\n\n\nd3-contour ​Fork ↗︎This module computes contour polygons by applying marching squares to a rectangular grid of numeric values. For example, the contours above show the topography of Maungawhau.See one of:ContoursDensity estimation\n\nSearchK7.9.0GitHub️ 110.0kOn this paged3-contour ​Fork ↗︎This module computes contour polygons by applying marching squares to a rectangular grid of numeric values. For example, the contours above show the topography of Maungawhau.See one of:ContoursDensity estimationPagerPrevious pageZoom interpolationNext pageContour polygons\n\nd3-contour ​Fork ↗︎This module computes contour polygons by applying marching squares to a rectangular grid of numeric values. For example, the contours above show the topography of Maungawhau.See one of:ContoursDensity estimation\n\n\n\nContour polygons ​For each threshold value, the contour generator constructs a GeoJSON MultiPolygon geometry object representing the area where the input values are greater than or equal to the threshold value. The geometry is in planar coordinates, where ⟨i + 0.5, j + 0.5⟩ corresponds to element i + jn in the input values array.Here is an example that loads a GeoTIFF of surface temperatures, and another that blurs a noisy monochrome PNG to produce smooth contours of cloud fraction:Since the contour polygons are GeoJSON, you can transform and display them using standard tools; see geoPath, geoProject and geoStitch, for example. Here the above contours of surface temperature are displayed in the Natural Earth projection:Contour plots can also visualize continuous functions by sampling. Here is the Goldstein–Price function (a test function for global optimization) and a trippy animation of sin(x + y)sin(x - y):contours() ​Examples · Source · Constructs a new contour generator with the default settings.jsconst contours = d3.contours()
    .size([width, height])
    .thresholds([0, 1, 2, 3, 4]);contours(values) ​Source · Computes the contours for the given array of values, returning an array of GeoJSON MultiPolygon geometry objects.jsconst polygons = contours(grid);Each geometry object represents the area where the input values are greater than or equal to the corresponding threshold value; the threshold value for each geometry object is exposed as geometry.value.The input values must be an array of length n×m where [n, m] is the contour generator’s size; furthermore, each values[i + jn] must represent the value at the position ⟨i, j⟩. For example, to construct a 256×256 grid for the Goldstein–Price function where -2 ≤ x ≤ 2 and -2 ≤ y ≤ 1:jsvar n = 256, m = 256, values = new Array(n * m);
for (var j = 0.5, k = 0; j < m; ++j) {
  for (var i = 0.5; i < n; ++i, ++k) {
    values[k] = goldsteinPrice(i / n * 4 - 2, 1 - j / m * 3);
  }
}jsfunction goldsteinPrice(x, y) {
  return (1 + Math.pow(x + y + 1, 2) * (19 - 14 * x + 3 * x * x - 14 * y + 6 * x * x + 3 * y * y))
      * (30 + Math.pow(2 * x - 3 * y, 2) * (18 - 32 * x + 12 * x * x + 48 * y - 36 * x * y + 27 * y * y));
}The returned geometry objects are typically passed to geoPath to display, using null or geoIdentity as the associated projection.contours.contour(values, threshold) ​Source · Computes a single contour, returning a GeoJSON MultiPolygon geometry object representing the area where the input values are greater than or equal to the given threshold value; the threshold value for each geometry object is exposed as geometry.value.The input values must be an array of length n×m where [n, m] is the contour generator’s size; furthermore, each values[i + jn] must represent the value at the position ⟨i, j⟩. See contours for an example.contours.size(size) ​Source · If size is specified, sets the expected size of the input values grid to the contour generator and returns the contour generator. The size is specified as an array [n, m] where n is the number of columns in the grid and m is the number of rows; n and m must be positive integers. If size is not specified, returns the current size which defaults to [1, 1].contours.smooth(smooth) ​Examples · Source · If smooth is specified, sets whether or not the generated contour polygons are smoothed using linear interpolation. If smooth is not specified, returns the current smoothing flag, which defaults to true.contours.thresholds(thresholds) ​Source · If thresholds is specified, sets the threshold generator to the specified function or array and returns this contour generator. If thresholds is not specified, returns the current threshold generator, which by default implements Sturges’ formula.Thresholds are defined as an array of values [x0, x1, …]. The first generated contour corresponds to the area where the input values are greater than or equal to x0; the second contour corresponds to the area where the input values are greater than or equal to x1, and so on. Thus, there is exactly one generated MultiPolygon geometry object for each specified threshold value; the threshold value is exposed as geometry.value.If a count is specified instead of an array of thresholds, then the input values’ extent will be uniformly divided into approximately count bins; see ticks.\n\nSearchK7.9.0GitHub️ 110.0kOn this pageContour polygons ​For each threshold value, the contour generator constructs a GeoJSON MultiPolygon geometry object representing the area where the input values are greater than or equal to the threshold value. The geometry is in planar coordinates, where ⟨i + 0.5, j + 0.5⟩ corresponds to element i + jn in the input values array.Here is an example that loads a GeoTIFF of surface temperatures, and another that blurs a noisy monochrome PNG to produce smooth contours of cloud fraction:Since the contour polygons are GeoJSON, you can transform and display them using standard tools; see geoPath, geoProject and geoStitch, for example. Here the above contours of surface temperature are displayed in the Natural Earth projection:Contour plots can also visualize continuous functions by sampling. Here is the Goldstein–Price function (a test function for global optimization) and a trippy animation of sin(x + y)sin(x - y):contours() ​Examples · Source · Constructs a new contour generator with the default settings.jsconst contours = d3.contours()
    .size([width, height])
    .thresholds([0, 1, 2, 3, 4]);contours(values) ​Source · Computes the contours for the given array of values, returning an array of GeoJSON MultiPolygon geometry objects.jsconst polygons = contours(grid);Each geometry object represents the area where the input values are greater than or equal to the corresponding threshold value; the threshold value for each geometry object is exposed as geometry.value.The input values must be an array of length n×m where [n, m] is the contour generator’s size; furthermore, each values[i + jn] must represent the value at the position ⟨i, j⟩. For example, to construct a 256×256 grid for the Goldstein–Price function where -2 ≤ x ≤ 2 and -2 ≤ y ≤ 1:jsvar n = 256, m = 256, values = new Array(n * m);
for (var j = 0.5, k = 0; j < m; ++j) {
  for (var i = 0.5; i < n; ++i, ++k) {
    values[k] = goldsteinPrice(i / n * 4 - 2, 1 - j / m * 3);
  }
}jsfunction goldsteinPrice(x, y) {
  return (1 + Math.pow(x + y + 1, 2) * (19 - 14 * x + 3 * x * x - 14 * y + 6 * x * x + 3 * y * y))
      * (30 + Math.pow(2 * x - 3 * y, 2) * (18 - 32 * x + 12 * x * x + 48 * y - 36 * x * y + 27 * y * y));
}The returned geometry objects are typically passed to geoPath to display, using null or geoIdentity as the associated projection.contours.contour(values, threshold) ​Source · Computes a single contour, returning a GeoJSON MultiPolygon geometry object representing the area where the input values are greater than or equal to the given threshold value; the threshold value for each geometry object is exposed as geometry.value.The input values must be an array of length n×m where [n, m] is the contour generator’s size; furthermore, each values[i + jn] must represent the value at the position ⟨i, j⟩. See contours for an example.contours.size(size) ​Source · If size is specified, sets the expected size of the input values grid to the contour generator and returns the contour generator. The size is specified as an array [n, m] where n is the number of columns in the grid and m is the number of rows; n and m must be positive integers. If size is not specified, returns the current size which defaults to [1, 1].contours.smooth(smooth) ​Examples · Source · If smooth is specified, sets whether or not the generated contour polygons are smoothed using linear interpolation. If smooth is not specified, returns the current smoothing flag, which defaults to true.contours.thresholds(thresholds) ​Source · If thresholds is specified, sets the threshold generator to the specified function or array and returns this contour generator. If thresholds is not specified, returns the current threshold generator, which by default implements Sturges’ formula.Thresholds are defined as an array of values [x0, x1, …]. The first generated contour corresponds to the area where the input values are greater than or equal to x0; the second contour corresponds to the area where the input values are greater than or equal to x1, and so on. Thus, there is exactly one generated MultiPolygon geometry object for each specified threshold value; the threshold value is exposed as geometry.value.If a count is specified instead of an array of thresholds, then the input values’ extent will be uniformly divided into approximately count bins; see ticks.PagerPrevious paged3-contourNext pageDensity estimation\n\nContour polygons ​For each threshold value, the contour generator constructs a GeoJSON MultiPolygon geometry object representing the area where the input values are greater than or equal to the threshold value. The geometry is in planar coordinates, where ⟨i + 0.5, j + 0.5⟩ corresponds to element i + jn in the input values array.Here is an example that loads a GeoTIFF of surface temperatures, and another that blurs a noisy monochrome PNG to produce smooth contours of cloud fraction:Since the contour polygons are GeoJSON, you can transform and display them using standard tools; see geoPath, geoProject and geoStitch, for example. Here the above contours of surface temperature are displayed in the Natural Earth projection:Contour plots can also visualize continuous functions by sampling. Here is the Goldstein–Price function (a test function for global optimization) and a trippy animation of sin(x + y)sin(x - y):contours() ​Examples · Source · Constructs a new contour generator with the default settings.jsconst contours = d3.contours()
    .size([width, height])
    .thresholds([0, 1, 2, 3, 4]);contours(values) ​Source · Computes the contours for the given array of values, returning an array of GeoJSON MultiPolygon geometry objects.jsconst polygons = contours(grid);Each geometry object represents the area where the input values are greater than or equal to the corresponding threshold value; the threshold value for each geometry object is exposed as geometry.value.The input values must be an array of length n×m where [n, m] is the contour generator’s size; furthermore, each values[i + jn] must represent the value at the position ⟨i, j⟩. For example, to construct a 256×256 grid for the Goldstein–Price function where -2 ≤ x ≤ 2 and -2 ≤ y ≤ 1:jsvar n = 256, m = 256, values = new Array(n * m);
for (var j = 0.5, k = 0; j < m; ++j) {
  for (var i = 0.5; i < n; ++i, ++k) {
    values[k] = goldsteinPrice(i / n * 4 - 2, 1 - j / m * 3);
  }
}jsfunction goldsteinPrice(x, y) {
  return (1 + Math.pow(x + y + 1, 2) * (19 - 14 * x + 3 * x * x - 14 * y + 6 * x * x + 3 * y * y))
      * (30 + Math.pow(2 * x - 3 * y, 2) * (18 - 32 * x + 12 * x * x + 48 * y - 36 * x * y + 27 * y * y));
}The returned geometry objects are typically passed to geoPath to display, using null or geoIdentity as the associated projection.contours.contour(values, threshold) ​Source · Computes a single contour, returning a GeoJSON MultiPolygon geometry object representing the area where the input values are greater than or equal to the given threshold value; the threshold value for each geometry object is exposed as geometry.value.The input values must be an array of length n×m where [n, m] is the contour generator’s size; furthermore, each values[i + jn] must represent the value at the position ⟨i, j⟩. See contours for an example.contours.size(size) ​Source · If size is specified, sets the expected size of the input values grid to the contour generator and returns the contour generator. The size is specified as an array [n, m] where n is the number of columns in the grid and m is the number of rows; n and m must be positive integers. If size is not specified, returns the current size which defaults to [1, 1].contours.smooth(smooth) ​Examples · Source · If smooth is specified, sets whether or not the generated contour polygons are smoothed using linear interpolation. If smooth is not specified, returns the current smoothing flag, which defaults to true.contours.thresholds(thresholds) ​Source · If thresholds is specified, sets the threshold generator to the specified function or array and returns this contour generator. If thresholds is not specified, returns the current threshold generator, which by default implements Sturges’ formula.Thresholds are defined as an array of values [x0, x1, …]. The first generated contour corresponds to the area where the input values are greater than or equal to x0; the second contour corresponds to the area where the input values are greater than or equal to x1, and so on. Thus, there is exactly one generated MultiPolygon geometry object for each specified threshold value; the threshold value is exposed as geometry.value.If a count is specified instead of an array of thresholds, then the input values’ extent will be uniformly divided into approximately count bins; see ticks.\n\n\n\nDensity estimation ​Contours can show the estimated density of point clouds, which is useful to avoid overplotting in large datasets. The contourDensity method implements fast two-dimensional kernel density estimation.Here is a scatterplot showing the relationship between the idle duration and eruption duration for Old Faithful:And here is a density contour plot showing the relationship between the weight and price of 53,940 diamonds:contourDensity() ​Examples · Source · Constructs a new density estimator with the default settings.density(data) ​Source · Estimates the density contours for the given array of data, returning an array of GeoJSON MultiPolygon geometry objects.Each geometry object represents the area where the estimated number of points per square pixel is greater than or equal to the corresponding threshold value; the threshold value for each geometry object is exposed as geometry.value. The returned geometry objects are typically passed to geoPath to display, using null or geoIdentity as the associated projection. See also contours.The x and y coordinate for each data point are computed using density.x and density.y. In addition, density.weight indicates the relative contribution of each data point (default 1). The generated contours are only accurate within the estimator’s defined size.density.x(x) ​Source · If x is specified, sets the x-coordinate accessor. If x is not specified, returns the current x-coordinate accessor, which defaults to:jsfunction x(d) {
  return d[0];
}density.y(y) ​Source · If y is specified, sets the y-coordinate accessor. If y is not specified, returns the current y-coordinate accessor, which defaults to:jsfunction y(d) {
  return d[1];
}density.weight(weight) ​Source · If weight is specified, sets the accessor for point weights. If weight is not specified, returns the current point weight accessor, which defaults to:jsfunction weight() {
  return 1;
}density.size(size) ​Source · If size is specified, sets the size of the density estimator to the specified bounds and returns the estimator. The size is specified as an array [width, height], where width is the maximum x-value and height is the maximum y-value. If size is not specified, returns the current size which defaults to [960, 500]. The estimated density contours are only accurate within the defined size.density.cellSize(cellSize) ​Source · If cellSize is specified, sets the size of individual cells in the underlying bin grid to the specified positive integer and returns the estimator. If cellSize is not specified, returns the current cell size, which defaults to 4. The cell size is rounded down to the nearest power of two. Smaller cells produce more detailed contour polygons, but are more expensive to compute.density.thresholds(thresholds) ​Source · If thresholds is specified, sets the threshold generator to the specified function or array and returns this contour generator. If thresholds is not specified, returns the current threshold generator, which by default generates about twenty nicely-rounded density thresholds.Thresholds are defined as an array of values [x0, x1, …]. The first generated density contour corresponds to the area where the estimated density is greater than or equal to x0; the second contour corresponds to the area where the estimated density is greater than or equal to x1, and so on. Thus, there is exactly one generated MultiPolygon geometry object for each specified threshold value; the threshold value is exposed as geometry.value. The first value x0 should typically be greater than zero.If a count is specified instead of an array of thresholds, then approximately count uniformly-spaced nicely-rounded thresholds will be generated; see ticks.density.bandwidth(bandwidth) ​Source · If bandwidth is specified, sets the bandwidth (the standard deviation) of the Gaussian kernel and returns the estimate. If bandwidth is not specified, returns the current bandwidth, which defaults to 20.4939…. The specified bandwidth is currently rounded to the nearest supported value by this implementation, and must be nonnegative.density.contours(data) ​Examples · Source · Return a contour(value) function that can be used to compute an arbitrary contour on the given data without needing to recompute the underlying grid. The returned contour function also exposes a contour.max value which represents the maximum density of the grid.\n\nSearchK7.9.0GitHub️ 110.0kOn this pageDensity estimation ​Contours can show the estimated density of point clouds, which is useful to avoid overplotting in large datasets. The contourDensity method implements fast two-dimensional kernel density estimation.Here is a scatterplot showing the relationship between the idle duration and eruption duration for Old Faithful:And here is a density contour plot showing the relationship between the weight and price of 53,940 diamonds:contourDensity() ​Examples · Source · Constructs a new density estimator with the default settings.density(data) ​Source · Estimates the density contours for the given array of data, returning an array of GeoJSON MultiPolygon geometry objects.Each geometry object represents the area where the estimated number of points per square pixel is greater than or equal to the corresponding threshold value; the threshold value for each geometry object is exposed as geometry.value. The returned geometry objects are typically passed to geoPath to display, using null or geoIdentity as the associated projection. See also contours.The x and y coordinate for each data point are computed using density.x and density.y. In addition, density.weight indicates the relative contribution of each data point (default 1). The generated contours are only accurate within the estimator’s defined size.density.x(x) ​Source · If x is specified, sets the x-coordinate accessor. If x is not specified, returns the current x-coordinate accessor, which defaults to:jsfunction x(d) {
  return d[0];
}density.y(y) ​Source · If y is specified, sets the y-coordinate accessor. If y is not specified, returns the current y-coordinate accessor, which defaults to:jsfunction y(d) {
  return d[1];
}density.weight(weight) ​Source · If weight is specified, sets the accessor for point weights. If weight is not specified, returns the current point weight accessor, which defaults to:jsfunction weight() {
  return 1;
}density.size(size) ​Source · If size is specified, sets the size of the density estimator to the specified bounds and returns the estimator. The size is specified as an array [width, height], where width is the maximum x-value and height is the maximum y-value. If size is not specified, returns the current size which defaults to [960, 500]. The estimated density contours are only accurate within the defined size.density.cellSize(cellSize) ​Source · If cellSize is specified, sets the size of individual cells in the underlying bin grid to the specified positive integer and returns the estimator. If cellSize is not specified, returns the current cell size, which defaults to 4. The cell size is rounded down to the nearest power of two. Smaller cells produce more detailed contour polygons, but are more expensive to compute.density.thresholds(thresholds) ​Source · If thresholds is specified, sets the threshold generator to the specified function or array and returns this contour generator. If thresholds is not specified, returns the current threshold generator, which by default generates about twenty nicely-rounded density thresholds.Thresholds are defined as an array of values [x0, x1, …]. The first generated density contour corresponds to the area where the estimated density is greater than or equal to x0; the second contour corresponds to the area where the estimated density is greater than or equal to x1, and so on. Thus, there is exactly one generated MultiPolygon geometry object for each specified threshold value; the threshold value is exposed as geometry.value. The first value x0 should typically be greater than zero.If a count is specified instead of an array of thresholds, then approximately count uniformly-spaced nicely-rounded thresholds will be generated; see ticks.density.bandwidth(bandwidth) ​Source · If bandwidth is specified, sets the bandwidth (the standard deviation) of the Gaussian kernel and returns the estimate. If bandwidth is not specified, returns the current bandwidth, which defaults to 20.4939…. The specified bandwidth is currently rounded to the nearest supported value by this implementation, and must be nonnegative.density.contours(data) ​Examples · Source · Return a contour(value) function that can be used to compute an arbitrary contour on the given data without needing to recompute the underlying grid. The returned contour function also exposes a contour.max value which represents the maximum density of the grid.PagerPrevious pageContour polygonsNext paged3-delaunay\n\nDensity estimation ​Contours can show the estimated density of point clouds, which is useful to avoid overplotting in large datasets. The contourDensity method implements fast two-dimensional kernel density estimation.Here is a scatterplot showing the relationship between the idle duration and eruption duration for Old Faithful:And here is a density contour plot showing the relationship between the weight and price of 53,940 diamonds:contourDensity() ​Examples · Source · Constructs a new density estimator with the default settings.density(data) ​Source · Estimates the density contours for the given array of data, returning an array of GeoJSON MultiPolygon geometry objects.Each geometry object represents the area where the estimated number of points per square pixel is greater than or equal to the corresponding threshold value; the threshold value for each geometry object is exposed as geometry.value. The returned geometry objects are typically passed to geoPath to display, using null or geoIdentity as the associated projection. See also contours.The x and y coordinate for each data point are computed using density.x and density.y. In addition, density.weight indicates the relative contribution of each data point (default 1). The generated contours are only accurate within the estimator’s defined size.density.x(x) ​Source · If x is specified, sets the x-coordinate accessor. If x is not specified, returns the current x-coordinate accessor, which defaults to:jsfunction x(d) {
  return d[0];
}density.y(y) ​Source · If y is specified, sets the y-coordinate accessor. If y is not specified, returns the current y-coordinate accessor, which defaults to:jsfunction y(d) {
  return d[1];
}density.weight(weight) ​Source · If weight is specified, sets the accessor for point weights. If weight is not specified, returns the current point weight accessor, which defaults to:jsfunction weight() {
  return 1;
}density.size(size) ​Source · If size is specified, sets the size of the density estimator to the specified bounds and returns the estimator. The size is specified as an array [width, height], where width is the maximum x-value and height is the maximum y-value. If size is not specified, returns the current size which defaults to [960, 500]. The estimated density contours are only accurate within the defined size.density.cellSize(cellSize) ​Source · If cellSize is specified, sets the size of individual cells in the underlying bin grid to the specified positive integer and returns the estimator. If cellSize is not specified, returns the current cell size, which defaults to 4. The cell size is rounded down to the nearest power of two. Smaller cells produce more detailed contour polygons, but are more expensive to compute.density.thresholds(thresholds) ​Source · If thresholds is specified, sets the threshold generator to the specified function or array and returns this contour generator. If thresholds is not specified, returns the current threshold generator, which by default generates about twenty nicely-rounded density thresholds.Thresholds are defined as an array of values [x0, x1, …]. The first generated density contour corresponds to the area where the estimated density is greater than or equal to x0; the second contour corresponds to the area where the estimated density is greater than or equal to x1, and so on. Thus, there is exactly one generated MultiPolygon geometry object for each specified threshold value; the threshold value is exposed as geometry.value. The first value x0 should typically be greater than zero.If a count is specified instead of an array of thresholds, then approximately count uniformly-spaced nicely-rounded thresholds will be generated; see ticks.density.bandwidth(bandwidth) ​Source · If bandwidth is specified, sets the bandwidth (the standard deviation) of the Gaussian kernel and returns the estimate. If bandwidth is not specified, returns the current bandwidth, which defaults to 20.4939…. The specified bandwidth is currently rounded to the nearest supported value by this implementation, and must be nonnegative.density.contours(data) ​Examples · Source · Return a contour(value) function that can be used to compute an arbitrary contour on the given data without needing to recompute the underlying grid. The returned contour function also exposes a contour.max value which represents the maximum density of the grid.\n\n\n\nd3-delaunay ​This is a fast library for computing the Voronoi diagram of a set of two-dimensional points. It is based on Delaunator, a fast library for computing the Delaunay triangulation using sweep algorithms. The Voronoi diagram is constructed by connecting the circumcenters of adjacent triangles in the Delaunay triangulation.See one of:Delaunay triangulationsVoronoi diagramsFor an interactive explanation of how this library works, see The Delaunay’s Dual.\n\nSearchK7.9.0GitHub️ 110.0kOn this paged3-delaunay ​This is a fast library for computing the Voronoi diagram of a set of two-dimensional points. It is based on Delaunator, a fast library for computing the Delaunay triangulation using sweep algorithms. The Voronoi diagram is constructed by connecting the circumcenters of adjacent triangles in the Delaunay triangulation.See one of:Delaunay triangulationsVoronoi diagramsFor an interactive explanation of how this library works, see The Delaunay’s Dual.PagerPrevious pageDensity estimationNext pageDelaunay triangulations\n\nd3-delaunay ​This is a fast library for computing the Voronoi diagram of a set of two-dimensional points. It is based on Delaunator, a fast library for computing the Delaunay triangulation using sweep algorithms. The Voronoi diagram is constructed by connecting the circumcenters of adjacent triangles in the Delaunay triangulation.See one of:Delaunay triangulationsVoronoi diagramsFor an interactive explanation of how this library works, see The Delaunay’s Dual.\n\n\n\nDelaunay triangulations ​The Delaunay triangulation is a triangular mesh formed from a set of points in x and y. No point is inside the circumcircle of any triangle, which is a nice geometric property for certain applications, and tends to avoid “sliver” triangles. The Delaunay triangulation is the dual of the Voronoi diagram.new Delaunay(points) ​Source · Returns the Delaunay triangulation for the given flat array [x0, y0, x1, y1, …] of points.jsconst delaunay = new d3.Delaunay(Float64Array.of(0, 0, 0, 1, 1, 0, 1, 1));The given points may be any array-like type, but is typically a Float64Array.delaunay.points ​The coordinates of the points as an array [x0, y0, x1, y1, …].delaunay.halfedges ​The halfedge indexes as an Int32Array [j0, j1, …]. For each index 0 ≤ i < halfedges.length, there is a halfedge from triangle vertex j = halfedges[i] to triangle vertex i. Equivalently, this means that triangle ⌊i / 3⌋ is adjacent to triangle ⌊j / 3⌋. If j is negative, then triangle ⌊i / 3⌋ is an exterior triangle on the convex hull. For example, to render the internal edges of the Delaunay triangulation:jsconst {points, halfedges, triangles} = delaunay;
for (let i = 0, n = halfedges.length; i < n; ++i) {
  const j = halfedges[i];
  if (j < i) continue;
  const ti = triangles[i];
  const tj = triangles[j];
  context.moveTo(points[ti * 2], points[ti * 2 + 1]);
  context.lineTo(points[tj * 2], points[tj * 2 + 1]);
}See also delaunay.render.delaunay.hull ​An Int32Array of point indexes that form the convex hull in counterclockwise order. If the points are collinear, returns them ordered.See also delaunay.renderHull.delaunay.triangles ​The triangle vertex indexes as an Uint32Array [i0, j0, k0, i1, j1, k1, …]. Each contiguous triplet of indexes i, j, k forms a counterclockwise triangle. The coordinates of the triangle’s points can be found by going through delaunay.points. For example, to render triangle i:jsconst {points, triangles} = delaunay;
const t0 = triangles[i * 3 + 0];
const t1 = triangles[i * 3 + 1];
const t2 = triangles[i * 3 + 2];
context.moveTo(points[t0 * 2], points[t0 * 2 + 1]);
context.lineTo(points[t1 * 2], points[t1 * 2 + 1]);
context.lineTo(points[t2 * 2], points[t2 * 2 + 1]);
context.closePath();See also delaunay.renderTriangle.delaunay.inedges ​The incoming halfedge indexes as a Int32Array [e0, e1, e2, …]. For each point i, inedges[i] is the halfedge index e of an incoming halfedge. For coincident points, the halfedge index is -1; for points on the convex hull, the incoming halfedge is on the convex hull; for other points, the choice of incoming halfedge is arbitrary. The inedges table can be used to traverse the Delaunay triangulation; see also delaunay.neighbors.Delaunay.from(points, fx, fy, that) ​TIPDelaunay.from is typically slower than new Delaunay because it requires materializing a new flat array of xy coordinates.Source · Returns the Delaunay triangulation for the given array or iterable of points. If fx and fy are not specified, then points is assumed to be an array of two-element arrays of numbers: [[x0, y0], [x1, y1], …].jsconst delaunay = d3.Delaunay.from([[0, 0], [0, 1], [1, 0], [1, 1]]);Otherwise, fx and fy are functions that are invoked for each element in the points array in order, and must return the respective x and y coordinate for each point.jsconst delaunay = d3.Delaunay.from([{x: 0, y: 0}, {x: 0, y: 1}, {x: 1, y: 0}, {x: 1, y: 1}], (d) => d.x, (d) => d.y);If that is specified, the functions fx and fy are invoked with that as this. (See Array.from for reference.)delaunay.find(x, y, i) ​jsdelaunay.find(0, 0) // -1Examples · Source · Returns the index of the input point that is closest to the specified point ⟨x, y⟩. The search is started at the specified point i. If i is not specified, it defaults to zero.delaunay.neighbors(i) ​jsdelaunay.neighbors(-1) // []Source · Returns an iterable over the indexes of the neighboring points to the specified point i. The iterable is empty if i is a coincident point.delaunay.render(context) ​Source · Renders the edges of the Delaunay triangulation to the specified context. The specified context must implement the context.moveTo and context.lineTo methods from the CanvasPathMethods API. If a context is not specified, an SVG path string is returned instead.delaunay.renderHull(context) ​Source · Renders the convex hull of the Delaunay triangulation to the specified context. The specified context must implement the context.moveTo and context.lineTo methods from the CanvasPathMethods API. If a context is not specified, an SVG path string is returned instead.delaunay.renderTriangle(i, context) ​Source · Renders triangle i of the Delaunay triangulation to the specified context. The specified context must implement the context.moveTo, context.lineTo and context.closePath methods from the CanvasPathMethods API. If a context is not specified, an SVG path string is returned instead.delaunay.renderPoints(context, radius) ​Source · Renders the input points of the Delaunay triangulation to the specified context as circles with the specified radius. If radius is not specified, it defaults to 2. The specified context must implement the context.moveTo and context.arc methods from the CanvasPathMethods API. If a context is not specified, an SVG path string is returned instead.delaunay.hullPolygon() ​Source · Returns the closed polygon [[x0, y0], [x1, y1], …, [x0, y0]] representing the convex hull. See also delaunay.renderHull.delaunay.trianglePolygons() ​Source · Returns an iterable over the polygons for each triangle, in order. See also delaunay.renderTriangle.delaunay.trianglePolygon(i) ​Source · Returns the closed polygon [[x0, y0], [x1, y1], [x2, y2], [x0, y0]] representing the triangle i. See also delaunay.renderTriangle.delaunay.update() ​Source · Recomputes the triangulation after the points have been modified in-place.delaunay.voronoi(bounds) ​Source · Returns the Voronoi diagram for the given Delaunay triangulation. When rendering, the diagram will be clipped to the specified bounds = [xmin, ymin, xmax, ymax].jsconst delaunay = d3.Delaunay.from(points);
const voronoi = delaunay.voronoi([0, 0, 640, 480]);If bounds is not specified, it defaults to [0, 0, 960, 500]. The Voronoi diagram is returned even in degenerate cases where no triangulation exists — namely 0, 1 or 2 points, and collinear points.\n\nSearchK7.9.0GitHub️ 110.0kOn this pageDelaunay triangulations ​The Delaunay triangulation is a triangular mesh formed from a set of points in x and y. No point is inside the circumcircle of any triangle, which is a nice geometric property for certain applications, and tends to avoid “sliver” triangles. The Delaunay triangulation is the dual of the Voronoi diagram.new Delaunay(points) ​Source · Returns the Delaunay triangulation for the given flat array [x0, y0, x1, y1, …] of points.jsconst delaunay = new d3.Delaunay(Float64Array.of(0, 0, 0, 1, 1, 0, 1, 1));The given points may be any array-like type, but is typically a Float64Array.delaunay.points ​The coordinates of the points as an array [x0, y0, x1, y1, …].delaunay.halfedges ​The halfedge indexes as an Int32Array [j0, j1, …]. For each index 0 ≤ i < halfedges.length, there is a halfedge from triangle vertex j = halfedges[i] to triangle vertex i. Equivalently, this means that triangle ⌊i / 3⌋ is adjacent to triangle ⌊j / 3⌋. If j is negative, then triangle ⌊i / 3⌋ is an exterior triangle on the convex hull. For example, to render the internal edges of the Delaunay triangulation:jsconst {points, halfedges, triangles} = delaunay;
for (let i = 0, n = halfedges.length; i < n; ++i) {
  const j = halfedges[i];
  if (j < i) continue;
  const ti = triangles[i];
  const tj = triangles[j];
  context.moveTo(points[ti * 2], points[ti * 2 + 1]);
  context.lineTo(points[tj * 2], points[tj * 2 + 1]);
}See also delaunay.render.delaunay.hull ​An Int32Array of point indexes that form the convex hull in counterclockwise order. If the points are collinear, returns them ordered.See also delaunay.renderHull.delaunay.triangles ​The triangle vertex indexes as an Uint32Array [i0, j0, k0, i1, j1, k1, …]. Each contiguous triplet of indexes i, j, k forms a counterclockwise triangle. The coordinates of the triangle’s points can be found by going through delaunay.points. For example, to render triangle i:jsconst {points, triangles} = delaunay;
const t0 = triangles[i * 3 + 0];
const t1 = triangles[i * 3 + 1];
const t2 = triangles[i * 3 + 2];
context.moveTo(points[t0 * 2], points[t0 * 2 + 1]);
context.lineTo(points[t1 * 2], points[t1 * 2 + 1]);
context.lineTo(points[t2 * 2], points[t2 * 2 + 1]);
context.closePath();See also delaunay.renderTriangle.delaunay.inedges ​The incoming halfedge indexes as a Int32Array [e0, e1, e2, …]. For each point i, inedges[i] is the halfedge index e of an incoming halfedge. For coincident points, the halfedge index is -1; for points on the convex hull, the incoming halfedge is on the convex hull; for other points, the choice of incoming halfedge is arbitrary. The inedges table can be used to traverse the Delaunay triangulation; see also delaunay.neighbors.Delaunay.from(points, fx, fy, that) ​TIPDelaunay.from is typically slower than new Delaunay because it requires materializing a new flat array of xy coordinates.Source · Returns the Delaunay triangulation for the given array or iterable of points. If fx and fy are not specified, then points is assumed to be an array of two-element arrays of numbers: [[x0, y0], [x1, y1], …].jsconst delaunay = d3.Delaunay.from([[0, 0], [0, 1], [1, 0], [1, 1]]);Otherwise, fx and fy are functions that are invoked for each element in the points array in order, and must return the respective x and y coordinate for each point.jsconst delaunay = d3.Delaunay.from([{x: 0, y: 0}, {x: 0, y: 1}, {x: 1, y: 0}, {x: 1, y: 1}], (d) => d.x, (d) => d.y);If that is specified, the functions fx and fy are invoked with that as this. (See Array.from for reference.)delaunay.find(x, y, i) ​jsdelaunay.find(0, 0) // -1Examples · Source · Returns the index of the input point that is closest to the specified point ⟨x, y⟩. The search is started at the specified point i. If i is not specified, it defaults to zero.delaunay.neighbors(i) ​jsdelaunay.neighbors(-1) // []Source · Returns an iterable over the indexes of the neighboring points to the specified point i. The iterable is empty if i is a coincident point.delaunay.render(context) ​Source · Renders the edges of the Delaunay triangulation to the specified context. The specified context must implement the context.moveTo and context.lineTo methods from the CanvasPathMethods API. If a context is not specified, an SVG path string is returned instead.delaunay.renderHull(context) ​Source · Renders the convex hull of the Delaunay triangulation to the specified context. The specified context must implement the context.moveTo and context.lineTo methods from the CanvasPathMethods API. If a context is not specified, an SVG path string is returned instead.delaunay.renderTriangle(i, context) ​Source · Renders triangle i of the Delaunay triangulation to the specified context. The specified context must implement the context.moveTo, context.lineTo and context.closePath methods from the CanvasPathMethods API. If a context is not specified, an SVG path string is returned instead.delaunay.renderPoints(context, radius) ​Source · Renders the input points of the Delaunay triangulation to the specified context as circles with the specified radius. If radius is not specified, it defaults to 2. The specified context must implement the context.moveTo and context.arc methods from the CanvasPathMethods API. If a context is not specified, an SVG path string is returned instead.delaunay.hullPolygon() ​Source · Returns the closed polygon [[x0, y0], [x1, y1], …, [x0, y0]] representing the convex hull. See also delaunay.renderHull.delaunay.trianglePolygons() ​Source · Returns an iterable over the polygons for each triangle, in order. See also delaunay.renderTriangle.delaunay.trianglePolygon(i) ​Source · Returns the closed polygon [[x0, y0], [x1, y1], [x2, y2], [x0, y0]] representing the triangle i. See also delaunay.renderTriangle.delaunay.update() ​Source · Recomputes the triangulation after the points have been modified in-place.delaunay.voronoi(bounds) ​Source · Returns the Voronoi diagram for the given Delaunay triangulation. When rendering, the diagram will be clipped to the specified bounds = [xmin, ymin, xmax, ymax].jsconst delaunay = d3.Delaunay.from(points);
const voronoi = delaunay.voronoi([0, 0, 640, 480]);If bounds is not specified, it defaults to [0, 0, 960, 500]. The Voronoi diagram is returned even in degenerate cases where no triangulation exists — namely 0, 1 or 2 points, and collinear points.PagerPrevious paged3-delaunayNext pageVoronoi diagrams\n\nDelaunay triangulations ​The Delaunay triangulation is a triangular mesh formed from a set of points in x and y. No point is inside the circumcircle of any triangle, which is a nice geometric property for certain applications, and tends to avoid “sliver” triangles. The Delaunay triangulation is the dual of the Voronoi diagram.new Delaunay(points) ​Source · Returns the Delaunay triangulation for the given flat array [x0, y0, x1, y1, …] of points.jsconst delaunay = new d3.Delaunay(Float64Array.of(0, 0, 0, 1, 1, 0, 1, 1));The given points may be any array-like type, but is typically a Float64Array.delaunay.points ​The coordinates of the points as an array [x0, y0, x1, y1, …].delaunay.halfedges ​The halfedge indexes as an Int32Array [j0, j1, …]. For each index 0 ≤ i < halfedges.length, there is a halfedge from triangle vertex j = halfedges[i] to triangle vertex i. Equivalently, this means that triangle ⌊i / 3⌋ is adjacent to triangle ⌊j / 3⌋. If j is negative, then triangle ⌊i / 3⌋ is an exterior triangle on the convex hull. For example, to render the internal edges of the Delaunay triangulation:jsconst {points, halfedges, triangles} = delaunay;
for (let i = 0, n = halfedges.length; i < n; ++i) {
  const j = halfedges[i];
  if (j < i) continue;
  const ti = triangles[i];
  const tj = triangles[j];
  context.moveTo(points[ti * 2], points[ti * 2 + 1]);
  context.lineTo(points[tj * 2], points[tj * 2 + 1]);
}See also delaunay.render.delaunay.hull ​An Int32Array of point indexes that form the convex hull in counterclockwise order. If the points are collinear, returns them ordered.See also delaunay.renderHull.delaunay.triangles ​The triangle vertex indexes as an Uint32Array [i0, j0, k0, i1, j1, k1, …]. Each contiguous triplet of indexes i, j, k forms a counterclockwise triangle. The coordinates of the triangle’s points can be found by going through delaunay.points. For example, to render triangle i:jsconst {points, triangles} = delaunay;
const t0 = triangles[i * 3 + 0];
const t1 = triangles[i * 3 + 1];
const t2 = triangles[i * 3 + 2];
context.moveTo(points[t0 * 2], points[t0 * 2 + 1]);
context.lineTo(points[t1 * 2], points[t1 * 2 + 1]);
context.lineTo(points[t2 * 2], points[t2 * 2 + 1]);
context.closePath();See also delaunay.renderTriangle.delaunay.inedges ​The incoming halfedge indexes as a Int32Array [e0, e1, e2, …]. For each point i, inedges[i] is the halfedge index e of an incoming halfedge. For coincident points, the halfedge index is -1; for points on the convex hull, the incoming halfedge is on the convex hull; for other points, the choice of incoming halfedge is arbitrary. The inedges table can be used to traverse the Delaunay triangulation; see also delaunay.neighbors.Delaunay.from(points, fx, fy, that) ​TIPDelaunay.from is typically slower than new Delaunay because it requires materializing a new flat array of xy coordinates.Source · Returns the Delaunay triangulation for the given array or iterable of points. If fx and fy are not specified, then points is assumed to be an array of two-element arrays of numbers: [[x0, y0], [x1, y1], …].jsconst delaunay = d3.Delaunay.from([[0, 0], [0, 1], [1, 0], [1, 1]]);Otherwise, fx and fy are functions that are invoked for each element in the points array in order, and must return the respective x and y coordinate for each point.jsconst delaunay = d3.Delaunay.from([{x: 0, y: 0}, {x: 0, y: 1}, {x: 1, y: 0}, {x: 1, y: 1}], (d) => d.x, (d) => d.y);If that is specified, the functions fx and fy are invoked with that as this. (See Array.from for reference.)delaunay.find(x, y, i) ​jsdelaunay.find(0, 0) // -1Examples · Source · Returns the index of the input point that is closest to the specified point ⟨x, y⟩. The search is started at the specified point i. If i is not specified, it defaults to zero.delaunay.neighbors(i) ​jsdelaunay.neighbors(-1) // []Source · Returns an iterable over the indexes of the neighboring points to the specified point i. The iterable is empty if i is a coincident point.delaunay.render(context) ​Source · Renders the edges of the Delaunay triangulation to the specified context. The specified context must implement the context.moveTo and context.lineTo methods from the CanvasPathMethods API. If a context is not specified, an SVG path string is returned instead.delaunay.renderHull(context) ​Source · Renders the convex hull of the Delaunay triangulation to the specified context. The specified context must implement the context.moveTo and context.lineTo methods from the CanvasPathMethods API. If a context is not specified, an SVG path string is returned instead.delaunay.renderTriangle(i, context) ​Source · Renders triangle i of the Delaunay triangulation to the specified context. The specified context must implement the context.moveTo, context.lineTo and context.closePath methods from the CanvasPathMethods API. If a context is not specified, an SVG path string is returned instead.delaunay.renderPoints(context, radius) ​Source · Renders the input points of the Delaunay triangulation to the specified context as circles with the specified radius. If radius is not specified, it defaults to 2. The specified context must implement the context.moveTo and context.arc methods from the CanvasPathMethods API. If a context is not specified, an SVG path string is returned instead.delaunay.hullPolygon() ​Source · Returns the closed polygon [[x0, y0], [x1, y1], …, [x0, y0]] representing the convex hull. See also delaunay.renderHull.delaunay.trianglePolygons() ​Source · Returns an iterable over the polygons for each triangle, in order. See also delaunay.renderTriangle.delaunay.trianglePolygon(i) ​Source · Returns the closed polygon [[x0, y0], [x1, y1], [x2, y2], [x0, y0]] representing the triangle i. See also delaunay.renderTriangle.delaunay.update() ​Source · Recomputes the triangulation after the points have been modified in-place.delaunay.voronoi(bounds) ​Source · Returns the Voronoi diagram for the given Delaunay triangulation. When rendering, the diagram will be clipped to the specified bounds = [xmin, ymin, xmax, ymax].jsconst delaunay = d3.Delaunay.from(points);
const voronoi = delaunay.voronoi([0, 0, 640, 480]);If bounds is not specified, it defaults to [0, 0, 960, 500]. The Voronoi diagram is returned even in degenerate cases where no triangulation exists — namely 0, 1 or 2 points, and collinear points.\n\n\n\nVoronoi diagrams ​Given a set of points, the Voronoi diagram partitions the plane into cells representing the region of the plane that is closest to the corresponding point. The Voronoi diagram is the dual of the Delaunay triangulation.delaunay.voronoi(bounds) ​Source · Returns the Voronoi diagram for the given Delaunay triangulation. When rendering, the diagram will be clipped to the specified bounds = [xmin, ymin, xmax, ymax].jsconst delaunay = d3.Delaunay.from([[0, 0], [0, 100], [100, 0], [100, 100]]);
const voronoi = delaunay.voronoi([0, 0, 640, 480]);If bounds is not specified, it defaults to [0, 0, 960, 500]. The Voronoi diagram is returned even in degenerate cases where no triangulation exists — namely 0, 1 or 2 points, and collinear points.voronoi.delaunay ​The Voronoi diagram’s associated Delaunay triangulation.voronoi.circumcenters ​The circumcenters of the Delaunay triangles as a Float64Array [cx0, cy0, cx1, cy1, …]. Each contiguous pair of coordinates cx, cy is the circumcenter for the corresponding triangle. These circumcenters form the coordinates of the Voronoi cell polygons.voronoi.vectors ​A Float64Array [vx0, vy0, wx0, wy0, …] where each non-zero quadruple describes an open (infinite) cell on the outer hull, giving the directions of two open half-lines.voronoi.xminvoronoi.yminvoronoi.xmaxvoronoi.ymax ​The bounds of the viewport [xmin, ymin, xmax, ymax] for rendering the Voronoi diagram. These values only affect the rendering methods (voronoi.render, voronoi.renderBounds, voronoi.renderCell).voronoi.contains(i, x, y) ​Source · Returns true if the cell with the specified index i contains the specified point ⟨x, y⟩; i.e., whether the point i is the closest point in the diagram to the specified point. (This method is not affected by the associated Voronoi diagram’s viewport bounds.)voronoi.neighbors(i) ​jsvoronoi.neighbors(-1) // []Source · Returns an iterable over the indexes of the cells that share a common edge with the specified cell i. Voronoi neighbors are always neighbors on the Delaunay graph, but the converse is false when the common edge has been clipped out by the Voronoi diagram’s viewport.voronoi.render(context) ​Source · Renders the mesh of Voronoi cells to the specified context. The specified context must implement the context.moveTo and context.lineTo methods from the CanvasPathMethods API. If a context is not specified, an SVG path string is returned instead.voronoi.renderBounds(context) ​Source · Renders the viewport extent to the specified context. The specified context must implement the context.rect method from the CanvasPathMethods API. Equivalent to context.rect(voronoi.xmin, voronoi.ymin, voronoi.xmax - voronoi.xmin, voronoi.ymax - voronoi.ymin). If a context is not specified, an SVG path string is returned instead.voronoi.renderCell(i, context) ​Source · Renders the cell with the specified index i to the specified context. The specified context must implement the context.moveTo , context.lineTo and context.closePath methods from the CanvasPathMethods API. If a context is not specified, an SVG path string is returned instead.voronoi.cellPolygons() ​Source · Returns an iterable over the non-empty polygons for each cell, with the cell index as property. See also voronoi.renderCell.voronoi.cellPolygon(i) ​Source · Returns the convex, closed polygon [[x0, y0], [x1, y1], …, [x0, y0]] representing the cell for the specified point i. See also voronoi.renderCell.voronoi.update() ​Source · Updates the Voronoi diagram and underlying triangulation after the points have been modified in-place — useful for Lloyd’s relaxation. Calls delaunay.update on the underlying Delaunay triangulation.\n\nSearchK7.9.0GitHub️ 110.0kOn this pageVoronoi diagrams ​Given a set of points, the Voronoi diagram partitions the plane into cells representing the region of the plane that is closest to the corresponding point. The Voronoi diagram is the dual of the Delaunay triangulation.delaunay.voronoi(bounds) ​Source · Returns the Voronoi diagram for the given Delaunay triangulation. When rendering, the diagram will be clipped to the specified bounds = [xmin, ymin, xmax, ymax].jsconst delaunay = d3.Delaunay.from([[0, 0], [0, 100], [100, 0], [100, 100]]);
const voronoi = delaunay.voronoi([0, 0, 640, 480]);If bounds is not specified, it defaults to [0, 0, 960, 500]. The Voronoi diagram is returned even in degenerate cases where no triangulation exists — namely 0, 1 or 2 points, and collinear points.voronoi.delaunay ​The Voronoi diagram’s associated Delaunay triangulation.voronoi.circumcenters ​The circumcenters of the Delaunay triangles as a Float64Array [cx0, cy0, cx1, cy1, …]. Each contiguous pair of coordinates cx, cy is the circumcenter for the corresponding triangle. These circumcenters form the coordinates of the Voronoi cell polygons.voronoi.vectors ​A Float64Array [vx0, vy0, wx0, wy0, …] where each non-zero quadruple describes an open (infinite) cell on the outer hull, giving the directions of two open half-lines.voronoi.xminvoronoi.yminvoronoi.xmaxvoronoi.ymax ​The bounds of the viewport [xmin, ymin, xmax, ymax] for rendering the Voronoi diagram. These values only affect the rendering methods (voronoi.render, voronoi.renderBounds, voronoi.renderCell).voronoi.contains(i, x, y) ​Source · Returns true if the cell with the specified index i contains the specified point ⟨x, y⟩; i.e., whether the point i is the closest point in the diagram to the specified point. (This method is not affected by the associated Voronoi diagram’s viewport bounds.)voronoi.neighbors(i) ​jsvoronoi.neighbors(-1) // []Source · Returns an iterable over the indexes of the cells that share a common edge with the specified cell i. Voronoi neighbors are always neighbors on the Delaunay graph, but the converse is false when the common edge has been clipped out by the Voronoi diagram’s viewport.voronoi.render(context) ​Source · Renders the mesh of Voronoi cells to the specified context. The specified context must implement the context.moveTo and context.lineTo methods from the CanvasPathMethods API. If a context is not specified, an SVG path string is returned instead.voronoi.renderBounds(context) ​Source · Renders the viewport extent to the specified context. The specified context must implement the context.rect method from the CanvasPathMethods API. Equivalent to context.rect(voronoi.xmin, voronoi.ymin, voronoi.xmax - voronoi.xmin, voronoi.ymax - voronoi.ymin). If a context is not specified, an SVG path string is returned instead.voronoi.renderCell(i, context) ​Source · Renders the cell with the specified index i to the specified context. The specified context must implement the context.moveTo , context.lineTo and context.closePath methods from the CanvasPathMethods API. If a context is not specified, an SVG path string is returned instead.voronoi.cellPolygons() ​Source · Returns an iterable over the non-empty polygons for each cell, with the cell index as property. See also voronoi.renderCell.voronoi.cellPolygon(i) ​Source · Returns the convex, closed polygon [[x0, y0], [x1, y1], …, [x0, y0]] representing the cell for the specified point i. See also voronoi.renderCell.voronoi.update() ​Source · Updates the Voronoi diagram and underlying triangulation after the points have been modified in-place — useful for Lloyd’s relaxation. Calls delaunay.update on the underlying Delaunay triangulation.PagerPrevious pageDelaunay triangulationsNext paged3-force\n\nVoronoi diagrams ​Given a set of points, the Voronoi diagram partitions the plane into cells representing the region of the plane that is closest to the corresponding point. The Voronoi diagram is the dual of the Delaunay triangulation.delaunay.voronoi(bounds) ​Source · Returns the Voronoi diagram for the given Delaunay triangulation. When rendering, the diagram will be clipped to the specified bounds = [xmin, ymin, xmax, ymax].jsconst delaunay = d3.Delaunay.from([[0, 0], [0, 100], [100, 0], [100, 100]]);
const voronoi = delaunay.voronoi([0, 0, 640, 480]);If bounds is not specified, it defaults to [0, 0, 960, 500]. The Voronoi diagram is returned even in degenerate cases where no triangulation exists — namely 0, 1 or 2 points, and collinear points.voronoi.delaunay ​The Voronoi diagram’s associated Delaunay triangulation.voronoi.circumcenters ​The circumcenters of the Delaunay triangles as a Float64Array [cx0, cy0, cx1, cy1, …]. Each contiguous pair of coordinates cx, cy is the circumcenter for the corresponding triangle. These circumcenters form the coordinates of the Voronoi cell polygons.voronoi.vectors ​A Float64Array [vx0, vy0, wx0, wy0, …] where each non-zero quadruple describes an open (infinite) cell on the outer hull, giving the directions of two open half-lines.voronoi.xminvoronoi.yminvoronoi.xmaxvoronoi.ymax ​The bounds of the viewport [xmin, ymin, xmax, ymax] for rendering the Voronoi diagram. These values only affect the rendering methods (voronoi.render, voronoi.renderBounds, voronoi.renderCell).voronoi.contains(i, x, y) ​Source · Returns true if the cell with the specified index i contains the specified point ⟨x, y⟩; i.e., whether the point i is the closest point in the diagram to the specified point. (This method is not affected by the associated Voronoi diagram’s viewport bounds.)voronoi.neighbors(i) ​jsvoronoi.neighbors(-1) // []Source · Returns an iterable over the indexes of the cells that share a common edge with the specified cell i. Voronoi neighbors are always neighbors on the Delaunay graph, but the converse is false when the common edge has been clipped out by the Voronoi diagram’s viewport.voronoi.render(context) ​Source · Renders the mesh of Voronoi cells to the specified context. The specified context must implement the context.moveTo and context.lineTo methods from the CanvasPathMethods API. If a context is not specified, an SVG path string is returned instead.voronoi.renderBounds(context) ​Source · Renders the viewport extent to the specified context. The specified context must implement the context.rect method from the CanvasPathMethods API. Equivalent to context.rect(voronoi.xmin, voronoi.ymin, voronoi.xmax - voronoi.xmin, voronoi.ymax - voronoi.ymin). If a context is not specified, an SVG path string is returned instead.voronoi.renderCell(i, context) ​Source · Renders the cell with the specified index i to the specified context. The specified context must implement the context.moveTo , context.lineTo and context.closePath methods from the CanvasPathMethods API. If a context is not specified, an SVG path string is returned instead.voronoi.cellPolygons() ​Source · Returns an iterable over the non-empty polygons for each cell, with the cell index as property. See also voronoi.renderCell.voronoi.cellPolygon(i) ​Source · Returns the convex, closed polygon [[x0, y0], [x1, y1], …, [x0, y0]] representing the cell for the specified point i. See also voronoi.renderCell.voronoi.update() ​Source · Updates the Voronoi diagram and underlying triangulation after the points have been modified in-place — useful for Lloyd’s relaxation. Calls delaunay.update on the underlying Delaunay triangulation.\n\n\n\nd3-force ​Fork ↗︎This module implements a velocity Verlet numerical integrator for simulating physical forces on particles. Force simulations can be used to visualize networks and hierarchies, and to resolve collisions as in bubble charts.To use this module, create a simulation for an array of nodes and apply the desired forces. Then listen for tick events to render the nodes as they update in your preferred graphics system, such as Canvas or SVG.See one of:Force simulationsCenter forceCollide forceLink forceMany-body forcePosition forces\n\nSearchK7.9.0GitHub️ 110.0kOn this paged3-force ​Fork ↗︎This module implements a velocity Verlet numerical integrator for simulating physical forces on particles. Force simulations can be used to visualize networks and hierarchies, and to resolve collisions as in bubble charts.To use this module, create a simulation for an array of nodes and apply the desired forces. Then listen for tick events to render the nodes as they update in your preferred graphics system, such as Canvas or SVG.See one of:Force simulationsCenter forceCollide forceLink forceMany-body forcePosition forcesPagerPrevious pageVoronoi diagramsNext pageForce simulations\n\nd3-force ​Fork ↗︎This module implements a velocity Verlet numerical integrator for simulating physical forces on particles. Force simulations can be used to visualize networks and hierarchies, and to resolve collisions as in bubble charts.To use this module, create a simulation for an array of nodes and apply the desired forces. Then listen for tick events to render the nodes as they update in your preferred graphics system, such as Canvas or SVG.See one of:Force simulationsCenter forceCollide forceLink forceMany-body forcePosition forces\n\n\n\nForce simulations ​A force simulation implements a velocity Verlet numerical integrator for simulating physical forces on particles (nodes). The simulation assumes a constant unit time step Δt = 1 for each step and a constant unit mass m = 1 for all particles. As a result, a force F acting on a particle is equivalent to a constant acceleration a over the time interval Δt, and can be simulated simply by adding to the particle’s velocity, which is then added to the particle’s position.forceSimulation(nodes) ​Source · Creates a new simulation with the specified array of nodes and no forces. If nodes is not specified, it defaults to the empty array.WARNINGThis function is impure; it mutates the passed-in nodes. See simulation.nodes.jsconst simulation = d3.forceSimulation(nodes);The simulator starts automatically; use simulation.on to listen for tick events as the simulation runs. If you wish to run the simulation manually instead, call simulation.stop, and then call simulation.tick as desired.simulation.restart() ​Source · Restarts the simulation’s internal timer and returns the simulation. In conjunction with simulation.alphaTarget or simulation.alpha, this method can be used to “reheat” the simulation during interaction, such as when dragging a node, or to resume the simulation after temporarily pausing it with simulation.stop.simulation.stop() ​Source · Stops the simulation’s internal timer, if it is running, and returns the simulation. If the timer is already stopped, this method does nothing. This method is useful for running the simulation manually; see simulation.tick.simulation.tick(iterations) ​Source · Manually steps the simulation by the specified number of iterations, and returns the simulation. If iterations is not specified, it defaults to 1 (single step).For each iteration, it increments the current alpha by (alphaTarget - alpha) × alphaDecay; then invokes each registered force, passing the new alpha; then decrements each node’s velocity by velocity × velocityDecay; lastly increments each node’s position by velocity.This method does not dispatch events; events are only dispatched by the internal timer when the simulation is started automatically upon creation or by calling simulation.restart. The natural number of ticks when the simulation is started is ⌈log(alphaMin) / log(1 - alphaDecay)⌉; by default, this is 300.This method can be used in conjunction with simulation.stop to compute a static force layout. For large graphs, static layouts should be computed in a web worker to avoid freezing the user interface.simulation.nodes(nodes) ​Source · If nodes is specified, sets the simulation’s nodes to the specified array of objects, initializing their positions and velocities if necessary, and then re-initializes any bound forces; returns the simulation. If nodes is not specified, returns the simulation’s array of nodes as specified to the constructor.WARNINGThis function is impure; it mutates the passed-in nodes to assign the index node.index, the position node.x & node.y, and the velocity node.vx & node.vy. The position and velocity are further updated as the simulation runs by simulation.tick.Each node must be an object. The following properties are assigned by the simulation:index - the node’s zero-based index into nodesx - the node’s current x-positiony - the node’s current y-positionvx - the node’s current x-velocityvy - the node’s current y-velocityThe position ⟨x,y⟩ and velocity ⟨vx,vy⟩ may be subsequently modified by forces and by the simulation. If either vx or vy is NaN, the velocity is initialized to ⟨0,0⟩. If either x or y is NaN, the position is initialized in a phyllotaxis arrangement, so chosen to ensure a deterministic, uniform distribution.To fix a node in a given position, you may specify two additional properties:fx - the node’s fixed x-positionfy - the node’s fixed y-positionAt the end of each tick, after the application of any forces, a node with a defined node.fx has node.x reset to this value and node.vx set to zero; likewise, a node with a defined node.fy has node.y reset to this value and node.vy set to zero. To unfix a node that was previously fixed, set node.fx and node.fy to null, or delete these properties.If the specified array of nodes is modified, such as when nodes are added to or removed from the simulation, this method must be called again with the new (or changed) array to notify the simulation and bound forces of the change; the simulation does not make a defensive copy of the specified array.simulation.alpha(alpha) ​Source · alpha is roughly analogous to temperature in simulated annealing. It decreases over time as the simulation “cools down”. When alpha reaches alphaMin, the simulation stops; see simulation.restart.If alpha is specified, sets the current alpha to the specified number in the range [0,1] and returns this simulation. If alpha is not specified, returns the current alpha value, which defaults to 1.simulation.alphaMin(min) ​Source · If min is specified, sets the minimum alpha to the specified number in the range [0,1] and returns this simulation. If min is not specified, returns the current minimum alpha value, which defaults to 0.001. The simulation’s internal timer stops when the current alpha is less than the minimum alpha. The default alpha decay rate of ~0.0228 corresponds to 300 iterations.simulation.alphaDecay(decay) ​Source · If decay is specified, sets the alpha decay rate to the specified number in the range [0,1] and returns this simulation. If decay is not specified, returns the current alpha decay rate, which defaults to 0.0228… = 1 - pow(0.001, 1 / 300) where 0.001 is the default minimum alpha.The alpha decay rate determines how quickly the current alpha interpolates towards the desired target alpha; since the default target alpha is zero, by default this controls how quickly the simulation cools. Higher decay rates cause the simulation to stabilize more quickly, but risk getting stuck in a local minimum; lower values cause the simulation to take longer to run, but typically converge on a better layout. To have the simulation run forever at the current alpha, set the decay rate to zero; alternatively, set a target alpha greater than the minimum alpha.simulation.alphaTarget(target) ​Source · If target is specified, sets the current target alpha to the specified number in the range [0,1] and returns this simulation. If target is not specified, returns the current target alpha value, which defaults to 0.simulation.velocityDecay(decay) ​Source · If decay is specified, sets the velocity decay factor to the specified number in the range [0,1] and returns this simulation. If decay is not specified, returns the current velocity decay factor, which defaults to 0.4. The decay factor is akin to atmospheric friction; after the application of any forces during a tick, each node’s velocity is multiplied by 1 - decay. As with lowering the alpha decay rate, less velocity decay may converge on a better solution, but risks numerical instabilities and oscillation.simulation.force(name, force) ​Source · If force is specified, assigns the force for the specified name and returns this simulation. If force is not specified, returns the force with the specified name, or undefined if there is no such force. (By default, new simulations have no forces.) For example, to create a new simulation to layout a graph, you might say:jsconst simulation = d3.forceSimulation(nodes)
    .force("charge", d3.forceManyBody())
    .force("link", d3.forceLink(links))
    .force("center", d3.forceCenter());To remove the force with the given name, pass null as the force. For example, to remove the charge force:jssimulation.force("charge", null);simulation.find(x, y, radius) ​Source · Returns the node closest to the position ⟨x,y⟩ with the given search radius. If radius is not specified, it defaults to infinity. If there is no node within the search area, returns undefined.simulation.randomSource(source) ​Source)If source is specified, sets the function used to generate random numbers; this should be a function that returns a number between 0 (inclusive) and 1 (exclusive). If source is not specified, returns this simulation’s current random source which defaults to a fixed-seed linear congruential generator. See also random.source.simulation.on(typenames, listener) ​Source · If listener is specified, sets the event listener for the specified typenames and returns this simulation. If an event listener was already registered for the same type and name, the existing listener is removed before the new listener is added. If listener is null, removes the current event listeners for the specified typenames, if any. If listener is not specified, returns the first currently-assigned listener matching the specified typenames, if any. When a specified event is dispatched, each listener will be invoked with the this context as the simulation.The typenames is a string containing one or more typename separated by whitespace. Each typename is a type, optionally followed by a period (.) and a name, such as tick.foo and tick.bar; the name allows multiple listeners to be registered for the same type. The type must be one of the following:tick - after each tick of the simulation’s internal timer.end - after the simulation’s timer stops when alpha < alphaMin.Note that tick events are not dispatched when simulation.tick is called manually; events are only dispatched by the internal timer and are intended for interactive rendering of the simulation. To affect the simulation, register forces instead of modifying nodes’ positions or velocities inside a tick event listener.See dispatch.on for details.Custom forces ​A force is a function that modifies nodes’ positions or velocities. It can simulate a physical force such as electrical charge or gravity, or it can resolve a geometric constraint such as keeping nodes within a bounding box or keeping linked nodes a fixed distance apart. For example, here is a force that moves nodes towards the origin:jsfunction force(alpha) {
  for (let i = 0, n = nodes.length, node, k = alpha * 0.1; i < n; ++i) {
    node = nodes[i];
    node.vx -= node.x * k;
    node.vy -= node.y * k;
  }
}Forces typically read the node’s current position ⟨x,y⟩ and then mutate the node’s velocity ⟨vx,vy⟩. Forces may also “peek ahead” to the anticipated next position of the node, ⟨x + vx,y + vy⟩; this is necessary for resolving geometric constraints through iterative relaxation. Forces may also modify the position directly, which is sometimes useful to avoid adding energy to the simulation, such as when recentering the simulation in the viewport.force(alpha) ​Applies this force, optionally observing the specified alpha. Typically, the force is applied to the array of nodes previously passed to force.initialize, however, some forces may apply to a subset of nodes, or behave differently. For example, forceLink applies to the source and target of each link.force.initialize(nodes) ​Supplies the array of nodes and random source to this force. This method is called when a force is bound to a simulation via simulation.force and when the simulation’s nodes change via simulation.nodes. A force may perform necessary work during initialization, such as evaluating per-node parameters, to avoid repeatedly performing work during each application of the force.\n\nSearchK7.9.0GitHub️ 110.0kOn this pageForce simulations ​A force simulation implements a velocity Verlet numerical integrator for simulating physical forces on particles (nodes). The simulation assumes a constant unit time step Δt = 1 for each step and a constant unit mass m = 1 for all particles. As a result, a force F acting on a particle is equivalent to a constant acceleration a over the time interval Δt, and can be simulated simply by adding to the particle’s velocity, which is then added to the particle’s position.forceSimulation(nodes) ​Source · Creates a new simulation with the specified array of nodes and no forces. If nodes is not specified, it defaults to the empty array.WARNINGThis function is impure; it mutates the passed-in nodes. See simulation.nodes.jsconst simulation = d3.forceSimulation(nodes);The simulator starts automatically; use simulation.on to listen for tick events as the simulation runs. If you wish to run the simulation manually instead, call simulation.stop, and then call simulation.tick as desired.simulation.restart() ​Source · Restarts the simulation’s internal timer and returns the simulation. In conjunction with simulation.alphaTarget or simulation.alpha, this method can be used to “reheat” the simulation during interaction, such as when dragging a node, or to resume the simulation after temporarily pausing it with simulation.stop.simulation.stop() ​Source · Stops the simulation’s internal timer, if it is running, and returns the simulation. If the timer is already stopped, this method does nothing. This method is useful for running the simulation manually; see simulation.tick.simulation.tick(iterations) ​Source · Manually steps the simulation by the specified number of iterations, and returns the simulation. If iterations is not specified, it defaults to 1 (single step).For each iteration, it increments the current alpha by (alphaTarget - alpha) × alphaDecay; then invokes each registered force, passing the new alpha; then decrements each node’s velocity by velocity × velocityDecay; lastly increments each node’s position by velocity.This method does not dispatch events; events are only dispatched by the internal timer when the simulation is started automatically upon creation or by calling simulation.restart. The natural number of ticks when the simulation is started is ⌈log(alphaMin) / log(1 - alphaDecay)⌉; by default, this is 300.This method can be used in conjunction with simulation.stop to compute a static force layout. For large graphs, static layouts should be computed in a web worker to avoid freezing the user interface.simulation.nodes(nodes) ​Source · If nodes is specified, sets the simulation’s nodes to the specified array of objects, initializing their positions and velocities if necessary, and then re-initializes any bound forces; returns the simulation. If nodes is not specified, returns the simulation’s array of nodes as specified to the constructor.WARNINGThis function is impure; it mutates the passed-in nodes to assign the index node.index, the position node.x & node.y, and the velocity node.vx & node.vy. The position and velocity are further updated as the simulation runs by simulation.tick.Each node must be an object. The following properties are assigned by the simulation:index - the node’s zero-based index into nodesx - the node’s current x-positiony - the node’s current y-positionvx - the node’s current x-velocityvy - the node’s current y-velocityThe position ⟨x,y⟩ and velocity ⟨vx,vy⟩ may be subsequently modified by forces and by the simulation. If either vx or vy is NaN, the velocity is initialized to ⟨0,0⟩. If either x or y is NaN, the position is initialized in a phyllotaxis arrangement, so chosen to ensure a deterministic, uniform distribution.To fix a node in a given position, you may specify two additional properties:fx - the node’s fixed x-positionfy - the node’s fixed y-positionAt the end of each tick, after the application of any forces, a node with a defined node.fx has node.x reset to this value and node.vx set to zero; likewise, a node with a defined node.fy has node.y reset to this value and node.vy set to zero. To unfix a node that was previously fixed, set node.fx and node.fy to null, or delete these properties.If the specified array of nodes is modified, such as when nodes are added to or removed from the simulation, this method must be called again with the new (or changed) array to notify the simulation and bound forces of the change; the simulation does not make a defensive copy of the specified array.simulation.alpha(alpha) ​Source · alpha is roughly analogous to temperature in simulated annealing. It decreases over time as the simulation “cools down”. When alpha reaches alphaMin, the simulation stops; see simulation.restart.If alpha is specified, sets the current alpha to the specified number in the range [0,1] and returns this simulation. If alpha is not specified, returns the current alpha value, which defaults to 1.simulation.alphaMin(min) ​Source · If min is specified, sets the minimum alpha to the specified number in the range [0,1] and returns this simulation. If min is not specified, returns the current minimum alpha value, which defaults to 0.001. The simulation’s internal timer stops when the current alpha is less than the minimum alpha. The default alpha decay rate of ~0.0228 corresponds to 300 iterations.simulation.alphaDecay(decay) ​Source · If decay is specified, sets the alpha decay rate to the specified number in the range [0,1] and returns this simulation. If decay is not specified, returns the current alpha decay rate, which defaults to 0.0228… = 1 - pow(0.001, 1 / 300) where 0.001 is the default minimum alpha.The alpha decay rate determines how quickly the current alpha interpolates towards the desired target alpha; since the default target alpha is zero, by default this controls how quickly the simulation cools. Higher decay rates cause the simulation to stabilize more quickly, but risk getting stuck in a local minimum; lower values cause the simulation to take longer to run, but typically converge on a better layout. To have the simulation run forever at the current alpha, set the decay rate to zero; alternatively, set a target alpha greater than the minimum alpha.simulation.alphaTarget(target) ​Source · If target is specified, sets the current target alpha to the specified number in the range [0,1] and returns this simulation. If target is not specified, returns the current target alpha value, which defaults to 0.simulation.velocityDecay(decay) ​Source · If decay is specified, sets the velocity decay factor to the specified number in the range [0,1] and returns this simulation. If decay is not specified, returns the current velocity decay factor, which defaults to 0.4. The decay factor is akin to atmospheric friction; after the application of any forces during a tick, each node’s velocity is multiplied by 1 - decay. As with lowering the alpha decay rate, less velocity decay may converge on a better solution, but risks numerical instabilities and oscillation.simulation.force(name, force) ​Source · If force is specified, assigns the force for the specified name and returns this simulation. If force is not specified, returns the force with the specified name, or undefined if there is no such force. (By default, new simulations have no forces.) For example, to create a new simulation to layout a graph, you might say:jsconst simulation = d3.forceSimulation(nodes)
    .force("charge", d3.forceManyBody())
    .force("link", d3.forceLink(links))
    .force("center", d3.forceCenter());To remove the force with the given name, pass null as the force. For example, to remove the charge force:jssimulation.force("charge", null);simulation.find(x, y, radius) ​Source · Returns the node closest to the position ⟨x,y⟩ with the given search radius. If radius is not specified, it defaults to infinity. If there is no node within the search area, returns undefined.simulation.randomSource(source) ​Source)If source is specified, sets the function used to generate random numbers; this should be a function that returns a number between 0 (inclusive) and 1 (exclusive). If source is not specified, returns this simulation’s current random source which defaults to a fixed-seed linear congruential generator. See also random.source.simulation.on(typenames, listener) ​Source · If listener is specified, sets the event listener for the specified typenames and returns this simulation. If an event listener was already registered for the same type and name, the existing listener is removed before the new listener is added. If listener is null, removes the current event listeners for the specified typenames, if any. If listener is not specified, returns the first currently-assigned listener matching the specified typenames, if any. When a specified event is dispatched, each listener will be invoked with the this context as the simulation.The typenames is a string containing one or more typename separated by whitespace. Each typename is a type, optionally followed by a period (.) and a name, such as tick.foo and tick.bar; the name allows multiple listeners to be registered for the same type. The type must be one of the following:tick - after each tick of the simulation’s internal timer.end - after the simulation’s timer stops when alpha < alphaMin.Note that tick events are not dispatched when simulation.tick is called manually; events are only dispatched by the internal timer and are intended for interactive rendering of the simulation. To affect the simulation, register forces instead of modifying nodes’ positions or velocities inside a tick event listener.See dispatch.on for details.Custom forces ​A force is a function that modifies nodes’ positions or velocities. It can simulate a physical force such as electrical charge or gravity, or it can resolve a geometric constraint such as keeping nodes within a bounding box or keeping linked nodes a fixed distance apart. For example, here is a force that moves nodes towards the origin:jsfunction force(alpha) {
  for (let i = 0, n = nodes.length, node, k = alpha * 0.1; i < n; ++i) {
    node = nodes[i];
    node.vx -= node.x * k;
    node.vy -= node.y * k;
  }
}Forces typically read the node’s current position ⟨x,y⟩ and then mutate the node’s velocity ⟨vx,vy⟩. Forces may also “peek ahead” to the anticipated next position of the node, ⟨x + vx,y + vy⟩; this is necessary for resolving geometric constraints through iterative relaxation. Forces may also modify the position directly, which is sometimes useful to avoid adding energy to the simulation, such as when recentering the simulation in the viewport.force(alpha) ​Applies this force, optionally observing the specified alpha. Typically, the force is applied to the array of nodes previously passed to force.initialize, however, some forces may apply to a subset of nodes, or behave differently. For example, forceLink applies to the source and target of each link.force.initialize(nodes) ​Supplies the array of nodes and random source to this force. This method is called when a force is bound to a simulation via simulation.force and when the simulation’s nodes change via simulation.nodes. A force may perform necessary work during initialization, such as evaluating per-node parameters, to avoid repeatedly performing work during each application of the force.PagerPrevious paged3-forceNext pageCenter force\n\nForce simulations ​A force simulation implements a velocity Verlet numerical integrator for simulating physical forces on particles (nodes). The simulation assumes a constant unit time step Δt = 1 for each step and a constant unit mass m = 1 for all particles. As a result, a force F acting on a particle is equivalent to a constant acceleration a over the time interval Δt, and can be simulated simply by adding to the particle’s velocity, which is then added to the particle’s position.forceSimulation(nodes) ​Source · Creates a new simulation with the specified array of nodes and no forces. If nodes is not specified, it defaults to the empty array.WARNINGThis function is impure; it mutates the passed-in nodes. See simulation.nodes.jsconst simulation = d3.forceSimulation(nodes);The simulator starts automatically; use simulation.on to listen for tick events as the simulation runs. If you wish to run the simulation manually instead, call simulation.stop, and then call simulation.tick as desired.simulation.restart() ​Source · Restarts the simulation’s internal timer and returns the simulation. In conjunction with simulation.alphaTarget or simulation.alpha, this method can be used to “reheat” the simulation during interaction, such as when dragging a node, or to resume the simulation after temporarily pausing it with simulation.stop.simulation.stop() ​Source · Stops the simulation’s internal timer, if it is running, and returns the simulation. If the timer is already stopped, this method does nothing. This method is useful for running the simulation manually; see simulation.tick.simulation.tick(iterations) ​Source · Manually steps the simulation by the specified number of iterations, and returns the simulation. If iterations is not specified, it defaults to 1 (single step).For each iteration, it increments the current alpha by (alphaTarget - alpha) × alphaDecay; then invokes each registered force, passing the new alpha; then decrements each node’s velocity by velocity × velocityDecay; lastly increments each node’s position by velocity.This method does not dispatch events; events are only dispatched by the internal timer when the simulation is started automatically upon creation or by calling simulation.restart. The natural number of ticks when the simulation is started is ⌈log(alphaMin) / log(1 - alphaDecay)⌉; by default, this is 300.This method can be used in conjunction with simulation.stop to compute a static force layout. For large graphs, static layouts should be computed in a web worker to avoid freezing the user interface.simulation.nodes(nodes) ​Source · If nodes is specified, sets the simulation’s nodes to the specified array of objects, initializing their positions and velocities if necessary, and then re-initializes any bound forces; returns the simulation. If nodes is not specified, returns the simulation’s array of nodes as specified to the constructor.WARNINGThis function is impure; it mutates the passed-in nodes to assign the index node.index, the position node.x & node.y, and the velocity node.vx & node.vy. The position and velocity are further updated as the simulation runs by simulation.tick.Each node must be an object. The following properties are assigned by the simulation:index - the node’s zero-based index into nodesx - the node’s current x-positiony - the node’s current y-positionvx - the node’s current x-velocityvy - the node’s current y-velocityThe position ⟨x,y⟩ and velocity ⟨vx,vy⟩ may be subsequently modified by forces and by the simulation. If either vx or vy is NaN, the velocity is initialized to ⟨0,0⟩. If either x or y is NaN, the position is initialized in a phyllotaxis arrangement, so chosen to ensure a deterministic, uniform distribution.To fix a node in a given position, you may specify two additional properties:fx - the node’s fixed x-positionfy - the node’s fixed y-positionAt the end of each tick, after the application of any forces, a node with a defined node.fx has node.x reset to this value and node.vx set to zero; likewise, a node with a defined node.fy has node.y reset to this value and node.vy set to zero. To unfix a node that was previously fixed, set node.fx and node.fy to null, or delete these properties.If the specified array of nodes is modified, such as when nodes are added to or removed from the simulation, this method must be called again with the new (or changed) array to notify the simulation and bound forces of the change; the simulation does not make a defensive copy of the specified array.simulation.alpha(alpha) ​Source · alpha is roughly analogous to temperature in simulated annealing. It decreases over time as the simulation “cools down”. When alpha reaches alphaMin, the simulation stops; see simulation.restart.If alpha is specified, sets the current alpha to the specified number in the range [0,1] and returns this simulation. If alpha is not specified, returns the current alpha value, which defaults to 1.simulation.alphaMin(min) ​Source · If min is specified, sets the minimum alpha to the specified number in the range [0,1] and returns this simulation. If min is not specified, returns the current minimum alpha value, which defaults to 0.001. The simulation’s internal timer stops when the current alpha is less than the minimum alpha. The default alpha decay rate of ~0.0228 corresponds to 300 iterations.simulation.alphaDecay(decay) ​Source · If decay is specified, sets the alpha decay rate to the specified number in the range [0,1] and returns this simulation. If decay is not specified, returns the current alpha decay rate, which defaults to 0.0228… = 1 - pow(0.001, 1 / 300) where 0.001 is the default minimum alpha.The alpha decay rate determines how quickly the current alpha interpolates towards the desired target alpha; since the default target alpha is zero, by default this controls how quickly the simulation cools. Higher decay rates cause the simulation to stabilize more quickly, but risk getting stuck in a local minimum; lower values cause the simulation to take longer to run, but typically converge on a better layout. To have the simulation run forever at the current alpha, set the decay rate to zero; alternatively, set a target alpha greater than the minimum alpha.simulation.alphaTarget(target) ​Source · If target is specified, sets the current target alpha to the specified number in the range [0,1] and returns this simulation. If target is not specified, returns the current target alpha value, which defaults to 0.simulation.velocityDecay(decay) ​Source · If decay is specified, sets the velocity decay factor to the specified number in the range [0,1] and returns this simulation. If decay is not specified, returns the current velocity decay factor, which defaults to 0.4. The decay factor is akin to atmospheric friction; after the application of any forces during a tick, each node’s velocity is multiplied by 1 - decay. As with lowering the alpha decay rate, less velocity decay may converge on a better solution, but risks numerical instabilities and oscillation.simulation.force(name, force) ​Source · If force is specified, assigns the force for the specified name and returns this simulation. If force is not specified, returns the force with the specified name, or undefined if there is no such force. (By default, new simulations have no forces.) For example, to create a new simulation to layout a graph, you might say:jsconst simulation = d3.forceSimulation(nodes)
    .force("charge", d3.forceManyBody())
    .force("link", d3.forceLink(links))
    .force("center", d3.forceCenter());To remove the force with the given name, pass null as the force. For example, to remove the charge force:jssimulation.force("charge", null);simulation.find(x, y, radius) ​Source · Returns the node closest to the position ⟨x,y⟩ with the given search radius. If radius is not specified, it defaults to infinity. If there is no node within the search area, returns undefined.simulation.randomSource(source) ​Source)If source is specified, sets the function used to generate random numbers; this should be a function that returns a number between 0 (inclusive) and 1 (exclusive). If source is not specified, returns this simulation’s current random source which defaults to a fixed-seed linear congruential generator. See also random.source.simulation.on(typenames, listener) ​Source · If listener is specified, sets the event listener for the specified typenames and returns this simulation. If an event listener was already registered for the same type and name, the existing listener is removed before the new listener is added. If listener is null, removes the current event listeners for the specified typenames, if any. If listener is not specified, returns the first currently-assigned listener matching the specified typenames, if any. When a specified event is dispatched, each listener will be invoked with the this context as the simulation.The typenames is a string containing one or more typename separated by whitespace. Each typename is a type, optionally followed by a period (.) and a name, such as tick.foo and tick.bar; the name allows multiple listeners to be registered for the same type. The type must be one of the following:tick - after each tick of the simulation’s internal timer.end - after the simulation’s timer stops when alpha < alphaMin.Note that tick events are not dispatched when simulation.tick is called manually; events are only dispatched by the internal timer and are intended for interactive rendering of the simulation. To affect the simulation, register forces instead of modifying nodes’ positions or velocities inside a tick event listener.See dispatch.on for details.Custom forces ​A force is a function that modifies nodes’ positions or velocities. It can simulate a physical force such as electrical charge or gravity, or it can resolve a geometric constraint such as keeping nodes within a bounding box or keeping linked nodes a fixed distance apart. For example, here is a force that moves nodes towards the origin:jsfunction force(alpha) {
  for (let i = 0, n = nodes.length, node, k = alpha * 0.1; i < n; ++i) {
    node = nodes[i];
    node.vx -= node.x * k;
    node.vy -= node.y * k;
  }
}Forces typically read the node’s current position ⟨x,y⟩ and then mutate the node’s velocity ⟨vx,vy⟩. Forces may also “peek ahead” to the anticipated next position of the node, ⟨x + vx,y + vy⟩; this is necessary for resolving geometric constraints through iterative relaxation. Forces may also modify the position directly, which is sometimes useful to avoid adding energy to the simulation, such as when recentering the simulation in the viewport.force(alpha) ​Applies this force, optionally observing the specified alpha. Typically, the force is applied to the array of nodes previously passed to force.initialize, however, some forces may apply to a subset of nodes, or behave differently. For example, forceLink applies to the source and target of each link.force.initialize(nodes) ​Supplies the array of nodes and random source to this force. This method is called when a force is bound to a simulation via simulation.force and when the simulation’s nodes change via simulation.nodes. A force may perform necessary work during initialization, such as evaluating per-node parameters, to avoid repeatedly performing work during each application of the force.\n\n\n\nCenter force ​The center force translates nodes uniformly so that the mean position of all nodes (the center of mass if all nodes have equal weight) is at the given position ⟨x,y⟩. This force modifies the positions of nodes on each application; it does not modify velocities, as doing so would typically cause the nodes to overshoot and oscillate around the desired center. This force helps keep nodes in the center of the viewport, and unlike the position forces, it does not distort their relative positions.forceCenter(x, y) ​Source · Creates a new center force with the specified x- and y- coordinates. If x and y are not specified, they default to ⟨0,0⟩.jsconst center = d3.forceCenter(width / 2, height / 2);center.x(x) ​Source · If x is specified, sets the x-coordinate of the centering position to the specified number and returns this force. If x is not specified, returns the current x-coordinate, which defaults to zero.center.y(y) ​Source · If y is specified, sets the y coordinate of the centering position to the specified number and returns this force. If y is not specified, returns the current y coordinate, which defaults to zero.center.strength(strength) ​Examples · Source · If strength is specified, sets the center force’s strength. A reduced strength of e.g. 0.05 softens the movements on interactive graphs in which new nodes enter or exit the graph. If strength is not specified, returns the force’s current strength, which defaults to 1.\n\nSearchK7.9.0GitHub️ 110.0kOn this pageCenter force ​The center force translates nodes uniformly so that the mean position of all nodes (the center of mass if all nodes have equal weight) is at the given position ⟨x,y⟩. This force modifies the positions of nodes on each application; it does not modify velocities, as doing so would typically cause the nodes to overshoot and oscillate around the desired center. This force helps keep nodes in the center of the viewport, and unlike the position forces, it does not distort their relative positions.forceCenter(x, y) ​Source · Creates a new center force with the specified x- and y- coordinates. If x and y are not specified, they default to ⟨0,0⟩.jsconst center = d3.forceCenter(width / 2, height / 2);center.x(x) ​Source · If x is specified, sets the x-coordinate of the centering position to the specified number and returns this force. If x is not specified, returns the current x-coordinate, which defaults to zero.center.y(y) ​Source · If y is specified, sets the y coordinate of the centering position to the specified number and returns this force. If y is not specified, returns the current y coordinate, which defaults to zero.center.strength(strength) ​Examples · Source · If strength is specified, sets the center force’s strength. A reduced strength of e.g. 0.05 softens the movements on interactive graphs in which new nodes enter or exit the graph. If strength is not specified, returns the force’s current strength, which defaults to 1.PagerPrevious pageForce simulationsNext pageCollide force\n\nCenter force ​The center force translates nodes uniformly so that the mean position of all nodes (the center of mass if all nodes have equal weight) is at the given position ⟨x,y⟩. This force modifies the positions of nodes on each application; it does not modify velocities, as doing so would typically cause the nodes to overshoot and oscillate around the desired center. This force helps keep nodes in the center of the viewport, and unlike the position forces, it does not distort their relative positions.forceCenter(x, y) ​Source · Creates a new center force with the specified x- and y- coordinates. If x and y are not specified, they default to ⟨0,0⟩.jsconst center = d3.forceCenter(width / 2, height / 2);center.x(x) ​Source · If x is specified, sets the x-coordinate of the centering position to the specified number and returns this force. If x is not specified, returns the current x-coordinate, which defaults to zero.center.y(y) ​Source · If y is specified, sets the y coordinate of the centering position to the specified number and returns this force. If y is not specified, returns the current y coordinate, which defaults to zero.center.strength(strength) ​Examples · Source · If strength is specified, sets the center force’s strength. A reduced strength of e.g. 0.05 softens the movements on interactive graphs in which new nodes enter or exit the graph. If strength is not specified, returns the force’s current strength, which defaults to 1.\n\n\n\nCollide force ​Fork ↗︎The collide force treats nodes as circles with a given radius, rather than points, and prevents nodes from overlapping. More formally, two nodes a and b are separated so that the distance between a and b is at least radius(a) + radius(b). To reduce jitter, this is by default a “soft” constraint with a configurable strength and iteration count.forceCollide(radius) ​Source · Creates a new circle collide force with the specified radius. If radius is not specified, it defaults to the constant one for all nodes.jsconst collide = d3.forceCollide((d) => d.r);collide.radius(radius) ​Source · If radius is specified, sets the radius accessor to the specified number or function, re-evaluates the radius accessor for each node, and returns this force. If radius is not specified, returns the current radius accessor, which defaults to:jsfunction radius() {
  return 1;
}The radius accessor is invoked for each node in the simulation, being passed the node and its zero-based index. The resulting number is then stored internally, such that the radius of each node is only recomputed when the force is initialized or when this method is called with a new radius, and not on every application of the force.collide.strength(strength) ​Source · If strength is specified, sets the force strength to the specified number in the range [0,1] and returns this force. If strength is not specified, returns the current strength which defaults to 1.Overlapping nodes are resolved through iterative relaxation. For each node, the other nodes that are anticipated to overlap at the next tick (using the anticipated positions ⟨x + vx,y + vy⟩) are determined; the node’s velocity is then modified to push the node out of each overlapping node. The change in velocity is dampened by the force’s strength such that the resolution of simultaneous overlaps can be blended together to find a stable solution.collide.iterations(iterations) ​Source · If iterations is specified, sets the number of iterations per application to the specified number and returns this force. If iterations is not specified, returns the current iteration count which defaults to 1. Increasing the number of iterations greatly increases the rigidity of the constraint and avoids partial overlap of nodes, but also increases the runtime cost to evaluate the force.\n\nSearchK7.9.0GitHub️ 110.0kOn this pageCollide force ​Fork ↗︎The collide force treats nodes as circles with a given radius, rather than points, and prevents nodes from overlapping. More formally, two nodes a and b are separated so that the distance between a and b is at least radius(a) + radius(b). To reduce jitter, this is by default a “soft” constraint with a configurable strength and iteration count.forceCollide(radius) ​Source · Creates a new circle collide force with the specified radius. If radius is not specified, it defaults to the constant one for all nodes.jsconst collide = d3.forceCollide((d) => d.r);collide.radius(radius) ​Source · If radius is specified, sets the radius accessor to the specified number or function, re-evaluates the radius accessor for each node, and returns this force. If radius is not specified, returns the current radius accessor, which defaults to:jsfunction radius() {
  return 1;
}The radius accessor is invoked for each node in the simulation, being passed the node and its zero-based index. The resulting number is then stored internally, such that the radius of each node is only recomputed when the force is initialized or when this method is called with a new radius, and not on every application of the force.collide.strength(strength) ​Source · If strength is specified, sets the force strength to the specified number in the range [0,1] and returns this force. If strength is not specified, returns the current strength which defaults to 1.Overlapping nodes are resolved through iterative relaxation. For each node, the other nodes that are anticipated to overlap at the next tick (using the anticipated positions ⟨x + vx,y + vy⟩) are determined; the node’s velocity is then modified to push the node out of each overlapping node. The change in velocity is dampened by the force’s strength such that the resolution of simultaneous overlaps can be blended together to find a stable solution.collide.iterations(iterations) ​Source · If iterations is specified, sets the number of iterations per application to the specified number and returns this force. If iterations is not specified, returns the current iteration count which defaults to 1. Increasing the number of iterations greatly increases the rigidity of the constraint and avoids partial overlap of nodes, but also increases the runtime cost to evaluate the force.PagerPrevious pageCenter forceNext pageLink force\n\nCollide force ​Fork ↗︎The collide force treats nodes as circles with a given radius, rather than points, and prevents nodes from overlapping. More formally, two nodes a and b are separated so that the distance between a and b is at least radius(a) + radius(b). To reduce jitter, this is by default a “soft” constraint with a configurable strength and iteration count.forceCollide(radius) ​Source · Creates a new circle collide force with the specified radius. If radius is not specified, it defaults to the constant one for all nodes.jsconst collide = d3.forceCollide((d) => d.r);collide.radius(radius) ​Source · If radius is specified, sets the radius accessor to the specified number or function, re-evaluates the radius accessor for each node, and returns this force. If radius is not specified, returns the current radius accessor, which defaults to:jsfunction radius() {
  return 1;
}The radius accessor is invoked for each node in the simulation, being passed the node and its zero-based index. The resulting number is then stored internally, such that the radius of each node is only recomputed when the force is initialized or when this method is called with a new radius, and not on every application of the force.collide.strength(strength) ​Source · If strength is specified, sets the force strength to the specified number in the range [0,1] and returns this force. If strength is not specified, returns the current strength which defaults to 1.Overlapping nodes are resolved through iterative relaxation. For each node, the other nodes that are anticipated to overlap at the next tick (using the anticipated positions ⟨x + vx,y + vy⟩) are determined; the node’s velocity is then modified to push the node out of each overlapping node. The change in velocity is dampened by the force’s strength such that the resolution of simultaneous overlaps can be blended together to find a stable solution.collide.iterations(iterations) ​Source · If iterations is specified, sets the number of iterations per application to the specified number and returns this force. If iterations is not specified, returns the current iteration count which defaults to 1. Increasing the number of iterations greatly increases the rigidity of the constraint and avoids partial overlap of nodes, but also increases the runtime cost to evaluate the force.\n\n\n\nLink force ​Fork ↗︎The link force pushes linked nodes together or apart according to the desired link distance. The strength of the force is proportional to the difference between the linked nodes’ distance and the target distance, similar to a spring force.forceLink(links) ​Source · Creates a new link force with the specified links and default parameters. If links is not specified, it defaults to the empty array.WARNINGThis function is impure; it may mutate the passed-in links. See link.links.jsconst link = d3.forceLink(links).id((d) => d.id);link.links(links) ​Source · If links is specified, sets the array of links associated with this force, recomputes the distance and strength parameters for each link, and returns this force. If links is not specified, returns the current array of links, which defaults to the empty array.Each link is an object with the following properties:source - the link’s source node; see simulation.nodestarget - the link’s target node; see simulation.nodesindex - the zero-based index into links, assigned by this methodFor convenience, a link’s source and target properties may be initialized using numeric or string identifiers rather than object references; see link.id.WARNINGThis function is impure; it may mutate the passed-in links when the link force is initialized (or re-initialized, as when the nodes or links change). Any link.source or link.target property which is not an object is replaced by an object reference to the corresponding node with the given identifier.If the specified array of links is modified, such as when links are added to or removed from the simulation, this method must be called again with the new (or changed) array to notify the force of the change; the force does not make a defensive copy of the specified array.link.id(id) ​Source · If id is specified, sets the node id accessor to the specified function and returns this force. If id is not specified, returns the current node id accessor, which defaults to the numeric node.index:jsfunction id(d) {
  return d.index;
}The default id accessor allows each link’s source and target to be specified as a zero-based index into the nodes array. For example:jsconst nodes = [
  {"id": "Alice"},
  {"id": "Bob"},
  {"id": "Carol"}
];

const links = [
  {"source": 0, "target": 1}, // Alice → Bob
  {"source": 1, "target": 2} // Bob → Carol
];Now consider a different id accessor that returns a string:jsfunction id(d) {
  return d.id;
}With this accessor, you can use named sources and targets:jsconst nodes = [
  {"id": "Alice"},
  {"id": "Bob"},
  {"id": "Carol"}
];

const links = [
  {"source": "Alice", "target": "Bob"},
  {"source": "Bob", "target": "Carol"}
];This is particularly useful when representing graphs in JSON, as JSON does not allow references. See this example.The id accessor is invoked for each node whenever the force is initialized, as when the nodes or links change, being passed the node and its zero-based index.link.distance(distance) ​Source · If distance is specified, sets the distance accessor to the specified number or function, re-evaluates the distance accessor for each link, and returns this force. If distance is not specified, returns the current distance accessor, which defaults to:jsfunction distance() {
  return 30;
}The distance accessor is invoked for each link, being passed the link and its zero-based index. The resulting number is then stored internally, such that the distance of each link is only recomputed when the force is initialized or when this method is called with a new distance, and not on every application of the force.link.strength(strength) ​Source · If strength is specified, sets the strength accessor to the specified number or function, re-evaluates the strength accessor for each link, and returns this force. If strength is not specified, returns the current strength accessor, which defaults to:jsfunction strength(link) {
  return 1 / Math.min(count(link.source), count(link.target));
}Where count(node) is a function that returns the number of links with the given node as a source or target. This default was chosen because it automatically reduces the strength of links connected to heavily-connected nodes, improving stability.The strength accessor is invoked for each link, being passed the link and its zero-based index. The resulting number is then stored internally, such that the strength of each link is only recomputed when the force is initialized or when this method is called with a new strength, and not on every application of the force.link.iterations(iterations) ​Source · If iterations is specified, sets the number of iterations per application to the specified number and returns this force. If iterations is not specified, returns the current iteration count which defaults to 1. Increasing the number of iterations greatly increases the rigidity of the constraint and is useful for complex structures such as lattices, but also increases the runtime cost to evaluate the force.\n\nSearchK7.9.0GitHub️ 110.0kOn this pageLink force ​Fork ↗︎The link force pushes linked nodes together or apart according to the desired link distance. The strength of the force is proportional to the difference between the linked nodes’ distance and the target distance, similar to a spring force.forceLink(links) ​Source · Creates a new link force with the specified links and default parameters. If links is not specified, it defaults to the empty array.WARNINGThis function is impure; it may mutate the passed-in links. See link.links.jsconst link = d3.forceLink(links).id((d) => d.id);link.links(links) ​Source · If links is specified, sets the array of links associated with this force, recomputes the distance and strength parameters for each link, and returns this force. If links is not specified, returns the current array of links, which defaults to the empty array.Each link is an object with the following properties:source - the link’s source node; see simulation.nodestarget - the link’s target node; see simulation.nodesindex - the zero-based index into links, assigned by this methodFor convenience, a link’s source and target properties may be initialized using numeric or string identifiers rather than object references; see link.id.WARNINGThis function is impure; it may mutate the passed-in links when the link force is initialized (or re-initialized, as when the nodes or links change). Any link.source or link.target property which is not an object is replaced by an object reference to the corresponding node with the given identifier.If the specified array of links is modified, such as when links are added to or removed from the simulation, this method must be called again with the new (or changed) array to notify the force of the change; the force does not make a defensive copy of the specified array.link.id(id) ​Source · If id is specified, sets the node id accessor to the specified function and returns this force. If id is not specified, returns the current node id accessor, which defaults to the numeric node.index:jsfunction id(d) {
  return d.index;
}The default id accessor allows each link’s source and target to be specified as a zero-based index into the nodes array. For example:jsconst nodes = [
  {"id": "Alice"},
  {"id": "Bob"},
  {"id": "Carol"}
];

const links = [
  {"source": 0, "target": 1}, // Alice → Bob
  {"source": 1, "target": 2} // Bob → Carol
];Now consider a different id accessor that returns a string:jsfunction id(d) {
  return d.id;
}With this accessor, you can use named sources and targets:jsconst nodes = [
  {"id": "Alice"},
  {"id": "Bob"},
  {"id": "Carol"}
];

const links = [
  {"source": "Alice", "target": "Bob"},
  {"source": "Bob", "target": "Carol"}
];This is particularly useful when representing graphs in JSON, as JSON does not allow references. See this example.The id accessor is invoked for each node whenever the force is initialized, as when the nodes or links change, being passed the node and its zero-based index.link.distance(distance) ​Source · If distance is specified, sets the distance accessor to the specified number or function, re-evaluates the distance accessor for each link, and returns this force. If distance is not specified, returns the current distance accessor, which defaults to:jsfunction distance() {
  return 30;
}The distance accessor is invoked for each link, being passed the link and its zero-based index. The resulting number is then stored internally, such that the distance of each link is only recomputed when the force is initialized or when this method is called with a new distance, and not on every application of the force.link.strength(strength) ​Source · If strength is specified, sets the strength accessor to the specified number or function, re-evaluates the strength accessor for each link, and returns this force. If strength is not specified, returns the current strength accessor, which defaults to:jsfunction strength(link) {
  return 1 / Math.min(count(link.source), count(link.target));
}Where count(node) is a function that returns the number of links with the given node as a source or target. This default was chosen because it automatically reduces the strength of links connected to heavily-connected nodes, improving stability.The strength accessor is invoked for each link, being passed the link and its zero-based index. The resulting number is then stored internally, such that the strength of each link is only recomputed when the force is initialized or when this method is called with a new strength, and not on every application of the force.link.iterations(iterations) ​Source · If iterations is specified, sets the number of iterations per application to the specified number and returns this force. If iterations is not specified, returns the current iteration count which defaults to 1. Increasing the number of iterations greatly increases the rigidity of the constraint and is useful for complex structures such as lattices, but also increases the runtime cost to evaluate the force.PagerPrevious pageCollide forceNext pageMany-body force\n\nLink force ​Fork ↗︎The link force pushes linked nodes together or apart according to the desired link distance. The strength of the force is proportional to the difference between the linked nodes’ distance and the target distance, similar to a spring force.forceLink(links) ​Source · Creates a new link force with the specified links and default parameters. If links is not specified, it defaults to the empty array.WARNINGThis function is impure; it may mutate the passed-in links. See link.links.jsconst link = d3.forceLink(links).id((d) => d.id);link.links(links) ​Source · If links is specified, sets the array of links associated with this force, recomputes the distance and strength parameters for each link, and returns this force. If links is not specified, returns the current array of links, which defaults to the empty array.Each link is an object with the following properties:source - the link’s source node; see simulation.nodestarget - the link’s target node; see simulation.nodesindex - the zero-based index into links, assigned by this methodFor convenience, a link’s source and target properties may be initialized using numeric or string identifiers rather than object references; see link.id.WARNINGThis function is impure; it may mutate the passed-in links when the link force is initialized (or re-initialized, as when the nodes or links change). Any link.source or link.target property which is not an object is replaced by an object reference to the corresponding node with the given identifier.If the specified array of links is modified, such as when links are added to or removed from the simulation, this method must be called again with the new (or changed) array to notify the force of the change; the force does not make a defensive copy of the specified array.link.id(id) ​Source · If id is specified, sets the node id accessor to the specified function and returns this force. If id is not specified, returns the current node id accessor, which defaults to the numeric node.index:jsfunction id(d) {
  return d.index;
}The default id accessor allows each link’s source and target to be specified as a zero-based index into the nodes array. For example:jsconst nodes = [
  {"id": "Alice"},
  {"id": "Bob"},
  {"id": "Carol"}
];

const links = [
  {"source": 0, "target": 1}, // Alice → Bob
  {"source": 1, "target": 2} // Bob → Carol
];Now consider a different id accessor that returns a string:jsfunction id(d) {
  return d.id;
}With this accessor, you can use named sources and targets:jsconst nodes = [
  {"id": "Alice"},
  {"id": "Bob"},
  {"id": "Carol"}
];

const links = [
  {"source": "Alice", "target": "Bob"},
  {"source": "Bob", "target": "Carol"}
];This is particularly useful when representing graphs in JSON, as JSON does not allow references. See this example.The id accessor is invoked for each node whenever the force is initialized, as when the nodes or links change, being passed the node and its zero-based index.link.distance(distance) ​Source · If distance is specified, sets the distance accessor to the specified number or function, re-evaluates the distance accessor for each link, and returns this force. If distance is not specified, returns the current distance accessor, which defaults to:jsfunction distance() {
  return 30;
}The distance accessor is invoked for each link, being passed the link and its zero-based index. The resulting number is then stored internally, such that the distance of each link is only recomputed when the force is initialized or when this method is called with a new distance, and not on every application of the force.link.strength(strength) ​Source · If strength is specified, sets the strength accessor to the specified number or function, re-evaluates the strength accessor for each link, and returns this force. If strength is not specified, returns the current strength accessor, which defaults to:jsfunction strength(link) {
  return 1 / Math.min(count(link.source), count(link.target));
}Where count(node) is a function that returns the number of links with the given node as a source or target. This default was chosen because it automatically reduces the strength of links connected to heavily-connected nodes, improving stability.The strength accessor is invoked for each link, being passed the link and its zero-based index. The resulting number is then stored internally, such that the strength of each link is only recomputed when the force is initialized or when this method is called with a new strength, and not on every application of the force.link.iterations(iterations) ​Source · If iterations is specified, sets the number of iterations per application to the specified number and returns this force. If iterations is not specified, returns the current iteration count which defaults to 1. Increasing the number of iterations greatly increases the rigidity of the constraint and is useful for complex structures such as lattices, but also increases the runtime cost to evaluate the force.\n\n\n\nMany-body force ​The many-body (or n-body) force applies mutually amongst all nodes. It can be used to simulate gravity (attraction) if the strength is positive, or electrostatic charge (repulsion) if the strength is negative. This implementation uses a quadtree and the Barnes–Hut approximation to greatly improve performance; the accuracy can be customized using the theta parameter.Unlike the link force, which only affect two linked nodes, the charge force is global: every node affects every other node, even if they are on disconnected subgraphs.forceManyBody() ​Source · Creates a new many-body force with the default parameters.jsconst manyBody = d3.forceManyBody().strength(-100);manyBody.strength(strength) ​Source · If strength is specified, sets the strength accessor to the specified number or function, re-evaluates the strength accessor for each node, and returns this force. A positive value causes nodes to attract each other, similar to gravity, while a negative value causes nodes to repel each other, similar to electrostatic charge. If strength is not specified, returns the current strength accessor, which defaults to:jsfunction strength() {
  return -30;
}The strength accessor is invoked for each node in the simulation, being passed the node and its zero-based index. The resulting number is then stored internally, such that the strength of each node is only recomputed when the force is initialized or when this method is called with a new strength, and not on every application of the force.manyBody.theta(theta) ​Source · If theta is specified, sets the Barnes–Hut approximation criterion to the specified number and returns this force. If theta is not specified, returns the current value, which defaults to 0.9.To accelerate computation, this force implements the Barnes–Hut approximation which takes O(n log n) per application where n is the number of nodes. For each application, a quadtree stores the current node positions; then for each node, the combined force of all other nodes on the given node is computed. For a cluster of nodes that is far away, the charge force can be approximated by treating the cluster as a single, larger node. The theta parameter determines the accuracy of the approximation: if the ratio w / l of the width w of the quadtree cell to the distance l from the node to the cell’s center of mass is less than theta, all nodes in the given cell are treated as a single node rather than individually.manyBody.distanceMin(distance) ​Source · If distance is specified, sets the minimum distance between nodes over which this force is considered. If distance is not specified, returns the current minimum distance, which defaults to 1. A minimum distance establishes an upper bound on the strength of the force between two nearby nodes, avoiding instability. In particular, it avoids an infinitely-strong force if two nodes are exactly coincident; in this case, the direction of the force is random.manyBody.distanceMax(distance) ​Source · If distance is specified, sets the maximum distance between nodes over which this force is considered. If distance is not specified, returns the current maximum distance, which defaults to infinity. Specifying a finite maximum distance improves performance and produces a more localized layout.\n\nSearchK7.9.0GitHub️ 110.0kOn this pageMany-body force ​The many-body (or n-body) force applies mutually amongst all nodes. It can be used to simulate gravity (attraction) if the strength is positive, or electrostatic charge (repulsion) if the strength is negative. This implementation uses a quadtree and the Barnes–Hut approximation to greatly improve performance; the accuracy can be customized using the theta parameter.Unlike the link force, which only affect two linked nodes, the charge force is global: every node affects every other node, even if they are on disconnected subgraphs.forceManyBody() ​Source · Creates a new many-body force with the default parameters.jsconst manyBody = d3.forceManyBody().strength(-100);manyBody.strength(strength) ​Source · If strength is specified, sets the strength accessor to the specified number or function, re-evaluates the strength accessor for each node, and returns this force. A positive value causes nodes to attract each other, similar to gravity, while a negative value causes nodes to repel each other, similar to electrostatic charge. If strength is not specified, returns the current strength accessor, which defaults to:jsfunction strength() {
  return -30;
}The strength accessor is invoked for each node in the simulation, being passed the node and its zero-based index. The resulting number is then stored internally, such that the strength of each node is only recomputed when the force is initialized or when this method is called with a new strength, and not on every application of the force.manyBody.theta(theta) ​Source · If theta is specified, sets the Barnes–Hut approximation criterion to the specified number and returns this force. If theta is not specified, returns the current value, which defaults to 0.9.To accelerate computation, this force implements the Barnes–Hut approximation which takes O(n log n) per application where n is the number of nodes. For each application, a quadtree stores the current node positions; then for each node, the combined force of all other nodes on the given node is computed. For a cluster of nodes that is far away, the charge force can be approximated by treating the cluster as a single, larger node. The theta parameter determines the accuracy of the approximation: if the ratio w / l of the width w of the quadtree cell to the distance l from the node to the cell’s center of mass is less than theta, all nodes in the given cell are treated as a single node rather than individually.manyBody.distanceMin(distance) ​Source · If distance is specified, sets the minimum distance between nodes over which this force is considered. If distance is not specified, returns the current minimum distance, which defaults to 1. A minimum distance establishes an upper bound on the strength of the force between two nearby nodes, avoiding instability. In particular, it avoids an infinitely-strong force if two nodes are exactly coincident; in this case, the direction of the force is random.manyBody.distanceMax(distance) ​Source · If distance is specified, sets the maximum distance between nodes over which this force is considered. If distance is not specified, returns the current maximum distance, which defaults to infinity. Specifying a finite maximum distance improves performance and produces a more localized layout.PagerPrevious pageLink forceNext pagePosition forces\n\nMany-body force ​The many-body (or n-body) force applies mutually amongst all nodes. It can be used to simulate gravity (attraction) if the strength is positive, or electrostatic charge (repulsion) if the strength is negative. This implementation uses a quadtree and the Barnes–Hut approximation to greatly improve performance; the accuracy can be customized using the theta parameter.Unlike the link force, which only affect two linked nodes, the charge force is global: every node affects every other node, even if they are on disconnected subgraphs.forceManyBody() ​Source · Creates a new many-body force with the default parameters.jsconst manyBody = d3.forceManyBody().strength(-100);manyBody.strength(strength) ​Source · If strength is specified, sets the strength accessor to the specified number or function, re-evaluates the strength accessor for each node, and returns this force. A positive value causes nodes to attract each other, similar to gravity, while a negative value causes nodes to repel each other, similar to electrostatic charge. If strength is not specified, returns the current strength accessor, which defaults to:jsfunction strength() {
  return -30;
}The strength accessor is invoked for each node in the simulation, being passed the node and its zero-based index. The resulting number is then stored internally, such that the strength of each node is only recomputed when the force is initialized or when this method is called with a new strength, and not on every application of the force.manyBody.theta(theta) ​Source · If theta is specified, sets the Barnes–Hut approximation criterion to the specified number and returns this force. If theta is not specified, returns the current value, which defaults to 0.9.To accelerate computation, this force implements the Barnes–Hut approximation which takes O(n log n) per application where n is the number of nodes. For each application, a quadtree stores the current node positions; then for each node, the combined force of all other nodes on the given node is computed. For a cluster of nodes that is far away, the charge force can be approximated by treating the cluster as a single, larger node. The theta parameter determines the accuracy of the approximation: if the ratio w / l of the width w of the quadtree cell to the distance l from the node to the cell’s center of mass is less than theta, all nodes in the given cell are treated as a single node rather than individually.manyBody.distanceMin(distance) ​Source · If distance is specified, sets the minimum distance between nodes over which this force is considered. If distance is not specified, returns the current minimum distance, which defaults to 1. A minimum distance establishes an upper bound on the strength of the force between two nearby nodes, avoiding instability. In particular, it avoids an infinitely-strong force if two nodes are exactly coincident; in this case, the direction of the force is random.manyBody.distanceMax(distance) ​Source · If distance is specified, sets the maximum distance between nodes over which this force is considered. If distance is not specified, returns the current maximum distance, which defaults to infinity. Specifying a finite maximum distance improves performance and produces a more localized layout.\n\n\n\nPosition forces ​The x- and y-position forces push nodes towards a desired position along the given dimension with a configurable strength. The radial force is similar, except it pushes nodes towards the closest point on a given circle. The strength of the force is proportional to the one-dimensional distance between the node’s position and the target position. While these forces can be used to position individual nodes, they are intended primarily for global forces that apply to all (or most) nodes.forceX(x) ​Source · Creates a new position force along the x-axis towards the given position x. If x is not specified, it defaults to 0.jsconst x = d3.forceX(width / 2);x.strength(strength) ​Source · If strength is specified, sets the strength accessor to the specified number or function, re-evaluates the strength accessor for each node, and returns this force. The strength determines how much to increment the node’s x-velocity: (x - node.x) × strength. For example, a value of 0.1 indicates that the node should move a tenth of the way from its current x-position to the target x-position with each application. Higher values moves nodes more quickly to the target position, often at the expense of other forces or constraints. A value outside the range [0,1] is not recommended.If strength is not specified, returns the current strength accessor, which defaults to:jsfunction strength() {
  return 0.1;
}The strength accessor is invoked for each node in the simulation, being passed the node and its zero-based index. The resulting number is then stored internally, such that the strength of each node is only recomputed when the force is initialized or when this method is called with a new strength, and not on every application of the force.x.x(x) ​Source · If x is specified, sets the x-coordinate accessor to the specified number or function, re-evaluates the x-accessor for each node, and returns this force. If x is not specified, returns the current x-accessor, which defaults to:jsfunction x() {
  return 0;
}The x-accessor is invoked for each node in the simulation, being passed the node and its zero-based index. The resulting number is then stored internally, such that the target x-coordinate of each node is only recomputed when the force is initialized or when this method is called with a new x, and not on every application of the force.forceY(y) ​Source · Creates a new position force along the y-axis towards the given position y. If y is not specified, it defaults to 0.jsconst y = d3.forceY(height / 2);y.strength(strength) ​Source · If strength is specified, sets the strength accessor to the specified number or function, re-evaluates the strength accessor for each node, and returns this force. The strength determines how much to increment the node’s y-velocity: (y - node.y) × strength. For example, a value of 0.1 indicates that the node should move a tenth of the way from its current y-position to the target y-position with each application. Higher values moves nodes more quickly to the target position, often at the expense of other forces or constraints. A value outside the range [0,1] is not recommended.If strength is not specified, returns the current strength accessor, which defaults to:jsfunction strength() {
  return 0.1;
}The strength accessor is invoked for each node in the simulation, being passed the node and its zero-based index. The resulting number is then stored internally, such that the strength of each node is only recomputed when the force is initialized or when this method is called with a new strength, and not on every application of the force.y.y(y) ​Source · If y is specified, sets the y-coordinate accessor to the specified number or function, re-evaluates the y-accessor for each node, and returns this force. If y is not specified, returns the current y-accessor, which defaults to:jsfunction y() {
  return 0;
}The y-accessor is invoked for each node in the simulation, being passed the node and its zero-based index. The resulting number is then stored internally, such that the target y coordinate of each node is only recomputed when the force is initialized or when this method is called with a new y, and not on every application of the force.forceRadial(radius, x, y) ​Source · Creates a new position force towards a circle of the specified radius centered at ⟨x,y⟩. If x and y are not specified, they default to ⟨0,0⟩.jsconst radial = d3.forceRadial(r, width / 2, height / 2);radial.strength(strength) ​Source · If strength is specified, sets the strength accessor to the specified number or function, re-evaluates the strength accessor for each node, and returns this force. The strength determines how much to increment the node’s x- and y-velocity. For example, a value of 0.1 indicates that the node should move a tenth of the way from its current position to the closest point on the circle with each application. Higher values moves nodes more quickly to the target position, often at the expense of other forces or constraints. A value outside the range [0,1] is not recommended.If strength is not specified, returns the current strength accessor, which defaults to:jsfunction strength() {
  return 0.1;
}The strength accessor is invoked for each node in the simulation, being passed the node and its zero-based index. The resulting number is then stored internally, such that the strength of each node is only recomputed when the force is initialized or when this method is called with a new strength, and not on every application of the force.radial.radius(radius) ​Source · If radius is specified, sets the circle radius to the specified number or function, re-evaluates the radius accessor for each node, and returns this force. If radius is not specified, returns the current radius accessor.The radius accessor is invoked for each node in the simulation, being passed the node and its zero-based index. The resulting number is then stored internally, such that the target radius of each node is only recomputed when the force is initialized or when this method is called with a new radius, and not on every application of the force.radial.x(x) ​Source · If x is specified, sets the x-coordinate of the circle center to the specified number and returns this force. If x is not specified, returns the current x-coordinate of the center, which defaults to zero.radial.y(y) ​Source · If y is specified, sets the y coordinate of the circle center to the specified number and returns this force. If y is not specified, returns the current y coordinate of the center, which defaults to zero.\n\nSearchK7.9.0GitHub️ 110.0kOn this pagePosition forces ​The x- and y-position forces push nodes towards a desired position along the given dimension with a configurable strength. The radial force is similar, except it pushes nodes towards the closest point on a given circle. The strength of the force is proportional to the one-dimensional distance between the node’s position and the target position. While these forces can be used to position individual nodes, they are intended primarily for global forces that apply to all (or most) nodes.forceX(x) ​Source · Creates a new position force along the x-axis towards the given position x. If x is not specified, it defaults to 0.jsconst x = d3.forceX(width / 2);x.strength(strength) ​Source · If strength is specified, sets the strength accessor to the specified number or function, re-evaluates the strength accessor for each node, and returns this force. The strength determines how much to increment the node’s x-velocity: (x - node.x) × strength. For example, a value of 0.1 indicates that the node should move a tenth of the way from its current x-position to the target x-position with each application. Higher values moves nodes more quickly to the target position, often at the expense of other forces or constraints. A value outside the range [0,1] is not recommended.If strength is not specified, returns the current strength accessor, which defaults to:jsfunction strength() {
  return 0.1;
}The strength accessor is invoked for each node in the simulation, being passed the node and its zero-based index. The resulting number is then stored internally, such that the strength of each node is only recomputed when the force is initialized or when this method is called with a new strength, and not on every application of the force.x.x(x) ​Source · If x is specified, sets the x-coordinate accessor to the specified number or function, re-evaluates the x-accessor for each node, and returns this force. If x is not specified, returns the current x-accessor, which defaults to:jsfunction x() {
  return 0;
}The x-accessor is invoked for each node in the simulation, being passed the node and its zero-based index. The resulting number is then stored internally, such that the target x-coordinate of each node is only recomputed when the force is initialized or when this method is called with a new x, and not on every application of the force.forceY(y) ​Source · Creates a new position force along the y-axis towards the given position y. If y is not specified, it defaults to 0.jsconst y = d3.forceY(height / 2);y.strength(strength) ​Source · If strength is specified, sets the strength accessor to the specified number or function, re-evaluates the strength accessor for each node, and returns this force. The strength determines how much to increment the node’s y-velocity: (y - node.y) × strength. For example, a value of 0.1 indicates that the node should move a tenth of the way from its current y-position to the target y-position with each application. Higher values moves nodes more quickly to the target position, often at the expense of other forces or constraints. A value outside the range [0,1] is not recommended.If strength is not specified, returns the current strength accessor, which defaults to:jsfunction strength() {
  return 0.1;
}The strength accessor is invoked for each node in the simulation, being passed the node and its zero-based index. The resulting number is then stored internally, such that the strength of each node is only recomputed when the force is initialized or when this method is called with a new strength, and not on every application of the force.y.y(y) ​Source · If y is specified, sets the y-coordinate accessor to the specified number or function, re-evaluates the y-accessor for each node, and returns this force. If y is not specified, returns the current y-accessor, which defaults to:jsfunction y() {
  return 0;
}The y-accessor is invoked for each node in the simulation, being passed the node and its zero-based index. The resulting number is then stored internally, such that the target y coordinate of each node is only recomputed when the force is initialized or when this method is called with a new y, and not on every application of the force.forceRadial(radius, x, y) ​Source · Creates a new position force towards a circle of the specified radius centered at ⟨x,y⟩. If x and y are not specified, they default to ⟨0,0⟩.jsconst radial = d3.forceRadial(r, width / 2, height / 2);radial.strength(strength) ​Source · If strength is specified, sets the strength accessor to the specified number or function, re-evaluates the strength accessor for each node, and returns this force. The strength determines how much to increment the node’s x- and y-velocity. For example, a value of 0.1 indicates that the node should move a tenth of the way from its current position to the closest point on the circle with each application. Higher values moves nodes more quickly to the target position, often at the expense of other forces or constraints. A value outside the range [0,1] is not recommended.If strength is not specified, returns the current strength accessor, which defaults to:jsfunction strength() {
  return 0.1;
}The strength accessor is invoked for each node in the simulation, being passed the node and its zero-based index. The resulting number is then stored internally, such that the strength of each node is only recomputed when the force is initialized or when this method is called with a new strength, and not on every application of the force.radial.radius(radius) ​Source · If radius is specified, sets the circle radius to the specified number or function, re-evaluates the radius accessor for each node, and returns this force. If radius is not specified, returns the current radius accessor.The radius accessor is invoked for each node in the simulation, being passed the node and its zero-based index. The resulting number is then stored internally, such that the target radius of each node is only recomputed when the force is initialized or when this method is called with a new radius, and not on every application of the force.radial.x(x) ​Source · If x is specified, sets the x-coordinate of the circle center to the specified number and returns this force. If x is not specified, returns the current x-coordinate of the center, which defaults to zero.radial.y(y) ​Source · If y is specified, sets the y coordinate of the circle center to the specified number and returns this force. If y is not specified, returns the current y coordinate of the center, which defaults to zero.PagerPrevious pageMany-body forceNext paged3-geo\n\nPosition forces ​The x- and y-position forces push nodes towards a desired position along the given dimension with a configurable strength. The radial force is similar, except it pushes nodes towards the closest point on a given circle. The strength of the force is proportional to the one-dimensional distance between the node’s position and the target position. While these forces can be used to position individual nodes, they are intended primarily for global forces that apply to all (or most) nodes.forceX(x) ​Source · Creates a new position force along the x-axis towards the given position x. If x is not specified, it defaults to 0.jsconst x = d3.forceX(width / 2);x.strength(strength) ​Source · If strength is specified, sets the strength accessor to the specified number or function, re-evaluates the strength accessor for each node, and returns this force. The strength determines how much to increment the node’s x-velocity: (x - node.x) × strength. For example, a value of 0.1 indicates that the node should move a tenth of the way from its current x-position to the target x-position with each application. Higher values moves nodes more quickly to the target position, often at the expense of other forces or constraints. A value outside the range [0,1] is not recommended.If strength is not specified, returns the current strength accessor, which defaults to:jsfunction strength() {
  return 0.1;
}The strength accessor is invoked for each node in the simulation, being passed the node and its zero-based index. The resulting number is then stored internally, such that the strength of each node is only recomputed when the force is initialized or when this method is called with a new strength, and not on every application of the force.x.x(x) ​Source · If x is specified, sets the x-coordinate accessor to the specified number or function, re-evaluates the x-accessor for each node, and returns this force. If x is not specified, returns the current x-accessor, which defaults to:jsfunction x() {
  return 0;
}The x-accessor is invoked for each node in the simulation, being passed the node and its zero-based index. The resulting number is then stored internally, such that the target x-coordinate of each node is only recomputed when the force is initialized or when this method is called with a new x, and not on every application of the force.forceY(y) ​Source · Creates a new position force along the y-axis towards the given position y. If y is not specified, it defaults to 0.jsconst y = d3.forceY(height / 2);y.strength(strength) ​Source · If strength is specified, sets the strength accessor to the specified number or function, re-evaluates the strength accessor for each node, and returns this force. The strength determines how much to increment the node’s y-velocity: (y - node.y) × strength. For example, a value of 0.1 indicates that the node should move a tenth of the way from its current y-position to the target y-position with each application. Higher values moves nodes more quickly to the target position, often at the expense of other forces or constraints. A value outside the range [0,1] is not recommended.If strength is not specified, returns the current strength accessor, which defaults to:jsfunction strength() {
  return 0.1;
}The strength accessor is invoked for each node in the simulation, being passed the node and its zero-based index. The resulting number is then stored internally, such that the strength of each node is only recomputed when the force is initialized or when this method is called with a new strength, and not on every application of the force.y.y(y) ​Source · If y is specified, sets the y-coordinate accessor to the specified number or function, re-evaluates the y-accessor for each node, and returns this force. If y is not specified, returns the current y-accessor, which defaults to:jsfunction y() {
  return 0;
}The y-accessor is invoked for each node in the simulation, being passed the node and its zero-based index. The resulting number is then stored internally, such that the target y coordinate of each node is only recomputed when the force is initialized or when this method is called with a new y, and not on every application of the force.forceRadial(radius, x, y) ​Source · Creates a new position force towards a circle of the specified radius centered at ⟨x,y⟩. If x and y are not specified, they default to ⟨0,0⟩.jsconst radial = d3.forceRadial(r, width / 2, height / 2);radial.strength(strength) ​Source · If strength is specified, sets the strength accessor to the specified number or function, re-evaluates the strength accessor for each node, and returns this force. The strength determines how much to increment the node’s x- and y-velocity. For example, a value of 0.1 indicates that the node should move a tenth of the way from its current position to the closest point on the circle with each application. Higher values moves nodes more quickly to the target position, often at the expense of other forces or constraints. A value outside the range [0,1] is not recommended.If strength is not specified, returns the current strength accessor, which defaults to:jsfunction strength() {
  return 0.1;
}The strength accessor is invoked for each node in the simulation, being passed the node and its zero-based index. The resulting number is then stored internally, such that the strength of each node is only recomputed when the force is initialized or when this method is called with a new strength, and not on every application of the force.radial.radius(radius) ​Source · If radius is specified, sets the circle radius to the specified number or function, re-evaluates the radius accessor for each node, and returns this force. If radius is not specified, returns the current radius accessor.The radius accessor is invoked for each node in the simulation, being passed the node and its zero-based index. The resulting number is then stored internally, such that the target radius of each node is only recomputed when the force is initialized or when this method is called with a new radius, and not on every application of the force.radial.x(x) ​Source · If x is specified, sets the x-coordinate of the circle center to the specified number and returns this force. If x is not specified, returns the current x-coordinate of the center, which defaults to zero.radial.y(y) ​Source · If y is specified, sets the y coordinate of the circle center to the specified number and returns this force. If y is not specified, returns the current y coordinate of the center, which defaults to zero.\n\n\n\nPaths ​The geographic path generator, geoPath, takes a given GeoJSON geometry or feature object and generates SVG path data string or renders to a Canvas. Paths can be used with projections or transforms, or they can be used to render planar geometry directly to Canvas or SVG.geoPath(projection, context) ​Source · Creates a new geographic path generator with the default settings. If projection is specified, sets the current projection. If context is specified, sets the current context.jsconst path = d3.geoPath(projection); // for SVGjsconst path = d3.geoPath(projection, context); // for canvaspath(object, ...arguments) ​Source · Renders the given object, which may be any GeoJSON feature or geometry object:Point - a single positionMultiPoint - an array of positionsLineString - an array of positions forming a continuous lineMultiLineString - an array of arrays of positions forming several linesPolygon - an array of arrays of positions forming a polygon (possibly with holes)MultiPolygon - a multidimensional array of positions forming multiple polygonsGeometryCollection - an array of geometry objectsFeature - a feature containing one of the above geometry objectsFeatureCollection - an array of feature objectsThe type Sphere is also supported, which is useful for rendering the outline of the globe; a sphere has no coordinates. Any additional arguments are passed along to the pointRadius accessor.To display multiple features, combine them into a feature collection:jssvg.append("path")
    .datum({type: "FeatureCollection", features: features})
    .attr("d", d3.geoPath());Or use multiple path elements:jssvg.selectAll()
  .data(features)
  .join("path")
    .attr("d", d3.geoPath());Separate path elements are typically slower than a single path element. However, distinct path elements are useful for styling and interaction (e.g., click or mouseover). Canvas rendering (see path.context) is typically faster than SVG, but requires more effort to implement styling and interaction.path.area(object) ​Source · Returns the projected planar area (typically in square pixels) for the specified GeoJSON object.jspath.area(california) // 17063.1671837991 px²Point, MultiPoint, LineString and MultiLineString geometries have zero area. For Polygon and MultiPolygon geometries, this method first computes the area of the exterior ring, and then subtracts the area of any interior holes. This method observes any clipping performed by the projection; see projection.clipAngle and projection.clipExtent. This is the planar equivalent of geoArea.path.bounds(object) ​Source · Returns the projected planar bounding box (typically in pixels) for the specified GeoJSON object.jspath.bounds(california) // [[18.48513821663947, 159.95146883594333], [162.7651668852596, 407.09641570706725]]The bounding box is represented by a two-dimensional array: [[x₀, y₀], [x₁, y₁]], where x₀ is the minimum x-coordinate, y₀ is the minimum y coordinate, x₁ is maximum x-coordinate, and y₁ is the maximum y coordinate. This is handy for, say, zooming in to a particular feature. (Note that in projected planar coordinates, the minimum latitude is typically the maximum y-value, and the maximum latitude is typically the minimum y-value.) This method observes any clipping performed by the projection; see projection.clipAngle and projection.clipExtent. This is the planar equivalent of geoBounds.path.centroid(object) ​Source · Returns the projected planar centroid (typically in pixels) for the specified GeoJSON object.jspath.centroid(california) // [82.08679434495191, 288.14204870673404]This is handy for, say, labeling state or county boundaries, or displaying a symbol map. For example, a noncontiguous cartogram might scale each state around its centroid. This method observes any clipping performed by the projection; see projection.clipAngle and projection.clipExtent. This is the planar equivalent of geoCentroid.path.digits(digits) ​Source · If digits is specified (as a non-negative number), sets the number of fractional digits for coordinates generated in SVG path strings.jsconst path = d3.geoPath().digits(3);If projection is not specified, returns the current number of digits, which defaults to 3.jspath.digits() // 3This option only applies when the associated context is null, as when this arc generator is used to produce path data.path.measure(object) ​Source · Returns the projected planar length (typically in pixels) for the specified GeoJSON object.jspath.measure(california) // 825.7124297512761Point and MultiPoint geometries have zero length. For Polygon and MultiPolygon geometries, this method computes the summed length of all rings. This method observes any clipping performed by the projection; see projection.clipAngle and projection.clipExtent. This is the planar equivalent of geoLength.path.projection(projection) ​Source · If a projection is specified, sets the current projection to the specified projection.jsconst path = d3.geoPath().projection(d3.geoAlbers());If projection is not specified, returns the current projection.jspath.projection() // a d3.geoAlbers instanceThe projection defaults to null, which represents the identity transformation: the input geometry is not projected and is instead rendered directly in raw coordinates. This can be useful for fast rendering of pre-projected geometry, or for fast rendering of the equirectangular projection.The given projection is typically one of D3’s built-in geographic projections; however, any object that exposes a projection.stream function can be used, enabling the use of custom projections. See D3’s transforms for more examples of arbitrary geometric transformations.path.context(context) ​Source · If context is specified, sets the current render context and returns the path generator.jsconst context = canvas.getContext("2d");
const path = d3.geoPath().context(context);If the context is null, then the path generator will return an SVG path string; if the context is non-null, the path generator will instead call methods on the specified context to render geometry. The context must implement the following subset of the CanvasRenderingContext2D API:context.beginPath()context.moveTo(x, y)context.lineTo(x, y)context.arc(x, y, radius, startAngle, endAngle)context.closePath()If a context is not specified, returns the current render context which defaults to null. See also d3-path.path.pointRadius(radius) ​Source · If radius is specified, sets the radius used to display Point and MultiPoint geometries to the specified number.jsconst path = d3.geoPath().pointRadius(10);If radius is not specified, returns the current radius accessor.jspath.pointRadius() // 10The radius accessor defaults to 4.5. While the radius is commonly specified as a number constant, it may also be specified as a function which is computed per feature, being passed the any arguments passed to the path generator. For example, if your GeoJSON data has additional properties, you might access those properties inside the radius function to vary the point size; alternatively, you could symbol and a projection for greater flexibility.\n\nSearchK7.9.0GitHub️ 110.0kOn this pagePaths ​The geographic path generator, geoPath, takes a given GeoJSON geometry or feature object and generates SVG path data string or renders to a Canvas. Paths can be used with projections or transforms, or they can be used to render planar geometry directly to Canvas or SVG.geoPath(projection, context) ​Source · Creates a new geographic path generator with the default settings. If projection is specified, sets the current projection. If context is specified, sets the current context.jsconst path = d3.geoPath(projection); // for SVGjsconst path = d3.geoPath(projection, context); // for canvaspath(object, ...arguments) ​Source · Renders the given object, which may be any GeoJSON feature or geometry object:Point - a single positionMultiPoint - an array of positionsLineString - an array of positions forming a continuous lineMultiLineString - an array of arrays of positions forming several linesPolygon - an array of arrays of positions forming a polygon (possibly with holes)MultiPolygon - a multidimensional array of positions forming multiple polygonsGeometryCollection - an array of geometry objectsFeature - a feature containing one of the above geometry objectsFeatureCollection - an array of feature objectsThe type Sphere is also supported, which is useful for rendering the outline of the globe; a sphere has no coordinates. Any additional arguments are passed along to the pointRadius accessor.To display multiple features, combine them into a feature collection:jssvg.append("path")
    .datum({type: "FeatureCollection", features: features})
    .attr("d", d3.geoPath());Or use multiple path elements:jssvg.selectAll()
  .data(features)
  .join("path")
    .attr("d", d3.geoPath());Separate path elements are typically slower than a single path element. However, distinct path elements are useful for styling and interaction (e.g., click or mouseover). Canvas rendering (see path.context) is typically faster than SVG, but requires more effort to implement styling and interaction.path.area(object) ​Source · Returns the projected planar area (typically in square pixels) for the specified GeoJSON object.jspath.area(california) // 17063.1671837991 px²Point, MultiPoint, LineString and MultiLineString geometries have zero area. For Polygon and MultiPolygon geometries, this method first computes the area of the exterior ring, and then subtracts the area of any interior holes. This method observes any clipping performed by the projection; see projection.clipAngle and projection.clipExtent. This is the planar equivalent of geoArea.path.bounds(object) ​Source · Returns the projected planar bounding box (typically in pixels) for the specified GeoJSON object.jspath.bounds(california) // [[18.48513821663947, 159.95146883594333], [162.7651668852596, 407.09641570706725]]The bounding box is represented by a two-dimensional array: [[x₀, y₀], [x₁, y₁]], where x₀ is the minimum x-coordinate, y₀ is the minimum y coordinate, x₁ is maximum x-coordinate, and y₁ is the maximum y coordinate. This is handy for, say, zooming in to a particular feature. (Note that in projected planar coordinates, the minimum latitude is typically the maximum y-value, and the maximum latitude is typically the minimum y-value.) This method observes any clipping performed by the projection; see projection.clipAngle and projection.clipExtent. This is the planar equivalent of geoBounds.path.centroid(object) ​Source · Returns the projected planar centroid (typically in pixels) for the specified GeoJSON object.jspath.centroid(california) // [82.08679434495191, 288.14204870673404]This is handy for, say, labeling state or county boundaries, or displaying a symbol map. For example, a noncontiguous cartogram might scale each state around its centroid. This method observes any clipping performed by the projection; see projection.clipAngle and projection.clipExtent. This is the planar equivalent of geoCentroid.path.digits(digits) ​Source · If digits is specified (as a non-negative number), sets the number of fractional digits for coordinates generated in SVG path strings.jsconst path = d3.geoPath().digits(3);If projection is not specified, returns the current number of digits, which defaults to 3.jspath.digits() // 3This option only applies when the associated context is null, as when this arc generator is used to produce path data.path.measure(object) ​Source · Returns the projected planar length (typically in pixels) for the specified GeoJSON object.jspath.measure(california) // 825.7124297512761Point and MultiPoint geometries have zero length. For Polygon and MultiPolygon geometries, this method computes the summed length of all rings. This method observes any clipping performed by the projection; see projection.clipAngle and projection.clipExtent. This is the planar equivalent of geoLength.path.projection(projection) ​Source · If a projection is specified, sets the current projection to the specified projection.jsconst path = d3.geoPath().projection(d3.geoAlbers());If projection is not specified, returns the current projection.jspath.projection() // a d3.geoAlbers instanceThe projection defaults to null, which represents the identity transformation: the input geometry is not projected and is instead rendered directly in raw coordinates. This can be useful for fast rendering of pre-projected geometry, or for fast rendering of the equirectangular projection.The given projection is typically one of D3’s built-in geographic projections; however, any object that exposes a projection.stream function can be used, enabling the use of custom projections. See D3’s transforms for more examples of arbitrary geometric transformations.path.context(context) ​Source · If context is specified, sets the current render context and returns the path generator.jsconst context = canvas.getContext("2d");
const path = d3.geoPath().context(context);If the context is null, then the path generator will return an SVG path string; if the context is non-null, the path generator will instead call methods on the specified context to render geometry. The context must implement the following subset of the CanvasRenderingContext2D API:context.beginPath()context.moveTo(x, y)context.lineTo(x, y)context.arc(x, y, radius, startAngle, endAngle)context.closePath()If a context is not specified, returns the current render context which defaults to null. See also d3-path.path.pointRadius(radius) ​Source · If radius is specified, sets the radius used to display Point and MultiPoint geometries to the specified number.jsconst path = d3.geoPath().pointRadius(10);If radius is not specified, returns the current radius accessor.jspath.pointRadius() // 10The radius accessor defaults to 4.5. While the radius is commonly specified as a number constant, it may also be specified as a function which is computed per feature, being passed the any arguments passed to the path generator. For example, if your GeoJSON data has additional properties, you might access those properties inside the radius function to vary the point size; alternatively, you could symbol and a projection for greater flexibility.PagerPrevious paged3-geoNext pageProjections\n\nPaths ​The geographic path generator, geoPath, takes a given GeoJSON geometry or feature object and generates SVG path data string or renders to a Canvas. Paths can be used with projections or transforms, or they can be used to render planar geometry directly to Canvas or SVG.geoPath(projection, context) ​Source · Creates a new geographic path generator with the default settings. If projection is specified, sets the current projection. If context is specified, sets the current context.jsconst path = d3.geoPath(projection); // for SVGjsconst path = d3.geoPath(projection, context); // for canvaspath(object, ...arguments) ​Source · Renders the given object, which may be any GeoJSON feature or geometry object:Point - a single positionMultiPoint - an array of positionsLineString - an array of positions forming a continuous lineMultiLineString - an array of arrays of positions forming several linesPolygon - an array of arrays of positions forming a polygon (possibly with holes)MultiPolygon - a multidimensional array of positions forming multiple polygonsGeometryCollection - an array of geometry objectsFeature - a feature containing one of the above geometry objectsFeatureCollection - an array of feature objectsThe type Sphere is also supported, which is useful for rendering the outline of the globe; a sphere has no coordinates. Any additional arguments are passed along to the pointRadius accessor.To display multiple features, combine them into a feature collection:jssvg.append("path")
    .datum({type: "FeatureCollection", features: features})
    .attr("d", d3.geoPath());Or use multiple path elements:jssvg.selectAll()
  .data(features)
  .join("path")
    .attr("d", d3.geoPath());Separate path elements are typically slower than a single path element. However, distinct path elements are useful for styling and interaction (e.g., click or mouseover). Canvas rendering (see path.context) is typically faster than SVG, but requires more effort to implement styling and interaction.path.area(object) ​Source · Returns the projected planar area (typically in square pixels) for the specified GeoJSON object.jspath.area(california) // 17063.1671837991 px²Point, MultiPoint, LineString and MultiLineString geometries have zero area. For Polygon and MultiPolygon geometries, this method first computes the area of the exterior ring, and then subtracts the area of any interior holes. This method observes any clipping performed by the projection; see projection.clipAngle and projection.clipExtent. This is the planar equivalent of geoArea.path.bounds(object) ​Source · Returns the projected planar bounding box (typically in pixels) for the specified GeoJSON object.jspath.bounds(california) // [[18.48513821663947, 159.95146883594333], [162.7651668852596, 407.09641570706725]]The bounding box is represented by a two-dimensional array: [[x₀, y₀], [x₁, y₁]], where x₀ is the minimum x-coordinate, y₀ is the minimum y coordinate, x₁ is maximum x-coordinate, and y₁ is the maximum y coordinate. This is handy for, say, zooming in to a particular feature. (Note that in projected planar coordinates, the minimum latitude is typically the maximum y-value, and the maximum latitude is typically the minimum y-value.) This method observes any clipping performed by the projection; see projection.clipAngle and projection.clipExtent. This is the planar equivalent of geoBounds.path.centroid(object) ​Source · Returns the projected planar centroid (typically in pixels) for the specified GeoJSON object.jspath.centroid(california) // [82.08679434495191, 288.14204870673404]This is handy for, say, labeling state or county boundaries, or displaying a symbol map. For example, a noncontiguous cartogram might scale each state around its centroid. This method observes any clipping performed by the projection; see projection.clipAngle and projection.clipExtent. This is the planar equivalent of geoCentroid.path.digits(digits) ​Source · If digits is specified (as a non-negative number), sets the number of fractional digits for coordinates generated in SVG path strings.jsconst path = d3.geoPath().digits(3);If projection is not specified, returns the current number of digits, which defaults to 3.jspath.digits() // 3This option only applies when the associated context is null, as when this arc generator is used to produce path data.path.measure(object) ​Source · Returns the projected planar length (typically in pixels) for the specified GeoJSON object.jspath.measure(california) // 825.7124297512761Point and MultiPoint geometries have zero length. For Polygon and MultiPolygon geometries, this method computes the summed length of all rings. This method observes any clipping performed by the projection; see projection.clipAngle and projection.clipExtent. This is the planar equivalent of geoLength.path.projection(projection) ​Source · If a projection is specified, sets the current projection to the specified projection.jsconst path = d3.geoPath().projection(d3.geoAlbers());If projection is not specified, returns the current projection.jspath.projection() // a d3.geoAlbers instanceThe projection defaults to null, which represents the identity transformation: the input geometry is not projected and is instead rendered directly in raw coordinates. This can be useful for fast rendering of pre-projected geometry, or for fast rendering of the equirectangular projection.The given projection is typically one of D3’s built-in geographic projections; however, any object that exposes a projection.stream function can be used, enabling the use of custom projections. See D3’s transforms for more examples of arbitrary geometric transformations.path.context(context) ​Source · If context is specified, sets the current render context and returns the path generator.jsconst context = canvas.getContext("2d");
const path = d3.geoPath().context(context);If the context is null, then the path generator will return an SVG path string; if the context is non-null, the path generator will instead call methods on the specified context to render geometry. The context must implement the following subset of the CanvasRenderingContext2D API:context.beginPath()context.moveTo(x, y)context.lineTo(x, y)context.arc(x, y, radius, startAngle, endAngle)context.closePath()If a context is not specified, returns the current render context which defaults to null. See also d3-path.path.pointRadius(radius) ​Source · If radius is specified, sets the radius used to display Point and MultiPoint geometries to the specified number.jsconst path = d3.geoPath().pointRadius(10);If radius is not specified, returns the current radius accessor.jspath.pointRadius() // 10The radius accessor defaults to 4.5. While the radius is commonly specified as a number constant, it may also be specified as a function which is computed per feature, being passed the any arguments passed to the path generator. For example, if your GeoJSON data has additional properties, you might access those properties inside the radius function to vary the point size; alternatively, you could symbol and a projection for greater flexibility.\n\n\n\nProjections ​Projections transform spherical polygonal geometry to planar polygonal geometry. D3 provides implementations of several classes of standard projections:Azimuthal projectionsConic projectionsCylindrical projectionsFor more projections, see d3-geo-projection and d3-geo-polygon. You can implement custom projections using geoProjection or geoProjectionMutator.projection(point) ​Source · Returns a new array [x, y] (typically in pixels) representing the projected point of the given point. The point must be specified as a two-element array [longitude, latitude] in degrees. May return null if the specified point has no defined projected position, such as when the point is outside the clipping bounds of the projection.projection.invert(point) ​Source · Returns a new array [longitude, latitude] in degrees representing the unprojected point of the given projected point. The point must be specified as a two-element array [x, y] (typically in pixels). May return null if the specified point has no defined projected position, such as when the point is outside the clipping bounds of the projection.This method is only defined on invertible projections.projection.stream(stream) ​Source · Returns a projection stream for the specified output stream. Any input geometry is projected before being streamed to the output stream. A typical projection involves several geometry transformations: the input geometry is first converted to radians, rotated on three axes, clipped to the small circle or cut along the antimeridian, and lastly projected to the plane with adaptive resampling, scale and translation.projection.preclip(preclip) ​If preclip is specified, sets the projection’s spherical clipping to the specified function and returns the projection; preclip is a function that takes a projection stream and returns a clipped stream. If preclip is not specified, returns the current spherical clipping function. Preclipping is commonly used to cut along the antimeridian line or along a small circle.projection.postclip(postclip) ​If postclip is specified, sets the projection’s Cartesian clipping to the specified function and returns the projection; postclip is a function that takes a projection stream and returns a clipped stream. If postclip is not specified, returns the current Cartesian clipping function. Post-clipping occurs on the plane, when a projection is bounded to a certain extent such as a rectangle.projection.clipAngle(angle) ​Source · If angle is specified, sets the projection’s clipping circle radius to the specified angle in degrees and returns the projection. If angle is null, switches to antimeridian cutting rather than small-circle clipping. If angle is not specified, returns the current clip angle which defaults to null. Small-circle clipping is independent of viewport clipping via projection.clipExtent. See also projection.preclip, geoClipAntimeridian, geoClipCircle.projection.clipExtent(extent) ​Source · If extent is specified, sets the projection’s viewport clip extent to the specified bounds in pixels and returns the projection. The extent bounds are specified as an array [[x₀, y₀], [x₁, y₁]], where x₀ is the left-side of the viewport, y₀ is the top, x₁ is the right and y₁ is the bottom. If extent is null, no viewport clipping is performed. If extent is not specified, returns the current viewport clip extent which defaults to null. Viewport clipping is independent of small-circle clipping via projection.clipAngle. See also projection.postclip, geoClipRectangle.projection.scale(scale) ​Source · If scale is specified, sets the projection’s scale factor to the specified value and returns the projection. If scale is not specified, returns the current scale factor; the default scale is projection-specific. The scale factor corresponds linearly to the distance between projected points; however, absolute scale factors are not equivalent across projections.projection.translate(translate) ​Source · If translate is specified, sets the projection’s translation offset to the specified two-element array [tx, ty] and returns the projection. If translate is not specified, returns the current translation offset which defaults to [480, 250]. The translation offset determines the pixel coordinates of the projection’s center. The default translation offset places ⟨0°,0°⟩ at the center of a 960×500 area.projection.center(center) ​Source · If center is specified, sets the projection’s center to the specified center, a two-element array of [longitude, latitude] in degrees and returns the projection. If center is not specified, returns the current center, which defaults to ⟨0°,0°⟩.projection.angle(angle) ​Source · If angle is specified, sets the projection’s post-projection planar rotation angle to the specified angle in degrees and returns the projection. If angle is not specified, returns the projection’s current angle, which defaults to 0°. Note that it may be faster to rotate during rendering (e.g., using context.rotate) rather than during projection.projection.reflectX(reflect) ​If reflect is specified, sets whether or not the x-dimension is reflected (negated) in the output. If reflect is not specified, returns true if x-reflection is enabled, which defaults to false. This can be useful to display sky and astronomical data with the orb seen from below: right ascension (eastern direction) will point to the left when North is pointing up.projection.reflectY(reflect) ​If reflect is specified, sets whether or not the y-dimension is reflected (negated) in the output. If reflect is not specified, returns true if y-reflection is enabled, which defaults to false. This is especially useful for transforming from standard spatial reference systems, which treat positive y as pointing up, to display coordinate systems such as Canvas and SVG, which treat positive y as pointing down.projection.rotate(angles) ​Source · If angles is specified, sets the projection’s three-axis spherical rotation to the specified value, which must be a two- or three-element array of numbers [lambda, phi, gamma] specifying the rotation angles in degrees about each spherical axis. (These correspond to yaw, pitch and roll.) If the rotation angle gamma is omitted, it defaults to 0. See also geoRotation. If angles is not specified, returns the current rotation which defaults to [0, 0, 0].projection.precision(precision) ​Source · If precision is specified, sets the threshold for the projection’s adaptive resampling to the specified value in pixels and returns the projection. This value corresponds to the Douglas–Peucker distance. If precision is not specified, returns the projection’s current resampling precision which defaults to √0.5 ≅ 0.70710…projection.fitExtent(extent, object) ​Source · Sets the projection’s scale and translate to fit the specified GeoJSON object in the center of the given extent. The extent is specified as an array [[x₀, y₀], [x₁, y₁]], where x₀ is the left side of the bounding box, y₀ is the top, x₁ is the right and y₁ is the bottom. Returns the projection.For example, to scale and translate the New Jersey State Plane projection to fit a GeoJSON object nj in the center of a 960×500 bounding box with 20 pixels of padding on each side:jsvar projection = d3.geoTransverseMercator()
    .rotate([74 + 30 / 60, -38 - 50 / 60])
    .fitExtent([[20, 20], [940, 480]], nj);Any clip extent is ignored when determining the new scale and translate. The precision used to compute the bounding box of the given object is computed at an effective scale of 150.projection.fitSize(size, object) ​Source · A convenience method for projection.fitExtent where the top-left corner of the extent is [0, 0]. The following two statements are equivalent:jsprojection.fitExtent([[0, 0], [width, height]], object);
projection.fitSize([width, height], object);projection.fitWidth(width, object) ​Source · A convenience method for projection.fitSize where the height is automatically chosen from the aspect ratio of object and the given constraint on width.projection.fitHeight(height, object) ​Source · A convenience method for projection.fitSize where the width is automatically chosen from the aspect ratio of object and the given constraint on height.Raw projections ​Raw projections are point transformation functions that are used to implement custom projections; they typically passed to geoProjection or geoProjectionMutator. They are exposed here to facilitate the derivation of related projections. Raw projections take spherical coordinates [lambda, phi] in radians (not degrees!) and return a point [x, y], typically in the unit square centered around the origin.project(lambda, phi) ​Projects the specified point [lambda, phi] in radians, returning a new point [x, y] in unitless coordinates.project.invert(x, y) ​The inverse of project.geoProjection(project) ​Source · Constructs a new projection from the specified raw projection, project. The project function takes the longitude and latitude of a given point in radians, often referred to as lambda (λ) and phi (φ), and returns a two-element array [x, y] representing its unit projection. The project function does not need to scale or translate the point, as these are applied automatically by projection.scale, projection.translate, and projection.center. Likewise, the project function does not need to perform any spherical rotation, as projection.rotate is applied prior to projection.For example, a spherical Mercator projection can be implemented as:jsvar mercator = d3.geoProjection(function(x, y) {
  return [x, Math.log(Math.tan(Math.PI / 4 + y / 2))];
});If the project function exposes an invert method, the returned projection will also expose projection.invert.geoProjectionMutator(factory) ​Source · Constructs a new projection from the specified raw projection factory and returns a mutate function to call whenever the raw projection changes. The factory must return a raw projection. The returned mutate function returns the wrapped projection. For example, a conic projection typically has two configurable parallels. A suitable factory function, such as geoConicEqualAreaRaw, would have the form:js// y0 and y1 represent two parallels
function conicFactory(phi0, phi1) {
  return function conicRaw(lambda, phi) {
    return […, …];
  };
}Using d3.geoProjectionMutator, you can implement a standard projection that allows the parallels to be changed, reassigning the raw projection used internally by geoProjection:jsfunction conicCustom() {
  var phi0 = 29.5,
      phi1 = 45.5,
      mutate = d3.geoProjectionMutator(conicFactory),
      projection = mutate(phi0, phi1);

  projection.parallels = function(_) {
    return arguments.length ? mutate(phi0 = +_[0], phi1 = +_[1]) : [phi0, phi1];
  };

  return projection;
}When creating a mutable projection, the mutate function is typically not exposed.geoTransform(methods) ​Source · Defines an arbitrary transform using the methods defined on the specified methods object. Any undefined methods will use pass-through methods that propagate inputs to the output stream.For example, to reflect the y-dimension (see also projection.reflectY):jsconst reflectY = d3.geoTransform({
  point(x, y) {
    this.stream.point(x, -y);
  }
});Or to define an affine matrix transformation:jsfunction matrix(a, b, c, d, tx, ty) {
  return d3.geoTransform({
    point(x, y) {
      this.stream.point(a * x + b * y + tx, c * x + d * y + ty);
    }
  });
}A transform is a generalized projection; it implements projection.stream and can be passed to path.projection. However, it implements only a subset of the other projection methods, and represent arbitrary geometric transformations rather than projections from spherical to planar coordinates.geoIdentity() ​Source · The identity transform can be used to scale, translate and clip planar geometry. It implements projection.scale, projection.translate, projection.fitExtent, projection.fitSize, projection.fitWidth, projection.fitHeight, projection.clipExtent, projection.angle, projection.reflectX and projection.reflectY.geoClipAntimeridian ​Source · A clipping function which transforms a stream such that geometries (lines or polygons) that cross the antimeridian line are cut in two, one on each side. Typically used for pre-clipping.geoClipCircle(angle) ​Source · Generates a clipping function which transforms a stream such that geometries are bounded by a small circle of radius angle around the projection’s center. Typically used for pre-clipping.geoClipRectangle(x0, y0, x1, y1) ​Source · Generates a clipping function which transforms a stream such that geometries are bounded by a rectangle of coordinates [[x0, y0], [x1, y1]]. Typically used for post-clipping.\n\nSearchK7.9.0GitHub️ 110.0kOn this pageProjections ​Projections transform spherical polygonal geometry to planar polygonal geometry. D3 provides implementations of several classes of standard projections:Azimuthal projectionsConic projectionsCylindrical projectionsFor more projections, see d3-geo-projection and d3-geo-polygon. You can implement custom projections using geoProjection or geoProjectionMutator.projection(point) ​Source · Returns a new array [x, y] (typically in pixels) representing the projected point of the given point. The point must be specified as a two-element array [longitude, latitude] in degrees. May return null if the specified point has no defined projected position, such as when the point is outside the clipping bounds of the projection.projection.invert(point) ​Source · Returns a new array [longitude, latitude] in degrees representing the unprojected point of the given projected point. The point must be specified as a two-element array [x, y] (typically in pixels). May return null if the specified point has no defined projected position, such as when the point is outside the clipping bounds of the projection.This method is only defined on invertible projections.projection.stream(stream) ​Source · Returns a projection stream for the specified output stream. Any input geometry is projected before being streamed to the output stream. A typical projection involves several geometry transformations: the input geometry is first converted to radians, rotated on three axes, clipped to the small circle or cut along the antimeridian, and lastly projected to the plane with adaptive resampling, scale and translation.projection.preclip(preclip) ​If preclip is specified, sets the projection’s spherical clipping to the specified function and returns the projection; preclip is a function that takes a projection stream and returns a clipped stream. If preclip is not specified, returns the current spherical clipping function. Preclipping is commonly used to cut along the antimeridian line or along a small circle.projection.postclip(postclip) ​If postclip is specified, sets the projection’s Cartesian clipping to the specified function and returns the projection; postclip is a function that takes a projection stream and returns a clipped stream. If postclip is not specified, returns the current Cartesian clipping function. Post-clipping occurs on the plane, when a projection is bounded to a certain extent such as a rectangle.projection.clipAngle(angle) ​Source · If angle is specified, sets the projection’s clipping circle radius to the specified angle in degrees and returns the projection. If angle is null, switches to antimeridian cutting rather than small-circle clipping. If angle is not specified, returns the current clip angle which defaults to null. Small-circle clipping is independent of viewport clipping via projection.clipExtent. See also projection.preclip, geoClipAntimeridian, geoClipCircle.projection.clipExtent(extent) ​Source · If extent is specified, sets the projection’s viewport clip extent to the specified bounds in pixels and returns the projection. The extent bounds are specified as an array [[x₀, y₀], [x₁, y₁]], where x₀ is the left-side of the viewport, y₀ is the top, x₁ is the right and y₁ is the bottom. If extent is null, no viewport clipping is performed. If extent is not specified, returns the current viewport clip extent which defaults to null. Viewport clipping is independent of small-circle clipping via projection.clipAngle. See also projection.postclip, geoClipRectangle.projection.scale(scale) ​Source · If scale is specified, sets the projection’s scale factor to the specified value and returns the projection. If scale is not specified, returns the current scale factor; the default scale is projection-specific. The scale factor corresponds linearly to the distance between projected points; however, absolute scale factors are not equivalent across projections.projection.translate(translate) ​Source · If translate is specified, sets the projection’s translation offset to the specified two-element array [tx, ty] and returns the projection. If translate is not specified, returns the current translation offset which defaults to [480, 250]. The translation offset determines the pixel coordinates of the projection’s center. The default translation offset places ⟨0°,0°⟩ at the center of a 960×500 area.projection.center(center) ​Source · If center is specified, sets the projection’s center to the specified center, a two-element array of [longitude, latitude] in degrees and returns the projection. If center is not specified, returns the current center, which defaults to ⟨0°,0°⟩.projection.angle(angle) ​Source · If angle is specified, sets the projection’s post-projection planar rotation angle to the specified angle in degrees and returns the projection. If angle is not specified, returns the projection’s current angle, which defaults to 0°. Note that it may be faster to rotate during rendering (e.g., using context.rotate) rather than during projection.projection.reflectX(reflect) ​If reflect is specified, sets whether or not the x-dimension is reflected (negated) in the output. If reflect is not specified, returns true if x-reflection is enabled, which defaults to false. This can be useful to display sky and astronomical data with the orb seen from below: right ascension (eastern direction) will point to the left when North is pointing up.projection.reflectY(reflect) ​If reflect is specified, sets whether or not the y-dimension is reflected (negated) in the output. If reflect is not specified, returns true if y-reflection is enabled, which defaults to false. This is especially useful for transforming from standard spatial reference systems, which treat positive y as pointing up, to display coordinate systems such as Canvas and SVG, which treat positive y as pointing down.projection.rotate(angles) ​Source · If angles is specified, sets the projection’s three-axis spherical rotation to the specified value, which must be a two- or three-element array of numbers [lambda, phi, gamma] specifying the rotation angles in degrees about each spherical axis. (These correspond to yaw, pitch and roll.) If the rotation angle gamma is omitted, it defaults to 0. See also geoRotation. If angles is not specified, returns the current rotation which defaults to [0, 0, 0].projection.precision(precision) ​Source · If precision is specified, sets the threshold for the projection’s adaptive resampling to the specified value in pixels and returns the projection. This value corresponds to the Douglas–Peucker distance. If precision is not specified, returns the projection’s current resampling precision which defaults to √0.5 ≅ 0.70710…projection.fitExtent(extent, object) ​Source · Sets the projection’s scale and translate to fit the specified GeoJSON object in the center of the given extent. The extent is specified as an array [[x₀, y₀], [x₁, y₁]], where x₀ is the left side of the bounding box, y₀ is the top, x₁ is the right and y₁ is the bottom. Returns the projection.For example, to scale and translate the New Jersey State Plane projection to fit a GeoJSON object nj in the center of a 960×500 bounding box with 20 pixels of padding on each side:jsvar projection = d3.geoTransverseMercator()
    .rotate([74 + 30 / 60, -38 - 50 / 60])
    .fitExtent([[20, 20], [940, 480]], nj);Any clip extent is ignored when determining the new scale and translate. The precision used to compute the bounding box of the given object is computed at an effective scale of 150.projection.fitSize(size, object) ​Source · A convenience method for projection.fitExtent where the top-left corner of the extent is [0, 0]. The following two statements are equivalent:jsprojection.fitExtent([[0, 0], [width, height]], object);
projection.fitSize([width, height], object);projection.fitWidth(width, object) ​Source · A convenience method for projection.fitSize where the height is automatically chosen from the aspect ratio of object and the given constraint on width.projection.fitHeight(height, object) ​Source · A convenience method for projection.fitSize where the width is automatically chosen from the aspect ratio of object and the given constraint on height.Raw projections ​Raw projections are point transformation functions that are used to implement custom projections; they typically passed to geoProjection or geoProjectionMutator. They are exposed here to facilitate the derivation of related projections. Raw projections take spherical coordinates [lambda, phi] in radians (not degrees!) and return a point [x, y], typically in the unit square centered around the origin.project(lambda, phi) ​Projects the specified point [lambda, phi] in radians, returning a new point [x, y] in unitless coordinates.project.invert(x, y) ​The inverse of project.geoProjection(project) ​Source · Constructs a new projection from the specified raw projection, project. The project function takes the longitude and latitude of a given point in radians, often referred to as lambda (λ) and phi (φ), and returns a two-element array [x, y] representing its unit projection. The project function does not need to scale or translate the point, as these are applied automatically by projection.scale, projection.translate, and projection.center. Likewise, the project function does not need to perform any spherical rotation, as projection.rotate is applied prior to projection.For example, a spherical Mercator projection can be implemented as:jsvar mercator = d3.geoProjection(function(x, y) {
  return [x, Math.log(Math.tan(Math.PI / 4 + y / 2))];
});If the project function exposes an invert method, the returned projection will also expose projection.invert.geoProjectionMutator(factory) ​Source · Constructs a new projection from the specified raw projection factory and returns a mutate function to call whenever the raw projection changes. The factory must return a raw projection. The returned mutate function returns the wrapped projection. For example, a conic projection typically has two configurable parallels. A suitable factory function, such as geoConicEqualAreaRaw, would have the form:js// y0 and y1 represent two parallels
function conicFactory(phi0, phi1) {
  return function conicRaw(lambda, phi) {
    return […, …];
  };
}Using d3.geoProjectionMutator, you can implement a standard projection that allows the parallels to be changed, reassigning the raw projection used internally by geoProjection:jsfunction conicCustom() {
  var phi0 = 29.5,
      phi1 = 45.5,
      mutate = d3.geoProjectionMutator(conicFactory),
      projection = mutate(phi0, phi1);

  projection.parallels = function(_) {
    return arguments.length ? mutate(phi0 = +_[0], phi1 = +_[1]) : [phi0, phi1];
  };

  return projection;
}When creating a mutable projection, the mutate function is typically not exposed.geoTransform(methods) ​Source · Defines an arbitrary transform using the methods defined on the specified methods object. Any undefined methods will use pass-through methods that propagate inputs to the output stream.For example, to reflect the y-dimension (see also projection.reflectY):jsconst reflectY = d3.geoTransform({
  point(x, y) {
    this.stream.point(x, -y);
  }
});Or to define an affine matrix transformation:jsfunction matrix(a, b, c, d, tx, ty) {
  return d3.geoTransform({
    point(x, y) {
      this.stream.point(a * x + b * y + tx, c * x + d * y + ty);
    }
  });
}A transform is a generalized projection; it implements projection.stream and can be passed to path.projection. However, it implements only a subset of the other projection methods, and represent arbitrary geometric transformations rather than projections from spherical to planar coordinates.geoIdentity() ​Source · The identity transform can be used to scale, translate and clip planar geometry. It implements projection.scale, projection.translate, projection.fitExtent, projection.fitSize, projection.fitWidth, projection.fitHeight, projection.clipExtent, projection.angle, projection.reflectX and projection.reflectY.geoClipAntimeridian ​Source · A clipping function which transforms a stream such that geometries (lines or polygons) that cross the antimeridian line are cut in two, one on each side. Typically used for pre-clipping.geoClipCircle(angle) ​Source · Generates a clipping function which transforms a stream such that geometries are bounded by a small circle of radius angle around the projection’s center. Typically used for pre-clipping.geoClipRectangle(x0, y0, x1, y1) ​Source · Generates a clipping function which transforms a stream such that geometries are bounded by a rectangle of coordinates [[x0, y0], [x1, y1]]. Typically used for post-clipping.PagerPrevious pagePathsNext pageAzimuthal projections\n\nProjections ​Projections transform spherical polygonal geometry to planar polygonal geometry. D3 provides implementations of several classes of standard projections:Azimuthal projectionsConic projectionsCylindrical projectionsFor more projections, see d3-geo-projection and d3-geo-polygon. You can implement custom projections using geoProjection or geoProjectionMutator.projection(point) ​Source · Returns a new array [x, y] (typically in pixels) representing the projected point of the given point. The point must be specified as a two-element array [longitude, latitude] in degrees. May return null if the specified point has no defined projected position, such as when the point is outside the clipping bounds of the projection.projection.invert(point) ​Source · Returns a new array [longitude, latitude] in degrees representing the unprojected point of the given projected point. The point must be specified as a two-element array [x, y] (typically in pixels). May return null if the specified point has no defined projected position, such as when the point is outside the clipping bounds of the projection.This method is only defined on invertible projections.projection.stream(stream) ​Source · Returns a projection stream for the specified output stream. Any input geometry is projected before being streamed to the output stream. A typical projection involves several geometry transformations: the input geometry is first converted to radians, rotated on three axes, clipped to the small circle or cut along the antimeridian, and lastly projected to the plane with adaptive resampling, scale and translation.projection.preclip(preclip) ​If preclip is specified, sets the projection’s spherical clipping to the specified function and returns the projection; preclip is a function that takes a projection stream and returns a clipped stream. If preclip is not specified, returns the current spherical clipping function. Preclipping is commonly used to cut along the antimeridian line or along a small circle.projection.postclip(postclip) ​If postclip is specified, sets the projection’s Cartesian clipping to the specified function and returns the projection; postclip is a function that takes a projection stream and returns a clipped stream. If postclip is not specified, returns the current Cartesian clipping function. Post-clipping occurs on the plane, when a projection is bounded to a certain extent such as a rectangle.projection.clipAngle(angle) ​Source · If angle is specified, sets the projection’s clipping circle radius to the specified angle in degrees and returns the projection. If angle is null, switches to antimeridian cutting rather than small-circle clipping. If angle is not specified, returns the current clip angle which defaults to null. Small-circle clipping is independent of viewport clipping via projection.clipExtent. See also projection.preclip, geoClipAntimeridian, geoClipCircle.projection.clipExtent(extent) ​Source · If extent is specified, sets the projection’s viewport clip extent to the specified bounds in pixels and returns the projection. The extent bounds are specified as an array [[x₀, y₀], [x₁, y₁]], where x₀ is the left-side of the viewport, y₀ is the top, x₁ is the right and y₁ is the bottom. If extent is null, no viewport clipping is performed. If extent is not specified, returns the current viewport clip extent which defaults to null. Viewport clipping is independent of small-circle clipping via projection.clipAngle. See also projection.postclip, geoClipRectangle.projection.scale(scale) ​Source · If scale is specified, sets the projection’s scale factor to the specified value and returns the projection. If scale is not specified, returns the current scale factor; the default scale is projection-specific. The scale factor corresponds linearly to the distance between projected points; however, absolute scale factors are not equivalent across projections.projection.translate(translate) ​Source · If translate is specified, sets the projection’s translation offset to the specified two-element array [tx, ty] and returns the projection. If translate is not specified, returns the current translation offset which defaults to [480, 250]. The translation offset determines the pixel coordinates of the projection’s center. The default translation offset places ⟨0°,0°⟩ at the center of a 960×500 area.projection.center(center) ​Source · If center is specified, sets the projection’s center to the specified center, a two-element array of [longitude, latitude] in degrees and returns the projection. If center is not specified, returns the current center, which defaults to ⟨0°,0°⟩.projection.angle(angle) ​Source · If angle is specified, sets the projection’s post-projection planar rotation angle to the specified angle in degrees and returns the projection. If angle is not specified, returns the projection’s current angle, which defaults to 0°. Note that it may be faster to rotate during rendering (e.g., using context.rotate) rather than during projection.projection.reflectX(reflect) ​If reflect is specified, sets whether or not the x-dimension is reflected (negated) in the output. If reflect is not specified, returns true if x-reflection is enabled, which defaults to false. This can be useful to display sky and astronomical data with the orb seen from below: right ascension (eastern direction) will point to the left when North is pointing up.projection.reflectY(reflect) ​If reflect is specified, sets whether or not the y-dimension is reflected (negated) in the output. If reflect is not specified, returns true if y-reflection is enabled, which defaults to false. This is especially useful for transforming from standard spatial reference systems, which treat positive y as pointing up, to display coordinate systems such as Canvas and SVG, which treat positive y as pointing down.projection.rotate(angles) ​Source · If angles is specified, sets the projection’s three-axis spherical rotation to the specified value, which must be a two- or three-element array of numbers [lambda, phi, gamma] specifying the rotation angles in degrees about each spherical axis. (These correspond to yaw, pitch and roll.) If the rotation angle gamma is omitted, it defaults to 0. See also geoRotation. If angles is not specified, returns the current rotation which defaults to [0, 0, 0].projection.precision(precision) ​Source · If precision is specified, sets the threshold for the projection’s adaptive resampling to the specified value in pixels and returns the projection. This value corresponds to the Douglas–Peucker distance. If precision is not specified, returns the projection’s current resampling precision which defaults to √0.5 ≅ 0.70710…projection.fitExtent(extent, object) ​Source · Sets the projection’s scale and translate to fit the specified GeoJSON object in the center of the given extent. The extent is specified as an array [[x₀, y₀], [x₁, y₁]], where x₀ is the left side of the bounding box, y₀ is the top, x₁ is the right and y₁ is the bottom. Returns the projection.For example, to scale and translate the New Jersey State Plane projection to fit a GeoJSON object nj in the center of a 960×500 bounding box with 20 pixels of padding on each side:jsvar projection = d3.geoTransverseMercator()
    .rotate([74 + 30 / 60, -38 - 50 / 60])
    .fitExtent([[20, 20], [940, 480]], nj);Any clip extent is ignored when determining the new scale and translate. The precision used to compute the bounding box of the given object is computed at an effective scale of 150.projection.fitSize(size, object) ​Source · A convenience method for projection.fitExtent where the top-left corner of the extent is [0, 0]. The following two statements are equivalent:jsprojection.fitExtent([[0, 0], [width, height]], object);
projection.fitSize([width, height], object);projection.fitWidth(width, object) ​Source · A convenience method for projection.fitSize where the height is automatically chosen from the aspect ratio of object and the given constraint on width.projection.fitHeight(height, object) ​Source · A convenience method for projection.fitSize where the width is automatically chosen from the aspect ratio of object and the given constraint on height.Raw projections ​Raw projections are point transformation functions that are used to implement custom projections; they typically passed to geoProjection or geoProjectionMutator. They are exposed here to facilitate the derivation of related projections. Raw projections take spherical coordinates [lambda, phi] in radians (not degrees!) and return a point [x, y], typically in the unit square centered around the origin.project(lambda, phi) ​Projects the specified point [lambda, phi] in radians, returning a new point [x, y] in unitless coordinates.project.invert(x, y) ​The inverse of project.geoProjection(project) ​Source · Constructs a new projection from the specified raw projection, project. The project function takes the longitude and latitude of a given point in radians, often referred to as lambda (λ) and phi (φ), and returns a two-element array [x, y] representing its unit projection. The project function does not need to scale or translate the point, as these are applied automatically by projection.scale, projection.translate, and projection.center. Likewise, the project function does not need to perform any spherical rotation, as projection.rotate is applied prior to projection.For example, a spherical Mercator projection can be implemented as:jsvar mercator = d3.geoProjection(function(x, y) {
  return [x, Math.log(Math.tan(Math.PI / 4 + y / 2))];
});If the project function exposes an invert method, the returned projection will also expose projection.invert.geoProjectionMutator(factory) ​Source · Constructs a new projection from the specified raw projection factory and returns a mutate function to call whenever the raw projection changes. The factory must return a raw projection. The returned mutate function returns the wrapped projection. For example, a conic projection typically has two configurable parallels. A suitable factory function, such as geoConicEqualAreaRaw, would have the form:js// y0 and y1 represent two parallels
function conicFactory(phi0, phi1) {
  return function conicRaw(lambda, phi) {
    return […, …];
  };
}Using d3.geoProjectionMutator, you can implement a standard projection that allows the parallels to be changed, reassigning the raw projection used internally by geoProjection:jsfunction conicCustom() {
  var phi0 = 29.5,
      phi1 = 45.5,
      mutate = d3.geoProjectionMutator(conicFactory),
      projection = mutate(phi0, phi1);

  projection.parallels = function(_) {
    return arguments.length ? mutate(phi0 = +_[0], phi1 = +_[1]) : [phi0, phi1];
  };

  return projection;
}When creating a mutable projection, the mutate function is typically not exposed.geoTransform(methods) ​Source · Defines an arbitrary transform using the methods defined on the specified methods object. Any undefined methods will use pass-through methods that propagate inputs to the output stream.For example, to reflect the y-dimension (see also projection.reflectY):jsconst reflectY = d3.geoTransform({
  point(x, y) {
    this.stream.point(x, -y);
  }
});Or to define an affine matrix transformation:jsfunction matrix(a, b, c, d, tx, ty) {
  return d3.geoTransform({
    point(x, y) {
      this.stream.point(a * x + b * y + tx, c * x + d * y + ty);
    }
  });
}A transform is a generalized projection; it implements projection.stream and can be passed to path.projection. However, it implements only a subset of the other projection methods, and represent arbitrary geometric transformations rather than projections from spherical to planar coordinates.geoIdentity() ​Source · The identity transform can be used to scale, translate and clip planar geometry. It implements projection.scale, projection.translate, projection.fitExtent, projection.fitSize, projection.fitWidth, projection.fitHeight, projection.clipExtent, projection.angle, projection.reflectX and projection.reflectY.geoClipAntimeridian ​Source · A clipping function which transforms a stream such that geometries (lines or polygons) that cross the antimeridian line are cut in two, one on each side. Typically used for pre-clipping.geoClipCircle(angle) ​Source · Generates a clipping function which transforms a stream such that geometries are bounded by a small circle of radius angle around the projection’s center. Typically used for pre-clipping.geoClipRectangle(x0, y0, x1, y1) ​Source · Generates a clipping function which transforms a stream such that geometries are bounded by a rectangle of coordinates [[x0, y0], [x1, y1]]. Typically used for post-clipping.\n\n\n\nAzimuthal projections ​Azimuthal projections project the sphere directly onto a plane.geoAzimuthalEqualArea() ​Source · The azimuthal equal-area projection.geoAzimuthalEquidistant() ​Source · The azimuthal equidistant projection.geoGnomonic() ​Source · The gnomonic projection.geoOrthographic() ​Source · The orthographic projection.geoStereographic() ​Source · The stereographic projection.\n\nSearchK7.9.0GitHub️ 110.0kOn this pageAzimuthal projections ​Azimuthal projections project the sphere directly onto a plane.geoAzimuthalEqualArea() ​Source · The azimuthal equal-area projection.geoAzimuthalEquidistant() ​Source · The azimuthal equidistant projection.geoGnomonic() ​Source · The gnomonic projection.geoOrthographic() ​Source · The orthographic projection.geoStereographic() ​Source · The stereographic projection.PagerPrevious pageProjectionsNext pageConic projections\n\nAzimuthal projections ​Azimuthal projections project the sphere directly onto a plane.geoAzimuthalEqualArea() ​Source · The azimuthal equal-area projection.geoAzimuthalEquidistant() ​Source · The azimuthal equidistant projection.geoGnomonic() ​Source · The gnomonic projection.geoOrthographic() ​Source · The orthographic projection.geoStereographic() ​Source · The stereographic projection.\n\n\n\nConic projections ​Conic projections project the sphere onto a cone, and then unroll the cone onto the plane. Conic projections have two standard parallels.conic.parallels(parallels) ​Source · The two standard parallels that define the map layout in conic projections.geoConicConformal() ​Source · The conic conformal projection. The parallels default to [30°, 30°] resulting in flat top.geoConicEqualArea() ​Source · The Albers’ equal-area conic projection.geoConicEquidistant() ​Source · The conic equidistant projection.geoAlbers() ​Source · The Albers’ equal area-conic projection. This is a U.S.-centric configuration of geoConicEqualArea.geoAlbersUsa() ​Source · This is a U.S.-centric composite projection of three geoConicEqualArea projections: geoAlbers is used for the lower forty-eight states, and separate conic equal-area projections are used for Alaska and Hawaii. The scale for Alaska is diminished: it is projected at 0.35× its true relative area. See Albers USA with Territories for an extension to all US territories, and d3-composite-projections for more examples.The constituent projections have fixed clip, center and rotation, and thus this projection does not support projection.center, projection.rotate, projection.clipAngle, or projection.clipExtent.\n\nSearchK7.9.0GitHub️ 110.0kOn this pageConic projections ​Conic projections project the sphere onto a cone, and then unroll the cone onto the plane. Conic projections have two standard parallels.conic.parallels(parallels) ​Source · The two standard parallels that define the map layout in conic projections.geoConicConformal() ​Source · The conic conformal projection. The parallels default to [30°, 30°] resulting in flat top.geoConicEqualArea() ​Source · The Albers’ equal-area conic projection.geoConicEquidistant() ​Source · The conic equidistant projection.geoAlbers() ​Source · The Albers’ equal area-conic projection. This is a U.S.-centric configuration of geoConicEqualArea.geoAlbersUsa() ​Source · This is a U.S.-centric composite projection of three geoConicEqualArea projections: geoAlbers is used for the lower forty-eight states, and separate conic equal-area projections are used for Alaska and Hawaii. The scale for Alaska is diminished: it is projected at 0.35× its true relative area. See Albers USA with Territories for an extension to all US territories, and d3-composite-projections for more examples.The constituent projections have fixed clip, center and rotation, and thus this projection does not support projection.center, projection.rotate, projection.clipAngle, or projection.clipExtent.PagerPrevious pageAzimuthal projectionsNext pageCylindrical projections\n\nConic projections ​Conic projections project the sphere onto a cone, and then unroll the cone onto the plane. Conic projections have two standard parallels.conic.parallels(parallels) ​Source · The two standard parallels that define the map layout in conic projections.geoConicConformal() ​Source · The conic conformal projection. The parallels default to [30°, 30°] resulting in flat top.geoConicEqualArea() ​Source · The Albers’ equal-area conic projection.geoConicEquidistant() ​Source · The conic equidistant projection.geoAlbers() ​Source · The Albers’ equal area-conic projection. This is a U.S.-centric configuration of geoConicEqualArea.geoAlbersUsa() ​Source · This is a U.S.-centric composite projection of three geoConicEqualArea projections: geoAlbers is used for the lower forty-eight states, and separate conic equal-area projections are used for Alaska and Hawaii. The scale for Alaska is diminished: it is projected at 0.35× its true relative area. See Albers USA with Territories for an extension to all US territories, and d3-composite-projections for more examples.The constituent projections have fixed clip, center and rotation, and thus this projection does not support projection.center, projection.rotate, projection.clipAngle, or projection.clipExtent.\n\n\n\nCylindrical projections ​Cylindrical projections project the sphere onto a containing cylinder, and then unroll the cylinder onto the plane. Pseudocylindrical projections are a generalization of cylindrical projections.geoEquirectangular() ​Source · The equirectangular (plate carrée) projection.geoMercator() ​Source · The spherical Mercator projection. Defines a default projection.clipExtent such that the world is projected to a square, clipped to approximately ±85° latitude.geoTransverseMercator() ​Source · The transverse spherical Mercator projection. Defines a default projection.clipExtent such that the world is projected to a square, clipped to approximately ±85° latitude.geoEqualEarth() ​Source · The Equal Earth projection, an equal-area projection, by Bojan Šavrič et al., 2018.geoNaturalEarth1() ​Source · The Natural Earth projection is a pseudocylindrical projection designed by Tom Patterson. It is neither conformal nor equal-area, but appealing to the eye for small-scale maps of the whole world.\n\nSearchK7.9.0GitHub️ 110.0kOn this pageCylindrical projections ​Cylindrical projections project the sphere onto a containing cylinder, and then unroll the cylinder onto the plane. Pseudocylindrical projections are a generalization of cylindrical projections.geoEquirectangular() ​Source · The equirectangular (plate carrée) projection.geoMercator() ​Source · The spherical Mercator projection. Defines a default projection.clipExtent such that the world is projected to a square, clipped to approximately ±85° latitude.geoTransverseMercator() ​Source · The transverse spherical Mercator projection. Defines a default projection.clipExtent such that the world is projected to a square, clipped to approximately ±85° latitude.geoEqualEarth() ​Source · The Equal Earth projection, an equal-area projection, by Bojan Šavrič et al., 2018.geoNaturalEarth1() ​Source · The Natural Earth projection is a pseudocylindrical projection designed by Tom Patterson. It is neither conformal nor equal-area, but appealing to the eye for small-scale maps of the whole world.PagerPrevious pageConic projectionsNext pageStreams\n\nCylindrical projections ​Cylindrical projections project the sphere onto a containing cylinder, and then unroll the cylinder onto the plane. Pseudocylindrical projections are a generalization of cylindrical projections.geoEquirectangular() ​Source · The equirectangular (plate carrée) projection.geoMercator() ​Source · The spherical Mercator projection. Defines a default projection.clipExtent such that the world is projected to a square, clipped to approximately ±85° latitude.geoTransverseMercator() ​Source · The transverse spherical Mercator projection. Defines a default projection.clipExtent such that the world is projected to a square, clipped to approximately ±85° latitude.geoEqualEarth() ​Source · The Equal Earth projection, an equal-area projection, by Bojan Šavrič et al., 2018.geoNaturalEarth1() ​Source · The Natural Earth projection is a pseudocylindrical projection designed by Tom Patterson. It is neither conformal nor equal-area, but appealing to the eye for small-scale maps of the whole world.\n\n\n\nStreams ​Rather than materializing intermediate representations, streams transform geometry through function calls to minimize overhead. Streams must implement several methods to receive input geometry. Streams are inherently stateful; the meaning of a point depends on whether the point is inside of a line, and likewise a line is distinguished from a ring by a polygon. Despite the name “stream”, these method calls are currently synchronous.geoStream(object, stream) ​Source · Streams the specified GeoJSON object to the specified projection stream. While both features and geometry objects are supported as input, the stream interface only describes the geometry, and thus additional feature properties are not visible to streams.stream.point(x, y, z) ​Indicates a point with the specified coordinates x and y (and optionally z). The coordinate system is unspecified and implementation-dependent; for example, projection streams require spherical coordinates in degrees as input. Outside the context of a polygon or line, a point indicates a point geometry object (Point or MultiPoint). Within a line or polygon ring, the point indicates a control point.stream.lineStart() ​Indicates the start of a line or ring. Within a polygon, indicates the start of a ring. The first ring of a polygon is the exterior ring, and is typically clockwise. Any subsequent rings indicate holes in the polygon, and are typically counterclockwise.stream.lineEnd() ​Indicates the end of a line or ring. Within a polygon, indicates the end of a ring. Unlike GeoJSON, the redundant closing coordinate of a ring is not indicated via point, and instead is implied via lineEnd within a polygon. Thus, the given polygon input:json{
  "type": "Polygon",
  "coordinates": [[[0, 0], [0, 1], [1, 1], [1, 0], [0, 0]]]
}Will produce the following series of method calls on the stream:jsstream.polygonStart();
stream.lineStart();
stream.point(0, 0);
stream.point(0, 1);
stream.point(1, 1);
stream.point(1, 0);
stream.lineEnd();
stream.polygonEnd();stream.polygonStart() ​Indicates the start of a polygon. The first line of a polygon indicates the exterior ring, and any subsequent lines indicate interior holes.stream.polygonEnd() ​Indicates the end of a polygon.stream.sphere() ​Indicates the sphere (the globe; the unit sphere centered at ⟨0,0,0⟩).\n\nSearchK7.9.0GitHub️ 110.0kOn this pageStreams ​Rather than materializing intermediate representations, streams transform geometry through function calls to minimize overhead. Streams must implement several methods to receive input geometry. Streams are inherently stateful; the meaning of a point depends on whether the point is inside of a line, and likewise a line is distinguished from a ring by a polygon. Despite the name “stream”, these method calls are currently synchronous.geoStream(object, stream) ​Source · Streams the specified GeoJSON object to the specified projection stream. While both features and geometry objects are supported as input, the stream interface only describes the geometry, and thus additional feature properties are not visible to streams.stream.point(x, y, z) ​Indicates a point with the specified coordinates x and y (and optionally z). The coordinate system is unspecified and implementation-dependent; for example, projection streams require spherical coordinates in degrees as input. Outside the context of a polygon or line, a point indicates a point geometry object (Point or MultiPoint). Within a line or polygon ring, the point indicates a control point.stream.lineStart() ​Indicates the start of a line or ring. Within a polygon, indicates the start of a ring. The first ring of a polygon is the exterior ring, and is typically clockwise. Any subsequent rings indicate holes in the polygon, and are typically counterclockwise.stream.lineEnd() ​Indicates the end of a line or ring. Within a polygon, indicates the end of a ring. Unlike GeoJSON, the redundant closing coordinate of a ring is not indicated via point, and instead is implied via lineEnd within a polygon. Thus, the given polygon input:json{
  "type": "Polygon",
  "coordinates": [[[0, 0], [0, 1], [1, 1], [1, 0], [0, 0]]]
}Will produce the following series of method calls on the stream:jsstream.polygonStart();
stream.lineStart();
stream.point(0, 0);
stream.point(0, 1);
stream.point(1, 1);
stream.point(1, 0);
stream.lineEnd();
stream.polygonEnd();stream.polygonStart() ​Indicates the start of a polygon. The first line of a polygon indicates the exterior ring, and any subsequent lines indicate interior holes.stream.polygonEnd() ​Indicates the end of a polygon.stream.sphere() ​Indicates the sphere (the globe; the unit sphere centered at ⟨0,0,0⟩).PagerPrevious pageCylindrical projectionsNext pageSpherical shapes\n\nStreams ​Rather than materializing intermediate representations, streams transform geometry through function calls to minimize overhead. Streams must implement several methods to receive input geometry. Streams are inherently stateful; the meaning of a point depends on whether the point is inside of a line, and likewise a line is distinguished from a ring by a polygon. Despite the name “stream”, these method calls are currently synchronous.geoStream(object, stream) ​Source · Streams the specified GeoJSON object to the specified projection stream. While both features and geometry objects are supported as input, the stream interface only describes the geometry, and thus additional feature properties are not visible to streams.stream.point(x, y, z) ​Indicates a point with the specified coordinates x and y (and optionally z). The coordinate system is unspecified and implementation-dependent; for example, projection streams require spherical coordinates in degrees as input. Outside the context of a polygon or line, a point indicates a point geometry object (Point or MultiPoint). Within a line or polygon ring, the point indicates a control point.stream.lineStart() ​Indicates the start of a line or ring. Within a polygon, indicates the start of a ring. The first ring of a polygon is the exterior ring, and is typically clockwise. Any subsequent rings indicate holes in the polygon, and are typically counterclockwise.stream.lineEnd() ​Indicates the end of a line or ring. Within a polygon, indicates the end of a ring. Unlike GeoJSON, the redundant closing coordinate of a ring is not indicated via point, and instead is implied via lineEnd within a polygon. Thus, the given polygon input:json{
  "type": "Polygon",
  "coordinates": [[[0, 0], [0, 1], [1, 1], [1, 0], [0, 0]]]
}Will produce the following series of method calls on the stream:jsstream.polygonStart();
stream.lineStart();
stream.point(0, 0);
stream.point(0, 1);
stream.point(1, 1);
stream.point(1, 0);
stream.lineEnd();
stream.polygonEnd();stream.polygonStart() ​Indicates the start of a polygon. The first line of a polygon indicates the exterior ring, and any subsequent lines indicate interior holes.stream.polygonEnd() ​Indicates the end of a polygon.stream.sphere() ​Indicates the sphere (the globe; the unit sphere centered at ⟨0,0,0⟩).\n\n\n\nSpherical shapes ​These shape generators return spherical GeoJSON for use with geoPath.TIPTo generate a great arc (a segment of a great circle), pass a GeoJSON LineString geometry object to a geoPath. D3’s projections use geodesic interpolation for intermediate points.geoGraticule() ​Source · Constructs a geometry generator for creating graticules: a uniform grid of meridians and parallels for showing projection distortion. The default graticule has meridians and parallels every 10° between ±80° latitude; for the polar regions, there are meridians every 90°.graticule() ​Source · Returns a GeoJSON MultiLineString geometry object representing all meridians and parallels for this graticule.graticule.lines() ​Source · Returns an array of GeoJSON LineString geometry objects, one for each meridian or parallel for this graticule.graticule.outline() ​Source · Returns a GeoJSON Polygon geometry object representing the outline of this graticule, i.e. along the meridians and parallels defining its extent.graticule.extent(extent) ​Source · If extent is specified, sets the major and minor extents of this graticule. If extent is not specified, returns the current minor extent, which defaults to ⟨⟨-180°, -80° - ε⟩, ⟨180°, 80° + ε⟩⟩.graticule.extentMajor(extent) ​Source · If extent is specified, sets the major extent of this graticule. If extent is not specified, returns the current major extent, which defaults to ⟨⟨-180°, -90° + ε⟩, ⟨180°, 90° - ε⟩⟩.graticule.extentMinor(extent) ​Source · If extent is specified, sets the minor extent of this graticule. If extent is not specified, returns the current minor extent, which defaults to ⟨⟨-180°, -80° - ε⟩, ⟨180°, 80° + ε⟩⟩.graticule.step(step) ​Source · If step is specified, sets the major and minor step for this graticule. If step is not specified, returns the current minor step, which defaults to ⟨10°, 10°⟩.graticule.stepMajor(step) ​Source · If step is specified, sets the major step for this graticule. If step is not specified, returns the current major step, which defaults to ⟨90°, 360°⟩.graticule.stepMinor(step) ​Source · If step is specified, sets the minor step for this graticule. If step is not specified, returns the current minor step, which defaults to ⟨10°, 10°⟩.graticule.precision(angle) ​Source · If precision is specified, sets the precision for this graticule, in degrees. If precision is not specified, returns the current precision, which defaults to 2.5°.geoGraticule10() ​Source · A convenience method for directly generating the default 10° global graticule as a GeoJSON MultiLineString geometry object. Equivalent to:jsfunction geoGraticule10() {
  return d3.geoGraticule()();
}geoCircle() ​Source · Returns a new circle generator.circle(...arguments) ​Source · Returns a new GeoJSON geometry object of type “Polygon” approximating a circle on the surface of a sphere, with the current center, radius and precision. Any arguments are passed to the accessors.circle.center(center) ​Source · If center is specified, sets the circle center to the specified point [longitude, latitude] in degrees, and returns this circle generator. The center may also be specified as a function; this function will be invoked whenever a circle is generated, being passed any arguments passed to the circle generator. If center is not specified, returns the current center accessor, which defaults to:jsfunction center() {
  return [0, 0];
}circle.radius(radius) ​Source · If radius is specified, sets the circle radius to the specified angle in degrees, and returns this circle generator. The radius may also be specified as a function; this function will be invoked whenever a circle is generated, being passed any arguments passed to the circle generator. If radius is not specified, returns the current radius accessor, which defaults to:jsfunction radius() {
  return 90;
}circle.precision(angle) ​Source · If precision is specified, sets the circle precision to the specified angle in degrees, and returns this circle generator. The precision may also be specified as a function; this function will be invoked whenever a circle is generated, being passed any arguments passed to the circle generator. If precision is not specified, returns the current precision accessor, which defaults to:jsfunction precision() {
  return 2;
}Small circles do not follow great arcs and thus the generated polygon is only an approximation. Specifying a smaller precision angle improves the accuracy of the approximate polygon, but also increase the cost to generate and render it.\n\nSearchK7.9.0GitHub️ 110.0kOn this pageSpherical shapes ​These shape generators return spherical GeoJSON for use with geoPath.TIPTo generate a great arc (a segment of a great circle), pass a GeoJSON LineString geometry object to a geoPath. D3’s projections use geodesic interpolation for intermediate points.geoGraticule() ​Source · Constructs a geometry generator for creating graticules: a uniform grid of meridians and parallels for showing projection distortion. The default graticule has meridians and parallels every 10° between ±80° latitude; for the polar regions, there are meridians every 90°.graticule() ​Source · Returns a GeoJSON MultiLineString geometry object representing all meridians and parallels for this graticule.graticule.lines() ​Source · Returns an array of GeoJSON LineString geometry objects, one for each meridian or parallel for this graticule.graticule.outline() ​Source · Returns a GeoJSON Polygon geometry object representing the outline of this graticule, i.e. along the meridians and parallels defining its extent.graticule.extent(extent) ​Source · If extent is specified, sets the major and minor extents of this graticule. If extent is not specified, returns the current minor extent, which defaults to ⟨⟨-180°, -80° - ε⟩, ⟨180°, 80° + ε⟩⟩.graticule.extentMajor(extent) ​Source · If extent is specified, sets the major extent of this graticule. If extent is not specified, returns the current major extent, which defaults to ⟨⟨-180°, -90° + ε⟩, ⟨180°, 90° - ε⟩⟩.graticule.extentMinor(extent) ​Source · If extent is specified, sets the minor extent of this graticule. If extent is not specified, returns the current minor extent, which defaults to ⟨⟨-180°, -80° - ε⟩, ⟨180°, 80° + ε⟩⟩.graticule.step(step) ​Source · If step is specified, sets the major and minor step for this graticule. If step is not specified, returns the current minor step, which defaults to ⟨10°, 10°⟩.graticule.stepMajor(step) ​Source · If step is specified, sets the major step for this graticule. If step is not specified, returns the current major step, which defaults to ⟨90°, 360°⟩.graticule.stepMinor(step) ​Source · If step is specified, sets the minor step for this graticule. If step is not specified, returns the current minor step, which defaults to ⟨10°, 10°⟩.graticule.precision(angle) ​Source · If precision is specified, sets the precision for this graticule, in degrees. If precision is not specified, returns the current precision, which defaults to 2.5°.geoGraticule10() ​Source · A convenience method for directly generating the default 10° global graticule as a GeoJSON MultiLineString geometry object. Equivalent to:jsfunction geoGraticule10() {
  return d3.geoGraticule()();
}geoCircle() ​Source · Returns a new circle generator.circle(...arguments) ​Source · Returns a new GeoJSON geometry object of type “Polygon” approximating a circle on the surface of a sphere, with the current center, radius and precision. Any arguments are passed to the accessors.circle.center(center) ​Source · If center is specified, sets the circle center to the specified point [longitude, latitude] in degrees, and returns this circle generator. The center may also be specified as a function; this function will be invoked whenever a circle is generated, being passed any arguments passed to the circle generator. If center is not specified, returns the current center accessor, which defaults to:jsfunction center() {
  return [0, 0];
}circle.radius(radius) ​Source · If radius is specified, sets the circle radius to the specified angle in degrees, and returns this circle generator. The radius may also be specified as a function; this function will be invoked whenever a circle is generated, being passed any arguments passed to the circle generator. If radius is not specified, returns the current radius accessor, which defaults to:jsfunction radius() {
  return 90;
}circle.precision(angle) ​Source · If precision is specified, sets the circle precision to the specified angle in degrees, and returns this circle generator. The precision may also be specified as a function; this function will be invoked whenever a circle is generated, being passed any arguments passed to the circle generator. If precision is not specified, returns the current precision accessor, which defaults to:jsfunction precision() {
  return 2;
}Small circles do not follow great arcs and thus the generated polygon is only an approximation. Specifying a smaller precision angle improves the accuracy of the approximate polygon, but also increase the cost to generate and render it.PagerPrevious pageStreamsNext pageSpherical math\n\nSpherical shapes ​These shape generators return spherical GeoJSON for use with geoPath.TIPTo generate a great arc (a segment of a great circle), pass a GeoJSON LineString geometry object to a geoPath. D3’s projections use geodesic interpolation for intermediate points.geoGraticule() ​Source · Constructs a geometry generator for creating graticules: a uniform grid of meridians and parallels for showing projection distortion. The default graticule has meridians and parallels every 10° between ±80° latitude; for the polar regions, there are meridians every 90°.graticule() ​Source · Returns a GeoJSON MultiLineString geometry object representing all meridians and parallels for this graticule.graticule.lines() ​Source · Returns an array of GeoJSON LineString geometry objects, one for each meridian or parallel for this graticule.graticule.outline() ​Source · Returns a GeoJSON Polygon geometry object representing the outline of this graticule, i.e. along the meridians and parallels defining its extent.graticule.extent(extent) ​Source · If extent is specified, sets the major and minor extents of this graticule. If extent is not specified, returns the current minor extent, which defaults to ⟨⟨-180°, -80° - ε⟩, ⟨180°, 80° + ε⟩⟩.graticule.extentMajor(extent) ​Source · If extent is specified, sets the major extent of this graticule. If extent is not specified, returns the current major extent, which defaults to ⟨⟨-180°, -90° + ε⟩, ⟨180°, 90° - ε⟩⟩.graticule.extentMinor(extent) ​Source · If extent is specified, sets the minor extent of this graticule. If extent is not specified, returns the current minor extent, which defaults to ⟨⟨-180°, -80° - ε⟩, ⟨180°, 80° + ε⟩⟩.graticule.step(step) ​Source · If step is specified, sets the major and minor step for this graticule. If step is not specified, returns the current minor step, which defaults to ⟨10°, 10°⟩.graticule.stepMajor(step) ​Source · If step is specified, sets the major step for this graticule. If step is not specified, returns the current major step, which defaults to ⟨90°, 360°⟩.graticule.stepMinor(step) ​Source · If step is specified, sets the minor step for this graticule. If step is not specified, returns the current minor step, which defaults to ⟨10°, 10°⟩.graticule.precision(angle) ​Source · If precision is specified, sets the precision for this graticule, in degrees. If precision is not specified, returns the current precision, which defaults to 2.5°.geoGraticule10() ​Source · A convenience method for directly generating the default 10° global graticule as a GeoJSON MultiLineString geometry object. Equivalent to:jsfunction geoGraticule10() {
  return d3.geoGraticule()();
}geoCircle() ​Source · Returns a new circle generator.circle(...arguments) ​Source · Returns a new GeoJSON geometry object of type “Polygon” approximating a circle on the surface of a sphere, with the current center, radius and precision. Any arguments are passed to the accessors.circle.center(center) ​Source · If center is specified, sets the circle center to the specified point [longitude, latitude] in degrees, and returns this circle generator. The center may also be specified as a function; this function will be invoked whenever a circle is generated, being passed any arguments passed to the circle generator. If center is not specified, returns the current center accessor, which defaults to:jsfunction center() {
  return [0, 0];
}circle.radius(radius) ​Source · If radius is specified, sets the circle radius to the specified angle in degrees, and returns this circle generator. The radius may also be specified as a function; this function will be invoked whenever a circle is generated, being passed any arguments passed to the circle generator. If radius is not specified, returns the current radius accessor, which defaults to:jsfunction radius() {
  return 90;
}circle.precision(angle) ​Source · If precision is specified, sets the circle precision to the specified angle in degrees, and returns this circle generator. The precision may also be specified as a function; this function will be invoked whenever a circle is generated, being passed any arguments passed to the circle generator. If precision is not specified, returns the current precision accessor, which defaults to:jsfunction precision() {
  return 2;
}Small circles do not follow great arcs and thus the generated polygon is only an approximation. Specifying a smaller precision angle improves the accuracy of the approximate polygon, but also increase the cost to generate and render it.\n\n\n\nSpherical math ​Low-level utilities for spherical geometry.geoArea(object) ​Source · Returns the spherical area of the specified GeoJSON object in steradians. This is the spherical equivalent of path.area.geoBounds(object) ​Source · Returns the spherical bounding box for the specified GeoJSON object. The bounding box is represented by a two-dimensional array: [[left, bottom], [right, top]], where left is the minimum longitude, bottom is the minimum latitude, right is maximum longitude, and top is the maximum latitude. All coordinates are given in degrees. (Note that in projected planar coordinates, the minimum latitude is typically the maximum y-value, and the maximum latitude is typically the minimum y-value.) This is the spherical equivalent of path.bounds.geoCentroid(object) ​Source · Returns the spherical centroid of the specified GeoJSON object. This is the spherical equivalent of path.centroid.geoDistance(a, b) ​Source · Returns the great-arc distance in radians between the two points a and b. Each point must be specified as a two-element array [longitude, latitude] in degrees. This is the spherical equivalent of path.measure given a LineString of two points.geoLength(object) ​Source · Returns the great-arc length of the specified GeoJSON object in radians. For polygons, returns the perimeter of the exterior ring plus that of any interior rings. This is the spherical equivalent of path.measure.geoInterpolate(a, b) ​Source · Returns an interpolator function given two points a and b. Each point must be specified as a two-element array [longitude, latitude] in degrees. The returned interpolator function takes a single argument t, where t is a number ranging from 0 to 1; a value of 0 returns the point a, while a value of 1 returns the point b. Intermediate values interpolate from a to b along the great arc that passes through both a and b. If a and b are antipodes, an arbitrary great arc is chosen.geoContains(object, point) ​Source · Returns true if and only if the specified GeoJSON object contains the specified point, or false if the object does not contain the point. The point must be specified as a two-element array [longitude, latitude] in degrees. For Point and MultiPoint geometries, an exact test is used; for a Sphere, true is always returned; for other geometries, an epsilon threshold is applied.geoRotation(angles) ​Source · Returns a rotation function for the given angles, which must be a two- or three-element array of numbers [lambda, phi, gamma] specifying the rotation angles in degrees about each spherical axis. (These correspond to yaw, pitch and roll.) If the rotation angle gamma is omitted, it defaults to 0. See also projection.rotate.rotation(point) ​Source · Returns a new array [longitude, latitude] in degrees representing the rotated point of the given point. The point must be specified as a two-element array [longitude, latitude] in degrees.rotation.invert(point) ​Source · Returns a new array [longitude, latitude] in degrees representing the point of the given rotated point; the inverse of rotation. The point must be specified as a two-element array [longitude, latitude] in degrees.\n\nSearchK7.9.0GitHub️ 110.0kOn this pageSpherical math ​Low-level utilities for spherical geometry.geoArea(object) ​Source · Returns the spherical area of the specified GeoJSON object in steradians. This is the spherical equivalent of path.area.geoBounds(object) ​Source · Returns the spherical bounding box for the specified GeoJSON object. The bounding box is represented by a two-dimensional array: [[left, bottom], [right, top]], where left is the minimum longitude, bottom is the minimum latitude, right is maximum longitude, and top is the maximum latitude. All coordinates are given in degrees. (Note that in projected planar coordinates, the minimum latitude is typically the maximum y-value, and the maximum latitude is typically the minimum y-value.) This is the spherical equivalent of path.bounds.geoCentroid(object) ​Source · Returns the spherical centroid of the specified GeoJSON object. This is the spherical equivalent of path.centroid.geoDistance(a, b) ​Source · Returns the great-arc distance in radians between the two points a and b. Each point must be specified as a two-element array [longitude, latitude] in degrees. This is the spherical equivalent of path.measure given a LineString of two points.geoLength(object) ​Source · Returns the great-arc length of the specified GeoJSON object in radians. For polygons, returns the perimeter of the exterior ring plus that of any interior rings. This is the spherical equivalent of path.measure.geoInterpolate(a, b) ​Source · Returns an interpolator function given two points a and b. Each point must be specified as a two-element array [longitude, latitude] in degrees. The returned interpolator function takes a single argument t, where t is a number ranging from 0 to 1; a value of 0 returns the point a, while a value of 1 returns the point b. Intermediate values interpolate from a to b along the great arc that passes through both a and b. If a and b are antipodes, an arbitrary great arc is chosen.geoContains(object, point) ​Source · Returns true if and only if the specified GeoJSON object contains the specified point, or false if the object does not contain the point. The point must be specified as a two-element array [longitude, latitude] in degrees. For Point and MultiPoint geometries, an exact test is used; for a Sphere, true is always returned; for other geometries, an epsilon threshold is applied.geoRotation(angles) ​Source · Returns a rotation function for the given angles, which must be a two- or three-element array of numbers [lambda, phi, gamma] specifying the rotation angles in degrees about each spherical axis. (These correspond to yaw, pitch and roll.) If the rotation angle gamma is omitted, it defaults to 0. See also projection.rotate.rotation(point) ​Source · Returns a new array [longitude, latitude] in degrees representing the rotated point of the given point. The point must be specified as a two-element array [longitude, latitude] in degrees.rotation.invert(point) ​Source · Returns a new array [longitude, latitude] in degrees representing the point of the given rotated point; the inverse of rotation. The point must be specified as a two-element array [longitude, latitude] in degrees.PagerPrevious pageSpherical shapesNext paged3-hierarchy\n\nSpherical math ​Low-level utilities for spherical geometry.geoArea(object) ​Source · Returns the spherical area of the specified GeoJSON object in steradians. This is the spherical equivalent of path.area.geoBounds(object) ​Source · Returns the spherical bounding box for the specified GeoJSON object. The bounding box is represented by a two-dimensional array: [[left, bottom], [right, top]], where left is the minimum longitude, bottom is the minimum latitude, right is maximum longitude, and top is the maximum latitude. All coordinates are given in degrees. (Note that in projected planar coordinates, the minimum latitude is typically the maximum y-value, and the maximum latitude is typically the minimum y-value.) This is the spherical equivalent of path.bounds.geoCentroid(object) ​Source · Returns the spherical centroid of the specified GeoJSON object. This is the spherical equivalent of path.centroid.geoDistance(a, b) ​Source · Returns the great-arc distance in radians between the two points a and b. Each point must be specified as a two-element array [longitude, latitude] in degrees. This is the spherical equivalent of path.measure given a LineString of two points.geoLength(object) ​Source · Returns the great-arc length of the specified GeoJSON object in radians. For polygons, returns the perimeter of the exterior ring plus that of any interior rings. This is the spherical equivalent of path.measure.geoInterpolate(a, b) ​Source · Returns an interpolator function given two points a and b. Each point must be specified as a two-element array [longitude, latitude] in degrees. The returned interpolator function takes a single argument t, where t is a number ranging from 0 to 1; a value of 0 returns the point a, while a value of 1 returns the point b. Intermediate values interpolate from a to b along the great arc that passes through both a and b. If a and b are antipodes, an arbitrary great arc is chosen.geoContains(object, point) ​Source · Returns true if and only if the specified GeoJSON object contains the specified point, or false if the object does not contain the point. The point must be specified as a two-element array [longitude, latitude] in degrees. For Point and MultiPoint geometries, an exact test is used; for a Sphere, true is always returned; for other geometries, an epsilon threshold is applied.geoRotation(angles) ​Source · Returns a rotation function for the given angles, which must be a two- or three-element array of numbers [lambda, phi, gamma] specifying the rotation angles in degrees about each spherical axis. (These correspond to yaw, pitch and roll.) If the rotation angle gamma is omitted, it defaults to 0. See also projection.rotate.rotation(point) ​Source · Returns a new array [longitude, latitude] in degrees representing the rotated point of the given point. The point must be specified as a two-element array [longitude, latitude] in degrees.rotation.invert(point) ​Source · Returns a new array [longitude, latitude] in degrees representing the point of the given rotated point; the inverse of rotation. The point must be specified as a two-element array [longitude, latitude] in degrees.\n\n\n\nHierarchies ​Before you can compute a hierarchical layout, you need a root node. If your data is already in a hierarchical format, such as JSON, you can pass it directly to hierarchy; otherwise, you can rearrange tabular data, such as comma-separated values (CSV), into a hierarchy using stratify.hierarchy(data, children) ​Examples · Source · Constructs a root node from the specified hierarchical data. The specified data must be an object representing the root node. For example:jsconst data = {
  name: "Eve",
  children: [
    {name: "Cain"},
    {name: "Seth", children: [{name: "Enos"}, {name: "Noam"}]},
    {name: "Abel"},
    {name: "Awan", children: [{name: "Enoch"}]},
    {name: "Azura"}
  ]
};To construct a hierarchy:jsconst root = d3.hierarchy(data);The specified children accessor function is invoked for each datum, starting with the root data, and must return an iterable of data representing the children, if any. If the children accessor is not specified, it defaults to:jsfunction children(d) {
  return d.children;
}If data is a Map, it is implicitly converted to the entry [undefined, data], and the children accessor instead defaults to:jsfunction children(d) {
  return Array.isArray(d) ? d[1] : null;
}This allows you to pass the result of group or rollup to hierarchy.The returned root node and each descendant has the following properties:node.data - the associated data as passed to hierarchynode.depth - zero for the root, increasing by one for each descendant generationnode.height - the greatest distance from any descendant leaf, or zero for leavesnode.parent - the parent node, or null for the root nodenode.children - an array of child nodes, if any, or undefined for leavesnode.value - the optional summed value of the node and its descendantsThis method can also be used to test if a node is an instanceof d3.hierarchy and to extend the node prototype.node.ancestors() ​Source · Returns the array of ancestors nodes, starting with this node, then followed by each parent up to the root.node.descendants() ​Source · Returns the array of descendant nodes, starting with this node, then followed by each child in topological order.node.leaves() ​Source · Returns the array of leaf nodes in traversal order. A leaf is a node with no children.node.find(filter) ​Source · Returns the first node in the hierarchy from this node for which the specified filter returns a truthy value. Returns undefined if no such node is found.node.path(target) ​Source · Returns the shortest path through the hierarchy from this node to the specified target node. The path starts at this node, ascends to the least common ancestor of this node and the target node, and then descends to the target node. This is useful for hierarchical edge bundling.node.links() ​Source · Returns an array of links for this node and its descendants, where each link is an object that defines source and target properties. The source of each link is the parent node, and the target is a child node.node.sum(value) ​Examples · Source · Evaluates the specified value function for this node and each descendant in post-order traversal, and returns this node. The node.value property of each node is set to the numeric value returned by the specified function plus the combined value of all children. The function is passed the node’s data, and must return a non-negative number. The value accessor is evaluated for node and every descendant, including internal nodes; if you only want leaf nodes to have internal value, then return zero for any node with children. For example, as an alternative to node.count:jsroot.sum((d) => d.value ? 1 : 0);You must call node.sum or node.count before invoking a hierarchical layout that requires node.value, such as treemap. For example:js// Construct the treemap layout.
const treemap = d3.treemap();
treemap.size([width, height]);
treemap.padding(2);

// Sum and sort the data.
root.sum((d) => d.value);
root.sort((a, b) => b.height - a.height || b.value - a.value);

// Compute the treemap layout.
treemap(root);

// Retrieve all descendant nodes.
const nodes = root.descendants();Since the API supports method chaining, you can also say:jsd3.treemap()
    .size([width, height])
    .padding(2)
  (root
      .sum((d) => d.value)
      .sort((a, b) => b.height - a.height || b.value - a.value))
  .descendants()This example assumes that the node data has a value field.node.count() ​Examples · Source · Computes the number of leaves under this node and assigns it to node.value, and similarly for every descendant of node. If this node is a leaf, its count is one. Returns this node. See also node.sum.node.sort(compare) ​Examples · Source · Sorts the children of this node, if any, and each of this node’s descendants’ children, in pre-order traversal using the specified compare function, and returns this node.The specified function is passed two nodes a and b to compare. If a should be before b, the function must return a value less than zero; if b should be before a, the function must return a value greater than zero; otherwise, the relative order of a and b are not specified. See array.sort for more.Unlike node.sum, the compare function is passed two nodes rather than two nodes’ data. For example, if the data has a value property, this sorts nodes by the descending aggregate value of the node and all its descendants, as is recommended for circle-packing:jsroot
    .sum((d) => d.value)
    .sort((a, b) => b.value - a.value);Similarly, to sort nodes by descending height (greatest distance from any descendant leaf) and then descending value, as is recommended for treemaps and icicles:jsroot
    .sum((d) => d.value)
    .sort((a, b) => b.height - a.height || b.value - a.value);To sort nodes by descending height and then ascending id, as is recommended for trees and dendrograms:jsroot
    .sum((d) => d.value)
    .sort((a, b) => b.height - a.height || d3.ascending(a.id, b.id));You must call node.sort before invoking a hierarchical layout if you want the new sort order to affect the layout; see node.sum for an example.node[Symbol.iterator]() ​Source · Returns an iterator over the node’s descendants in breadth-first order. For example:jsfor (const descendant of node) {
  console.log(descendant);
}node.each(function, that) ​Examples · Source · Invokes the specified function for node and each descendant in breadth-first order, such that a given node is only visited if all nodes of lesser depth have already been visited, as well as all preceding nodes of the same depth. The specified function is passed the current descendant, the zero-based traversal index, and this node. If that is specified, it is the this context of the callback.node.eachAfter(function, that) ​Examples · Source · Invokes the specified function for node and each descendant in post-order traversal, such that a given node is only visited after all of its descendants have already been visited. The specified function is passed the current descendant, the zero-based traversal index, and this node. If that is specified, it is the this context of the callback.node.eachBefore(function, that) ​Examples · Source · Invokes the specified function for node and each descendant in pre-order traversal, such that a given node is only visited after all of its ancestors have already been visited. The specified function is passed the current descendant, the zero-based traversal index, and this node. If that is specified, it is the this context of the callback.node.copy() ​Source · Return a deep copy of the subtree starting at this node. (The returned deep copy shares the same data, however.) The returned node is the root of a new tree; the returned node’s parent is always null and its depth is always zero.\n\nSearchK7.9.0GitHub️ 110.0kOn this pageHierarchies ​Before you can compute a hierarchical layout, you need a root node. If your data is already in a hierarchical format, such as JSON, you can pass it directly to hierarchy; otherwise, you can rearrange tabular data, such as comma-separated values (CSV), into a hierarchy using stratify.hierarchy(data, children) ​Examples · Source · Constructs a root node from the specified hierarchical data. The specified data must be an object representing the root node. For example:jsconst data = {
  name: "Eve",
  children: [
    {name: "Cain"},
    {name: "Seth", children: [{name: "Enos"}, {name: "Noam"}]},
    {name: "Abel"},
    {name: "Awan", children: [{name: "Enoch"}]},
    {name: "Azura"}
  ]
};To construct a hierarchy:jsconst root = d3.hierarchy(data);The specified children accessor function is invoked for each datum, starting with the root data, and must return an iterable of data representing the children, if any. If the children accessor is not specified, it defaults to:jsfunction children(d) {
  return d.children;
}If data is a Map, it is implicitly converted to the entry [undefined, data], and the children accessor instead defaults to:jsfunction children(d) {
  return Array.isArray(d) ? d[1] : null;
}This allows you to pass the result of group or rollup to hierarchy.The returned root node and each descendant has the following properties:node.data - the associated data as passed to hierarchynode.depth - zero for the root, increasing by one for each descendant generationnode.height - the greatest distance from any descendant leaf, or zero for leavesnode.parent - the parent node, or null for the root nodenode.children - an array of child nodes, if any, or undefined for leavesnode.value - the optional summed value of the node and its descendantsThis method can also be used to test if a node is an instanceof d3.hierarchy and to extend the node prototype.node.ancestors() ​Source · Returns the array of ancestors nodes, starting with this node, then followed by each parent up to the root.node.descendants() ​Source · Returns the array of descendant nodes, starting with this node, then followed by each child in topological order.node.leaves() ​Source · Returns the array of leaf nodes in traversal order. A leaf is a node with no children.node.find(filter) ​Source · Returns the first node in the hierarchy from this node for which the specified filter returns a truthy value. Returns undefined if no such node is found.node.path(target) ​Source · Returns the shortest path through the hierarchy from this node to the specified target node. The path starts at this node, ascends to the least common ancestor of this node and the target node, and then descends to the target node. This is useful for hierarchical edge bundling.node.links() ​Source · Returns an array of links for this node and its descendants, where each link is an object that defines source and target properties. The source of each link is the parent node, and the target is a child node.node.sum(value) ​Examples · Source · Evaluates the specified value function for this node and each descendant in post-order traversal, and returns this node. The node.value property of each node is set to the numeric value returned by the specified function plus the combined value of all children. The function is passed the node’s data, and must return a non-negative number. The value accessor is evaluated for node and every descendant, including internal nodes; if you only want leaf nodes to have internal value, then return zero for any node with children. For example, as an alternative to node.count:jsroot.sum((d) => d.value ? 1 : 0);You must call node.sum or node.count before invoking a hierarchical layout that requires node.value, such as treemap. For example:js// Construct the treemap layout.
const treemap = d3.treemap();
treemap.size([width, height]);
treemap.padding(2);

// Sum and sort the data.
root.sum((d) => d.value);
root.sort((a, b) => b.height - a.height || b.value - a.value);

// Compute the treemap layout.
treemap(root);

// Retrieve all descendant nodes.
const nodes = root.descendants();Since the API supports method chaining, you can also say:jsd3.treemap()
    .size([width, height])
    .padding(2)
  (root
      .sum((d) => d.value)
      .sort((a, b) => b.height - a.height || b.value - a.value))
  .descendants()This example assumes that the node data has a value field.node.count() ​Examples · Source · Computes the number of leaves under this node and assigns it to node.value, and similarly for every descendant of node. If this node is a leaf, its count is one. Returns this node. See also node.sum.node.sort(compare) ​Examples · Source · Sorts the children of this node, if any, and each of this node’s descendants’ children, in pre-order traversal using the specified compare function, and returns this node.The specified function is passed two nodes a and b to compare. If a should be before b, the function must return a value less than zero; if b should be before a, the function must return a value greater than zero; otherwise, the relative order of a and b are not specified. See array.sort for more.Unlike node.sum, the compare function is passed two nodes rather than two nodes’ data. For example, if the data has a value property, this sorts nodes by the descending aggregate value of the node and all its descendants, as is recommended for circle-packing:jsroot
    .sum((d) => d.value)
    .sort((a, b) => b.value - a.value);Similarly, to sort nodes by descending height (greatest distance from any descendant leaf) and then descending value, as is recommended for treemaps and icicles:jsroot
    .sum((d) => d.value)
    .sort((a, b) => b.height - a.height || b.value - a.value);To sort nodes by descending height and then ascending id, as is recommended for trees and dendrograms:jsroot
    .sum((d) => d.value)
    .sort((a, b) => b.height - a.height || d3.ascending(a.id, b.id));You must call node.sort before invoking a hierarchical layout if you want the new sort order to affect the layout; see node.sum for an example.node[Symbol.iterator]() ​Source · Returns an iterator over the node’s descendants in breadth-first order. For example:jsfor (const descendant of node) {
  console.log(descendant);
}node.each(function, that) ​Examples · Source · Invokes the specified function for node and each descendant in breadth-first order, such that a given node is only visited if all nodes of lesser depth have already been visited, as well as all preceding nodes of the same depth. The specified function is passed the current descendant, the zero-based traversal index, and this node. If that is specified, it is the this context of the callback.node.eachAfter(function, that) ​Examples · Source · Invokes the specified function for node and each descendant in post-order traversal, such that a given node is only visited after all of its descendants have already been visited. The specified function is passed the current descendant, the zero-based traversal index, and this node. If that is specified, it is the this context of the callback.node.eachBefore(function, that) ​Examples · Source · Invokes the specified function for node and each descendant in pre-order traversal, such that a given node is only visited after all of its ancestors have already been visited. The specified function is passed the current descendant, the zero-based traversal index, and this node. If that is specified, it is the this context of the callback.node.copy() ​Source · Return a deep copy of the subtree starting at this node. (The returned deep copy shares the same data, however.) The returned node is the root of a new tree; the returned node’s parent is always null and its depth is always zero.PagerPrevious paged3-hierarchyNext pageStratify\n\nHierarchies ​Before you can compute a hierarchical layout, you need a root node. If your data is already in a hierarchical format, such as JSON, you can pass it directly to hierarchy; otherwise, you can rearrange tabular data, such as comma-separated values (CSV), into a hierarchy using stratify.hierarchy(data, children) ​Examples · Source · Constructs a root node from the specified hierarchical data. The specified data must be an object representing the root node. For example:jsconst data = {
  name: "Eve",
  children: [
    {name: "Cain"},
    {name: "Seth", children: [{name: "Enos"}, {name: "Noam"}]},
    {name: "Abel"},
    {name: "Awan", children: [{name: "Enoch"}]},
    {name: "Azura"}
  ]
};To construct a hierarchy:jsconst root = d3.hierarchy(data);The specified children accessor function is invoked for each datum, starting with the root data, and must return an iterable of data representing the children, if any. If the children accessor is not specified, it defaults to:jsfunction children(d) {
  return d.children;
}If data is a Map, it is implicitly converted to the entry [undefined, data], and the children accessor instead defaults to:jsfunction children(d) {
  return Array.isArray(d) ? d[1] : null;
}This allows you to pass the result of group or rollup to hierarchy.The returned root node and each descendant has the following properties:node.data - the associated data as passed to hierarchynode.depth - zero for the root, increasing by one for each descendant generationnode.height - the greatest distance from any descendant leaf, or zero for leavesnode.parent - the parent node, or null for the root nodenode.children - an array of child nodes, if any, or undefined for leavesnode.value - the optional summed value of the node and its descendantsThis method can also be used to test if a node is an instanceof d3.hierarchy and to extend the node prototype.node.ancestors() ​Source · Returns the array of ancestors nodes, starting with this node, then followed by each parent up to the root.node.descendants() ​Source · Returns the array of descendant nodes, starting with this node, then followed by each child in topological order.node.leaves() ​Source · Returns the array of leaf nodes in traversal order. A leaf is a node with no children.node.find(filter) ​Source · Returns the first node in the hierarchy from this node for which the specified filter returns a truthy value. Returns undefined if no such node is found.node.path(target) ​Source · Returns the shortest path through the hierarchy from this node to the specified target node. The path starts at this node, ascends to the least common ancestor of this node and the target node, and then descends to the target node. This is useful for hierarchical edge bundling.node.links() ​Source · Returns an array of links for this node and its descendants, where each link is an object that defines source and target properties. The source of each link is the parent node, and the target is a child node.node.sum(value) ​Examples · Source · Evaluates the specified value function for this node and each descendant in post-order traversal, and returns this node. The node.value property of each node is set to the numeric value returned by the specified function plus the combined value of all children. The function is passed the node’s data, and must return a non-negative number. The value accessor is evaluated for node and every descendant, including internal nodes; if you only want leaf nodes to have internal value, then return zero for any node with children. For example, as an alternative to node.count:jsroot.sum((d) => d.value ? 1 : 0);You must call node.sum or node.count before invoking a hierarchical layout that requires node.value, such as treemap. For example:js// Construct the treemap layout.
const treemap = d3.treemap();
treemap.size([width, height]);
treemap.padding(2);

// Sum and sort the data.
root.sum((d) => d.value);
root.sort((a, b) => b.height - a.height || b.value - a.value);

// Compute the treemap layout.
treemap(root);

// Retrieve all descendant nodes.
const nodes = root.descendants();Since the API supports method chaining, you can also say:jsd3.treemap()
    .size([width, height])
    .padding(2)
  (root
      .sum((d) => d.value)
      .sort((a, b) => b.height - a.height || b.value - a.value))
  .descendants()This example assumes that the node data has a value field.node.count() ​Examples · Source · Computes the number of leaves under this node and assigns it to node.value, and similarly for every descendant of node. If this node is a leaf, its count is one. Returns this node. See also node.sum.node.sort(compare) ​Examples · Source · Sorts the children of this node, if any, and each of this node’s descendants’ children, in pre-order traversal using the specified compare function, and returns this node.The specified function is passed two nodes a and b to compare. If a should be before b, the function must return a value less than zero; if b should be before a, the function must return a value greater than zero; otherwise, the relative order of a and b are not specified. See array.sort for more.Unlike node.sum, the compare function is passed two nodes rather than two nodes’ data. For example, if the data has a value property, this sorts nodes by the descending aggregate value of the node and all its descendants, as is recommended for circle-packing:jsroot
    .sum((d) => d.value)
    .sort((a, b) => b.value - a.value);Similarly, to sort nodes by descending height (greatest distance from any descendant leaf) and then descending value, as is recommended for treemaps and icicles:jsroot
    .sum((d) => d.value)
    .sort((a, b) => b.height - a.height || b.value - a.value);To sort nodes by descending height and then ascending id, as is recommended for trees and dendrograms:jsroot
    .sum((d) => d.value)
    .sort((a, b) => b.height - a.height || d3.ascending(a.id, b.id));You must call node.sort before invoking a hierarchical layout if you want the new sort order to affect the layout; see node.sum for an example.node[Symbol.iterator]() ​Source · Returns an iterator over the node’s descendants in breadth-first order. For example:jsfor (const descendant of node) {
  console.log(descendant);
}node.each(function, that) ​Examples · Source · Invokes the specified function for node and each descendant in breadth-first order, such that a given node is only visited if all nodes of lesser depth have already been visited, as well as all preceding nodes of the same depth. The specified function is passed the current descendant, the zero-based traversal index, and this node. If that is specified, it is the this context of the callback.node.eachAfter(function, that) ​Examples · Source · Invokes the specified function for node and each descendant in post-order traversal, such that a given node is only visited after all of its descendants have already been visited. The specified function is passed the current descendant, the zero-based traversal index, and this node. If that is specified, it is the this context of the callback.node.eachBefore(function, that) ​Examples · Source · Invokes the specified function for node and each descendant in pre-order traversal, such that a given node is only visited after all of its ancestors have already been visited. The specified function is passed the current descendant, the zero-based traversal index, and this node. If that is specified, it is the this context of the callback.node.copy() ​Source · Return a deep copy of the subtree starting at this node. (The returned deep copy shares the same data, however.) The returned node is the root of a new tree; the returned node’s parent is always null and its depth is always zero.\n\n\n\nStratify ​Examples · Consider the following table of relationships:NameParentEveCainEveSethEveEnosSethNoamSethAbelEveAwanEveEnochAwanAzuraEveThese names are conveniently unique, so we can unambiguously represent the hierarchy as a CSV file:name,parent
Eve,
Cain,Eve
Seth,Eve
Enos,Seth
Noam,Seth
Abel,Eve
Awan,Eve
Enoch,Awan
Azura,EveTo parse the CSV using csvParse:jsconst table = d3.csvParse(text);This returns an array of {name, parent} objects:json[
  {"name": "Eve",   "parent": ""},
  {"name": "Cain",  "parent": "Eve"},
  {"name": "Seth",  "parent": "Eve"},
  {"name": "Enos",  "parent": "Seth"},
  {"name": "Noam",  "parent": "Seth"},
  {"name": "Abel",  "parent": "Eve"},
  {"name": "Awan",  "parent": "Eve"},
  {"name": "Enoch", "parent": "Awan"},
  {"name": "Azura", "parent": "Eve"}
]To convert to a hierarchy:jsconst root = d3.stratify()
    .id((d) => d.name)
    .parentId((d) => d.parent)
  (table);This hierarchy can now be passed to a hierarchical layout, such as tree, for visualization.The stratify operator also works with delimited paths as is common in file systems.stratify() ​Source · Constructs a new stratify operator with the default settings.jsconst stratify = d3.stratify();stratify(data) ​Source · Generates a new hierarchy from the specified tabular data.jsconst root = stratify(data);stratify.id(id) ​Source · If id is specified, sets the id accessor to the given function and returns this stratify operator. Otherwise, returns the current id accessor, which defaults to:jsfunction id(d) {
  return d.id;
}The id accessor is invoked for each element in the input data passed to the stratify operator, being passed the current datum (d) and the current index (i). The returned string is then used to identify the node’s relationships in conjunction with the parent id. For leaf nodes, the id may be undefined; otherwise, the id must be unique. (Null and the empty string are equivalent to undefined.)stratify.parentId(parentId) ​Source · If parentId is specified, sets the parent id accessor to the given function and returns this stratify operator. Otherwise, returns the current parent id accessor, which defaults to:jsfunction parentId(d) {
  return d.parentId;
}The parent id accessor is invoked for each element in the input data passed to the stratify operator, being passed the current datum (d) and the current index (i). The returned string is then used to identify the node’s relationships in conjunction with the id. For the root node, the parent id should be undefined. (Null and the empty string are equivalent to undefined.) There must be exactly one root node in the input data, and no circular relationships.stratify.path(path) ​Source · If path is specified, sets the path accessor to the given function and returns this stratify operator. Otherwise, returns the current path accessor, which defaults to undefined.If a path accessor is set, the id and parentId accessors are ignored, and a unix-like hierarchy is computed on the slash-delimited strings returned by the path accessor, imputing parent nodes and ids as necessary.For example, given the output of the UNIX find command in the local directory:jsconst paths = [
  "axes.js",
  "channel.js",
  "context.js",
  "legends.js",
  "legends/ramp.js",
  "marks/density.js",
  "marks/dot.js",
  "marks/frame.js",
  "scales/diverging.js",
  "scales/index.js",
  "scales/ordinal.js",
  "stats.js",
  "style.js",
  "transforms/basic.js",
  "transforms/bin.js",
  "transforms/centroid.js",
  "warnings.js",
];You can say:jsconst root = d3.stratify().path((d) => d)(paths);\n\nSearchK7.9.0GitHub️ 110.0kOn this pageStratify ​Examples · Consider the following table of relationships:NameParentEveCainEveSethEveEnosSethNoamSethAbelEveAwanEveEnochAwanAzuraEveThese names are conveniently unique, so we can unambiguously represent the hierarchy as a CSV file:name,parent
Eve,
Cain,Eve
Seth,Eve
Enos,Seth
Noam,Seth
Abel,Eve
Awan,Eve
Enoch,Awan
Azura,EveTo parse the CSV using csvParse:jsconst table = d3.csvParse(text);This returns an array of {name, parent} objects:json[
  {"name": "Eve",   "parent": ""},
  {"name": "Cain",  "parent": "Eve"},
  {"name": "Seth",  "parent": "Eve"},
  {"name": "Enos",  "parent": "Seth"},
  {"name": "Noam",  "parent": "Seth"},
  {"name": "Abel",  "parent": "Eve"},
  {"name": "Awan",  "parent": "Eve"},
  {"name": "Enoch", "parent": "Awan"},
  {"name": "Azura", "parent": "Eve"}
]To convert to a hierarchy:jsconst root = d3.stratify()
    .id((d) => d.name)
    .parentId((d) => d.parent)
  (table);This hierarchy can now be passed to a hierarchical layout, such as tree, for visualization.The stratify operator also works with delimited paths as is common in file systems.stratify() ​Source · Constructs a new stratify operator with the default settings.jsconst stratify = d3.stratify();stratify(data) ​Source · Generates a new hierarchy from the specified tabular data.jsconst root = stratify(data);stratify.id(id) ​Source · If id is specified, sets the id accessor to the given function and returns this stratify operator. Otherwise, returns the current id accessor, which defaults to:jsfunction id(d) {
  return d.id;
}The id accessor is invoked for each element in the input data passed to the stratify operator, being passed the current datum (d) and the current index (i). The returned string is then used to identify the node’s relationships in conjunction with the parent id. For leaf nodes, the id may be undefined; otherwise, the id must be unique. (Null and the empty string are equivalent to undefined.)stratify.parentId(parentId) ​Source · If parentId is specified, sets the parent id accessor to the given function and returns this stratify operator. Otherwise, returns the current parent id accessor, which defaults to:jsfunction parentId(d) {
  return d.parentId;
}The parent id accessor is invoked for each element in the input data passed to the stratify operator, being passed the current datum (d) and the current index (i). The returned string is then used to identify the node’s relationships in conjunction with the id. For the root node, the parent id should be undefined. (Null and the empty string are equivalent to undefined.) There must be exactly one root node in the input data, and no circular relationships.stratify.path(path) ​Source · If path is specified, sets the path accessor to the given function and returns this stratify operator. Otherwise, returns the current path accessor, which defaults to undefined.If a path accessor is set, the id and parentId accessors are ignored, and a unix-like hierarchy is computed on the slash-delimited strings returned by the path accessor, imputing parent nodes and ids as necessary.For example, given the output of the UNIX find command in the local directory:jsconst paths = [
  "axes.js",
  "channel.js",
  "context.js",
  "legends.js",
  "legends/ramp.js",
  "marks/density.js",
  "marks/dot.js",
  "marks/frame.js",
  "scales/diverging.js",
  "scales/index.js",
  "scales/ordinal.js",
  "stats.js",
  "style.js",
  "transforms/basic.js",
  "transforms/bin.js",
  "transforms/centroid.js",
  "warnings.js",
];You can say:jsconst root = d3.stratify().path((d) => d)(paths);PagerPrevious pageHierarchiesNext pageTree\n\nStratify ​Examples · Consider the following table of relationships:NameParentEveCainEveSethEveEnosSethNoamSethAbelEveAwanEveEnochAwanAzuraEveThese names are conveniently unique, so we can unambiguously represent the hierarchy as a CSV file:name,parent
Eve,
Cain,Eve
Seth,Eve
Enos,Seth
Noam,Seth
Abel,Eve
Awan,Eve
Enoch,Awan
Azura,EveTo parse the CSV using csvParse:jsconst table = d3.csvParse(text);This returns an array of {name, parent} objects:json[
  {"name": "Eve",   "parent": ""},
  {"name": "Cain",  "parent": "Eve"},
  {"name": "Seth",  "parent": "Eve"},
  {"name": "Enos",  "parent": "Seth"},
  {"name": "Noam",  "parent": "Seth"},
  {"name": "Abel",  "parent": "Eve"},
  {"name": "Awan",  "parent": "Eve"},
  {"name": "Enoch", "parent": "Awan"},
  {"name": "Azura", "parent": "Eve"}
]To convert to a hierarchy:jsconst root = d3.stratify()
    .id((d) => d.name)
    .parentId((d) => d.parent)
  (table);This hierarchy can now be passed to a hierarchical layout, such as tree, for visualization.The stratify operator also works with delimited paths as is common in file systems.stratify() ​Source · Constructs a new stratify operator with the default settings.jsconst stratify = d3.stratify();stratify(data) ​Source · Generates a new hierarchy from the specified tabular data.jsconst root = stratify(data);stratify.id(id) ​Source · If id is specified, sets the id accessor to the given function and returns this stratify operator. Otherwise, returns the current id accessor, which defaults to:jsfunction id(d) {
  return d.id;
}The id accessor is invoked for each element in the input data passed to the stratify operator, being passed the current datum (d) and the current index (i). The returned string is then used to identify the node’s relationships in conjunction with the parent id. For leaf nodes, the id may be undefined; otherwise, the id must be unique. (Null and the empty string are equivalent to undefined.)stratify.parentId(parentId) ​Source · If parentId is specified, sets the parent id accessor to the given function and returns this stratify operator. Otherwise, returns the current parent id accessor, which defaults to:jsfunction parentId(d) {
  return d.parentId;
}The parent id accessor is invoked for each element in the input data passed to the stratify operator, being passed the current datum (d) and the current index (i). The returned string is then used to identify the node’s relationships in conjunction with the id. For the root node, the parent id should be undefined. (Null and the empty string are equivalent to undefined.) There must be exactly one root node in the input data, and no circular relationships.stratify.path(path) ​Source · If path is specified, sets the path accessor to the given function and returns this stratify operator. Otherwise, returns the current path accessor, which defaults to undefined.If a path accessor is set, the id and parentId accessors are ignored, and a unix-like hierarchy is computed on the slash-delimited strings returned by the path accessor, imputing parent nodes and ids as necessary.For example, given the output of the UNIX find command in the local directory:jsconst paths = [
  "axes.js",
  "channel.js",
  "context.js",
  "legends.js",
  "legends/ramp.js",
  "marks/density.js",
  "marks/dot.js",
  "marks/frame.js",
  "scales/diverging.js",
  "scales/index.js",
  "scales/ordinal.js",
  "stats.js",
  "style.js",
  "transforms/basic.js",
  "transforms/bin.js",
  "transforms/centroid.js",
  "warnings.js",
];You can say:jsconst root = d3.stratify().path((d) => d)(paths);\n\n\n\nTree ​Examples · The tree layout produces tidy node-link diagrams of trees using the Reingold–Tilford “tidy” algorithm, improved to run in linear time by Buchheim et al. Tidy trees are typically more compact than dendrograms.tree() ​Source · Creates a new tree layout with default settings.tree(root) ​Source · Lays out the specified root hierarchy, assigning the following properties on root and its descendants:node.x - the x-coordinate of the nodenode.y - the y coordinate of the nodeThe coordinates x and y represent an arbitrary coordinate system; for example, you can treat x as an angle and y as a radius to produce a radial layout. You may want to call root.sort before passing the hierarchy to the tree layout.tree.size(size) ​Source · If size is specified, sets this tree layout’s size to the specified two-element array of numbers [width, height] and returns this tree layout. If size is not specified, returns the current layout size, which defaults to [1, 1]. A layout size of null indicates that a node size will be used instead. The coordinates x and y represent an arbitrary coordinate system; for example, to produce a radial layout, a size of [360, radius] corresponds to a breadth of 360° and a depth of radius.tree.nodeSize(size) ​Source · If size is specified, sets this tree layout’s node size to the specified two-element array of numbers [width, height] and returns this tree layout. If size is not specified, returns the current node size, which defaults to null. A node size of null indicates that a layout size will be used instead. When a node size is specified, the root node is always positioned at ⟨0, 0⟩.tree.separation(separation) ​Source · If separation is specified, sets the separation accessor to the specified function and returns this tree layout. If separation is not specified, returns the current separation accessor, which defaults to:jsfunction separation(a, b) {
  return a.parent == b.parent ? 1 : 2;
}A variation that is more appropriate for radial layouts reduces the separation gap proportionally to the radius:jsfunction separation(a, b) {
  return (a.parent == b.parent ? 1 : 2) / a.depth;
}The separation accessor is used to separate neighboring nodes. The separation function is passed two nodes a and b, and must return the desired separation. The nodes are typically siblings, though the nodes may be more distantly related if the layout decides to place such nodes adjacent.\n\nSearchK7.9.0GitHub️ 110.0kOn this pageTree ​Examples · The tree layout produces tidy node-link diagrams of trees using the Reingold–Tilford “tidy” algorithm, improved to run in linear time by Buchheim et al. Tidy trees are typically more compact than dendrograms.tree() ​Source · Creates a new tree layout with default settings.tree(root) ​Source · Lays out the specified root hierarchy, assigning the following properties on root and its descendants:node.x - the x-coordinate of the nodenode.y - the y coordinate of the nodeThe coordinates x and y represent an arbitrary coordinate system; for example, you can treat x as an angle and y as a radius to produce a radial layout. You may want to call root.sort before passing the hierarchy to the tree layout.tree.size(size) ​Source · If size is specified, sets this tree layout’s size to the specified two-element array of numbers [width, height] and returns this tree layout. If size is not specified, returns the current layout size, which defaults to [1, 1]. A layout size of null indicates that a node size will be used instead. The coordinates x and y represent an arbitrary coordinate system; for example, to produce a radial layout, a size of [360, radius] corresponds to a breadth of 360° and a depth of radius.tree.nodeSize(size) ​Source · If size is specified, sets this tree layout’s node size to the specified two-element array of numbers [width, height] and returns this tree layout. If size is not specified, returns the current node size, which defaults to null. A node size of null indicates that a layout size will be used instead. When a node size is specified, the root node is always positioned at ⟨0, 0⟩.tree.separation(separation) ​Source · If separation is specified, sets the separation accessor to the specified function and returns this tree layout. If separation is not specified, returns the current separation accessor, which defaults to:jsfunction separation(a, b) {
  return a.parent == b.parent ? 1 : 2;
}A variation that is more appropriate for radial layouts reduces the separation gap proportionally to the radius:jsfunction separation(a, b) {
  return (a.parent == b.parent ? 1 : 2) / a.depth;
}The separation accessor is used to separate neighboring nodes. The separation function is passed two nodes a and b, and must return the desired separation. The nodes are typically siblings, though the nodes may be more distantly related if the layout decides to place such nodes adjacent.PagerPrevious pageStratifyNext pageCluster\n\nTree ​Examples · The tree layout produces tidy node-link diagrams of trees using the Reingold–Tilford “tidy” algorithm, improved to run in linear time by Buchheim et al. Tidy trees are typically more compact than dendrograms.tree() ​Source · Creates a new tree layout with default settings.tree(root) ​Source · Lays out the specified root hierarchy, assigning the following properties on root and its descendants:node.x - the x-coordinate of the nodenode.y - the y coordinate of the nodeThe coordinates x and y represent an arbitrary coordinate system; for example, you can treat x as an angle and y as a radius to produce a radial layout. You may want to call root.sort before passing the hierarchy to the tree layout.tree.size(size) ​Source · If size is specified, sets this tree layout’s size to the specified two-element array of numbers [width, height] and returns this tree layout. If size is not specified, returns the current layout size, which defaults to [1, 1]. A layout size of null indicates that a node size will be used instead. The coordinates x and y represent an arbitrary coordinate system; for example, to produce a radial layout, a size of [360, radius] corresponds to a breadth of 360° and a depth of radius.tree.nodeSize(size) ​Source · If size is specified, sets this tree layout’s node size to the specified two-element array of numbers [width, height] and returns this tree layout. If size is not specified, returns the current node size, which defaults to null. A node size of null indicates that a layout size will be used instead. When a node size is specified, the root node is always positioned at ⟨0, 0⟩.tree.separation(separation) ​Source · If separation is specified, sets the separation accessor to the specified function and returns this tree layout. If separation is not specified, returns the current separation accessor, which defaults to:jsfunction separation(a, b) {
  return a.parent == b.parent ? 1 : 2;
}A variation that is more appropriate for radial layouts reduces the separation gap proportionally to the radius:jsfunction separation(a, b) {
  return (a.parent == b.parent ? 1 : 2) / a.depth;
}The separation accessor is used to separate neighboring nodes. The separation function is passed two nodes a and b, and must return the desired separation. The nodes are typically siblings, though the nodes may be more distantly related if the layout decides to place such nodes adjacent.\n\n\n\nCluster ​Examples · The cluster layout produces dendrograms: node-link diagrams that place leaf nodes of the tree at the same depth. Dendrograms are typically less compact than tidy trees, but are useful when all the leaves should be at the same level, such as for hierarchical clustering or phylogenetic tree diagrams.cluster() ​Source · Creates a new cluster layout with default settings.cluster(root) ​Source · Lays out the specified root hierarchy, assigning the following properties on root and its descendants:node.x - the x-coordinate of the nodenode.y - the y coordinate of the nodeThe coordinates x and y represent an arbitrary coordinate system; for example, you can treat x as an angle and y as a radius to produce a radial layout. You may want to call root.sort before passing the hierarchy to the cluster layout.cluster.size(size) ​Source · If size is specified, sets this cluster layout’s size to the specified two-element array of numbers [width, height] and returns this cluster layout. If size is not specified, returns the current layout size, which defaults to [1, 1]. A layout size of null indicates that a node size will be used instead. The coordinates x and y represent an arbitrary coordinate system; for example, to produce a radial layout, a size of [360, radius] corresponds to a breadth of 360° and a depth of radius.cluster.nodeSize(size) ​Source · If size is specified, sets this cluster layout’s node size to the specified two-element array of numbers [width, height] and returns this cluster layout. If size is not specified, returns the current node size, which defaults to null. A node size of null indicates that a layout size will be used instead. When a node size is specified, the root node is always positioned at ⟨0, 0⟩.cluster.separation(separation) ​Source · If separation is specified, sets the separation accessor to the specified function and returns this cluster layout. If separation is not specified, returns the current separation accessor, which defaults to:jsfunction separation(a, b) {
  return a.parent == b.parent ? 1 : 2;
}The separation accessor is used to separate neighboring leaves. The separation function is passed two leaves a and b, and must return the desired separation. The nodes are typically siblings, though the nodes may be more distantly related if the layout decides to place such nodes adjacent.\n\nSearchK7.9.0GitHub️ 110.0kOn this pageCluster ​Examples · The cluster layout produces dendrograms: node-link diagrams that place leaf nodes of the tree at the same depth. Dendrograms are typically less compact than tidy trees, but are useful when all the leaves should be at the same level, such as for hierarchical clustering or phylogenetic tree diagrams.cluster() ​Source · Creates a new cluster layout with default settings.cluster(root) ​Source · Lays out the specified root hierarchy, assigning the following properties on root and its descendants:node.x - the x-coordinate of the nodenode.y - the y coordinate of the nodeThe coordinates x and y represent an arbitrary coordinate system; for example, you can treat x as an angle and y as a radius to produce a radial layout. You may want to call root.sort before passing the hierarchy to the cluster layout.cluster.size(size) ​Source · If size is specified, sets this cluster layout’s size to the specified two-element array of numbers [width, height] and returns this cluster layout. If size is not specified, returns the current layout size, which defaults to [1, 1]. A layout size of null indicates that a node size will be used instead. The coordinates x and y represent an arbitrary coordinate system; for example, to produce a radial layout, a size of [360, radius] corresponds to a breadth of 360° and a depth of radius.cluster.nodeSize(size) ​Source · If size is specified, sets this cluster layout’s node size to the specified two-element array of numbers [width, height] and returns this cluster layout. If size is not specified, returns the current node size, which defaults to null. A node size of null indicates that a layout size will be used instead. When a node size is specified, the root node is always positioned at ⟨0, 0⟩.cluster.separation(separation) ​Source · If separation is specified, sets the separation accessor to the specified function and returns this cluster layout. If separation is not specified, returns the current separation accessor, which defaults to:jsfunction separation(a, b) {
  return a.parent == b.parent ? 1 : 2;
}The separation accessor is used to separate neighboring leaves. The separation function is passed two leaves a and b, and must return the desired separation. The nodes are typically siblings, though the nodes may be more distantly related if the layout decides to place such nodes adjacent.PagerPrevious pageTreeNext pagePartition\n\nCluster ​Examples · The cluster layout produces dendrograms: node-link diagrams that place leaf nodes of the tree at the same depth. Dendrograms are typically less compact than tidy trees, but are useful when all the leaves should be at the same level, such as for hierarchical clustering or phylogenetic tree diagrams.cluster() ​Source · Creates a new cluster layout with default settings.cluster(root) ​Source · Lays out the specified root hierarchy, assigning the following properties on root and its descendants:node.x - the x-coordinate of the nodenode.y - the y coordinate of the nodeThe coordinates x and y represent an arbitrary coordinate system; for example, you can treat x as an angle and y as a radius to produce a radial layout. You may want to call root.sort before passing the hierarchy to the cluster layout.cluster.size(size) ​Source · If size is specified, sets this cluster layout’s size to the specified two-element array of numbers [width, height] and returns this cluster layout. If size is not specified, returns the current layout size, which defaults to [1, 1]. A layout size of null indicates that a node size will be used instead. The coordinates x and y represent an arbitrary coordinate system; for example, to produce a radial layout, a size of [360, radius] corresponds to a breadth of 360° and a depth of radius.cluster.nodeSize(size) ​Source · If size is specified, sets this cluster layout’s node size to the specified two-element array of numbers [width, height] and returns this cluster layout. If size is not specified, returns the current node size, which defaults to null. A node size of null indicates that a layout size will be used instead. When a node size is specified, the root node is always positioned at ⟨0, 0⟩.cluster.separation(separation) ​Source · If separation is specified, sets the separation accessor to the specified function and returns this cluster layout. If separation is not specified, returns the current separation accessor, which defaults to:jsfunction separation(a, b) {
  return a.parent == b.parent ? 1 : 2;
}The separation accessor is used to separate neighboring leaves. The separation function is passed two leaves a and b, and must return the desired separation. The nodes are typically siblings, though the nodes may be more distantly related if the layout decides to place such nodes adjacent.\n\n\n\nPartition ​Examples · The partition layout produces adjacency diagrams: a space-filling variant of a node-link tree diagram. Rather than drawing a link between parent and child in the hierarchy, nodes are drawn as solid areas (either arcs or rectangles), and their placement relative to other nodes reveals their position in the hierarchy. The size of the nodes encodes a quantitative dimension that would be difficult to show in a node-link diagram.partition() ​Source · Creates a new partition layout with the default settings.partition(root) ​Source · Lays out the specified root hierarchy, assigning the following properties on root and its descendants:node.x0 - the left edge of the rectanglenode.y0 - the top edge of the rectanglenode.x1 - the right edge of the rectanglenode.y1 - the bottom edge of the rectangleYou must call root.sum before passing the hierarchy to the partition layout. You probably also want to call root.sort to order the hierarchy before computing the layout.partition.size(size) ​Source · If size is specified, sets this partition layout’s size to the specified two-element array of numbers [width, height] and returns this partition layout. If size is not specified, returns the current size, which defaults to [1, 1].partition.round(round) ​Source · If round is specified, enables or disables rounding according to the given boolean and returns this partition layout. If round is not specified, returns the current rounding state, which defaults to false.partition.padding(padding) ​Source · If padding is specified, sets the padding to the specified number and returns this partition layout. If padding is not specified, returns the current padding, which defaults to zero. The padding is used to separate a node’s adjacent children.\n\nSearchK7.9.0GitHub️ 110.0kOn this pagePartition ​Examples · The partition layout produces adjacency diagrams: a space-filling variant of a node-link tree diagram. Rather than drawing a link between parent and child in the hierarchy, nodes are drawn as solid areas (either arcs or rectangles), and their placement relative to other nodes reveals their position in the hierarchy. The size of the nodes encodes a quantitative dimension that would be difficult to show in a node-link diagram.partition() ​Source · Creates a new partition layout with the default settings.partition(root) ​Source · Lays out the specified root hierarchy, assigning the following properties on root and its descendants:node.x0 - the left edge of the rectanglenode.y0 - the top edge of the rectanglenode.x1 - the right edge of the rectanglenode.y1 - the bottom edge of the rectangleYou must call root.sum before passing the hierarchy to the partition layout. You probably also want to call root.sort to order the hierarchy before computing the layout.partition.size(size) ​Source · If size is specified, sets this partition layout’s size to the specified two-element array of numbers [width, height] and returns this partition layout. If size is not specified, returns the current size, which defaults to [1, 1].partition.round(round) ​Source · If round is specified, enables or disables rounding according to the given boolean and returns this partition layout. If round is not specified, returns the current rounding state, which defaults to false.partition.padding(padding) ​Source · If padding is specified, sets the padding to the specified number and returns this partition layout. If padding is not specified, returns the current padding, which defaults to zero. The padding is used to separate a node’s adjacent children.PagerPrevious pageClusterNext pagePack\n\nPartition ​Examples · The partition layout produces adjacency diagrams: a space-filling variant of a node-link tree diagram. Rather than drawing a link between parent and child in the hierarchy, nodes are drawn as solid areas (either arcs or rectangles), and their placement relative to other nodes reveals their position in the hierarchy. The size of the nodes encodes a quantitative dimension that would be difficult to show in a node-link diagram.partition() ​Source · Creates a new partition layout with the default settings.partition(root) ​Source · Lays out the specified root hierarchy, assigning the following properties on root and its descendants:node.x0 - the left edge of the rectanglenode.y0 - the top edge of the rectanglenode.x1 - the right edge of the rectanglenode.y1 - the bottom edge of the rectangleYou must call root.sum before passing the hierarchy to the partition layout. You probably also want to call root.sort to order the hierarchy before computing the layout.partition.size(size) ​Source · If size is specified, sets this partition layout’s size to the specified two-element array of numbers [width, height] and returns this partition layout. If size is not specified, returns the current size, which defaults to [1, 1].partition.round(round) ​Source · If round is specified, enables or disables rounding according to the given boolean and returns this partition layout. If round is not specified, returns the current rounding state, which defaults to false.partition.padding(padding) ​Source · If padding is specified, sets the padding to the specified number and returns this partition layout. If padding is not specified, returns the current padding, which defaults to zero. The padding is used to separate a node’s adjacent children.\n\n\n\nPack ​Examples · Enclosure diagrams use containment (nesting) to represent a hierarchy. The size of the leaf circles encodes a quantitative dimension of the data. The enclosing circles show the approximate cumulative size of each subtree, but due to wasted space there is some distortion; only the leaf nodes can be compared accurately. Although circle packing does not use space as efficiently as a treemap, the “wasted” space more prominently reveals the hierarchical structure.pack() ​Source · Creates a new pack layout with the default settings.pack(root) ​Source · Lays out the specified root hierarchy, assigning the following properties on root and its descendants:node.x - the x-coordinate of the circle’s centernode.y - the y coordinate of the circle’s centernode.r - the radius of the circleYou must call root.sum before passing the hierarchy to the pack layout. You probably also want to call root.sort to order the hierarchy before computing the layout.pack.radius(radius) ​Source · If radius is specified, sets the pack layout’s radius accessor to the specified function and returns this pack layout. If radius is not specified, returns the current radius accessor, which defaults to null. If the radius accessor is null, the radius of each leaf circle is derived from the leaf node.value (computed by node.sum); the radii are then scaled proportionally to fit the layout size. If the radius accessor is not null, the radius of each leaf circle is specified exactly by the function.pack.size(size) ​Source · If size is specified, sets this pack layout’s size to the specified two-element array of numbers [width, height] and returns this pack layout. If size is not specified, returns the current size, which defaults to [1, 1].pack.padding(padding) ​Source · If padding is specified, sets this pack layout’s padding accessor to the specified number or function and returns this pack layout. If padding is not specified, returns the current padding accessor, which defaults to the constant zero. When siblings are packed, tangent siblings will be separated by approximately the specified padding; the enclosing parent circle will also be separated from its children by approximately the specified padding. If an explicit radius is not specified, the padding is approximate because a two-pass algorithm is needed to fit within the layout size: the circles are first packed without padding; a scaling factor is computed and applied to the specified padding; and lastly the circles are re-packed with padding.packSiblings(circles) ​Source · Packs the specified array of circles, each of which must have a circle.r property specifying the circle’s radius. Assigns the following properties to each circle:circle.x - the x-coordinate of the circle’s centercircle.y - the y coordinate of the circle’s centerThe circles are positioned according to the front-chain packing algorithm by Wang et al.packEnclose(circles) ​Examples · Source · Computes the smallest circle that encloses the specified array of circles, each of which must have a circle.r property specifying the circle’s radius, and circle.x and circle.y properties specifying the circle’s center. The enclosing circle is computed using the Matoušek-Sharir-Welzl algorithm. (See also Apollonius’ Problem.)\n\nSearchK7.9.0GitHub️ 110.0kOn this pagePack ​Examples · Enclosure diagrams use containment (nesting) to represent a hierarchy. The size of the leaf circles encodes a quantitative dimension of the data. The enclosing circles show the approximate cumulative size of each subtree, but due to wasted space there is some distortion; only the leaf nodes can be compared accurately. Although circle packing does not use space as efficiently as a treemap, the “wasted” space more prominently reveals the hierarchical structure.pack() ​Source · Creates a new pack layout with the default settings.pack(root) ​Source · Lays out the specified root hierarchy, assigning the following properties on root and its descendants:node.x - the x-coordinate of the circle’s centernode.y - the y coordinate of the circle’s centernode.r - the radius of the circleYou must call root.sum before passing the hierarchy to the pack layout. You probably also want to call root.sort to order the hierarchy before computing the layout.pack.radius(radius) ​Source · If radius is specified, sets the pack layout’s radius accessor to the specified function and returns this pack layout. If radius is not specified, returns the current radius accessor, which defaults to null. If the radius accessor is null, the radius of each leaf circle is derived from the leaf node.value (computed by node.sum); the radii are then scaled proportionally to fit the layout size. If the radius accessor is not null, the radius of each leaf circle is specified exactly by the function.pack.size(size) ​Source · If size is specified, sets this pack layout’s size to the specified two-element array of numbers [width, height] and returns this pack layout. If size is not specified, returns the current size, which defaults to [1, 1].pack.padding(padding) ​Source · If padding is specified, sets this pack layout’s padding accessor to the specified number or function and returns this pack layout. If padding is not specified, returns the current padding accessor, which defaults to the constant zero. When siblings are packed, tangent siblings will be separated by approximately the specified padding; the enclosing parent circle will also be separated from its children by approximately the specified padding. If an explicit radius is not specified, the padding is approximate because a two-pass algorithm is needed to fit within the layout size: the circles are first packed without padding; a scaling factor is computed and applied to the specified padding; and lastly the circles are re-packed with padding.packSiblings(circles) ​Source · Packs the specified array of circles, each of which must have a circle.r property specifying the circle’s radius. Assigns the following properties to each circle:circle.x - the x-coordinate of the circle’s centercircle.y - the y coordinate of the circle’s centerThe circles are positioned according to the front-chain packing algorithm by Wang et al.packEnclose(circles) ​Examples · Source · Computes the smallest circle that encloses the specified array of circles, each of which must have a circle.r property specifying the circle’s radius, and circle.x and circle.y properties specifying the circle’s center. The enclosing circle is computed using the Matoušek-Sharir-Welzl algorithm. (See also Apollonius’ Problem.)PagerPrevious pagePartitionNext pageTreemap\n\nPack ​Examples · Enclosure diagrams use containment (nesting) to represent a hierarchy. The size of the leaf circles encodes a quantitative dimension of the data. The enclosing circles show the approximate cumulative size of each subtree, but due to wasted space there is some distortion; only the leaf nodes can be compared accurately. Although circle packing does not use space as efficiently as a treemap, the “wasted” space more prominently reveals the hierarchical structure.pack() ​Source · Creates a new pack layout with the default settings.pack(root) ​Source · Lays out the specified root hierarchy, assigning the following properties on root and its descendants:node.x - the x-coordinate of the circle’s centernode.y - the y coordinate of the circle’s centernode.r - the radius of the circleYou must call root.sum before passing the hierarchy to the pack layout. You probably also want to call root.sort to order the hierarchy before computing the layout.pack.radius(radius) ​Source · If radius is specified, sets the pack layout’s radius accessor to the specified function and returns this pack layout. If radius is not specified, returns the current radius accessor, which defaults to null. If the radius accessor is null, the radius of each leaf circle is derived from the leaf node.value (computed by node.sum); the radii are then scaled proportionally to fit the layout size. If the radius accessor is not null, the radius of each leaf circle is specified exactly by the function.pack.size(size) ​Source · If size is specified, sets this pack layout’s size to the specified two-element array of numbers [width, height] and returns this pack layout. If size is not specified, returns the current size, which defaults to [1, 1].pack.padding(padding) ​Source · If padding is specified, sets this pack layout’s padding accessor to the specified number or function and returns this pack layout. If padding is not specified, returns the current padding accessor, which defaults to the constant zero. When siblings are packed, tangent siblings will be separated by approximately the specified padding; the enclosing parent circle will also be separated from its children by approximately the specified padding. If an explicit radius is not specified, the padding is approximate because a two-pass algorithm is needed to fit within the layout size: the circles are first packed without padding; a scaling factor is computed and applied to the specified padding; and lastly the circles are re-packed with padding.packSiblings(circles) ​Source · Packs the specified array of circles, each of which must have a circle.r property specifying the circle’s radius. Assigns the following properties to each circle:circle.x - the x-coordinate of the circle’s centercircle.y - the y coordinate of the circle’s centerThe circles are positioned according to the front-chain packing algorithm by Wang et al.packEnclose(circles) ​Examples · Source · Computes the smallest circle that encloses the specified array of circles, each of which must have a circle.r property specifying the circle’s radius, and circle.x and circle.y properties specifying the circle’s center. The enclosing circle is computed using the Matoušek-Sharir-Welzl algorithm. (See also Apollonius’ Problem.)\n\n\n\nTreemap ​Examples · Introduced by Ben Shneiderman in 1991, a treemap recursively subdivides area into rectangles according to each node’s associated value. D3’s treemap implementation supports an extensible tiling method: the default squarified method seeks to generate rectangles with a golden aspect ratio; this offers better readability and size estimation than slice-and-dice, which simply alternates between horizontal and vertical subdivision by depth.treemap() ​Source · Creates a new treemap layout with default settings.treemap(root) ​Source · Lays out the specified root hierarchy, assigning the following properties on root and its descendants:node.x0 - the left edge of the rectanglenode.y0 - the top edge of the rectanglenode.x1 - the right edge of the rectanglenode.y1 - the bottom edge of the rectangleYou must call root.sum before passing the hierarchy to the treemap layout. You probably also want to call root.sort to order the hierarchy before computing the layout.treemap.tile(tile) ​Source · If tile is specified, sets the tiling method to the specified function and returns this treemap layout. If tile is not specified, returns the current tiling method, which defaults to treemapSquarify with the golden ratio.treemap.size(size) ​Source · If size is specified, sets this treemap layout’s size to the specified two-element array of numbers [width, height] and returns this treemap layout. If size is not specified, returns the current size, which defaults to [1, 1].treemap.round(round) ​Source · If round is specified, enables or disables rounding according to the given boolean and returns this treemap layout. If round is not specified, returns the current rounding state, which defaults to false.treemap.padding(padding) ​Source · If padding is specified, sets the inner and outer padding to the specified number or function and returns this treemap layout. If padding is not specified, returns the current inner padding function.treemap.paddingInner(padding) ​Source · If padding is specified, sets the inner padding to the specified number or function and returns this treemap layout. If padding is not specified, returns the current inner padding function, which defaults to the constant zero. If padding is a function, it is invoked for each node with children, being passed the current node. The inner padding is used to separate a node’s adjacent children.treemap.paddingOuter(padding) ​Source · If padding is specified, sets the top, right, bottom and left padding to the specified number or function and returns this treemap layout. If padding is not specified, returns the current top padding function.treemap.paddingTop(padding) ​Source · If padding is specified, sets the top padding to the specified number or function and returns this treemap layout. If padding is not specified, returns the current top padding function, which defaults to the constant zero. If padding is a function, it is invoked for each node with children, being passed the current node. The top padding is used to separate the top edge of a node from its children.treemap.paddingRight(padding) ​Source · If padding is specified, sets the right padding to the specified number or function and returns this treemap layout. If padding is not specified, returns the current right padding function, which defaults to the constant zero. If padding is a function, it is invoked for each node with children, being passed the current node. The right padding is used to separate the right edge of a node from its children.treemap.paddingBottom(padding) ​Source · If padding is specified, sets the bottom padding to the specified number or function and returns this treemap layout. If padding is not specified, returns the current bottom padding function, which defaults to the constant zero. If padding is a function, it is invoked for each node with children, being passed the current node. The bottom padding is used to separate the bottom edge of a node from its children.treemap.paddingLeft(padding) ​Source · If padding is specified, sets the left padding to the specified number or function and returns this treemap layout. If padding is not specified, returns the current left padding function, which defaults to the constant zero. If padding is a function, it is invoked for each node with children, being passed the current node. The left padding is used to separate the left edge of a node from its children.Treemap tiling ​Several built-in tiling methods are provided for use with treemap.tile.treemapBinary(node, x0, y0, x1, y1) ​Source · Recursively partitions the specified nodes into an approximately-balanced binary tree, choosing horizontal partitioning for wide rectangles and vertical partitioning for tall rectangles.treemapDice(node, x0, y0, x1, y1) ​Source · Divides the rectangular area specified by x0, y0, x1, y1 horizontally according the value of each of the specified node’s children. The children are positioned in order, starting with the left edge (x0) of the given rectangle. If the sum of the children’s values is less than the specified node’s value (i.e., if the specified node has a non-zero internal value), the remaining empty space will be positioned on the right edge (x1) of the given rectangle.treemapSlice(node, x0, y0, x1, y1) ​Source · Divides the rectangular area specified by x0, y0, x1, y1 vertically according the value of each of the specified node’s children. The children are positioned in order, starting with the top edge (y0) of the given rectangle. If the sum of the children’s values is less than the specified node’s value (i.e., if the specified node has a non-zero internal value), the remaining empty space will be positioned on the bottom edge (y1) of the given rectangle.treemapSliceDice(node, x0, y0, x1, y1) ​Source · If the specified node has odd depth, delegates to treemapSlice; otherwise delegates to treemapDice.treemapSquarify(node, x0, y0, x1, y1) ​Source · Implements the squarified treemap algorithm by Bruls et al., which seeks to produce rectangles of a given aspect ratio.treemapResquarify(node, x0, y0, x1, y1) ​Examples · Source · Like treemapSquarify, except preserves the topology (node adjacencies) of the previous layout computed by d3.treemapResquarify, if there is one and it used the same target aspect ratio. This tiling method is good for animating changes to treemaps because it only changes node sizes and not their relative positions, thus avoiding distracting shuffling and occlusion. The downside of a stable update, however, is a suboptimal layout for subsequent updates: only the first layout uses the Bruls et al. squarified algorithm.squarify.ratio(ratio) ​Source · Specifies the desired aspect ratio of the generated rectangles. The ratio must be specified as a number greater than or equal to one. Note that the orientation of the generated rectangles (tall or wide) is not implied by the ratio; for example, a ratio of two will attempt to produce a mixture of rectangles whose width:height ratio is either 2:1 or 1:2. (However, you can approximately achieve this result by generating a square treemap at different dimensions, and then stretching the treemap to the desired aspect ratio.) Furthermore, the specified ratio is merely a hint to the tiling algorithm; the rectangles are not guaranteed to have the specified aspect ratio. If not specified, the aspect ratio defaults to the golden ratio, φ = (1 + sqrt(5)) / 2, per Kong et al.\n\nSearchK7.9.0GitHub️ 110.0kOn this pageTreemap ​Examples · Introduced by Ben Shneiderman in 1991, a treemap recursively subdivides area into rectangles according to each node’s associated value. D3’s treemap implementation supports an extensible tiling method: the default squarified method seeks to generate rectangles with a golden aspect ratio; this offers better readability and size estimation than slice-and-dice, which simply alternates between horizontal and vertical subdivision by depth.treemap() ​Source · Creates a new treemap layout with default settings.treemap(root) ​Source · Lays out the specified root hierarchy, assigning the following properties on root and its descendants:node.x0 - the left edge of the rectanglenode.y0 - the top edge of the rectanglenode.x1 - the right edge of the rectanglenode.y1 - the bottom edge of the rectangleYou must call root.sum before passing the hierarchy to the treemap layout. You probably also want to call root.sort to order the hierarchy before computing the layout.treemap.tile(tile) ​Source · If tile is specified, sets the tiling method to the specified function and returns this treemap layout. If tile is not specified, returns the current tiling method, which defaults to treemapSquarify with the golden ratio.treemap.size(size) ​Source · If size is specified, sets this treemap layout’s size to the specified two-element array of numbers [width, height] and returns this treemap layout. If size is not specified, returns the current size, which defaults to [1, 1].treemap.round(round) ​Source · If round is specified, enables or disables rounding according to the given boolean and returns this treemap layout. If round is not specified, returns the current rounding state, which defaults to false.treemap.padding(padding) ​Source · If padding is specified, sets the inner and outer padding to the specified number or function and returns this treemap layout. If padding is not specified, returns the current inner padding function.treemap.paddingInner(padding) ​Source · If padding is specified, sets the inner padding to the specified number or function and returns this treemap layout. If padding is not specified, returns the current inner padding function, which defaults to the constant zero. If padding is a function, it is invoked for each node with children, being passed the current node. The inner padding is used to separate a node’s adjacent children.treemap.paddingOuter(padding) ​Source · If padding is specified, sets the top, right, bottom and left padding to the specified number or function and returns this treemap layout. If padding is not specified, returns the current top padding function.treemap.paddingTop(padding) ​Source · If padding is specified, sets the top padding to the specified number or function and returns this treemap layout. If padding is not specified, returns the current top padding function, which defaults to the constant zero. If padding is a function, it is invoked for each node with children, being passed the current node. The top padding is used to separate the top edge of a node from its children.treemap.paddingRight(padding) ​Source · If padding is specified, sets the right padding to the specified number or function and returns this treemap layout. If padding is not specified, returns the current right padding function, which defaults to the constant zero. If padding is a function, it is invoked for each node with children, being passed the current node. The right padding is used to separate the right edge of a node from its children.treemap.paddingBottom(padding) ​Source · If padding is specified, sets the bottom padding to the specified number or function and returns this treemap layout. If padding is not specified, returns the current bottom padding function, which defaults to the constant zero. If padding is a function, it is invoked for each node with children, being passed the current node. The bottom padding is used to separate the bottom edge of a node from its children.treemap.paddingLeft(padding) ​Source · If padding is specified, sets the left padding to the specified number or function and returns this treemap layout. If padding is not specified, returns the current left padding function, which defaults to the constant zero. If padding is a function, it is invoked for each node with children, being passed the current node. The left padding is used to separate the left edge of a node from its children.Treemap tiling ​Several built-in tiling methods are provided for use with treemap.tile.treemapBinary(node, x0, y0, x1, y1) ​Source · Recursively partitions the specified nodes into an approximately-balanced binary tree, choosing horizontal partitioning for wide rectangles and vertical partitioning for tall rectangles.treemapDice(node, x0, y0, x1, y1) ​Source · Divides the rectangular area specified by x0, y0, x1, y1 horizontally according the value of each of the specified node’s children. The children are positioned in order, starting with the left edge (x0) of the given rectangle. If the sum of the children’s values is less than the specified node’s value (i.e., if the specified node has a non-zero internal value), the remaining empty space will be positioned on the right edge (x1) of the given rectangle.treemapSlice(node, x0, y0, x1, y1) ​Source · Divides the rectangular area specified by x0, y0, x1, y1 vertically according the value of each of the specified node’s children. The children are positioned in order, starting with the top edge (y0) of the given rectangle. If the sum of the children’s values is less than the specified node’s value (i.e., if the specified node has a non-zero internal value), the remaining empty space will be positioned on the bottom edge (y1) of the given rectangle.treemapSliceDice(node, x0, y0, x1, y1) ​Source · If the specified node has odd depth, delegates to treemapSlice; otherwise delegates to treemapDice.treemapSquarify(node, x0, y0, x1, y1) ​Source · Implements the squarified treemap algorithm by Bruls et al., which seeks to produce rectangles of a given aspect ratio.treemapResquarify(node, x0, y0, x1, y1) ​Examples · Source · Like treemapSquarify, except preserves the topology (node adjacencies) of the previous layout computed by d3.treemapResquarify, if there is one and it used the same target aspect ratio. This tiling method is good for animating changes to treemaps because it only changes node sizes and not their relative positions, thus avoiding distracting shuffling and occlusion. The downside of a stable update, however, is a suboptimal layout for subsequent updates: only the first layout uses the Bruls et al. squarified algorithm.squarify.ratio(ratio) ​Source · Specifies the desired aspect ratio of the generated rectangles. The ratio must be specified as a number greater than or equal to one. Note that the orientation of the generated rectangles (tall or wide) is not implied by the ratio; for example, a ratio of two will attempt to produce a mixture of rectangles whose width:height ratio is either 2:1 or 1:2. (However, you can approximately achieve this result by generating a square treemap at different dimensions, and then stretching the treemap to the desired aspect ratio.) Furthermore, the specified ratio is merely a hint to the tiling algorithm; the rectangles are not guaranteed to have the specified aspect ratio. If not specified, the aspect ratio defaults to the golden ratio, φ = (1 + sqrt(5)) / 2, per Kong et al.PagerPrevious pagePackNext paged3-path\n\nTreemap ​Examples · Introduced by Ben Shneiderman in 1991, a treemap recursively subdivides area into rectangles according to each node’s associated value. D3’s treemap implementation supports an extensible tiling method: the default squarified method seeks to generate rectangles with a golden aspect ratio; this offers better readability and size estimation than slice-and-dice, which simply alternates between horizontal and vertical subdivision by depth.treemap() ​Source · Creates a new treemap layout with default settings.treemap(root) ​Source · Lays out the specified root hierarchy, assigning the following properties on root and its descendants:node.x0 - the left edge of the rectanglenode.y0 - the top edge of the rectanglenode.x1 - the right edge of the rectanglenode.y1 - the bottom edge of the rectangleYou must call root.sum before passing the hierarchy to the treemap layout. You probably also want to call root.sort to order the hierarchy before computing the layout.treemap.tile(tile) ​Source · If tile is specified, sets the tiling method to the specified function and returns this treemap layout. If tile is not specified, returns the current tiling method, which defaults to treemapSquarify with the golden ratio.treemap.size(size) ​Source · If size is specified, sets this treemap layout’s size to the specified two-element array of numbers [width, height] and returns this treemap layout. If size is not specified, returns the current size, which defaults to [1, 1].treemap.round(round) ​Source · If round is specified, enables or disables rounding according to the given boolean and returns this treemap layout. If round is not specified, returns the current rounding state, which defaults to false.treemap.padding(padding) ​Source · If padding is specified, sets the inner and outer padding to the specified number or function and returns this treemap layout. If padding is not specified, returns the current inner padding function.treemap.paddingInner(padding) ​Source · If padding is specified, sets the inner padding to the specified number or function and returns this treemap layout. If padding is not specified, returns the current inner padding function, which defaults to the constant zero. If padding is a function, it is invoked for each node with children, being passed the current node. The inner padding is used to separate a node’s adjacent children.treemap.paddingOuter(padding) ​Source · If padding is specified, sets the top, right, bottom and left padding to the specified number or function and returns this treemap layout. If padding is not specified, returns the current top padding function.treemap.paddingTop(padding) ​Source · If padding is specified, sets the top padding to the specified number or function and returns this treemap layout. If padding is not specified, returns the current top padding function, which defaults to the constant zero. If padding is a function, it is invoked for each node with children, being passed the current node. The top padding is used to separate the top edge of a node from its children.treemap.paddingRight(padding) ​Source · If padding is specified, sets the right padding to the specified number or function and returns this treemap layout. If padding is not specified, returns the current right padding function, which defaults to the constant zero. If padding is a function, it is invoked for each node with children, being passed the current node. The right padding is used to separate the right edge of a node from its children.treemap.paddingBottom(padding) ​Source · If padding is specified, sets the bottom padding to the specified number or function and returns this treemap layout. If padding is not specified, returns the current bottom padding function, which defaults to the constant zero. If padding is a function, it is invoked for each node with children, being passed the current node. The bottom padding is used to separate the bottom edge of a node from its children.treemap.paddingLeft(padding) ​Source · If padding is specified, sets the left padding to the specified number or function and returns this treemap layout. If padding is not specified, returns the current left padding function, which defaults to the constant zero. If padding is a function, it is invoked for each node with children, being passed the current node. The left padding is used to separate the left edge of a node from its children.Treemap tiling ​Several built-in tiling methods are provided for use with treemap.tile.treemapBinary(node, x0, y0, x1, y1) ​Source · Recursively partitions the specified nodes into an approximately-balanced binary tree, choosing horizontal partitioning for wide rectangles and vertical partitioning for tall rectangles.treemapDice(node, x0, y0, x1, y1) ​Source · Divides the rectangular area specified by x0, y0, x1, y1 horizontally according the value of each of the specified node’s children. The children are positioned in order, starting with the left edge (x0) of the given rectangle. If the sum of the children’s values is less than the specified node’s value (i.e., if the specified node has a non-zero internal value), the remaining empty space will be positioned on the right edge (x1) of the given rectangle.treemapSlice(node, x0, y0, x1, y1) ​Source · Divides the rectangular area specified by x0, y0, x1, y1 vertically according the value of each of the specified node’s children. The children are positioned in order, starting with the top edge (y0) of the given rectangle. If the sum of the children’s values is less than the specified node’s value (i.e., if the specified node has a non-zero internal value), the remaining empty space will be positioned on the bottom edge (y1) of the given rectangle.treemapSliceDice(node, x0, y0, x1, y1) ​Source · If the specified node has odd depth, delegates to treemapSlice; otherwise delegates to treemapDice.treemapSquarify(node, x0, y0, x1, y1) ​Source · Implements the squarified treemap algorithm by Bruls et al., which seeks to produce rectangles of a given aspect ratio.treemapResquarify(node, x0, y0, x1, y1) ​Examples · Source · Like treemapSquarify, except preserves the topology (node adjacencies) of the previous layout computed by d3.treemapResquarify, if there is one and it used the same target aspect ratio. This tiling method is good for animating changes to treemaps because it only changes node sizes and not their relative positions, thus avoiding distracting shuffling and occlusion. The downside of a stable update, however, is a suboptimal layout for subsequent updates: only the first layout uses the Bruls et al. squarified algorithm.squarify.ratio(ratio) ​Source · Specifies the desired aspect ratio of the generated rectangles. The ratio must be specified as a number greater than or equal to one. Note that the orientation of the generated rectangles (tall or wide) is not implied by the ratio; for example, a ratio of two will attempt to produce a mixture of rectangles whose width:height ratio is either 2:1 or 1:2. (However, you can approximately achieve this result by generating a square treemap at different dimensions, and then stretching the treemap to the desired aspect ratio.) Furthermore, the specified ratio is merely a hint to the tiling algorithm; the rectangles are not guaranteed to have the specified aspect ratio. If not specified, the aspect ratio defaults to the golden ratio, φ = (1 + sqrt(5)) / 2, per Kong et al.\n\n\n\nd3-path ​Examples · Say you have some code that draws to a 2D canvas:jsfunction drawCircle(context, radius) {
  context.moveTo(radius, 0);
  context.arc(0, 0, radius, 0, 2 * Math.PI);
}The d3-path module lets you take this exact code and additionally render to SVG. It works by serializing CanvasPathMethods calls to SVG path data. For example:jsconst path = d3.path();
drawCircle(path, 40);
path.toString(); // "M40,0A40,40,0,1,1,-40,0A40,40,0,1,1,40,0"Now code you write once can be used with both Canvas (for performance) and SVG (for convenience). For a practical example, see d3-shape.path() ​Source · Constructs a new path serializer that implements CanvasPathMethods.path.moveTo(x, y) ​Source · Move to the specified point ⟨x, y⟩. Equivalent to context.moveTo and SVG’s “moveto” command.jspath.moveTo(100, 100);path.closePath() ​Source · Ends the current subpath and causes an automatic straight line to be drawn from the current point to the initial point of the current subpath. Equivalent to context.closePath and SVG’s “closepath” command.jspath.closePath();path.lineTo(x, y) ​Source · Draws a straight line from the current point to the specified point ⟨x, y⟩. Equivalent to context.lineTo and SVG’s “lineto” command.jspath.lineTo(200, 200);path.quadraticCurveTo(cpx, cpy, x, y) ​Source · Draws a quadratic Bézier segment from the current point to the specified point ⟨x, y⟩, with the specified control point ⟨cpx, cpy⟩. Equivalent to context.quadraticCurveTo and SVG’s quadratic Bézier curve commands.jspath.quadraticCurveTo(200, 0, 200, 200);path.bezierCurveTo(cpx1, cpy1, cpx2, cpy2, x, y) ​Source · Draws a cubic Bézier segment from the current point to the specified point ⟨x, y⟩, with the specified control points ⟨cpx1, cpy1⟩ and ⟨cpx2, cpy2⟩. Equivalent to context.bezierCurveTo and SVG’s cubic Bézier curve commands.jspath.bezierCurveTo(200, 0, 0, 200, 200, 200);path.arcTo(x1, y1, x2, y2, radius) ​Source · Draws a circular arc segment with the specified radius that starts tangent to the line between the current point and the specified point ⟨x1, y1⟩ and ends tangent to the line between the specified points ⟨x1, y1⟩ and ⟨x2, y2⟩. If the first tangent point is not equal to the current point, a straight line is drawn between the current point and the first tangent point. Equivalent to context.arcTo and uses SVG’s elliptical arc curve commands.jspath.arcTo(150, 150, 300, 10, 40);path.arc(x, y, radius, startAngle, endAngle, anticlockwise) ​Source · Draws a circular arc segment with the specified center ⟨x, y⟩, radius, startAngle and endAngle. If anticlockwise is true, the arc is drawn in the anticlockwise direction; otherwise, it is drawn in the clockwise direction. If the current point is not equal to the starting point of the arc, a straight line is drawn from the current point to the start of the arc. Equivalent to context.arc and uses SVG’s elliptical arc curve commands.jspath.arc(80, 80, 70, 0, Math.PI * 2);path.rect(x, y, w, h) ​Source · Creates a new subpath containing just the four points ⟨x, y⟩, ⟨x + w, y⟩, ⟨x + w, y + h⟩, ⟨x, y + h⟩, with those four points connected by straight lines, and then marks the subpath as closed. Equivalent to context.rect and uses SVG’s “lineto” commands.jspath.rect(10, 10, 140, 140);path.toString() ​Source · Returns the string representation of this path according to SVG’s path data specification.jspath.toString() // "M40,0A40,40,0,1,1,-40,0A40,40,0,1,1,40,0"pathRound(digits = 3) ​Source · Like path, except limits the digits after the decimal to the specified number of digits. Useful for reducing the size of generated SVG path data.jsconst path = d3.pathRound(3);\n\nSearchK7.9.0GitHub️ 110.0kOn this paged3-path ​Examples · Say you have some code that draws to a 2D canvas:jsfunction drawCircle(context, radius) {
  context.moveTo(radius, 0);
  context.arc(0, 0, radius, 0, 2 * Math.PI);
}The d3-path module lets you take this exact code and additionally render to SVG. It works by serializing CanvasPathMethods calls to SVG path data. For example:jsconst path = d3.path();
drawCircle(path, 40);
path.toString(); // "M40,0A40,40,0,1,1,-40,0A40,40,0,1,1,40,0"Now code you write once can be used with both Canvas (for performance) and SVG (for convenience). For a practical example, see d3-shape.path() ​Source · Constructs a new path serializer that implements CanvasPathMethods.path.moveTo(x, y) ​Source · Move to the specified point ⟨x, y⟩. Equivalent to context.moveTo and SVG’s “moveto” command.jspath.moveTo(100, 100);path.closePath() ​Source · Ends the current subpath and causes an automatic straight line to be drawn from the current point to the initial point of the current subpath. Equivalent to context.closePath and SVG’s “closepath” command.jspath.closePath();path.lineTo(x, y) ​Source · Draws a straight line from the current point to the specified point ⟨x, y⟩. Equivalent to context.lineTo and SVG’s “lineto” command.jspath.lineTo(200, 200);path.quadraticCurveTo(cpx, cpy, x, y) ​Source · Draws a quadratic Bézier segment from the current point to the specified point ⟨x, y⟩, with the specified control point ⟨cpx, cpy⟩. Equivalent to context.quadraticCurveTo and SVG’s quadratic Bézier curve commands.jspath.quadraticCurveTo(200, 0, 200, 200);path.bezierCurveTo(cpx1, cpy1, cpx2, cpy2, x, y) ​Source · Draws a cubic Bézier segment from the current point to the specified point ⟨x, y⟩, with the specified control points ⟨cpx1, cpy1⟩ and ⟨cpx2, cpy2⟩. Equivalent to context.bezierCurveTo and SVG’s cubic Bézier curve commands.jspath.bezierCurveTo(200, 0, 0, 200, 200, 200);path.arcTo(x1, y1, x2, y2, radius) ​Source · Draws a circular arc segment with the specified radius that starts tangent to the line between the current point and the specified point ⟨x1, y1⟩ and ends tangent to the line between the specified points ⟨x1, y1⟩ and ⟨x2, y2⟩. If the first tangent point is not equal to the current point, a straight line is drawn between the current point and the first tangent point. Equivalent to context.arcTo and uses SVG’s elliptical arc curve commands.jspath.arcTo(150, 150, 300, 10, 40);path.arc(x, y, radius, startAngle, endAngle, anticlockwise) ​Source · Draws a circular arc segment with the specified center ⟨x, y⟩, radius, startAngle and endAngle. If anticlockwise is true, the arc is drawn in the anticlockwise direction; otherwise, it is drawn in the clockwise direction. If the current point is not equal to the starting point of the arc, a straight line is drawn from the current point to the start of the arc. Equivalent to context.arc and uses SVG’s elliptical arc curve commands.jspath.arc(80, 80, 70, 0, Math.PI * 2);path.rect(x, y, w, h) ​Source · Creates a new subpath containing just the four points ⟨x, y⟩, ⟨x + w, y⟩, ⟨x + w, y + h⟩, ⟨x, y + h⟩, with those four points connected by straight lines, and then marks the subpath as closed. Equivalent to context.rect and uses SVG’s “lineto” commands.jspath.rect(10, 10, 140, 140);path.toString() ​Source · Returns the string representation of this path according to SVG’s path data specification.jspath.toString() // "M40,0A40,40,0,1,1,-40,0A40,40,0,1,1,40,0"pathRound(digits = 3) ​Source · Like path, except limits the digits after the decimal to the specified number of digits. Useful for reducing the size of generated SVG path data.jsconst path = d3.pathRound(3);PagerPrevious pageTreemapNext paged3-polygon\n\nd3-path ​Examples · Say you have some code that draws to a 2D canvas:jsfunction drawCircle(context, radius) {
  context.moveTo(radius, 0);
  context.arc(0, 0, radius, 0, 2 * Math.PI);
}The d3-path module lets you take this exact code and additionally render to SVG. It works by serializing CanvasPathMethods calls to SVG path data. For example:jsconst path = d3.path();
drawCircle(path, 40);
path.toString(); // "M40,0A40,40,0,1,1,-40,0A40,40,0,1,1,40,0"Now code you write once can be used with both Canvas (for performance) and SVG (for convenience). For a practical example, see d3-shape.path() ​Source · Constructs a new path serializer that implements CanvasPathMethods.path.moveTo(x, y) ​Source · Move to the specified point ⟨x, y⟩. Equivalent to context.moveTo and SVG’s “moveto” command.jspath.moveTo(100, 100);path.closePath() ​Source · Ends the current subpath and causes an automatic straight line to be drawn from the current point to the initial point of the current subpath. Equivalent to context.closePath and SVG’s “closepath” command.jspath.closePath();path.lineTo(x, y) ​Source · Draws a straight line from the current point to the specified point ⟨x, y⟩. Equivalent to context.lineTo and SVG’s “lineto” command.jspath.lineTo(200, 200);path.quadraticCurveTo(cpx, cpy, x, y) ​Source · Draws a quadratic Bézier segment from the current point to the specified point ⟨x, y⟩, with the specified control point ⟨cpx, cpy⟩. Equivalent to context.quadraticCurveTo and SVG’s quadratic Bézier curve commands.jspath.quadraticCurveTo(200, 0, 200, 200);path.bezierCurveTo(cpx1, cpy1, cpx2, cpy2, x, y) ​Source · Draws a cubic Bézier segment from the current point to the specified point ⟨x, y⟩, with the specified control points ⟨cpx1, cpy1⟩ and ⟨cpx2, cpy2⟩. Equivalent to context.bezierCurveTo and SVG’s cubic Bézier curve commands.jspath.bezierCurveTo(200, 0, 0, 200, 200, 200);path.arcTo(x1, y1, x2, y2, radius) ​Source · Draws a circular arc segment with the specified radius that starts tangent to the line between the current point and the specified point ⟨x1, y1⟩ and ends tangent to the line between the specified points ⟨x1, y1⟩ and ⟨x2, y2⟩. If the first tangent point is not equal to the current point, a straight line is drawn between the current point and the first tangent point. Equivalent to context.arcTo and uses SVG’s elliptical arc curve commands.jspath.arcTo(150, 150, 300, 10, 40);path.arc(x, y, radius, startAngle, endAngle, anticlockwise) ​Source · Draws a circular arc segment with the specified center ⟨x, y⟩, radius, startAngle and endAngle. If anticlockwise is true, the arc is drawn in the anticlockwise direction; otherwise, it is drawn in the clockwise direction. If the current point is not equal to the starting point of the arc, a straight line is drawn from the current point to the start of the arc. Equivalent to context.arc and uses SVG’s elliptical arc curve commands.jspath.arc(80, 80, 70, 0, Math.PI * 2);path.rect(x, y, w, h) ​Source · Creates a new subpath containing just the four points ⟨x, y⟩, ⟨x + w, y⟩, ⟨x + w, y + h⟩, ⟨x, y + h⟩, with those four points connected by straight lines, and then marks the subpath as closed. Equivalent to context.rect and uses SVG’s “lineto” commands.jspath.rect(10, 10, 140, 140);path.toString() ​Source · Returns the string representation of this path according to SVG’s path data specification.jspath.toString() // "M40,0A40,40,0,1,1,-40,0A40,40,0,1,1,40,0"pathRound(digits = 3) ​Source · Like path, except limits the digits after the decimal to the specified number of digits. Useful for reducing the size of generated SVG path data.jsconst path = d3.pathRound(3);\n\n\n\nd3-polygon ​This module provides a few basic geometric operations for two-dimensional polygons. Each polygon is represented as an array of two-element arrays [​[x0, y0], [x1, y1], …], and may either be closed (wherein the first and last point are the same) or open (wherein they are not). Typically polygons are in counterclockwise order, assuming a coordinate system where the origin is in the top-left corner.polygonArea(polygon) ​jsd3.polygonArea([[1, 1], [1.5, 0], [2, 1]]) // -0.5Source · Returns the signed area of the specified polygon. If the vertices of the polygon are in counterclockwise order (assuming a coordinate system where the origin is in the top-left corner), the returned area is positive; otherwise it is negative, or zero.polygonCentroid(polygon) ​jsd3.polygonCentroid([[1, 1], [1.5, 0], [2, 1]]) // [1.5, 0.6666666666666666]Source · Returns the centroid of the specified polygon.polygonHull(points) ​jsd3.polygonHull(points) // [[3.0872864263338777, -1.300100095019402], [1.6559368816733773, -2.5092525689499605], …]Source · Returns the convex hull of the specified points using Andrew’s monotone chain algorithm. The returned hull is represented as an array containing a subset of the input points arranged in counterclockwise order. Returns null if points has fewer than three elements.polygonContains(polygon, point) ​jsd3.polygonContains([[1, 1], [1.5, 0], [2, 1]], [1.5, 0.667]) // trueSource · Returns true if and only if the specified point is inside the specified polygon.polygonLength(polygon) ​jsd3.polygonLength([[1, 1], [1.5, 0], [2, 1]]) // 3.23606797749979Source · Returns the length of the perimeter of the specified polygon.\n\nSearchK7.9.0GitHub️ 110.0kOn this paged3-polygon ​This module provides a few basic geometric operations for two-dimensional polygons. Each polygon is represented as an array of two-element arrays [​[x0, y0], [x1, y1], …], and may either be closed (wherein the first and last point are the same) or open (wherein they are not). Typically polygons are in counterclockwise order, assuming a coordinate system where the origin is in the top-left corner.polygonArea(polygon) ​jsd3.polygonArea([[1, 1], [1.5, 0], [2, 1]]) // -0.5Source · Returns the signed area of the specified polygon. If the vertices of the polygon are in counterclockwise order (assuming a coordinate system where the origin is in the top-left corner), the returned area is positive; otherwise it is negative, or zero.polygonCentroid(polygon) ​jsd3.polygonCentroid([[1, 1], [1.5, 0], [2, 1]]) // [1.5, 0.6666666666666666]Source · Returns the centroid of the specified polygon.polygonHull(points) ​jsd3.polygonHull(points) // [[3.0872864263338777, -1.300100095019402], [1.6559368816733773, -2.5092525689499605], …]Source · Returns the convex hull of the specified points using Andrew’s monotone chain algorithm. The returned hull is represented as an array containing a subset of the input points arranged in counterclockwise order. Returns null if points has fewer than three elements.polygonContains(polygon, point) ​jsd3.polygonContains([[1, 1], [1.5, 0], [2, 1]], [1.5, 0.667]) // trueSource · Returns true if and only if the specified point is inside the specified polygon.polygonLength(polygon) ​jsd3.polygonLength([[1, 1], [1.5, 0], [2, 1]]) // 3.23606797749979Source · Returns the length of the perimeter of the specified polygon.PagerPrevious paged3-pathNext paged3-quadtree\n\nd3-polygon ​This module provides a few basic geometric operations for two-dimensional polygons. Each polygon is represented as an array of two-element arrays [​[x0, y0], [x1, y1], …], and may either be closed (wherein the first and last point are the same) or open (wherein they are not). Typically polygons are in counterclockwise order, assuming a coordinate system where the origin is in the top-left corner.polygonArea(polygon) ​jsd3.polygonArea([[1, 1], [1.5, 0], [2, 1]]) // -0.5Source · Returns the signed area of the specified polygon. If the vertices of the polygon are in counterclockwise order (assuming a coordinate system where the origin is in the top-left corner), the returned area is positive; otherwise it is negative, or zero.polygonCentroid(polygon) ​jsd3.polygonCentroid([[1, 1], [1.5, 0], [2, 1]]) // [1.5, 0.6666666666666666]Source · Returns the centroid of the specified polygon.polygonHull(points) ​jsd3.polygonHull(points) // [[3.0872864263338777, -1.300100095019402], [1.6559368816733773, -2.5092525689499605], …]Source · Returns the convex hull of the specified points using Andrew’s monotone chain algorithm. The returned hull is represented as an array containing a subset of the input points arranged in counterclockwise order. Returns null if points has fewer than three elements.polygonContains(polygon, point) ​jsd3.polygonContains([[1, 1], [1.5, 0], [2, 1]], [1.5, 0.667]) // trueSource · Returns true if and only if the specified point is inside the specified polygon.polygonLength(polygon) ​jsd3.polygonLength([[1, 1], [1.5, 0], [2, 1]]) // 3.23606797749979Source · Returns the length of the perimeter of the specified polygon.\n\n\n\nd3-quadtree ​Fork ↗︎A quadtree recursively partitions two-dimensional space into squares, dividing each square into four equally-sized squares. Each distinct point exists in a unique leaf node; coincident points are represented by a linked list. Quadtrees can accelerate various spatial operations, such as the Barnes–Hut approximation for computing many-body forces, collision detection, and searching for nearby points.quadtree(data, x, y) ​Source · Creates a new, empty quadtree with an empty extent and the default x and y accessors. If data is specified, adds the specified iterable of data to the quadtree.jsconst tree = d3.quadtree(data);This is equivalent to:jsconst tree = d3.quadtree().addAll(data);If x and y are also specified, sets the x and y accessors to the specified functions before adding the specified iterable of data to the quadtree, equivalent to:jsconst tree = d3.quadtree().x(x).y(y).addAll(data);quadtree.x(x) ​Source · If x is specified, sets the current x-coordinate accessor and returns the quadtree.jsconst tree = d3.quadtree().x((d) => d.x);The x accessor is used to derive the x coordinate of data when adding to and removing from the tree. It is also used when finding to re-access the coordinates of data previously added to the tree; therefore, the x and y accessors must be consistent, returning the same value given the same input.If x is not specified, returns the current x accessor.jstree.x() // (d) => d.xThe x accessor defaults to:jsfunction x(d) {
  return d[0];
}quadtree.y(y) ​Source · If y is specified, sets the current y-coordinate accessor and returns the quadtree.jsconst tree = d3.quadtree().y((d) => d.y);The y accessor is used to derive the y coordinate of data when adding to and removing from the tree. It is also used when finding to re-access the coordinates of data previously added to the tree; therefore, the x and y accessors must be consistent, returning the same value given the same input.If y is not specified, returns the current y accessor.jstree.y() // (d) => d.yThe y accessor defaults to:jsfunction y(d) {
  return d[1];
}quadtree.extent(extent) ​Source · If extent is specified, expands the quadtree to cover the specified points [[x0, y0], [x1, y1]] and returns the quadtree.jsconst tree = d3.quadtree().extent([[0, 0], [1, 1]]);If extent is not specified, returns the quadtree’s current extent [[x0, y0], [x1, y1]], where x0 and y0 are the inclusive lower bounds and x1 and y1 are the inclusive upper bounds, or undefined if the quadtree has no extent.jstree.extent() // [[0, 0], [2, 2]]The extent may also be expanded by calling quadtree.cover or quadtree.add.quadtree.cover(x, y) ​Source · Expands the quadtree to cover the specified point ⟨x,y⟩, and returns the quadtree.jsconst tree = d3.quadtree().cover(0, 0).cover(1, 1);If the quadtree’s extent already covers the specified point, this method does nothing. If the quadtree has an extent, the extent is repeatedly doubled to cover the specified point, wrapping the root node as necessary; if the quadtree is empty, the extent is initialized to the extent [[⌊x⌋, ⌊y⌋], [⌈x⌉, ⌈y⌉]]. (Rounding is necessary such that if the extent is later doubled, the boundaries of existing quadrants do not change due to floating point error.)quadtree.add(datum) ​Source · Adds the specified datum to the quadtree, deriving its coordinates ⟨x,y⟩ using the current x and y accessors, and returns the quadtree.jsconst tree = d3.quadtree().add([0, 0]);If the new point is outside the current extent of the quadtree, the quadtree is automatically expanded to cover the new point.quadtree.addAll(data) ​Source · Adds the specified iterable of data to the quadtree, deriving each element’s coordinates ⟨x,y⟩ using the current x and y accessors, and return this quadtree.jsconst tree = d3.quadtree().addAll([[0, 0], [1, 2]]);This is approximately equivalent to calling quadtree.add repeatedly:jsfor (let i = 0, n = data.length; i < n; ++i) {
  quadtree.add(data[i]);
}However, this method results in a more compact quadtree because the extent of the data is computed first before adding the data.quadtree.remove(datum) ​Source · Removes the specified datum from the quadtree, deriving its coordinates ⟨x,y⟩ using the current x and y accessors, and returns the quadtree.jstree.remove(data[0]);If the specified datum does not exist in this quadtree (as determined by strict equality with datum, and independent of the computed position), this method does nothing.quadtree.removeAll(data) ​Source · Removes the specified data from the quadtree, deriving their coordinates ⟨x,y⟩ using the current x and y accessors, and returns the quadtree.jstree.removeAll(data);If a specified datum does not exist in this quadtree (as determined by strict equality with datum, and independent of the computed position), it is ignored.quadtree.copy() ​jsconst t1 = d3.quadtree(data);
const t2 = t1.copy();Source · Returns a copy of the quadtree. All nodes in the returned quadtree are identical copies of the corresponding node in the quadtree; however, any data in the quadtree is shared by reference and not copied.quadtree.root() ​Source · Returns the root node of the quadtree.jstree.root() // [{…}, empty × 2, {…}]quadtree.data() ​Source · Returns an array of all data in the quadtree.jstree.data() // [[0, 0], [1, 2]]quadtree.size() ​Source · Returns the total number of data in the quadtree.jstree.size() // 2quadtree.find(x, y, radius) ​Source · Returns the datum closest to the position ⟨x,y⟩ with the given search radius. If radius is not specified, it defaults to infinity.jstree.find(0.000, 0.000) // If there is no datum within the search area, returns undefined.jstree.find(10, 10, 1) // undefinedquadtree.visit(callback) ​Source · Visits each node in the quadtree in pre-order traversal, invoking the specified callback with arguments node, x0, y0, x1, y1 for each node, where node is the node being visited, ⟨x0, y0⟩ are the lower bounds of the node, and ⟨x1, y1⟩ are the upper bounds, and returns the quadtree. (Assuming that positive x is right and positive y is down, as is typically the case in Canvas and SVG, ⟨x0, y0⟩ is the top-left corner and ⟨x1, y1⟩ is the lower-right corner; however, the coordinate system is arbitrary, so more formally x0 <= x1 and y0 <= y1.)If the callback returns true for a given node, then the children of that node are not visited; otherwise, all child nodes are visited. This can be used to quickly visit only parts of the tree, for example when using the Barnes–Hut approximation. Note, however, that child quadrants are always visited in sibling order: top-left, top-right, bottom-left, bottom-right. In cases such as search, visiting siblings in a specific order may be faster.As an example, the following visits the quadtree and returns all the nodes within a rectangular extent [xmin, ymin, xmax, ymax], ignoring quads that cannot possibly contain any such node:jsfunction search(quadtree, xmin, ymin, xmax, ymax) {
  const results = [];
  quadtree.visit((node, x1, y1, x2, y2) => {
    if (!node.length) {
      do {
        let d = node.data;
        if (d[0] >= xmin && d[0] < xmax && d[1] >= ymin && d[1] < ymax) {
          results.push(d);
        }
      } while (node = node.next);
    }
    return x1 >= xmax || y1 >= ymax || x2 < xmin || y2 < ymin;
  });
  return results;
}quadtree.visitAfter(callback) ​Source · Visits each node in the quadtree in post-order traversal, invoking the specified callback with arguments node, x0, y0, x1, y1 for each node, where node is the node being visited, ⟨x0, y0⟩ are the lower bounds of the node, and ⟨x1, y1⟩ are the upper bounds, and returns the quadtree. (Assuming that positive x is right and positive y is down, as is typically the case in Canvas and SVG, ⟨x0, y0⟩ is the top-left corner and ⟨x1, y1⟩ is the lower-right corner; however, the coordinate system is arbitrary, so more formally x0 <= x1 and y0 <= y1.) Returns root.Quadtree nodes ​Internal nodes of the quadtree are represented as sparse four-element arrays in left-to-right, top-to-bottom order:0 - the top-left quadrant, if any.1 - the top-right quadrant, if any.2 - the bottom-left quadrant, if any.3 - the bottom-right quadrant, if any.A child quadrant may be undefined if it is empty.Leaf nodes are represented as objects with the following properties:data - the data associated with this point, as passed to quadtree.add.next - the next datum in this leaf, if any.The length property may be used to distinguish leaf nodes from internal nodes: it is undefined for leaf nodes, and 4 for internal nodes. For example, to iterate over all data in a leaf node:jsif (!node.length) do console.log(node.data); while (node = node.next);The point’s x and y coordinates must not be modified while the point is in the quadtree. To update a point’s position, remove the point and then re-add it to the quadtree at the new position. Alternatively, you may discard the existing quadtree entirely and create a new one from scratch; this may be more efficient if many of the points have moved.\n\nSearchK7.9.0GitHub️ 110.0kOn this paged3-quadtree ​Fork ↗︎A quadtree recursively partitions two-dimensional space into squares, dividing each square into four equally-sized squares. Each distinct point exists in a unique leaf node; coincident points are represented by a linked list. Quadtrees can accelerate various spatial operations, such as the Barnes–Hut approximation for computing many-body forces, collision detection, and searching for nearby points.quadtree(data, x, y) ​Source · Creates a new, empty quadtree with an empty extent and the default x and y accessors. If data is specified, adds the specified iterable of data to the quadtree.jsconst tree = d3.quadtree(data);This is equivalent to:jsconst tree = d3.quadtree().addAll(data);If x and y are also specified, sets the x and y accessors to the specified functions before adding the specified iterable of data to the quadtree, equivalent to:jsconst tree = d3.quadtree().x(x).y(y).addAll(data);quadtree.x(x) ​Source · If x is specified, sets the current x-coordinate accessor and returns the quadtree.jsconst tree = d3.quadtree().x((d) => d.x);The x accessor is used to derive the x coordinate of data when adding to and removing from the tree. It is also used when finding to re-access the coordinates of data previously added to the tree; therefore, the x and y accessors must be consistent, returning the same value given the same input.If x is not specified, returns the current x accessor.jstree.x() // (d) => d.xThe x accessor defaults to:jsfunction x(d) {
  return d[0];
}quadtree.y(y) ​Source · If y is specified, sets the current y-coordinate accessor and returns the quadtree.jsconst tree = d3.quadtree().y((d) => d.y);The y accessor is used to derive the y coordinate of data when adding to and removing from the tree. It is also used when finding to re-access the coordinates of data previously added to the tree; therefore, the x and y accessors must be consistent, returning the same value given the same input.If y is not specified, returns the current y accessor.jstree.y() // (d) => d.yThe y accessor defaults to:jsfunction y(d) {
  return d[1];
}quadtree.extent(extent) ​Source · If extent is specified, expands the quadtree to cover the specified points [[x0, y0], [x1, y1]] and returns the quadtree.jsconst tree = d3.quadtree().extent([[0, 0], [1, 1]]);If extent is not specified, returns the quadtree’s current extent [[x0, y0], [x1, y1]], where x0 and y0 are the inclusive lower bounds and x1 and y1 are the inclusive upper bounds, or undefined if the quadtree has no extent.jstree.extent() // [[0, 0], [2, 2]]The extent may also be expanded by calling quadtree.cover or quadtree.add.quadtree.cover(x, y) ​Source · Expands the quadtree to cover the specified point ⟨x,y⟩, and returns the quadtree.jsconst tree = d3.quadtree().cover(0, 0).cover(1, 1);If the quadtree’s extent already covers the specified point, this method does nothing. If the quadtree has an extent, the extent is repeatedly doubled to cover the specified point, wrapping the root node as necessary; if the quadtree is empty, the extent is initialized to the extent [[⌊x⌋, ⌊y⌋], [⌈x⌉, ⌈y⌉]]. (Rounding is necessary such that if the extent is later doubled, the boundaries of existing quadrants do not change due to floating point error.)quadtree.add(datum) ​Source · Adds the specified datum to the quadtree, deriving its coordinates ⟨x,y⟩ using the current x and y accessors, and returns the quadtree.jsconst tree = d3.quadtree().add([0, 0]);If the new point is outside the current extent of the quadtree, the quadtree is automatically expanded to cover the new point.quadtree.addAll(data) ​Source · Adds the specified iterable of data to the quadtree, deriving each element’s coordinates ⟨x,y⟩ using the current x and y accessors, and return this quadtree.jsconst tree = d3.quadtree().addAll([[0, 0], [1, 2]]);This is approximately equivalent to calling quadtree.add repeatedly:jsfor (let i = 0, n = data.length; i < n; ++i) {
  quadtree.add(data[i]);
}However, this method results in a more compact quadtree because the extent of the data is computed first before adding the data.quadtree.remove(datum) ​Source · Removes the specified datum from the quadtree, deriving its coordinates ⟨x,y⟩ using the current x and y accessors, and returns the quadtree.jstree.remove(data[0]);If the specified datum does not exist in this quadtree (as determined by strict equality with datum, and independent of the computed position), this method does nothing.quadtree.removeAll(data) ​Source · Removes the specified data from the quadtree, deriving their coordinates ⟨x,y⟩ using the current x and y accessors, and returns the quadtree.jstree.removeAll(data);If a specified datum does not exist in this quadtree (as determined by strict equality with datum, and independent of the computed position), it is ignored.quadtree.copy() ​jsconst t1 = d3.quadtree(data);
const t2 = t1.copy();Source · Returns a copy of the quadtree. All nodes in the returned quadtree are identical copies of the corresponding node in the quadtree; however, any data in the quadtree is shared by reference and not copied.quadtree.root() ​Source · Returns the root node of the quadtree.jstree.root() // [{…}, empty × 2, {…}]quadtree.data() ​Source · Returns an array of all data in the quadtree.jstree.data() // [[0, 0], [1, 2]]quadtree.size() ​Source · Returns the total number of data in the quadtree.jstree.size() // 2quadtree.find(x, y, radius) ​Source · Returns the datum closest to the position ⟨x,y⟩ with the given search radius. If radius is not specified, it defaults to infinity.jstree.find(0.000, 0.000) // If there is no datum within the search area, returns undefined.jstree.find(10, 10, 1) // undefinedquadtree.visit(callback) ​Source · Visits each node in the quadtree in pre-order traversal, invoking the specified callback with arguments node, x0, y0, x1, y1 for each node, where node is the node being visited, ⟨x0, y0⟩ are the lower bounds of the node, and ⟨x1, y1⟩ are the upper bounds, and returns the quadtree. (Assuming that positive x is right and positive y is down, as is typically the case in Canvas and SVG, ⟨x0, y0⟩ is the top-left corner and ⟨x1, y1⟩ is the lower-right corner; however, the coordinate system is arbitrary, so more formally x0 <= x1 and y0 <= y1.)If the callback returns true for a given node, then the children of that node are not visited; otherwise, all child nodes are visited. This can be used to quickly visit only parts of the tree, for example when using the Barnes–Hut approximation. Note, however, that child quadrants are always visited in sibling order: top-left, top-right, bottom-left, bottom-right. In cases such as search, visiting siblings in a specific order may be faster.As an example, the following visits the quadtree and returns all the nodes within a rectangular extent [xmin, ymin, xmax, ymax], ignoring quads that cannot possibly contain any such node:jsfunction search(quadtree, xmin, ymin, xmax, ymax) {
  const results = [];
  quadtree.visit((node, x1, y1, x2, y2) => {
    if (!node.length) {
      do {
        let d = node.data;
        if (d[0] >= xmin && d[0] < xmax && d[1] >= ymin && d[1] < ymax) {
          results.push(d);
        }
      } while (node = node.next);
    }
    return x1 >= xmax || y1 >= ymax || x2 < xmin || y2 < ymin;
  });
  return results;
}quadtree.visitAfter(callback) ​Source · Visits each node in the quadtree in post-order traversal, invoking the specified callback with arguments node, x0, y0, x1, y1 for each node, where node is the node being visited, ⟨x0, y0⟩ are the lower bounds of the node, and ⟨x1, y1⟩ are the upper bounds, and returns the quadtree. (Assuming that positive x is right and positive y is down, as is typically the case in Canvas and SVG, ⟨x0, y0⟩ is the top-left corner and ⟨x1, y1⟩ is the lower-right corner; however, the coordinate system is arbitrary, so more formally x0 <= x1 and y0 <= y1.) Returns root.Quadtree nodes ​Internal nodes of the quadtree are represented as sparse four-element arrays in left-to-right, top-to-bottom order:0 - the top-left quadrant, if any.1 - the top-right quadrant, if any.2 - the bottom-left quadrant, if any.3 - the bottom-right quadrant, if any.A child quadrant may be undefined if it is empty.Leaf nodes are represented as objects with the following properties:data - the data associated with this point, as passed to quadtree.add.next - the next datum in this leaf, if any.The length property may be used to distinguish leaf nodes from internal nodes: it is undefined for leaf nodes, and 4 for internal nodes. For example, to iterate over all data in a leaf node:jsif (!node.length) do console.log(node.data); while (node = node.next);The point’s x and y coordinates must not be modified while the point is in the quadtree. To update a point’s position, remove the point and then re-add it to the quadtree at the new position. Alternatively, you may discard the existing quadtree entirely and create a new one from scratch; this may be more efficient if many of the points have moved.PagerPrevious paged3-polygonNext paged3-scale\n\nd3-quadtree ​Fork ↗︎A quadtree recursively partitions two-dimensional space into squares, dividing each square into four equally-sized squares. Each distinct point exists in a unique leaf node; coincident points are represented by a linked list. Quadtrees can accelerate various spatial operations, such as the Barnes–Hut approximation for computing many-body forces, collision detection, and searching for nearby points.quadtree(data, x, y) ​Source · Creates a new, empty quadtree with an empty extent and the default x and y accessors. If data is specified, adds the specified iterable of data to the quadtree.jsconst tree = d3.quadtree(data);This is equivalent to:jsconst tree = d3.quadtree().addAll(data);If x and y are also specified, sets the x and y accessors to the specified functions before adding the specified iterable of data to the quadtree, equivalent to:jsconst tree = d3.quadtree().x(x).y(y).addAll(data);quadtree.x(x) ​Source · If x is specified, sets the current x-coordinate accessor and returns the quadtree.jsconst tree = d3.quadtree().x((d) => d.x);The x accessor is used to derive the x coordinate of data when adding to and removing from the tree. It is also used when finding to re-access the coordinates of data previously added to the tree; therefore, the x and y accessors must be consistent, returning the same value given the same input.If x is not specified, returns the current x accessor.jstree.x() // (d) => d.xThe x accessor defaults to:jsfunction x(d) {
  return d[0];
}quadtree.y(y) ​Source · If y is specified, sets the current y-coordinate accessor and returns the quadtree.jsconst tree = d3.quadtree().y((d) => d.y);The y accessor is used to derive the y coordinate of data when adding to and removing from the tree. It is also used when finding to re-access the coordinates of data previously added to the tree; therefore, the x and y accessors must be consistent, returning the same value given the same input.If y is not specified, returns the current y accessor.jstree.y() // (d) => d.yThe y accessor defaults to:jsfunction y(d) {
  return d[1];
}quadtree.extent(extent) ​Source · If extent is specified, expands the quadtree to cover the specified points [[x0, y0], [x1, y1]] and returns the quadtree.jsconst tree = d3.quadtree().extent([[0, 0], [1, 1]]);If extent is not specified, returns the quadtree’s current extent [[x0, y0], [x1, y1]], where x0 and y0 are the inclusive lower bounds and x1 and y1 are the inclusive upper bounds, or undefined if the quadtree has no extent.jstree.extent() // [[0, 0], [2, 2]]The extent may also be expanded by calling quadtree.cover or quadtree.add.quadtree.cover(x, y) ​Source · Expands the quadtree to cover the specified point ⟨x,y⟩, and returns the quadtree.jsconst tree = d3.quadtree().cover(0, 0).cover(1, 1);If the quadtree’s extent already covers the specified point, this method does nothing. If the quadtree has an extent, the extent is repeatedly doubled to cover the specified point, wrapping the root node as necessary; if the quadtree is empty, the extent is initialized to the extent [[⌊x⌋, ⌊y⌋], [⌈x⌉, ⌈y⌉]]. (Rounding is necessary such that if the extent is later doubled, the boundaries of existing quadrants do not change due to floating point error.)quadtree.add(datum) ​Source · Adds the specified datum to the quadtree, deriving its coordinates ⟨x,y⟩ using the current x and y accessors, and returns the quadtree.jsconst tree = d3.quadtree().add([0, 0]);If the new point is outside the current extent of the quadtree, the quadtree is automatically expanded to cover the new point.quadtree.addAll(data) ​Source · Adds the specified iterable of data to the quadtree, deriving each element’s coordinates ⟨x,y⟩ using the current x and y accessors, and return this quadtree.jsconst tree = d3.quadtree().addAll([[0, 0], [1, 2]]);This is approximately equivalent to calling quadtree.add repeatedly:jsfor (let i = 0, n = data.length; i < n; ++i) {
  quadtree.add(data[i]);
}However, this method results in a more compact quadtree because the extent of the data is computed first before adding the data.quadtree.remove(datum) ​Source · Removes the specified datum from the quadtree, deriving its coordinates ⟨x,y⟩ using the current x and y accessors, and returns the quadtree.jstree.remove(data[0]);If the specified datum does not exist in this quadtree (as determined by strict equality with datum, and independent of the computed position), this method does nothing.quadtree.removeAll(data) ​Source · Removes the specified data from the quadtree, deriving their coordinates ⟨x,y⟩ using the current x and y accessors, and returns the quadtree.jstree.removeAll(data);If a specified datum does not exist in this quadtree (as determined by strict equality with datum, and independent of the computed position), it is ignored.quadtree.copy() ​jsconst t1 = d3.quadtree(data);
const t2 = t1.copy();Source · Returns a copy of the quadtree. All nodes in the returned quadtree are identical copies of the corresponding node in the quadtree; however, any data in the quadtree is shared by reference and not copied.quadtree.root() ​Source · Returns the root node of the quadtree.jstree.root() // [{…}, empty × 2, {…}]quadtree.data() ​Source · Returns an array of all data in the quadtree.jstree.data() // [[0, 0], [1, 2]]quadtree.size() ​Source · Returns the total number of data in the quadtree.jstree.size() // 2quadtree.find(x, y, radius) ​Source · Returns the datum closest to the position ⟨x,y⟩ with the given search radius. If radius is not specified, it defaults to infinity.jstree.find(0.000, 0.000) // If there is no datum within the search area, returns undefined.jstree.find(10, 10, 1) // undefinedquadtree.visit(callback) ​Source · Visits each node in the quadtree in pre-order traversal, invoking the specified callback with arguments node, x0, y0, x1, y1 for each node, where node is the node being visited, ⟨x0, y0⟩ are the lower bounds of the node, and ⟨x1, y1⟩ are the upper bounds, and returns the quadtree. (Assuming that positive x is right and positive y is down, as is typically the case in Canvas and SVG, ⟨x0, y0⟩ is the top-left corner and ⟨x1, y1⟩ is the lower-right corner; however, the coordinate system is arbitrary, so more formally x0 <= x1 and y0 <= y1.)If the callback returns true for a given node, then the children of that node are not visited; otherwise, all child nodes are visited. This can be used to quickly visit only parts of the tree, for example when using the Barnes–Hut approximation. Note, however, that child quadrants are always visited in sibling order: top-left, top-right, bottom-left, bottom-right. In cases such as search, visiting siblings in a specific order may be faster.As an example, the following visits the quadtree and returns all the nodes within a rectangular extent [xmin, ymin, xmax, ymax], ignoring quads that cannot possibly contain any such node:jsfunction search(quadtree, xmin, ymin, xmax, ymax) {
  const results = [];
  quadtree.visit((node, x1, y1, x2, y2) => {
    if (!node.length) {
      do {
        let d = node.data;
        if (d[0] >= xmin && d[0] < xmax && d[1] >= ymin && d[1] < ymax) {
          results.push(d);
        }
      } while (node = node.next);
    }
    return x1 >= xmax || y1 >= ymax || x2 < xmin || y2 < ymin;
  });
  return results;
}quadtree.visitAfter(callback) ​Source · Visits each node in the quadtree in post-order traversal, invoking the specified callback with arguments node, x0, y0, x1, y1 for each node, where node is the node being visited, ⟨x0, y0⟩ are the lower bounds of the node, and ⟨x1, y1⟩ are the upper bounds, and returns the quadtree. (Assuming that positive x is right and positive y is down, as is typically the case in Canvas and SVG, ⟨x0, y0⟩ is the top-left corner and ⟨x1, y1⟩ is the lower-right corner; however, the coordinate system is arbitrary, so more formally x0 <= x1 and y0 <= y1.) Returns root.Quadtree nodes ​Internal nodes of the quadtree are represented as sparse four-element arrays in left-to-right, top-to-bottom order:0 - the top-left quadrant, if any.1 - the top-right quadrant, if any.2 - the bottom-left quadrant, if any.3 - the bottom-right quadrant, if any.A child quadrant may be undefined if it is empty.Leaf nodes are represented as objects with the following properties:data - the data associated with this point, as passed to quadtree.add.next - the next datum in this leaf, if any.The length property may be used to distinguish leaf nodes from internal nodes: it is undefined for leaf nodes, and 4 for internal nodes. For example, to iterate over all data in a leaf node:jsif (!node.length) do console.log(node.data); while (node = node.next);The point’s x and y coordinates must not be modified while the point is in the quadtree. To update a point’s position, remove the point and then re-add it to the quadtree at the new position. Alternatively, you may discard the existing quadtree entirely and create a new one from scratch; this may be more efficient if many of the points have moved.\n\n\n\nLinear scales ​Linear scales map a continuous, quantitative input domain to a continuous output range using a linear transformation (translate and scale). If the range is also numeric, the mapping may be inverted. Linear scales are a good default choice for continuous quantitative data because they preserve proportional differences. Each range value y can be expressed as a function of the domain value x: y = mx + b.scaleLinear(domain, range) ​Examples · Source · Constructs a new linear scale with the specified domain and range, the default interpolator, and clamping disabled.jsd3.scaleLinear([0, 100], ["red", "blue"])If a single argument is specified, it is interpreted as the range. If either domain or range are not specified, each defaults to [0, 1].jsd3.scaleLinear(["red", "blue"]) // default domain of [0, 1]linear(value) ​Examples · Source · Given a value from the domain, returns the corresponding value from the range. For example, to apply a position encoding:jsconst x = d3.scaleLinear([10, 130], [0, 960]);
x(20); // 80
x(50); // 320To apply a color encoding:jsconst color = d3.scaleLinear([10, 100], ["brown", "steelblue"]);
color(20); // "rgb(154, 52, 57)"
color(50); // "rgb(123, 81, 103)"If the given value is outside the domain, and clamping is not enabled, the mapping will be extrapolated such that the returned value is outside the range.linear.invert(value) ​Examples · Source · Given a value from the range, returns the corresponding value from the domain. Inversion is useful for interaction, say to determine the data value corresponding to the position of the mouse. For example, to invert a position encoding:jsconst x = d3.scaleLinear([10, 130], [0, 960]);
x.invert(80); // 20
x.invert(320); // 50If the given value is outside the range, and clamping is not enabled, the mapping may be extrapolated such that the returned value is outside the domain. This method is only supported if the range is numeric. If the range is not numeric, returns NaN.For a valid value y in the range, linear(linear.invert(y)) approximately equals y; similarly, for a valid value x in the domain, linear.invert(linear(x)) approximately equals x. The scale and its inverse may not be exact due to the limitations of floating point precision.linear.domain(domain) ​Examples · Source · If domain is specified, sets the scale’s domain to the specified array of numbers and returns this scale.jsconst x = d3.scaleLinear().domain([10, 130]);The array must contain two or more elements. If the elements in the given array are not numbers, they will be coerced to numbers.Although continuous scales typically have two values each in their domain and range, specifying more than two values produces a piecewise scale. For example, to create a diverging color scale that interpolates between white and red for negative values, and white and green for positive values, say:jsconst color = d3.scaleLinear([-1, 0, 1], ["red", "white", "green"]);
color(-0.5); // "rgb(255, 128, 128)"
color(+0.5); // "rgb(128, 192, 128)"Internally, a piecewise scale performs a binary search for the range interpolator corresponding to the given domain value. Thus, the domain must be in ascending or descending order. If the domain and range have different lengths N and M, only the first min(N,M) elements in each are observed.If domain is not specified, returns a copy of the scale’s current domain.jscolor.domain() // [-1, 0, 1]linear.range(range) ​Examples · Source · If range is specified, sets the scale’s range to the specified array of values and returns this scale.jsconst x = d3.scaleLinear().range([0, 960]);The array must contain two or more elements. Unlike the domain, elements in the given array need not be numbers; any value that is supported by the underlying interpolator will work, though note that numeric ranges are required for invert.If range is not specified, returns a copy of the scale’s current range.jsx.range() // [0, 960]See linear.interpolate for more examples.linear.rangeRound(range) ​Examples · Source · Sets the scale’s range to the specified array of values while also setting the scale’s interpolator to interpolateRound; returns this scale.jsconst x = d3.scaleLinear().rangeRound([0, 960]);This is a convenience method equivalent to:jslinear.range(range).interpolate(d3.interpolateRound)The rounding interpolator is sometimes useful for avoiding antialiasing artifacts, though also consider the shape-rendering “crispEdges” styles. Note that this interpolator can only be used with numeric ranges.linear.clamp(clamp) ​Examples · Source · If clamp is specified, enables or disables clamping accordingly; returns this scale.jsconst x = d3.scaleLinear([0, 960]).clamp(true);If clamping is disabled and the scale is passed a value outside the domain, the scale may return a value outside the range through extrapolation. If clamping is enabled, the return value of the scale is always within the scale’s range. Clamping similarly applies to linear.invert. For example:jsconst x = d3.scaleLinear([10, 130], [0, 960]); // clamping disabled by default
x(-10); // -160, outside range
x.invert(-160); // -10, outside domain
x.clamp(true); // enable clamping
x(-10); // 0, clamped to range
x.invert(-160); // 10, clamped to domainIf clamp is not specified, returns whether or not the scale currently clamps values to within the range.jsx.clamp() // true, perhapslinear.unknown(value) ​Examples · Source · If value is specified, sets the output value of the scale for undefined or NaN input values and returns this scale. This is useful for specifying how missing or invalid data is displayed.jsconst color = d3.scaleLinear([0, 100], ["red", "blue"]).unknown("#ccc");
color(NaN); // "#ccc"If value is not specified, returns the current unknown value, which defaults to undefined.jscolor.unknown() // "#ccc"linear.interpolate(interpolate) ​Examples · Source · If interpolate is specified, sets the scale’s range interpolator factory.jsconst color = d3.scaleLinear(["red", "blue"]).interpolate(d3.interpolateHcl);The scale’s interpolator factory is used to create interpolators for each adjacent pair of values from the range; these interpolators then map a normalized domain parameter t in [0, 1] to the corresponding value in the range. If factory is not specified, returns the scale’s current interpolator factory, which defaults to d3.interpolate. See d3-interpolate for more interpolators.For example, consider a diverging color scale with three colors in the range:jsconst color = d3.scaleLinear([-100, 0, +100], ["red", "white", "green"]);Two interpolators are created internally by the scale, equivalent to:jsconst i0 = d3.interpolate("red", "white");
const i1 = d3.interpolate("white", "green");A common reason to specify a custom interpolator is to change the color space of interpolation. For example, to use HCL:jsconst color = d3.scaleLinear()
    .domain([10, 100])
    .range(["brown", "steelblue"])
    .interpolate(d3.interpolateHcl);Or for Cubehelix with a custom gamma:jsconst color = d3.scaleLinear()
    .domain([10, 100])
    .range(["brown", "steelblue"])
    .interpolate(d3.interpolateCubehelix.gamma(3));CAUTIONThe default interpolator may reuse return values. For example, if the range values are objects, then the value interpolator always returns the same object, modifying it in-place. If the scale is used to set an attribute or style, this is typically acceptable (and desirable for performance); however, if you need to store the scale’s return value, you must specify your own interpolator or make a copy as appropriate.linear.ticks(count) ​Examples · Source · Returns approximately count representative values from the scale’s domain.jsconst x = d3.scaleLinear([10, 100], ["red", "blue"]);
x.ticks(); // [10, 20, 30, 40, 50, 60, 70, 80, 90, 100]If count is not specified, it defaults to 10. The returned tick values are uniformly spaced, have human-readable values (such as multiples of powers of 10), and are guaranteed to be within the extent of the domain. Ticks are often used to display reference lines, or tick marks, in conjunction with the visualized data. The specified count is only a hint; the scale may return more or fewer values depending on the domain. See also d3-array’s ticks.linear.tickFormat(count, specifier) ​Examples · Source · Returns a number format function suitable for displaying a tick value, automatically computing the appropriate precision based on the fixed interval between tick values. The specified count should have the same value as the count that is used to generate the tick values.jsconst x = d3.scaleLinear([0.1, 1], ["red", "blue"]);
const f = x.tickFormat();
f(0.1); // "0.1"
f(1); // "1.0"An optional specifier allows a custom format where the precision of the format is automatically set by the scale as appropriate for the tick interval. For example, to format percentage change, you might say:jsconst x = d3.scaleLinear([-1, 1], [0, 960]);
const T = x.ticks(5); // [-1, -0.5, 0, 0.5, 1]
const f = x.tickFormat(5, "+%");
T.map(f); // ["−100%", "−50%", "+0%", "+50%", "+100%"]If specifier uses the format type s, the scale will return a SI-prefix format based on the largest value in the domain. If the specifier already specifies a precision, this method is equivalent to locale.format.See also d3.tickFormat.linear.nice(count) ​Examples · Source · Extends the domain so that it starts and ends on nice round values.jsconst x = d3.scaleLinear([0.241079, 0.969679], [0, 960]).nice();
x.domain(); // [0.2, 1]This method typically modifies the scale’s domain, and may only extend the bounds to the nearest round value. Nicing is useful if the domain is computed from data, say using extent, and may be irregular. If the domain has more than two values, nicing the domain only affects the first and last value.An optional tick count argument allows greater control over the step size used to extend the bounds, guaranteeing that the returned ticks will exactly cover the domain.jsconst x = d3.scaleLinear([0.241079, 0.969679], [0, 960]).nice(40);
x.domain(); // [0.24, 0.98]Nicing a scale only modifies the current domain; it does not automatically nice domains that are subsequently set using linear.domain. You must re-nice the scale after setting the new domain, if desired.linear.copy() ​Examples · Source · Returns an exact copy of this scale.jsconst x1 = d3.scaleLinear([0, 100], ["red", "blue"]);
const x2 = x1.copy();Changes to this scale will not affect the returned scale, and vice versa.tickFormat(start, stop, count, specifier) ​Examples · Source · Returns a number format function suitable for displaying a tick value, automatically computing the appropriate precision based on the fixed interval between tick values, as determined by d3.tickStep.jsconst f = d3.tickFormat(0, 1, 20);
f(1); // "1.00"An optional specifier allows a custom format where the precision of the format is automatically set by the scale as appropriate for the tick interval. For example, to format percentage change, you might say:jsconst f = d3.tickFormat(-1, 1, 5, "+%");
f(-0.5); // "-50%"If specifier uses the format type s, the scale will return a SI-prefix format based on the larger absolute value of start and stop. If the specifier already specifies a precision, this method is equivalent to locale.format.scaleIdentity(range) ​Examples · Source · Constructs a new identity scale with the specified range (and by extension, domain).jsconst x = d3.scaleIdentity([0, 960]);Identity scales are a special case of linear scales where the domain and range are identical; the scale and its invert method are thus the identity function. These scales are occasionally useful when working with pixel coordinates, say in conjunction with an axis. Identity scales do not support rangeRound, clamp or interpolate.If range is not specified, it defaults to [0, 1].scaleRadial(domain, range) ​Examples · Source · Constructs a new radial scale with the specified domain and range.jsconst r = d3.scaleRadial([100, 200], [0, 480]);Radial scales are a variant of linear scales where the range is internally squared so that an input value corresponds linearly to the squared output value. These scales are useful when you want the input value to correspond to the area of a graphical mark and the mark is specified by radius, as in a radial bar chart. Radial scales do not support interpolate.If domain or range is not specified, each defaults to [0, 1].\n\nSearchK7.9.0GitHub️ 110.0kOn this pageLinear scales ​Linear scales map a continuous, quantitative input domain to a continuous output range using a linear transformation (translate and scale). If the range is also numeric, the mapping may be inverted. Linear scales are a good default choice for continuous quantitative data because they preserve proportional differences. Each range value y can be expressed as a function of the domain value x: y = mx + b.scaleLinear(domain, range) ​Examples · Source · Constructs a new linear scale with the specified domain and range, the default interpolator, and clamping disabled.jsd3.scaleLinear([0, 100], ["red", "blue"])If a single argument is specified, it is interpreted as the range. If either domain or range are not specified, each defaults to [0, 1].jsd3.scaleLinear(["red", "blue"]) // default domain of [0, 1]linear(value) ​Examples · Source · Given a value from the domain, returns the corresponding value from the range. For example, to apply a position encoding:jsconst x = d3.scaleLinear([10, 130], [0, 960]);
x(20); // 80
x(50); // 320To apply a color encoding:jsconst color = d3.scaleLinear([10, 100], ["brown", "steelblue"]);
color(20); // "rgb(154, 52, 57)"
color(50); // "rgb(123, 81, 103)"If the given value is outside the domain, and clamping is not enabled, the mapping will be extrapolated such that the returned value is outside the range.linear.invert(value) ​Examples · Source · Given a value from the range, returns the corresponding value from the domain. Inversion is useful for interaction, say to determine the data value corresponding to the position of the mouse. For example, to invert a position encoding:jsconst x = d3.scaleLinear([10, 130], [0, 960]);
x.invert(80); // 20
x.invert(320); // 50If the given value is outside the range, and clamping is not enabled, the mapping may be extrapolated such that the returned value is outside the domain. This method is only supported if the range is numeric. If the range is not numeric, returns NaN.For a valid value y in the range, linear(linear.invert(y)) approximately equals y; similarly, for a valid value x in the domain, linear.invert(linear(x)) approximately equals x. The scale and its inverse may not be exact due to the limitations of floating point precision.linear.domain(domain) ​Examples · Source · If domain is specified, sets the scale’s domain to the specified array of numbers and returns this scale.jsconst x = d3.scaleLinear().domain([10, 130]);The array must contain two or more elements. If the elements in the given array are not numbers, they will be coerced to numbers.Although continuous scales typically have two values each in their domain and range, specifying more than two values produces a piecewise scale. For example, to create a diverging color scale that interpolates between white and red for negative values, and white and green for positive values, say:jsconst color = d3.scaleLinear([-1, 0, 1], ["red", "white", "green"]);
color(-0.5); // "rgb(255, 128, 128)"
color(+0.5); // "rgb(128, 192, 128)"Internally, a piecewise scale performs a binary search for the range interpolator corresponding to the given domain value. Thus, the domain must be in ascending or descending order. If the domain and range have different lengths N and M, only the first min(N,M) elements in each are observed.If domain is not specified, returns a copy of the scale’s current domain.jscolor.domain() // [-1, 0, 1]linear.range(range) ​Examples · Source · If range is specified, sets the scale’s range to the specified array of values and returns this scale.jsconst x = d3.scaleLinear().range([0, 960]);The array must contain two or more elements. Unlike the domain, elements in the given array need not be numbers; any value that is supported by the underlying interpolator will work, though note that numeric ranges are required for invert.If range is not specified, returns a copy of the scale’s current range.jsx.range() // [0, 960]See linear.interpolate for more examples.linear.rangeRound(range) ​Examples · Source · Sets the scale’s range to the specified array of values while also setting the scale’s interpolator to interpolateRound; returns this scale.jsconst x = d3.scaleLinear().rangeRound([0, 960]);This is a convenience method equivalent to:jslinear.range(range).interpolate(d3.interpolateRound)The rounding interpolator is sometimes useful for avoiding antialiasing artifacts, though also consider the shape-rendering “crispEdges” styles. Note that this interpolator can only be used with numeric ranges.linear.clamp(clamp) ​Examples · Source · If clamp is specified, enables or disables clamping accordingly; returns this scale.jsconst x = d3.scaleLinear([0, 960]).clamp(true);If clamping is disabled and the scale is passed a value outside the domain, the scale may return a value outside the range through extrapolation. If clamping is enabled, the return value of the scale is always within the scale’s range. Clamping similarly applies to linear.invert. For example:jsconst x = d3.scaleLinear([10, 130], [0, 960]); // clamping disabled by default
x(-10); // -160, outside range
x.invert(-160); // -10, outside domain
x.clamp(true); // enable clamping
x(-10); // 0, clamped to range
x.invert(-160); // 10, clamped to domainIf clamp is not specified, returns whether or not the scale currently clamps values to within the range.jsx.clamp() // true, perhapslinear.unknown(value) ​Examples · Source · If value is specified, sets the output value of the scale for undefined or NaN input values and returns this scale. This is useful for specifying how missing or invalid data is displayed.jsconst color = d3.scaleLinear([0, 100], ["red", "blue"]).unknown("#ccc");
color(NaN); // "#ccc"If value is not specified, returns the current unknown value, which defaults to undefined.jscolor.unknown() // "#ccc"linear.interpolate(interpolate) ​Examples · Source · If interpolate is specified, sets the scale’s range interpolator factory.jsconst color = d3.scaleLinear(["red", "blue"]).interpolate(d3.interpolateHcl);The scale’s interpolator factory is used to create interpolators for each adjacent pair of values from the range; these interpolators then map a normalized domain parameter t in [0, 1] to the corresponding value in the range. If factory is not specified, returns the scale’s current interpolator factory, which defaults to d3.interpolate. See d3-interpolate for more interpolators.For example, consider a diverging color scale with three colors in the range:jsconst color = d3.scaleLinear([-100, 0, +100], ["red", "white", "green"]);Two interpolators are created internally by the scale, equivalent to:jsconst i0 = d3.interpolate("red", "white");
const i1 = d3.interpolate("white", "green");A common reason to specify a custom interpolator is to change the color space of interpolation. For example, to use HCL:jsconst color = d3.scaleLinear()
    .domain([10, 100])
    .range(["brown", "steelblue"])
    .interpolate(d3.interpolateHcl);Or for Cubehelix with a custom gamma:jsconst color = d3.scaleLinear()
    .domain([10, 100])
    .range(["brown", "steelblue"])
    .interpolate(d3.interpolateCubehelix.gamma(3));CAUTIONThe default interpolator may reuse return values. For example, if the range values are objects, then the value interpolator always returns the same object, modifying it in-place. If the scale is used to set an attribute or style, this is typically acceptable (and desirable for performance); however, if you need to store the scale’s return value, you must specify your own interpolator or make a copy as appropriate.linear.ticks(count) ​Examples · Source · Returns approximately count representative values from the scale’s domain.jsconst x = d3.scaleLinear([10, 100], ["red", "blue"]);
x.ticks(); // [10, 20, 30, 40, 50, 60, 70, 80, 90, 100]If count is not specified, it defaults to 10. The returned tick values are uniformly spaced, have human-readable values (such as multiples of powers of 10), and are guaranteed to be within the extent of the domain. Ticks are often used to display reference lines, or tick marks, in conjunction with the visualized data. The specified count is only a hint; the scale may return more or fewer values depending on the domain. See also d3-array’s ticks.linear.tickFormat(count, specifier) ​Examples · Source · Returns a number format function suitable for displaying a tick value, automatically computing the appropriate precision based on the fixed interval between tick values. The specified count should have the same value as the count that is used to generate the tick values.jsconst x = d3.scaleLinear([0.1, 1], ["red", "blue"]);
const f = x.tickFormat();
f(0.1); // "0.1"
f(1); // "1.0"An optional specifier allows a custom format where the precision of the format is automatically set by the scale as appropriate for the tick interval. For example, to format percentage change, you might say:jsconst x = d3.scaleLinear([-1, 1], [0, 960]);
const T = x.ticks(5); // [-1, -0.5, 0, 0.5, 1]
const f = x.tickFormat(5, "+%");
T.map(f); // ["−100%", "−50%", "+0%", "+50%", "+100%"]If specifier uses the format type s, the scale will return a SI-prefix format based on the largest value in the domain. If the specifier already specifies a precision, this method is equivalent to locale.format.See also d3.tickFormat.linear.nice(count) ​Examples · Source · Extends the domain so that it starts and ends on nice round values.jsconst x = d3.scaleLinear([0.241079, 0.969679], [0, 960]).nice();
x.domain(); // [0.2, 1]This method typically modifies the scale’s domain, and may only extend the bounds to the nearest round value. Nicing is useful if the domain is computed from data, say using extent, and may be irregular. If the domain has more than two values, nicing the domain only affects the first and last value.An optional tick count argument allows greater control over the step size used to extend the bounds, guaranteeing that the returned ticks will exactly cover the domain.jsconst x = d3.scaleLinear([0.241079, 0.969679], [0, 960]).nice(40);
x.domain(); // [0.24, 0.98]Nicing a scale only modifies the current domain; it does not automatically nice domains that are subsequently set using linear.domain. You must re-nice the scale after setting the new domain, if desired.linear.copy() ​Examples · Source · Returns an exact copy of this scale.jsconst x1 = d3.scaleLinear([0, 100], ["red", "blue"]);
const x2 = x1.copy();Changes to this scale will not affect the returned scale, and vice versa.tickFormat(start, stop, count, specifier) ​Examples · Source · Returns a number format function suitable for displaying a tick value, automatically computing the appropriate precision based on the fixed interval between tick values, as determined by d3.tickStep.jsconst f = d3.tickFormat(0, 1, 20);
f(1); // "1.00"An optional specifier allows a custom format where the precision of the format is automatically set by the scale as appropriate for the tick interval. For example, to format percentage change, you might say:jsconst f = d3.tickFormat(-1, 1, 5, "+%");
f(-0.5); // "-50%"If specifier uses the format type s, the scale will return a SI-prefix format based on the larger absolute value of start and stop. If the specifier already specifies a precision, this method is equivalent to locale.format.scaleIdentity(range) ​Examples · Source · Constructs a new identity scale with the specified range (and by extension, domain).jsconst x = d3.scaleIdentity([0, 960]);Identity scales are a special case of linear scales where the domain and range are identical; the scale and its invert method are thus the identity function. These scales are occasionally useful when working with pixel coordinates, say in conjunction with an axis. Identity scales do not support rangeRound, clamp or interpolate.If range is not specified, it defaults to [0, 1].scaleRadial(domain, range) ​Examples · Source · Constructs a new radial scale with the specified domain and range.jsconst r = d3.scaleRadial([100, 200], [0, 480]);Radial scales are a variant of linear scales where the range is internally squared so that an input value corresponds linearly to the squared output value. These scales are useful when you want the input value to correspond to the area of a graphical mark and the mark is specified by radius, as in a radial bar chart. Radial scales do not support interpolate.If domain or range is not specified, each defaults to [0, 1].PagerPrevious paged3-scaleNext pageTime scales\n\nLinear scales ​Linear scales map a continuous, quantitative input domain to a continuous output range using a linear transformation (translate and scale). If the range is also numeric, the mapping may be inverted. Linear scales are a good default choice for continuous quantitative data because they preserve proportional differences. Each range value y can be expressed as a function of the domain value x: y = mx + b.scaleLinear(domain, range) ​Examples · Source · Constructs a new linear scale with the specified domain and range, the default interpolator, and clamping disabled.jsd3.scaleLinear([0, 100], ["red", "blue"])If a single argument is specified, it is interpreted as the range. If either domain or range are not specified, each defaults to [0, 1].jsd3.scaleLinear(["red", "blue"]) // default domain of [0, 1]linear(value) ​Examples · Source · Given a value from the domain, returns the corresponding value from the range. For example, to apply a position encoding:jsconst x = d3.scaleLinear([10, 130], [0, 960]);
x(20); // 80
x(50); // 320To apply a color encoding:jsconst color = d3.scaleLinear([10, 100], ["brown", "steelblue"]);
color(20); // "rgb(154, 52, 57)"
color(50); // "rgb(123, 81, 103)"If the given value is outside the domain, and clamping is not enabled, the mapping will be extrapolated such that the returned value is outside the range.linear.invert(value) ​Examples · Source · Given a value from the range, returns the corresponding value from the domain. Inversion is useful for interaction, say to determine the data value corresponding to the position of the mouse. For example, to invert a position encoding:jsconst x = d3.scaleLinear([10, 130], [0, 960]);
x.invert(80); // 20
x.invert(320); // 50If the given value is outside the range, and clamping is not enabled, the mapping may be extrapolated such that the returned value is outside the domain. This method is only supported if the range is numeric. If the range is not numeric, returns NaN.For a valid value y in the range, linear(linear.invert(y)) approximately equals y; similarly, for a valid value x in the domain, linear.invert(linear(x)) approximately equals x. The scale and its inverse may not be exact due to the limitations of floating point precision.linear.domain(domain) ​Examples · Source · If domain is specified, sets the scale’s domain to the specified array of numbers and returns this scale.jsconst x = d3.scaleLinear().domain([10, 130]);The array must contain two or more elements. If the elements in the given array are not numbers, they will be coerced to numbers.Although continuous scales typically have two values each in their domain and range, specifying more than two values produces a piecewise scale. For example, to create a diverging color scale that interpolates between white and red for negative values, and white and green for positive values, say:jsconst color = d3.scaleLinear([-1, 0, 1], ["red", "white", "green"]);
color(-0.5); // "rgb(255, 128, 128)"
color(+0.5); // "rgb(128, 192, 128)"Internally, a piecewise scale performs a binary search for the range interpolator corresponding to the given domain value. Thus, the domain must be in ascending or descending order. If the domain and range have different lengths N and M, only the first min(N,M) elements in each are observed.If domain is not specified, returns a copy of the scale’s current domain.jscolor.domain() // [-1, 0, 1]linear.range(range) ​Examples · Source · If range is specified, sets the scale’s range to the specified array of values and returns this scale.jsconst x = d3.scaleLinear().range([0, 960]);The array must contain two or more elements. Unlike the domain, elements in the given array need not be numbers; any value that is supported by the underlying interpolator will work, though note that numeric ranges are required for invert.If range is not specified, returns a copy of the scale’s current range.jsx.range() // [0, 960]See linear.interpolate for more examples.linear.rangeRound(range) ​Examples · Source · Sets the scale’s range to the specified array of values while also setting the scale’s interpolator to interpolateRound; returns this scale.jsconst x = d3.scaleLinear().rangeRound([0, 960]);This is a convenience method equivalent to:jslinear.range(range).interpolate(d3.interpolateRound)The rounding interpolator is sometimes useful for avoiding antialiasing artifacts, though also consider the shape-rendering “crispEdges” styles. Note that this interpolator can only be used with numeric ranges.linear.clamp(clamp) ​Examples · Source · If clamp is specified, enables or disables clamping accordingly; returns this scale.jsconst x = d3.scaleLinear([0, 960]).clamp(true);If clamping is disabled and the scale is passed a value outside the domain, the scale may return a value outside the range through extrapolation. If clamping is enabled, the return value of the scale is always within the scale’s range. Clamping similarly applies to linear.invert. For example:jsconst x = d3.scaleLinear([10, 130], [0, 960]); // clamping disabled by default
x(-10); // -160, outside range
x.invert(-160); // -10, outside domain
x.clamp(true); // enable clamping
x(-10); // 0, clamped to range
x.invert(-160); // 10, clamped to domainIf clamp is not specified, returns whether or not the scale currently clamps values to within the range.jsx.clamp() // true, perhapslinear.unknown(value) ​Examples · Source · If value is specified, sets the output value of the scale for undefined or NaN input values and returns this scale. This is useful for specifying how missing or invalid data is displayed.jsconst color = d3.scaleLinear([0, 100], ["red", "blue"]).unknown("#ccc");
color(NaN); // "#ccc"If value is not specified, returns the current unknown value, which defaults to undefined.jscolor.unknown() // "#ccc"linear.interpolate(interpolate) ​Examples · Source · If interpolate is specified, sets the scale’s range interpolator factory.jsconst color = d3.scaleLinear(["red", "blue"]).interpolate(d3.interpolateHcl);The scale’s interpolator factory is used to create interpolators for each adjacent pair of values from the range; these interpolators then map a normalized domain parameter t in [0, 1] to the corresponding value in the range. If factory is not specified, returns the scale’s current interpolator factory, which defaults to d3.interpolate. See d3-interpolate for more interpolators.For example, consider a diverging color scale with three colors in the range:jsconst color = d3.scaleLinear([-100, 0, +100], ["red", "white", "green"]);Two interpolators are created internally by the scale, equivalent to:jsconst i0 = d3.interpolate("red", "white");
const i1 = d3.interpolate("white", "green");A common reason to specify a custom interpolator is to change the color space of interpolation. For example, to use HCL:jsconst color = d3.scaleLinear()
    .domain([10, 100])
    .range(["brown", "steelblue"])
    .interpolate(d3.interpolateHcl);Or for Cubehelix with a custom gamma:jsconst color = d3.scaleLinear()
    .domain([10, 100])
    .range(["brown", "steelblue"])
    .interpolate(d3.interpolateCubehelix.gamma(3));CAUTIONThe default interpolator may reuse return values. For example, if the range values are objects, then the value interpolator always returns the same object, modifying it in-place. If the scale is used to set an attribute or style, this is typically acceptable (and desirable for performance); however, if you need to store the scale’s return value, you must specify your own interpolator or make a copy as appropriate.linear.ticks(count) ​Examples · Source · Returns approximately count representative values from the scale’s domain.jsconst x = d3.scaleLinear([10, 100], ["red", "blue"]);
x.ticks(); // [10, 20, 30, 40, 50, 60, 70, 80, 90, 100]If count is not specified, it defaults to 10. The returned tick values are uniformly spaced, have human-readable values (such as multiples of powers of 10), and are guaranteed to be within the extent of the domain. Ticks are often used to display reference lines, or tick marks, in conjunction with the visualized data. The specified count is only a hint; the scale may return more or fewer values depending on the domain. See also d3-array’s ticks.linear.tickFormat(count, specifier) ​Examples · Source · Returns a number format function suitable for displaying a tick value, automatically computing the appropriate precision based on the fixed interval between tick values. The specified count should have the same value as the count that is used to generate the tick values.jsconst x = d3.scaleLinear([0.1, 1], ["red", "blue"]);
const f = x.tickFormat();
f(0.1); // "0.1"
f(1); // "1.0"An optional specifier allows a custom format where the precision of the format is automatically set by the scale as appropriate for the tick interval. For example, to format percentage change, you might say:jsconst x = d3.scaleLinear([-1, 1], [0, 960]);
const T = x.ticks(5); // [-1, -0.5, 0, 0.5, 1]
const f = x.tickFormat(5, "+%");
T.map(f); // ["−100%", "−50%", "+0%", "+50%", "+100%"]If specifier uses the format type s, the scale will return a SI-prefix format based on the largest value in the domain. If the specifier already specifies a precision, this method is equivalent to locale.format.See also d3.tickFormat.linear.nice(count) ​Examples · Source · Extends the domain so that it starts and ends on nice round values.jsconst x = d3.scaleLinear([0.241079, 0.969679], [0, 960]).nice();
x.domain(); // [0.2, 1]This method typically modifies the scale’s domain, and may only extend the bounds to the nearest round value. Nicing is useful if the domain is computed from data, say using extent, and may be irregular. If the domain has more than two values, nicing the domain only affects the first and last value.An optional tick count argument allows greater control over the step size used to extend the bounds, guaranteeing that the returned ticks will exactly cover the domain.jsconst x = d3.scaleLinear([0.241079, 0.969679], [0, 960]).nice(40);
x.domain(); // [0.24, 0.98]Nicing a scale only modifies the current domain; it does not automatically nice domains that are subsequently set using linear.domain. You must re-nice the scale after setting the new domain, if desired.linear.copy() ​Examples · Source · Returns an exact copy of this scale.jsconst x1 = d3.scaleLinear([0, 100], ["red", "blue"]);
const x2 = x1.copy();Changes to this scale will not affect the returned scale, and vice versa.tickFormat(start, stop, count, specifier) ​Examples · Source · Returns a number format function suitable for displaying a tick value, automatically computing the appropriate precision based on the fixed interval between tick values, as determined by d3.tickStep.jsconst f = d3.tickFormat(0, 1, 20);
f(1); // "1.00"An optional specifier allows a custom format where the precision of the format is automatically set by the scale as appropriate for the tick interval. For example, to format percentage change, you might say:jsconst f = d3.tickFormat(-1, 1, 5, "+%");
f(-0.5); // "-50%"If specifier uses the format type s, the scale will return a SI-prefix format based on the larger absolute value of start and stop. If the specifier already specifies a precision, this method is equivalent to locale.format.scaleIdentity(range) ​Examples · Source · Constructs a new identity scale with the specified range (and by extension, domain).jsconst x = d3.scaleIdentity([0, 960]);Identity scales are a special case of linear scales where the domain and range are identical; the scale and its invert method are thus the identity function. These scales are occasionally useful when working with pixel coordinates, say in conjunction with an axis. Identity scales do not support rangeRound, clamp or interpolate.If range is not specified, it defaults to [0, 1].scaleRadial(domain, range) ​Examples · Source · Constructs a new radial scale with the specified domain and range.jsconst r = d3.scaleRadial([100, 200], [0, 480]);Radial scales are a variant of linear scales where the range is internally squared so that an input value corresponds linearly to the squared output value. These scales are useful when you want the input value to correspond to the area of a graphical mark and the mark is specified by radius, as in a radial bar chart. Radial scales do not support interpolate.If domain or range is not specified, each defaults to [0, 1].\n\n\n\nTime scales ​Time scales are a variant of linear scales that have a temporal domain: domain values are coerced to dates rather than numbers, and invert likewise returns a date. Time scales implement ticks based on calendar intervals, taking the pain out of generating axes for temporal domains.scaleTime(domain, range) ​Examples · Source · Constructs a new time scale with the specified domain and range, the default interpolator and clamping disabled. For example, to create a position encoding:jsconst x = d3.scaleTime([new Date(2000, 0, 1), new Date(2000, 0, 2)], [0, 960]);
x(new Date(2000, 0, 1, 5)); // 200
x(new Date(2000, 0, 1, 16)); // 640
x.invert(200); // Sat Jan 01 2000 05:00:00 GMT-0800 (PST)
x.invert(640); // Sat Jan 01 2000 16:00:00 GMT-0800 (PST)If domain is not specified, it defaults to [2000-01-01, 2000-01-02] in local time. If range is not specified, it defaults to [0, 1].scaleUtc(domain, range) ​Examples · Source · Equivalent to scaleTime, but the returned time scale operates in Coordinated Universal Time rather than local time. For example, to create a position encoding:jsconst x = d3.scaleUtc([new Date("2000-01-01"), new Date("2000-01-02")], [0, 960]);
x(new Date("2000-01-01T05:00Z")); // 200
x(new Date("2000-01-01T16:00Z")); // 640
x.invert(200); // 2000-01-01T05:00Z
x.invert(640); // 2000-01-01T16:00ZIf domain is not specified, it defaults to [2000-01-01, 2000-01-02] in UTC time. If range is not specified, it defaults to [0, 1].TIPA UTC scale should be preferred when possible as it behaves more predictably: days are always twenty-four hours and the scale does not depend on the browser’s time zone.time.ticks(count) ​Examples · Source · Returns representative dates from the scale’s domain.jsconst x = d3.scaleTime();
x.ticks(10);
// [Sat Jan 01 2000 00:00:00 GMT-0800 (PST),
//  Sat Jan 01 2000 03:00:00 GMT-0800 (PST),
//  Sat Jan 01 2000 06:00:00 GMT-0800 (PST),
//  Sat Jan 01 2000 09:00:00 GMT-0800 (PST),
//  Sat Jan 01 2000 12:00:00 GMT-0800 (PST),
//  Sat Jan 01 2000 15:00:00 GMT-0800 (PST),
//  Sat Jan 01 2000 18:00:00 GMT-0800 (PST),
//  Sat Jan 01 2000 21:00:00 GMT-0800 (PST),
//  Sun Jan 02 2000 00:00:00 GMT-0800 (PST)]The returned tick values are uniformly-spaced (mostly), have sensible values (such as every day at midnight), and are guaranteed to be within the extent of the domain. Ticks are often used to display reference lines, or tick marks, in conjunction with the visualized data.An optional count may be specified to affect how many ticks are generated. If count is not specified, it defaults to 10. The specified count is only a hint; the scale may return more or fewer values depending on the domain.The following time intervals are considered for automatic ticks:1-, 5-, 15- and 30-second.1-, 5-, 15- and 30-minute.1-, 3-, 6- and 12-hour.1- and 2-day.1-week.1- and 3-month.1-year.In lieu of a count, a time interval may be explicitly specified. To prune the generated ticks for a given time interval, use interval.every. For example, to generate ticks at 15-minute intervals:jsconst x = d3.scaleUtc().domain([new Date("2000-01-01T00:00Z"), new Date("2000-01-01T02:00Z")]);
x.ticks(d3.utcMinute.every(15));
// [2000-01-01T00:00Z,
//  2000-01-01T00:15Z,
//  2000-01-01T00:30Z,
//  2000-01-01T00:45Z,
//  2000-01-01T01:00Z,
//  2000-01-01T01:15Z,
//  2000-01-01T01:30Z,
//  2000-01-01T01:45Z,
//  2000-01-01T02:00Z]Note: in some cases, such as with day ticks, specifying a step can result in irregular spacing of ticks because time intervals have varying length.time.tickFormat(count, specifier) ​Examples · Source · Returns a time format function suitable for displaying tick values.jsconst x = d3.scaleUtc().domain([new Date("2000-01-01T00:00Z"), new Date("2000-01-01T02:00Z")]);
const T = x.ticks(); // [2000-01-01T00:00Z, 2000-01-01T00:15Z, 2000-01-01T00:30Z, …]
const f = x.tickFormat();
T.map(f); // ["2000", "12:15", "12:30", "12:45", "01 AM", "01:15", "01:30", "01:45", "02 AM"]The specified count is currently ignored, but is accepted for consistency with other scales such as linear.tickFormat. If a format specifier is specified, this method is equivalent to format. If specifier is not specified, the default time format is returned. The default multi-scale time format chooses a human-readable representation based on the specified date as follows:%Y - for year boundaries, such as 2011.%B - for month boundaries, such as February.%b %d - for week boundaries, such as Feb 06.%a %d - for day boundaries, such as Mon 07.%I %p - for hour boundaries, such as 01 AM.%I:%M - for minute boundaries, such as 01:23.:%S - for second boundaries, such as :45..%L - milliseconds for all other times, such as .012.Although somewhat unusual, this default behavior has the benefit of providing both local and global context: for example, formatting a sequence of ticks as [11 PM, Mon 07, 01 AM] reveals information about hours, dates, and day simultaneously, rather than just the hours [11 PM, 12 AM, 01 AM]. See d3-time-format if you’d like to roll your own conditional time format.time.nice(count) ​Examples · Source · Extends the domain so that it starts and ends on nice round values.jsconst x = d3.scaleUtc().domain([new Date("2000-01-01T12:34Z"), new Date("2000-01-01T12:59Z")]).nice();
x.domain(); // [2000-01-01T12:30Z, 2000-01-01T13:00Z]This method typically modifies the scale’s domain, and may only extend the bounds to the nearest round value. See linear.nice for more.An optional tick count argument allows greater control over the step size used to extend the bounds, guaranteeing that the returned ticks will exactly cover the domain. Alternatively, a time interval may be specified to explicitly set the ticks. If an interval is specified, an optional step may also be specified to skip some ticks. For example, time.nice(d3.utcSecond.every(10)) will extend the domain to an even ten seconds (0, 10, 20, etc.). See time.ticks and interval.every for further detail.Nicing is useful if the domain is computed from data, say using extent, and may be irregular. For example, for a domain of [2009-07-13T00:02, 2009-07-13T23:48], the nice domain is [2009-07-13, 2009-07-14]. If the domain has more than two values, nicing the domain only affects the first and last value.\n\nSearchK7.9.0GitHub️ 110.0kOn this pageTime scales ​Time scales are a variant of linear scales that have a temporal domain: domain values are coerced to dates rather than numbers, and invert likewise returns a date. Time scales implement ticks based on calendar intervals, taking the pain out of generating axes for temporal domains.scaleTime(domain, range) ​Examples · Source · Constructs a new time scale with the specified domain and range, the default interpolator and clamping disabled. For example, to create a position encoding:jsconst x = d3.scaleTime([new Date(2000, 0, 1), new Date(2000, 0, 2)], [0, 960]);
x(new Date(2000, 0, 1, 5)); // 200
x(new Date(2000, 0, 1, 16)); // 640
x.invert(200); // Sat Jan 01 2000 05:00:00 GMT-0800 (PST)
x.invert(640); // Sat Jan 01 2000 16:00:00 GMT-0800 (PST)If domain is not specified, it defaults to [2000-01-01, 2000-01-02] in local time. If range is not specified, it defaults to [0, 1].scaleUtc(domain, range) ​Examples · Source · Equivalent to scaleTime, but the returned time scale operates in Coordinated Universal Time rather than local time. For example, to create a position encoding:jsconst x = d3.scaleUtc([new Date("2000-01-01"), new Date("2000-01-02")], [0, 960]);
x(new Date("2000-01-01T05:00Z")); // 200
x(new Date("2000-01-01T16:00Z")); // 640
x.invert(200); // 2000-01-01T05:00Z
x.invert(640); // 2000-01-01T16:00ZIf domain is not specified, it defaults to [2000-01-01, 2000-01-02] in UTC time. If range is not specified, it defaults to [0, 1].TIPA UTC scale should be preferred when possible as it behaves more predictably: days are always twenty-four hours and the scale does not depend on the browser’s time zone.time.ticks(count) ​Examples · Source · Returns representative dates from the scale’s domain.jsconst x = d3.scaleTime();
x.ticks(10);
// [Sat Jan 01 2000 00:00:00 GMT-0800 (PST),
//  Sat Jan 01 2000 03:00:00 GMT-0800 (PST),
//  Sat Jan 01 2000 06:00:00 GMT-0800 (PST),
//  Sat Jan 01 2000 09:00:00 GMT-0800 (PST),
//  Sat Jan 01 2000 12:00:00 GMT-0800 (PST),
//  Sat Jan 01 2000 15:00:00 GMT-0800 (PST),
//  Sat Jan 01 2000 18:00:00 GMT-0800 (PST),
//  Sat Jan 01 2000 21:00:00 GMT-0800 (PST),
//  Sun Jan 02 2000 00:00:00 GMT-0800 (PST)]The returned tick values are uniformly-spaced (mostly), have sensible values (such as every day at midnight), and are guaranteed to be within the extent of the domain. Ticks are often used to display reference lines, or tick marks, in conjunction with the visualized data.An optional count may be specified to affect how many ticks are generated. If count is not specified, it defaults to 10. The specified count is only a hint; the scale may return more or fewer values depending on the domain.The following time intervals are considered for automatic ticks:1-, 5-, 15- and 30-second.1-, 5-, 15- and 30-minute.1-, 3-, 6- and 12-hour.1- and 2-day.1-week.1- and 3-month.1-year.In lieu of a count, a time interval may be explicitly specified. To prune the generated ticks for a given time interval, use interval.every. For example, to generate ticks at 15-minute intervals:jsconst x = d3.scaleUtc().domain([new Date("2000-01-01T00:00Z"), new Date("2000-01-01T02:00Z")]);
x.ticks(d3.utcMinute.every(15));
// [2000-01-01T00:00Z,
//  2000-01-01T00:15Z,
//  2000-01-01T00:30Z,
//  2000-01-01T00:45Z,
//  2000-01-01T01:00Z,
//  2000-01-01T01:15Z,
//  2000-01-01T01:30Z,
//  2000-01-01T01:45Z,
//  2000-01-01T02:00Z]Note: in some cases, such as with day ticks, specifying a step can result in irregular spacing of ticks because time intervals have varying length.time.tickFormat(count, specifier) ​Examples · Source · Returns a time format function suitable for displaying tick values.jsconst x = d3.scaleUtc().domain([new Date("2000-01-01T00:00Z"), new Date("2000-01-01T02:00Z")]);
const T = x.ticks(); // [2000-01-01T00:00Z, 2000-01-01T00:15Z, 2000-01-01T00:30Z, …]
const f = x.tickFormat();
T.map(f); // ["2000", "12:15", "12:30", "12:45", "01 AM", "01:15", "01:30", "01:45", "02 AM"]The specified count is currently ignored, but is accepted for consistency with other scales such as linear.tickFormat. If a format specifier is specified, this method is equivalent to format. If specifier is not specified, the default time format is returned. The default multi-scale time format chooses a human-readable representation based on the specified date as follows:%Y - for year boundaries, such as 2011.%B - for month boundaries, such as February.%b %d - for week boundaries, such as Feb 06.%a %d - for day boundaries, such as Mon 07.%I %p - for hour boundaries, such as 01 AM.%I:%M - for minute boundaries, such as 01:23.:%S - for second boundaries, such as :45..%L - milliseconds for all other times, such as .012.Although somewhat unusual, this default behavior has the benefit of providing both local and global context: for example, formatting a sequence of ticks as [11 PM, Mon 07, 01 AM] reveals information about hours, dates, and day simultaneously, rather than just the hours [11 PM, 12 AM, 01 AM]. See d3-time-format if you’d like to roll your own conditional time format.time.nice(count) ​Examples · Source · Extends the domain so that it starts and ends on nice round values.jsconst x = d3.scaleUtc().domain([new Date("2000-01-01T12:34Z"), new Date("2000-01-01T12:59Z")]).nice();
x.domain(); // [2000-01-01T12:30Z, 2000-01-01T13:00Z]This method typically modifies the scale’s domain, and may only extend the bounds to the nearest round value. See linear.nice for more.An optional tick count argument allows greater control over the step size used to extend the bounds, guaranteeing that the returned ticks will exactly cover the domain. Alternatively, a time interval may be specified to explicitly set the ticks. If an interval is specified, an optional step may also be specified to skip some ticks. For example, time.nice(d3.utcSecond.every(10)) will extend the domain to an even ten seconds (0, 10, 20, etc.). See time.ticks and interval.every for further detail.Nicing is useful if the domain is computed from data, say using extent, and may be irregular. For example, for a domain of [2009-07-13T00:02, 2009-07-13T23:48], the nice domain is [2009-07-13, 2009-07-14]. If the domain has more than two values, nicing the domain only affects the first and last value.PagerPrevious pageLinear scalesNext pagePow scales\n\nTime scales ​Time scales are a variant of linear scales that have a temporal domain: domain values are coerced to dates rather than numbers, and invert likewise returns a date. Time scales implement ticks based on calendar intervals, taking the pain out of generating axes for temporal domains.scaleTime(domain, range) ​Examples · Source · Constructs a new time scale with the specified domain and range, the default interpolator and clamping disabled. For example, to create a position encoding:jsconst x = d3.scaleTime([new Date(2000, 0, 1), new Date(2000, 0, 2)], [0, 960]);
x(new Date(2000, 0, 1, 5)); // 200
x(new Date(2000, 0, 1, 16)); // 640
x.invert(200); // Sat Jan 01 2000 05:00:00 GMT-0800 (PST)
x.invert(640); // Sat Jan 01 2000 16:00:00 GMT-0800 (PST)If domain is not specified, it defaults to [2000-01-01, 2000-01-02] in local time. If range is not specified, it defaults to [0, 1].scaleUtc(domain, range) ​Examples · Source · Equivalent to scaleTime, but the returned time scale operates in Coordinated Universal Time rather than local time. For example, to create a position encoding:jsconst x = d3.scaleUtc([new Date("2000-01-01"), new Date("2000-01-02")], [0, 960]);
x(new Date("2000-01-01T05:00Z")); // 200
x(new Date("2000-01-01T16:00Z")); // 640
x.invert(200); // 2000-01-01T05:00Z
x.invert(640); // 2000-01-01T16:00ZIf domain is not specified, it defaults to [2000-01-01, 2000-01-02] in UTC time. If range is not specified, it defaults to [0, 1].TIPA UTC scale should be preferred when possible as it behaves more predictably: days are always twenty-four hours and the scale does not depend on the browser’s time zone.time.ticks(count) ​Examples · Source · Returns representative dates from the scale’s domain.jsconst x = d3.scaleTime();
x.ticks(10);
// [Sat Jan 01 2000 00:00:00 GMT-0800 (PST),
//  Sat Jan 01 2000 03:00:00 GMT-0800 (PST),
//  Sat Jan 01 2000 06:00:00 GMT-0800 (PST),
//  Sat Jan 01 2000 09:00:00 GMT-0800 (PST),
//  Sat Jan 01 2000 12:00:00 GMT-0800 (PST),
//  Sat Jan 01 2000 15:00:00 GMT-0800 (PST),
//  Sat Jan 01 2000 18:00:00 GMT-0800 (PST),
//  Sat Jan 01 2000 21:00:00 GMT-0800 (PST),
//  Sun Jan 02 2000 00:00:00 GMT-0800 (PST)]The returned tick values are uniformly-spaced (mostly), have sensible values (such as every day at midnight), and are guaranteed to be within the extent of the domain. Ticks are often used to display reference lines, or tick marks, in conjunction with the visualized data.An optional count may be specified to affect how many ticks are generated. If count is not specified, it defaults to 10. The specified count is only a hint; the scale may return more or fewer values depending on the domain.The following time intervals are considered for automatic ticks:1-, 5-, 15- and 30-second.1-, 5-, 15- and 30-minute.1-, 3-, 6- and 12-hour.1- and 2-day.1-week.1- and 3-month.1-year.In lieu of a count, a time interval may be explicitly specified. To prune the generated ticks for a given time interval, use interval.every. For example, to generate ticks at 15-minute intervals:jsconst x = d3.scaleUtc().domain([new Date("2000-01-01T00:00Z"), new Date("2000-01-01T02:00Z")]);
x.ticks(d3.utcMinute.every(15));
// [2000-01-01T00:00Z,
//  2000-01-01T00:15Z,
//  2000-01-01T00:30Z,
//  2000-01-01T00:45Z,
//  2000-01-01T01:00Z,
//  2000-01-01T01:15Z,
//  2000-01-01T01:30Z,
//  2000-01-01T01:45Z,
//  2000-01-01T02:00Z]Note: in some cases, such as with day ticks, specifying a step can result in irregular spacing of ticks because time intervals have varying length.time.tickFormat(count, specifier) ​Examples · Source · Returns a time format function suitable for displaying tick values.jsconst x = d3.scaleUtc().domain([new Date("2000-01-01T00:00Z"), new Date("2000-01-01T02:00Z")]);
const T = x.ticks(); // [2000-01-01T00:00Z, 2000-01-01T00:15Z, 2000-01-01T00:30Z, …]
const f = x.tickFormat();
T.map(f); // ["2000", "12:15", "12:30", "12:45", "01 AM", "01:15", "01:30", "01:45", "02 AM"]The specified count is currently ignored, but is accepted for consistency with other scales such as linear.tickFormat. If a format specifier is specified, this method is equivalent to format. If specifier is not specified, the default time format is returned. The default multi-scale time format chooses a human-readable representation based on the specified date as follows:%Y - for year boundaries, such as 2011.%B - for month boundaries, such as February.%b %d - for week boundaries, such as Feb 06.%a %d - for day boundaries, such as Mon 07.%I %p - for hour boundaries, such as 01 AM.%I:%M - for minute boundaries, such as 01:23.:%S - for second boundaries, such as :45..%L - milliseconds for all other times, such as .012.Although somewhat unusual, this default behavior has the benefit of providing both local and global context: for example, formatting a sequence of ticks as [11 PM, Mon 07, 01 AM] reveals information about hours, dates, and day simultaneously, rather than just the hours [11 PM, 12 AM, 01 AM]. See d3-time-format if you’d like to roll your own conditional time format.time.nice(count) ​Examples · Source · Extends the domain so that it starts and ends on nice round values.jsconst x = d3.scaleUtc().domain([new Date("2000-01-01T12:34Z"), new Date("2000-01-01T12:59Z")]).nice();
x.domain(); // [2000-01-01T12:30Z, 2000-01-01T13:00Z]This method typically modifies the scale’s domain, and may only extend the bounds to the nearest round value. See linear.nice for more.An optional tick count argument allows greater control over the step size used to extend the bounds, guaranteeing that the returned ticks will exactly cover the domain. Alternatively, a time interval may be specified to explicitly set the ticks. If an interval is specified, an optional step may also be specified to skip some ticks. For example, time.nice(d3.utcSecond.every(10)) will extend the domain to an even ten seconds (0, 10, 20, etc.). See time.ticks and interval.every for further detail.Nicing is useful if the domain is computed from data, say using extent, and may be irregular. For example, for a domain of [2009-07-13T00:02, 2009-07-13T23:48], the nice domain is [2009-07-13, 2009-07-14]. If the domain has more than two values, nicing the domain only affects the first and last value.\n\n\n\nPower scales ​Power (“pow”) scales are similar to linear scales, except an exponential transform is applied to the input domain value before the output range value is computed. Each range value y can be expressed as a function of the domain value x: y = mx^k + b, where k is the exponent value. Power scales also support negative domain values, in which case the input value and the resulting output value are multiplied by -1.scalePow(domain, range) ​Examples · Source · Constructs a new pow scale with the specified domain and range, the exponent 1, the default interpolator and clamping disabled.jsconst x = d3.scalePow([0, 100], ["red", "blue"]).exponent(2);If either domain or range are not specified, each defaults to [0, 1].scaleSqrt(domain, range) ​Examples · Source · Constructs a new pow scale with the specified domain and range, the exponent 0.5, the default interpolator and clamping disabled.jsconst x = d3.scaleSqrt([0, 100], ["red", "blue"]);If either domain or range are not specified, each defaults to [0, 1]. This is a convenience method equivalent to d3.scalePow(…).exponent(0.5).pow.exponent(exponent) ​Examples · Source · If exponent is specified, sets the current exponent to the given numeric value and returns this scale.jsconst x = d3.scalePow([0, 100], ["red", "blue"]).exponent(2);If exponent is not specified, returns the current exponent, which defaults to 1.jsx.exponent() // 2If the exponent is 1, the pow scale is effectively a linear scale.\n\nSearchK7.9.0GitHub️ 110.0kOn this pagePower scales ​Power (“pow”) scales are similar to linear scales, except an exponential transform is applied to the input domain value before the output range value is computed. Each range value y can be expressed as a function of the domain value x: y = mx^k + b, where k is the exponent value. Power scales also support negative domain values, in which case the input value and the resulting output value are multiplied by -1.scalePow(domain, range) ​Examples · Source · Constructs a new pow scale with the specified domain and range, the exponent 1, the default interpolator and clamping disabled.jsconst x = d3.scalePow([0, 100], ["red", "blue"]).exponent(2);If either domain or range are not specified, each defaults to [0, 1].scaleSqrt(domain, range) ​Examples · Source · Constructs a new pow scale with the specified domain and range, the exponent 0.5, the default interpolator and clamping disabled.jsconst x = d3.scaleSqrt([0, 100], ["red", "blue"]);If either domain or range are not specified, each defaults to [0, 1]. This is a convenience method equivalent to d3.scalePow(…).exponent(0.5).pow.exponent(exponent) ​Examples · Source · If exponent is specified, sets the current exponent to the given numeric value and returns this scale.jsconst x = d3.scalePow([0, 100], ["red", "blue"]).exponent(2);If exponent is not specified, returns the current exponent, which defaults to 1.jsx.exponent() // 2If the exponent is 1, the pow scale is effectively a linear scale.PagerPrevious pageTime scalesNext pageLog scales\n\nPower scales ​Power (“pow”) scales are similar to linear scales, except an exponential transform is applied to the input domain value before the output range value is computed. Each range value y can be expressed as a function of the domain value x: y = mx^k + b, where k is the exponent value. Power scales also support negative domain values, in which case the input value and the resulting output value are multiplied by -1.scalePow(domain, range) ​Examples · Source · Constructs a new pow scale with the specified domain and range, the exponent 1, the default interpolator and clamping disabled.jsconst x = d3.scalePow([0, 100], ["red", "blue"]).exponent(2);If either domain or range are not specified, each defaults to [0, 1].scaleSqrt(domain, range) ​Examples · Source · Constructs a new pow scale with the specified domain and range, the exponent 0.5, the default interpolator and clamping disabled.jsconst x = d3.scaleSqrt([0, 100], ["red", "blue"]);If either domain or range are not specified, each defaults to [0, 1]. This is a convenience method equivalent to d3.scalePow(…).exponent(0.5).pow.exponent(exponent) ​Examples · Source · If exponent is specified, sets the current exponent to the given numeric value and returns this scale.jsconst x = d3.scalePow([0, 100], ["red", "blue"]).exponent(2);If exponent is not specified, returns the current exponent, which defaults to 1.jsx.exponent() // 2If the exponent is 1, the pow scale is effectively a linear scale.\n\n\n\nLogarithmic scales ​Logarithmic (“log”) scales are like linear scales except that a logarithmic transform is applied to the input domain value before the output range value is computed. The mapping to the range value y can be expressed as a function of the domain value x: y = m log(x) + b.CAUTIONAs log(0) = -∞, a log scale domain must be strictly-positive or strictly-negative; the domain must not include or cross zero. A log scale with a positive domain has a well-defined behavior for positive values, and a log scale with a negative domain has a well-defined behavior for negative values. (For a negative domain, input and output values are implicitly multiplied by -1.) The behavior of the scale is undefined if you pass a negative value to a log scale with a positive domain or vice versa.scaleLog(domain, range) ​Examples · Source · Constructs a new log scale with the specified domain and range, the base 10, the default interpolator and clamping disabled.jsconst x = d3.scaleLog([1, 10], [0, 960]);If domain is not specified, it defaults to [1, 10]. If range is not specified, it defaults to [0, 1].log.base(base) ​Examples · Source · If base is specified, sets the base for this logarithmic scale to the specified value.jsconst x = d3.scaleLog([1, 1024], [0, 960]).base(2);If base is not specified, returns the current base, which defaults to 10. Note that due to the nature of a logarithmic transform, the base does not affect the encoding of the scale; it only affects which ticks are chosen.log.ticks(count) ​Examples · Source · Like linear.ticks, but customized for a log scale.jsconst x = d3.scaleLog([1, 100], [0, 960]);
const T = x.ticks(); // [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100]If the base is an integer, the returned ticks are uniformly spaced within each integer power of base; otherwise, one tick per power of base is returned. The returned ticks are guaranteed to be within the extent of the domain. If the orders of magnitude in the domain is greater than count, then at most one tick per power is returned. Otherwise, the tick values are unfiltered, but note that you can use log.tickFormat to filter the display of tick labels. If count is not specified, it defaults to 10.log.tickFormat(count, specifier) ​Examples · Source · Like linear.tickFormat, but customized for a log scale. The specified count typically has the same value as the count that is used to generate the tick values.jsconst x = d3.scaleLog([1, 100], [0, 960]);
const T = x.ticks(); // [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, …]
const f = x.tickFormat();
T.map(f); // ["1", "2", "3", "4", "5", "", "", "", "", "10", …]If there are too many ticks, the formatter may return the empty string for some of the tick labels; however, note that the ticks are still shown to convey the logarithmic transform accurately. To disable filtering, specify a count of Infinity.When specifying a count, you may also provide a format specifier or format function. For example, to get a tick formatter that will display 20 ticks of a currency, say log.tickFormat(20, "$,f"). If the specifier does not have a defined precision, the precision will be set automatically by the scale, returning the appropriate format. This provides a convenient way of specifying a format whose precision will be automatically set by the scale.log.nice() ​Examples · Source · Like linear.nice, except extends the domain to integer powers of base.jsconst x = d3.scaleLog([0.201479, 0.996679], [0, 960]).nice();
x.domain(); // [0.1, 1]If the domain has more than two values, nicing the domain only affects the first and last value. Nicing a scale only modifies the current domain; it does not automatically nice domains that are subsequently set using log.domain. You must re-nice the scale after setting the new domain, if desired.\n\nSearchK7.9.0GitHub️ 110.0kOn this pageLogarithmic scales ​Logarithmic (“log”) scales are like linear scales except that a logarithmic transform is applied to the input domain value before the output range value is computed. The mapping to the range value y can be expressed as a function of the domain value x: y = m log(x) + b.CAUTIONAs log(0) = -∞, a log scale domain must be strictly-positive or strictly-negative; the domain must not include or cross zero. A log scale with a positive domain has a well-defined behavior for positive values, and a log scale with a negative domain has a well-defined behavior for negative values. (For a negative domain, input and output values are implicitly multiplied by -1.) The behavior of the scale is undefined if you pass a negative value to a log scale with a positive domain or vice versa.scaleLog(domain, range) ​Examples · Source · Constructs a new log scale with the specified domain and range, the base 10, the default interpolator and clamping disabled.jsconst x = d3.scaleLog([1, 10], [0, 960]);If domain is not specified, it defaults to [1, 10]. If range is not specified, it defaults to [0, 1].log.base(base) ​Examples · Source · If base is specified, sets the base for this logarithmic scale to the specified value.jsconst x = d3.scaleLog([1, 1024], [0, 960]).base(2);If base is not specified, returns the current base, which defaults to 10. Note that due to the nature of a logarithmic transform, the base does not affect the encoding of the scale; it only affects which ticks are chosen.log.ticks(count) ​Examples · Source · Like linear.ticks, but customized for a log scale.jsconst x = d3.scaleLog([1, 100], [0, 960]);
const T = x.ticks(); // [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100]If the base is an integer, the returned ticks are uniformly spaced within each integer power of base; otherwise, one tick per power of base is returned. The returned ticks are guaranteed to be within the extent of the domain. If the orders of magnitude in the domain is greater than count, then at most one tick per power is returned. Otherwise, the tick values are unfiltered, but note that you can use log.tickFormat to filter the display of tick labels. If count is not specified, it defaults to 10.log.tickFormat(count, specifier) ​Examples · Source · Like linear.tickFormat, but customized for a log scale. The specified count typically has the same value as the count that is used to generate the tick values.jsconst x = d3.scaleLog([1, 100], [0, 960]);
const T = x.ticks(); // [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, …]
const f = x.tickFormat();
T.map(f); // ["1", "2", "3", "4", "5", "", "", "", "", "10", …]If there are too many ticks, the formatter may return the empty string for some of the tick labels; however, note that the ticks are still shown to convey the logarithmic transform accurately. To disable filtering, specify a count of Infinity.When specifying a count, you may also provide a format specifier or format function. For example, to get a tick formatter that will display 20 ticks of a currency, say log.tickFormat(20, "$,f"). If the specifier does not have a defined precision, the precision will be set automatically by the scale, returning the appropriate format. This provides a convenient way of specifying a format whose precision will be automatically set by the scale.log.nice() ​Examples · Source · Like linear.nice, except extends the domain to integer powers of base.jsconst x = d3.scaleLog([0.201479, 0.996679], [0, 960]).nice();
x.domain(); // [0.1, 1]If the domain has more than two values, nicing the domain only affects the first and last value. Nicing a scale only modifies the current domain; it does not automatically nice domains that are subsequently set using log.domain. You must re-nice the scale after setting the new domain, if desired.PagerPrevious pagePow scalesNext pageSymlog scales\n\nLogarithmic scales ​Logarithmic (“log”) scales are like linear scales except that a logarithmic transform is applied to the input domain value before the output range value is computed. The mapping to the range value y can be expressed as a function of the domain value x: y = m log(x) + b.CAUTIONAs log(0) = -∞, a log scale domain must be strictly-positive or strictly-negative; the domain must not include or cross zero. A log scale with a positive domain has a well-defined behavior for positive values, and a log scale with a negative domain has a well-defined behavior for negative values. (For a negative domain, input and output values are implicitly multiplied by -1.) The behavior of the scale is undefined if you pass a negative value to a log scale with a positive domain or vice versa.scaleLog(domain, range) ​Examples · Source · Constructs a new log scale with the specified domain and range, the base 10, the default interpolator and clamping disabled.jsconst x = d3.scaleLog([1, 10], [0, 960]);If domain is not specified, it defaults to [1, 10]. If range is not specified, it defaults to [0, 1].log.base(base) ​Examples · Source · If base is specified, sets the base for this logarithmic scale to the specified value.jsconst x = d3.scaleLog([1, 1024], [0, 960]).base(2);If base is not specified, returns the current base, which defaults to 10. Note that due to the nature of a logarithmic transform, the base does not affect the encoding of the scale; it only affects which ticks are chosen.log.ticks(count) ​Examples · Source · Like linear.ticks, but customized for a log scale.jsconst x = d3.scaleLog([1, 100], [0, 960]);
const T = x.ticks(); // [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100]If the base is an integer, the returned ticks are uniformly spaced within each integer power of base; otherwise, one tick per power of base is returned. The returned ticks are guaranteed to be within the extent of the domain. If the orders of magnitude in the domain is greater than count, then at most one tick per power is returned. Otherwise, the tick values are unfiltered, but note that you can use log.tickFormat to filter the display of tick labels. If count is not specified, it defaults to 10.log.tickFormat(count, specifier) ​Examples · Source · Like linear.tickFormat, but customized for a log scale. The specified count typically has the same value as the count that is used to generate the tick values.jsconst x = d3.scaleLog([1, 100], [0, 960]);
const T = x.ticks(); // [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, …]
const f = x.tickFormat();
T.map(f); // ["1", "2", "3", "4", "5", "", "", "", "", "10", …]If there are too many ticks, the formatter may return the empty string for some of the tick labels; however, note that the ticks are still shown to convey the logarithmic transform accurately. To disable filtering, specify a count of Infinity.When specifying a count, you may also provide a format specifier or format function. For example, to get a tick formatter that will display 20 ticks of a currency, say log.tickFormat(20, "$,f"). If the specifier does not have a defined precision, the precision will be set automatically by the scale, returning the appropriate format. This provides a convenient way of specifying a format whose precision will be automatically set by the scale.log.nice() ​Examples · Source · Like linear.nice, except extends the domain to integer powers of base.jsconst x = d3.scaleLog([0.201479, 0.996679], [0, 960]).nice();
x.domain(); // [0.1, 1]If the domain has more than two values, nicing the domain only affects the first and last value. Nicing a scale only modifies the current domain; it does not automatically nice domains that are subsequently set using log.domain. You must re-nice the scale after setting the new domain, if desired.\n\n\n\nSymlog scales ​See A bi-symmetric log transformation for wide-range data by Webber for details. Unlike a log scale, a symlog scale domain can include zero.scaleSymlog(domain, range) ​Examples · Source · Constructs a new continuous scale with the specified domain and range, the constant 1, the default interpolator and clamping disabled.jsconst x = d3.scaleSymlog([0, 100], [0, 960]);If a single argument is specified, it is interpreted as the range. If either domain or range are not specified, each defaults to [0, 1].jsconst color = d3.scaleSymlog(["red", "blue"]) // default domain of [0, 1]symlog.constant(constant) ​Examples · Source · If constant is specified, sets the symlog constant to the specified number and returns this scale. The constant defaults to 1.jsconst x = d3.scaleSymlog([0, 100], [0, 960]).constant(2);If constant is not specified, returns the current value of the symlog constant.jsx.constant() // 2\n\nSearchK7.9.0GitHub️ 110.0kOn this pageSymlog scales ​See A bi-symmetric log transformation for wide-range data by Webber for details. Unlike a log scale, a symlog scale domain can include zero.scaleSymlog(domain, range) ​Examples · Source · Constructs a new continuous scale with the specified domain and range, the constant 1, the default interpolator and clamping disabled.jsconst x = d3.scaleSymlog([0, 100], [0, 960]);If a single argument is specified, it is interpreted as the range. If either domain or range are not specified, each defaults to [0, 1].jsconst color = d3.scaleSymlog(["red", "blue"]) // default domain of [0, 1]symlog.constant(constant) ​Examples · Source · If constant is specified, sets the symlog constant to the specified number and returns this scale. The constant defaults to 1.jsconst x = d3.scaleSymlog([0, 100], [0, 960]).constant(2);If constant is not specified, returns the current value of the symlog constant.jsx.constant() // 2PagerPrevious pageLog scalesNext pageOrdinal scales\n\nSymlog scales ​See A bi-symmetric log transformation for wide-range data by Webber for details. Unlike a log scale, a symlog scale domain can include zero.scaleSymlog(domain, range) ​Examples · Source · Constructs a new continuous scale with the specified domain and range, the constant 1, the default interpolator and clamping disabled.jsconst x = d3.scaleSymlog([0, 100], [0, 960]);If a single argument is specified, it is interpreted as the range. If either domain or range are not specified, each defaults to [0, 1].jsconst color = d3.scaleSymlog(["red", "blue"]) // default domain of [0, 1]symlog.constant(constant) ​Examples · Source · If constant is specified, sets the symlog constant to the specified number and returns this scale. The constant defaults to 1.jsconst x = d3.scaleSymlog([0, 100], [0, 960]).constant(2);If constant is not specified, returns the current value of the symlog constant.jsx.constant() // 2\n\n\n\nOrdinal scales ​Unlike continuous scales, ordinal scales have a discrete domain and range. For example, an ordinal scale might map a set of named categories to a set of colors, or determine the horizontal positions of columns in a column chart.scaleOrdinal(domain, range) ​Examples · Source · Constructs a new ordinal scale with the specified domain and range.jsconst color = d3.scaleOrdinal(["a", "b", "c"], ["red", "green", "blue"]);If domain is not specified, it defaults to the empty array. If range is not specified, it defaults to the empty array; an ordinal scale always returns undefined until a non-empty range is defined.ordinal(value) ​Examples · Source · Given a value in the input domain, returns the corresponding value in the output range.jscolor("a") // "red"If the given value is not in the scale’s domain, returns the unknown value; or, if the unknown value is implicit (the default), then the value is implicitly added to the domain and the next-available value in the range is assigned to value, such that this and subsequent invocations of the scale given the same input value return the same output value.ordinal.domain(domain) ​Examples · Source · If domain is specified, sets the domain to the specified array of values.jsconst color = d3.scaleOrdinal(["red", "green", "blue"]).domain(["a", "b", "c"]);
color("a"); // "red"
color("b"); // "green"
color("c"); // "blue"The first element in domain will be mapped to the first element in the range, the second domain value to the second range value, and so on. Domain values are stored internally in an InternMap from primitive value to index; the resulting index is then used to retrieve a value from the range. Thus, an ordinal scale’s values must be coercible to a primitive value, and the primitive domain value uniquely identifies the corresponding range value.jscolor.domain() // ["a", "b", "c"]If domain is not specified, this method returns the current domain.Setting the domain on an ordinal scale is optional if the unknown value is implicit (the default). In this case, the domain will be inferred implicitly from usage by assigning each unique value passed to the scale a new value from the range.jsconst color = d3.scaleOrdinal(["red", "green", "blue"]);
color("b"); // "red"
color("a"); // "green"
color("c"); // "blue"
color.domain(); // inferred ["b", "a", "c"]CAUTIONAn explicit domain is recommended for deterministic behavior; inferring the domain from usage is dependent on ordering.ordinal.range(range) ​Examples · Source · If range is specified, sets the range of the ordinal scale to the specified array of values.jsconst color = d3.scaleOrdinal().range(["red", "green", "blue"]);The first element in the domain will be mapped to the first element in range, the second domain value to the second range value, and so on. If there are fewer elements in the range than in the domain, the scale will reuse values from the start of the range. If range is not specified, this method returns the current range.ordinal.unknown(value) ​Examples · Source · If value is specified, sets the output value of the scale for unknown input values and returns this scale.jsconst color = d3.scaleOrdinal(["a", "b", "c"], d3.schemeTableau10).unknown(null);
color("a"); // "#4e79a7"
color("b"); // "#f28e2c"
color("c"); // "#e15759"
color("d"); // nullIf value is not specified, returns the current unknown value, which defaults to implicit. The implicit value enables implicit domain construction; see ordinal.domain.ordinal.copy() ​Examples · Source · Returns an exact copy of this ordinal scale.jsconst c1 = d3.scaleOrdinal(["a", "b", "c"], d3.schemeTableau10);
const c2 = c1.copy();Changes to this scale will not affect the returned scale, and vice versa.scaleImplicit ​Examples · Source · A special value for ordinal.unknown that enables implicit domain construction: unknown values are implicitly added to the domain.jsconst color = d3.scaleOrdinal(["a", "b", "c"], d3.schemeTableau10);
color.unknown(); // d3.scaleImplicitCAUTIONAn explicit domain is recommended for deterministic behavior; inferring the domain from usage is dependent on ordering.\n\nSearchK7.9.0GitHub️ 110.0kOn this pageOrdinal scales ​Unlike continuous scales, ordinal scales have a discrete domain and range. For example, an ordinal scale might map a set of named categories to a set of colors, or determine the horizontal positions of columns in a column chart.scaleOrdinal(domain, range) ​Examples · Source · Constructs a new ordinal scale with the specified domain and range.jsconst color = d3.scaleOrdinal(["a", "b", "c"], ["red", "green", "blue"]);If domain is not specified, it defaults to the empty array. If range is not specified, it defaults to the empty array; an ordinal scale always returns undefined until a non-empty range is defined.ordinal(value) ​Examples · Source · Given a value in the input domain, returns the corresponding value in the output range.jscolor("a") // "red"If the given value is not in the scale’s domain, returns the unknown value; or, if the unknown value is implicit (the default), then the value is implicitly added to the domain and the next-available value in the range is assigned to value, such that this and subsequent invocations of the scale given the same input value return the same output value.ordinal.domain(domain) ​Examples · Source · If domain is specified, sets the domain to the specified array of values.jsconst color = d3.scaleOrdinal(["red", "green", "blue"]).domain(["a", "b", "c"]);
color("a"); // "red"
color("b"); // "green"
color("c"); // "blue"The first element in domain will be mapped to the first element in the range, the second domain value to the second range value, and so on. Domain values are stored internally in an InternMap from primitive value to index; the resulting index is then used to retrieve a value from the range. Thus, an ordinal scale’s values must be coercible to a primitive value, and the primitive domain value uniquely identifies the corresponding range value.jscolor.domain() // ["a", "b", "c"]If domain is not specified, this method returns the current domain.Setting the domain on an ordinal scale is optional if the unknown value is implicit (the default). In this case, the domain will be inferred implicitly from usage by assigning each unique value passed to the scale a new value from the range.jsconst color = d3.scaleOrdinal(["red", "green", "blue"]);
color("b"); // "red"
color("a"); // "green"
color("c"); // "blue"
color.domain(); // inferred ["b", "a", "c"]CAUTIONAn explicit domain is recommended for deterministic behavior; inferring the domain from usage is dependent on ordering.ordinal.range(range) ​Examples · Source · If range is specified, sets the range of the ordinal scale to the specified array of values.jsconst color = d3.scaleOrdinal().range(["red", "green", "blue"]);The first element in the domain will be mapped to the first element in range, the second domain value to the second range value, and so on. If there are fewer elements in the range than in the domain, the scale will reuse values from the start of the range. If range is not specified, this method returns the current range.ordinal.unknown(value) ​Examples · Source · If value is specified, sets the output value of the scale for unknown input values and returns this scale.jsconst color = d3.scaleOrdinal(["a", "b", "c"], d3.schemeTableau10).unknown(null);
color("a"); // "#4e79a7"
color("b"); // "#f28e2c"
color("c"); // "#e15759"
color("d"); // nullIf value is not specified, returns the current unknown value, which defaults to implicit. The implicit value enables implicit domain construction; see ordinal.domain.ordinal.copy() ​Examples · Source · Returns an exact copy of this ordinal scale.jsconst c1 = d3.scaleOrdinal(["a", "b", "c"], d3.schemeTableau10);
const c2 = c1.copy();Changes to this scale will not affect the returned scale, and vice versa.scaleImplicit ​Examples · Source · A special value for ordinal.unknown that enables implicit domain construction: unknown values are implicitly added to the domain.jsconst color = d3.scaleOrdinal(["a", "b", "c"], d3.schemeTableau10);
color.unknown(); // d3.scaleImplicitCAUTIONAn explicit domain is recommended for deterministic behavior; inferring the domain from usage is dependent on ordering.PagerPrevious pageSymlog scalesNext pageBand scales\n\nOrdinal scales ​Unlike continuous scales, ordinal scales have a discrete domain and range. For example, an ordinal scale might map a set of named categories to a set of colors, or determine the horizontal positions of columns in a column chart.scaleOrdinal(domain, range) ​Examples · Source · Constructs a new ordinal scale with the specified domain and range.jsconst color = d3.scaleOrdinal(["a", "b", "c"], ["red", "green", "blue"]);If domain is not specified, it defaults to the empty array. If range is not specified, it defaults to the empty array; an ordinal scale always returns undefined until a non-empty range is defined.ordinal(value) ​Examples · Source · Given a value in the input domain, returns the corresponding value in the output range.jscolor("a") // "red"If the given value is not in the scale’s domain, returns the unknown value; or, if the unknown value is implicit (the default), then the value is implicitly added to the domain and the next-available value in the range is assigned to value, such that this and subsequent invocations of the scale given the same input value return the same output value.ordinal.domain(domain) ​Examples · Source · If domain is specified, sets the domain to the specified array of values.jsconst color = d3.scaleOrdinal(["red", "green", "blue"]).domain(["a", "b", "c"]);
color("a"); // "red"
color("b"); // "green"
color("c"); // "blue"The first element in domain will be mapped to the first element in the range, the second domain value to the second range value, and so on. Domain values are stored internally in an InternMap from primitive value to index; the resulting index is then used to retrieve a value from the range. Thus, an ordinal scale’s values must be coercible to a primitive value, and the primitive domain value uniquely identifies the corresponding range value.jscolor.domain() // ["a", "b", "c"]If domain is not specified, this method returns the current domain.Setting the domain on an ordinal scale is optional if the unknown value is implicit (the default). In this case, the domain will be inferred implicitly from usage by assigning each unique value passed to the scale a new value from the range.jsconst color = d3.scaleOrdinal(["red", "green", "blue"]);
color("b"); // "red"
color("a"); // "green"
color("c"); // "blue"
color.domain(); // inferred ["b", "a", "c"]CAUTIONAn explicit domain is recommended for deterministic behavior; inferring the domain from usage is dependent on ordering.ordinal.range(range) ​Examples · Source · If range is specified, sets the range of the ordinal scale to the specified array of values.jsconst color = d3.scaleOrdinal().range(["red", "green", "blue"]);The first element in the domain will be mapped to the first element in range, the second domain value to the second range value, and so on. If there are fewer elements in the range than in the domain, the scale will reuse values from the start of the range. If range is not specified, this method returns the current range.ordinal.unknown(value) ​Examples · Source · If value is specified, sets the output value of the scale for unknown input values and returns this scale.jsconst color = d3.scaleOrdinal(["a", "b", "c"], d3.schemeTableau10).unknown(null);
color("a"); // "#4e79a7"
color("b"); // "#f28e2c"
color("c"); // "#e15759"
color("d"); // nullIf value is not specified, returns the current unknown value, which defaults to implicit. The implicit value enables implicit domain construction; see ordinal.domain.ordinal.copy() ​Examples · Source · Returns an exact copy of this ordinal scale.jsconst c1 = d3.scaleOrdinal(["a", "b", "c"], d3.schemeTableau10);
const c2 = c1.copy();Changes to this scale will not affect the returned scale, and vice versa.scaleImplicit ​Examples · Source · A special value for ordinal.unknown that enables implicit domain construction: unknown values are implicitly added to the domain.jsconst color = d3.scaleOrdinal(["a", "b", "c"], d3.schemeTableau10);
color.unknown(); // d3.scaleImplicitCAUTIONAn explicit domain is recommended for deterministic behavior; inferring the domain from usage is dependent on ordering.\n\n\n\nBand scales ​Band scales are like ordinal scales except the output range is continuous and numeric. The scale divides the continuous range into uniform bands. Band scales are typically used for bar charts with an ordinal or categorical dimension.scaleBand(domain, range) ​Examples · Source · Constructs a new band scale with the specified domain and range, no padding, no rounding and center alignment.jsconst x = d3.scaleBand(["a", "b", "c"], [0, 960]);If a single argument is specified, it is interpreted as the range. If domain is not specified, it defaults to the empty domain. If range is not specified, it defaults to the unit range [0, 1].band(value) ​Examples · Source · Given a value in the input domain, returns the start of the corresponding band derived from the output range.jsconst x = d3.scaleBand(["a", "b", "c"], [0, 960]);
x("a"); // 0
x("b"); // 320
x("c"); // 640
x("d"); // undefinedIf the given value is not in the scale’s domain, returns undefined.band.domain(domain) ​ Domain: Examples · Source · If domain is specified, sets the domain to the specified array of values and returns this scale.jsconst x = d3.scaleBand([0, 960]).domain(["a", "b", "c", "d", "e", "f"]);The first element in domain will be mapped to the first band, the second domain value to the second band, and so on. Domain values are stored internally in an InternMap from primitive value to index; the resulting index is then used to determine the band. Thus, a band scale’s values must be coercible to a primitive value, and the primitive domain value uniquely identifies the corresponding band. If domain is not specified, this method returns the current domain.band.range(range) ​Examples · Source · If range is specified, sets the scale’s range to the specified two-element array of numbers and returns this scale.jsconst x = d3.scaleBand().range([0, 960]);If the elements in the given array are not numbers, they will be coerced to numbers. If range is not specified, returns the scale’s current range, which defaults to [0, 1].band.rangeRound(range) ​Examples · Source · Sets the scale’s range to the specified two-element array of numbers while also enabling rounding; returns this scale.jsconst x = d3.scaleBand().rangeRound([0, 960]);This is a convenience method equivalent to:jsband.range(range).round(true)Rounding is sometimes useful for avoiding antialiasing artifacts, though also consider the shape-rendering “crispEdges” styles.band.round(round) ​ Round: Examples · Source · If round is specified, enables or disables rounding accordingly and returns this scale.jsconst x = d3.scaleBand(["a", "b", "c"], [0, 960]).round(false);If round is not specified, returns whether rounding is enabled.jsx.round() // falseIf rounding is enabled, the start and stop of each band will be integers. Rounding is sometimes useful for avoiding antialiasing artifacts, though also consider the shape-rendering “crispEdges” styles. Note that if the width of the domain is not a multiple of the cardinality of the range, there may be leftover unused space, even without padding! Use band.align to specify how the leftover space is distributed.band.paddingInner(padding) ​Inner padding:0.10Examples · Source · If padding is specified, sets the inner padding to the specified number which must be less than or equal to 1 and returns this scale.jsconst x = d3.scaleBand(["a", "b", "c"], [0, 960]).paddingInner(0.1);If padding is not specified, returns the current inner padding which defaults to 0.jsx.paddingInner() // 0.1The inner padding specifies the proportion of the range that is reserved for blank space between bands; a value of 0 means no blank space between bands, and a value of 1 means a bandwidth of zero.band.paddingOuter(padding) ​Outer padding:0.10Examples · Source · If padding is specified, sets the outer padding to the specified number which is typically in the range [0, 1] and returns this scale.jsconst x = d3.scaleBand(["a", "b", "c"], [0, 960]).paddingOuter(0.1);If padding is not specified, returns the current outer padding which defaults to 0.jsx.paddingOuter() // 0.1The outer padding specifies the amount of blank space, in terms of multiples of the step, to reserve before the first band and after the last band.band.padding(padding) ​Padding:0.10Examples · Source · A convenience method for setting the inner and outer padding to the same padding value.jsconst x = d3.scaleBand(["a", "b", "c"], [0, 960]).padding(0.1);If padding is not specified, returns the inner padding.jsx.padding() // 0.1band.align(align) ​Align:0.50Examples · Source · If align is specified, sets the alignment to the specified value which must be in the range [0, 1], and returns this scale.jsconst x = d3.scaleBand(["a", "b", "c"], [0, 960]).align(0.5);If align is not specified, returns the current alignment which defaults to 0.5.jsx.align() // 0.5The alignment specifies how outer padding is distributed in the range. A value of 0.5 indicates that the outer padding should be equally distributed before the first band and after the last band; i.e., the bands should be centered within the range. A value of 0 or 1 may be used to shift the bands to one side, say to position them adjacent to an axis. For more, see this explainer.band.bandwidth() ​Examples · Source · Returns the width of each band.jsx.bandwidth() // 50.8235294117647band.step() ​Examples · Source · Returns the distance between the starts of adjacent bands.jsx.step() // 63.529411764705884band.copy() ​Examples · Source · Returns an exact copy of this scale.jsconst x1 = d3.scaleBand(["a", "b", "c"], [0, 960]);
const x2 = x1.copy();Changes to this scale will not affect the returned scale, and vice versa.\n\nSearchK7.9.0GitHub️ 110.0kOn this pageBand scales ​Band scales are like ordinal scales except the output range is continuous and numeric. The scale divides the continuous range into uniform bands. Band scales are typically used for bar charts with an ordinal or categorical dimension.scaleBand(domain, range) ​Examples · Source · Constructs a new band scale with the specified domain and range, no padding, no rounding and center alignment.jsconst x = d3.scaleBand(["a", "b", "c"], [0, 960]);If a single argument is specified, it is interpreted as the range. If domain is not specified, it defaults to the empty domain. If range is not specified, it defaults to the unit range [0, 1].band(value) ​Examples · Source · Given a value in the input domain, returns the start of the corresponding band derived from the output range.jsconst x = d3.scaleBand(["a", "b", "c"], [0, 960]);
x("a"); // 0
x("b"); // 320
x("c"); // 640
x("d"); // undefinedIf the given value is not in the scale’s domain, returns undefined.band.domain(domain) ​ Domain: Examples · Source · If domain is specified, sets the domain to the specified array of values and returns this scale.jsconst x = d3.scaleBand([0, 960]).domain(["a", "b", "c", "d", "e", "f"]);The first element in domain will be mapped to the first band, the second domain value to the second band, and so on. Domain values are stored internally in an InternMap from primitive value to index; the resulting index is then used to determine the band. Thus, a band scale’s values must be coercible to a primitive value, and the primitive domain value uniquely identifies the corresponding band. If domain is not specified, this method returns the current domain.band.range(range) ​Examples · Source · If range is specified, sets the scale’s range to the specified two-element array of numbers and returns this scale.jsconst x = d3.scaleBand().range([0, 960]);If the elements in the given array are not numbers, they will be coerced to numbers. If range is not specified, returns the scale’s current range, which defaults to [0, 1].band.rangeRound(range) ​Examples · Source · Sets the scale’s range to the specified two-element array of numbers while also enabling rounding; returns this scale.jsconst x = d3.scaleBand().rangeRound([0, 960]);This is a convenience method equivalent to:jsband.range(range).round(true)Rounding is sometimes useful for avoiding antialiasing artifacts, though also consider the shape-rendering “crispEdges” styles.band.round(round) ​ Round: Examples · Source · If round is specified, enables or disables rounding accordingly and returns this scale.jsconst x = d3.scaleBand(["a", "b", "c"], [0, 960]).round(false);If round is not specified, returns whether rounding is enabled.jsx.round() // falseIf rounding is enabled, the start and stop of each band will be integers. Rounding is sometimes useful for avoiding antialiasing artifacts, though also consider the shape-rendering “crispEdges” styles. Note that if the width of the domain is not a multiple of the cardinality of the range, there may be leftover unused space, even without padding! Use band.align to specify how the leftover space is distributed.band.paddingInner(padding) ​Inner padding:0.10Examples · Source · If padding is specified, sets the inner padding to the specified number which must be less than or equal to 1 and returns this scale.jsconst x = d3.scaleBand(["a", "b", "c"], [0, 960]).paddingInner(0.1);If padding is not specified, returns the current inner padding which defaults to 0.jsx.paddingInner() // 0.1The inner padding specifies the proportion of the range that is reserved for blank space between bands; a value of 0 means no blank space between bands, and a value of 1 means a bandwidth of zero.band.paddingOuter(padding) ​Outer padding:0.10Examples · Source · If padding is specified, sets the outer padding to the specified number which is typically in the range [0, 1] and returns this scale.jsconst x = d3.scaleBand(["a", "b", "c"], [0, 960]).paddingOuter(0.1);If padding is not specified, returns the current outer padding which defaults to 0.jsx.paddingOuter() // 0.1The outer padding specifies the amount of blank space, in terms of multiples of the step, to reserve before the first band and after the last band.band.padding(padding) ​Padding:0.10Examples · Source · A convenience method for setting the inner and outer padding to the same padding value.jsconst x = d3.scaleBand(["a", "b", "c"], [0, 960]).padding(0.1);If padding is not specified, returns the inner padding.jsx.padding() // 0.1band.align(align) ​Align:0.50Examples · Source · If align is specified, sets the alignment to the specified value which must be in the range [0, 1], and returns this scale.jsconst x = d3.scaleBand(["a", "b", "c"], [0, 960]).align(0.5);If align is not specified, returns the current alignment which defaults to 0.5.jsx.align() // 0.5The alignment specifies how outer padding is distributed in the range. A value of 0.5 indicates that the outer padding should be equally distributed before the first band and after the last band; i.e., the bands should be centered within the range. A value of 0 or 1 may be used to shift the bands to one side, say to position them adjacent to an axis. For more, see this explainer.band.bandwidth() ​Examples · Source · Returns the width of each band.jsx.bandwidth() // 50.8235294117647band.step() ​Examples · Source · Returns the distance between the starts of adjacent bands.jsx.step() // 63.529411764705884band.copy() ​Examples · Source · Returns an exact copy of this scale.jsconst x1 = d3.scaleBand(["a", "b", "c"], [0, 960]);
const x2 = x1.copy();Changes to this scale will not affect the returned scale, and vice versa.PagerPrevious pageOrdinal scalesNext pagePoint scales\n\nBand scales ​Band scales are like ordinal scales except the output range is continuous and numeric. The scale divides the continuous range into uniform bands. Band scales are typically used for bar charts with an ordinal or categorical dimension.scaleBand(domain, range) ​Examples · Source · Constructs a new band scale with the specified domain and range, no padding, no rounding and center alignment.jsconst x = d3.scaleBand(["a", "b", "c"], [0, 960]);If a single argument is specified, it is interpreted as the range. If domain is not specified, it defaults to the empty domain. If range is not specified, it defaults to the unit range [0, 1].band(value) ​Examples · Source · Given a value in the input domain, returns the start of the corresponding band derived from the output range.jsconst x = d3.scaleBand(["a", "b", "c"], [0, 960]);
x("a"); // 0
x("b"); // 320
x("c"); // 640
x("d"); // undefinedIf the given value is not in the scale’s domain, returns undefined.band.domain(domain) ​ Domain: Examples · Source · If domain is specified, sets the domain to the specified array of values and returns this scale.jsconst x = d3.scaleBand([0, 960]).domain(["a", "b", "c", "d", "e", "f"]);The first element in domain will be mapped to the first band, the second domain value to the second band, and so on. Domain values are stored internally in an InternMap from primitive value to index; the resulting index is then used to determine the band. Thus, a band scale’s values must be coercible to a primitive value, and the primitive domain value uniquely identifies the corresponding band. If domain is not specified, this method returns the current domain.band.range(range) ​Examples · Source · If range is specified, sets the scale’s range to the specified two-element array of numbers and returns this scale.jsconst x = d3.scaleBand().range([0, 960]);If the elements in the given array are not numbers, they will be coerced to numbers. If range is not specified, returns the scale’s current range, which defaults to [0, 1].band.rangeRound(range) ​Examples · Source · Sets the scale’s range to the specified two-element array of numbers while also enabling rounding; returns this scale.jsconst x = d3.scaleBand().rangeRound([0, 960]);This is a convenience method equivalent to:jsband.range(range).round(true)Rounding is sometimes useful for avoiding antialiasing artifacts, though also consider the shape-rendering “crispEdges” styles.band.round(round) ​ Round: Examples · Source · If round is specified, enables or disables rounding accordingly and returns this scale.jsconst x = d3.scaleBand(["a", "b", "c"], [0, 960]).round(false);If round is not specified, returns whether rounding is enabled.jsx.round() // falseIf rounding is enabled, the start and stop of each band will be integers. Rounding is sometimes useful for avoiding antialiasing artifacts, though also consider the shape-rendering “crispEdges” styles. Note that if the width of the domain is not a multiple of the cardinality of the range, there may be leftover unused space, even without padding! Use band.align to specify how the leftover space is distributed.band.paddingInner(padding) ​Inner padding:0.10Examples · Source · If padding is specified, sets the inner padding to the specified number which must be less than or equal to 1 and returns this scale.jsconst x = d3.scaleBand(["a", "b", "c"], [0, 960]).paddingInner(0.1);If padding is not specified, returns the current inner padding which defaults to 0.jsx.paddingInner() // 0.1The inner padding specifies the proportion of the range that is reserved for blank space between bands; a value of 0 means no blank space between bands, and a value of 1 means a bandwidth of zero.band.paddingOuter(padding) ​Outer padding:0.10Examples · Source · If padding is specified, sets the outer padding to the specified number which is typically in the range [0, 1] and returns this scale.jsconst x = d3.scaleBand(["a", "b", "c"], [0, 960]).paddingOuter(0.1);If padding is not specified, returns the current outer padding which defaults to 0.jsx.paddingOuter() // 0.1The outer padding specifies the amount of blank space, in terms of multiples of the step, to reserve before the first band and after the last band.band.padding(padding) ​Padding:0.10Examples · Source · A convenience method for setting the inner and outer padding to the same padding value.jsconst x = d3.scaleBand(["a", "b", "c"], [0, 960]).padding(0.1);If padding is not specified, returns the inner padding.jsx.padding() // 0.1band.align(align) ​Align:0.50Examples · Source · If align is specified, sets the alignment to the specified value which must be in the range [0, 1], and returns this scale.jsconst x = d3.scaleBand(["a", "b", "c"], [0, 960]).align(0.5);If align is not specified, returns the current alignment which defaults to 0.5.jsx.align() // 0.5The alignment specifies how outer padding is distributed in the range. A value of 0.5 indicates that the outer padding should be equally distributed before the first band and after the last band; i.e., the bands should be centered within the range. A value of 0 or 1 may be used to shift the bands to one side, say to position them adjacent to an axis. For more, see this explainer.band.bandwidth() ​Examples · Source · Returns the width of each band.jsx.bandwidth() // 50.8235294117647band.step() ​Examples · Source · Returns the distance between the starts of adjacent bands.jsx.step() // 63.529411764705884band.copy() ​Examples · Source · Returns an exact copy of this scale.jsconst x1 = d3.scaleBand(["a", "b", "c"], [0, 960]);
const x2 = x1.copy();Changes to this scale will not affect the returned scale, and vice versa.\n\n\n\nPoint scales ​Point scales are a variant of band scales with the bandwidth fixed to zero. Point scales are typically used for scatterplots with an ordinal or categorical dimension.scalePoint(domain, range) ​Examples · Source · Constructs a new point scale with the specified domain and range, no padding, no rounding and center alignment. If domain is not specified, it defaults to the empty domain. If range is not specified, it defaults to the unit range [0, 1].point(value) ​Examples · Source · Given a value in the input domain, returns the corresponding point derived from the output range.jsconst x = d3.scalePoint(["a", "b", "c"], [0, 960]);
x("a"); // 0
x("b"); // 480
x("c"); // 960
x("d"); // undefinedIf the given value is not in the scale’s domain, returns undefined.point.domain(domain) ​ Domain: Examples · Source · If domain is specified, sets the domain to the specified array of values.jsconst x = d3.scalePoint([0, 960]).domain(["a", "b", "c", "d", "e", "f"]);The first element in domain will be mapped to the first point, the second domain value to the second point, and so on. Domain values are stored internally in an InternMap from primitive value to index; the resulting index is then used to determine the point. Thus, a point scale’s values must be coercible to a primitive value, and the primitive domain value uniquely identifies the corresponding point. If domain is not specified, this method returns the current domain.point.range(range) ​Examples · Source · If range is specified, sets the scale’s range to the specified two-element array of numbers and returns this scale.jsconst x = d3.scalePoint().range([0, 960]);If the elements in the given array are not numbers, they will be coerced to numbers. If range is not specified, returns the scale’s current range, which defaults to [0, 1].point.rangeRound(range) ​Examples · Source · Sets the scale’s range to the specified two-element array of numbers while also enabling rounding; returns this scale.jsconst x = d3.scalePoint().rangeRound([0, 960]);This is a convenience method equivalent to:jspoint.range(range).round(true)Rounding is sometimes useful for avoiding antialiasing artifacts, though also consider the shape-rendering “crispEdges” styles.point.round(round) ​ Round: Examples · Source · If round is specified, enables or disables rounding accordingly.jsconst x = d3.scalePoint(["a", "b", "c"], [0, 960]).round(false);If round is not specified, returns whether rounding is enabled.jsx.round() // falseIf rounding is enabled, the position of each point will be integers. Rounding is sometimes useful for avoiding antialiasing artifacts, though also consider the shape-rendering “crispEdges” styles. Note that if the width of the domain is not a multiple of the cardinality of the range, there may be leftover unused space, even without padding! Use point.align to specify how the leftover space is distributed.point.padding(padding) ​Padding:0.10Examples · Source · If padding is specified, sets the outer padding to the specified number which is typically in the range [0, 1].jsconst x = d3.scalePoint(["a", "b", "c"], [0, 960]).padding(0.1);If padding is not specified, returns the current outer padding which defaults to 0.jsx.padding() // 0.1The outer padding specifies the amount of blank space, in terms of multiples of the step, to reserve before the first point and after the last point. Equivalent to band.paddingOuter.point.align(align) ​Align:0.50Examples · Source · If align is specified, sets the alignment to the specified value which must be in the range [0, 1].jsconst x = d3.scalePoint(["a", "b", "c"], [0, 960]).align(0.5);If align is not specified, returns the current alignment which defaults to 0.5.jsx.align() // 0.5The alignment specifies how any leftover unused space in the range is distributed. A value of 0.5 indicates that the leftover space should be equally distributed before the first point and after the last point; i.e., the points should be centered within the range. A value of 0 or 1 may be used to shift the points to one side, say to position them adjacent to an axis.point.bandwidth() ​Examples · Source · Returns zero.point.step() ​Examples · Source · Returns the distance between adjacent points.point.copy() ​Examples · Source · Returns an exact copy of this scale. Changes to this scale will not affect the returned scale, and vice versa.\n\nSearchK7.9.0GitHub️ 110.0kOn this pagePoint scales ​Point scales are a variant of band scales with the bandwidth fixed to zero. Point scales are typically used for scatterplots with an ordinal or categorical dimension.scalePoint(domain, range) ​Examples · Source · Constructs a new point scale with the specified domain and range, no padding, no rounding and center alignment. If domain is not specified, it defaults to the empty domain. If range is not specified, it defaults to the unit range [0, 1].point(value) ​Examples · Source · Given a value in the input domain, returns the corresponding point derived from the output range.jsconst x = d3.scalePoint(["a", "b", "c"], [0, 960]);
x("a"); // 0
x("b"); // 480
x("c"); // 960
x("d"); // undefinedIf the given value is not in the scale’s domain, returns undefined.point.domain(domain) ​ Domain: Examples · Source · If domain is specified, sets the domain to the specified array of values.jsconst x = d3.scalePoint([0, 960]).domain(["a", "b", "c", "d", "e", "f"]);The first element in domain will be mapped to the first point, the second domain value to the second point, and so on. Domain values are stored internally in an InternMap from primitive value to index; the resulting index is then used to determine the point. Thus, a point scale’s values must be coercible to a primitive value, and the primitive domain value uniquely identifies the corresponding point. If domain is not specified, this method returns the current domain.point.range(range) ​Examples · Source · If range is specified, sets the scale’s range to the specified two-element array of numbers and returns this scale.jsconst x = d3.scalePoint().range([0, 960]);If the elements in the given array are not numbers, they will be coerced to numbers. If range is not specified, returns the scale’s current range, which defaults to [0, 1].point.rangeRound(range) ​Examples · Source · Sets the scale’s range to the specified two-element array of numbers while also enabling rounding; returns this scale.jsconst x = d3.scalePoint().rangeRound([0, 960]);This is a convenience method equivalent to:jspoint.range(range).round(true)Rounding is sometimes useful for avoiding antialiasing artifacts, though also consider the shape-rendering “crispEdges” styles.point.round(round) ​ Round: Examples · Source · If round is specified, enables or disables rounding accordingly.jsconst x = d3.scalePoint(["a", "b", "c"], [0, 960]).round(false);If round is not specified, returns whether rounding is enabled.jsx.round() // falseIf rounding is enabled, the position of each point will be integers. Rounding is sometimes useful for avoiding antialiasing artifacts, though also consider the shape-rendering “crispEdges” styles. Note that if the width of the domain is not a multiple of the cardinality of the range, there may be leftover unused space, even without padding! Use point.align to specify how the leftover space is distributed.point.padding(padding) ​Padding:0.10Examples · Source · If padding is specified, sets the outer padding to the specified number which is typically in the range [0, 1].jsconst x = d3.scalePoint(["a", "b", "c"], [0, 960]).padding(0.1);If padding is not specified, returns the current outer padding which defaults to 0.jsx.padding() // 0.1The outer padding specifies the amount of blank space, in terms of multiples of the step, to reserve before the first point and after the last point. Equivalent to band.paddingOuter.point.align(align) ​Align:0.50Examples · Source · If align is specified, sets the alignment to the specified value which must be in the range [0, 1].jsconst x = d3.scalePoint(["a", "b", "c"], [0, 960]).align(0.5);If align is not specified, returns the current alignment which defaults to 0.5.jsx.align() // 0.5The alignment specifies how any leftover unused space in the range is distributed. A value of 0.5 indicates that the leftover space should be equally distributed before the first point and after the last point; i.e., the points should be centered within the range. A value of 0 or 1 may be used to shift the points to one side, say to position them adjacent to an axis.point.bandwidth() ​Examples · Source · Returns zero.point.step() ​Examples · Source · Returns the distance between adjacent points.point.copy() ​Examples · Source · Returns an exact copy of this scale. Changes to this scale will not affect the returned scale, and vice versa.PagerPrevious pageBand scalesNext pageSequential scales\n\nPoint scales ​Point scales are a variant of band scales with the bandwidth fixed to zero. Point scales are typically used for scatterplots with an ordinal or categorical dimension.scalePoint(domain, range) ​Examples · Source · Constructs a new point scale with the specified domain and range, no padding, no rounding and center alignment. If domain is not specified, it defaults to the empty domain. If range is not specified, it defaults to the unit range [0, 1].point(value) ​Examples · Source · Given a value in the input domain, returns the corresponding point derived from the output range.jsconst x = d3.scalePoint(["a", "b", "c"], [0, 960]);
x("a"); // 0
x("b"); // 480
x("c"); // 960
x("d"); // undefinedIf the given value is not in the scale’s domain, returns undefined.point.domain(domain) ​ Domain: Examples · Source · If domain is specified, sets the domain to the specified array of values.jsconst x = d3.scalePoint([0, 960]).domain(["a", "b", "c", "d", "e", "f"]);The first element in domain will be mapped to the first point, the second domain value to the second point, and so on. Domain values are stored internally in an InternMap from primitive value to index; the resulting index is then used to determine the point. Thus, a point scale’s values must be coercible to a primitive value, and the primitive domain value uniquely identifies the corresponding point. If domain is not specified, this method returns the current domain.point.range(range) ​Examples · Source · If range is specified, sets the scale’s range to the specified two-element array of numbers and returns this scale.jsconst x = d3.scalePoint().range([0, 960]);If the elements in the given array are not numbers, they will be coerced to numbers. If range is not specified, returns the scale’s current range, which defaults to [0, 1].point.rangeRound(range) ​Examples · Source · Sets the scale’s range to the specified two-element array of numbers while also enabling rounding; returns this scale.jsconst x = d3.scalePoint().rangeRound([0, 960]);This is a convenience method equivalent to:jspoint.range(range).round(true)Rounding is sometimes useful for avoiding antialiasing artifacts, though also consider the shape-rendering “crispEdges” styles.point.round(round) ​ Round: Examples · Source · If round is specified, enables or disables rounding accordingly.jsconst x = d3.scalePoint(["a", "b", "c"], [0, 960]).round(false);If round is not specified, returns whether rounding is enabled.jsx.round() // falseIf rounding is enabled, the position of each point will be integers. Rounding is sometimes useful for avoiding antialiasing artifacts, though also consider the shape-rendering “crispEdges” styles. Note that if the width of the domain is not a multiple of the cardinality of the range, there may be leftover unused space, even without padding! Use point.align to specify how the leftover space is distributed.point.padding(padding) ​Padding:0.10Examples · Source · If padding is specified, sets the outer padding to the specified number which is typically in the range [0, 1].jsconst x = d3.scalePoint(["a", "b", "c"], [0, 960]).padding(0.1);If padding is not specified, returns the current outer padding which defaults to 0.jsx.padding() // 0.1The outer padding specifies the amount of blank space, in terms of multiples of the step, to reserve before the first point and after the last point. Equivalent to band.paddingOuter.point.align(align) ​Align:0.50Examples · Source · If align is specified, sets the alignment to the specified value which must be in the range [0, 1].jsconst x = d3.scalePoint(["a", "b", "c"], [0, 960]).align(0.5);If align is not specified, returns the current alignment which defaults to 0.5.jsx.align() // 0.5The alignment specifies how any leftover unused space in the range is distributed. A value of 0.5 indicates that the leftover space should be equally distributed before the first point and after the last point; i.e., the points should be centered within the range. A value of 0 or 1 may be used to shift the points to one side, say to position them adjacent to an axis.point.bandwidth() ​Examples · Source · Returns zero.point.step() ​Examples · Source · Returns the distance between adjacent points.point.copy() ​Examples · Source · Returns an exact copy of this scale. Changes to this scale will not affect the returned scale, and vice versa.\n\n\n\nSequential scales ​Sequential scales are similar to linear scales in that they map a continuous, numeric input domain to a continuous output range. Unlike linear scales, the input domain and output range of a sequential scale always have exactly two elements, and the output range is typically specified as an interpolator rather than an array of values. Sequential scales are typically used for a color encoding; see also d3-scale-chromatic. These scales do not expose invert and interpolate methods. There are also log, pow, symlog, and quantile variants of sequential scales.scaleSequential(domain, interpolator) ​Examples · Source · Constructs a new sequential scale with the specified domain and interpolator function or array.jsconst color = d3.scaleSequential([0, 100], d3.interpolateBlues);If domain is not specified, it defaults to [0, 1].jsconst color = d3.scaleSequential(d3.interpolateBlues);If interpolator is not specified, it defaults to the identity function.jsconst identity = d3.scaleSequential();When the scale is applied, the interpolator will be invoked with a value typically in the range [0, 1], where 0 represents the minimum value and 1 represents the maximum value. For example, to implement the ill-advised angry rainbow scale (please use interpolateRainbow instead):jsconst rainbow = d3.scaleSequential((t) => d3.hsl(t * 360, 1, 0.5) + "");If interpolator is an array, it represents the scale’s two-element output range and is converted to an interpolator function using interpolate.jsconst color = d3.scaleSequential(["red", "blue"]);A sequential scale’s domain must be numeric and must contain exactly two values.sequential.interpolator(interpolator) ​If interpolator is specified, sets the scale’s interpolator to the specified function.jsconst color = d3.scaleSequential().interpolator(d3.interpolateBlues);If interpolator is not specified, returns the scale’s current interpolator.jscolor.interpolator() // d3.interpolateBluessequential.range(range) ​See linear.range. If range is specified, the given two-element array is converted to an interpolator function using interpolate.jsconst color = d3.scaleSequential().range(["red", "blue"]);The above is equivalent to:jsconst color = d3.scaleSequential(d3.interpolate("red", "blue"));sequential.rangeRound(range) ​See linear.rangeRound. If range is specified, implicitly uses interpolateRound as the interpolator.scaleSequentialLog(domain, range) ​Returns a new sequential scale with a logarithmic transform, analogous to a log scale.scaleSequentialPow(domain, range) ​Returns a new sequential scale with an exponential transform, analogous to a power scale.scaleSequentialSqrt(domain, range) ​Returns a new sequential scale with a square-root transform, analogous to a sqrt scale.scaleSequentialSymlog(domain, range) ​Returns a new sequential scale with a symmetric logarithmic transform, analogous to a symlog scale.scaleSequentialQuantile(domain, range) ​Source · Returns a new sequential scale with a p-quantile transform, analogous to a quantile scale.sequentialQuantile.quantiles(n) ​Source · Returns an array of n + 1 quantiles.jsconst color = d3.scaleSequentialQuantile()
    .domain(penguins.map((d) => d.body_mass_g))
    .interpolator(d3.interpolateBlues);

color.quantiles(4); // [2700, 3550, 4050, 4750, 6300]For example, if n = 4, returns an array of five numbers: the minimum value, the first quartile, the median, the third quartile, and the maximum.\n\nSearchK7.9.0GitHub️ 110.0kOn this pageSequential scales ​Sequential scales are similar to linear scales in that they map a continuous, numeric input domain to a continuous output range. Unlike linear scales, the input domain and output range of a sequential scale always have exactly two elements, and the output range is typically specified as an interpolator rather than an array of values. Sequential scales are typically used for a color encoding; see also d3-scale-chromatic. These scales do not expose invert and interpolate methods. There are also log, pow, symlog, and quantile variants of sequential scales.scaleSequential(domain, interpolator) ​Examples · Source · Constructs a new sequential scale with the specified domain and interpolator function or array.jsconst color = d3.scaleSequential([0, 100], d3.interpolateBlues);If domain is not specified, it defaults to [0, 1].jsconst color = d3.scaleSequential(d3.interpolateBlues);If interpolator is not specified, it defaults to the identity function.jsconst identity = d3.scaleSequential();When the scale is applied, the interpolator will be invoked with a value typically in the range [0, 1], where 0 represents the minimum value and 1 represents the maximum value. For example, to implement the ill-advised angry rainbow scale (please use interpolateRainbow instead):jsconst rainbow = d3.scaleSequential((t) => d3.hsl(t * 360, 1, 0.5) + "");If interpolator is an array, it represents the scale’s two-element output range and is converted to an interpolator function using interpolate.jsconst color = d3.scaleSequential(["red", "blue"]);A sequential scale’s domain must be numeric and must contain exactly two values.sequential.interpolator(interpolator) ​If interpolator is specified, sets the scale’s interpolator to the specified function.jsconst color = d3.scaleSequential().interpolator(d3.interpolateBlues);If interpolator is not specified, returns the scale’s current interpolator.jscolor.interpolator() // d3.interpolateBluessequential.range(range) ​See linear.range. If range is specified, the given two-element array is converted to an interpolator function using interpolate.jsconst color = d3.scaleSequential().range(["red", "blue"]);The above is equivalent to:jsconst color = d3.scaleSequential(d3.interpolate("red", "blue"));sequential.rangeRound(range) ​See linear.rangeRound. If range is specified, implicitly uses interpolateRound as the interpolator.scaleSequentialLog(domain, range) ​Returns a new sequential scale with a logarithmic transform, analogous to a log scale.scaleSequentialPow(domain, range) ​Returns a new sequential scale with an exponential transform, analogous to a power scale.scaleSequentialSqrt(domain, range) ​Returns a new sequential scale with a square-root transform, analogous to a sqrt scale.scaleSequentialSymlog(domain, range) ​Returns a new sequential scale with a symmetric logarithmic transform, analogous to a symlog scale.scaleSequentialQuantile(domain, range) ​Source · Returns a new sequential scale with a p-quantile transform, analogous to a quantile scale.sequentialQuantile.quantiles(n) ​Source · Returns an array of n + 1 quantiles.jsconst color = d3.scaleSequentialQuantile()
    .domain(penguins.map((d) => d.body_mass_g))
    .interpolator(d3.interpolateBlues);

color.quantiles(4); // [2700, 3550, 4050, 4750, 6300]For example, if n = 4, returns an array of five numbers: the minimum value, the first quartile, the median, the third quartile, and the maximum.PagerPrevious pagePoint scalesNext pageDiverging scales\n\nSequential scales ​Sequential scales are similar to linear scales in that they map a continuous, numeric input domain to a continuous output range. Unlike linear scales, the input domain and output range of a sequential scale always have exactly two elements, and the output range is typically specified as an interpolator rather than an array of values. Sequential scales are typically used for a color encoding; see also d3-scale-chromatic. These scales do not expose invert and interpolate methods. There are also log, pow, symlog, and quantile variants of sequential scales.scaleSequential(domain, interpolator) ​Examples · Source · Constructs a new sequential scale with the specified domain and interpolator function or array.jsconst color = d3.scaleSequential([0, 100], d3.interpolateBlues);If domain is not specified, it defaults to [0, 1].jsconst color = d3.scaleSequential(d3.interpolateBlues);If interpolator is not specified, it defaults to the identity function.jsconst identity = d3.scaleSequential();When the scale is applied, the interpolator will be invoked with a value typically in the range [0, 1], where 0 represents the minimum value and 1 represents the maximum value. For example, to implement the ill-advised angry rainbow scale (please use interpolateRainbow instead):jsconst rainbow = d3.scaleSequential((t) => d3.hsl(t * 360, 1, 0.5) + "");If interpolator is an array, it represents the scale’s two-element output range and is converted to an interpolator function using interpolate.jsconst color = d3.scaleSequential(["red", "blue"]);A sequential scale’s domain must be numeric and must contain exactly two values.sequential.interpolator(interpolator) ​If interpolator is specified, sets the scale’s interpolator to the specified function.jsconst color = d3.scaleSequential().interpolator(d3.interpolateBlues);If interpolator is not specified, returns the scale’s current interpolator.jscolor.interpolator() // d3.interpolateBluessequential.range(range) ​See linear.range. If range is specified, the given two-element array is converted to an interpolator function using interpolate.jsconst color = d3.scaleSequential().range(["red", "blue"]);The above is equivalent to:jsconst color = d3.scaleSequential(d3.interpolate("red", "blue"));sequential.rangeRound(range) ​See linear.rangeRound. If range is specified, implicitly uses interpolateRound as the interpolator.scaleSequentialLog(domain, range) ​Returns a new sequential scale with a logarithmic transform, analogous to a log scale.scaleSequentialPow(domain, range) ​Returns a new sequential scale with an exponential transform, analogous to a power scale.scaleSequentialSqrt(domain, range) ​Returns a new sequential scale with a square-root transform, analogous to a sqrt scale.scaleSequentialSymlog(domain, range) ​Returns a new sequential scale with a symmetric logarithmic transform, analogous to a symlog scale.scaleSequentialQuantile(domain, range) ​Source · Returns a new sequential scale with a p-quantile transform, analogous to a quantile scale.sequentialQuantile.quantiles(n) ​Source · Returns an array of n + 1 quantiles.jsconst color = d3.scaleSequentialQuantile()
    .domain(penguins.map((d) => d.body_mass_g))
    .interpolator(d3.interpolateBlues);

color.quantiles(4); // [2700, 3550, 4050, 4750, 6300]For example, if n = 4, returns an array of five numbers: the minimum value, the first quartile, the median, the third quartile, and the maximum.\n\n\n\nDiverging scales ​Diverging scales are similar to linear scales in that they map a continuous, numeric input domain to a continuous output range. Unlike linear scales, the input domain and output range of a diverging scale always have exactly three elements, and the output range is typically specified as an interpolator rather than an array of values. Diverging scales are typically used for a color encoding; see also d3-scale-chromatic. These scales do not expose invert and interpolate methods. There are also log, pow, and symlog variants of diverging scales.scaleDiverging(domain, interpolator) ​Examples · Source · Constructs a new diverging scale with the specified domain and interpolator function or array.jsconst color = d3.scaleDiverging([-1, 0, 1], d3.interpolateRdBu);If domain is not specified, it defaults to [0, 0.5, 1].jsconst color = d3.scaleDiverging(d3.interpolateRdBu);If interpolator is not specified, it defaults to the identity function.jsconst identity = d3.scaleDiverging();When the scale is applied, the interpolator will be invoked with a value typically in the range [0, 1], where 0 represents the extreme negative value, 0.5 represents the neutral value, and 1 represents the extreme positive value.If interpolator is an array, it represents the scale’s three-element output range and is converted to an interpolator function using d3.interpolate and d3.piecewise.jsconst color = d3.scaleDiverging(["blue", "white", "red"]);A diverging scale’s domain must be numeric and must contain exactly three values.diverging.interpolator(interpolator) ​If interpolator is specified, sets the scale’s interpolator to the specified function.jsconst color = d3.scaleDiverging().interpolator(d3.interpolateRdBu);If interpolator is not specified, returns the scale’s current interpolator.jscolor.interpolator() // d3.interpolateRdBudiverging.range(range) ​See linear.range. If range is specified, the given three-element array is converted to an interpolator function using piecewise.jsconst color = d3.scaleDiverging().range(["blue", "white", "red"]);The above is equivalent to:jsconst color = d3.scaleDiverging(d3.piecewise(["blue", "white", "red"]));diverging.rangeRound(range) ​See linear.range. If range is specified, implicitly uses interpolateRound as the interpolator.scaleDivergingLog(domain, range) ​Returns a new diverging scale with a logarithmic transform, analogous to a log scale.scaleDivergingPow(domain, range) ​Returns a new diverging scale with an exponential transform, analogous to a power scale.scaleDivergingSqrt(domain, range) ​Returns a new diverging scale with a square-root transform, analogous to a sqrt scale.scaleDivergingSymlog(domain, range) ​Returns a new diverging scale with a symmetric logarithmic transform, analogous to a symlog scale.\n\nSearchK7.9.0GitHub️ 110.0kOn this pageDiverging scales ​Diverging scales are similar to linear scales in that they map a continuous, numeric input domain to a continuous output range. Unlike linear scales, the input domain and output range of a diverging scale always have exactly three elements, and the output range is typically specified as an interpolator rather than an array of values. Diverging scales are typically used for a color encoding; see also d3-scale-chromatic. These scales do not expose invert and interpolate methods. There are also log, pow, and symlog variants of diverging scales.scaleDiverging(domain, interpolator) ​Examples · Source · Constructs a new diverging scale with the specified domain and interpolator function or array.jsconst color = d3.scaleDiverging([-1, 0, 1], d3.interpolateRdBu);If domain is not specified, it defaults to [0, 0.5, 1].jsconst color = d3.scaleDiverging(d3.interpolateRdBu);If interpolator is not specified, it defaults to the identity function.jsconst identity = d3.scaleDiverging();When the scale is applied, the interpolator will be invoked with a value typically in the range [0, 1], where 0 represents the extreme negative value, 0.5 represents the neutral value, and 1 represents the extreme positive value.If interpolator is an array, it represents the scale’s three-element output range and is converted to an interpolator function using d3.interpolate and d3.piecewise.jsconst color = d3.scaleDiverging(["blue", "white", "red"]);A diverging scale’s domain must be numeric and must contain exactly three values.diverging.interpolator(interpolator) ​If interpolator is specified, sets the scale’s interpolator to the specified function.jsconst color = d3.scaleDiverging().interpolator(d3.interpolateRdBu);If interpolator is not specified, returns the scale’s current interpolator.jscolor.interpolator() // d3.interpolateRdBudiverging.range(range) ​See linear.range. If range is specified, the given three-element array is converted to an interpolator function using piecewise.jsconst color = d3.scaleDiverging().range(["blue", "white", "red"]);The above is equivalent to:jsconst color = d3.scaleDiverging(d3.piecewise(["blue", "white", "red"]));diverging.rangeRound(range) ​See linear.range. If range is specified, implicitly uses interpolateRound as the interpolator.scaleDivergingLog(domain, range) ​Returns a new diverging scale with a logarithmic transform, analogous to a log scale.scaleDivergingPow(domain, range) ​Returns a new diverging scale with an exponential transform, analogous to a power scale.scaleDivergingSqrt(domain, range) ​Returns a new diverging scale with a square-root transform, analogous to a sqrt scale.scaleDivergingSymlog(domain, range) ​Returns a new diverging scale with a symmetric logarithmic transform, analogous to a symlog scale.PagerPrevious pageSequential scalesNext pageQuantile scales\n\nDiverging scales ​Diverging scales are similar to linear scales in that they map a continuous, numeric input domain to a continuous output range. Unlike linear scales, the input domain and output range of a diverging scale always have exactly three elements, and the output range is typically specified as an interpolator rather than an array of values. Diverging scales are typically used for a color encoding; see also d3-scale-chromatic. These scales do not expose invert and interpolate methods. There are also log, pow, and symlog variants of diverging scales.scaleDiverging(domain, interpolator) ​Examples · Source · Constructs a new diverging scale with the specified domain and interpolator function or array.jsconst color = d3.scaleDiverging([-1, 0, 1], d3.interpolateRdBu);If domain is not specified, it defaults to [0, 0.5, 1].jsconst color = d3.scaleDiverging(d3.interpolateRdBu);If interpolator is not specified, it defaults to the identity function.jsconst identity = d3.scaleDiverging();When the scale is applied, the interpolator will be invoked with a value typically in the range [0, 1], where 0 represents the extreme negative value, 0.5 represents the neutral value, and 1 represents the extreme positive value.If interpolator is an array, it represents the scale’s three-element output range and is converted to an interpolator function using d3.interpolate and d3.piecewise.jsconst color = d3.scaleDiverging(["blue", "white", "red"]);A diverging scale’s domain must be numeric and must contain exactly three values.diverging.interpolator(interpolator) ​If interpolator is specified, sets the scale’s interpolator to the specified function.jsconst color = d3.scaleDiverging().interpolator(d3.interpolateRdBu);If interpolator is not specified, returns the scale’s current interpolator.jscolor.interpolator() // d3.interpolateRdBudiverging.range(range) ​See linear.range. If range is specified, the given three-element array is converted to an interpolator function using piecewise.jsconst color = d3.scaleDiverging().range(["blue", "white", "red"]);The above is equivalent to:jsconst color = d3.scaleDiverging(d3.piecewise(["blue", "white", "red"]));diverging.rangeRound(range) ​See linear.range. If range is specified, implicitly uses interpolateRound as the interpolator.scaleDivergingLog(domain, range) ​Returns a new diverging scale with a logarithmic transform, analogous to a log scale.scaleDivergingPow(domain, range) ​Returns a new diverging scale with an exponential transform, analogous to a power scale.scaleDivergingSqrt(domain, range) ​Returns a new diverging scale with a square-root transform, analogous to a sqrt scale.scaleDivergingSymlog(domain, range) ​Returns a new diverging scale with a symmetric logarithmic transform, analogous to a symlog scale.\n\n\n\nQuantile scales ​Quantile scales map a sampled input domain to a discrete range. The domain is considered continuous and thus the scale will accept any reasonable input value; however, the domain is specified as a discrete set of sample values. The number of values in (the cardinality of) the output range determines the number of quantiles that will be computed from the domain. To compute the quantiles, the domain is sorted, and treated as a population of discrete values; see quantile. See this quantile choropleth for an example.scaleQuantile(domain, range) ​Examples · Source · Constructs a new quantile scale with the specified domain and range.jsconst color = d3.scaleQuantile(penguins.map((d) => d.body_mass_g), d3.schemeBlues[5]);If either domain or range is not specified, each defaults to the empty array. The quantile scale is invalid until both a domain and range are specified.quantile(value) ​Examples · Source · Given a value in the input domain, returns the corresponding value in the output range.jscolor(3000); // "#eff3ff"
color(4000); // "#6baed6"
color(5000); // "#08519c"quantile.invertExtent(value) ​Examples · Source · Returns the extent of values in the domain [x0, x1] for the corresponding value in the range: the inverse of quantile.jscolor.invertExtent("#eff3ff"); // [2700, 3475]
color.invertExtent("#6baed6"); // [3800, 4300]
color.invertExtent("#08519c"); // [4950, 6300]This method is useful for interaction, say to determine the value in the domain that corresponds to the pixel location under the mouse.quantile.domain(domain) ​Examples · Source · If domain is specified, sets the domain of the quantile scale to the specified set of discrete numeric values and returns this scale.jsconst color = d3.scaleQuantile(d3.schemeBlues[5]);
color.domain(penguins.map((d) => d.body_mass_g));The array must not be empty, and must contain at least one numeric value; NaN, null and undefined values are ignored and not considered part of the sample population. If the elements in the given array are not numbers, they will be coerced to numbers. A copy of the input array is sorted and stored internally.If domain is not specified, returns the scale’s current domain (the set of observed values).jscolor.domain() // [2700, 2850, 2850, 2900, 2900, 2900, 2900, …]quantile.range(range) ​Examples · Source · If range is specified, sets the discrete values in the range.jsconst color = d3.scaleQuantile();
color.range(d3.schemeBlues[5]);The array must not be empty, and may contain any type of value. The number of values in (the cardinality, or length, of) the range array determines the number of quantiles that are computed. For example, to compute quartiles, range must be an array of four elements such as [0, 1, 2, 3].If range is not specified, returns the current range.jscolor.range() // ["#eff3ff", "#bdd7e7", "#6baed6", "#3182bd", "#08519c"]quantile.quantiles() ​Examples · Source · Returns the quantile thresholds.jscolor.quantiles() // [3475, 3800, 4300, 4950]If the range contains n discrete values, the returned array will contain n - 1 thresholds. Values less than the first threshold are considered in the first quantile; values greater than or equal to the first threshold but less than the second threshold are in the second quantile, and so on. Internally, the thresholds array is used with bisect to find the output quantile associated with the given input value.quantile.copy() ​Examples · Source · Returns an exact copy of this scale.jsconst c1 = d3.scaleQuantile(d3.schemeBlues[5]);
const c2 = c1.copy();Changes to this scale will not affect the returned scale, and vice versa.\n\nSearchK7.9.0GitHub️ 110.0kOn this pageQuantile scales ​Quantile scales map a sampled input domain to a discrete range. The domain is considered continuous and thus the scale will accept any reasonable input value; however, the domain is specified as a discrete set of sample values. The number of values in (the cardinality of) the output range determines the number of quantiles that will be computed from the domain. To compute the quantiles, the domain is sorted, and treated as a population of discrete values; see quantile. See this quantile choropleth for an example.scaleQuantile(domain, range) ​Examples · Source · Constructs a new quantile scale with the specified domain and range.jsconst color = d3.scaleQuantile(penguins.map((d) => d.body_mass_g), d3.schemeBlues[5]);If either domain or range is not specified, each defaults to the empty array. The quantile scale is invalid until both a domain and range are specified.quantile(value) ​Examples · Source · Given a value in the input domain, returns the corresponding value in the output range.jscolor(3000); // "#eff3ff"
color(4000); // "#6baed6"
color(5000); // "#08519c"quantile.invertExtent(value) ​Examples · Source · Returns the extent of values in the domain [x0, x1] for the corresponding value in the range: the inverse of quantile.jscolor.invertExtent("#eff3ff"); // [2700, 3475]
color.invertExtent("#6baed6"); // [3800, 4300]
color.invertExtent("#08519c"); // [4950, 6300]This method is useful for interaction, say to determine the value in the domain that corresponds to the pixel location under the mouse.quantile.domain(domain) ​Examples · Source · If domain is specified, sets the domain of the quantile scale to the specified set of discrete numeric values and returns this scale.jsconst color = d3.scaleQuantile(d3.schemeBlues[5]);
color.domain(penguins.map((d) => d.body_mass_g));The array must not be empty, and must contain at least one numeric value; NaN, null and undefined values are ignored and not considered part of the sample population. If the elements in the given array are not numbers, they will be coerced to numbers. A copy of the input array is sorted and stored internally.If domain is not specified, returns the scale’s current domain (the set of observed values).jscolor.domain() // [2700, 2850, 2850, 2900, 2900, 2900, 2900, …]quantile.range(range) ​Examples · Source · If range is specified, sets the discrete values in the range.jsconst color = d3.scaleQuantile();
color.range(d3.schemeBlues[5]);The array must not be empty, and may contain any type of value. The number of values in (the cardinality, or length, of) the range array determines the number of quantiles that are computed. For example, to compute quartiles, range must be an array of four elements such as [0, 1, 2, 3].If range is not specified, returns the current range.jscolor.range() // ["#eff3ff", "#bdd7e7", "#6baed6", "#3182bd", "#08519c"]quantile.quantiles() ​Examples · Source · Returns the quantile thresholds.jscolor.quantiles() // [3475, 3800, 4300, 4950]If the range contains n discrete values, the returned array will contain n - 1 thresholds. Values less than the first threshold are considered in the first quantile; values greater than or equal to the first threshold but less than the second threshold are in the second quantile, and so on. Internally, the thresholds array is used with bisect to find the output quantile associated with the given input value.quantile.copy() ​Examples · Source · Returns an exact copy of this scale.jsconst c1 = d3.scaleQuantile(d3.schemeBlues[5]);
const c2 = c1.copy();Changes to this scale will not affect the returned scale, and vice versa.PagerPrevious pageDiverging scalesNext pageQuantize scales\n\nQuantile scales ​Quantile scales map a sampled input domain to a discrete range. The domain is considered continuous and thus the scale will accept any reasonable input value; however, the domain is specified as a discrete set of sample values. The number of values in (the cardinality of) the output range determines the number of quantiles that will be computed from the domain. To compute the quantiles, the domain is sorted, and treated as a population of discrete values; see quantile. See this quantile choropleth for an example.scaleQuantile(domain, range) ​Examples · Source · Constructs a new quantile scale with the specified domain and range.jsconst color = d3.scaleQuantile(penguins.map((d) => d.body_mass_g), d3.schemeBlues[5]);If either domain or range is not specified, each defaults to the empty array. The quantile scale is invalid until both a domain and range are specified.quantile(value) ​Examples · Source · Given a value in the input domain, returns the corresponding value in the output range.jscolor(3000); // "#eff3ff"
color(4000); // "#6baed6"
color(5000); // "#08519c"quantile.invertExtent(value) ​Examples · Source · Returns the extent of values in the domain [x0, x1] for the corresponding value in the range: the inverse of quantile.jscolor.invertExtent("#eff3ff"); // [2700, 3475]
color.invertExtent("#6baed6"); // [3800, 4300]
color.invertExtent("#08519c"); // [4950, 6300]This method is useful for interaction, say to determine the value in the domain that corresponds to the pixel location under the mouse.quantile.domain(domain) ​Examples · Source · If domain is specified, sets the domain of the quantile scale to the specified set of discrete numeric values and returns this scale.jsconst color = d3.scaleQuantile(d3.schemeBlues[5]);
color.domain(penguins.map((d) => d.body_mass_g));The array must not be empty, and must contain at least one numeric value; NaN, null and undefined values are ignored and not considered part of the sample population. If the elements in the given array are not numbers, they will be coerced to numbers. A copy of the input array is sorted and stored internally.If domain is not specified, returns the scale’s current domain (the set of observed values).jscolor.domain() // [2700, 2850, 2850, 2900, 2900, 2900, 2900, …]quantile.range(range) ​Examples · Source · If range is specified, sets the discrete values in the range.jsconst color = d3.scaleQuantile();
color.range(d3.schemeBlues[5]);The array must not be empty, and may contain any type of value. The number of values in (the cardinality, or length, of) the range array determines the number of quantiles that are computed. For example, to compute quartiles, range must be an array of four elements such as [0, 1, 2, 3].If range is not specified, returns the current range.jscolor.range() // ["#eff3ff", "#bdd7e7", "#6baed6", "#3182bd", "#08519c"]quantile.quantiles() ​Examples · Source · Returns the quantile thresholds.jscolor.quantiles() // [3475, 3800, 4300, 4950]If the range contains n discrete values, the returned array will contain n - 1 thresholds. Values less than the first threshold are considered in the first quantile; values greater than or equal to the first threshold but less than the second threshold are in the second quantile, and so on. Internally, the thresholds array is used with bisect to find the output quantile associated with the given input value.quantile.copy() ​Examples · Source · Returns an exact copy of this scale.jsconst c1 = d3.scaleQuantile(d3.schemeBlues[5]);
const c2 = c1.copy();Changes to this scale will not affect the returned scale, and vice versa.\n\n\n\nQuantize scales ​Quantize scales are similar to linear scales, except they use a discrete rather than continuous range. The continuous input domain is divided into uniform segments based on the number of values in (i.e., the cardinality of) the output range. Each range value y can be expressed as a quantized linear function of the domain value x: y = m round(x) + b. See the quantized choropleth for an example.scaleQuantize(domain, range) ​Examples · Source · Constructs a new quantize scale with the specified domain and range.jsconst color = d3.scaleQuantize([0, 100], d3.schemeBlues[9]);If either domain or range is not specified, each defaults to [0, 1].jsconst color = d3.scaleQuantize(d3.schemeBlues[9]);quantize(value) ​Examples · Source · Given a value in the input domain, returns the corresponding value in the output range. For example, to apply a color encoding:jsconst color = d3.scaleQuantize([0, 1], ["brown", "steelblue"]);
color(0.49); // "brown"
color(0.51); // "steelblue"Or dividing the domain into three equally-sized parts with different range values to compute an appropriate stroke width:jsconst width = d3.scaleQuantize([10, 100], [1, 2, 4]);
width(20); // 1
width(50); // 2
width(80); // 4quantize.invertExtent(value) ​Examples · Source · Returns the extent of values in the domain [x0, x1] for the corresponding value in the range: the inverse of quantize. This method is useful for interaction, say to determine the value in the domain that corresponds to the pixel location under the mouse.jsconst width = d3.scaleQuantize([10, 100], [1, 2, 4]);
width.invertExtent(2); // [40, 70]quantize.domain(domain) ​Examples · Source · If domain is specified, sets the scale’s domain to the specified two-element array of numbers.jsconst color = d3.scaleQuantize(d3.schemeBlues[9]);
color.domain([0, 100]);If the elements in the given array are not numbers, they will be coerced to numbers. The numbers must be in ascending order or the behavior of the scale is undefined.If domain is not specified, returns the scale’s current domain.jscolor.domain() // [0, 100]quantize.range(range) ​Examples · Source · If range is specified, sets the scale’s range to the specified array of values.jsconst color = d3.scaleQuantize();
color.range(d3.schemeBlues[5]);The array may contain any number of discrete values. The elements in the given array need not be numbers; any value or type will work.If range is not specified, returns the scale’s current range.jscolor.range() // ["#eff3ff", "#bdd7e7", "#6baed6", "#3182bd", "#08519c"]quantize.thresholds() ​Examples · Source · Returns the array of computed thresholds within the domain.jscolor.thresholds() // [0.2, 0.4, 0.6, 0.8]The number of returned thresholds is one less than the length of the range: values less than the first threshold are assigned the first element in the range, whereas values greater than or equal to the last threshold are assigned the last element in the range.quantize.copy() ​Examples · Source · Returns an exact copy of this scale.jsconst c1 = d3.scaleQuantize(d3.schemeBlues[5]);
const c2 = c1.copy();Changes to this scale will not affect the returned scale, and vice versa.\n\nSearchK7.9.0GitHub️ 110.0kOn this pageQuantize scales ​Quantize scales are similar to linear scales, except they use a discrete rather than continuous range. The continuous input domain is divided into uniform segments based on the number of values in (i.e., the cardinality of) the output range. Each range value y can be expressed as a quantized linear function of the domain value x: y = m round(x) + b. See the quantized choropleth for an example.scaleQuantize(domain, range) ​Examples · Source · Constructs a new quantize scale with the specified domain and range.jsconst color = d3.scaleQuantize([0, 100], d3.schemeBlues[9]);If either domain or range is not specified, each defaults to [0, 1].jsconst color = d3.scaleQuantize(d3.schemeBlues[9]);quantize(value) ​Examples · Source · Given a value in the input domain, returns the corresponding value in the output range. For example, to apply a color encoding:jsconst color = d3.scaleQuantize([0, 1], ["brown", "steelblue"]);
color(0.49); // "brown"
color(0.51); // "steelblue"Or dividing the domain into three equally-sized parts with different range values to compute an appropriate stroke width:jsconst width = d3.scaleQuantize([10, 100], [1, 2, 4]);
width(20); // 1
width(50); // 2
width(80); // 4quantize.invertExtent(value) ​Examples · Source · Returns the extent of values in the domain [x0, x1] for the corresponding value in the range: the inverse of quantize. This method is useful for interaction, say to determine the value in the domain that corresponds to the pixel location under the mouse.jsconst width = d3.scaleQuantize([10, 100], [1, 2, 4]);
width.invertExtent(2); // [40, 70]quantize.domain(domain) ​Examples · Source · If domain is specified, sets the scale’s domain to the specified two-element array of numbers.jsconst color = d3.scaleQuantize(d3.schemeBlues[9]);
color.domain([0, 100]);If the elements in the given array are not numbers, they will be coerced to numbers. The numbers must be in ascending order or the behavior of the scale is undefined.If domain is not specified, returns the scale’s current domain.jscolor.domain() // [0, 100]quantize.range(range) ​Examples · Source · If range is specified, sets the scale’s range to the specified array of values.jsconst color = d3.scaleQuantize();
color.range(d3.schemeBlues[5]);The array may contain any number of discrete values. The elements in the given array need not be numbers; any value or type will work.If range is not specified, returns the scale’s current range.jscolor.range() // ["#eff3ff", "#bdd7e7", "#6baed6", "#3182bd", "#08519c"]quantize.thresholds() ​Examples · Source · Returns the array of computed thresholds within the domain.jscolor.thresholds() // [0.2, 0.4, 0.6, 0.8]The number of returned thresholds is one less than the length of the range: values less than the first threshold are assigned the first element in the range, whereas values greater than or equal to the last threshold are assigned the last element in the range.quantize.copy() ​Examples · Source · Returns an exact copy of this scale.jsconst c1 = d3.scaleQuantize(d3.schemeBlues[5]);
const c2 = c1.copy();Changes to this scale will not affect the returned scale, and vice versa.PagerPrevious pageQuantile scalesNext pageThreshold scales\n\nQuantize scales ​Quantize scales are similar to linear scales, except they use a discrete rather than continuous range. The continuous input domain is divided into uniform segments based on the number of values in (i.e., the cardinality of) the output range. Each range value y can be expressed as a quantized linear function of the domain value x: y = m round(x) + b. See the quantized choropleth for an example.scaleQuantize(domain, range) ​Examples · Source · Constructs a new quantize scale with the specified domain and range.jsconst color = d3.scaleQuantize([0, 100], d3.schemeBlues[9]);If either domain or range is not specified, each defaults to [0, 1].jsconst color = d3.scaleQuantize(d3.schemeBlues[9]);quantize(value) ​Examples · Source · Given a value in the input domain, returns the corresponding value in the output range. For example, to apply a color encoding:jsconst color = d3.scaleQuantize([0, 1], ["brown", "steelblue"]);
color(0.49); // "brown"
color(0.51); // "steelblue"Or dividing the domain into three equally-sized parts with different range values to compute an appropriate stroke width:jsconst width = d3.scaleQuantize([10, 100], [1, 2, 4]);
width(20); // 1
width(50); // 2
width(80); // 4quantize.invertExtent(value) ​Examples · Source · Returns the extent of values in the domain [x0, x1] for the corresponding value in the range: the inverse of quantize. This method is useful for interaction, say to determine the value in the domain that corresponds to the pixel location under the mouse.jsconst width = d3.scaleQuantize([10, 100], [1, 2, 4]);
width.invertExtent(2); // [40, 70]quantize.domain(domain) ​Examples · Source · If domain is specified, sets the scale’s domain to the specified two-element array of numbers.jsconst color = d3.scaleQuantize(d3.schemeBlues[9]);
color.domain([0, 100]);If the elements in the given array are not numbers, they will be coerced to numbers. The numbers must be in ascending order or the behavior of the scale is undefined.If domain is not specified, returns the scale’s current domain.jscolor.domain() // [0, 100]quantize.range(range) ​Examples · Source · If range is specified, sets the scale’s range to the specified array of values.jsconst color = d3.scaleQuantize();
color.range(d3.schemeBlues[5]);The array may contain any number of discrete values. The elements in the given array need not be numbers; any value or type will work.If range is not specified, returns the scale’s current range.jscolor.range() // ["#eff3ff", "#bdd7e7", "#6baed6", "#3182bd", "#08519c"]quantize.thresholds() ​Examples · Source · Returns the array of computed thresholds within the domain.jscolor.thresholds() // [0.2, 0.4, 0.6, 0.8]The number of returned thresholds is one less than the length of the range: values less than the first threshold are assigned the first element in the range, whereas values greater than or equal to the last threshold are assigned the last element in the range.quantize.copy() ​Examples · Source · Returns an exact copy of this scale.jsconst c1 = d3.scaleQuantize(d3.schemeBlues[5]);
const c2 = c1.copy();Changes to this scale will not affect the returned scale, and vice versa.\n\n\n\nThreshold scales ​Threshold scales are similar to quantize scales, except they allow you to map arbitrary subsets of the domain to discrete values in the range. The input domain is still continuous, and divided into slices based on a set of threshold values. See this choropleth for an example.scaleThreshold(domain, range) ​Examples · Source · Constructs a new threshold scale with the specified domain and range.jsconst color = d3.scaleThreshold([0, 1], ["red", "white", "blue"]);If domain is not specified, it defaults to [0.5].jsconst color = d3.scaleThreshold(["red", "blue"]);
color(0); // "red"
color(1); // "blue"If range is not specified, it defaults to [0, 1].threshold(value) ​Examples · Source · Given a value in the input domain, returns the corresponding value in the output range. For example:jsconst color = d3.scaleThreshold([0, 1], ["red", "white", "green"]);
color(-1); // "red"
color(0); // "white"
color(0.5); // "white"
color(1); // "green"
color(1000); // "green"threshold.invertExtent(value) ​Source · Returns the extent of values in the domain [x0, x1] for the corresponding value in the range, representing the inverse mapping from range to domain.jsconst color = d3.scaleThreshold([0, 1], ["red", "white", "green"]);
color.invertExtent("red"); // [undefined, 0]
color.invertExtent("white"); // [0, 1]
color.invertExtent("green"); // [1, undefined]This method is useful for interaction, say to determine the value in the domain that corresponds to the pixel location under the mouse. The extent below the lowest threshold is undefined (unbounded), as is the extent above the highest threshold.threshold.domain(domain) ​Examples · Source · If domain is specified, sets the scale’s domain to the specified array of values.jsconst color = d3.scaleThreshold(["red", "white", "green"]).domain([0, 1]);The values must be in ascending order or the behavior of the scale is undefined. The values are typically numbers, but any naturally ordered values (such as strings) will work; a threshold scale can be used to encode any type that is ordered. If the number of values in the scale’s range is n + 1, the number of values in the scale’s domain must be n. If there are fewer than n elements in the domain, the additional values in the range are ignored. If there are more than n elements in the domain, the scale may return undefined for some inputs.If domain is not specified, returns the scale’s current domain.jscolor.domain() // [0, 1]threshold.range(range) ​Examples · Source · If range is specified, sets the scale’s range to the specified array of values.jsconst color = d3.scaleThreshold().range(["red", "white", "green"]);If the number of values in the scale’s domain is n, the number of values in the scale’s range must be n + 1. If there are fewer than n + 1 elements in the range, the scale may return undefined for some inputs. If there are more than n + 1 elements in the range, the additional values are ignored. The elements in the given array need not be numbers; any value or type will work.If range is not specified, returns the scale’s current range.jscolor.range() // ["red", "white", "green"]threshold.copy() ​Examples · Source · Returns an exact copy of this scale.jsconst c1 = d3.scaleThreshold(d3.schemeBlues[5]);
const c2 = c1.copy();Changes to this scale will not affect the returned scale, and vice versa.\n\nSearchK7.9.0GitHub️ 110.0kOn this pageThreshold scales ​Threshold scales are similar to quantize scales, except they allow you to map arbitrary subsets of the domain to discrete values in the range. The input domain is still continuous, and divided into slices based on a set of threshold values. See this choropleth for an example.scaleThreshold(domain, range) ​Examples · Source · Constructs a new threshold scale with the specified domain and range.jsconst color = d3.scaleThreshold([0, 1], ["red", "white", "blue"]);If domain is not specified, it defaults to [0.5].jsconst color = d3.scaleThreshold(["red", "blue"]);
color(0); // "red"
color(1); // "blue"If range is not specified, it defaults to [0, 1].threshold(value) ​Examples · Source · Given a value in the input domain, returns the corresponding value in the output range. For example:jsconst color = d3.scaleThreshold([0, 1], ["red", "white", "green"]);
color(-1); // "red"
color(0); // "white"
color(0.5); // "white"
color(1); // "green"
color(1000); // "green"threshold.invertExtent(value) ​Source · Returns the extent of values in the domain [x0, x1] for the corresponding value in the range, representing the inverse mapping from range to domain.jsconst color = d3.scaleThreshold([0, 1], ["red", "white", "green"]);
color.invertExtent("red"); // [undefined, 0]
color.invertExtent("white"); // [0, 1]
color.invertExtent("green"); // [1, undefined]This method is useful for interaction, say to determine the value in the domain that corresponds to the pixel location under the mouse. The extent below the lowest threshold is undefined (unbounded), as is the extent above the highest threshold.threshold.domain(domain) ​Examples · Source · If domain is specified, sets the scale’s domain to the specified array of values.jsconst color = d3.scaleThreshold(["red", "white", "green"]).domain([0, 1]);The values must be in ascending order or the behavior of the scale is undefined. The values are typically numbers, but any naturally ordered values (such as strings) will work; a threshold scale can be used to encode any type that is ordered. If the number of values in the scale’s range is n + 1, the number of values in the scale’s domain must be n. If there are fewer than n elements in the domain, the additional values in the range are ignored. If there are more than n elements in the domain, the scale may return undefined for some inputs.If domain is not specified, returns the scale’s current domain.jscolor.domain() // [0, 1]threshold.range(range) ​Examples · Source · If range is specified, sets the scale’s range to the specified array of values.jsconst color = d3.scaleThreshold().range(["red", "white", "green"]);If the number of values in the scale’s domain is n, the number of values in the scale’s range must be n + 1. If there are fewer than n + 1 elements in the range, the scale may return undefined for some inputs. If there are more than n + 1 elements in the range, the additional values are ignored. The elements in the given array need not be numbers; any value or type will work.If range is not specified, returns the scale’s current range.jscolor.range() // ["red", "white", "green"]threshold.copy() ​Examples · Source · Returns an exact copy of this scale.jsconst c1 = d3.scaleThreshold(d3.schemeBlues[5]);
const c2 = c1.copy();Changes to this scale will not affect the returned scale, and vice versa.PagerPrevious pageQuantize scalesNext paged3-scale-chromatic\n\nThreshold scales ​Threshold scales are similar to quantize scales, except they allow you to map arbitrary subsets of the domain to discrete values in the range. The input domain is still continuous, and divided into slices based on a set of threshold values. See this choropleth for an example.scaleThreshold(domain, range) ​Examples · Source · Constructs a new threshold scale with the specified domain and range.jsconst color = d3.scaleThreshold([0, 1], ["red", "white", "blue"]);If domain is not specified, it defaults to [0.5].jsconst color = d3.scaleThreshold(["red", "blue"]);
color(0); // "red"
color(1); // "blue"If range is not specified, it defaults to [0, 1].threshold(value) ​Examples · Source · Given a value in the input domain, returns the corresponding value in the output range. For example:jsconst color = d3.scaleThreshold([0, 1], ["red", "white", "green"]);
color(-1); // "red"
color(0); // "white"
color(0.5); // "white"
color(1); // "green"
color(1000); // "green"threshold.invertExtent(value) ​Source · Returns the extent of values in the domain [x0, x1] for the corresponding value in the range, representing the inverse mapping from range to domain.jsconst color = d3.scaleThreshold([0, 1], ["red", "white", "green"]);
color.invertExtent("red"); // [undefined, 0]
color.invertExtent("white"); // [0, 1]
color.invertExtent("green"); // [1, undefined]This method is useful for interaction, say to determine the value in the domain that corresponds to the pixel location under the mouse. The extent below the lowest threshold is undefined (unbounded), as is the extent above the highest threshold.threshold.domain(domain) ​Examples · Source · If domain is specified, sets the scale’s domain to the specified array of values.jsconst color = d3.scaleThreshold(["red", "white", "green"]).domain([0, 1]);The values must be in ascending order or the behavior of the scale is undefined. The values are typically numbers, but any naturally ordered values (such as strings) will work; a threshold scale can be used to encode any type that is ordered. If the number of values in the scale’s range is n + 1, the number of values in the scale’s domain must be n. If there are fewer than n elements in the domain, the additional values in the range are ignored. If there are more than n elements in the domain, the scale may return undefined for some inputs.If domain is not specified, returns the scale’s current domain.jscolor.domain() // [0, 1]threshold.range(range) ​Examples · Source · If range is specified, sets the scale’s range to the specified array of values.jsconst color = d3.scaleThreshold().range(["red", "white", "green"]);If the number of values in the scale’s domain is n, the number of values in the scale’s range must be n + 1. If there are fewer than n + 1 elements in the range, the scale may return undefined for some inputs. If there are more than n + 1 elements in the range, the additional values are ignored. The elements in the given array need not be numbers; any value or type will work.If range is not specified, returns the scale’s current range.jscolor.range() // ["red", "white", "green"]threshold.copy() ​Examples · Source · Returns an exact copy of this scale.jsconst c1 = d3.scaleThreshold(d3.schemeBlues[5]);
const c2 = c1.copy();Changes to this scale will not affect the returned scale, and vice versa.\n\n\n\nd3-scale-chromatic ​This module provides sequential, diverging and categorical color schemes designed to work with d3-scale’s d3.scaleOrdinal and d3.scaleSequential. Most of these schemes are derived from Cynthia A. Brewer’s ColorBrewer. Since ColorBrewer publishes only discrete color schemes, the sequential and diverging scales are interpolated using uniform B-splines.See one of:Categorical schemesCyclical schemesDiverging schemesSequential schemes\n\nSearchK7.9.0GitHub️ 110.0kOn this paged3-scale-chromatic ​This module provides sequential, diverging and categorical color schemes designed to work with d3-scale’s d3.scaleOrdinal and d3.scaleSequential. Most of these schemes are derived from Cynthia A. Brewer’s ColorBrewer. Since ColorBrewer publishes only discrete color schemes, the sequential and diverging scales are interpolated using uniform B-splines.See one of:Categorical schemesCyclical schemesDiverging schemesSequential schemesPagerPrevious pageThreshold scalesNext pageCategorical schemes\n\nd3-scale-chromatic ​This module provides sequential, diverging and categorical color schemes designed to work with d3-scale’s d3.scaleOrdinal and d3.scaleSequential. Most of these schemes are derived from Cynthia A. Brewer’s ColorBrewer. Since ColorBrewer publishes only discrete color schemes, the sequential and diverging scales are interpolated using uniform B-splines.See one of:Categorical schemesCyclical schemesDiverging schemesSequential schemes\n\n\n\nCategorical schemes ​For example, to create a categorical color scale using the Accent color scheme:jsconst color = d3.scaleOrdinal(d3.schemeAccent);schemeCategory10 ​Source · An array of ten categorical colors represented as RGB hexadecimal strings.schemeAccent ​Source · An array of eight categorical colors represented as RGB hexadecimal strings.schemeDark2 ​Source · An array of eight categorical colors represented as RGB hexadecimal strings.schemeObservable10 ​Source · An array of ten categorical colors represented as RGB hexadecimal strings.schemePaired ​Source · An array of twelve categorical colors represented as RGB hexadecimal strings.schemePastel1 ​Source · An array of nine categorical colors represented as RGB hexadecimal strings.schemePastel2 ​Source · An array of eight categorical colors represented as RGB hexadecimal strings.schemeSet1 ​Source · An array of nine categorical colors represented as RGB hexadecimal strings.schemeSet2 ​Source · An array of eight categorical colors represented as RGB hexadecimal strings.schemeSet3 ​Source · An array of twelve categorical colors represented as RGB hexadecimal strings.schemeTableau10 ​Source · An array of ten categorical colors authored by Tableau as part of Tableau 10 represented as RGB hexadecimal strings.\n\nSearchK7.9.0GitHub️ 110.0kOn this pageCategorical schemes ​For example, to create a categorical color scale using the Accent color scheme:jsconst color = d3.scaleOrdinal(d3.schemeAccent);schemeCategory10 ​Source · An array of ten categorical colors represented as RGB hexadecimal strings.schemeAccent ​Source · An array of eight categorical colors represented as RGB hexadecimal strings.schemeDark2 ​Source · An array of eight categorical colors represented as RGB hexadecimal strings.schemeObservable10 ​Source · An array of ten categorical colors represented as RGB hexadecimal strings.schemePaired ​Source · An array of twelve categorical colors represented as RGB hexadecimal strings.schemePastel1 ​Source · An array of nine categorical colors represented as RGB hexadecimal strings.schemePastel2 ​Source · An array of eight categorical colors represented as RGB hexadecimal strings.schemeSet1 ​Source · An array of nine categorical colors represented as RGB hexadecimal strings.schemeSet2 ​Source · An array of eight categorical colors represented as RGB hexadecimal strings.schemeSet3 ​Source · An array of twelve categorical colors represented as RGB hexadecimal strings.schemeTableau10 ​Source · An array of ten categorical colors authored by Tableau as part of Tableau 10 represented as RGB hexadecimal strings.PagerPrevious paged3-scale-chromaticNext pageCyclical schemes\n\nCategorical schemes ​For example, to create a categorical color scale using the Accent color scheme:jsconst color = d3.scaleOrdinal(d3.schemeAccent);schemeCategory10 ​Source · An array of ten categorical colors represented as RGB hexadecimal strings.schemeAccent ​Source · An array of eight categorical colors represented as RGB hexadecimal strings.schemeDark2 ​Source · An array of eight categorical colors represented as RGB hexadecimal strings.schemeObservable10 ​Source · An array of ten categorical colors represented as RGB hexadecimal strings.schemePaired ​Source · An array of twelve categorical colors represented as RGB hexadecimal strings.schemePastel1 ​Source · An array of nine categorical colors represented as RGB hexadecimal strings.schemePastel2 ​Source · An array of eight categorical colors represented as RGB hexadecimal strings.schemeSet1 ​Source · An array of nine categorical colors represented as RGB hexadecimal strings.schemeSet2 ​Source · An array of eight categorical colors represented as RGB hexadecimal strings.schemeSet3 ​Source · An array of twelve categorical colors represented as RGB hexadecimal strings.schemeTableau10 ​Source · An array of ten categorical colors authored by Tableau as part of Tableau 10 represented as RGB hexadecimal strings.\n\n\n\nCyclical schemes ​To create a cyclical continuous color scale using the Rainbow color scheme:jsconst color = d3.scaleSequential(d3.interpolateRainbow);interpolateRainbow(t) ​Source · Given a number t in the range [0,1], returns the corresponding color from d3.interpolateWarm scale from [0.0, 0.5] followed by the d3.interpolateCool scale from [0.5, 1.0], thus implementing the cyclical less-angry rainbow color scheme.interpolateSinebow(t) ​Source · Given a number t in the range [0,1], returns the corresponding color from the “sinebow” color scheme by Jim Bumgardner and Charlie Loyd.\n\nSearchK7.9.0GitHub️ 110.0kOn this pageCyclical schemes ​To create a cyclical continuous color scale using the Rainbow color scheme:jsconst color = d3.scaleSequential(d3.interpolateRainbow);interpolateRainbow(t) ​Source · Given a number t in the range [0,1], returns the corresponding color from d3.interpolateWarm scale from [0.0, 0.5] followed by the d3.interpolateCool scale from [0.5, 1.0], thus implementing the cyclical less-angry rainbow color scheme.interpolateSinebow(t) ​Source · Given a number t in the range [0,1], returns the corresponding color from the “sinebow” color scheme by Jim Bumgardner and Charlie Loyd.PagerPrevious pageCategorical schemesNext pageDiverging schemes\n\nCyclical schemes ​To create a cyclical continuous color scale using the Rainbow color scheme:jsconst color = d3.scaleSequential(d3.interpolateRainbow);interpolateRainbow(t) ​Source · Given a number t in the range [0,1], returns the corresponding color from d3.interpolateWarm scale from [0.0, 0.5] followed by the d3.interpolateCool scale from [0.5, 1.0], thus implementing the cyclical less-angry rainbow color scheme.interpolateSinebow(t) ​Source · Given a number t in the range [0,1], returns the corresponding color from the “sinebow” color scheme by Jim Bumgardner and Charlie Loyd.\n\n\n\nDiverging schemes ​Diverging color schemes are available as continuous interpolators (often used with d3.scaleSequential) and as discrete schemes (often used with d3.scaleOrdinal).Each discrete scheme, such as d3.schemeBrBG, is represented as an array of arrays of hexadecimal color strings. The kth element of this array contains the color scheme of size k; for example, d3.schemeBrBG[9] contains an array of nine strings representing the nine colors of the brown-blue-green diverging color scheme. Diverging color schemes support a size k ranging from 3 to 11.To create a diverging continuous color scale using the PiYG color scheme:jsconst color = d3.scaleSequential(d3.interpolatePiYG);To create a diverging discrete nine-color scale using the PiYG color scheme:jsconst color = d3.scaleOrdinal(d3.schemePiYG[9]);interpolateBrBG(t) ​Source · Given a number t in the range [0,1], returns the corresponding color from the “BrBG” diverging color scheme represented as an RGB string.interpolatePRGn(t) ​Source · Given a number t in the range [0,1], returns the corresponding color from the “PRGn” diverging color scheme represented as an RGB string.interpolatePiYG(t) ​Source · Given a number t in the range [0,1], returns the corresponding color from the “PiYG” diverging color scheme represented as an RGB string.interpolatePuOr(t) ​Source · Given a number t in the range [0,1], returns the corresponding color from the “PuOr” diverging color scheme represented as an RGB string.interpolateRdBu(t) ​Source · Given a number t in the range [0,1], returns the corresponding color from the “RdBu” diverging color scheme represented as an RGB string.interpolateRdGy(t) ​Source · Given a number t in the range [0,1], returns the corresponding color from the “RdGy” diverging color scheme represented as an RGB string.interpolateRdYlBu(t) ​Source · Given a number t in the range [0,1], returns the corresponding color from the “RdYlBu” diverging color scheme represented as an RGB string.interpolateRdYlGn(t) ​Source · Given a number t in the range [0,1], returns the corresponding color from the “RdYlGn” diverging color scheme represented as an RGB string.interpolateSpectral(t) ​Source · Given a number t in the range [0,1], returns the corresponding color from the “Spectral” diverging color scheme represented as an RGB string.schemeBrBG[k] ​Source · The “BrBG” discrete diverging color scheme of size k in 3–11.schemePRGn[k] ​Source · The “PRGn” discrete diverging color scheme of size k in 3–11.schemePiYG[k] ​Source · The “PiYG” discrete diverging color scheme of size k in 3–11.schemePuOr[k] ​Source · The “PuOr” discrete diverging color scheme of size k in 3–11.schemeRdBu[k] ​Source · The “RdBu” discrete diverging color scheme of size k in 3–11.schemeRdGy[k] ​Source · The “RdGy” discrete diverging color scheme of size k in 3–11.schemeRdYlBu[k] ​Source · The “RdYlBu” discrete diverging color scheme of size k in 3–11.schemeRdYlGn[k] ​Source · The “RdYlGn” discrete diverging color scheme of size k in 3–11.schemeSpectral[k] ​Source · The “Spectral” discrete diverging color scheme of size k in 3–11.\n\nSearchK7.9.0GitHub️ 110.0kOn this pageDiverging schemes ​Diverging color schemes are available as continuous interpolators (often used with d3.scaleSequential) and as discrete schemes (often used with d3.scaleOrdinal).Each discrete scheme, such as d3.schemeBrBG, is represented as an array of arrays of hexadecimal color strings. The kth element of this array contains the color scheme of size k; for example, d3.schemeBrBG[9] contains an array of nine strings representing the nine colors of the brown-blue-green diverging color scheme. Diverging color schemes support a size k ranging from 3 to 11.To create a diverging continuous color scale using the PiYG color scheme:jsconst color = d3.scaleSequential(d3.interpolatePiYG);To create a diverging discrete nine-color scale using the PiYG color scheme:jsconst color = d3.scaleOrdinal(d3.schemePiYG[9]);interpolateBrBG(t) ​Source · Given a number t in the range [0,1], returns the corresponding color from the “BrBG” diverging color scheme represented as an RGB string.interpolatePRGn(t) ​Source · Given a number t in the range [0,1], returns the corresponding color from the “PRGn” diverging color scheme represented as an RGB string.interpolatePiYG(t) ​Source · Given a number t in the range [0,1], returns the corresponding color from the “PiYG” diverging color scheme represented as an RGB string.interpolatePuOr(t) ​Source · Given a number t in the range [0,1], returns the corresponding color from the “PuOr” diverging color scheme represented as an RGB string.interpolateRdBu(t) ​Source · Given a number t in the range [0,1], returns the corresponding color from the “RdBu” diverging color scheme represented as an RGB string.interpolateRdGy(t) ​Source · Given a number t in the range [0,1], returns the corresponding color from the “RdGy” diverging color scheme represented as an RGB string.interpolateRdYlBu(t) ​Source · Given a number t in the range [0,1], returns the corresponding color from the “RdYlBu” diverging color scheme represented as an RGB string.interpolateRdYlGn(t) ​Source · Given a number t in the range [0,1], returns the corresponding color from the “RdYlGn” diverging color scheme represented as an RGB string.interpolateSpectral(t) ​Source · Given a number t in the range [0,1], returns the corresponding color from the “Spectral” diverging color scheme represented as an RGB string.schemeBrBG[k] ​Source · The “BrBG” discrete diverging color scheme of size k in 3–11.schemePRGn[k] ​Source · The “PRGn” discrete diverging color scheme of size k in 3–11.schemePiYG[k] ​Source · The “PiYG” discrete diverging color scheme of size k in 3–11.schemePuOr[k] ​Source · The “PuOr” discrete diverging color scheme of size k in 3–11.schemeRdBu[k] ​Source · The “RdBu” discrete diverging color scheme of size k in 3–11.schemeRdGy[k] ​Source · The “RdGy” discrete diverging color scheme of size k in 3–11.schemeRdYlBu[k] ​Source · The “RdYlBu” discrete diverging color scheme of size k in 3–11.schemeRdYlGn[k] ​Source · The “RdYlGn” discrete diverging color scheme of size k in 3–11.schemeSpectral[k] ​Source · The “Spectral” discrete diverging color scheme of size k in 3–11.PagerPrevious pageCyclical schemesNext pageSequential schemes\n\nDiverging schemes ​Diverging color schemes are available as continuous interpolators (often used with d3.scaleSequential) and as discrete schemes (often used with d3.scaleOrdinal).Each discrete scheme, such as d3.schemeBrBG, is represented as an array of arrays of hexadecimal color strings. The kth element of this array contains the color scheme of size k; for example, d3.schemeBrBG[9] contains an array of nine strings representing the nine colors of the brown-blue-green diverging color scheme. Diverging color schemes support a size k ranging from 3 to 11.To create a diverging continuous color scale using the PiYG color scheme:jsconst color = d3.scaleSequential(d3.interpolatePiYG);To create a diverging discrete nine-color scale using the PiYG color scheme:jsconst color = d3.scaleOrdinal(d3.schemePiYG[9]);interpolateBrBG(t) ​Source · Given a number t in the range [0,1], returns the corresponding color from the “BrBG” diverging color scheme represented as an RGB string.interpolatePRGn(t) ​Source · Given a number t in the range [0,1], returns the corresponding color from the “PRGn” diverging color scheme represented as an RGB string.interpolatePiYG(t) ​Source · Given a number t in the range [0,1], returns the corresponding color from the “PiYG” diverging color scheme represented as an RGB string.interpolatePuOr(t) ​Source · Given a number t in the range [0,1], returns the corresponding color from the “PuOr” diverging color scheme represented as an RGB string.interpolateRdBu(t) ​Source · Given a number t in the range [0,1], returns the corresponding color from the “RdBu” diverging color scheme represented as an RGB string.interpolateRdGy(t) ​Source · Given a number t in the range [0,1], returns the corresponding color from the “RdGy” diverging color scheme represented as an RGB string.interpolateRdYlBu(t) ​Source · Given a number t in the range [0,1], returns the corresponding color from the “RdYlBu” diverging color scheme represented as an RGB string.interpolateRdYlGn(t) ​Source · Given a number t in the range [0,1], returns the corresponding color from the “RdYlGn” diverging color scheme represented as an RGB string.interpolateSpectral(t) ​Source · Given a number t in the range [0,1], returns the corresponding color from the “Spectral” diverging color scheme represented as an RGB string.schemeBrBG[k] ​Source · The “BrBG” discrete diverging color scheme of size k in 3–11.schemePRGn[k] ​Source · The “PRGn” discrete diverging color scheme of size k in 3–11.schemePiYG[k] ​Source · The “PiYG” discrete diverging color scheme of size k in 3–11.schemePuOr[k] ​Source · The “PuOr” discrete diverging color scheme of size k in 3–11.schemeRdBu[k] ​Source · The “RdBu” discrete diverging color scheme of size k in 3–11.schemeRdGy[k] ​Source · The “RdGy” discrete diverging color scheme of size k in 3–11.schemeRdYlBu[k] ​Source · The “RdYlBu” discrete diverging color scheme of size k in 3–11.schemeRdYlGn[k] ​Source · The “RdYlGn” discrete diverging color scheme of size k in 3–11.schemeSpectral[k] ​Source · The “Spectral” discrete diverging color scheme of size k in 3–11.\n\n\n\nSequential schemes ​Sequential color schemes are available as continuous interpolators (often used with d3.scaleSequential) and as discrete schemes (often used with d3.scaleOrdinal).Each discrete scheme, such as d3.schemeBlues, is represented as an array of arrays of hexadecimal color strings. The kth element of this array contains the color scheme of size k; for example, d3.schemeBlues[9] contains an array of nine strings representing the nine colors of the blue sequential color scheme. Sequential color schemes support a size k ranging from 3 to 9.To create a sequential discrete nine-color scale using the Blues color scheme:jsconst color = d3.scaleOrdinal(d3.schemeBlues[9]);To create a sequential continuous color scale using the Blues color scheme:jsconst color = d3.scaleSequential(d3.interpolateBlues);interpolateBlues(t) ​Source · Given a number t in the range [0,1], returns the corresponding color from the “Blues” sequential color scheme represented as an RGB string.interpolateGreens(t) ​Source · Given a number t in the range [0,1], returns the corresponding color from the “Greens” sequential color scheme represented as an RGB string.interpolateGreys(t) ​Source · Given a number t in the range [0,1], returns the corresponding color from the “Greys” sequential color scheme represented as an RGB string.interpolateOranges(t) ​Source · Given a number t in the range [0,1], returns the corresponding color from the “Oranges” sequential color scheme represented as an RGB string.interpolatePurples(t) ​Source · Given a number t in the range [0,1], returns the corresponding color from the “Purples” sequential color scheme represented as an RGB string.interpolateReds(t) ​Source · Given a number t in the range [0,1], returns the corresponding color from the “Reds” sequential color scheme represented as an RGB string.interpolateTurbo(t) ​Source · Given a number t in the range [0,1], returns the corresponding color from the “turbo” color scheme by Anton Mikhailov.interpolateViridis(t) ​Source · Given a number t in the range [0,1], returns the corresponding color from the “viridis” perceptually-uniform color scheme designed by van der Walt, Smith and Firing for matplotlib, represented as an RGB string.interpolateInferno(t) ​Source · Given a number t in the range [0,1], returns the corresponding color from the “inferno” perceptually-uniform color scheme designed by van der Walt and Smith for matplotlib, represented as an RGB string.interpolateMagma(t) ​Source · Given a number t in the range [0,1], returns the corresponding color from the “magma” perceptually-uniform color scheme designed by van der Walt and Smith for matplotlib, represented as an RGB string.interpolatePlasma(t) ​Source · Given a number t in the range [0,1], returns the corresponding color from the “plasma” perceptually-uniform color scheme designed by van der Walt and Smith for matplotlib, represented as an RGB string.interpolateCividis(t) ​Source · Given a number t in the range [0,1], returns the corresponding color from the “cividis” color vision deficiency-optimized color scheme designed by Nuñez, Anderton, and Renslow, represented as an RGB string.interpolateWarm(t) ​Source · Given a number t in the range [0,1], returns the corresponding color from a 180° rotation of Niccoli’s perceptual rainbow, represented as an RGB string.interpolateCool(t) ​Source · Given a number t in the range [0,1], returns the corresponding color from Niccoli’s perceptual rainbow, represented as an RGB string.interpolateCubehelixDefault(t) ​Source · Given a number t in the range [0,1], returns the corresponding color from Green’s default Cubehelix represented as an RGB string.interpolateBuGn(t) ​Source · Given a number t in the range [0,1], returns the corresponding color from the “BuGn” sequential color scheme represented as an RGB string.interpolateBuPu(t) ​Source · Given a number t in the range [0,1], returns the corresponding color from the “BuPu” sequential color scheme represented as an RGB string.interpolateGnBu(t) ​Source · Given a number t in the range [0,1], returns the corresponding color from the “GnBu” sequential color scheme represented as an RGB string.interpolateOrRd(t) ​Source · Given a number t in the range [0,1], returns the corresponding color from the “OrRd” sequential color scheme represented as an RGB string.interpolatePuBuGn(t) ​Source · Given a number t in the range [0,1], returns the corresponding color from the “PuBuGn” sequential color scheme represented as an RGB string.interpolatePuBu(t) ​Source · Given a number t in the range [0,1], returns the corresponding color from the “PuBu” sequential color scheme represented as an RGB string.interpolatePuRd(t) ​Source · Given a number t in the range [0,1], returns the corresponding color from the “PuRd” sequential color scheme represented as an RGB string.interpolateRdPu(t) ​Source · Given a number t in the range [0,1], returns the corresponding color from the “RdPu” sequential color scheme represented as an RGB string.interpolateYlGnBu(t) ​Source · Given a number t in the range [0,1], returns the corresponding color from the “YlGnBu” sequential color scheme represented as an RGB string.interpolateYlGn(t) ​Source · Given a number t in the range [0,1], returns the corresponding color from the “YlGn” sequential color scheme represented as an RGB string.interpolateYlOrBr(t) ​Source · Given a number t in the range [0,1], returns the corresponding color from the “YlOrBr” sequential color scheme represented as an RGB string.interpolateYlOrRd(t) ​Source · Given a number t in the range [0,1], returns the corresponding color from the “YlOrRd” sequential color scheme represented as an RGB string.schemeBlues[k] ​Source · The “Blues” discrete sequential color scheme of size k in 3–9.schemeGreens[k] ​Source · The “Greens” discrete sequential color scheme of size k in 3–9.schemeGreys[k] ​Source · The “Greys” discrete sequential color scheme of size k in 3–9.schemeOranges[k] ​Source · The “Oranges” discrete sequential color scheme of size k in 3–9.schemePurples[k] ​Source · The “Purples” discrete sequential color scheme of size k in 3–9.schemeReds[k] ​Source · The “Reds” discrete sequential color scheme of size k in 3–9.schemeBuGn[k] ​Source · The “BuGn” discrete sequential color scheme of size k in 3–9.schemeBuPu[k] ​Source · The “BuPu” discrete sequential color scheme of size k in 3–9.schemeGnBu[k] ​Source · The “GnBu” discrete sequential color scheme of size k in 3–9.schemeOrRd[k] ​Source · The “OrRd” discrete sequential color scheme of size k in 3–9.schemePuBuGn[k] ​Source · The “PuBuGn” discrete sequential color scheme of size k in 3–9.schemePuBu[k] ​Source · The “PuBu” discrete sequential color scheme of size k in 3–9.schemePuRd[k] ​Source · The “PuRd” discrete sequential color scheme of size k in 3–9.schemeRdPu[k] ​Source · The “RdPu” discrete sequential color scheme of size k in 3–9.schemeYlGnBu[k] ​Source · The “YlGnBu” discrete sequential color scheme of size k in 3–9.schemeYlGn[k] ​Source · The “YlGn” discrete sequential color scheme of size k in 3–9.schemeYlOrBr[k] ​Source · The “YlOrBr” discrete sequential color scheme of size k in 3–9.schemeYlOrRd[k] ​Source · The “YlOrRd” discrete sequential color scheme of size k in 3–9.\n\nSearchK7.9.0GitHub️ 110.0kOn this pageSequential schemes ​Sequential color schemes are available as continuous interpolators (often used with d3.scaleSequential) and as discrete schemes (often used with d3.scaleOrdinal).Each discrete scheme, such as d3.schemeBlues, is represented as an array of arrays of hexadecimal color strings. The kth element of this array contains the color scheme of size k; for example, d3.schemeBlues[9] contains an array of nine strings representing the nine colors of the blue sequential color scheme. Sequential color schemes support a size k ranging from 3 to 9.To create a sequential discrete nine-color scale using the Blues color scheme:jsconst color = d3.scaleOrdinal(d3.schemeBlues[9]);To create a sequential continuous color scale using the Blues color scheme:jsconst color = d3.scaleSequential(d3.interpolateBlues);interpolateBlues(t) ​Source · Given a number t in the range [0,1], returns the corresponding color from the “Blues” sequential color scheme represented as an RGB string.interpolateGreens(t) ​Source · Given a number t in the range [0,1], returns the corresponding color from the “Greens” sequential color scheme represented as an RGB string.interpolateGreys(t) ​Source · Given a number t in the range [0,1], returns the corresponding color from the “Greys” sequential color scheme represented as an RGB string.interpolateOranges(t) ​Source · Given a number t in the range [0,1], returns the corresponding color from the “Oranges” sequential color scheme represented as an RGB string.interpolatePurples(t) ​Source · Given a number t in the range [0,1], returns the corresponding color from the “Purples” sequential color scheme represented as an RGB string.interpolateReds(t) ​Source · Given a number t in the range [0,1], returns the corresponding color from the “Reds” sequential color scheme represented as an RGB string.interpolateTurbo(t) ​Source · Given a number t in the range [0,1], returns the corresponding color from the “turbo” color scheme by Anton Mikhailov.interpolateViridis(t) ​Source · Given a number t in the range [0,1], returns the corresponding color from the “viridis” perceptually-uniform color scheme designed by van der Walt, Smith and Firing for matplotlib, represented as an RGB string.interpolateInferno(t) ​Source · Given a number t in the range [0,1], returns the corresponding color from the “inferno” perceptually-uniform color scheme designed by van der Walt and Smith for matplotlib, represented as an RGB string.interpolateMagma(t) ​Source · Given a number t in the range [0,1], returns the corresponding color from the “magma” perceptually-uniform color scheme designed by van der Walt and Smith for matplotlib, represented as an RGB string.interpolatePlasma(t) ​Source · Given a number t in the range [0,1], returns the corresponding color from the “plasma” perceptually-uniform color scheme designed by van der Walt and Smith for matplotlib, represented as an RGB string.interpolateCividis(t) ​Source · Given a number t in the range [0,1], returns the corresponding color from the “cividis” color vision deficiency-optimized color scheme designed by Nuñez, Anderton, and Renslow, represented as an RGB string.interpolateWarm(t) ​Source · Given a number t in the range [0,1], returns the corresponding color from a 180° rotation of Niccoli’s perceptual rainbow, represented as an RGB string.interpolateCool(t) ​Source · Given a number t in the range [0,1], returns the corresponding color from Niccoli’s perceptual rainbow, represented as an RGB string.interpolateCubehelixDefault(t) ​Source · Given a number t in the range [0,1], returns the corresponding color from Green’s default Cubehelix represented as an RGB string.interpolateBuGn(t) ​Source · Given a number t in the range [0,1], returns the corresponding color from the “BuGn” sequential color scheme represented as an RGB string.interpolateBuPu(t) ​Source · Given a number t in the range [0,1], returns the corresponding color from the “BuPu” sequential color scheme represented as an RGB string.interpolateGnBu(t) ​Source · Given a number t in the range [0,1], returns the corresponding color from the “GnBu” sequential color scheme represented as an RGB string.interpolateOrRd(t) ​Source · Given a number t in the range [0,1], returns the corresponding color from the “OrRd” sequential color scheme represented as an RGB string.interpolatePuBuGn(t) ​Source · Given a number t in the range [0,1], returns the corresponding color from the “PuBuGn” sequential color scheme represented as an RGB string.interpolatePuBu(t) ​Source · Given a number t in the range [0,1], returns the corresponding color from the “PuBu” sequential color scheme represented as an RGB string.interpolatePuRd(t) ​Source · Given a number t in the range [0,1], returns the corresponding color from the “PuRd” sequential color scheme represented as an RGB string.interpolateRdPu(t) ​Source · Given a number t in the range [0,1], returns the corresponding color from the “RdPu” sequential color scheme represented as an RGB string.interpolateYlGnBu(t) ​Source · Given a number t in the range [0,1], returns the corresponding color from the “YlGnBu” sequential color scheme represented as an RGB string.interpolateYlGn(t) ​Source · Given a number t in the range [0,1], returns the corresponding color from the “YlGn” sequential color scheme represented as an RGB string.interpolateYlOrBr(t) ​Source · Given a number t in the range [0,1], returns the corresponding color from the “YlOrBr” sequential color scheme represented as an RGB string.interpolateYlOrRd(t) ​Source · Given a number t in the range [0,1], returns the corresponding color from the “YlOrRd” sequential color scheme represented as an RGB string.schemeBlues[k] ​Source · The “Blues” discrete sequential color scheme of size k in 3–9.schemeGreens[k] ​Source · The “Greens” discrete sequential color scheme of size k in 3–9.schemeGreys[k] ​Source · The “Greys” discrete sequential color scheme of size k in 3–9.schemeOranges[k] ​Source · The “Oranges” discrete sequential color scheme of size k in 3–9.schemePurples[k] ​Source · The “Purples” discrete sequential color scheme of size k in 3–9.schemeReds[k] ​Source · The “Reds” discrete sequential color scheme of size k in 3–9.schemeBuGn[k] ​Source · The “BuGn” discrete sequential color scheme of size k in 3–9.schemeBuPu[k] ​Source · The “BuPu” discrete sequential color scheme of size k in 3–9.schemeGnBu[k] ​Source · The “GnBu” discrete sequential color scheme of size k in 3–9.schemeOrRd[k] ​Source · The “OrRd” discrete sequential color scheme of size k in 3–9.schemePuBuGn[k] ​Source · The “PuBuGn” discrete sequential color scheme of size k in 3–9.schemePuBu[k] ​Source · The “PuBu” discrete sequential color scheme of size k in 3–9.schemePuRd[k] ​Source · The “PuRd” discrete sequential color scheme of size k in 3–9.schemeRdPu[k] ​Source · The “RdPu” discrete sequential color scheme of size k in 3–9.schemeYlGnBu[k] ​Source · The “YlGnBu” discrete sequential color scheme of size k in 3–9.schemeYlGn[k] ​Source · The “YlGn” discrete sequential color scheme of size k in 3–9.schemeYlOrBr[k] ​Source · The “YlOrBr” discrete sequential color scheme of size k in 3–9.schemeYlOrRd[k] ​Source · The “YlOrRd” discrete sequential color scheme of size k in 3–9.PagerPrevious pageDiverging schemesNext paged3-selection\n\nSequential schemes ​Sequential color schemes are available as continuous interpolators (often used with d3.scaleSequential) and as discrete schemes (often used with d3.scaleOrdinal).Each discrete scheme, such as d3.schemeBlues, is represented as an array of arrays of hexadecimal color strings. The kth element of this array contains the color scheme of size k; for example, d3.schemeBlues[9] contains an array of nine strings representing the nine colors of the blue sequential color scheme. Sequential color schemes support a size k ranging from 3 to 9.To create a sequential discrete nine-color scale using the Blues color scheme:jsconst color = d3.scaleOrdinal(d3.schemeBlues[9]);To create a sequential continuous color scale using the Blues color scheme:jsconst color = d3.scaleSequential(d3.interpolateBlues);interpolateBlues(t) ​Source · Given a number t in the range [0,1], returns the corresponding color from the “Blues” sequential color scheme represented as an RGB string.interpolateGreens(t) ​Source · Given a number t in the range [0,1], returns the corresponding color from the “Greens” sequential color scheme represented as an RGB string.interpolateGreys(t) ​Source · Given a number t in the range [0,1], returns the corresponding color from the “Greys” sequential color scheme represented as an RGB string.interpolateOranges(t) ​Source · Given a number t in the range [0,1], returns the corresponding color from the “Oranges” sequential color scheme represented as an RGB string.interpolatePurples(t) ​Source · Given a number t in the range [0,1], returns the corresponding color from the “Purples” sequential color scheme represented as an RGB string.interpolateReds(t) ​Source · Given a number t in the range [0,1], returns the corresponding color from the “Reds” sequential color scheme represented as an RGB string.interpolateTurbo(t) ​Source · Given a number t in the range [0,1], returns the corresponding color from the “turbo” color scheme by Anton Mikhailov.interpolateViridis(t) ​Source · Given a number t in the range [0,1], returns the corresponding color from the “viridis” perceptually-uniform color scheme designed by van der Walt, Smith and Firing for matplotlib, represented as an RGB string.interpolateInferno(t) ​Source · Given a number t in the range [0,1], returns the corresponding color from the “inferno” perceptually-uniform color scheme designed by van der Walt and Smith for matplotlib, represented as an RGB string.interpolateMagma(t) ​Source · Given a number t in the range [0,1], returns the corresponding color from the “magma” perceptually-uniform color scheme designed by van der Walt and Smith for matplotlib, represented as an RGB string.interpolatePlasma(t) ​Source · Given a number t in the range [0,1], returns the corresponding color from the “plasma” perceptually-uniform color scheme designed by van der Walt and Smith for matplotlib, represented as an RGB string.interpolateCividis(t) ​Source · Given a number t in the range [0,1], returns the corresponding color from the “cividis” color vision deficiency-optimized color scheme designed by Nuñez, Anderton, and Renslow, represented as an RGB string.interpolateWarm(t) ​Source · Given a number t in the range [0,1], returns the corresponding color from a 180° rotation of Niccoli’s perceptual rainbow, represented as an RGB string.interpolateCool(t) ​Source · Given a number t in the range [0,1], returns the corresponding color from Niccoli’s perceptual rainbow, represented as an RGB string.interpolateCubehelixDefault(t) ​Source · Given a number t in the range [0,1], returns the corresponding color from Green’s default Cubehelix represented as an RGB string.interpolateBuGn(t) ​Source · Given a number t in the range [0,1], returns the corresponding color from the “BuGn” sequential color scheme represented as an RGB string.interpolateBuPu(t) ​Source · Given a number t in the range [0,1], returns the corresponding color from the “BuPu” sequential color scheme represented as an RGB string.interpolateGnBu(t) ​Source · Given a number t in the range [0,1], returns the corresponding color from the “GnBu” sequential color scheme represented as an RGB string.interpolateOrRd(t) ​Source · Given a number t in the range [0,1], returns the corresponding color from the “OrRd” sequential color scheme represented as an RGB string.interpolatePuBuGn(t) ​Source · Given a number t in the range [0,1], returns the corresponding color from the “PuBuGn” sequential color scheme represented as an RGB string.interpolatePuBu(t) ​Source · Given a number t in the range [0,1], returns the corresponding color from the “PuBu” sequential color scheme represented as an RGB string.interpolatePuRd(t) ​Source · Given a number t in the range [0,1], returns the corresponding color from the “PuRd” sequential color scheme represented as an RGB string.interpolateRdPu(t) ​Source · Given a number t in the range [0,1], returns the corresponding color from the “RdPu” sequential color scheme represented as an RGB string.interpolateYlGnBu(t) ​Source · Given a number t in the range [0,1], returns the corresponding color from the “YlGnBu” sequential color scheme represented as an RGB string.interpolateYlGn(t) ​Source · Given a number t in the range [0,1], returns the corresponding color from the “YlGn” sequential color scheme represented as an RGB string.interpolateYlOrBr(t) ​Source · Given a number t in the range [0,1], returns the corresponding color from the “YlOrBr” sequential color scheme represented as an RGB string.interpolateYlOrRd(t) ​Source · Given a number t in the range [0,1], returns the corresponding color from the “YlOrRd” sequential color scheme represented as an RGB string.schemeBlues[k] ​Source · The “Blues” discrete sequential color scheme of size k in 3–9.schemeGreens[k] ​Source · The “Greens” discrete sequential color scheme of size k in 3–9.schemeGreys[k] ​Source · The “Greys” discrete sequential color scheme of size k in 3–9.schemeOranges[k] ​Source · The “Oranges” discrete sequential color scheme of size k in 3–9.schemePurples[k] ​Source · The “Purples” discrete sequential color scheme of size k in 3–9.schemeReds[k] ​Source · The “Reds” discrete sequential color scheme of size k in 3–9.schemeBuGn[k] ​Source · The “BuGn” discrete sequential color scheme of size k in 3–9.schemeBuPu[k] ​Source · The “BuPu” discrete sequential color scheme of size k in 3–9.schemeGnBu[k] ​Source · The “GnBu” discrete sequential color scheme of size k in 3–9.schemeOrRd[k] ​Source · The “OrRd” discrete sequential color scheme of size k in 3–9.schemePuBuGn[k] ​Source · The “PuBuGn” discrete sequential color scheme of size k in 3–9.schemePuBu[k] ​Source · The “PuBu” discrete sequential color scheme of size k in 3–9.schemePuRd[k] ​Source · The “PuRd” discrete sequential color scheme of size k in 3–9.schemeRdPu[k] ​Source · The “RdPu” discrete sequential color scheme of size k in 3–9.schemeYlGnBu[k] ​Source · The “YlGnBu” discrete sequential color scheme of size k in 3–9.schemeYlGn[k] ​Source · The “YlGn” discrete sequential color scheme of size k in 3–9.schemeYlOrBr[k] ​Source · The “YlOrBr” discrete sequential color scheme of size k in 3–9.schemeYlOrRd[k] ​Source · The “YlOrRd” discrete sequential color scheme of size k in 3–9.\n\n\n\nSelecting elements ​A selection is a set of elements from the DOM. Typically these elements are identified by selectors such as .fancy for elements with the class fancy, or div to select DIV elements.Selection methods come in two forms, select and selectAll: the former selects only the first matching element, while the latter selects all matching elements in document order. The top-level selection methods, d3.select and d3.selectAll, query the entire document; the subselection methods, selection.select and selection.selectAll, restrict selection to descendants of the selected elements. There is also selection.selectChild and selection.selectChildren for direct children.By convention, selection methods that return the current selection such as selection.attr use four spaces of indent, while methods that return a new selection use only two. This helps reveal changes of context by making them stick out of the chain:jsd3.select("body")
  .append("svg")
    .attr("width", 960)
    .attr("height", 500)
  .append("g")
    .attr("transform", "translate(20,20)")
  .append("rect")
    .attr("width", 920)
    .attr("height", 460);selection() ​Source · Selects the root element, document.documentElement.jsconst root = d3.selection();This function can also be used to test for selections (instanceof d3.selection) or to extend the selection prototype. For example, to add a method to check checkboxes:jsd3.selection.prototype.checked = function(value) {
  return arguments.length < 1
      ? this.property("checked")
      : this.property("checked", !!value);
};And then to use:jsd3.selectAll("input[type=checkbox]").checked(true);select(selector) ​Source · Selects the first element that matches the specified selector string.jsconst svg = d3.select("#chart");If no elements match the selector, returns an empty selection. If multiple elements match the selector, only the first matching element (in document order) will be selected. For example, to select the first anchor element:jsconst anchor = d3.select("a");If the selector is not a string, instead selects the specified node; this is useful if you already have a reference to a node, such as document.body.jsd3.select(document.body).style("background", "red");Or, to make a clicked paragraph red:jsd3.selectAll("p").on("click", (event) => d3.select(event.currentTarget).style("color", "red"));selectAll(selector) ​Source · Selects all elements that match the specified selector string.jsconst p = d3.selectAll("p");The elements will be selected in document order (top-to-bottom). If no elements in the document match the selector, or if the selector is null or undefined, returns an empty selection.If the selector is not a string, instead selects the specified array of nodes; this is useful if you already have a reference to nodes, such as this.childNodes within an event listener or a global such as document.links. The nodes may instead be an iterable, or a pseudo-array such as a NodeList. For example, to color all links red:jsd3.selectAll(document.links).style("color", "red");selection.select(selector) ​Source · For each selected element, selects the first descendant element that matches the specified selector string.jsconst b = d3.selectAll("p").select("b"); // the first <b> in every <p>If no element matches the specified selector for the current element, the element at the current index will be null in the returned selection. (If the selector is null, every element in the returned selection will be null, resulting in an empty selection.) If the current element has associated data, this data is propagated to the corresponding selected element. If multiple elements match the selector, only the first matching element in document order is selected.If the selector is a function, it is evaluated for each selected element, in order, being passed the current datum (d), the current index (i), and the current group (nodes), with this as the current DOM element (nodes[i]). It must return an element, or null if there is no matching element. For example, to select the previous sibling of each paragraph:jsconst previous = d3.selectAll("p").select(function() {
  return this.previousElementSibling;
});Unlike selection.selectAll, selection.select does not affect grouping: it preserves the existing group structure and indexes, and propagates data (if any) to selected children. Grouping plays an important role in the data join. See Nested Selections and How Selections Work for more on this topic.CAUTIONselection.select propagates the parent’s data to the selected child.selection.selectAll(selector) ​Source · For each selected element, selects the descendant elements that match the specified selector string.jsconst b = d3.selectAll("p").selectAll("b"); // every <b> in every <p>The elements in the returned selection are grouped by their corresponding parent node in this selection. If no element matches the specified selector for the current element, or if the selector is null, the group at the current index will be empty. The selected elements do not inherit data from this selection; use selection.data to propagate data to children.If the selector is a function, it is evaluated for each selected element, in order, being passed the current datum (d), the current index (i), and the current group (nodes), with this as the current DOM element (nodes[i]). It must return an array of elements (or an iterable, or a pseudo-array such as a NodeList), or the empty array if there are no matching elements. For example, to select the previous and next siblings of each paragraph:jsconst sibling = d3.selectAll("p").selectAll(function() {
  return [
    this.previousElementSibling,
    this.nextElementSibling
  ];
});Unlike selection.select, selection.selectAll does affect grouping: each selected descendant is grouped by the parent element in the originating selection. Grouping plays an important role in the data join. See Nested Selections and How Selections Work for more on this topic.selection.filter(filter) ​Source · Filters the selection, returning a new selection that contains only the elements for which the specified filter is true. For example, to filter a selection of table rows to contain only even rows:jsconst even = d3.selectAll("tr").filter(":nth-child(even)");This is approximately equivalent to using d3.selectAll directly, although the indexes may be different:jsconst even = d3.selectAll("tr:nth-child(even)");The filter may be specified either as a selector string or a function. If the filter is a function, it is evaluated for each selected element, in order, being passed the current datum (d), the current index (i), and the current group (nodes), with this as the current DOM element (nodes[i]). Using a function:jsconst even = d3.selectAll("tr").filter((d, i) => i & 1);Or using selection.select (and avoiding an arrow function, since this is needed to refer to the current element):jsconst even = d3.selectAll("tr").select(function(d, i) { return i & 1 ? this : null; });Note that the :nth-child pseudo-class is a one-based index rather than a zero-based index. Also, the above filter functions do not have precisely the same meaning as :nth-child; they rely on the selection index rather than the number of preceding sibling elements in the DOM.The returned filtered selection preserves the parents of this selection, but like array.filter, it does not preserve indexes as some elements may be removed; use selection.select to preserve the index, if needed.selection.selectChild(selector) ​Source · Returns a new selection with the (first) child of each element of the current selection matching the selector.jsd3.selectAll("p").selectChild("b") // the first <b> child of every <p>If no selector is specified, selects the first child (if any). If the selector is specified as a string, selects the first child that matches (if any). If the selector is a function, it is evaluated for each of the children nodes, in order, being passed the child (child), the child’s index (i), and the list of children (children); the method selects the first child for which the selector return truthy, if any.CAUTIONselection.selectChild propagates the parent’s data to the selected child.selection.selectChildren(selector) ​Source · Returns a new selection with the children of each element of the current selection matching the selector. If no selector is specified, selects all the children. If the selector is specified as a string, selects the children that match (if any). If the selector is a function, it is evaluated for each of the children nodes, in order, being passed the child (child), the child’s index (i), and the list of children (children); the method selects all children for which the selector return truthy.selection.selection() ​Source · Returns the selection (for symmetry with transition.selection).matcher(selector) ​Source · Given the specified selector, returns a function which returns true if this element matches the specified selector. This method is used internally by selection.filter. For example, this:jsconst div = selection.filter("div");Is equivalent to:jsconst div = selection.filter(d3.matcher("div"));(Although D3 is not a compatibility layer, this implementation does support vendor-prefixed implementations due to the recent standardization of element.matches.)selector(selector) ​Source · Given the specified selector, returns a function which returns the first descendant of this element that matches the specified selector. This method is used internally by selection.select. For example, this:jsconst div = selection.select("div");Is equivalent to:jsconst div = selection.select(d3.selector("div"));selectorAll(selector) ​Source · Given the specified selector, returns a function which returns all descendants of this element that match the specified selector. This method is used internally by selection.selectAll. For example, this:jsconst div = selection.selectAll("div");Is equivalent to:jsconst div = selection.selectAll(d3.selectorAll("div"));window(node) ​Source · Returns the owner window for the specified node. If node is a node, returns the owner document’s default view; if node is a document, returns its default view; otherwise returns the node.style(node, name) ​Source · Returns the value of the style property with the specified name for the specified node. If the node has an inline style with the specified name, its value is returned; otherwise, the computed property value is returned. See also selection.style.\n\nSearchK7.9.0GitHub️ 110.0kOn this pageSelecting elements ​A selection is a set of elements from the DOM. Typically these elements are identified by selectors such as .fancy for elements with the class fancy, or div to select DIV elements.Selection methods come in two forms, select and selectAll: the former selects only the first matching element, while the latter selects all matching elements in document order. The top-level selection methods, d3.select and d3.selectAll, query the entire document; the subselection methods, selection.select and selection.selectAll, restrict selection to descendants of the selected elements. There is also selection.selectChild and selection.selectChildren for direct children.By convention, selection methods that return the current selection such as selection.attr use four spaces of indent, while methods that return a new selection use only two. This helps reveal changes of context by making them stick out of the chain:jsd3.select("body")
  .append("svg")
    .attr("width", 960)
    .attr("height", 500)
  .append("g")
    .attr("transform", "translate(20,20)")
  .append("rect")
    .attr("width", 920)
    .attr("height", 460);selection() ​Source · Selects the root element, document.documentElement.jsconst root = d3.selection();This function can also be used to test for selections (instanceof d3.selection) or to extend the selection prototype. For example, to add a method to check checkboxes:jsd3.selection.prototype.checked = function(value) {
  return arguments.length < 1
      ? this.property("checked")
      : this.property("checked", !!value);
};And then to use:jsd3.selectAll("input[type=checkbox]").checked(true);select(selector) ​Source · Selects the first element that matches the specified selector string.jsconst svg = d3.select("#chart");If no elements match the selector, returns an empty selection. If multiple elements match the selector, only the first matching element (in document order) will be selected. For example, to select the first anchor element:jsconst anchor = d3.select("a");If the selector is not a string, instead selects the specified node; this is useful if you already have a reference to a node, such as document.body.jsd3.select(document.body).style("background", "red");Or, to make a clicked paragraph red:jsd3.selectAll("p").on("click", (event) => d3.select(event.currentTarget).style("color", "red"));selectAll(selector) ​Source · Selects all elements that match the specified selector string.jsconst p = d3.selectAll("p");The elements will be selected in document order (top-to-bottom). If no elements in the document match the selector, or if the selector is null or undefined, returns an empty selection.If the selector is not a string, instead selects the specified array of nodes; this is useful if you already have a reference to nodes, such as this.childNodes within an event listener or a global such as document.links. The nodes may instead be an iterable, or a pseudo-array such as a NodeList. For example, to color all links red:jsd3.selectAll(document.links).style("color", "red");selection.select(selector) ​Source · For each selected element, selects the first descendant element that matches the specified selector string.jsconst b = d3.selectAll("p").select("b"); // the first <b> in every <p>If no element matches the specified selector for the current element, the element at the current index will be null in the returned selection. (If the selector is null, every element in the returned selection will be null, resulting in an empty selection.) If the current element has associated data, this data is propagated to the corresponding selected element. If multiple elements match the selector, only the first matching element in document order is selected.If the selector is a function, it is evaluated for each selected element, in order, being passed the current datum (d), the current index (i), and the current group (nodes), with this as the current DOM element (nodes[i]). It must return an element, or null if there is no matching element. For example, to select the previous sibling of each paragraph:jsconst previous = d3.selectAll("p").select(function() {
  return this.previousElementSibling;
});Unlike selection.selectAll, selection.select does not affect grouping: it preserves the existing group structure and indexes, and propagates data (if any) to selected children. Grouping plays an important role in the data join. See Nested Selections and How Selections Work for more on this topic.CAUTIONselection.select propagates the parent’s data to the selected child.selection.selectAll(selector) ​Source · For each selected element, selects the descendant elements that match the specified selector string.jsconst b = d3.selectAll("p").selectAll("b"); // every <b> in every <p>The elements in the returned selection are grouped by their corresponding parent node in this selection. If no element matches the specified selector for the current element, or if the selector is null, the group at the current index will be empty. The selected elements do not inherit data from this selection; use selection.data to propagate data to children.If the selector is a function, it is evaluated for each selected element, in order, being passed the current datum (d), the current index (i), and the current group (nodes), with this as the current DOM element (nodes[i]). It must return an array of elements (or an iterable, or a pseudo-array such as a NodeList), or the empty array if there are no matching elements. For example, to select the previous and next siblings of each paragraph:jsconst sibling = d3.selectAll("p").selectAll(function() {
  return [
    this.previousElementSibling,
    this.nextElementSibling
  ];
});Unlike selection.select, selection.selectAll does affect grouping: each selected descendant is grouped by the parent element in the originating selection. Grouping plays an important role in the data join. See Nested Selections and How Selections Work for more on this topic.selection.filter(filter) ​Source · Filters the selection, returning a new selection that contains only the elements for which the specified filter is true. For example, to filter a selection of table rows to contain only even rows:jsconst even = d3.selectAll("tr").filter(":nth-child(even)");This is approximately equivalent to using d3.selectAll directly, although the indexes may be different:jsconst even = d3.selectAll("tr:nth-child(even)");The filter may be specified either as a selector string or a function. If the filter is a function, it is evaluated for each selected element, in order, being passed the current datum (d), the current index (i), and the current group (nodes), with this as the current DOM element (nodes[i]). Using a function:jsconst even = d3.selectAll("tr").filter((d, i) => i & 1);Or using selection.select (and avoiding an arrow function, since this is needed to refer to the current element):jsconst even = d3.selectAll("tr").select(function(d, i) { return i & 1 ? this : null; });Note that the :nth-child pseudo-class is a one-based index rather than a zero-based index. Also, the above filter functions do not have precisely the same meaning as :nth-child; they rely on the selection index rather than the number of preceding sibling elements in the DOM.The returned filtered selection preserves the parents of this selection, but like array.filter, it does not preserve indexes as some elements may be removed; use selection.select to preserve the index, if needed.selection.selectChild(selector) ​Source · Returns a new selection with the (first) child of each element of the current selection matching the selector.jsd3.selectAll("p").selectChild("b") // the first <b> child of every <p>If no selector is specified, selects the first child (if any). If the selector is specified as a string, selects the first child that matches (if any). If the selector is a function, it is evaluated for each of the children nodes, in order, being passed the child (child), the child’s index (i), and the list of children (children); the method selects the first child for which the selector return truthy, if any.CAUTIONselection.selectChild propagates the parent’s data to the selected child.selection.selectChildren(selector) ​Source · Returns a new selection with the children of each element of the current selection matching the selector. If no selector is specified, selects all the children. If the selector is specified as a string, selects the children that match (if any). If the selector is a function, it is evaluated for each of the children nodes, in order, being passed the child (child), the child’s index (i), and the list of children (children); the method selects all children for which the selector return truthy.selection.selection() ​Source · Returns the selection (for symmetry with transition.selection).matcher(selector) ​Source · Given the specified selector, returns a function which returns true if this element matches the specified selector. This method is used internally by selection.filter. For example, this:jsconst div = selection.filter("div");Is equivalent to:jsconst div = selection.filter(d3.matcher("div"));(Although D3 is not a compatibility layer, this implementation does support vendor-prefixed implementations due to the recent standardization of element.matches.)selector(selector) ​Source · Given the specified selector, returns a function which returns the first descendant of this element that matches the specified selector. This method is used internally by selection.select. For example, this:jsconst div = selection.select("div");Is equivalent to:jsconst div = selection.select(d3.selector("div"));selectorAll(selector) ​Source · Given the specified selector, returns a function which returns all descendants of this element that match the specified selector. This method is used internally by selection.selectAll. For example, this:jsconst div = selection.selectAll("div");Is equivalent to:jsconst div = selection.selectAll(d3.selectorAll("div"));window(node) ​Source · Returns the owner window for the specified node. If node is a node, returns the owner document’s default view; if node is a document, returns its default view; otherwise returns the node.style(node, name) ​Source · Returns the value of the style property with the specified name for the specified node. If the node has an inline style with the specified name, its value is returned; otherwise, the computed property value is returned. See also selection.style.PagerPrevious paged3-selectionNext pageModifying elements\n\nSelecting elements ​A selection is a set of elements from the DOM. Typically these elements are identified by selectors such as .fancy for elements with the class fancy, or div to select DIV elements.Selection methods come in two forms, select and selectAll: the former selects only the first matching element, while the latter selects all matching elements in document order. The top-level selection methods, d3.select and d3.selectAll, query the entire document; the subselection methods, selection.select and selection.selectAll, restrict selection to descendants of the selected elements. There is also selection.selectChild and selection.selectChildren for direct children.By convention, selection methods that return the current selection such as selection.attr use four spaces of indent, while methods that return a new selection use only two. This helps reveal changes of context by making them stick out of the chain:jsd3.select("body")
  .append("svg")
    .attr("width", 960)
    .attr("height", 500)
  .append("g")
    .attr("transform", "translate(20,20)")
  .append("rect")
    .attr("width", 920)
    .attr("height", 460);selection() ​Source · Selects the root element, document.documentElement.jsconst root = d3.selection();This function can also be used to test for selections (instanceof d3.selection) or to extend the selection prototype. For example, to add a method to check checkboxes:jsd3.selection.prototype.checked = function(value) {
  return arguments.length < 1
      ? this.property("checked")
      : this.property("checked", !!value);
};And then to use:jsd3.selectAll("input[type=checkbox]").checked(true);select(selector) ​Source · Selects the first element that matches the specified selector string.jsconst svg = d3.select("#chart");If no elements match the selector, returns an empty selection. If multiple elements match the selector, only the first matching element (in document order) will be selected. For example, to select the first anchor element:jsconst anchor = d3.select("a");If the selector is not a string, instead selects the specified node; this is useful if you already have a reference to a node, such as document.body.jsd3.select(document.body).style("background", "red");Or, to make a clicked paragraph red:jsd3.selectAll("p").on("click", (event) => d3.select(event.currentTarget).style("color", "red"));selectAll(selector) ​Source · Selects all elements that match the specified selector string.jsconst p = d3.selectAll("p");The elements will be selected in document order (top-to-bottom). If no elements in the document match the selector, or if the selector is null or undefined, returns an empty selection.If the selector is not a string, instead selects the specified array of nodes; this is useful if you already have a reference to nodes, such as this.childNodes within an event listener or a global such as document.links. The nodes may instead be an iterable, or a pseudo-array such as a NodeList. For example, to color all links red:jsd3.selectAll(document.links).style("color", "red");selection.select(selector) ​Source · For each selected element, selects the first descendant element that matches the specified selector string.jsconst b = d3.selectAll("p").select("b"); // the first <b> in every <p>If no element matches the specified selector for the current element, the element at the current index will be null in the returned selection. (If the selector is null, every element in the returned selection will be null, resulting in an empty selection.) If the current element has associated data, this data is propagated to the corresponding selected element. If multiple elements match the selector, only the first matching element in document order is selected.If the selector is a function, it is evaluated for each selected element, in order, being passed the current datum (d), the current index (i), and the current group (nodes), with this as the current DOM element (nodes[i]). It must return an element, or null if there is no matching element. For example, to select the previous sibling of each paragraph:jsconst previous = d3.selectAll("p").select(function() {
  return this.previousElementSibling;
});Unlike selection.selectAll, selection.select does not affect grouping: it preserves the existing group structure and indexes, and propagates data (if any) to selected children. Grouping plays an important role in the data join. See Nested Selections and How Selections Work for more on this topic.CAUTIONselection.select propagates the parent’s data to the selected child.selection.selectAll(selector) ​Source · For each selected element, selects the descendant elements that match the specified selector string.jsconst b = d3.selectAll("p").selectAll("b"); // every <b> in every <p>The elements in the returned selection are grouped by their corresponding parent node in this selection. If no element matches the specified selector for the current element, or if the selector is null, the group at the current index will be empty. The selected elements do not inherit data from this selection; use selection.data to propagate data to children.If the selector is a function, it is evaluated for each selected element, in order, being passed the current datum (d), the current index (i), and the current group (nodes), with this as the current DOM element (nodes[i]). It must return an array of elements (or an iterable, or a pseudo-array such as a NodeList), or the empty array if there are no matching elements. For example, to select the previous and next siblings of each paragraph:jsconst sibling = d3.selectAll("p").selectAll(function() {
  return [
    this.previousElementSibling,
    this.nextElementSibling
  ];
});Unlike selection.select, selection.selectAll does affect grouping: each selected descendant is grouped by the parent element in the originating selection. Grouping plays an important role in the data join. See Nested Selections and How Selections Work for more on this topic.selection.filter(filter) ​Source · Filters the selection, returning a new selection that contains only the elements for which the specified filter is true. For example, to filter a selection of table rows to contain only even rows:jsconst even = d3.selectAll("tr").filter(":nth-child(even)");This is approximately equivalent to using d3.selectAll directly, although the indexes may be different:jsconst even = d3.selectAll("tr:nth-child(even)");The filter may be specified either as a selector string or a function. If the filter is a function, it is evaluated for each selected element, in order, being passed the current datum (d), the current index (i), and the current group (nodes), with this as the current DOM element (nodes[i]). Using a function:jsconst even = d3.selectAll("tr").filter((d, i) => i & 1);Or using selection.select (and avoiding an arrow function, since this is needed to refer to the current element):jsconst even = d3.selectAll("tr").select(function(d, i) { return i & 1 ? this : null; });Note that the :nth-child pseudo-class is a one-based index rather than a zero-based index. Also, the above filter functions do not have precisely the same meaning as :nth-child; they rely on the selection index rather than the number of preceding sibling elements in the DOM.The returned filtered selection preserves the parents of this selection, but like array.filter, it does not preserve indexes as some elements may be removed; use selection.select to preserve the index, if needed.selection.selectChild(selector) ​Source · Returns a new selection with the (first) child of each element of the current selection matching the selector.jsd3.selectAll("p").selectChild("b") // the first <b> child of every <p>If no selector is specified, selects the first child (if any). If the selector is specified as a string, selects the first child that matches (if any). If the selector is a function, it is evaluated for each of the children nodes, in order, being passed the child (child), the child’s index (i), and the list of children (children); the method selects the first child for which the selector return truthy, if any.CAUTIONselection.selectChild propagates the parent’s data to the selected child.selection.selectChildren(selector) ​Source · Returns a new selection with the children of each element of the current selection matching the selector. If no selector is specified, selects all the children. If the selector is specified as a string, selects the children that match (if any). If the selector is a function, it is evaluated for each of the children nodes, in order, being passed the child (child), the child’s index (i), and the list of children (children); the method selects all children for which the selector return truthy.selection.selection() ​Source · Returns the selection (for symmetry with transition.selection).matcher(selector) ​Source · Given the specified selector, returns a function which returns true if this element matches the specified selector. This method is used internally by selection.filter. For example, this:jsconst div = selection.filter("div");Is equivalent to:jsconst div = selection.filter(d3.matcher("div"));(Although D3 is not a compatibility layer, this implementation does support vendor-prefixed implementations due to the recent standardization of element.matches.)selector(selector) ​Source · Given the specified selector, returns a function which returns the first descendant of this element that matches the specified selector. This method is used internally by selection.select. For example, this:jsconst div = selection.select("div");Is equivalent to:jsconst div = selection.select(d3.selector("div"));selectorAll(selector) ​Source · Given the specified selector, returns a function which returns all descendants of this element that match the specified selector. This method is used internally by selection.selectAll. For example, this:jsconst div = selection.selectAll("div");Is equivalent to:jsconst div = selection.selectAll(d3.selectorAll("div"));window(node) ​Source · Returns the owner window for the specified node. If node is a node, returns the owner document’s default view; if node is a document, returns its default view; otherwise returns the node.style(node, name) ​Source · Returns the value of the style property with the specified name for the specified node. If the node has an inline style with the specified name, its value is returned; otherwise, the computed property value is returned. See also selection.style.\n\n\n\nModifying elements ​After selecting elements, use the selection to modify the elements. For example, to set the class and color style of all paragraph elements in the current document:jsd3.selectAll("p")
    .attr("class", "graf")
    .style("color", "red");Selection methods typically return the current selection, or a new selection, allowing the concise application of multiple operations on a given selection via method chaining. The above is equivalent to:jsconst p = d3.selectAll("p");
p.attr("class", "graf");
p.style("color", "red");Selections are immutable. All selection methods that affect which elements are selected (or their order) return a new selection rather than modifying the current selection. However, note that elements are necessarily mutable, as selections drive transformations of the document!selection.attr(name, value) ​Source · If a value is specified, sets the attribute with the specified name to the specified value on the selected elements and returns this selection.jsselection.attr("color", "red")If the value is a constant, all elements are given the same attribute value; otherwise, if the value is a function, it is evaluated for each selected element, in order, being passed the current datum (d), the current index (i), and the current group (nodes), with this as the current DOM element (nodes[i]). The function’s return value is then used to set each element’s attribute. A null value will remove the specified attribute.jsselection.attr("color") // "red"If a value is not specified, returns the current value of the specified attribute for the first (non-null) element in the selection. This is generally useful only if you know that the selection contains exactly one element.The specified name may have a namespace prefix, such as xlink:href to specify the href attribute in the XLink namespace. See namespaces for the map of supported namespaces; additional namespaces can be registered by adding to the map.selection.classed(names, value) ​Source · If a value is specified, assigns or unassigns the specified CSS class names on the selected elements by setting the class attribute or modifying the classList property and returns this selection.jsselection.classed("foo", true)The specified names is a string of space-separated class names. For example, to assign the classes foo and bar to the selected elements:jsselection.classed("foo bar", true)If the value is truthy, then all elements are assigned the specified classes; otherwise, the classes are unassigned.jsselection.classed("foo", () => Math.random() > 0.5)If the value is a function, it is evaluated for each selected element, in order, being passed the current datum (d), the current index (i), and the current group (nodes), with this as the current DOM element (nodes[i]). The function’s return value is then used to assign or unassign classes on each element.jsselection.classed("foo") // true, perhapsIf a value is not specified, returns true if and only if the first (non-null) selected element has the specified classes. This is generally useful only if you know the selection contains exactly one element.selection.style(name, value, priority) ​Source · If a value is specified, sets the style property with the specified name to the specified value on the selected elements and returns this selection.jsselection.style("color", "red")If the value is a constant, then all elements are given the same style property value; otherwise, if the value is a function, it is evaluated for each selected element, in order, being passed the current datum (d), the current index (i), and the current group (nodes), with this as the current DOM element (nodes[i]). The function’s return value is then used to set each element’s style property. A null value will remove the style property. An optional priority may also be specified, either as null or the string important (without the exclamation point).jsselection.style("color") // "red"If a value is not specified, returns the current value of the specified style property for the first (non-null) element in the selection. The current value is defined as the element’s inline value, if present, and otherwise its computed value. Accessing the current style value is generally useful only if you know the selection contains exactly one element.CAUTIONUnlike many SVG attributes, CSS styles typically have associated units. For example, 3px is a valid stroke-width property value, while 3 is not. Some browsers implicitly assign the px (pixel) unit to numeric values, but not all browsers do: IE, for example, throws an “invalid arguments” error!selection.property(name, value) ​Source · Some HTML elements have special properties that are not addressable using attributes or styles, such as a form field’s text value and a checkbox’s checked boolean. Use this method to get or set these properties.jsselection.property("checked", true)If a value is specified, sets the property with the specified name to the specified value on selected elements. If the value is a constant, then all elements are given the same property value; otherwise, if the value is a function, it is evaluated for each selected element, in order, being passed the current datum (d), the current index (i), and the current group (nodes), with this as the current DOM element (nodes[i]). The function’s return value is then used to set each element’s property. A null value will delete the specified property.jsselection.property("checked") // true, perhapsIf a value is not specified, returns the value of the specified property for the first (non-null) element in the selection. This is generally useful only if you know the selection contains exactly one element.selection.text(value) ​Source · If a value is specified, sets the text content to the specified value on all selected elements, replacing any existing child elements.jsselection.text("Hello, world!")If the value is a constant, then all elements are given the same text content; otherwise, if the value is a function, it is evaluated for each selected element, in order, being passed the current datum (d), the current index (i), and the current group (nodes), with this as the current DOM element (nodes[i]). The function’s return value is then used to set each element’s text content. A null value will clear the content.jsselection.text() // "Hello, world!"If a value is not specified, returns the text content for the first (non-null) element in the selection. This is generally useful only if you know the selection contains exactly one element.selection.html(value) ​Source · If a value is specified, sets the inner HTML to the specified value on all selected elements, replacing any existing child elements.jsselection.html("Hello, <i>world</i>!")If the value is a constant, then all elements are given the same inner HTML; otherwise, if the value is a function, it is evaluated for each selected element, in order, being passed the current datum (d), the current index (i), and the current group (nodes), with this as the current DOM element (nodes[i]). The function’s return value is then used to set each element’s inner HTML. A null value will clear the content.jsselection.html() // "Hello, <i>world</i>!"If a value is not specified, returns the inner HTML for the first (non-null) element in the selection. This is generally useful only if you know the selection contains exactly one element.Use selection.append or selection.insert instead to create data-driven content; this method is intended for when you want a little bit of HTML, say for rich formatting. Also, selection.html is only supported on HTML elements. SVG elements and other non-HTML elements do not support the innerHTML property, and thus are incompatible with selection.html. Consider using XMLSerializer to convert a DOM subtree to text. See also the innersvg polyfill, which provides a shim to support the innerHTML property on SVG elements.selection.append(type) ​Source · If the specified type is a string, appends a new element of this type (tag name) as the last child of each selected element, or before the next following sibling in the update selection if this is an enter selection. The latter behavior for enter selections allows you to insert elements into the DOM in an order consistent with the new bound data; however, note that selection.order may still be required if updating elements change order (i.e., if the order of new data is inconsistent with old data).If the specified type is a function, it is evaluated for each selected element, in order, being passed the current datum (d), the current index (i), and the current group (nodes), with this as the current DOM element (nodes[i]). This function should return an element to be appended. (The function typically creates a new element, but it may instead return an existing element.) For example, to append a paragraph to each DIV element:jsd3.selectAll("div").append("p");This is equivalent to:jsd3.selectAll("div").append(() => document.createElement("p"));Which is equivalent to:jsd3.selectAll("div").select(function() {
  return this.appendChild(document.createElement("p"));
});In both cases, this method returns a new selection containing the appended elements. Each new element inherits the data of the current elements, if any, in the same manner as selection.select.The specified name may have a namespace prefix, such as svg:text to specify a text attribute in the SVG namespace. See namespaces for the map of supported namespaces; additional namespaces can be registered by adding to the map. If no namespace is specified, the namespace will be inherited from the parent element; or, if the name is one of the known prefixes, the corresponding namespace will be used (for example, svg implies svg:svg).selection.insert(type, before) ​Source · If the specified type is a string, inserts a new element of this type (tag name) before the first element matching the specified before selector for each selected element. For example, a before selector :first-child will prepend nodes before the first child. If before is not specified, it defaults to null. (To append elements in an order consistent with bound data, use selection.append.)Both type and before may instead be specified as functions which are evaluated for each selected element, in order, being passed the current datum (d), the current index (i), and the current group (nodes), with this as the current DOM element (nodes[i]). The type function should return an element to be inserted; the before function should return the child element before which the element should be inserted. For example, to append a paragraph to each DIV element:jsd3.selectAll("div").insert("p");This is equivalent to:jsd3.selectAll("div").insert(() => document.createElement("p"));Which is equivalent to:jsd3.selectAll("div").select(function() {
  return this.insertBefore(document.createElement("p"), null);
});In both cases, this method returns a new selection containing the appended elements. Each new element inherits the data of the current elements, if any, in the same manner as selection.select.The specified name may have a namespace prefix, such as svg:text to specify a text attribute in the SVG namespace. See namespaces for the map of supported namespaces; additional namespaces can be registered by adding to the map. If no namespace is specified, the namespace will be inherited from the parent element; or, if the name is one of the known prefixes, the corresponding namespace will be used (for example, svg implies svg:svg).selection.remove() ​Source · Removes the selected elements from the document. Returns this selection (the removed elements) which are now detached from the DOM. There is not currently a dedicated API to add removed elements back to the document; however, you can pass a function to selection.append or selection.insert to re-add elements.selection.clone(deep) ​Source · Inserts clones of the selected elements immediately following the selected elements and returns a selection of the newly added clones. If deep is truthy, the descendant nodes of the selected elements will be cloned as well. Otherwise, only the elements themselves will be cloned. Equivalent to:jsselection.select(function() {
  return this.parentNode.insertBefore(this.cloneNode(deep), this.nextSibling);
});selection.sort(compare) ​Source · Returns a new selection that contains a copy of each group in this selection sorted according to the compare function. After sorting, re-inserts elements to match the resulting order (per selection.order).The compare function, which defaults to ascending, is passed two elements’ data a and b to compare. It should return either a negative, positive, or zero value. If negative, then a should be before b; if positive, then a should be after b; otherwise, a and b are considered equal and the order is arbitrary.selection.order() ​Source · Re-inserts elements into the document such that the document order of each group matches the selection order. This is equivalent to calling selection.sort if the data is already sorted, but much faster.selection.raise() ​Source · Re-inserts each selected element, in order, as the last child of its parent. Equivalent to:jsselection.each(function() {
  this.parentNode.appendChild(this);
});selection.lower() ​Source · Re-inserts each selected element, in order, as the first child of its parent. Equivalent to:jsselection.each(function() {
  this.parentNode.insertBefore(this, this.parentNode.firstChild);
});create(name) ​Source · Given the specified element name, returns a single-element selection containing a detached element of the given name in the current document. This method assumes the HTML namespace, so you must specify a namespace explicitly when creating SVG or other non-HTML elements; see namespace for details on supported namespace prefixes.jsd3.create("svg") // equivalent to svg:svgjsd3.create("svg:svg") // more explicitlyjsd3.create("svg:g") // an SVG G elementjsd3.create("g") // an HTML G (unknown) elementcreator(name) ​Source · Given the specified element name, returns a function which creates an element of the given name, assuming that this is the parent element. This method is used internally by selection.append and selection.insert to create new elements. For example, this:jsselection.append("div");Is equivalent to:jsselection.append(d3.creator("div"));See namespace for details on supported namespace prefixes, such as for SVG elements.\n\nSearchK7.9.0GitHub️ 110.0kOn this pageModifying elements ​After selecting elements, use the selection to modify the elements. For example, to set the class and color style of all paragraph elements in the current document:jsd3.selectAll("p")
    .attr("class", "graf")
    .style("color", "red");Selection methods typically return the current selection, or a new selection, allowing the concise application of multiple operations on a given selection via method chaining. The above is equivalent to:jsconst p = d3.selectAll("p");
p.attr("class", "graf");
p.style("color", "red");Selections are immutable. All selection methods that affect which elements are selected (or their order) return a new selection rather than modifying the current selection. However, note that elements are necessarily mutable, as selections drive transformations of the document!selection.attr(name, value) ​Source · If a value is specified, sets the attribute with the specified name to the specified value on the selected elements and returns this selection.jsselection.attr("color", "red")If the value is a constant, all elements are given the same attribute value; otherwise, if the value is a function, it is evaluated for each selected element, in order, being passed the current datum (d), the current index (i), and the current group (nodes), with this as the current DOM element (nodes[i]). The function’s return value is then used to set each element’s attribute. A null value will remove the specified attribute.jsselection.attr("color") // "red"If a value is not specified, returns the current value of the specified attribute for the first (non-null) element in the selection. This is generally useful only if you know that the selection contains exactly one element.The specified name may have a namespace prefix, such as xlink:href to specify the href attribute in the XLink namespace. See namespaces for the map of supported namespaces; additional namespaces can be registered by adding to the map.selection.classed(names, value) ​Source · If a value is specified, assigns or unassigns the specified CSS class names on the selected elements by setting the class attribute or modifying the classList property and returns this selection.jsselection.classed("foo", true)The specified names is a string of space-separated class names. For example, to assign the classes foo and bar to the selected elements:jsselection.classed("foo bar", true)If the value is truthy, then all elements are assigned the specified classes; otherwise, the classes are unassigned.jsselection.classed("foo", () => Math.random() > 0.5)If the value is a function, it is evaluated for each selected element, in order, being passed the current datum (d), the current index (i), and the current group (nodes), with this as the current DOM element (nodes[i]). The function’s return value is then used to assign or unassign classes on each element.jsselection.classed("foo") // true, perhapsIf a value is not specified, returns true if and only if the first (non-null) selected element has the specified classes. This is generally useful only if you know the selection contains exactly one element.selection.style(name, value, priority) ​Source · If a value is specified, sets the style property with the specified name to the specified value on the selected elements and returns this selection.jsselection.style("color", "red")If the value is a constant, then all elements are given the same style property value; otherwise, if the value is a function, it is evaluated for each selected element, in order, being passed the current datum (d), the current index (i), and the current group (nodes), with this as the current DOM element (nodes[i]). The function’s return value is then used to set each element’s style property. A null value will remove the style property. An optional priority may also be specified, either as null or the string important (without the exclamation point).jsselection.style("color") // "red"If a value is not specified, returns the current value of the specified style property for the first (non-null) element in the selection. The current value is defined as the element’s inline value, if present, and otherwise its computed value. Accessing the current style value is generally useful only if you know the selection contains exactly one element.CAUTIONUnlike many SVG attributes, CSS styles typically have associated units. For example, 3px is a valid stroke-width property value, while 3 is not. Some browsers implicitly assign the px (pixel) unit to numeric values, but not all browsers do: IE, for example, throws an “invalid arguments” error!selection.property(name, value) ​Source · Some HTML elements have special properties that are not addressable using attributes or styles, such as a form field’s text value and a checkbox’s checked boolean. Use this method to get or set these properties.jsselection.property("checked", true)If a value is specified, sets the property with the specified name to the specified value on selected elements. If the value is a constant, then all elements are given the same property value; otherwise, if the value is a function, it is evaluated for each selected element, in order, being passed the current datum (d), the current index (i), and the current group (nodes), with this as the current DOM element (nodes[i]). The function’s return value is then used to set each element’s property. A null value will delete the specified property.jsselection.property("checked") // true, perhapsIf a value is not specified, returns the value of the specified property for the first (non-null) element in the selection. This is generally useful only if you know the selection contains exactly one element.selection.text(value) ​Source · If a value is specified, sets the text content to the specified value on all selected elements, replacing any existing child elements.jsselection.text("Hello, world!")If the value is a constant, then all elements are given the same text content; otherwise, if the value is a function, it is evaluated for each selected element, in order, being passed the current datum (d), the current index (i), and the current group (nodes), with this as the current DOM element (nodes[i]). The function’s return value is then used to set each element’s text content. A null value will clear the content.jsselection.text() // "Hello, world!"If a value is not specified, returns the text content for the first (non-null) element in the selection. This is generally useful only if you know the selection contains exactly one element.selection.html(value) ​Source · If a value is specified, sets the inner HTML to the specified value on all selected elements, replacing any existing child elements.jsselection.html("Hello, <i>world</i>!")If the value is a constant, then all elements are given the same inner HTML; otherwise, if the value is a function, it is evaluated for each selected element, in order, being passed the current datum (d), the current index (i), and the current group (nodes), with this as the current DOM element (nodes[i]). The function’s return value is then used to set each element’s inner HTML. A null value will clear the content.jsselection.html() // "Hello, <i>world</i>!"If a value is not specified, returns the inner HTML for the first (non-null) element in the selection. This is generally useful only if you know the selection contains exactly one element.Use selection.append or selection.insert instead to create data-driven content; this method is intended for when you want a little bit of HTML, say for rich formatting. Also, selection.html is only supported on HTML elements. SVG elements and other non-HTML elements do not support the innerHTML property, and thus are incompatible with selection.html. Consider using XMLSerializer to convert a DOM subtree to text. See also the innersvg polyfill, which provides a shim to support the innerHTML property on SVG elements.selection.append(type) ​Source · If the specified type is a string, appends a new element of this type (tag name) as the last child of each selected element, or before the next following sibling in the update selection if this is an enter selection. The latter behavior for enter selections allows you to insert elements into the DOM in an order consistent with the new bound data; however, note that selection.order may still be required if updating elements change order (i.e., if the order of new data is inconsistent with old data).If the specified type is a function, it is evaluated for each selected element, in order, being passed the current datum (d), the current index (i), and the current group (nodes), with this as the current DOM element (nodes[i]). This function should return an element to be appended. (The function typically creates a new element, but it may instead return an existing element.) For example, to append a paragraph to each DIV element:jsd3.selectAll("div").append("p");This is equivalent to:jsd3.selectAll("div").append(() => document.createElement("p"));Which is equivalent to:jsd3.selectAll("div").select(function() {
  return this.appendChild(document.createElement("p"));
});In both cases, this method returns a new selection containing the appended elements. Each new element inherits the data of the current elements, if any, in the same manner as selection.select.The specified name may have a namespace prefix, such as svg:text to specify a text attribute in the SVG namespace. See namespaces for the map of supported namespaces; additional namespaces can be registered by adding to the map. If no namespace is specified, the namespace will be inherited from the parent element; or, if the name is one of the known prefixes, the corresponding namespace will be used (for example, svg implies svg:svg).selection.insert(type, before) ​Source · If the specified type is a string, inserts a new element of this type (tag name) before the first element matching the specified before selector for each selected element. For example, a before selector :first-child will prepend nodes before the first child. If before is not specified, it defaults to null. (To append elements in an order consistent with bound data, use selection.append.)Both type and before may instead be specified as functions which are evaluated for each selected element, in order, being passed the current datum (d), the current index (i), and the current group (nodes), with this as the current DOM element (nodes[i]). The type function should return an element to be inserted; the before function should return the child element before which the element should be inserted. For example, to append a paragraph to each DIV element:jsd3.selectAll("div").insert("p");This is equivalent to:jsd3.selectAll("div").insert(() => document.createElement("p"));Which is equivalent to:jsd3.selectAll("div").select(function() {
  return this.insertBefore(document.createElement("p"), null);
});In both cases, this method returns a new selection containing the appended elements. Each new element inherits the data of the current elements, if any, in the same manner as selection.select.The specified name may have a namespace prefix, such as svg:text to specify a text attribute in the SVG namespace. See namespaces for the map of supported namespaces; additional namespaces can be registered by adding to the map. If no namespace is specified, the namespace will be inherited from the parent element; or, if the name is one of the known prefixes, the corresponding namespace will be used (for example, svg implies svg:svg).selection.remove() ​Source · Removes the selected elements from the document. Returns this selection (the removed elements) which are now detached from the DOM. There is not currently a dedicated API to add removed elements back to the document; however, you can pass a function to selection.append or selection.insert to re-add elements.selection.clone(deep) ​Source · Inserts clones of the selected elements immediately following the selected elements and returns a selection of the newly added clones. If deep is truthy, the descendant nodes of the selected elements will be cloned as well. Otherwise, only the elements themselves will be cloned. Equivalent to:jsselection.select(function() {
  return this.parentNode.insertBefore(this.cloneNode(deep), this.nextSibling);
});selection.sort(compare) ​Source · Returns a new selection that contains a copy of each group in this selection sorted according to the compare function. After sorting, re-inserts elements to match the resulting order (per selection.order).The compare function, which defaults to ascending, is passed two elements’ data a and b to compare. It should return either a negative, positive, or zero value. If negative, then a should be before b; if positive, then a should be after b; otherwise, a and b are considered equal and the order is arbitrary.selection.order() ​Source · Re-inserts elements into the document such that the document order of each group matches the selection order. This is equivalent to calling selection.sort if the data is already sorted, but much faster.selection.raise() ​Source · Re-inserts each selected element, in order, as the last child of its parent. Equivalent to:jsselection.each(function() {
  this.parentNode.appendChild(this);
});selection.lower() ​Source · Re-inserts each selected element, in order, as the first child of its parent. Equivalent to:jsselection.each(function() {
  this.parentNode.insertBefore(this, this.parentNode.firstChild);
});create(name) ​Source · Given the specified element name, returns a single-element selection containing a detached element of the given name in the current document. This method assumes the HTML namespace, so you must specify a namespace explicitly when creating SVG or other non-HTML elements; see namespace for details on supported namespace prefixes.jsd3.create("svg") // equivalent to svg:svgjsd3.create("svg:svg") // more explicitlyjsd3.create("svg:g") // an SVG G elementjsd3.create("g") // an HTML G (unknown) elementcreator(name) ​Source · Given the specified element name, returns a function which creates an element of the given name, assuming that this is the parent element. This method is used internally by selection.append and selection.insert to create new elements. For example, this:jsselection.append("div");Is equivalent to:jsselection.append(d3.creator("div"));See namespace for details on supported namespace prefixes, such as for SVG elements.PagerPrevious pageSelecting elementsNext pageJoining data\n\nModifying elements ​After selecting elements, use the selection to modify the elements. For example, to set the class and color style of all paragraph elements in the current document:jsd3.selectAll("p")
    .attr("class", "graf")
    .style("color", "red");Selection methods typically return the current selection, or a new selection, allowing the concise application of multiple operations on a given selection via method chaining. The above is equivalent to:jsconst p = d3.selectAll("p");
p.attr("class", "graf");
p.style("color", "red");Selections are immutable. All selection methods that affect which elements are selected (or their order) return a new selection rather than modifying the current selection. However, note that elements are necessarily mutable, as selections drive transformations of the document!selection.attr(name, value) ​Source · If a value is specified, sets the attribute with the specified name to the specified value on the selected elements and returns this selection.jsselection.attr("color", "red")If the value is a constant, all elements are given the same attribute value; otherwise, if the value is a function, it is evaluated for each selected element, in order, being passed the current datum (d), the current index (i), and the current group (nodes), with this as the current DOM element (nodes[i]). The function’s return value is then used to set each element’s attribute. A null value will remove the specified attribute.jsselection.attr("color") // "red"If a value is not specified, returns the current value of the specified attribute for the first (non-null) element in the selection. This is generally useful only if you know that the selection contains exactly one element.The specified name may have a namespace prefix, such as xlink:href to specify the href attribute in the XLink namespace. See namespaces for the map of supported namespaces; additional namespaces can be registered by adding to the map.selection.classed(names, value) ​Source · If a value is specified, assigns or unassigns the specified CSS class names on the selected elements by setting the class attribute or modifying the classList property and returns this selection.jsselection.classed("foo", true)The specified names is a string of space-separated class names. For example, to assign the classes foo and bar to the selected elements:jsselection.classed("foo bar", true)If the value is truthy, then all elements are assigned the specified classes; otherwise, the classes are unassigned.jsselection.classed("foo", () => Math.random() > 0.5)If the value is a function, it is evaluated for each selected element, in order, being passed the current datum (d), the current index (i), and the current group (nodes), with this as the current DOM element (nodes[i]). The function’s return value is then used to assign or unassign classes on each element.jsselection.classed("foo") // true, perhapsIf a value is not specified, returns true if and only if the first (non-null) selected element has the specified classes. This is generally useful only if you know the selection contains exactly one element.selection.style(name, value, priority) ​Source · If a value is specified, sets the style property with the specified name to the specified value on the selected elements and returns this selection.jsselection.style("color", "red")If the value is a constant, then all elements are given the same style property value; otherwise, if the value is a function, it is evaluated for each selected element, in order, being passed the current datum (d), the current index (i), and the current group (nodes), with this as the current DOM element (nodes[i]). The function’s return value is then used to set each element’s style property. A null value will remove the style property. An optional priority may also be specified, either as null or the string important (without the exclamation point).jsselection.style("color") // "red"If a value is not specified, returns the current value of the specified style property for the first (non-null) element in the selection. The current value is defined as the element’s inline value, if present, and otherwise its computed value. Accessing the current style value is generally useful only if you know the selection contains exactly one element.CAUTIONUnlike many SVG attributes, CSS styles typically have associated units. For example, 3px is a valid stroke-width property value, while 3 is not. Some browsers implicitly assign the px (pixel) unit to numeric values, but not all browsers do: IE, for example, throws an “invalid arguments” error!selection.property(name, value) ​Source · Some HTML elements have special properties that are not addressable using attributes or styles, such as a form field’s text value and a checkbox’s checked boolean. Use this method to get or set these properties.jsselection.property("checked", true)If a value is specified, sets the property with the specified name to the specified value on selected elements. If the value is a constant, then all elements are given the same property value; otherwise, if the value is a function, it is evaluated for each selected element, in order, being passed the current datum (d), the current index (i), and the current group (nodes), with this as the current DOM element (nodes[i]). The function’s return value is then used to set each element’s property. A null value will delete the specified property.jsselection.property("checked") // true, perhapsIf a value is not specified, returns the value of the specified property for the first (non-null) element in the selection. This is generally useful only if you know the selection contains exactly one element.selection.text(value) ​Source · If a value is specified, sets the text content to the specified value on all selected elements, replacing any existing child elements.jsselection.text("Hello, world!")If the value is a constant, then all elements are given the same text content; otherwise, if the value is a function, it is evaluated for each selected element, in order, being passed the current datum (d), the current index (i), and the current group (nodes), with this as the current DOM element (nodes[i]). The function’s return value is then used to set each element’s text content. A null value will clear the content.jsselection.text() // "Hello, world!"If a value is not specified, returns the text content for the first (non-null) element in the selection. This is generally useful only if you know the selection contains exactly one element.selection.html(value) ​Source · If a value is specified, sets the inner HTML to the specified value on all selected elements, replacing any existing child elements.jsselection.html("Hello, <i>world</i>!")If the value is a constant, then all elements are given the same inner HTML; otherwise, if the value is a function, it is evaluated for each selected element, in order, being passed the current datum (d), the current index (i), and the current group (nodes), with this as the current DOM element (nodes[i]). The function’s return value is then used to set each element’s inner HTML. A null value will clear the content.jsselection.html() // "Hello, <i>world</i>!"If a value is not specified, returns the inner HTML for the first (non-null) element in the selection. This is generally useful only if you know the selection contains exactly one element.Use selection.append or selection.insert instead to create data-driven content; this method is intended for when you want a little bit of HTML, say for rich formatting. Also, selection.html is only supported on HTML elements. SVG elements and other non-HTML elements do not support the innerHTML property, and thus are incompatible with selection.html. Consider using XMLSerializer to convert a DOM subtree to text. See also the innersvg polyfill, which provides a shim to support the innerHTML property on SVG elements.selection.append(type) ​Source · If the specified type is a string, appends a new element of this type (tag name) as the last child of each selected element, or before the next following sibling in the update selection if this is an enter selection. The latter behavior for enter selections allows you to insert elements into the DOM in an order consistent with the new bound data; however, note that selection.order may still be required if updating elements change order (i.e., if the order of new data is inconsistent with old data).If the specified type is a function, it is evaluated for each selected element, in order, being passed the current datum (d), the current index (i), and the current group (nodes), with this as the current DOM element (nodes[i]). This function should return an element to be appended. (The function typically creates a new element, but it may instead return an existing element.) For example, to append a paragraph to each DIV element:jsd3.selectAll("div").append("p");This is equivalent to:jsd3.selectAll("div").append(() => document.createElement("p"));Which is equivalent to:jsd3.selectAll("div").select(function() {
  return this.appendChild(document.createElement("p"));
});In both cases, this method returns a new selection containing the appended elements. Each new element inherits the data of the current elements, if any, in the same manner as selection.select.The specified name may have a namespace prefix, such as svg:text to specify a text attribute in the SVG namespace. See namespaces for the map of supported namespaces; additional namespaces can be registered by adding to the map. If no namespace is specified, the namespace will be inherited from the parent element; or, if the name is one of the known prefixes, the corresponding namespace will be used (for example, svg implies svg:svg).selection.insert(type, before) ​Source · If the specified type is a string, inserts a new element of this type (tag name) before the first element matching the specified before selector for each selected element. For example, a before selector :first-child will prepend nodes before the first child. If before is not specified, it defaults to null. (To append elements in an order consistent with bound data, use selection.append.)Both type and before may instead be specified as functions which are evaluated for each selected element, in order, being passed the current datum (d), the current index (i), and the current group (nodes), with this as the current DOM element (nodes[i]). The type function should return an element to be inserted; the before function should return the child element before which the element should be inserted. For example, to append a paragraph to each DIV element:jsd3.selectAll("div").insert("p");This is equivalent to:jsd3.selectAll("div").insert(() => document.createElement("p"));Which is equivalent to:jsd3.selectAll("div").select(function() {
  return this.insertBefore(document.createElement("p"), null);
});In both cases, this method returns a new selection containing the appended elements. Each new element inherits the data of the current elements, if any, in the same manner as selection.select.The specified name may have a namespace prefix, such as svg:text to specify a text attribute in the SVG namespace. See namespaces for the map of supported namespaces; additional namespaces can be registered by adding to the map. If no namespace is specified, the namespace will be inherited from the parent element; or, if the name is one of the known prefixes, the corresponding namespace will be used (for example, svg implies svg:svg).selection.remove() ​Source · Removes the selected elements from the document. Returns this selection (the removed elements) which are now detached from the DOM. There is not currently a dedicated API to add removed elements back to the document; however, you can pass a function to selection.append or selection.insert to re-add elements.selection.clone(deep) ​Source · Inserts clones of the selected elements immediately following the selected elements and returns a selection of the newly added clones. If deep is truthy, the descendant nodes of the selected elements will be cloned as well. Otherwise, only the elements themselves will be cloned. Equivalent to:jsselection.select(function() {
  return this.parentNode.insertBefore(this.cloneNode(deep), this.nextSibling);
});selection.sort(compare) ​Source · Returns a new selection that contains a copy of each group in this selection sorted according to the compare function. After sorting, re-inserts elements to match the resulting order (per selection.order).The compare function, which defaults to ascending, is passed two elements’ data a and b to compare. It should return either a negative, positive, or zero value. If negative, then a should be before b; if positive, then a should be after b; otherwise, a and b are considered equal and the order is arbitrary.selection.order() ​Source · Re-inserts elements into the document such that the document order of each group matches the selection order. This is equivalent to calling selection.sort if the data is already sorted, but much faster.selection.raise() ​Source · Re-inserts each selected element, in order, as the last child of its parent. Equivalent to:jsselection.each(function() {
  this.parentNode.appendChild(this);
});selection.lower() ​Source · Re-inserts each selected element, in order, as the first child of its parent. Equivalent to:jsselection.each(function() {
  this.parentNode.insertBefore(this, this.parentNode.firstChild);
});create(name) ​Source · Given the specified element name, returns a single-element selection containing a detached element of the given name in the current document. This method assumes the HTML namespace, so you must specify a namespace explicitly when creating SVG or other non-HTML elements; see namespace for details on supported namespace prefixes.jsd3.create("svg") // equivalent to svg:svgjsd3.create("svg:svg") // more explicitlyjsd3.create("svg:g") // an SVG G elementjsd3.create("g") // an HTML G (unknown) elementcreator(name) ​Source · Given the specified element name, returns a function which creates an element of the given name, assuming that this is the parent element. This method is used internally by selection.append and selection.insert to create new elements. For example, this:jsselection.append("div");Is equivalent to:jsselection.append(d3.creator("div"));See namespace for details on supported namespace prefixes, such as for SVG elements.\n\n\n\nJoining data ​For an introduction, see Thinking With Joins and the selection.join notebook.selection.data(data, key) ​Source · Binds the specified array of data with the selected elements, returning a new selection that represents the update selection: the elements successfully bound to data. Also defines the enter and exit selections on the returned selection, which can be used to add or remove elements to correspond to the new data. The specified data is an array of arbitrary values (e.g., numbers or objects), or a function that returns an array of values for each group. When data is assigned to an element, it is stored in the property __data__, thus making the data “sticky” and available on re-selection.The data is specified for each group in the selection. If the selection has multiple groups (such as d3.selectAll followed by selection.selectAll), then data should typically be specified as a function. This function will be evaluated for each group in order, being passed the group’s parent datum (d, which may be undefined), the group index (i), and the selection’s parent nodes (nodes), with this as the group’s parent element.In conjunction with selection.join (or more explicitly with selection.enter, selection.exit, selection.append and selection.remove), selection.data can be used to enter, update and exit elements to match data. For example, to create an HTML table from a matrix of numbers:jsconst matrix = [
  [11975,  5871, 8916, 2868],
  [ 1951, 10048, 2060, 6171],
  [ 8010, 16145, 8090, 8045],
  [ 1013,   990,  940, 6907]
];

d3.select("body")
  .append("table")
  .selectAll("tr")
  .data(matrix)
  .join("tr")
  .selectAll("td")
  .data(d => d)
  .join("td")
    .text(d => d);In this example the data function is the identity function: for each table row, it returns the corresponding row from the data matrix.If a key function is not specified, then the first datum in data is assigned to the first selected element, the second datum to the second selected element, and so on. A key function may be specified to control which datum is assigned to which element, replacing the default join-by-index, by computing a string identifier for each datum and element. This key function is evaluated for each selected element, in order, being passed the current datum (d), the current index (i), and the current group (nodes), with this as the current DOM element (nodes[i]); the returned string is the element’s key. The key function is then also evaluated for each new datum in data, being passed the current datum (d), the current index (i), and the group’s new data, with this as the group’s parent DOM element; the returned string is the datum’s key. The datum for a given key is assigned to the element with the matching key. If multiple elements have the same key, the duplicate elements are put into the exit selection; if multiple data have the same key, the duplicate data are put into the enter selection.For example, given this document:html<div id="Ford"></div>
<div id="Jarrah"></div>
<div id="Kwon"></div>
<div id="Locke"></div>
<div id="Reyes"></div>
<div id="Shephard"></div>You could join data by key as follows:jsconst data = [
  {name: "Locke", number: 4},
  {name: "Reyes", number: 8},
  {name: "Ford", number: 15},
  {name: "Jarrah", number: 16},
  {name: "Shephard", number: 23},
  {name: "Kwon", number: 42}
];

d3.selectAll("div")
  .data(data, function(d) { return d ? d.name : this.id; })
    .text(d => d.number);This example key function uses the datum d if present, and otherwise falls back to the element’s id property. Since these elements were not previously bound to data, the datum d is null when the key function is evaluated on selected elements, and non-null when the key function is evaluated on the new data.The update and enter selections are returned in data order, while the exit selection preserves the selection order prior to the join. If a key function is specified, the order of elements in the selection may not match their order in the document; use selection.order or selection.sort as needed. For more on how the key function affects the join, see A Bar Chart, Part 2 and Object Constancy.If data is not specified, this method returns the array of data for the selected elements.This method cannot be used to clear bound data; use selection.datum instead.selection.join(enter, update, exit) ​Source · Appends, removes and reorders elements as necessary to match the data that was previously bound by selection.data, returning the merged enter and update selection. This method is a convenient alternative to the explicit general update pattern, replacing selection.enter, selection.exit, selection.append, selection.remove, and selection.order. For example:jssvg.selectAll("circle")
  .data(data)
  .join("circle")
    .attr("fill", "none")
    .attr("stroke", "black");The enter function may be specified as a string shorthand, as above, which is equivalent to selection.append with the given element name. Likewise, optional update and exit functions may be specified, which default to the identity function and calling selection.remove, respectively. The shorthand above is thus equivalent to:jssvg.selectAll("circle")
  .data(data)
  .join(
    enter => enter.append("circle"),
    update => update,
    exit => exit.remove()
  )
    .attr("fill", "none")
    .attr("stroke", "black");By passing separate functions on enter, update and exit, you have greater control over what happens. And by specifying a key function to selection.data, you can minimize changes to the DOM to optimize performance. For example, to set different fill colors for enter and update:jssvg.selectAll("circle")
  .data(data)
  .join(
    enter => enter.append("circle").attr("fill", "green"),
    update => update.attr("fill", "blue")
  )
    .attr("stroke", "black");The selections returned by the enter and update functions are merged and then returned by selection.join.You can animate enter, update and exit by creating transitions inside the enter, update and exit functions. If the enter and update functions return transitions, their underlying selections are merged and then returned by selection.join. The return value of the exit function is not used.For more, see the selection.join notebook.selection.enter() ​Source · Returns the enter selection: placeholder nodes for each datum that had no corresponding DOM element in the selection. (The enter selection is empty for selections not returned by selection.data.)The enter selection is typically used to create “missing” elements corresponding to new data. For example, to create DIV elements from an array of numbers:jsconst div = d3.select("body")
  .selectAll("div")
  .data([4, 8, 15, 16, 23, 42])
  .enter().append("div")
    .text(d => d);If the body is initially empty, the above code will create six new DIV elements, append them to the body in-order, and assign their text content as the associated (string-coerced) number:html<div>4</div>
<div>8</div>
<div>15</div>
<div>16</div>
<div>23</div>
<div>42</div>Conceptually, the enter selection’s placeholders are pointers to the parent element (in this example, the document body). The enter selection is typically only used transiently to append elements, and is often merged with the update selection after appending, such that modifications can be applied to both entering and updating elements.selection.exit() ​Source · Returns the exit selection: existing DOM elements in the selection for which no new datum was found. (The exit selection is empty for selections not returned by selection.data.)The exit selection is typically used to remove “superfluous” elements corresponding to old data. For example, to update the DIV elements created previously with a new array of numbers:jsdiv = div.data([1, 2, 4, 8, 16, 32], d => d);Since a key function was specified (as the identity function), and the new data contains the numbers [4, 8, 16] which match existing elements in the document, the update selection contains three DIV elements. Leaving those elements as-is, we can append new elements for [1, 2, 32] using the enter selection:jsdiv.enter().append("div").text(d => d);Likewise, to remove the exiting elements [15, 23, 42]:jsdiv.exit().remove();Now the document body looks like this:html<div>1</div>
<div>2</div>
<div>4</div>
<div>8</div>
<div>16</div>
<div>32</div>The order of the DOM elements matches the order of the data because the old data’s order and the new data’s order were consistent. If the new data’s order is different, use selection.order to reorder the elements in the DOM. See the general update pattern notebook for more on data joins.selection.datum(value) ​Source · Gets or sets the bound data for each selected element. Unlike selection.data, this method does not compute a join and does not affect indexes or the enter and exit selections.If a value is specified, sets the element’s bound data to the specified value on all selected elements. If the value is a constant, all elements are given the same datum; otherwise, if the value is a function, it is evaluated for each selected element, in order, being passed the current datum (d), the current index (i), and the current group (nodes), with this as the current DOM element (nodes[i]). The function is then used to set each element’s new data. A null value will delete the bound data.If a value is not specified, returns the bound datum for the first (non-null) element in the selection. This is generally useful only if you know the selection contains exactly one element.This method is useful for accessing HTML5 custom data attributes. For example, given the following elements:html<ul id="list">
  <li data-username="shawnbot">Shawn Allen</li>
  <li data-username="mbostock">Mike Bostock</li>
</ul>You can expose the custom data attributes by setting each element’s data as the built-in dataset property:jsselection.datum(function() { return this.dataset; })selection.merge(other) ​Source · Returns a new selection merging this selection with the specified other selection or transition. The returned selection has the same number of groups and the same parents as this selection. Any missing (null) elements in this selection are filled with the corresponding element, if present (not null), from the specified selection. (If the other selection has additional groups or parents, they are ignored.)This method is used internally by selection.join to merge the enter and update selections after binding data. You can also merge explicitly, although note that since merging is based on element index, you should use operations that preserve index, such as selection.select instead of selection.filter. For example:jsconst odd = selection.select(function(d, i) { return i & 1 ? this : null; ));
const even = selection.select(function(d, i) { return i & 1 ? null : this; ));
const merged = odd.merge(even);See selection.data for more.This method is not intended for concatenating arbitrary selections, however: if both this selection and the specified other selection have (non-null) elements at the same index, this selection’s element is returned in the merge and the other selection’s element is ignored.\n\nSearchK7.9.0GitHub️ 110.0kOn this pageJoining data ​For an introduction, see Thinking With Joins and the selection.join notebook.selection.data(data, key) ​Source · Binds the specified array of data with the selected elements, returning a new selection that represents the update selection: the elements successfully bound to data. Also defines the enter and exit selections on the returned selection, which can be used to add or remove elements to correspond to the new data. The specified data is an array of arbitrary values (e.g., numbers or objects), or a function that returns an array of values for each group. When data is assigned to an element, it is stored in the property __data__, thus making the data “sticky” and available on re-selection.The data is specified for each group in the selection. If the selection has multiple groups (such as d3.selectAll followed by selection.selectAll), then data should typically be specified as a function. This function will be evaluated for each group in order, being passed the group’s parent datum (d, which may be undefined), the group index (i), and the selection’s parent nodes (nodes), with this as the group’s parent element.In conjunction with selection.join (or more explicitly with selection.enter, selection.exit, selection.append and selection.remove), selection.data can be used to enter, update and exit elements to match data. For example, to create an HTML table from a matrix of numbers:jsconst matrix = [
  [11975,  5871, 8916, 2868],
  [ 1951, 10048, 2060, 6171],
  [ 8010, 16145, 8090, 8045],
  [ 1013,   990,  940, 6907]
];

d3.select("body")
  .append("table")
  .selectAll("tr")
  .data(matrix)
  .join("tr")
  .selectAll("td")
  .data(d => d)
  .join("td")
    .text(d => d);In this example the data function is the identity function: for each table row, it returns the corresponding row from the data matrix.If a key function is not specified, then the first datum in data is assigned to the first selected element, the second datum to the second selected element, and so on. A key function may be specified to control which datum is assigned to which element, replacing the default join-by-index, by computing a string identifier for each datum and element. This key function is evaluated for each selected element, in order, being passed the current datum (d), the current index (i), and the current group (nodes), with this as the current DOM element (nodes[i]); the returned string is the element’s key. The key function is then also evaluated for each new datum in data, being passed the current datum (d), the current index (i), and the group’s new data, with this as the group’s parent DOM element; the returned string is the datum’s key. The datum for a given key is assigned to the element with the matching key. If multiple elements have the same key, the duplicate elements are put into the exit selection; if multiple data have the same key, the duplicate data are put into the enter selection.For example, given this document:html<div id="Ford"></div>
<div id="Jarrah"></div>
<div id="Kwon"></div>
<div id="Locke"></div>
<div id="Reyes"></div>
<div id="Shephard"></div>You could join data by key as follows:jsconst data = [
  {name: "Locke", number: 4},
  {name: "Reyes", number: 8},
  {name: "Ford", number: 15},
  {name: "Jarrah", number: 16},
  {name: "Shephard", number: 23},
  {name: "Kwon", number: 42}
];

d3.selectAll("div")
  .data(data, function(d) { return d ? d.name : this.id; })
    .text(d => d.number);This example key function uses the datum d if present, and otherwise falls back to the element’s id property. Since these elements were not previously bound to data, the datum d is null when the key function is evaluated on selected elements, and non-null when the key function is evaluated on the new data.The update and enter selections are returned in data order, while the exit selection preserves the selection order prior to the join. If a key function is specified, the order of elements in the selection may not match their order in the document; use selection.order or selection.sort as needed. For more on how the key function affects the join, see A Bar Chart, Part 2 and Object Constancy.If data is not specified, this method returns the array of data for the selected elements.This method cannot be used to clear bound data; use selection.datum instead.selection.join(enter, update, exit) ​Source · Appends, removes and reorders elements as necessary to match the data that was previously bound by selection.data, returning the merged enter and update selection. This method is a convenient alternative to the explicit general update pattern, replacing selection.enter, selection.exit, selection.append, selection.remove, and selection.order. For example:jssvg.selectAll("circle")
  .data(data)
  .join("circle")
    .attr("fill", "none")
    .attr("stroke", "black");The enter function may be specified as a string shorthand, as above, which is equivalent to selection.append with the given element name. Likewise, optional update and exit functions may be specified, which default to the identity function and calling selection.remove, respectively. The shorthand above is thus equivalent to:jssvg.selectAll("circle")
  .data(data)
  .join(
    enter => enter.append("circle"),
    update => update,
    exit => exit.remove()
  )
    .attr("fill", "none")
    .attr("stroke", "black");By passing separate functions on enter, update and exit, you have greater control over what happens. And by specifying a key function to selection.data, you can minimize changes to the DOM to optimize performance. For example, to set different fill colors for enter and update:jssvg.selectAll("circle")
  .data(data)
  .join(
    enter => enter.append("circle").attr("fill", "green"),
    update => update.attr("fill", "blue")
  )
    .attr("stroke", "black");The selections returned by the enter and update functions are merged and then returned by selection.join.You can animate enter, update and exit by creating transitions inside the enter, update and exit functions. If the enter and update functions return transitions, their underlying selections are merged and then returned by selection.join. The return value of the exit function is not used.For more, see the selection.join notebook.selection.enter() ​Source · Returns the enter selection: placeholder nodes for each datum that had no corresponding DOM element in the selection. (The enter selection is empty for selections not returned by selection.data.)The enter selection is typically used to create “missing” elements corresponding to new data. For example, to create DIV elements from an array of numbers:jsconst div = d3.select("body")
  .selectAll("div")
  .data([4, 8, 15, 16, 23, 42])
  .enter().append("div")
    .text(d => d);If the body is initially empty, the above code will create six new DIV elements, append them to the body in-order, and assign their text content as the associated (string-coerced) number:html<div>4</div>
<div>8</div>
<div>15</div>
<div>16</div>
<div>23</div>
<div>42</div>Conceptually, the enter selection’s placeholders are pointers to the parent element (in this example, the document body). The enter selection is typically only used transiently to append elements, and is often merged with the update selection after appending, such that modifications can be applied to both entering and updating elements.selection.exit() ​Source · Returns the exit selection: existing DOM elements in the selection for which no new datum was found. (The exit selection is empty for selections not returned by selection.data.)The exit selection is typically used to remove “superfluous” elements corresponding to old data. For example, to update the DIV elements created previously with a new array of numbers:jsdiv = div.data([1, 2, 4, 8, 16, 32], d => d);Since a key function was specified (as the identity function), and the new data contains the numbers [4, 8, 16] which match existing elements in the document, the update selection contains three DIV elements. Leaving those elements as-is, we can append new elements for [1, 2, 32] using the enter selection:jsdiv.enter().append("div").text(d => d);Likewise, to remove the exiting elements [15, 23, 42]:jsdiv.exit().remove();Now the document body looks like this:html<div>1</div>
<div>2</div>
<div>4</div>
<div>8</div>
<div>16</div>
<div>32</div>The order of the DOM elements matches the order of the data because the old data’s order and the new data’s order were consistent. If the new data’s order is different, use selection.order to reorder the elements in the DOM. See the general update pattern notebook for more on data joins.selection.datum(value) ​Source · Gets or sets the bound data for each selected element. Unlike selection.data, this method does not compute a join and does not affect indexes or the enter and exit selections.If a value is specified, sets the element’s bound data to the specified value on all selected elements. If the value is a constant, all elements are given the same datum; otherwise, if the value is a function, it is evaluated for each selected element, in order, being passed the current datum (d), the current index (i), and the current group (nodes), with this as the current DOM element (nodes[i]). The function is then used to set each element’s new data. A null value will delete the bound data.If a value is not specified, returns the bound datum for the first (non-null) element in the selection. This is generally useful only if you know the selection contains exactly one element.This method is useful for accessing HTML5 custom data attributes. For example, given the following elements:html<ul id="list">
  <li data-username="shawnbot">Shawn Allen</li>
  <li data-username="mbostock">Mike Bostock</li>
</ul>You can expose the custom data attributes by setting each element’s data as the built-in dataset property:jsselection.datum(function() { return this.dataset; })selection.merge(other) ​Source · Returns a new selection merging this selection with the specified other selection or transition. The returned selection has the same number of groups and the same parents as this selection. Any missing (null) elements in this selection are filled with the corresponding element, if present (not null), from the specified selection. (If the other selection has additional groups or parents, they are ignored.)This method is used internally by selection.join to merge the enter and update selections after binding data. You can also merge explicitly, although note that since merging is based on element index, you should use operations that preserve index, such as selection.select instead of selection.filter. For example:jsconst odd = selection.select(function(d, i) { return i & 1 ? this : null; ));
const even = selection.select(function(d, i) { return i & 1 ? null : this; ));
const merged = odd.merge(even);See selection.data for more.This method is not intended for concatenating arbitrary selections, however: if both this selection and the specified other selection have (non-null) elements at the same index, this selection’s element is returned in the merge and the other selection’s element is ignored.PagerPrevious pageModifying elementsNext pageHandling events\n\nJoining data ​For an introduction, see Thinking With Joins and the selection.join notebook.selection.data(data, key) ​Source · Binds the specified array of data with the selected elements, returning a new selection that represents the update selection: the elements successfully bound to data. Also defines the enter and exit selections on the returned selection, which can be used to add or remove elements to correspond to the new data. The specified data is an array of arbitrary values (e.g., numbers or objects), or a function that returns an array of values for each group. When data is assigned to an element, it is stored in the property __data__, thus making the data “sticky” and available on re-selection.The data is specified for each group in the selection. If the selection has multiple groups (such as d3.selectAll followed by selection.selectAll), then data should typically be specified as a function. This function will be evaluated for each group in order, being passed the group’s parent datum (d, which may be undefined), the group index (i), and the selection’s parent nodes (nodes), with this as the group’s parent element.In conjunction with selection.join (or more explicitly with selection.enter, selection.exit, selection.append and selection.remove), selection.data can be used to enter, update and exit elements to match data. For example, to create an HTML table from a matrix of numbers:jsconst matrix = [
  [11975,  5871, 8916, 2868],
  [ 1951, 10048, 2060, 6171],
  [ 8010, 16145, 8090, 8045],
  [ 1013,   990,  940, 6907]
];

d3.select("body")
  .append("table")
  .selectAll("tr")
  .data(matrix)
  .join("tr")
  .selectAll("td")
  .data(d => d)
  .join("td")
    .text(d => d);In this example the data function is the identity function: for each table row, it returns the corresponding row from the data matrix.If a key function is not specified, then the first datum in data is assigned to the first selected element, the second datum to the second selected element, and so on. A key function may be specified to control which datum is assigned to which element, replacing the default join-by-index, by computing a string identifier for each datum and element. This key function is evaluated for each selected element, in order, being passed the current datum (d), the current index (i), and the current group (nodes), with this as the current DOM element (nodes[i]); the returned string is the element’s key. The key function is then also evaluated for each new datum in data, being passed the current datum (d), the current index (i), and the group’s new data, with this as the group’s parent DOM element; the returned string is the datum’s key. The datum for a given key is assigned to the element with the matching key. If multiple elements have the same key, the duplicate elements are put into the exit selection; if multiple data have the same key, the duplicate data are put into the enter selection.For example, given this document:html<div id="Ford"></div>
<div id="Jarrah"></div>
<div id="Kwon"></div>
<div id="Locke"></div>
<div id="Reyes"></div>
<div id="Shephard"></div>You could join data by key as follows:jsconst data = [
  {name: "Locke", number: 4},
  {name: "Reyes", number: 8},
  {name: "Ford", number: 15},
  {name: "Jarrah", number: 16},
  {name: "Shephard", number: 23},
  {name: "Kwon", number: 42}
];

d3.selectAll("div")
  .data(data, function(d) { return d ? d.name : this.id; })
    .text(d => d.number);This example key function uses the datum d if present, and otherwise falls back to the element’s id property. Since these elements were not previously bound to data, the datum d is null when the key function is evaluated on selected elements, and non-null when the key function is evaluated on the new data.The update and enter selections are returned in data order, while the exit selection preserves the selection order prior to the join. If a key function is specified, the order of elements in the selection may not match their order in the document; use selection.order or selection.sort as needed. For more on how the key function affects the join, see A Bar Chart, Part 2 and Object Constancy.If data is not specified, this method returns the array of data for the selected elements.This method cannot be used to clear bound data; use selection.datum instead.selection.join(enter, update, exit) ​Source · Appends, removes and reorders elements as necessary to match the data that was previously bound by selection.data, returning the merged enter and update selection. This method is a convenient alternative to the explicit general update pattern, replacing selection.enter, selection.exit, selection.append, selection.remove, and selection.order. For example:jssvg.selectAll("circle")
  .data(data)
  .join("circle")
    .attr("fill", "none")
    .attr("stroke", "black");The enter function may be specified as a string shorthand, as above, which is equivalent to selection.append with the given element name. Likewise, optional update and exit functions may be specified, which default to the identity function and calling selection.remove, respectively. The shorthand above is thus equivalent to:jssvg.selectAll("circle")
  .data(data)
  .join(
    enter => enter.append("circle"),
    update => update,
    exit => exit.remove()
  )
    .attr("fill", "none")
    .attr("stroke", "black");By passing separate functions on enter, update and exit, you have greater control over what happens. And by specifying a key function to selection.data, you can minimize changes to the DOM to optimize performance. For example, to set different fill colors for enter and update:jssvg.selectAll("circle")
  .data(data)
  .join(
    enter => enter.append("circle").attr("fill", "green"),
    update => update.attr("fill", "blue")
  )
    .attr("stroke", "black");The selections returned by the enter and update functions are merged and then returned by selection.join.You can animate enter, update and exit by creating transitions inside the enter, update and exit functions. If the enter and update functions return transitions, their underlying selections are merged and then returned by selection.join. The return value of the exit function is not used.For more, see the selection.join notebook.selection.enter() ​Source · Returns the enter selection: placeholder nodes for each datum that had no corresponding DOM element in the selection. (The enter selection is empty for selections not returned by selection.data.)The enter selection is typically used to create “missing” elements corresponding to new data. For example, to create DIV elements from an array of numbers:jsconst div = d3.select("body")
  .selectAll("div")
  .data([4, 8, 15, 16, 23, 42])
  .enter().append("div")
    .text(d => d);If the body is initially empty, the above code will create six new DIV elements, append them to the body in-order, and assign their text content as the associated (string-coerced) number:html<div>4</div>
<div>8</div>
<div>15</div>
<div>16</div>
<div>23</div>
<div>42</div>Conceptually, the enter selection’s placeholders are pointers to the parent element (in this example, the document body). The enter selection is typically only used transiently to append elements, and is often merged with the update selection after appending, such that modifications can be applied to both entering and updating elements.selection.exit() ​Source · Returns the exit selection: existing DOM elements in the selection for which no new datum was found. (The exit selection is empty for selections not returned by selection.data.)The exit selection is typically used to remove “superfluous” elements corresponding to old data. For example, to update the DIV elements created previously with a new array of numbers:jsdiv = div.data([1, 2, 4, 8, 16, 32], d => d);Since a key function was specified (as the identity function), and the new data contains the numbers [4, 8, 16] which match existing elements in the document, the update selection contains three DIV elements. Leaving those elements as-is, we can append new elements for [1, 2, 32] using the enter selection:jsdiv.enter().append("div").text(d => d);Likewise, to remove the exiting elements [15, 23, 42]:jsdiv.exit().remove();Now the document body looks like this:html<div>1</div>
<div>2</div>
<div>4</div>
<div>8</div>
<div>16</div>
<div>32</div>The order of the DOM elements matches the order of the data because the old data’s order and the new data’s order were consistent. If the new data’s order is different, use selection.order to reorder the elements in the DOM. See the general update pattern notebook for more on data joins.selection.datum(value) ​Source · Gets or sets the bound data for each selected element. Unlike selection.data, this method does not compute a join and does not affect indexes or the enter and exit selections.If a value is specified, sets the element’s bound data to the specified value on all selected elements. If the value is a constant, all elements are given the same datum; otherwise, if the value is a function, it is evaluated for each selected element, in order, being passed the current datum (d), the current index (i), and the current group (nodes), with this as the current DOM element (nodes[i]). The function is then used to set each element’s new data. A null value will delete the bound data.If a value is not specified, returns the bound datum for the first (non-null) element in the selection. This is generally useful only if you know the selection contains exactly one element.This method is useful for accessing HTML5 custom data attributes. For example, given the following elements:html<ul id="list">
  <li data-username="shawnbot">Shawn Allen</li>
  <li data-username="mbostock">Mike Bostock</li>
</ul>You can expose the custom data attributes by setting each element’s data as the built-in dataset property:jsselection.datum(function() { return this.dataset; })selection.merge(other) ​Source · Returns a new selection merging this selection with the specified other selection or transition. The returned selection has the same number of groups and the same parents as this selection. Any missing (null) elements in this selection are filled with the corresponding element, if present (not null), from the specified selection. (If the other selection has additional groups or parents, they are ignored.)This method is used internally by selection.join to merge the enter and update selections after binding data. You can also merge explicitly, although note that since merging is based on element index, you should use operations that preserve index, such as selection.select instead of selection.filter. For example:jsconst odd = selection.select(function(d, i) { return i & 1 ? this : null; ));
const even = selection.select(function(d, i) { return i & 1 ? null : this; ));
const merged = odd.merge(even);See selection.data for more.This method is not intended for concatenating arbitrary selections, however: if both this selection and the specified other selection have (non-null) elements at the same index, this selection’s element is returned in the merge and the other selection’s element is ignored.\n\n\n\nHandling events ​For interaction, selections allow listening for and dispatching of events.selection.on(typenames, listener, options) ​Source · Adds or removes a listener to each selected element for the specified event typenames.jsd3.selectAll("p").on("click", (event) => console.log(event))The typenames is a string event type, such as click, mouseover, or submit; any DOM event type supported by your browser may be used. The type may be optionally followed by a period (.) and a name; the optional name allows multiple callbacks to be registered to receive events of the same type, such as click.foo and click.bar. To specify multiple typenames, separate typenames with spaces, such as input change or click.foo click.bar.When a specified event is dispatched on a selected element, the specified listener will be evaluated for the element, being passed the current event (event) and the current datum (d), with this as the current DOM element (event.currentTarget). Listeners always see the latest datum for their element. Note: while you can use event.pageX and event.pageY directly, it is often convenient to transform the event position to the local coordinate system of the element that received the event using d3.pointer.If an event listener was previously registered for the same typename on a selected element, the old listener is removed before the new listener is added. To remove a listener, pass null as the listener. To remove all listeners for a given name, pass null as the listener and .foo as the typename, where foo is the name; to remove all listeners with no name, specify . as the typename.An optional options object may specify characteristics about the event listener, such as whether it is capturing or passive; see element.addEventListener.If a listener is not specified, returns the currently-assigned listener for the specified event typename on the first (non-null) selected element, if any. If multiple typenames are specified, the first matching listener is returned.selection.dispatch(type, parameters) ​Source · Dispatches a custom event of the specified type to each selected element, in order.jsd3.select("p").dispatch("click")An optional parameters object may be specified to set additional properties of the event. It may contain the following fields:bubbles - if true, the event is dispatched to ancestors in reverse tree order.cancelable - if true, event.preventDefault is allowed.detail - any custom data associated with the event.If parameters is a function, it is evaluated for each selected element, in order, being passed the current datum (d), the current index (i), and the current group (nodes), with this as the current DOM element (nodes[i]). It must return the parameters for the current element.pointer(event, target) ​Source · Returns a two-element array of numbers [x, y] representing the coordinates of the specified event relative to the specified target.jsconst [x, y] = d3.pointer(event);event can be a MouseEvent, a PointerEvent, a Touch, or a custom event holding a UIEvent as event.sourceEvent.If target is not specified, it defaults to the source event’s currentTarget property, if available. If the target is an SVG element, the event’s coordinates are transformed using the inverse of the screen coordinate transformation matrix. If the target is an HTML element, the event’s coordinates are translated relative to the top-left corner of the target’s bounding client rectangle. (As such, the coordinate system can only be translated relative to the client coordinates. See also GeometryUtils.) Otherwise, [event.pageX, event.pageY] is returned.pointers(event, target) ​Source · Returns an array [[x0, y0], [x1, y1]…] of coordinates of the specified event’s pointer locations relative to the specified target.jsconst points = d3.pointers(event);For touch events, the returned array of positions corresponds to the event.touches array; for other events, returns a single-element array.If target is not specified, it defaults to the source event’s currentTarget property, if any.\n\nSearchK7.9.0GitHub️ 110.0kOn this pageHandling events ​For interaction, selections allow listening for and dispatching of events.selection.on(typenames, listener, options) ​Source · Adds or removes a listener to each selected element for the specified event typenames.jsd3.selectAll("p").on("click", (event) => console.log(event))The typenames is a string event type, such as click, mouseover, or submit; any DOM event type supported by your browser may be used. The type may be optionally followed by a period (.) and a name; the optional name allows multiple callbacks to be registered to receive events of the same type, such as click.foo and click.bar. To specify multiple typenames, separate typenames with spaces, such as input change or click.foo click.bar.When a specified event is dispatched on a selected element, the specified listener will be evaluated for the element, being passed the current event (event) and the current datum (d), with this as the current DOM element (event.currentTarget). Listeners always see the latest datum for their element. Note: while you can use event.pageX and event.pageY directly, it is often convenient to transform the event position to the local coordinate system of the element that received the event using d3.pointer.If an event listener was previously registered for the same typename on a selected element, the old listener is removed before the new listener is added. To remove a listener, pass null as the listener. To remove all listeners for a given name, pass null as the listener and .foo as the typename, where foo is the name; to remove all listeners with no name, specify . as the typename.An optional options object may specify characteristics about the event listener, such as whether it is capturing or passive; see element.addEventListener.If a listener is not specified, returns the currently-assigned listener for the specified event typename on the first (non-null) selected element, if any. If multiple typenames are specified, the first matching listener is returned.selection.dispatch(type, parameters) ​Source · Dispatches a custom event of the specified type to each selected element, in order.jsd3.select("p").dispatch("click")An optional parameters object may be specified to set additional properties of the event. It may contain the following fields:bubbles - if true, the event is dispatched to ancestors in reverse tree order.cancelable - if true, event.preventDefault is allowed.detail - any custom data associated with the event.If parameters is a function, it is evaluated for each selected element, in order, being passed the current datum (d), the current index (i), and the current group (nodes), with this as the current DOM element (nodes[i]). It must return the parameters for the current element.pointer(event, target) ​Source · Returns a two-element array of numbers [x, y] representing the coordinates of the specified event relative to the specified target.jsconst [x, y] = d3.pointer(event);event can be a MouseEvent, a PointerEvent, a Touch, or a custom event holding a UIEvent as event.sourceEvent.If target is not specified, it defaults to the source event’s currentTarget property, if available. If the target is an SVG element, the event’s coordinates are transformed using the inverse of the screen coordinate transformation matrix. If the target is an HTML element, the event’s coordinates are translated relative to the top-left corner of the target’s bounding client rectangle. (As such, the coordinate system can only be translated relative to the client coordinates. See also GeometryUtils.) Otherwise, [event.pageX, event.pageY] is returned.pointers(event, target) ​Source · Returns an array [[x0, y0], [x1, y1]…] of coordinates of the specified event’s pointer locations relative to the specified target.jsconst points = d3.pointers(event);For touch events, the returned array of positions corresponds to the event.touches array; for other events, returns a single-element array.If target is not specified, it defaults to the source event’s currentTarget property, if any.PagerPrevious pageJoining dataNext pageControl flow\n\nHandling events ​For interaction, selections allow listening for and dispatching of events.selection.on(typenames, listener, options) ​Source · Adds or removes a listener to each selected element for the specified event typenames.jsd3.selectAll("p").on("click", (event) => console.log(event))The typenames is a string event type, such as click, mouseover, or submit; any DOM event type supported by your browser may be used. The type may be optionally followed by a period (.) and a name; the optional name allows multiple callbacks to be registered to receive events of the same type, such as click.foo and click.bar. To specify multiple typenames, separate typenames with spaces, such as input change or click.foo click.bar.When a specified event is dispatched on a selected element, the specified listener will be evaluated for the element, being passed the current event (event) and the current datum (d), with this as the current DOM element (event.currentTarget). Listeners always see the latest datum for their element. Note: while you can use event.pageX and event.pageY directly, it is often convenient to transform the event position to the local coordinate system of the element that received the event using d3.pointer.If an event listener was previously registered for the same typename on a selected element, the old listener is removed before the new listener is added. To remove a listener, pass null as the listener. To remove all listeners for a given name, pass null as the listener and .foo as the typename, where foo is the name; to remove all listeners with no name, specify . as the typename.An optional options object may specify characteristics about the event listener, such as whether it is capturing or passive; see element.addEventListener.If a listener is not specified, returns the currently-assigned listener for the specified event typename on the first (non-null) selected element, if any. If multiple typenames are specified, the first matching listener is returned.selection.dispatch(type, parameters) ​Source · Dispatches a custom event of the specified type to each selected element, in order.jsd3.select("p").dispatch("click")An optional parameters object may be specified to set additional properties of the event. It may contain the following fields:bubbles - if true, the event is dispatched to ancestors in reverse tree order.cancelable - if true, event.preventDefault is allowed.detail - any custom data associated with the event.If parameters is a function, it is evaluated for each selected element, in order, being passed the current datum (d), the current index (i), and the current group (nodes), with this as the current DOM element (nodes[i]). It must return the parameters for the current element.pointer(event, target) ​Source · Returns a two-element array of numbers [x, y] representing the coordinates of the specified event relative to the specified target.jsconst [x, y] = d3.pointer(event);event can be a MouseEvent, a PointerEvent, a Touch, or a custom event holding a UIEvent as event.sourceEvent.If target is not specified, it defaults to the source event’s currentTarget property, if available. If the target is an SVG element, the event’s coordinates are transformed using the inverse of the screen coordinate transformation matrix. If the target is an HTML element, the event’s coordinates are translated relative to the top-left corner of the target’s bounding client rectangle. (As such, the coordinate system can only be translated relative to the client coordinates. See also GeometryUtils.) Otherwise, [event.pageX, event.pageY] is returned.pointers(event, target) ​Source · Returns an array [[x0, y0], [x1, y1]…] of coordinates of the specified event’s pointer locations relative to the specified target.jsconst points = d3.pointers(event);For touch events, the returned array of positions corresponds to the event.touches array; for other events, returns a single-element array.If target is not specified, it defaults to the source event’s currentTarget property, if any.\n\n\n\nControl flow ​For advanced usage, selections provide methods for custom control flow.selection.each(function) ​Source · Invokes the specified function for each selected element, in order, being passed the current datum (d), the current index (i), and the current group (nodes), with this as the current DOM element (nodes[i]). This method can be used to invoke arbitrary code for each selected element, and is useful for creating a context to access parent and child data simultaneously, such as:jsparent.each(function(p, j) {
  d3.select(this)
    .selectAll(".child")
      .text(d => `child ${d.name} of ${p.name}`);
});See sized donut multiples for an example.selection.call(function, ...arguments) ​Source · Invokes the specified function exactly once, passing in this selection along with any optional arguments. Returns this selection. This is equivalent to invoking the function by hand but facilitates method chaining. For example, to set several styles in a reusable function:jsfunction name(selection, first, last) {
  selection
      .attr("first-name", first)
      .attr("last-name", last);
}Now say:jsd3.selectAll("div").call(name, "John", "Snow");This is roughly equivalent to:jsname(d3.selectAll("div"), "John", "Snow");The only difference is that selection.call always returns the selection and not the return value of the called function, name.selection.empty() ​Source · Returns true if this selection contains no (non-null) elements.jsd3.selectAll("p").empty() // false, hereselection.nodes() ​Source · Returns an array of all (non-null) elements in this selection.jsd3.selectAll("p").nodes() // [p, p, p, …]Equivalent to:jsArray.from(selection)selection[Symbol.iterator]() ​Source · Returns an iterator over the selected (non-null) elements. For example, to iterate over the selected elements:jsfor (const element of selection) {
  console.log(element);
}To flatten the selection to an array:jsconst elements = [...selection];selection.node() ​Source · Returns the first (non-null) element in this selection. If the selection is empty, returns null.selection.size() ​Source · Returns the total number of (non-null) elements in this selection.\n\nSearchK7.9.0GitHub️ 110.0kOn this pageControl flow ​For advanced usage, selections provide methods for custom control flow.selection.each(function) ​Source · Invokes the specified function for each selected element, in order, being passed the current datum (d), the current index (i), and the current group (nodes), with this as the current DOM element (nodes[i]). This method can be used to invoke arbitrary code for each selected element, and is useful for creating a context to access parent and child data simultaneously, such as:jsparent.each(function(p, j) {
  d3.select(this)
    .selectAll(".child")
      .text(d => `child ${d.name} of ${p.name}`);
});See sized donut multiples for an example.selection.call(function, ...arguments) ​Source · Invokes the specified function exactly once, passing in this selection along with any optional arguments. Returns this selection. This is equivalent to invoking the function by hand but facilitates method chaining. For example, to set several styles in a reusable function:jsfunction name(selection, first, last) {
  selection
      .attr("first-name", first)
      .attr("last-name", last);
}Now say:jsd3.selectAll("div").call(name, "John", "Snow");This is roughly equivalent to:jsname(d3.selectAll("div"), "John", "Snow");The only difference is that selection.call always returns the selection and not the return value of the called function, name.selection.empty() ​Source · Returns true if this selection contains no (non-null) elements.jsd3.selectAll("p").empty() // false, hereselection.nodes() ​Source · Returns an array of all (non-null) elements in this selection.jsd3.selectAll("p").nodes() // [p, p, p, …]Equivalent to:jsArray.from(selection)selection[Symbol.iterator]() ​Source · Returns an iterator over the selected (non-null) elements. For example, to iterate over the selected elements:jsfor (const element of selection) {
  console.log(element);
}To flatten the selection to an array:jsconst elements = [...selection];selection.node() ​Source · Returns the first (non-null) element in this selection. If the selection is empty, returns null.selection.size() ​Source · Returns the total number of (non-null) elements in this selection.PagerPrevious pageHandling eventsNext pageLocal variables\n\nControl flow ​For advanced usage, selections provide methods for custom control flow.selection.each(function) ​Source · Invokes the specified function for each selected element, in order, being passed the current datum (d), the current index (i), and the current group (nodes), with this as the current DOM element (nodes[i]). This method can be used to invoke arbitrary code for each selected element, and is useful for creating a context to access parent and child data simultaneously, such as:jsparent.each(function(p, j) {
  d3.select(this)
    .selectAll(".child")
      .text(d => `child ${d.name} of ${p.name}`);
});See sized donut multiples for an example.selection.call(function, ...arguments) ​Source · Invokes the specified function exactly once, passing in this selection along with any optional arguments. Returns this selection. This is equivalent to invoking the function by hand but facilitates method chaining. For example, to set several styles in a reusable function:jsfunction name(selection, first, last) {
  selection
      .attr("first-name", first)
      .attr("last-name", last);
}Now say:jsd3.selectAll("div").call(name, "John", "Snow");This is roughly equivalent to:jsname(d3.selectAll("div"), "John", "Snow");The only difference is that selection.call always returns the selection and not the return value of the called function, name.selection.empty() ​Source · Returns true if this selection contains no (non-null) elements.jsd3.selectAll("p").empty() // false, hereselection.nodes() ​Source · Returns an array of all (non-null) elements in this selection.jsd3.selectAll("p").nodes() // [p, p, p, …]Equivalent to:jsArray.from(selection)selection[Symbol.iterator]() ​Source · Returns an iterator over the selected (non-null) elements. For example, to iterate over the selected elements:jsfor (const element of selection) {
  console.log(element);
}To flatten the selection to an array:jsconst elements = [...selection];selection.node() ​Source · Returns the first (non-null) element in this selection. If the selection is empty, returns null.selection.size() ​Source · Returns the total number of (non-null) elements in this selection.\n\n\n\nLocal variables ​D3 locals allow you to define local state independent of data. For instance, when rendering small multiples of time-series data, you might want the same x scale for all charts but distinct y scales to compare the relative performance of each metric. D3 locals are scoped by DOM elements: on set, the value is stored on the given element; on get, the value is retrieved from given element or the nearest ancestor that defines it.CAUTIONLocals are rarely used; you may find it easier to store whatever state you need in the selection’s data.local() ​Source · Declares a new local variable.jsconst foo = d3.local();Like var, each local is a distinct symbolic reference; unlike var, the value of each local is also scoped by the DOM.local.set(node, value) ​Source · Sets the value of this local on the specified node to the value, and returns the specified value. This is often performed using selection.each:jsselection.each(function(d) {
  foo.set(this, d.value);
});If you are just setting a single variable, consider using selection.property:jsselection.property(foo, (d) => d.value);local.get(node) ​Source · Returns the value of this local on the specified node.jsselection.each(function() {
  const value = foo.get(this);
});If the node does not define this local, returns the value from the nearest ancestor that defines it. Returns undefined if no ancestor defines this local.local.remove(node) ​Source · Deletes this local’s value from the specified node.jsselection.each(function() {
  foo.remove(this);
});Returns true if the node defined this local prior to removal, and false otherwise. If ancestors also define this local, those definitions are unaffected, and thus local.get will still return the inherited value.local.toString() ​Source · Returns the automatically-generated identifier for this local. This is the name of the property that is used to store the local’s value on elements, and thus you can also set or get the local’s value using element[local] or by using selection.property.\n\nSearchK7.9.0GitHub️ 110.0kOn this pageLocal variables ​D3 locals allow you to define local state independent of data. For instance, when rendering small multiples of time-series data, you might want the same x scale for all charts but distinct y scales to compare the relative performance of each metric. D3 locals are scoped by DOM elements: on set, the value is stored on the given element; on get, the value is retrieved from given element or the nearest ancestor that defines it.CAUTIONLocals are rarely used; you may find it easier to store whatever state you need in the selection’s data.local() ​Source · Declares a new local variable.jsconst foo = d3.local();Like var, each local is a distinct symbolic reference; unlike var, the value of each local is also scoped by the DOM.local.set(node, value) ​Source · Sets the value of this local on the specified node to the value, and returns the specified value. This is often performed using selection.each:jsselection.each(function(d) {
  foo.set(this, d.value);
});If you are just setting a single variable, consider using selection.property:jsselection.property(foo, (d) => d.value);local.get(node) ​Source · Returns the value of this local on the specified node.jsselection.each(function() {
  const value = foo.get(this);
});If the node does not define this local, returns the value from the nearest ancestor that defines it. Returns undefined if no ancestor defines this local.local.remove(node) ​Source · Deletes this local’s value from the specified node.jsselection.each(function() {
  foo.remove(this);
});Returns true if the node defined this local prior to removal, and false otherwise. If ancestors also define this local, those definitions are unaffected, and thus local.get will still return the inherited value.local.toString() ​Source · Returns the automatically-generated identifier for this local. This is the name of the property that is used to store the local’s value on elements, and thus you can also set or get the local’s value using element[local] or by using selection.property.PagerPrevious pageControl flowNext pageNamespaces\n\nLocal variables ​D3 locals allow you to define local state independent of data. For instance, when rendering small multiples of time-series data, you might want the same x scale for all charts but distinct y scales to compare the relative performance of each metric. D3 locals are scoped by DOM elements: on set, the value is stored on the given element; on get, the value is retrieved from given element or the nearest ancestor that defines it.CAUTIONLocals are rarely used; you may find it easier to store whatever state you need in the selection’s data.local() ​Source · Declares a new local variable.jsconst foo = d3.local();Like var, each local is a distinct symbolic reference; unlike var, the value of each local is also scoped by the DOM.local.set(node, value) ​Source · Sets the value of this local on the specified node to the value, and returns the specified value. This is often performed using selection.each:jsselection.each(function(d) {
  foo.set(this, d.value);
});If you are just setting a single variable, consider using selection.property:jsselection.property(foo, (d) => d.value);local.get(node) ​Source · Returns the value of this local on the specified node.jsselection.each(function() {
  const value = foo.get(this);
});If the node does not define this local, returns the value from the nearest ancestor that defines it. Returns undefined if no ancestor defines this local.local.remove(node) ​Source · Deletes this local’s value from the specified node.jsselection.each(function() {
  foo.remove(this);
});Returns true if the node defined this local prior to removal, and false otherwise. If ancestors also define this local, those definitions are unaffected, and thus local.get will still return the inherited value.local.toString() ​Source · Returns the automatically-generated identifier for this local. This is the name of the property that is used to store the local’s value on elements, and thus you can also set or get the local’s value using element[local] or by using selection.property.\n\n\n\nNamespaces ​XML namespaces are fun! Right? 🤪 Fortunately you can mostly ignore them.A case where you need to specify them is when appending an element to a parent that belongs to a different namespace; typically, to create a div inside a SVG foreignObject element:jsd3.create("svg")
  .append("foreignObject")
    .attr("width", 300)
    .attr("height", 100)
  .append("xhtml:div")
    .text("Hello, HTML!");namespace(name) ​Source · Qualifies the specified name, which may or may not have a namespace prefix.jsd3.namespace("svg:text") // {space: "http://www.w3.org/2000/svg", local: "text"}If the name contains a colon (:), the substring before the colon is interpreted as the namespace prefix, which must be registered in d3.namespaces. Returns an object space and local attributes describing the full namespace URL and the local name. If the name does not contain a colon, this function merely returns the input name.namespaces ​Source · The map of registered namespace prefixes. The initial value is:js{
  svg: "http://www.w3.org/2000/svg",
  xhtml: "http://www.w3.org/1999/xhtml",
  xlink: "http://www.w3.org/1999/xlink",
  xml: "http://www.w3.org/XML/1998/namespace",
  xmlns: "http://www.w3.org/2000/xmlns/"
}Additional prefixes may be assigned as needed to create elements or attributes in other namespaces.\n\nSearchK7.9.0GitHub️ 110.0kOn this pageNamespaces ​XML namespaces are fun! Right? 🤪 Fortunately you can mostly ignore them.A case where you need to specify them is when appending an element to a parent that belongs to a different namespace; typically, to create a div inside a SVG foreignObject element:jsd3.create("svg")
  .append("foreignObject")
    .attr("width", 300)
    .attr("height", 100)
  .append("xhtml:div")
    .text("Hello, HTML!");namespace(name) ​Source · Qualifies the specified name, which may or may not have a namespace prefix.jsd3.namespace("svg:text") // {space: "http://www.w3.org/2000/svg", local: "text"}If the name contains a colon (:), the substring before the colon is interpreted as the namespace prefix, which must be registered in d3.namespaces. Returns an object space and local attributes describing the full namespace URL and the local name. If the name does not contain a colon, this function merely returns the input name.namespaces ​Source · The map of registered namespace prefixes. The initial value is:js{
  svg: "http://www.w3.org/2000/svg",
  xhtml: "http://www.w3.org/1999/xhtml",
  xlink: "http://www.w3.org/1999/xlink",
  xml: "http://www.w3.org/XML/1998/namespace",
  xmlns: "http://www.w3.org/2000/xmlns/"
}Additional prefixes may be assigned as needed to create elements or attributes in other namespaces.PagerPrevious pageLocal variablesNext paged3-shape\n\nNamespaces ​XML namespaces are fun! Right? 🤪 Fortunately you can mostly ignore them.A case where you need to specify them is when appending an element to a parent that belongs to a different namespace; typically, to create a div inside a SVG foreignObject element:jsd3.create("svg")
  .append("foreignObject")
    .attr("width", 300)
    .attr("height", 100)
  .append("xhtml:div")
    .text("Hello, HTML!");namespace(name) ​Source · Qualifies the specified name, which may or may not have a namespace prefix.jsd3.namespace("svg:text") // {space: "http://www.w3.org/2000/svg", local: "text"}If the name contains a colon (:), the substring before the colon is interpreted as the namespace prefix, which must be registered in d3.namespaces. Returns an object space and local attributes describing the full namespace URL and the local name. If the name does not contain a colon, this function merely returns the input name.namespaces ​Source · The map of registered namespace prefixes. The initial value is:js{
  svg: "http://www.w3.org/2000/svg",
  xhtml: "http://www.w3.org/1999/xhtml",
  xlink: "http://www.w3.org/1999/xlink",
  xml: "http://www.w3.org/XML/1998/namespace",
  xmlns: "http://www.w3.org/2000/xmlns/"
}Additional prefixes may be assigned as needed to create elements or attributes in other namespaces.\n\n\n\nArcs ​The arc generator produces a circular or annular sector, as in a pie or donut chart. Arcs are centered at the origin; use a transform to move the arc to a different position.jssvg.append("path")
    .attr("transform", "translate(100,100)")
    .attr("d", d3.arc()({
      innerRadius: 100,
      outerRadius: 200,
      startAngle: -Math.PI / 2,
      endAngle: Math.PI / 2
    }));If the absolute difference between the start and end angles (the angular span) is greater than 2π, the arc generator will produce a complete circle or annulus. If it is less than 2π, the arc’s angular length will be equal to the absolute difference between the two angles (going clockwise if the signed difference is positive and anticlockwise if it is negative). If the absolute difference is less than 2π, the arc may have rounded corners and angular padding.See also the pie generator, which computes the necessary angles to represent an array of data as a pie or donut chart; these angles can then be passed to an arc generator.arc() ​Source · Constructs a new arc generator with the default settings. With default settings:jsconst arc = d3.arc();Or, with the radii and angles configured as constants:jsconst arc = d3.arc()
    .innerRadius(0)
    .outerRadius(100)
    .startAngle(0)
    .endAngle(Math.PI / 2);arc(...arguments) ​Source · Generates an arc for the given arguments. The arguments are arbitrary; they are propagated to the arc generator’s accessor functions along with the this object. For example, with the default settings, an object with radii and angles is expected:jsconst arc = d3.arc();

arc({
  innerRadius: 0,
  outerRadius: 100,
  startAngle: 0,
  endAngle: Math.PI / 2
}); // "M0,-100A100,100,0,0,1,100,0L0,0Z"If the radii and angles are instead defined as constants, you can generate an arc without any arguments:jsd3.arc()
    .innerRadius(0)
    .outerRadius(100)
    .startAngle(0)
    .endAngle(Math.PI / 2)
  (); // "M0,-100A100,100,0,0,1,100,0L0,0Z"If the arc generator has a context, then the arc is rendered to this context as a sequence of path method calls and this function returns void. Otherwise, a path data string is returned.arc.centroid(...arguments) ​Examples · Source · Computes the midpoint [x, y] of the center line of the arc that would be generated by the given arguments.The arguments are arbitrary; they are propagated to the arc generator’s accessor functions along with the this object. To be consistent with the generated arc, the accessors must be deterministic, i.e., return the same value given the same arguments. The midpoint is defined as (startAngle + endAngle) / 2 and (innerRadius + outerRadius) / 2. For example:Note that this is not the geometric center of the arc, which may be outside the arc; this method is merely a convenience for positioning labels.arc.innerRadius(radius) ​Source · If radius is specified, sets the inner radius to the specified function or number and returns this arc generator.jsconst arc = d3.arc().innerRadius(40);If radius is not specified, returns the current inner radius accessor.jsarc.innerRadius() // () => 40The inner radius accessor defaults to:jsfunction innerRadius(d) {
  return d.innerRadius;
}Specifying the inner radius as a function is useful for constructing a stacked polar bar chart, often in conjunction with a sqrt scale. More commonly, a constant inner radius is used for a donut or pie chart. If the outer radius is smaller than the inner radius, the inner and outer radii are swapped. A negative value is treated as zero.arc.outerRadius(radius) ​Source · If radius is specified, sets the outer radius to the specified function or number and returns this arc generator.jsconst arc = d3.arc().outerRadius(240);If radius is not specified, returns the current outer radius accessor.jsarc.outerRadius() // () => 240The outer radius accessor defaults to:jsfunction outerRadius(d) {
  return d.outerRadius;
}Specifying the outer radius as a function is useful for constructing a coxcomb or polar bar chart, often in conjunction with a sqrt scale. More commonly, a constant outer radius is used for a pie or donut chart. If the outer radius is smaller than the inner radius, the inner and outer radii are swapped. A negative value is treated as zero.arc.cornerRadius(radius) ​Corner radius:18Examples · Source · If radius is specified, sets the corner radius to the specified function or number and returns this arc generator.jsconst arc = d3.arc().cornerRadius(18);If radius is not specified, returns the current corner radius accessor.jsarc.cornerRadius() // () => 18The corner radius accessor defaults to:jsfunction cornerRadius() {
  return 0;
}If the corner radius is greater than zero, the corners of the arc are rounded using circles of the given radius. For a circular sector, the two outer corners are rounded; for an annular sector, all four corners are rounded.The corner radius may not be larger than (outerRadius - innerRadius) / 2. In addition, for arcs whose angular span is less than π, the corner radius may be reduced as two adjacent rounded corners intersect. This occurs more often with the inner corners. See the arc corners animation for illustration.arc.startAngle(angle) ​Source · If angle is specified, sets the start angle to the specified function or number and returns this arc generator.jsconst arc = d3.arc().startAngle(Math.PI / 4);If angle is not specified, returns the current start angle accessor.jsarc.startAngle() // () => 0.7853981633974483The start angle accessor defaults to:jsfunction startAngle(d) {
  return d.startAngle;
}The angle is specified in radians, with 0 at -y (12 o’clock) and positive angles proceeding clockwise. If |endAngle - startAngle| ≥ 2π, a complete circle or annulus is generated rather than a sector.arc.endAngle(angle) ​Source · If angle is specified, sets the end angle to the specified function or number and returns this arc generator.jsconst arc = d3.arc().endAngle(Math.PI);If angle is not specified, returns the current end angle accessor.jsarc.endAngle() // () => 3.141592653589793The end angle accessor defaults to:jsfunction endAngle(d) {
  return d.endAngle;
}The angle is specified in radians, with 0 at -y (12 o’clock) and positive angles proceeding clockwise. If |endAngle - startAngle| ≥ 2π, a complete circle or annulus is generated rather than a sector.arc.padAngle(angle) ​Pad angle:0.030Examples · Source · If angle is specified, sets the pad angle to the specified function or number and returns this arc generator.jsconst arc = d3.arc().padAngle(0);If angle is not specified, returns the current pad angle accessor.jsarc.padAngle() // () => 0The pad angle accessor defaults to:jsfunction padAngle() {
  return d && d.padAngle;
}The pad angle is converted to a fixed linear distance separating adjacent arcs, defined as padRadius × padAngle. This distance is subtracted equally from the start and end of the arc. If the arc forms a complete circle or annulus, as when |endAngle - startAngle| ≥ 2π, the pad angle is ignored.If the inner radius or angular span is small relative to the pad angle, it may not be possible to maintain parallel edges between adjacent arcs. In this case, the inner edge of the arc may collapse to a point, similar to a circular sector. For this reason, padding is typically only applied to annular sectors (i.e., when innerRadius is positive), as shown in this diagram:The recommended minimum inner radius when using padding is outerRadius * padAngle / sin(θ), where θ is the angular span of the smallest arc before padding. For example, if the outer radius is 200 pixels and the pad angle is 0.02 radians, a reasonable θ is 0.04 radians, and a reasonable inner radius is 100 pixels. See the arc padding animation for illustration.Often, the pad angle is not set directly on the arc generator, but is instead computed by the pie generator so as to ensure that the area of padded arcs is proportional to their value; see pie.padAngle. See the pie padding animation for illustration. If you apply a constant pad angle to the arc generator directly, it tends to subtract disproportionately from smaller arcs, introducing distortion.arc.padRadius(radius) ​Pad radius:200Source · If radius is specified, sets the pad radius to the specified function or number and returns this arc generator. If radius is not specified, returns the current pad radius accessor, which defaults to null, indicating that the pad radius should be automatically computed as sqrt(innerRadius × innerRadius + outerRadius × outerRadius). The pad radius determines the fixed linear distance separating adjacent arcs, defined as padRadius × padAngle.arc.context(context) ​Source · If context is specified, sets the context and returns this arc generator.jsconst context = canvas.getContext("2d");
const arc = d3.arc().context(context);If context is not specified, returns the current context, which defaults to null.jsarc.context() // contextIf the context is not null, then the generated arc is rendered to this context as a sequence of path method calls. Otherwise, a path data string representing the generated arc is returned.arc.digits(digits) ​Source · If digits is specified, sets the maximum number of digits after the decimal separator and returns this arc generator.jsconst arc = d3.arc().digits(3);If digits is not specified, returns the current maximum fraction digits, which defaults to 3.jsarc.digits() // 3This option only applies when the associated context is null, as when this arc generator is used to produce path data.\n\nSearchK7.9.0GitHub️ 110.0kOn this pageArcs ​The arc generator produces a circular or annular sector, as in a pie or donut chart. Arcs are centered at the origin; use a transform to move the arc to a different position.jssvg.append("path")
    .attr("transform", "translate(100,100)")
    .attr("d", d3.arc()({
      innerRadius: 100,
      outerRadius: 200,
      startAngle: -Math.PI / 2,
      endAngle: Math.PI / 2
    }));If the absolute difference between the start and end angles (the angular span) is greater than 2π, the arc generator will produce a complete circle or annulus. If it is less than 2π, the arc’s angular length will be equal to the absolute difference between the two angles (going clockwise if the signed difference is positive and anticlockwise if it is negative). If the absolute difference is less than 2π, the arc may have rounded corners and angular padding.See also the pie generator, which computes the necessary angles to represent an array of data as a pie or donut chart; these angles can then be passed to an arc generator.arc() ​Source · Constructs a new arc generator with the default settings. With default settings:jsconst arc = d3.arc();Or, with the radii and angles configured as constants:jsconst arc = d3.arc()
    .innerRadius(0)
    .outerRadius(100)
    .startAngle(0)
    .endAngle(Math.PI / 2);arc(...arguments) ​Source · Generates an arc for the given arguments. The arguments are arbitrary; they are propagated to the arc generator’s accessor functions along with the this object. For example, with the default settings, an object with radii and angles is expected:jsconst arc = d3.arc();

arc({
  innerRadius: 0,
  outerRadius: 100,
  startAngle: 0,
  endAngle: Math.PI / 2
}); // "M0,-100A100,100,0,0,1,100,0L0,0Z"If the radii and angles are instead defined as constants, you can generate an arc without any arguments:jsd3.arc()
    .innerRadius(0)
    .outerRadius(100)
    .startAngle(0)
    .endAngle(Math.PI / 2)
  (); // "M0,-100A100,100,0,0,1,100,0L0,0Z"If the arc generator has a context, then the arc is rendered to this context as a sequence of path method calls and this function returns void. Otherwise, a path data string is returned.arc.centroid(...arguments) ​Examples · Source · Computes the midpoint [x, y] of the center line of the arc that would be generated by the given arguments.The arguments are arbitrary; they are propagated to the arc generator’s accessor functions along with the this object. To be consistent with the generated arc, the accessors must be deterministic, i.e., return the same value given the same arguments. The midpoint is defined as (startAngle + endAngle) / 2 and (innerRadius + outerRadius) / 2. For example:Note that this is not the geometric center of the arc, which may be outside the arc; this method is merely a convenience for positioning labels.arc.innerRadius(radius) ​Source · If radius is specified, sets the inner radius to the specified function or number and returns this arc generator.jsconst arc = d3.arc().innerRadius(40);If radius is not specified, returns the current inner radius accessor.jsarc.innerRadius() // () => 40The inner radius accessor defaults to:jsfunction innerRadius(d) {
  return d.innerRadius;
}Specifying the inner radius as a function is useful for constructing a stacked polar bar chart, often in conjunction with a sqrt scale. More commonly, a constant inner radius is used for a donut or pie chart. If the outer radius is smaller than the inner radius, the inner and outer radii are swapped. A negative value is treated as zero.arc.outerRadius(radius) ​Source · If radius is specified, sets the outer radius to the specified function or number and returns this arc generator.jsconst arc = d3.arc().outerRadius(240);If radius is not specified, returns the current outer radius accessor.jsarc.outerRadius() // () => 240The outer radius accessor defaults to:jsfunction outerRadius(d) {
  return d.outerRadius;
}Specifying the outer radius as a function is useful for constructing a coxcomb or polar bar chart, often in conjunction with a sqrt scale. More commonly, a constant outer radius is used for a pie or donut chart. If the outer radius is smaller than the inner radius, the inner and outer radii are swapped. A negative value is treated as zero.arc.cornerRadius(radius) ​Corner radius:18Examples · Source · If radius is specified, sets the corner radius to the specified function or number and returns this arc generator.jsconst arc = d3.arc().cornerRadius(18);If radius is not specified, returns the current corner radius accessor.jsarc.cornerRadius() // () => 18The corner radius accessor defaults to:jsfunction cornerRadius() {
  return 0;
}If the corner radius is greater than zero, the corners of the arc are rounded using circles of the given radius. For a circular sector, the two outer corners are rounded; for an annular sector, all four corners are rounded.The corner radius may not be larger than (outerRadius - innerRadius) / 2. In addition, for arcs whose angular span is less than π, the corner radius may be reduced as two adjacent rounded corners intersect. This occurs more often with the inner corners. See the arc corners animation for illustration.arc.startAngle(angle) ​Source · If angle is specified, sets the start angle to the specified function or number and returns this arc generator.jsconst arc = d3.arc().startAngle(Math.PI / 4);If angle is not specified, returns the current start angle accessor.jsarc.startAngle() // () => 0.7853981633974483The start angle accessor defaults to:jsfunction startAngle(d) {
  return d.startAngle;
}The angle is specified in radians, with 0 at -y (12 o’clock) and positive angles proceeding clockwise. If |endAngle - startAngle| ≥ 2π, a complete circle or annulus is generated rather than a sector.arc.endAngle(angle) ​Source · If angle is specified, sets the end angle to the specified function or number and returns this arc generator.jsconst arc = d3.arc().endAngle(Math.PI);If angle is not specified, returns the current end angle accessor.jsarc.endAngle() // () => 3.141592653589793The end angle accessor defaults to:jsfunction endAngle(d) {
  return d.endAngle;
}The angle is specified in radians, with 0 at -y (12 o’clock) and positive angles proceeding clockwise. If |endAngle - startAngle| ≥ 2π, a complete circle or annulus is generated rather than a sector.arc.padAngle(angle) ​Pad angle:0.030Examples · Source · If angle is specified, sets the pad angle to the specified function or number and returns this arc generator.jsconst arc = d3.arc().padAngle(0);If angle is not specified, returns the current pad angle accessor.jsarc.padAngle() // () => 0The pad angle accessor defaults to:jsfunction padAngle() {
  return d && d.padAngle;
}The pad angle is converted to a fixed linear distance separating adjacent arcs, defined as padRadius × padAngle. This distance is subtracted equally from the start and end of the arc. If the arc forms a complete circle or annulus, as when |endAngle - startAngle| ≥ 2π, the pad angle is ignored.If the inner radius or angular span is small relative to the pad angle, it may not be possible to maintain parallel edges between adjacent arcs. In this case, the inner edge of the arc may collapse to a point, similar to a circular sector. For this reason, padding is typically only applied to annular sectors (i.e., when innerRadius is positive), as shown in this diagram:The recommended minimum inner radius when using padding is outerRadius * padAngle / sin(θ), where θ is the angular span of the smallest arc before padding. For example, if the outer radius is 200 pixels and the pad angle is 0.02 radians, a reasonable θ is 0.04 radians, and a reasonable inner radius is 100 pixels. See the arc padding animation for illustration.Often, the pad angle is not set directly on the arc generator, but is instead computed by the pie generator so as to ensure that the area of padded arcs is proportional to their value; see pie.padAngle. See the pie padding animation for illustration. If you apply a constant pad angle to the arc generator directly, it tends to subtract disproportionately from smaller arcs, introducing distortion.arc.padRadius(radius) ​Pad radius:200Source · If radius is specified, sets the pad radius to the specified function or number and returns this arc generator. If radius is not specified, returns the current pad radius accessor, which defaults to null, indicating that the pad radius should be automatically computed as sqrt(innerRadius × innerRadius + outerRadius × outerRadius). The pad radius determines the fixed linear distance separating adjacent arcs, defined as padRadius × padAngle.arc.context(context) ​Source · If context is specified, sets the context and returns this arc generator.jsconst context = canvas.getContext("2d");
const arc = d3.arc().context(context);If context is not specified, returns the current context, which defaults to null.jsarc.context() // contextIf the context is not null, then the generated arc is rendered to this context as a sequence of path method calls. Otherwise, a path data string representing the generated arc is returned.arc.digits(digits) ​Source · If digits is specified, sets the maximum number of digits after the decimal separator and returns this arc generator.jsconst arc = d3.arc().digits(3);If digits is not specified, returns the current maximum fraction digits, which defaults to 3.jsarc.digits() // 3This option only applies when the associated context is null, as when this arc generator is used to produce path data.PagerPrevious paged3-shapeNext pageAreas\n\nArcs ​The arc generator produces a circular or annular sector, as in a pie or donut chart. Arcs are centered at the origin; use a transform to move the arc to a different position.jssvg.append("path")
    .attr("transform", "translate(100,100)")
    .attr("d", d3.arc()({
      innerRadius: 100,
      outerRadius: 200,
      startAngle: -Math.PI / 2,
      endAngle: Math.PI / 2
    }));If the absolute difference between the start and end angles (the angular span) is greater than 2π, the arc generator will produce a complete circle or annulus. If it is less than 2π, the arc’s angular length will be equal to the absolute difference between the two angles (going clockwise if the signed difference is positive and anticlockwise if it is negative). If the absolute difference is less than 2π, the arc may have rounded corners and angular padding.See also the pie generator, which computes the necessary angles to represent an array of data as a pie or donut chart; these angles can then be passed to an arc generator.arc() ​Source · Constructs a new arc generator with the default settings. With default settings:jsconst arc = d3.arc();Or, with the radii and angles configured as constants:jsconst arc = d3.arc()
    .innerRadius(0)
    .outerRadius(100)
    .startAngle(0)
    .endAngle(Math.PI / 2);arc(...arguments) ​Source · Generates an arc for the given arguments. The arguments are arbitrary; they are propagated to the arc generator’s accessor functions along with the this object. For example, with the default settings, an object with radii and angles is expected:jsconst arc = d3.arc();

arc({
  innerRadius: 0,
  outerRadius: 100,
  startAngle: 0,
  endAngle: Math.PI / 2
}); // "M0,-100A100,100,0,0,1,100,0L0,0Z"If the radii and angles are instead defined as constants, you can generate an arc without any arguments:jsd3.arc()
    .innerRadius(0)
    .outerRadius(100)
    .startAngle(0)
    .endAngle(Math.PI / 2)
  (); // "M0,-100A100,100,0,0,1,100,0L0,0Z"If the arc generator has a context, then the arc is rendered to this context as a sequence of path method calls and this function returns void. Otherwise, a path data string is returned.arc.centroid(...arguments) ​Examples · Source · Computes the midpoint [x, y] of the center line of the arc that would be generated by the given arguments.The arguments are arbitrary; they are propagated to the arc generator’s accessor functions along with the this object. To be consistent with the generated arc, the accessors must be deterministic, i.e., return the same value given the same arguments. The midpoint is defined as (startAngle + endAngle) / 2 and (innerRadius + outerRadius) / 2. For example:Note that this is not the geometric center of the arc, which may be outside the arc; this method is merely a convenience for positioning labels.arc.innerRadius(radius) ​Source · If radius is specified, sets the inner radius to the specified function or number and returns this arc generator.jsconst arc = d3.arc().innerRadius(40);If radius is not specified, returns the current inner radius accessor.jsarc.innerRadius() // () => 40The inner radius accessor defaults to:jsfunction innerRadius(d) {
  return d.innerRadius;
}Specifying the inner radius as a function is useful for constructing a stacked polar bar chart, often in conjunction with a sqrt scale. More commonly, a constant inner radius is used for a donut or pie chart. If the outer radius is smaller than the inner radius, the inner and outer radii are swapped. A negative value is treated as zero.arc.outerRadius(radius) ​Source · If radius is specified, sets the outer radius to the specified function or number and returns this arc generator.jsconst arc = d3.arc().outerRadius(240);If radius is not specified, returns the current outer radius accessor.jsarc.outerRadius() // () => 240The outer radius accessor defaults to:jsfunction outerRadius(d) {
  return d.outerRadius;
}Specifying the outer radius as a function is useful for constructing a coxcomb or polar bar chart, often in conjunction with a sqrt scale. More commonly, a constant outer radius is used for a pie or donut chart. If the outer radius is smaller than the inner radius, the inner and outer radii are swapped. A negative value is treated as zero.arc.cornerRadius(radius) ​Corner radius:18Examples · Source · If radius is specified, sets the corner radius to the specified function or number and returns this arc generator.jsconst arc = d3.arc().cornerRadius(18);If radius is not specified, returns the current corner radius accessor.jsarc.cornerRadius() // () => 18The corner radius accessor defaults to:jsfunction cornerRadius() {
  return 0;
}If the corner radius is greater than zero, the corners of the arc are rounded using circles of the given radius. For a circular sector, the two outer corners are rounded; for an annular sector, all four corners are rounded.The corner radius may not be larger than (outerRadius - innerRadius) / 2. In addition, for arcs whose angular span is less than π, the corner radius may be reduced as two adjacent rounded corners intersect. This occurs more often with the inner corners. See the arc corners animation for illustration.arc.startAngle(angle) ​Source · If angle is specified, sets the start angle to the specified function or number and returns this arc generator.jsconst arc = d3.arc().startAngle(Math.PI / 4);If angle is not specified, returns the current start angle accessor.jsarc.startAngle() // () => 0.7853981633974483The start angle accessor defaults to:jsfunction startAngle(d) {
  return d.startAngle;
}The angle is specified in radians, with 0 at -y (12 o’clock) and positive angles proceeding clockwise. If |endAngle - startAngle| ≥ 2π, a complete circle or annulus is generated rather than a sector.arc.endAngle(angle) ​Source · If angle is specified, sets the end angle to the specified function or number and returns this arc generator.jsconst arc = d3.arc().endAngle(Math.PI);If angle is not specified, returns the current end angle accessor.jsarc.endAngle() // () => 3.141592653589793The end angle accessor defaults to:jsfunction endAngle(d) {
  return d.endAngle;
}The angle is specified in radians, with 0 at -y (12 o’clock) and positive angles proceeding clockwise. If |endAngle - startAngle| ≥ 2π, a complete circle or annulus is generated rather than a sector.arc.padAngle(angle) ​Pad angle:0.030Examples · Source · If angle is specified, sets the pad angle to the specified function or number and returns this arc generator.jsconst arc = d3.arc().padAngle(0);If angle is not specified, returns the current pad angle accessor.jsarc.padAngle() // () => 0The pad angle accessor defaults to:jsfunction padAngle() {
  return d && d.padAngle;
}The pad angle is converted to a fixed linear distance separating adjacent arcs, defined as padRadius × padAngle. This distance is subtracted equally from the start and end of the arc. If the arc forms a complete circle or annulus, as when |endAngle - startAngle| ≥ 2π, the pad angle is ignored.If the inner radius or angular span is small relative to the pad angle, it may not be possible to maintain parallel edges between adjacent arcs. In this case, the inner edge of the arc may collapse to a point, similar to a circular sector. For this reason, padding is typically only applied to annular sectors (i.e., when innerRadius is positive), as shown in this diagram:The recommended minimum inner radius when using padding is outerRadius * padAngle / sin(θ), where θ is the angular span of the smallest arc before padding. For example, if the outer radius is 200 pixels and the pad angle is 0.02 radians, a reasonable θ is 0.04 radians, and a reasonable inner radius is 100 pixels. See the arc padding animation for illustration.Often, the pad angle is not set directly on the arc generator, but is instead computed by the pie generator so as to ensure that the area of padded arcs is proportional to their value; see pie.padAngle. See the pie padding animation for illustration. If you apply a constant pad angle to the arc generator directly, it tends to subtract disproportionately from smaller arcs, introducing distortion.arc.padRadius(radius) ​Pad radius:200Source · If radius is specified, sets the pad radius to the specified function or number and returns this arc generator. If radius is not specified, returns the current pad radius accessor, which defaults to null, indicating that the pad radius should be automatically computed as sqrt(innerRadius × innerRadius + outerRadius × outerRadius). The pad radius determines the fixed linear distance separating adjacent arcs, defined as padRadius × padAngle.arc.context(context) ​Source · If context is specified, sets the context and returns this arc generator.jsconst context = canvas.getContext("2d");
const arc = d3.arc().context(context);If context is not specified, returns the current context, which defaults to null.jsarc.context() // contextIf the context is not null, then the generated arc is rendered to this context as a sequence of path method calls. Otherwise, a path data string representing the generated arc is returned.arc.digits(digits) ​Source · If digits is specified, sets the maximum number of digits after the decimal separator and returns this arc generator.jsconst arc = d3.arc().digits(3);If digits is not specified, returns the current maximum fraction digits, which defaults to 3.jsarc.digits() // 3This option only applies when the associated context is null, as when this arc generator is used to produce path data.\n\n\n\nAreas ​Examples · The area generator produces an area defined by a topline and a baseline as in an area chart. Typically, the two lines share the same x-values (x0 = x1), differing only in y-value (y0 and y1); most commonly, y0 is defined as a constant representing zero (the y scale’s output for zero). The topline is defined by x1 and y1 and is rendered first; the baseline is defined by x0 and y0 and is rendered second with the points in reverse order. With a curveLinear curve, this produces a clockwise polygon. See also radial areas.area(x, y0, y1) ​Source · Constructs a new area generator with the given x, y0, and y1 accessors or numbers.jsconst area = d3.area((d) => x(d.Date), y(0), (d) => y(d.Close));If x, y0 or y1 are not specified, the respective defaults will be used. The above can be expressed more explicitly as:jsconst area = d3.area()
    .x((d) => x(d.Date))
    .y0(y(0))
    .y1((d) => y(d.Close));area(data) ​Source · Generates an area for the given array of data.jssvg.append("path").attr("d", area(data));If the area generator has a context, then the area is rendered to this context as a sequence of path method calls and this function returns void. Otherwise, a path data string is returned.CAUTIONDepending on this area generator’s associated curve, the given input data may need to be sorted by x-value before being passed to the area generator.area.x(x) ​Source · If x is specified, sets x0 to x and x1 to null and returns this area generator.jsconst area = d3.area().x((d) => x(d.Date));If x is not specified, returns the current x0 accessor.jsarea.x() // (d) => x(d.Date)area.x0(x) ​TIPThis method is intended for vertically-oriented areas, as when time goes down↓ rather than right→; for the more common horizontally-oriented areas, use area.x instead.Source · If x is specified, sets the x0 accessor to the specified function or number and returns this area generator.jsconst area = d3.area().x0(x(0));When an area is generated, the x0 accessor will be invoked for each defined element in the input data array, being passed the element d, the index i, and the array data as three arguments.If x is not specified, returns the current x0 accessor.jsarea.x0() // () => 20The x0 accessor defaults to:jsfunction x(d) {
  return d[0];
}The default x0 accessor assumes that the input data are two-element arrays of numbers [[x0, y0], [x1, y1], …]. If your data are in a different format, or if you wish to transform the data before rendering, then you should specify a custom accessor as shown above.area.x1(x) ​TIPThis method is intended for vertically-oriented areas, as when time goes down↓ rather than right→; for the more common horizontally-oriented areas, use area.x instead.Source · If x is specified, sets the x1 accessor to the specified function or number and returns this area generator.jsconst area = d3.area().x1((d) => x(d.Close));When an area is generated, the x1 accessor will be invoked for each defined element in the input data array, being passed the element d, the index i, and the array data as three arguments.If x is not specified, returns the current x1 accessor.jsarea.x1() // (d) => x(d.Close)The x1 accessor defaults to null, indicating that the previously-computed x0 value should be reused for the x1 value; this default is intended for horizontally-oriented areas.area.y(y) ​TIPThis method is intended for vertically-oriented areas, as when time goes down↓ rather than right→; for the more common horizontally-oriented areas, use area.y0 and area.y1 instead.Source · If y is specified, sets y0 to y and y1 to null and returns this area generator.jsconst area = d3.area().y((d) => y(d.Date));If y is not specified, returns the current y0 accessor.jsarea.y() // (d) => y(d.Date)area.y0(y) ​Source · If y is specified, sets the y0 accessor to the specified function or number and returns this area generator.jsconst area = d3.area().y0(y(0));When an area is generated, the y0 accessor will be invoked for each defined element in the input data array, being passed the element d, the index i, and the array data as three arguments. For a horizontally-oriented area with a constant baseline (i.e., an area that is not stacked, and not a ribbon or band), y0 is typically set to the output of the y scale for zero.If y is not specified, returns the current y0 accessor.jsarea.y0() // () => 360The y0 accessor defaults to:jsfunction y() {
  return 0;
}In the default SVG coordinate system, note that the default zero represents the top of the chart rather than the bottom, producing a flipped (or “hanging”) area.area.y1(y) ​Source · If y is specified, sets the y1 accessor to the specified function or number and returns this area generator.jsconst area = d3.area().y1((d) => y(d.Close));When an area is generated, the y1 accessor will be invoked for each defined element in the input data array, being passed the element d, the index i, and the array data as three arguments.If y is not specified, returns the current y1 accessor.jsarea.y1() // (d) => y(d.Close)The y1 accessor defaults to:jsfunction y(d) {
  return d[1];
}The default y1 accessor assumes that the input data are two-element arrays of numbers [[x0, y0], [x1, y1], …]. If your data are in a different format, or if you wish to transform the data before rendering, then you should specify a custom accessor as shown above. A null accessor is also allowed, indicating that the previously-computed y0 value should be reused for the y1 value; this can be used for a vertically-oriented area, as when time goes down↓ instead of right→.area.defined(defined) ​Examples · Source · If defined is specified, sets the defined accessor to the specified function or boolean and returns this area generator.jsconst area = d3.area().defined((d) => !isNaN(d.Close));When an area is generated, the defined accessor will be invoked for each element in the input data array, being passed the element d, the index i, and the array data as three arguments. If the given element is defined (i.e., if the defined accessor returns a truthy value for this element), the x0, x1, y0 and y1 accessors will subsequently be evaluated and the point will be added to the current area segment. Otherwise, the element will be skipped, the current area segment will be ended, and a new area segment will be generated for the next defined point. As a result, the generated area may have several discrete segments.If defined is not specified, returns the current defined accessor.jsarea.defined() // (d) => !isNaN(d.Close)The defined accessor defaults to the constant true, and assumes that the input data is always defined:jsfunction defined() {
  return true;
}Note that if an area segment consists of only a single point, it may appear invisible unless rendered with rounded or square line caps. In addition, some curves such as curveCardinalOpen only render a visible segment if it contains multiple points.area.curve(curve) ​Source · If curve is specified, sets the curve factory and returns this area generator.jsconst area = d3.area().curve(d3.curveStep);If curve is not specified, returns the current curve factory, which defaults to curveLinear.jsarea.curve() // d3.curveSteparea.context(context) ​Source · If context is specified, sets the context and returns this area generator.jsconst context = canvas.getContext("2d");
const area = d3.area().context(context);If context is not specified, returns the current context.jsarea.context() // contextThe context defaults to null. If the context is not null, then the generated area is rendered to this context as a sequence of path method calls. Otherwise, a path data string representing the generated area is returned.area.digits(digits) ​Source · If digits is specified, sets the maximum number of digits after the decimal separator and returns this area generator.jsconst area = d3.area().digits(3);If digits is not specified, returns the current maximum fraction digits, which defaults to 3.jsarea.digits() // 3This option only applies when the associated context is null, as when this area generator is used to produce path data.area.lineX0() ​An alias for area.lineY0.area.lineY0() ​Source · Returns a new line generator that has this area generator’s current defined accessor, curve and context. The line’s x-accessor is this area’s x0-accessor, and the line’s y-accessor is this area’s y0-accessor.area.lineX1() ​Source · Returns a new line generator that has this area generator’s current defined accessor, curve and context. The line’s x-accessor is this area’s x1-accessor, and the line’s y-accessor is this area’s y0-accessor.area.lineY1() ​Source · Returns a new line generator that has this area generator’s current defined accessor, curve and context. The line’s x-accessor is this area’s x0-accessor, and the line’s y-accessor is this area’s y1-accessor.\n\nSearchK7.9.0GitHub️ 110.0kOn this pageAreas ​Examples · The area generator produces an area defined by a topline and a baseline as in an area chart. Typically, the two lines share the same x-values (x0 = x1), differing only in y-value (y0 and y1); most commonly, y0 is defined as a constant representing zero (the y scale’s output for zero). The topline is defined by x1 and y1 and is rendered first; the baseline is defined by x0 and y0 and is rendered second with the points in reverse order. With a curveLinear curve, this produces a clockwise polygon. See also radial areas.area(x, y0, y1) ​Source · Constructs a new area generator with the given x, y0, and y1 accessors or numbers.jsconst area = d3.area((d) => x(d.Date), y(0), (d) => y(d.Close));If x, y0 or y1 are not specified, the respective defaults will be used. The above can be expressed more explicitly as:jsconst area = d3.area()
    .x((d) => x(d.Date))
    .y0(y(0))
    .y1((d) => y(d.Close));area(data) ​Source · Generates an area for the given array of data.jssvg.append("path").attr("d", area(data));If the area generator has a context, then the area is rendered to this context as a sequence of path method calls and this function returns void. Otherwise, a path data string is returned.CAUTIONDepending on this area generator’s associated curve, the given input data may need to be sorted by x-value before being passed to the area generator.area.x(x) ​Source · If x is specified, sets x0 to x and x1 to null and returns this area generator.jsconst area = d3.area().x((d) => x(d.Date));If x is not specified, returns the current x0 accessor.jsarea.x() // (d) => x(d.Date)area.x0(x) ​TIPThis method is intended for vertically-oriented areas, as when time goes down↓ rather than right→; for the more common horizontally-oriented areas, use area.x instead.Source · If x is specified, sets the x0 accessor to the specified function or number and returns this area generator.jsconst area = d3.area().x0(x(0));When an area is generated, the x0 accessor will be invoked for each defined element in the input data array, being passed the element d, the index i, and the array data as three arguments.If x is not specified, returns the current x0 accessor.jsarea.x0() // () => 20The x0 accessor defaults to:jsfunction x(d) {
  return d[0];
}The default x0 accessor assumes that the input data are two-element arrays of numbers [[x0, y0], [x1, y1], …]. If your data are in a different format, or if you wish to transform the data before rendering, then you should specify a custom accessor as shown above.area.x1(x) ​TIPThis method is intended for vertically-oriented areas, as when time goes down↓ rather than right→; for the more common horizontally-oriented areas, use area.x instead.Source · If x is specified, sets the x1 accessor to the specified function or number and returns this area generator.jsconst area = d3.area().x1((d) => x(d.Close));When an area is generated, the x1 accessor will be invoked for each defined element in the input data array, being passed the element d, the index i, and the array data as three arguments.If x is not specified, returns the current x1 accessor.jsarea.x1() // (d) => x(d.Close)The x1 accessor defaults to null, indicating that the previously-computed x0 value should be reused for the x1 value; this default is intended for horizontally-oriented areas.area.y(y) ​TIPThis method is intended for vertically-oriented areas, as when time goes down↓ rather than right→; for the more common horizontally-oriented areas, use area.y0 and area.y1 instead.Source · If y is specified, sets y0 to y and y1 to null and returns this area generator.jsconst area = d3.area().y((d) => y(d.Date));If y is not specified, returns the current y0 accessor.jsarea.y() // (d) => y(d.Date)area.y0(y) ​Source · If y is specified, sets the y0 accessor to the specified function or number and returns this area generator.jsconst area = d3.area().y0(y(0));When an area is generated, the y0 accessor will be invoked for each defined element in the input data array, being passed the element d, the index i, and the array data as three arguments. For a horizontally-oriented area with a constant baseline (i.e., an area that is not stacked, and not a ribbon or band), y0 is typically set to the output of the y scale for zero.If y is not specified, returns the current y0 accessor.jsarea.y0() // () => 360The y0 accessor defaults to:jsfunction y() {
  return 0;
}In the default SVG coordinate system, note that the default zero represents the top of the chart rather than the bottom, producing a flipped (or “hanging”) area.area.y1(y) ​Source · If y is specified, sets the y1 accessor to the specified function or number and returns this area generator.jsconst area = d3.area().y1((d) => y(d.Close));When an area is generated, the y1 accessor will be invoked for each defined element in the input data array, being passed the element d, the index i, and the array data as three arguments.If y is not specified, returns the current y1 accessor.jsarea.y1() // (d) => y(d.Close)The y1 accessor defaults to:jsfunction y(d) {
  return d[1];
}The default y1 accessor assumes that the input data are two-element arrays of numbers [[x0, y0], [x1, y1], …]. If your data are in a different format, or if you wish to transform the data before rendering, then you should specify a custom accessor as shown above. A null accessor is also allowed, indicating that the previously-computed y0 value should be reused for the y1 value; this can be used for a vertically-oriented area, as when time goes down↓ instead of right→.area.defined(defined) ​Examples · Source · If defined is specified, sets the defined accessor to the specified function or boolean and returns this area generator.jsconst area = d3.area().defined((d) => !isNaN(d.Close));When an area is generated, the defined accessor will be invoked for each element in the input data array, being passed the element d, the index i, and the array data as three arguments. If the given element is defined (i.e., if the defined accessor returns a truthy value for this element), the x0, x1, y0 and y1 accessors will subsequently be evaluated and the point will be added to the current area segment. Otherwise, the element will be skipped, the current area segment will be ended, and a new area segment will be generated for the next defined point. As a result, the generated area may have several discrete segments.If defined is not specified, returns the current defined accessor.jsarea.defined() // (d) => !isNaN(d.Close)The defined accessor defaults to the constant true, and assumes that the input data is always defined:jsfunction defined() {
  return true;
}Note that if an area segment consists of only a single point, it may appear invisible unless rendered with rounded or square line caps. In addition, some curves such as curveCardinalOpen only render a visible segment if it contains multiple points.area.curve(curve) ​Source · If curve is specified, sets the curve factory and returns this area generator.jsconst area = d3.area().curve(d3.curveStep);If curve is not specified, returns the current curve factory, which defaults to curveLinear.jsarea.curve() // d3.curveSteparea.context(context) ​Source · If context is specified, sets the context and returns this area generator.jsconst context = canvas.getContext("2d");
const area = d3.area().context(context);If context is not specified, returns the current context.jsarea.context() // contextThe context defaults to null. If the context is not null, then the generated area is rendered to this context as a sequence of path method calls. Otherwise, a path data string representing the generated area is returned.area.digits(digits) ​Source · If digits is specified, sets the maximum number of digits after the decimal separator and returns this area generator.jsconst area = d3.area().digits(3);If digits is not specified, returns the current maximum fraction digits, which defaults to 3.jsarea.digits() // 3This option only applies when the associated context is null, as when this area generator is used to produce path data.area.lineX0() ​An alias for area.lineY0.area.lineY0() ​Source · Returns a new line generator that has this area generator’s current defined accessor, curve and context. The line’s x-accessor is this area’s x0-accessor, and the line’s y-accessor is this area’s y0-accessor.area.lineX1() ​Source · Returns a new line generator that has this area generator’s current defined accessor, curve and context. The line’s x-accessor is this area’s x1-accessor, and the line’s y-accessor is this area’s y0-accessor.area.lineY1() ​Source · Returns a new line generator that has this area generator’s current defined accessor, curve and context. The line’s x-accessor is this area’s x0-accessor, and the line’s y-accessor is this area’s y1-accessor.PagerPrevious pageArcsNext pageCurves\n\nAreas ​Examples · The area generator produces an area defined by a topline and a baseline as in an area chart. Typically, the two lines share the same x-values (x0 = x1), differing only in y-value (y0 and y1); most commonly, y0 is defined as a constant representing zero (the y scale’s output for zero). The topline is defined by x1 and y1 and is rendered first; the baseline is defined by x0 and y0 and is rendered second with the points in reverse order. With a curveLinear curve, this produces a clockwise polygon. See also radial areas.area(x, y0, y1) ​Source · Constructs a new area generator with the given x, y0, and y1 accessors or numbers.jsconst area = d3.area((d) => x(d.Date), y(0), (d) => y(d.Close));If x, y0 or y1 are not specified, the respective defaults will be used. The above can be expressed more explicitly as:jsconst area = d3.area()
    .x((d) => x(d.Date))
    .y0(y(0))
    .y1((d) => y(d.Close));area(data) ​Source · Generates an area for the given array of data.jssvg.append("path").attr("d", area(data));If the area generator has a context, then the area is rendered to this context as a sequence of path method calls and this function returns void. Otherwise, a path data string is returned.CAUTIONDepending on this area generator’s associated curve, the given input data may need to be sorted by x-value before being passed to the area generator.area.x(x) ​Source · If x is specified, sets x0 to x and x1 to null and returns this area generator.jsconst area = d3.area().x((d) => x(d.Date));If x is not specified, returns the current x0 accessor.jsarea.x() // (d) => x(d.Date)area.x0(x) ​TIPThis method is intended for vertically-oriented areas, as when time goes down↓ rather than right→; for the more common horizontally-oriented areas, use area.x instead.Source · If x is specified, sets the x0 accessor to the specified function or number and returns this area generator.jsconst area = d3.area().x0(x(0));When an area is generated, the x0 accessor will be invoked for each defined element in the input data array, being passed the element d, the index i, and the array data as three arguments.If x is not specified, returns the current x0 accessor.jsarea.x0() // () => 20The x0 accessor defaults to:jsfunction x(d) {
  return d[0];
}The default x0 accessor assumes that the input data are two-element arrays of numbers [[x0, y0], [x1, y1], …]. If your data are in a different format, or if you wish to transform the data before rendering, then you should specify a custom accessor as shown above.area.x1(x) ​TIPThis method is intended for vertically-oriented areas, as when time goes down↓ rather than right→; for the more common horizontally-oriented areas, use area.x instead.Source · If x is specified, sets the x1 accessor to the specified function or number and returns this area generator.jsconst area = d3.area().x1((d) => x(d.Close));When an area is generated, the x1 accessor will be invoked for each defined element in the input data array, being passed the element d, the index i, and the array data as three arguments.If x is not specified, returns the current x1 accessor.jsarea.x1() // (d) => x(d.Close)The x1 accessor defaults to null, indicating that the previously-computed x0 value should be reused for the x1 value; this default is intended for horizontally-oriented areas.area.y(y) ​TIPThis method is intended for vertically-oriented areas, as when time goes down↓ rather than right→; for the more common horizontally-oriented areas, use area.y0 and area.y1 instead.Source · If y is specified, sets y0 to y and y1 to null and returns this area generator.jsconst area = d3.area().y((d) => y(d.Date));If y is not specified, returns the current y0 accessor.jsarea.y() // (d) => y(d.Date)area.y0(y) ​Source · If y is specified, sets the y0 accessor to the specified function or number and returns this area generator.jsconst area = d3.area().y0(y(0));When an area is generated, the y0 accessor will be invoked for each defined element in the input data array, being passed the element d, the index i, and the array data as three arguments. For a horizontally-oriented area with a constant baseline (i.e., an area that is not stacked, and not a ribbon or band), y0 is typically set to the output of the y scale for zero.If y is not specified, returns the current y0 accessor.jsarea.y0() // () => 360The y0 accessor defaults to:jsfunction y() {
  return 0;
}In the default SVG coordinate system, note that the default zero represents the top of the chart rather than the bottom, producing a flipped (or “hanging”) area.area.y1(y) ​Source · If y is specified, sets the y1 accessor to the specified function or number and returns this area generator.jsconst area = d3.area().y1((d) => y(d.Close));When an area is generated, the y1 accessor will be invoked for each defined element in the input data array, being passed the element d, the index i, and the array data as three arguments.If y is not specified, returns the current y1 accessor.jsarea.y1() // (d) => y(d.Close)The y1 accessor defaults to:jsfunction y(d) {
  return d[1];
}The default y1 accessor assumes that the input data are two-element arrays of numbers [[x0, y0], [x1, y1], …]. If your data are in a different format, or if you wish to transform the data before rendering, then you should specify a custom accessor as shown above. A null accessor is also allowed, indicating that the previously-computed y0 value should be reused for the y1 value; this can be used for a vertically-oriented area, as when time goes down↓ instead of right→.area.defined(defined) ​Examples · Source · If defined is specified, sets the defined accessor to the specified function or boolean and returns this area generator.jsconst area = d3.area().defined((d) => !isNaN(d.Close));When an area is generated, the defined accessor will be invoked for each element in the input data array, being passed the element d, the index i, and the array data as three arguments. If the given element is defined (i.e., if the defined accessor returns a truthy value for this element), the x0, x1, y0 and y1 accessors will subsequently be evaluated and the point will be added to the current area segment. Otherwise, the element will be skipped, the current area segment will be ended, and a new area segment will be generated for the next defined point. As a result, the generated area may have several discrete segments.If defined is not specified, returns the current defined accessor.jsarea.defined() // (d) => !isNaN(d.Close)The defined accessor defaults to the constant true, and assumes that the input data is always defined:jsfunction defined() {
  return true;
}Note that if an area segment consists of only a single point, it may appear invisible unless rendered with rounded or square line caps. In addition, some curves such as curveCardinalOpen only render a visible segment if it contains multiple points.area.curve(curve) ​Source · If curve is specified, sets the curve factory and returns this area generator.jsconst area = d3.area().curve(d3.curveStep);If curve is not specified, returns the current curve factory, which defaults to curveLinear.jsarea.curve() // d3.curveSteparea.context(context) ​Source · If context is specified, sets the context and returns this area generator.jsconst context = canvas.getContext("2d");
const area = d3.area().context(context);If context is not specified, returns the current context.jsarea.context() // contextThe context defaults to null. If the context is not null, then the generated area is rendered to this context as a sequence of path method calls. Otherwise, a path data string representing the generated area is returned.area.digits(digits) ​Source · If digits is specified, sets the maximum number of digits after the decimal separator and returns this area generator.jsconst area = d3.area().digits(3);If digits is not specified, returns the current maximum fraction digits, which defaults to 3.jsarea.digits() // 3This option only applies when the associated context is null, as when this area generator is used to produce path data.area.lineX0() ​An alias for area.lineY0.area.lineY0() ​Source · Returns a new line generator that has this area generator’s current defined accessor, curve and context. The line’s x-accessor is this area’s x0-accessor, and the line’s y-accessor is this area’s y0-accessor.area.lineX1() ​Source · Returns a new line generator that has this area generator’s current defined accessor, curve and context. The line’s x-accessor is this area’s x1-accessor, and the line’s y-accessor is this area’s y0-accessor.area.lineY1() ​Source · Returns a new line generator that has this area generator’s current defined accessor, curve and context. The line’s x-accessor is this area’s x0-accessor, and the line’s y-accessor is this area’s y1-accessor.\n\n\n\nCurves ​Curves turn a discrete (pointwise) representation of a line or area into a continuous shape: curves specify how to interpolate between two-dimensional [x, y] points.Curves are typically not constructed or used directly. Instead, one of the built-in curves is being passed to line.curve or area.curve.jsconst line = d3.line()
    .x((d) => x(d.date))
    .y((d) => y(d.value))
    .curve(d3.curveCatmullRom.alpha(0.5));If desired, you can implement a custom curve. For an example of using a curve directly, see Context to Curve.curveBasis(context) ​Source · Produces a cubic basis spline using the specified control points. The first and last points are triplicated such that the spline starts at the first point and ends at the last point, and is tangent to the line between the first and second points, and to the line between the penultimate and last points.curveBasisClosed(context) ​Source · Produces a closed cubic basis spline using the specified control points. When a line segment ends, the first three control points are repeated, producing a closed loop with C2 continuity.curveBasisOpen(context) ​Source · Produces a cubic basis spline using the specified control points. Unlike basis, the first and last points are not repeated, and thus the curve typically does not intersect these points.curveBumpX(context) ​Source · Produces a Bézier curve between each pair of points, with horizontal tangents at each point.curveBumpY(context) ​Source · Produces a Bézier curve between each pair of points, with vertical tangents at each point.curveBundle(context) ​Source · Produces a straightened cubic basis spline using the specified control points, with the spline straightened according to the curve’s beta, which defaults to 0.85. This curve is typically used in hierarchical edge bundling to disambiguate connections, as proposed by Danny Holten in Hierarchical Edge Bundles: Visualization of Adjacency Relations in Hierarchical Data. This curve does not implement curve.areaStart and curve.areaEnd; it is intended to work with d3.line, not d3.area.curveBundle.beta(beta) ​Beta:0.85Source · Returns a bundle curve with the specified beta in the range [0, 1], representing the bundle strength. If beta equals zero, a straight line between the first and last point is produced; if beta equals one, a standard basis spline is produced. For example:jsconst line = d3.line().curve(d3.curveBundle.beta(0.5));curveCardinal(context) ​Source · Produces a cubic cardinal spline using the specified control points, with one-sided differences used for the first and last piece. The default tension is 0.curveCardinalClosed(context) ​Source · Produces a closed cubic cardinal spline using the specified control points. When a line segment ends, the first three control points are repeated, producing a closed loop. The default tension is 0.curveCardinalOpen(context) ​Source · Produces a cubic cardinal spline using the specified control points. Unlike curveCardinal, one-sided differences are not used for the first and last piece, and thus the curve starts at the second point and ends at the penultimate point. The default tension is 0.curveCardinal.tension(tension) ​Tension:0.00Source · Returns a cardinal curve with the specified tension in the range [0, 1]. The tension determines the length of the tangents: a tension of one yields all zero tangents, equivalent to curveLinear; a tension of zero produces a uniform Catmull–Rom spline. For example:jsconst line = d3.line().curve(d3.curveCardinal.tension(0.5));curveCatmullRom(context) ​Source · Produces a cubic Catmull–Rom spline using the specified control points and the parameter alpha, which defaults to 0.5, as proposed by Yuksel et al. in On the Parameterization of Catmull–Rom Curves, with one-sided differences used for the first and last piece.curveCatmullRomClosed(context) ​Source · Produces a closed cubic Catmull–Rom spline using the specified control points and the parameter alpha, which defaults to 0.5, as proposed by Yuksel et al. When a line segment ends, the first three control points are repeated, producing a closed loop.curveCatmullRomOpen(context) ​Source · Produces a cubic Catmull–Rom spline using the specified control points and the parameter alpha, which defaults to 0.5, as proposed by Yuksel et al. Unlike curveCatmullRom, one-sided differences are not used for the first and last piece, and thus the curve starts at the second point and ends at the penultimate point.curveCatmullRom.alpha(alpha) ​Alpha:0.50Source · Returns a cubic Catmull–Rom curve with the specified alpha in the range [0, 1]. If alpha is zero, produces a uniform spline, equivalent to curveCardinal with a tension of zero; if alpha is one, produces a chordal spline; if alpha is 0.5, produces a centripetal spline. Centripetal splines are recommended to avoid self-intersections and overshoot. For example:jsconst line = d3.line().curve(d3.curveCatmullRom.alpha(0.5));curveLinear(context) ​Source · Produces a polyline through the specified points.curveLinearClosed(context) ​Source · Produces a closed polyline through the specified points by repeating the first point when the line segment ends.curveMonotoneX(context) ​Source · Produces a cubic spline that preserves monotonicity in y, assuming monotonicity in x, as proposed by Steffen in A simple method for monotonic interpolation in one dimension: “a smooth curve with continuous first-order derivatives that passes through any given set of data points without spurious oscillations. Local extrema can occur only at grid points where they are given by the data, but not in between two adjacent grid points.”curveMonotoneY(context) ​Source · Produces a cubic spline that preserves monotonicity in x, assuming monotonicity in y, as proposed by Steffen in A simple method for monotonic interpolation in one dimension: “a smooth curve with continuous first-order derivatives that passes through any given set of data points without spurious oscillations. Local extrema can occur only at grid points where they are given by the data, but not in between two adjacent grid points.”curveNatural(context) ​Source · Produces a natural cubic spline with the second derivative of the spline set to zero at the endpoints.curveStep(context) ​Source · Produces a piecewise constant function (a step function) consisting of alternating horizontal and vertical lines. The y-value changes at the midpoint of each pair of adjacent x-values.curveStepAfter(context) ​Source · Produces a piecewise constant function (a step function) consisting of alternating horizontal and vertical lines. The y-value changes after the x-value.curveStepBefore(context) ​Source · Produces a piecewise constant function (a step function) consisting of alternating horizontal and vertical lines. The y-value changes before the x-value.Custom curves ​Curves are typically not used directly, instead being passed to line.curve and area.curve. However, you can define your own curve implementation should none of the built-in curves satisfy your needs using the following interface; see the curveLinear source for an example implementation. You can also use this low-level interface with a built-in curve type as an alternative to the line and area generators.curve.areaStart() ​Indicates the start of a new area segment. Each area segment consists of exactly two line segments: the topline, followed by the baseline, with the baseline points in reverse order.curve.areaEnd() ​Indicates the end of the current area segment.curve.lineStart() ​Indicates the start of a new line segment. Zero or more points will follow.curve.lineEnd() ​Indicates the end of the current line segment.curve.point(x, y) ​Indicates a new point in the current line segment with the given x- and y-values.\n\nSearchK7.9.0GitHub️ 110.0kOn this pageCurves ​Curves turn a discrete (pointwise) representation of a line or area into a continuous shape: curves specify how to interpolate between two-dimensional [x, y] points.Curves are typically not constructed or used directly. Instead, one of the built-in curves is being passed to line.curve or area.curve.jsconst line = d3.line()
    .x((d) => x(d.date))
    .y((d) => y(d.value))
    .curve(d3.curveCatmullRom.alpha(0.5));If desired, you can implement a custom curve. For an example of using a curve directly, see Context to Curve.curveBasis(context) ​Source · Produces a cubic basis spline using the specified control points. The first and last points are triplicated such that the spline starts at the first point and ends at the last point, and is tangent to the line between the first and second points, and to the line between the penultimate and last points.curveBasisClosed(context) ​Source · Produces a closed cubic basis spline using the specified control points. When a line segment ends, the first three control points are repeated, producing a closed loop with C2 continuity.curveBasisOpen(context) ​Source · Produces a cubic basis spline using the specified control points. Unlike basis, the first and last points are not repeated, and thus the curve typically does not intersect these points.curveBumpX(context) ​Source · Produces a Bézier curve between each pair of points, with horizontal tangents at each point.curveBumpY(context) ​Source · Produces a Bézier curve between each pair of points, with vertical tangents at each point.curveBundle(context) ​Source · Produces a straightened cubic basis spline using the specified control points, with the spline straightened according to the curve’s beta, which defaults to 0.85. This curve is typically used in hierarchical edge bundling to disambiguate connections, as proposed by Danny Holten in Hierarchical Edge Bundles: Visualization of Adjacency Relations in Hierarchical Data. This curve does not implement curve.areaStart and curve.areaEnd; it is intended to work with d3.line, not d3.area.curveBundle.beta(beta) ​Beta:0.85Source · Returns a bundle curve with the specified beta in the range [0, 1], representing the bundle strength. If beta equals zero, a straight line between the first and last point is produced; if beta equals one, a standard basis spline is produced. For example:jsconst line = d3.line().curve(d3.curveBundle.beta(0.5));curveCardinal(context) ​Source · Produces a cubic cardinal spline using the specified control points, with one-sided differences used for the first and last piece. The default tension is 0.curveCardinalClosed(context) ​Source · Produces a closed cubic cardinal spline using the specified control points. When a line segment ends, the first three control points are repeated, producing a closed loop. The default tension is 0.curveCardinalOpen(context) ​Source · Produces a cubic cardinal spline using the specified control points. Unlike curveCardinal, one-sided differences are not used for the first and last piece, and thus the curve starts at the second point and ends at the penultimate point. The default tension is 0.curveCardinal.tension(tension) ​Tension:0.00Source · Returns a cardinal curve with the specified tension in the range [0, 1]. The tension determines the length of the tangents: a tension of one yields all zero tangents, equivalent to curveLinear; a tension of zero produces a uniform Catmull–Rom spline. For example:jsconst line = d3.line().curve(d3.curveCardinal.tension(0.5));curveCatmullRom(context) ​Source · Produces a cubic Catmull–Rom spline using the specified control points and the parameter alpha, which defaults to 0.5, as proposed by Yuksel et al. in On the Parameterization of Catmull–Rom Curves, with one-sided differences used for the first and last piece.curveCatmullRomClosed(context) ​Source · Produces a closed cubic Catmull–Rom spline using the specified control points and the parameter alpha, which defaults to 0.5, as proposed by Yuksel et al. When a line segment ends, the first three control points are repeated, producing a closed loop.curveCatmullRomOpen(context) ​Source · Produces a cubic Catmull–Rom spline using the specified control points and the parameter alpha, which defaults to 0.5, as proposed by Yuksel et al. Unlike curveCatmullRom, one-sided differences are not used for the first and last piece, and thus the curve starts at the second point and ends at the penultimate point.curveCatmullRom.alpha(alpha) ​Alpha:0.50Source · Returns a cubic Catmull–Rom curve with the specified alpha in the range [0, 1]. If alpha is zero, produces a uniform spline, equivalent to curveCardinal with a tension of zero; if alpha is one, produces a chordal spline; if alpha is 0.5, produces a centripetal spline. Centripetal splines are recommended to avoid self-intersections and overshoot. For example:jsconst line = d3.line().curve(d3.curveCatmullRom.alpha(0.5));curveLinear(context) ​Source · Produces a polyline through the specified points.curveLinearClosed(context) ​Source · Produces a closed polyline through the specified points by repeating the first point when the line segment ends.curveMonotoneX(context) ​Source · Produces a cubic spline that preserves monotonicity in y, assuming monotonicity in x, as proposed by Steffen in A simple method for monotonic interpolation in one dimension: “a smooth curve with continuous first-order derivatives that passes through any given set of data points without spurious oscillations. Local extrema can occur only at grid points where they are given by the data, but not in between two adjacent grid points.”curveMonotoneY(context) ​Source · Produces a cubic spline that preserves monotonicity in x, assuming monotonicity in y, as proposed by Steffen in A simple method for monotonic interpolation in one dimension: “a smooth curve with continuous first-order derivatives that passes through any given set of data points without spurious oscillations. Local extrema can occur only at grid points where they are given by the data, but not in between two adjacent grid points.”curveNatural(context) ​Source · Produces a natural cubic spline with the second derivative of the spline set to zero at the endpoints.curveStep(context) ​Source · Produces a piecewise constant function (a step function) consisting of alternating horizontal and vertical lines. The y-value changes at the midpoint of each pair of adjacent x-values.curveStepAfter(context) ​Source · Produces a piecewise constant function (a step function) consisting of alternating horizontal and vertical lines. The y-value changes after the x-value.curveStepBefore(context) ​Source · Produces a piecewise constant function (a step function) consisting of alternating horizontal and vertical lines. The y-value changes before the x-value.Custom curves ​Curves are typically not used directly, instead being passed to line.curve and area.curve. However, you can define your own curve implementation should none of the built-in curves satisfy your needs using the following interface; see the curveLinear source for an example implementation. You can also use this low-level interface with a built-in curve type as an alternative to the line and area generators.curve.areaStart() ​Indicates the start of a new area segment. Each area segment consists of exactly two line segments: the topline, followed by the baseline, with the baseline points in reverse order.curve.areaEnd() ​Indicates the end of the current area segment.curve.lineStart() ​Indicates the start of a new line segment. Zero or more points will follow.curve.lineEnd() ​Indicates the end of the current line segment.curve.point(x, y) ​Indicates a new point in the current line segment with the given x- and y-values.PagerPrevious pageAreasNext pageLines\n\nCurves ​Curves turn a discrete (pointwise) representation of a line or area into a continuous shape: curves specify how to interpolate between two-dimensional [x, y] points.Curves are typically not constructed or used directly. Instead, one of the built-in curves is being passed to line.curve or area.curve.jsconst line = d3.line()
    .x((d) => x(d.date))
    .y((d) => y(d.value))
    .curve(d3.curveCatmullRom.alpha(0.5));If desired, you can implement a custom curve. For an example of using a curve directly, see Context to Curve.curveBasis(context) ​Source · Produces a cubic basis spline using the specified control points. The first and last points are triplicated such that the spline starts at the first point and ends at the last point, and is tangent to the line between the first and second points, and to the line between the penultimate and last points.curveBasisClosed(context) ​Source · Produces a closed cubic basis spline using the specified control points. When a line segment ends, the first three control points are repeated, producing a closed loop with C2 continuity.curveBasisOpen(context) ​Source · Produces a cubic basis spline using the specified control points. Unlike basis, the first and last points are not repeated, and thus the curve typically does not intersect these points.curveBumpX(context) ​Source · Produces a Bézier curve between each pair of points, with horizontal tangents at each point.curveBumpY(context) ​Source · Produces a Bézier curve between each pair of points, with vertical tangents at each point.curveBundle(context) ​Source · Produces a straightened cubic basis spline using the specified control points, with the spline straightened according to the curve’s beta, which defaults to 0.85. This curve is typically used in hierarchical edge bundling to disambiguate connections, as proposed by Danny Holten in Hierarchical Edge Bundles: Visualization of Adjacency Relations in Hierarchical Data. This curve does not implement curve.areaStart and curve.areaEnd; it is intended to work with d3.line, not d3.area.curveBundle.beta(beta) ​Beta:0.85Source · Returns a bundle curve with the specified beta in the range [0, 1], representing the bundle strength. If beta equals zero, a straight line between the first and last point is produced; if beta equals one, a standard basis spline is produced. For example:jsconst line = d3.line().curve(d3.curveBundle.beta(0.5));curveCardinal(context) ​Source · Produces a cubic cardinal spline using the specified control points, with one-sided differences used for the first and last piece. The default tension is 0.curveCardinalClosed(context) ​Source · Produces a closed cubic cardinal spline using the specified control points. When a line segment ends, the first three control points are repeated, producing a closed loop. The default tension is 0.curveCardinalOpen(context) ​Source · Produces a cubic cardinal spline using the specified control points. Unlike curveCardinal, one-sided differences are not used for the first and last piece, and thus the curve starts at the second point and ends at the penultimate point. The default tension is 0.curveCardinal.tension(tension) ​Tension:0.00Source · Returns a cardinal curve with the specified tension in the range [0, 1]. The tension determines the length of the tangents: a tension of one yields all zero tangents, equivalent to curveLinear; a tension of zero produces a uniform Catmull–Rom spline. For example:jsconst line = d3.line().curve(d3.curveCardinal.tension(0.5));curveCatmullRom(context) ​Source · Produces a cubic Catmull–Rom spline using the specified control points and the parameter alpha, which defaults to 0.5, as proposed by Yuksel et al. in On the Parameterization of Catmull–Rom Curves, with one-sided differences used for the first and last piece.curveCatmullRomClosed(context) ​Source · Produces a closed cubic Catmull–Rom spline using the specified control points and the parameter alpha, which defaults to 0.5, as proposed by Yuksel et al. When a line segment ends, the first three control points are repeated, producing a closed loop.curveCatmullRomOpen(context) ​Source · Produces a cubic Catmull–Rom spline using the specified control points and the parameter alpha, which defaults to 0.5, as proposed by Yuksel et al. Unlike curveCatmullRom, one-sided differences are not used for the first and last piece, and thus the curve starts at the second point and ends at the penultimate point.curveCatmullRom.alpha(alpha) ​Alpha:0.50Source · Returns a cubic Catmull–Rom curve with the specified alpha in the range [0, 1]. If alpha is zero, produces a uniform spline, equivalent to curveCardinal with a tension of zero; if alpha is one, produces a chordal spline; if alpha is 0.5, produces a centripetal spline. Centripetal splines are recommended to avoid self-intersections and overshoot. For example:jsconst line = d3.line().curve(d3.curveCatmullRom.alpha(0.5));curveLinear(context) ​Source · Produces a polyline through the specified points.curveLinearClosed(context) ​Source · Produces a closed polyline through the specified points by repeating the first point when the line segment ends.curveMonotoneX(context) ​Source · Produces a cubic spline that preserves monotonicity in y, assuming monotonicity in x, as proposed by Steffen in A simple method for monotonic interpolation in one dimension: “a smooth curve with continuous first-order derivatives that passes through any given set of data points without spurious oscillations. Local extrema can occur only at grid points where they are given by the data, but not in between two adjacent grid points.”curveMonotoneY(context) ​Source · Produces a cubic spline that preserves monotonicity in x, assuming monotonicity in y, as proposed by Steffen in A simple method for monotonic interpolation in one dimension: “a smooth curve with continuous first-order derivatives that passes through any given set of data points without spurious oscillations. Local extrema can occur only at grid points where they are given by the data, but not in between two adjacent grid points.”curveNatural(context) ​Source · Produces a natural cubic spline with the second derivative of the spline set to zero at the endpoints.curveStep(context) ​Source · Produces a piecewise constant function (a step function) consisting of alternating horizontal and vertical lines. The y-value changes at the midpoint of each pair of adjacent x-values.curveStepAfter(context) ​Source · Produces a piecewise constant function (a step function) consisting of alternating horizontal and vertical lines. The y-value changes after the x-value.curveStepBefore(context) ​Source · Produces a piecewise constant function (a step function) consisting of alternating horizontal and vertical lines. The y-value changes before the x-value.Custom curves ​Curves are typically not used directly, instead being passed to line.curve and area.curve. However, you can define your own curve implementation should none of the built-in curves satisfy your needs using the following interface; see the curveLinear source for an example implementation. You can also use this low-level interface with a built-in curve type as an alternative to the line and area generators.curve.areaStart() ​Indicates the start of a new area segment. Each area segment consists of exactly two line segments: the topline, followed by the baseline, with the baseline points in reverse order.curve.areaEnd() ​Indicates the end of the current area segment.curve.lineStart() ​Indicates the start of a new line segment. Zero or more points will follow.curve.lineEnd() ​Indicates the end of the current line segment.curve.point(x, y) ​Indicates a new point in the current line segment with the given x- and y-values.\n\n\n\nLines ​Examples · The line generator produces a spline or polyline as in a line chart. Lines also appear in many other visualization types, such as the links in hierarchical edge bundling. See also radial lines.line(x, y) ​Source · Constructs a new line generator with the given x and y accessor.jsconst line = d3.line((d) => x(d.Date), (d) => y(d.Close));If x or y are not specified, the respective defaults will be used. The above can be expressed more explicitly as:jsconst line = d3.line()
    .x((d) => x(d.Date))
    .y((d) => y(d.Close));line(data) ​Source · Generates a line for the given array of data.jssvg.append("path").attr("d", line(data)).attr("stroke", "currentColor");If the line generator has a context, then the line is rendered to this context as a sequence of path method calls and this function returns void. Otherwise, a path data string is returned.CAUTIONDepending on this line generator’s associated curve, the given input data may need to be sorted by x-value before being passed to the line generator.line.x(x) ​Source · If x is specified, sets the x accessor to the specified function or number and returns this line generator.jsconst line = d3.line().x((d) => x(d.Date));If x is not specified, returns the current x accessor.jsline.x() // (d) => x(d.Date)The x accessor defaults to:jsfunction x(d) {
  return d[0];
}When a line is generated, the x accessor will be invoked for each defined element in the input data array, being passed the element d, the index i, and the array data as three arguments.The default x accessor assumes that the input data are two-element arrays of numbers. If your data are in a different format, or if you wish to transform the data before rendering, then you should specify a custom accessor.line.y(y) ​Source · If y is specified, sets the y accessor to the specified function or number and returns this line generator.jsconst line = d3.line().y((d) => y(d.Close));When a line is generated, the y accessor will be invoked for each defined element in the input data array, being passed the element d, the index i, and the array data as three arguments.If y is not specified, returns the current y accessor.jsline.y() // (d) => y(d.Close)The y accessor defaults to:jsfunction y(d) {
  return d[1];
}The default y accessor assumes that the input data are two-element arrays of numbers. See line.x for more information.line.defined(defined) ​Examples · Source · If defined is specified, sets the defined accessor to the specified function or boolean and returns this line generator.jsconst line = d3.line().defined((d) => !isNaN(d.Close));When a line is generated, the defined accessor will be invoked for each element in the input data array, being passed the element d, the index i, and the array data as three arguments. If the given element is defined (i.e., if the defined accessor returns a truthy value for this element), the x and y accessors will subsequently be evaluated and the point will be added to the current line segment. Otherwise, the element will be skipped, the current line segment will be ended, and a new line segment will be generated for the next defined point.If defined is not specified, returns the current defined accessor.jsline.defined() // (d) => !isNaN(d.Close)The defined accessor defaults to the constant true, and assumes that the input data is always defined:jsfunction defined() {
  return true;
}Note that if a line segment consists of only a single point, it may appear invisible unless rendered with rounded or square line caps. In addition, some curves such as curveCardinalOpen only render a visible segment if it contains multiple points.line.curve(curve) ​Source · If curve is specified, sets the curve factory and returns this line generator.jsconst line = d3.line().curve(d3.curveStep);If curve is not specified, returns the current curve factory, which defaults to curveLinear.jsline.curve() // d3.curveStepline.context(context) ​Source · If context is specified, sets the context and returns this line generator.jsconst context = canvas.getContext("2d");
const line = d3.line().context(context);If context is not specified, returns the current context.jsline.context() // contextThe context defaults to null. If the context is not null, then the generated line is rendered to this context as a sequence of path method calls. Otherwise, a path data string representing the generated line is returned.line.digits(digits) ​Source · If digits is specified, sets the maximum number of digits after the decimal separator and returns this line generator.jsconst line = d3.line().digits(3);If digits is not specified, returns the current maximum fraction digits, which defaults to 3.jsline.digits() // 3This option only applies when the associated context is null, as when this line generator is used to produce path data.\n\nSearchK7.9.0GitHub️ 110.0kOn this pageLines ​Examples · The line generator produces a spline or polyline as in a line chart. Lines also appear in many other visualization types, such as the links in hierarchical edge bundling. See also radial lines.line(x, y) ​Source · Constructs a new line generator with the given x and y accessor.jsconst line = d3.line((d) => x(d.Date), (d) => y(d.Close));If x or y are not specified, the respective defaults will be used. The above can be expressed more explicitly as:jsconst line = d3.line()
    .x((d) => x(d.Date))
    .y((d) => y(d.Close));line(data) ​Source · Generates a line for the given array of data.jssvg.append("path").attr("d", line(data)).attr("stroke", "currentColor");If the line generator has a context, then the line is rendered to this context as a sequence of path method calls and this function returns void. Otherwise, a path data string is returned.CAUTIONDepending on this line generator’s associated curve, the given input data may need to be sorted by x-value before being passed to the line generator.line.x(x) ​Source · If x is specified, sets the x accessor to the specified function or number and returns this line generator.jsconst line = d3.line().x((d) => x(d.Date));If x is not specified, returns the current x accessor.jsline.x() // (d) => x(d.Date)The x accessor defaults to:jsfunction x(d) {
  return d[0];
}When a line is generated, the x accessor will be invoked for each defined element in the input data array, being passed the element d, the index i, and the array data as three arguments.The default x accessor assumes that the input data are two-element arrays of numbers. If your data are in a different format, or if you wish to transform the data before rendering, then you should specify a custom accessor.line.y(y) ​Source · If y is specified, sets the y accessor to the specified function or number and returns this line generator.jsconst line = d3.line().y((d) => y(d.Close));When a line is generated, the y accessor will be invoked for each defined element in the input data array, being passed the element d, the index i, and the array data as three arguments.If y is not specified, returns the current y accessor.jsline.y() // (d) => y(d.Close)The y accessor defaults to:jsfunction y(d) {
  return d[1];
}The default y accessor assumes that the input data are two-element arrays of numbers. See line.x for more information.line.defined(defined) ​Examples · Source · If defined is specified, sets the defined accessor to the specified function or boolean and returns this line generator.jsconst line = d3.line().defined((d) => !isNaN(d.Close));When a line is generated, the defined accessor will be invoked for each element in the input data array, being passed the element d, the index i, and the array data as three arguments. If the given element is defined (i.e., if the defined accessor returns a truthy value for this element), the x and y accessors will subsequently be evaluated and the point will be added to the current line segment. Otherwise, the element will be skipped, the current line segment will be ended, and a new line segment will be generated for the next defined point.If defined is not specified, returns the current defined accessor.jsline.defined() // (d) => !isNaN(d.Close)The defined accessor defaults to the constant true, and assumes that the input data is always defined:jsfunction defined() {
  return true;
}Note that if a line segment consists of only a single point, it may appear invisible unless rendered with rounded or square line caps. In addition, some curves such as curveCardinalOpen only render a visible segment if it contains multiple points.line.curve(curve) ​Source · If curve is specified, sets the curve factory and returns this line generator.jsconst line = d3.line().curve(d3.curveStep);If curve is not specified, returns the current curve factory, which defaults to curveLinear.jsline.curve() // d3.curveStepline.context(context) ​Source · If context is specified, sets the context and returns this line generator.jsconst context = canvas.getContext("2d");
const line = d3.line().context(context);If context is not specified, returns the current context.jsline.context() // contextThe context defaults to null. If the context is not null, then the generated line is rendered to this context as a sequence of path method calls. Otherwise, a path data string representing the generated line is returned.line.digits(digits) ​Source · If digits is specified, sets the maximum number of digits after the decimal separator and returns this line generator.jsconst line = d3.line().digits(3);If digits is not specified, returns the current maximum fraction digits, which defaults to 3.jsline.digits() // 3This option only applies when the associated context is null, as when this line generator is used to produce path data.PagerPrevious pageCurvesNext pageLinks\n\nLines ​Examples · The line generator produces a spline or polyline as in a line chart. Lines also appear in many other visualization types, such as the links in hierarchical edge bundling. See also radial lines.line(x, y) ​Source · Constructs a new line generator with the given x and y accessor.jsconst line = d3.line((d) => x(d.Date), (d) => y(d.Close));If x or y are not specified, the respective defaults will be used. The above can be expressed more explicitly as:jsconst line = d3.line()
    .x((d) => x(d.Date))
    .y((d) => y(d.Close));line(data) ​Source · Generates a line for the given array of data.jssvg.append("path").attr("d", line(data)).attr("stroke", "currentColor");If the line generator has a context, then the line is rendered to this context as a sequence of path method calls and this function returns void. Otherwise, a path data string is returned.CAUTIONDepending on this line generator’s associated curve, the given input data may need to be sorted by x-value before being passed to the line generator.line.x(x) ​Source · If x is specified, sets the x accessor to the specified function or number and returns this line generator.jsconst line = d3.line().x((d) => x(d.Date));If x is not specified, returns the current x accessor.jsline.x() // (d) => x(d.Date)The x accessor defaults to:jsfunction x(d) {
  return d[0];
}When a line is generated, the x accessor will be invoked for each defined element in the input data array, being passed the element d, the index i, and the array data as three arguments.The default x accessor assumes that the input data are two-element arrays of numbers. If your data are in a different format, or if you wish to transform the data before rendering, then you should specify a custom accessor.line.y(y) ​Source · If y is specified, sets the y accessor to the specified function or number and returns this line generator.jsconst line = d3.line().y((d) => y(d.Close));When a line is generated, the y accessor will be invoked for each defined element in the input data array, being passed the element d, the index i, and the array data as three arguments.If y is not specified, returns the current y accessor.jsline.y() // (d) => y(d.Close)The y accessor defaults to:jsfunction y(d) {
  return d[1];
}The default y accessor assumes that the input data are two-element arrays of numbers. See line.x for more information.line.defined(defined) ​Examples · Source · If defined is specified, sets the defined accessor to the specified function or boolean and returns this line generator.jsconst line = d3.line().defined((d) => !isNaN(d.Close));When a line is generated, the defined accessor will be invoked for each element in the input data array, being passed the element d, the index i, and the array data as three arguments. If the given element is defined (i.e., if the defined accessor returns a truthy value for this element), the x and y accessors will subsequently be evaluated and the point will be added to the current line segment. Otherwise, the element will be skipped, the current line segment will be ended, and a new line segment will be generated for the next defined point.If defined is not specified, returns the current defined accessor.jsline.defined() // (d) => !isNaN(d.Close)The defined accessor defaults to the constant true, and assumes that the input data is always defined:jsfunction defined() {
  return true;
}Note that if a line segment consists of only a single point, it may appear invisible unless rendered with rounded or square line caps. In addition, some curves such as curveCardinalOpen only render a visible segment if it contains multiple points.line.curve(curve) ​Source · If curve is specified, sets the curve factory and returns this line generator.jsconst line = d3.line().curve(d3.curveStep);If curve is not specified, returns the current curve factory, which defaults to curveLinear.jsline.curve() // d3.curveStepline.context(context) ​Source · If context is specified, sets the context and returns this line generator.jsconst context = canvas.getContext("2d");
const line = d3.line().context(context);If context is not specified, returns the current context.jsline.context() // contextThe context defaults to null. If the context is not null, then the generated line is rendered to this context as a sequence of path method calls. Otherwise, a path data string representing the generated line is returned.line.digits(digits) ​Source · If digits is specified, sets the maximum number of digits after the decimal separator and returns this line generator.jsconst line = d3.line().digits(3);If digits is not specified, returns the current maximum fraction digits, which defaults to 3.jsline.digits() // 3This option only applies when the associated context is null, as when this line generator is used to produce path data.\n\n\n\nLinks ​Examples · The link shape generates a smooth cubic Bézier curve from a source point to a target point. The tangents of the curve at the start and end are either vertical or horizontal. See also radial links.link(curve) ​Source · Returns a new link generator using the specified curve. For example, to visualize links in a tree diagram rooted on the top edge of the display, you might say:jsconst link = d3.link(d3.curveBumpY)
    .x((d) => d.x)
    .y((d) => d.y);linkVertical() ​Source · Shorthand for link with curveBumpY; suitable for visualizing links in a tree diagram rooted on the top edge of the display. Equivalent to:jsconst link = d3.link(d3.curveBumpY);linkHorizontal() ​Source · Shorthand for link with curveBumpX; suitable for visualizing links in a tree diagram rooted on the left edge of the display. Equivalent to:jsconst link = d3.link(d3.curveBumpX);link(...arguments) ​Source · Generates a link for the given arguments. The arguments are arbitrary; they are propagated to the link generator’s accessor functions along with the this object. With the default settings, an object with source and target properties is expected.jslink({source: [100, 100], target: [300, 300]}) // "M100,100C200,100,200,300,300,300"link.source(source) ​Source · If source is specified, sets the source accessor to the specified function and returns this link generator.jsconst link = d3.linkHorizontal().source((d) => d[0]);If source is not specified, returns the current source accessor.jslink.source() // (d) => d[0]The source accessor defaults to:jsfunction source(d) {
  return d.source;
}link.target(target) ​Source · If target is specified, sets the target accessor to the specified function and returns this link generator.jsconst link = d3.linkHorizontal().target((d) => d[1]);If target is not specified, returns the current target accessor.jslink.target() // (d) => d[1]The target accessor defaults to:jsfunction target(d) {
  return d.target;
}link.x(x) ​Source · If x is specified, sets the x-accessor to the specified function or number and returns this link generator.jsconst link = d3.linkHorizontal().x((d) => x(d.x));If x is not specified, returns the current x accessor.jslink.x() // (d) => x(d.x)The x accessor defaults to:jsfunction x(d) {
  return d[0];
}link.y(y) ​Source · If y is specified, sets the y-accessor to the specified function or number and returns this link generator.jsconst link = d3.linkHorizontal().y((d) => y(d.y));If y is not specified, returns the current y accessor.jslink.y() // (d) => y(d.y)The y accessor defaults to:jsfunction y(d) {
  return d[1];
}link.context(context) ​Source · If context is specified, sets the context and returns this link generator.jsconst context = canvas.getContext("2d");
const link = d3.link().context(context);If context is not specified, returns the current context.jslink.context() // contextThe context defaults to null. If the context is not null, then the generated link is rendered to this context as a sequence of path method calls. Otherwise, a path data string representing the generated link is returned. See also d3-path.link.digits(digits) ​Source · If digits is specified, sets the maximum number of digits after the decimal separator and returns this link generator.jsconst link = d3.link().digits(3);If digits is not specified, returns the current maximum fraction digits, which defaults to 3.jslink.digits() // 3This option only applies when the associated context is null, as when this link generator is used to produce path data.\n\nSearchK7.9.0GitHub️ 110.0kOn this pageLinks ​Examples · The link shape generates a smooth cubic Bézier curve from a source point to a target point. The tangents of the curve at the start and end are either vertical or horizontal. See also radial links.link(curve) ​Source · Returns a new link generator using the specified curve. For example, to visualize links in a tree diagram rooted on the top edge of the display, you might say:jsconst link = d3.link(d3.curveBumpY)
    .x((d) => d.x)
    .y((d) => d.y);linkVertical() ​Source · Shorthand for link with curveBumpY; suitable for visualizing links in a tree diagram rooted on the top edge of the display. Equivalent to:jsconst link = d3.link(d3.curveBumpY);linkHorizontal() ​Source · Shorthand for link with curveBumpX; suitable for visualizing links in a tree diagram rooted on the left edge of the display. Equivalent to:jsconst link = d3.link(d3.curveBumpX);link(...arguments) ​Source · Generates a link for the given arguments. The arguments are arbitrary; they are propagated to the link generator’s accessor functions along with the this object. With the default settings, an object with source and target properties is expected.jslink({source: [100, 100], target: [300, 300]}) // "M100,100C200,100,200,300,300,300"link.source(source) ​Source · If source is specified, sets the source accessor to the specified function and returns this link generator.jsconst link = d3.linkHorizontal().source((d) => d[0]);If source is not specified, returns the current source accessor.jslink.source() // (d) => d[0]The source accessor defaults to:jsfunction source(d) {
  return d.source;
}link.target(target) ​Source · If target is specified, sets the target accessor to the specified function and returns this link generator.jsconst link = d3.linkHorizontal().target((d) => d[1]);If target is not specified, returns the current target accessor.jslink.target() // (d) => d[1]The target accessor defaults to:jsfunction target(d) {
  return d.target;
}link.x(x) ​Source · If x is specified, sets the x-accessor to the specified function or number and returns this link generator.jsconst link = d3.linkHorizontal().x((d) => x(d.x));If x is not specified, returns the current x accessor.jslink.x() // (d) => x(d.x)The x accessor defaults to:jsfunction x(d) {
  return d[0];
}link.y(y) ​Source · If y is specified, sets the y-accessor to the specified function or number and returns this link generator.jsconst link = d3.linkHorizontal().y((d) => y(d.y));If y is not specified, returns the current y accessor.jslink.y() // (d) => y(d.y)The y accessor defaults to:jsfunction y(d) {
  return d[1];
}link.context(context) ​Source · If context is specified, sets the context and returns this link generator.jsconst context = canvas.getContext("2d");
const link = d3.link().context(context);If context is not specified, returns the current context.jslink.context() // contextThe context defaults to null. If the context is not null, then the generated link is rendered to this context as a sequence of path method calls. Otherwise, a path data string representing the generated link is returned. See also d3-path.link.digits(digits) ​Source · If digits is specified, sets the maximum number of digits after the decimal separator and returns this link generator.jsconst link = d3.link().digits(3);If digits is not specified, returns the current maximum fraction digits, which defaults to 3.jslink.digits() // 3This option only applies when the associated context is null, as when this link generator is used to produce path data.PagerPrevious pageLinesNext pagePies\n\nLinks ​Examples · The link shape generates a smooth cubic Bézier curve from a source point to a target point. The tangents of the curve at the start and end are either vertical or horizontal. See also radial links.link(curve) ​Source · Returns a new link generator using the specified curve. For example, to visualize links in a tree diagram rooted on the top edge of the display, you might say:jsconst link = d3.link(d3.curveBumpY)
    .x((d) => d.x)
    .y((d) => d.y);linkVertical() ​Source · Shorthand for link with curveBumpY; suitable for visualizing links in a tree diagram rooted on the top edge of the display. Equivalent to:jsconst link = d3.link(d3.curveBumpY);linkHorizontal() ​Source · Shorthand for link with curveBumpX; suitable for visualizing links in a tree diagram rooted on the left edge of the display. Equivalent to:jsconst link = d3.link(d3.curveBumpX);link(...arguments) ​Source · Generates a link for the given arguments. The arguments are arbitrary; they are propagated to the link generator’s accessor functions along with the this object. With the default settings, an object with source and target properties is expected.jslink({source: [100, 100], target: [300, 300]}) // "M100,100C200,100,200,300,300,300"link.source(source) ​Source · If source is specified, sets the source accessor to the specified function and returns this link generator.jsconst link = d3.linkHorizontal().source((d) => d[0]);If source is not specified, returns the current source accessor.jslink.source() // (d) => d[0]The source accessor defaults to:jsfunction source(d) {
  return d.source;
}link.target(target) ​Source · If target is specified, sets the target accessor to the specified function and returns this link generator.jsconst link = d3.linkHorizontal().target((d) => d[1]);If target is not specified, returns the current target accessor.jslink.target() // (d) => d[1]The target accessor defaults to:jsfunction target(d) {
  return d.target;
}link.x(x) ​Source · If x is specified, sets the x-accessor to the specified function or number and returns this link generator.jsconst link = d3.linkHorizontal().x((d) => x(d.x));If x is not specified, returns the current x accessor.jslink.x() // (d) => x(d.x)The x accessor defaults to:jsfunction x(d) {
  return d[0];
}link.y(y) ​Source · If y is specified, sets the y-accessor to the specified function or number and returns this link generator.jsconst link = d3.linkHorizontal().y((d) => y(d.y));If y is not specified, returns the current y accessor.jslink.y() // (d) => y(d.y)The y accessor defaults to:jsfunction y(d) {
  return d[1];
}link.context(context) ​Source · If context is specified, sets the context and returns this link generator.jsconst context = canvas.getContext("2d");
const link = d3.link().context(context);If context is not specified, returns the current context.jslink.context() // contextThe context defaults to null. If the context is not null, then the generated link is rendered to this context as a sequence of path method calls. Otherwise, a path data string representing the generated link is returned. See also d3-path.link.digits(digits) ​Source · If digits is specified, sets the maximum number of digits after the decimal separator and returns this link generator.jsconst link = d3.link().digits(3);If digits is not specified, returns the current maximum fraction digits, which defaults to 3.jslink.digits() // 3This option only applies when the associated context is null, as when this link generator is used to produce path data.\n\n\n\nPies ​Examples · The pie generator computes the necessary angles to represent a tabular dataset as a pie or donut chart; these angles can then be passed to an arc generator. (The pie generator does not produce a shape directly.)pie() ​Source · Constructs a new pie generator with the default settings.jsconst pie = d3.pie();pie(data, ...arguments) ​Source · Generates a pie for the given array of data, returning an array of objects representing each datum’s arc angles. For example, given a set of numbers, here is how to compute the angles for a pie chart:jsconst data = [1, 1, 2, 3, 5, 8, 13, 21];
const pie = d3.pie();
const arcs = pie(data);The resulting arcs is an array of objects:json[
  {"data":  1, "value":  1, "index": 6, "startAngle": 6.050474740247008, "endAngle": 6.166830023713296, "padAngle": 0},
  {"data":  1, "value":  1, "index": 7, "startAngle": 6.166830023713296, "endAngle": 6.283185307179584, "padAngle": 0},
  {"data":  2, "value":  2, "index": 5, "startAngle": 5.817764173314431, "endAngle": 6.050474740247008, "padAngle": 0},
  {"data":  3, "value":  3, "index": 4, "startAngle": 5.468698322915565, "endAngle": 5.817764173314431, "padAngle": 0},
  {"data":  5, "value":  5, "index": 3, "startAngle": 4.886921905584122, "endAngle": 5.468698322915565, "padAngle": 0},
  {"data":  8, "value":  8, "index": 2, "startAngle": 3.956079637853813, "endAngle": 4.886921905584122, "padAngle": 0},
  {"data": 13, "value": 13, "index": 1, "startAngle": 2.443460952792061, "endAngle": 3.956079637853813, "padAngle": 0},
  {"data": 21, "value": 21, "index": 0, "startAngle": 0.000000000000000, "endAngle": 2.443460952792061, "padAngle": 0}
]Each object in the returned array has the following properties:data - the input datum; the corresponding element in the input data array.value - the numeric value of the arc.index - the zero-based sorted index of the arc.startAngle - the start angle of the arc.endAngle - the end angle of the arc.padAngle - the pad angle of the arc.This representation is designed to work with the arc generator’s default startAngle, endAngle and padAngle accessors. Angles are in radians, with 0 at -y (12 o’clock) and positive angles proceeding clockwise.The length of the returned array is the same as data, and each element i in the returned array corresponds to the element i in the input data. The returned array of arcs is in the same order as the data, even when the pie chart is sorted.Any additional arguments are arbitrary; they are propagated to the pie generator’s accessor functions along with the this object.pie.value(value) ​Source · If value is specified, sets the value accessor to the specified function or number and returns this pie generator.jsconst pie = d3.pie().value((d) => d.value);When a pie is generated, the value accessor will be invoked for each element in the input data array, being passed the element d, the index i, and the array data as three arguments.If value is not specified, returns the current value accessor.jspie.value() // (d) => d.valueThe value accessor defaults to:jsfunction value(d) {
  return d;
}The default value accessor assumes that the input data are numbers, or that they are coercible to numbers using valueOf. If your data are not numbers, then you should specify an accessor that returns the corresponding numeric value for a given datum. For example, given a CSV file with number and name fields:number,name
4,Locke
8,Reyes
15,Ford
16,Jarrah
23,Shephard
42,KwonYou might say:jsconst data = await d3.csv("lost.csv", d3.autoType);
const pie = d3.pie().value((d) => d.number);
const arcs = pie(data);This is similar to mapping your data to values before invoking the pie generator:jsconst arcs = d3.pie()(data.map((d) => d.number));The benefit of an accessor is that the input data remains associated with the returned objects, thereby making it easier to access other fields of the data, for example to set the color or to add text labels.pie.sort(compare) ​Source · If compare is specified, sets the data comparator to the specified function and returns this pie generator.jsconst pie = d3.pie().sort((a, b) => d3.ascending(a.name, b.name));The data comparator takes two arguments a and b, each elements from the input data array. If the arc for a should be before the arc for b, then the comparator must return a number less than zero; if the arc for a should be after the arc for b, then the comparator must return a number greater than zero; returning zero means that the relative order of a and b is unspecified.If compare is not specified, returns the current data comparator.jspie.sort() // (a, b) => d3.ascending(a.name, b.name))The data comparator defaults to null. If both the data comparator and the value comparator are null, then arcs are positioned in the original input order. Setting the data comparator implicitly sets the value comparator to null.Sorting does not affect the order of the generated arc array which is always in the same order as the input data array; it only affects the computed angles of each arc. The first arc starts at the start angle and the last arc ends at the end angle.pie.sortValues(compare) ​Source · If compare is specified, sets the value comparator to the specified function and returns this pie generator.jsconst pie = d3.pie().sortValues(d3.ascending);The value comparator is similar to the data comparator, except the two arguments a and b are values derived from the input data array using the value accessor rather than the data elements. If the arc for a should be before the arc for b, then the comparator must return a number less than zero; if the arc for a should be after the arc for b, then the comparator must return a number greater than zero; returning zero means that the relative order of a and b is unspecified.If compare is not specified, returns the current value comparator.jspie.sortValues() // d3.ascendingThe value comparator defaults to descending. If both the data comparator and the value comparator are null, then arcs are positioned in the original input order. Setting the value comparator implicitly sets the data comparator to null.Sorting does not affect the order of the generated arc array which is always in the same order as the input data array; it merely affects the computed angles of each arc. The first arc starts at the start angle and the last arc ends at the end angle.pie.startAngle(angle) ​Source · If angle is specified, sets the overall start angle of the pie to the specified function or number and returns this pie generator.jsconst pie = d3.pie().startAngle(0);The start angle is the overall start angle of the pie, i.e., the start angle of the first arc. It is typically expressed as a constant number but can also be expressed as a function of data. When a function, the start angle accessor is invoked once, being passed the same arguments and this context as the pie generator.If angle is not specified, returns the current start angle accessor.jspie.startAngle() // () => 0The start angle accessor defaults to:jsfunction startAngle() {
  return 0;
}Angles are in radians, with 0 at -y (12 o’clock) and positive angles proceeding clockwise.pie.endAngle(angle) ​Source · If angle is specified, sets the overall end angle of the pie to the specified function or number and returns this pie generator.jsconst pie = d3.pie().endAngle(Math.PI);The end angle here means the overall end angle of the pie, i.e., the end angle of the last arc. It is typically expressed as a constant number but can also be expressed as a function of data. When a function, the end angle accessor is invoked once, being passed the same arguments and this context as the pie generator.If angle is not specified, returns the current end angle accessor.jspie.endAngle() // () => Math.PIThe end angle accessor defaults to:jsfunction endAngle() {
  return 2 * Math.PI;
}Angles are in radians, with 0 at -y (12 o’clock) and positive angles proceeding clockwise. The value of the end angle is constrained to startAngle ± τ, such that |endAngle - startAngle| ≤ τ.pie.padAngle(angle) ​Pad angle:0.030Examples · Source · If angle is specified, sets the pad angle to the specified function or number and returns this pie generator.jsconst pie = d3.pie().padAngle(0.03);The pad angle specifies the angular separation in radians between adjacent arcs. The total amount of padding is the specified angle times the number of elements in the input data array, and at most |endAngle - startAngle|; the remaining space is divided proportionally by value such that the relative area of each arc is preserved.The pad angle is typically expressed as a constant number but can also be expressed as a function of data. When a function, the pad angle accessor is invoked once, being passed the same arguments and this context as the pie generator.If angle is not specified, returns the current pad angle accessor.jspie.padAngle() // () => 0.03The pad angle accessor defaults to:jsfunction padAngle() {
  return 0;
}\n\nSearchK7.9.0GitHub️ 110.0kOn this pagePies ​Examples · The pie generator computes the necessary angles to represent a tabular dataset as a pie or donut chart; these angles can then be passed to an arc generator. (The pie generator does not produce a shape directly.)pie() ​Source · Constructs a new pie generator with the default settings.jsconst pie = d3.pie();pie(data, ...arguments) ​Source · Generates a pie for the given array of data, returning an array of objects representing each datum’s arc angles. For example, given a set of numbers, here is how to compute the angles for a pie chart:jsconst data = [1, 1, 2, 3, 5, 8, 13, 21];
const pie = d3.pie();
const arcs = pie(data);The resulting arcs is an array of objects:json[
  {"data":  1, "value":  1, "index": 6, "startAngle": 6.050474740247008, "endAngle": 6.166830023713296, "padAngle": 0},
  {"data":  1, "value":  1, "index": 7, "startAngle": 6.166830023713296, "endAngle": 6.283185307179584, "padAngle": 0},
  {"data":  2, "value":  2, "index": 5, "startAngle": 5.817764173314431, "endAngle": 6.050474740247008, "padAngle": 0},
  {"data":  3, "value":  3, "index": 4, "startAngle": 5.468698322915565, "endAngle": 5.817764173314431, "padAngle": 0},
  {"data":  5, "value":  5, "index": 3, "startAngle": 4.886921905584122, "endAngle": 5.468698322915565, "padAngle": 0},
  {"data":  8, "value":  8, "index": 2, "startAngle": 3.956079637853813, "endAngle": 4.886921905584122, "padAngle": 0},
  {"data": 13, "value": 13, "index": 1, "startAngle": 2.443460952792061, "endAngle": 3.956079637853813, "padAngle": 0},
  {"data": 21, "value": 21, "index": 0, "startAngle": 0.000000000000000, "endAngle": 2.443460952792061, "padAngle": 0}
]Each object in the returned array has the following properties:data - the input datum; the corresponding element in the input data array.value - the numeric value of the arc.index - the zero-based sorted index of the arc.startAngle - the start angle of the arc.endAngle - the end angle of the arc.padAngle - the pad angle of the arc.This representation is designed to work with the arc generator’s default startAngle, endAngle and padAngle accessors. Angles are in radians, with 0 at -y (12 o’clock) and positive angles proceeding clockwise.The length of the returned array is the same as data, and each element i in the returned array corresponds to the element i in the input data. The returned array of arcs is in the same order as the data, even when the pie chart is sorted.Any additional arguments are arbitrary; they are propagated to the pie generator’s accessor functions along with the this object.pie.value(value) ​Source · If value is specified, sets the value accessor to the specified function or number and returns this pie generator.jsconst pie = d3.pie().value((d) => d.value);When a pie is generated, the value accessor will be invoked for each element in the input data array, being passed the element d, the index i, and the array data as three arguments.If value is not specified, returns the current value accessor.jspie.value() // (d) => d.valueThe value accessor defaults to:jsfunction value(d) {
  return d;
}The default value accessor assumes that the input data are numbers, or that they are coercible to numbers using valueOf. If your data are not numbers, then you should specify an accessor that returns the corresponding numeric value for a given datum. For example, given a CSV file with number and name fields:number,name
4,Locke
8,Reyes
15,Ford
16,Jarrah
23,Shephard
42,KwonYou might say:jsconst data = await d3.csv("lost.csv", d3.autoType);
const pie = d3.pie().value((d) => d.number);
const arcs = pie(data);This is similar to mapping your data to values before invoking the pie generator:jsconst arcs = d3.pie()(data.map((d) => d.number));The benefit of an accessor is that the input data remains associated with the returned objects, thereby making it easier to access other fields of the data, for example to set the color or to add text labels.pie.sort(compare) ​Source · If compare is specified, sets the data comparator to the specified function and returns this pie generator.jsconst pie = d3.pie().sort((a, b) => d3.ascending(a.name, b.name));The data comparator takes two arguments a and b, each elements from the input data array. If the arc for a should be before the arc for b, then the comparator must return a number less than zero; if the arc for a should be after the arc for b, then the comparator must return a number greater than zero; returning zero means that the relative order of a and b is unspecified.If compare is not specified, returns the current data comparator.jspie.sort() // (a, b) => d3.ascending(a.name, b.name))The data comparator defaults to null. If both the data comparator and the value comparator are null, then arcs are positioned in the original input order. Setting the data comparator implicitly sets the value comparator to null.Sorting does not affect the order of the generated arc array which is always in the same order as the input data array; it only affects the computed angles of each arc. The first arc starts at the start angle and the last arc ends at the end angle.pie.sortValues(compare) ​Source · If compare is specified, sets the value comparator to the specified function and returns this pie generator.jsconst pie = d3.pie().sortValues(d3.ascending);The value comparator is similar to the data comparator, except the two arguments a and b are values derived from the input data array using the value accessor rather than the data elements. If the arc for a should be before the arc for b, then the comparator must return a number less than zero; if the arc for a should be after the arc for b, then the comparator must return a number greater than zero; returning zero means that the relative order of a and b is unspecified.If compare is not specified, returns the current value comparator.jspie.sortValues() // d3.ascendingThe value comparator defaults to descending. If both the data comparator and the value comparator are null, then arcs are positioned in the original input order. Setting the value comparator implicitly sets the data comparator to null.Sorting does not affect the order of the generated arc array which is always in the same order as the input data array; it merely affects the computed angles of each arc. The first arc starts at the start angle and the last arc ends at the end angle.pie.startAngle(angle) ​Source · If angle is specified, sets the overall start angle of the pie to the specified function or number and returns this pie generator.jsconst pie = d3.pie().startAngle(0);The start angle is the overall start angle of the pie, i.e., the start angle of the first arc. It is typically expressed as a constant number but can also be expressed as a function of data. When a function, the start angle accessor is invoked once, being passed the same arguments and this context as the pie generator.If angle is not specified, returns the current start angle accessor.jspie.startAngle() // () => 0The start angle accessor defaults to:jsfunction startAngle() {
  return 0;
}Angles are in radians, with 0 at -y (12 o’clock) and positive angles proceeding clockwise.pie.endAngle(angle) ​Source · If angle is specified, sets the overall end angle of the pie to the specified function or number and returns this pie generator.jsconst pie = d3.pie().endAngle(Math.PI);The end angle here means the overall end angle of the pie, i.e., the end angle of the last arc. It is typically expressed as a constant number but can also be expressed as a function of data. When a function, the end angle accessor is invoked once, being passed the same arguments and this context as the pie generator.If angle is not specified, returns the current end angle accessor.jspie.endAngle() // () => Math.PIThe end angle accessor defaults to:jsfunction endAngle() {
  return 2 * Math.PI;
}Angles are in radians, with 0 at -y (12 o’clock) and positive angles proceeding clockwise. The value of the end angle is constrained to startAngle ± τ, such that |endAngle - startAngle| ≤ τ.pie.padAngle(angle) ​Pad angle:0.030Examples · Source · If angle is specified, sets the pad angle to the specified function or number and returns this pie generator.jsconst pie = d3.pie().padAngle(0.03);The pad angle specifies the angular separation in radians between adjacent arcs. The total amount of padding is the specified angle times the number of elements in the input data array, and at most |endAngle - startAngle|; the remaining space is divided proportionally by value such that the relative area of each arc is preserved.The pad angle is typically expressed as a constant number but can also be expressed as a function of data. When a function, the pad angle accessor is invoked once, being passed the same arguments and this context as the pie generator.If angle is not specified, returns the current pad angle accessor.jspie.padAngle() // () => 0.03The pad angle accessor defaults to:jsfunction padAngle() {
  return 0;
}PagerPrevious pageLinksNext pageStacks\n\nPies ​Examples · The pie generator computes the necessary angles to represent a tabular dataset as a pie or donut chart; these angles can then be passed to an arc generator. (The pie generator does not produce a shape directly.)pie() ​Source · Constructs a new pie generator with the default settings.jsconst pie = d3.pie();pie(data, ...arguments) ​Source · Generates a pie for the given array of data, returning an array of objects representing each datum’s arc angles. For example, given a set of numbers, here is how to compute the angles for a pie chart:jsconst data = [1, 1, 2, 3, 5, 8, 13, 21];
const pie = d3.pie();
const arcs = pie(data);The resulting arcs is an array of objects:json[
  {"data":  1, "value":  1, "index": 6, "startAngle": 6.050474740247008, "endAngle": 6.166830023713296, "padAngle": 0},
  {"data":  1, "value":  1, "index": 7, "startAngle": 6.166830023713296, "endAngle": 6.283185307179584, "padAngle": 0},
  {"data":  2, "value":  2, "index": 5, "startAngle": 5.817764173314431, "endAngle": 6.050474740247008, "padAngle": 0},
  {"data":  3, "value":  3, "index": 4, "startAngle": 5.468698322915565, "endAngle": 5.817764173314431, "padAngle": 0},
  {"data":  5, "value":  5, "index": 3, "startAngle": 4.886921905584122, "endAngle": 5.468698322915565, "padAngle": 0},
  {"data":  8, "value":  8, "index": 2, "startAngle": 3.956079637853813, "endAngle": 4.886921905584122, "padAngle": 0},
  {"data": 13, "value": 13, "index": 1, "startAngle": 2.443460952792061, "endAngle": 3.956079637853813, "padAngle": 0},
  {"data": 21, "value": 21, "index": 0, "startAngle": 0.000000000000000, "endAngle": 2.443460952792061, "padAngle": 0}
]Each object in the returned array has the following properties:data - the input datum; the corresponding element in the input data array.value - the numeric value of the arc.index - the zero-based sorted index of the arc.startAngle - the start angle of the arc.endAngle - the end angle of the arc.padAngle - the pad angle of the arc.This representation is designed to work with the arc generator’s default startAngle, endAngle and padAngle accessors. Angles are in radians, with 0 at -y (12 o’clock) and positive angles proceeding clockwise.The length of the returned array is the same as data, and each element i in the returned array corresponds to the element i in the input data. The returned array of arcs is in the same order as the data, even when the pie chart is sorted.Any additional arguments are arbitrary; they are propagated to the pie generator’s accessor functions along with the this object.pie.value(value) ​Source · If value is specified, sets the value accessor to the specified function or number and returns this pie generator.jsconst pie = d3.pie().value((d) => d.value);When a pie is generated, the value accessor will be invoked for each element in the input data array, being passed the element d, the index i, and the array data as three arguments.If value is not specified, returns the current value accessor.jspie.value() // (d) => d.valueThe value accessor defaults to:jsfunction value(d) {
  return d;
}The default value accessor assumes that the input data are numbers, or that they are coercible to numbers using valueOf. If your data are not numbers, then you should specify an accessor that returns the corresponding numeric value for a given datum. For example, given a CSV file with number and name fields:number,name
4,Locke
8,Reyes
15,Ford
16,Jarrah
23,Shephard
42,KwonYou might say:jsconst data = await d3.csv("lost.csv", d3.autoType);
const pie = d3.pie().value((d) => d.number);
const arcs = pie(data);This is similar to mapping your data to values before invoking the pie generator:jsconst arcs = d3.pie()(data.map((d) => d.number));The benefit of an accessor is that the input data remains associated with the returned objects, thereby making it easier to access other fields of the data, for example to set the color or to add text labels.pie.sort(compare) ​Source · If compare is specified, sets the data comparator to the specified function and returns this pie generator.jsconst pie = d3.pie().sort((a, b) => d3.ascending(a.name, b.name));The data comparator takes two arguments a and b, each elements from the input data array. If the arc for a should be before the arc for b, then the comparator must return a number less than zero; if the arc for a should be after the arc for b, then the comparator must return a number greater than zero; returning zero means that the relative order of a and b is unspecified.If compare is not specified, returns the current data comparator.jspie.sort() // (a, b) => d3.ascending(a.name, b.name))The data comparator defaults to null. If both the data comparator and the value comparator are null, then arcs are positioned in the original input order. Setting the data comparator implicitly sets the value comparator to null.Sorting does not affect the order of the generated arc array which is always in the same order as the input data array; it only affects the computed angles of each arc. The first arc starts at the start angle and the last arc ends at the end angle.pie.sortValues(compare) ​Source · If compare is specified, sets the value comparator to the specified function and returns this pie generator.jsconst pie = d3.pie().sortValues(d3.ascending);The value comparator is similar to the data comparator, except the two arguments a and b are values derived from the input data array using the value accessor rather than the data elements. If the arc for a should be before the arc for b, then the comparator must return a number less than zero; if the arc for a should be after the arc for b, then the comparator must return a number greater than zero; returning zero means that the relative order of a and b is unspecified.If compare is not specified, returns the current value comparator.jspie.sortValues() // d3.ascendingThe value comparator defaults to descending. If both the data comparator and the value comparator are null, then arcs are positioned in the original input order. Setting the value comparator implicitly sets the data comparator to null.Sorting does not affect the order of the generated arc array which is always in the same order as the input data array; it merely affects the computed angles of each arc. The first arc starts at the start angle and the last arc ends at the end angle.pie.startAngle(angle) ​Source · If angle is specified, sets the overall start angle of the pie to the specified function or number and returns this pie generator.jsconst pie = d3.pie().startAngle(0);The start angle is the overall start angle of the pie, i.e., the start angle of the first arc. It is typically expressed as a constant number but can also be expressed as a function of data. When a function, the start angle accessor is invoked once, being passed the same arguments and this context as the pie generator.If angle is not specified, returns the current start angle accessor.jspie.startAngle() // () => 0The start angle accessor defaults to:jsfunction startAngle() {
  return 0;
}Angles are in radians, with 0 at -y (12 o’clock) and positive angles proceeding clockwise.pie.endAngle(angle) ​Source · If angle is specified, sets the overall end angle of the pie to the specified function or number and returns this pie generator.jsconst pie = d3.pie().endAngle(Math.PI);The end angle here means the overall end angle of the pie, i.e., the end angle of the last arc. It is typically expressed as a constant number but can also be expressed as a function of data. When a function, the end angle accessor is invoked once, being passed the same arguments and this context as the pie generator.If angle is not specified, returns the current end angle accessor.jspie.endAngle() // () => Math.PIThe end angle accessor defaults to:jsfunction endAngle() {
  return 2 * Math.PI;
}Angles are in radians, with 0 at -y (12 o’clock) and positive angles proceeding clockwise. The value of the end angle is constrained to startAngle ± τ, such that |endAngle - startAngle| ≤ τ.pie.padAngle(angle) ​Pad angle:0.030Examples · Source · If angle is specified, sets the pad angle to the specified function or number and returns this pie generator.jsconst pie = d3.pie().padAngle(0.03);The pad angle specifies the angular separation in radians between adjacent arcs. The total amount of padding is the specified angle times the number of elements in the input data array, and at most |endAngle - startAngle|; the remaining space is divided proportionally by value such that the relative area of each arc is preserved.The pad angle is typically expressed as a constant number but can also be expressed as a function of data. When a function, the pad angle accessor is invoked once, being passed the same arguments and this context as the pie generator.If angle is not specified, returns the current pad angle accessor.jspie.padAngle() // () => 0.03The pad angle accessor defaults to:jsfunction padAngle() {
  return 0;
}\n\n\n\nStacks ​Examples · Stacking converts lengths into contiguous position intervals. For example, a bar chart of monthly sales might be broken down into a multi-series bar chart by category, stacking bars vertically and applying a categorical color encoding. Stacked charts can show overall value and per-category value simultaneously; however, it is typically harder to compare across categories as only the bottom layer of the stack is aligned. So, chose the stack order carefully, and consider a streamgraph. (See also grouped charts.)Like the pie generator, the stack generator does not produce a shape directly. Instead it computes positions which you can then pass to an area generator or use directly, say to position bars.stack() ​Source · Constructs a new stack generator with the default settings. See stack for usage.stack(data, ...arguments) ​Source · Generates a stack for the given array of data and returns an array representing each series. Any additional arguments are arbitrary; they are propagated to accessors along with the this object.For example, consider this tidy table of monthly fruit sales:datefruitsales1/2015apples38401/2015bananas19201/2015cherries9601/2015durians4002/2015apples16002/2015bananas14402/2015cherries9602/2015durians4003/2015apples6403/2015bananas9603/2015cherries6403/2015durians4004/2015apples3204/2015bananas4804/2015cherries6404/2015durians400This could be represented in JavaScript as an array of objects, perhaps parsed from CSV:jsconst data = [
  {date: new Date("2015-01-01"), fruit: "apples", sales: 3840},
  {date: new Date("2015-01-01"), fruit: "bananas", sales: 1920},
  {date: new Date("2015-01-01"), fruit: "cherries", sales: 960},
  {date: new Date("2015-01-01"), fruit: "durians", sales: 400},
  {date: new Date("2015-02-01"), fruit: "apples", sales: 1600},
  {date: new Date("2015-02-01"), fruit: "bananas", sales: 1440},
  {date: new Date("2015-02-01"), fruit: "cherries", sales: 960},
  {date: new Date("2015-02-01"), fruit: "durians", sales: 400},
  {date: new Date("2015-03-01"), fruit: "apples", sales: 640},
  {date: new Date("2015-03-01"), fruit: "bananas", sales: 960},
  {date: new Date("2015-03-01"), fruit: "cherries", sales: 640},
  {date: new Date("2015-03-01"), fruit: "durians", sales: 400},
  {date: new Date("2015-04-01"), fruit: "apples", sales: 320},
  {date: new Date("2015-04-01"), fruit: "bananas", sales: 480},
  {date: new Date("2015-04-01"), fruit: "cherries", sales: 640},
  {date: new Date("2015-04-01"), fruit: "durians", sales: 400}
];To compute the stacked series (a series, or layer, for each fruit; and a stack, or column, for each date), we can index the data by date and then fruit, compute the distinct fruit names across the data set, and lastly get the sales value for each date and fruit.jsconst series = d3.stack()
    .keys(d3.union(data.map(d => d.fruit))) // apples, bananas, cherries, …
    .value(([, group], key) => group.get(key).sales)
  (d3.index(data, d => d.date, d => d.fruit));TIPSee union and index from d3-array.The resulting array has one element per series. Each series has one point per month, and each point has a lower and upper value defining the baseline and topline:js[
  [[   0, 3840], [   0, 1600], [   0,  640], [   0,  320]], // apples
  [[3840, 5760], [1600, 3040], [ 640, 1600], [ 320,  800]], // bananas
  [[5760, 6720], [3040, 4000], [1600, 2240], [ 800, 1440]], // cherries
  [[6720, 7120], [4000, 4400], [2240, 2640], [1440, 1840]]  // durians
]Each series in then typically passed to an area generator to render an area chart, or used to construct rectangles for a bar chart.jssvg.append("g")
  .selectAll("g")
  .data(series)
  .join("g")
    .attr("fill", d => color(d.key))
  .selectAll("rect")
  .data(D => D)
  .join("rect")
    .attr("x", d => x(d.data[0]))
    .attr("y", d => y(d[1]))
    .attr("height", d => y(d[0]) - y(d[1]))
    .attr("width", x.bandwidth());The series are determined by the keys accessor; each series i in the returned array corresponds to the ith key. Each series is an array of points, where each point j corresponds to the jth element in the input data. Lastly, each point is represented as an array [y0, y1] where y0 is the lower value (baseline) and y1 is the upper value (topline); the difference between y0 and y1 corresponds to the computed value for this point. The key for each series is available as series.key, and the index as series.index. The input data element for each point is available as point.data.stack.keys(keys) ​Source · If keys is specified, sets the keys accessor to the specified function or array and returns this stack generator.jsconst stack = d3.stack().keys(["apples", "bananas", "cherries", "durians"]);If keys is not specified, returns the current keys accessor.jsstack.keys() // () => ["apples", "bananas", "cherries", "durians"]The keys accessor defaults to the empty array. A series (layer) is generated for each key. Keys are typically strings, but they may be arbitrary values; see InternMap. The series’ key is passed to the value accessor, along with each data point, to compute the point’s value.stack.value(value) ​Source · If value is specified, sets the value accessor to the specified function or number and returns this stack generator.jsconst stack = d3.stack().value((d, key) => d[key]);If value is not specified, returns the current value accessor.jsstack.value() // (d, key) => d[key]The value accessor defaults to:jsfunction value(d, key) {
  return d[key];
}CAUTIONThe default value accessor assumes that the input data is an array of objects exposing named properties with numeric values. This is a “wide” rather than “tidy” representation of data and is no longer recommended. See stack for an example using tidy data.stack.order(order) ​Source · If order is specified, sets the order accessor to the specified function or array and returns this stack generator.jsconst stack = d3.stack().order(d3.stackOrderNone);If order is a function, it is passed the generated series array and must return an array of numeric indexes representing the stack order. For example, to use reverse key order:jsconst stack = d3.stack().order(series => d3.range(series.length).reverse());The stack order is computed prior to the offset; thus, the lower value for all points is zero at the time the order is computed. The index attribute for each series is also not set until after the order is computed.If order is not specified, returns the current order accessor.jsstack.order() // d3.stackOrderNoneThe order accessor defaults to stackOrderNone; this uses the order given by the key accessor. See stack orders for the built-in orders.stack.offset(offset) ​Source · If offset is specified, sets the offset accessor to the specified function and returns this stack generator.jsconst stack = d3.stack().offset(d3.stackOffsetExpand);The offset function is passed the generated series array and the order index array; it is then responsible for updating the lower and upper values in the series array. See the built-in offsets for a reference implementation.If offset is not specified, returns the current offset acccesor.jsstack.offset() // d3.stackOffsetExpandThe offset accessor defaults to stackOffsetNone; this uses a zero baseline. See stack offsets for the built-in offsets.Stack orders ​Stack orders are typically not used directly, but are instead passed to stack.order.stackOrderAppearance(series) ​jsconst stack = d3.stack().order(d3.stackOrderAppearance);Source · Returns a series order such that the earliest series (according to the maximum value) is at the bottom.stackOrderAscending(series) ​jsconst stack = d3.stack().order(d3.stackOrderAscending);Source · Returns a series order such that the smallest series (according to the sum of values) is at the bottom.stackOrderDescending(series) ​jsconst stack = d3.stack().order(d3.stackOrderDescending);Source · Returns a series order such that the largest series (according to the sum of values) is at the bottom.stackOrderInsideOut(series) ​jsconst stack = d3.stack().order(d3.stackOrderInsideOut);Source · Returns a series order such that the earliest series (according to the maximum value) are on the inside and the later series are on the outside. This order is recommended for streamgraphs in conjunction with the wiggle offset. See Stacked Graphs — Geometry & Aesthetics by Byron & Wattenberg for more information.stackOrderNone(series) ​jsconst stack = d3.stack().order(d3.stackOrderNone);Source · Returns the given series order [0, 1, … n - 1] where n is the number of elements in series. Thus, the stack order is given by the key accessor.stackOrderReverse(series) ​jsconst stack = d3.stack().order(d3.stackOrderReverse);Source · Returns the reverse of the given series order [n - 1, n - 2, … 0] where n is the number of elements in series. Thus, the stack order is given by the reverse of the key accessor.Stack offsets ​Stack offsets are typically not used directly, but are instead passed to stack.offset.stackOffsetExpand(series, order) ​jsconst stack = d3.stack().offset(d3.stackOffsetExpand);Source · Applies a zero baseline and normalizes the values for each point such that the topline is always one.stackOffsetDiverging(series, order) ​jsconst stack = d3.stack().offset(d3.stackOffsetDiverging);Source · Positive values are stacked above zero, negative values are stacked below zero, and zero values are stacked at zero.stackOffsetNone(series, order) ​jsconst stack = d3.stack().offset(d3.stackOffsetNone);Source · Applies a zero baseline.stackOffsetSilhouette(series, order) ​jsconst stack = d3.stack().offset(d3.stackOffsetSilhouette);Source · Shifts the baseline down such that the center of the streamgraph is always at zero.stackOffsetWiggle(series, order) ​jsconst stack = d3.stack().offset(d3.stackOffsetWiggle);Source · Shifts the baseline so as to minimize the weighted wiggle of layers. This offset is recommended for streamgraphs in conjunction with the inside-out order. See Stacked Graphs — Geometry & Aesthetics by Bryon & Wattenberg for more information.\n\nSearchK7.9.0GitHub️ 110.0kOn this pageStacks ​Examples · Stacking converts lengths into contiguous position intervals. For example, a bar chart of monthly sales might be broken down into a multi-series bar chart by category, stacking bars vertically and applying a categorical color encoding. Stacked charts can show overall value and per-category value simultaneously; however, it is typically harder to compare across categories as only the bottom layer of the stack is aligned. So, chose the stack order carefully, and consider a streamgraph. (See also grouped charts.)Like the pie generator, the stack generator does not produce a shape directly. Instead it computes positions which you can then pass to an area generator or use directly, say to position bars.stack() ​Source · Constructs a new stack generator with the default settings. See stack for usage.stack(data, ...arguments) ​Source · Generates a stack for the given array of data and returns an array representing each series. Any additional arguments are arbitrary; they are propagated to accessors along with the this object.For example, consider this tidy table of monthly fruit sales:datefruitsales1/2015apples38401/2015bananas19201/2015cherries9601/2015durians4002/2015apples16002/2015bananas14402/2015cherries9602/2015durians4003/2015apples6403/2015bananas9603/2015cherries6403/2015durians4004/2015apples3204/2015bananas4804/2015cherries6404/2015durians400This could be represented in JavaScript as an array of objects, perhaps parsed from CSV:jsconst data = [
  {date: new Date("2015-01-01"), fruit: "apples", sales: 3840},
  {date: new Date("2015-01-01"), fruit: "bananas", sales: 1920},
  {date: new Date("2015-01-01"), fruit: "cherries", sales: 960},
  {date: new Date("2015-01-01"), fruit: "durians", sales: 400},
  {date: new Date("2015-02-01"), fruit: "apples", sales: 1600},
  {date: new Date("2015-02-01"), fruit: "bananas", sales: 1440},
  {date: new Date("2015-02-01"), fruit: "cherries", sales: 960},
  {date: new Date("2015-02-01"), fruit: "durians", sales: 400},
  {date: new Date("2015-03-01"), fruit: "apples", sales: 640},
  {date: new Date("2015-03-01"), fruit: "bananas", sales: 960},
  {date: new Date("2015-03-01"), fruit: "cherries", sales: 640},
  {date: new Date("2015-03-01"), fruit: "durians", sales: 400},
  {date: new Date("2015-04-01"), fruit: "apples", sales: 320},
  {date: new Date("2015-04-01"), fruit: "bananas", sales: 480},
  {date: new Date("2015-04-01"), fruit: "cherries", sales: 640},
  {date: new Date("2015-04-01"), fruit: "durians", sales: 400}
];To compute the stacked series (a series, or layer, for each fruit; and a stack, or column, for each date), we can index the data by date and then fruit, compute the distinct fruit names across the data set, and lastly get the sales value for each date and fruit.jsconst series = d3.stack()
    .keys(d3.union(data.map(d => d.fruit))) // apples, bananas, cherries, …
    .value(([, group], key) => group.get(key).sales)
  (d3.index(data, d => d.date, d => d.fruit));TIPSee union and index from d3-array.The resulting array has one element per series. Each series has one point per month, and each point has a lower and upper value defining the baseline and topline:js[
  [[   0, 3840], [   0, 1600], [   0,  640], [   0,  320]], // apples
  [[3840, 5760], [1600, 3040], [ 640, 1600], [ 320,  800]], // bananas
  [[5760, 6720], [3040, 4000], [1600, 2240], [ 800, 1440]], // cherries
  [[6720, 7120], [4000, 4400], [2240, 2640], [1440, 1840]]  // durians
]Each series in then typically passed to an area generator to render an area chart, or used to construct rectangles for a bar chart.jssvg.append("g")
  .selectAll("g")
  .data(series)
  .join("g")
    .attr("fill", d => color(d.key))
  .selectAll("rect")
  .data(D => D)
  .join("rect")
    .attr("x", d => x(d.data[0]))
    .attr("y", d => y(d[1]))
    .attr("height", d => y(d[0]) - y(d[1]))
    .attr("width", x.bandwidth());The series are determined by the keys accessor; each series i in the returned array corresponds to the ith key. Each series is an array of points, where each point j corresponds to the jth element in the input data. Lastly, each point is represented as an array [y0, y1] where y0 is the lower value (baseline) and y1 is the upper value (topline); the difference between y0 and y1 corresponds to the computed value for this point. The key for each series is available as series.key, and the index as series.index. The input data element for each point is available as point.data.stack.keys(keys) ​Source · If keys is specified, sets the keys accessor to the specified function or array and returns this stack generator.jsconst stack = d3.stack().keys(["apples", "bananas", "cherries", "durians"]);If keys is not specified, returns the current keys accessor.jsstack.keys() // () => ["apples", "bananas", "cherries", "durians"]The keys accessor defaults to the empty array. A series (layer) is generated for each key. Keys are typically strings, but they may be arbitrary values; see InternMap. The series’ key is passed to the value accessor, along with each data point, to compute the point’s value.stack.value(value) ​Source · If value is specified, sets the value accessor to the specified function or number and returns this stack generator.jsconst stack = d3.stack().value((d, key) => d[key]);If value is not specified, returns the current value accessor.jsstack.value() // (d, key) => d[key]The value accessor defaults to:jsfunction value(d, key) {
  return d[key];
}CAUTIONThe default value accessor assumes that the input data is an array of objects exposing named properties with numeric values. This is a “wide” rather than “tidy” representation of data and is no longer recommended. See stack for an example using tidy data.stack.order(order) ​Source · If order is specified, sets the order accessor to the specified function or array and returns this stack generator.jsconst stack = d3.stack().order(d3.stackOrderNone);If order is a function, it is passed the generated series array and must return an array of numeric indexes representing the stack order. For example, to use reverse key order:jsconst stack = d3.stack().order(series => d3.range(series.length).reverse());The stack order is computed prior to the offset; thus, the lower value for all points is zero at the time the order is computed. The index attribute for each series is also not set until after the order is computed.If order is not specified, returns the current order accessor.jsstack.order() // d3.stackOrderNoneThe order accessor defaults to stackOrderNone; this uses the order given by the key accessor. See stack orders for the built-in orders.stack.offset(offset) ​Source · If offset is specified, sets the offset accessor to the specified function and returns this stack generator.jsconst stack = d3.stack().offset(d3.stackOffsetExpand);The offset function is passed the generated series array and the order index array; it is then responsible for updating the lower and upper values in the series array. See the built-in offsets for a reference implementation.If offset is not specified, returns the current offset acccesor.jsstack.offset() // d3.stackOffsetExpandThe offset accessor defaults to stackOffsetNone; this uses a zero baseline. See stack offsets for the built-in offsets.Stack orders ​Stack orders are typically not used directly, but are instead passed to stack.order.stackOrderAppearance(series) ​jsconst stack = d3.stack().order(d3.stackOrderAppearance);Source · Returns a series order such that the earliest series (according to the maximum value) is at the bottom.stackOrderAscending(series) ​jsconst stack = d3.stack().order(d3.stackOrderAscending);Source · Returns a series order such that the smallest series (according to the sum of values) is at the bottom.stackOrderDescending(series) ​jsconst stack = d3.stack().order(d3.stackOrderDescending);Source · Returns a series order such that the largest series (according to the sum of values) is at the bottom.stackOrderInsideOut(series) ​jsconst stack = d3.stack().order(d3.stackOrderInsideOut);Source · Returns a series order such that the earliest series (according to the maximum value) are on the inside and the later series are on the outside. This order is recommended for streamgraphs in conjunction with the wiggle offset. See Stacked Graphs — Geometry & Aesthetics by Byron & Wattenberg for more information.stackOrderNone(series) ​jsconst stack = d3.stack().order(d3.stackOrderNone);Source · Returns the given series order [0, 1, … n - 1] where n is the number of elements in series. Thus, the stack order is given by the key accessor.stackOrderReverse(series) ​jsconst stack = d3.stack().order(d3.stackOrderReverse);Source · Returns the reverse of the given series order [n - 1, n - 2, … 0] where n is the number of elements in series. Thus, the stack order is given by the reverse of the key accessor.Stack offsets ​Stack offsets are typically not used directly, but are instead passed to stack.offset.stackOffsetExpand(series, order) ​jsconst stack = d3.stack().offset(d3.stackOffsetExpand);Source · Applies a zero baseline and normalizes the values for each point such that the topline is always one.stackOffsetDiverging(series, order) ​jsconst stack = d3.stack().offset(d3.stackOffsetDiverging);Source · Positive values are stacked above zero, negative values are stacked below zero, and zero values are stacked at zero.stackOffsetNone(series, order) ​jsconst stack = d3.stack().offset(d3.stackOffsetNone);Source · Applies a zero baseline.stackOffsetSilhouette(series, order) ​jsconst stack = d3.stack().offset(d3.stackOffsetSilhouette);Source · Shifts the baseline down such that the center of the streamgraph is always at zero.stackOffsetWiggle(series, order) ​jsconst stack = d3.stack().offset(d3.stackOffsetWiggle);Source · Shifts the baseline so as to minimize the weighted wiggle of layers. This offset is recommended for streamgraphs in conjunction with the inside-out order. See Stacked Graphs — Geometry & Aesthetics by Bryon & Wattenberg for more information.PagerPrevious pagePiesNext pageSymbols\n\nStacks ​Examples · Stacking converts lengths into contiguous position intervals. For example, a bar chart of monthly sales might be broken down into a multi-series bar chart by category, stacking bars vertically and applying a categorical color encoding. Stacked charts can show overall value and per-category value simultaneously; however, it is typically harder to compare across categories as only the bottom layer of the stack is aligned. So, chose the stack order carefully, and consider a streamgraph. (See also grouped charts.)Like the pie generator, the stack generator does not produce a shape directly. Instead it computes positions which you can then pass to an area generator or use directly, say to position bars.stack() ​Source · Constructs a new stack generator with the default settings. See stack for usage.stack(data, ...arguments) ​Source · Generates a stack for the given array of data and returns an array representing each series. Any additional arguments are arbitrary; they are propagated to accessors along with the this object.For example, consider this tidy table of monthly fruit sales:datefruitsales1/2015apples38401/2015bananas19201/2015cherries9601/2015durians4002/2015apples16002/2015bananas14402/2015cherries9602/2015durians4003/2015apples6403/2015bananas9603/2015cherries6403/2015durians4004/2015apples3204/2015bananas4804/2015cherries6404/2015durians400This could be represented in JavaScript as an array of objects, perhaps parsed from CSV:jsconst data = [
  {date: new Date("2015-01-01"), fruit: "apples", sales: 3840},
  {date: new Date("2015-01-01"), fruit: "bananas", sales: 1920},
  {date: new Date("2015-01-01"), fruit: "cherries", sales: 960},
  {date: new Date("2015-01-01"), fruit: "durians", sales: 400},
  {date: new Date("2015-02-01"), fruit: "apples", sales: 1600},
  {date: new Date("2015-02-01"), fruit: "bananas", sales: 1440},
  {date: new Date("2015-02-01"), fruit: "cherries", sales: 960},
  {date: new Date("2015-02-01"), fruit: "durians", sales: 400},
  {date: new Date("2015-03-01"), fruit: "apples", sales: 640},
  {date: new Date("2015-03-01"), fruit: "bananas", sales: 960},
  {date: new Date("2015-03-01"), fruit: "cherries", sales: 640},
  {date: new Date("2015-03-01"), fruit: "durians", sales: 400},
  {date: new Date("2015-04-01"), fruit: "apples", sales: 320},
  {date: new Date("2015-04-01"), fruit: "bananas", sales: 480},
  {date: new Date("2015-04-01"), fruit: "cherries", sales: 640},
  {date: new Date("2015-04-01"), fruit: "durians", sales: 400}
];To compute the stacked series (a series, or layer, for each fruit; and a stack, or column, for each date), we can index the data by date and then fruit, compute the distinct fruit names across the data set, and lastly get the sales value for each date and fruit.jsconst series = d3.stack()
    .keys(d3.union(data.map(d => d.fruit))) // apples, bananas, cherries, …
    .value(([, group], key) => group.get(key).sales)
  (d3.index(data, d => d.date, d => d.fruit));TIPSee union and index from d3-array.The resulting array has one element per series. Each series has one point per month, and each point has a lower and upper value defining the baseline and topline:js[
  [[   0, 3840], [   0, 1600], [   0,  640], [   0,  320]], // apples
  [[3840, 5760], [1600, 3040], [ 640, 1600], [ 320,  800]], // bananas
  [[5760, 6720], [3040, 4000], [1600, 2240], [ 800, 1440]], // cherries
  [[6720, 7120], [4000, 4400], [2240, 2640], [1440, 1840]]  // durians
]Each series in then typically passed to an area generator to render an area chart, or used to construct rectangles for a bar chart.jssvg.append("g")
  .selectAll("g")
  .data(series)
  .join("g")
    .attr("fill", d => color(d.key))
  .selectAll("rect")
  .data(D => D)
  .join("rect")
    .attr("x", d => x(d.data[0]))
    .attr("y", d => y(d[1]))
    .attr("height", d => y(d[0]) - y(d[1]))
    .attr("width", x.bandwidth());The series are determined by the keys accessor; each series i in the returned array corresponds to the ith key. Each series is an array of points, where each point j corresponds to the jth element in the input data. Lastly, each point is represented as an array [y0, y1] where y0 is the lower value (baseline) and y1 is the upper value (topline); the difference between y0 and y1 corresponds to the computed value for this point. The key for each series is available as series.key, and the index as series.index. The input data element for each point is available as point.data.stack.keys(keys) ​Source · If keys is specified, sets the keys accessor to the specified function or array and returns this stack generator.jsconst stack = d3.stack().keys(["apples", "bananas", "cherries", "durians"]);If keys is not specified, returns the current keys accessor.jsstack.keys() // () => ["apples", "bananas", "cherries", "durians"]The keys accessor defaults to the empty array. A series (layer) is generated for each key. Keys are typically strings, but they may be arbitrary values; see InternMap. The series’ key is passed to the value accessor, along with each data point, to compute the point’s value.stack.value(value) ​Source · If value is specified, sets the value accessor to the specified function or number and returns this stack generator.jsconst stack = d3.stack().value((d, key) => d[key]);If value is not specified, returns the current value accessor.jsstack.value() // (d, key) => d[key]The value accessor defaults to:jsfunction value(d, key) {
  return d[key];
}CAUTIONThe default value accessor assumes that the input data is an array of objects exposing named properties with numeric values. This is a “wide” rather than “tidy” representation of data and is no longer recommended. See stack for an example using tidy data.stack.order(order) ​Source · If order is specified, sets the order accessor to the specified function or array and returns this stack generator.jsconst stack = d3.stack().order(d3.stackOrderNone);If order is a function, it is passed the generated series array and must return an array of numeric indexes representing the stack order. For example, to use reverse key order:jsconst stack = d3.stack().order(series => d3.range(series.length).reverse());The stack order is computed prior to the offset; thus, the lower value for all points is zero at the time the order is computed. The index attribute for each series is also not set until after the order is computed.If order is not specified, returns the current order accessor.jsstack.order() // d3.stackOrderNoneThe order accessor defaults to stackOrderNone; this uses the order given by the key accessor. See stack orders for the built-in orders.stack.offset(offset) ​Source · If offset is specified, sets the offset accessor to the specified function and returns this stack generator.jsconst stack = d3.stack().offset(d3.stackOffsetExpand);The offset function is passed the generated series array and the order index array; it is then responsible for updating the lower and upper values in the series array. See the built-in offsets for a reference implementation.If offset is not specified, returns the current offset acccesor.jsstack.offset() // d3.stackOffsetExpandThe offset accessor defaults to stackOffsetNone; this uses a zero baseline. See stack offsets for the built-in offsets.Stack orders ​Stack orders are typically not used directly, but are instead passed to stack.order.stackOrderAppearance(series) ​jsconst stack = d3.stack().order(d3.stackOrderAppearance);Source · Returns a series order such that the earliest series (according to the maximum value) is at the bottom.stackOrderAscending(series) ​jsconst stack = d3.stack().order(d3.stackOrderAscending);Source · Returns a series order such that the smallest series (according to the sum of values) is at the bottom.stackOrderDescending(series) ​jsconst stack = d3.stack().order(d3.stackOrderDescending);Source · Returns a series order such that the largest series (according to the sum of values) is at the bottom.stackOrderInsideOut(series) ​jsconst stack = d3.stack().order(d3.stackOrderInsideOut);Source · Returns a series order such that the earliest series (according to the maximum value) are on the inside and the later series are on the outside. This order is recommended for streamgraphs in conjunction with the wiggle offset. See Stacked Graphs — Geometry & Aesthetics by Byron & Wattenberg for more information.stackOrderNone(series) ​jsconst stack = d3.stack().order(d3.stackOrderNone);Source · Returns the given series order [0, 1, … n - 1] where n is the number of elements in series. Thus, the stack order is given by the key accessor.stackOrderReverse(series) ​jsconst stack = d3.stack().order(d3.stackOrderReverse);Source · Returns the reverse of the given series order [n - 1, n - 2, … 0] where n is the number of elements in series. Thus, the stack order is given by the reverse of the key accessor.Stack offsets ​Stack offsets are typically not used directly, but are instead passed to stack.offset.stackOffsetExpand(series, order) ​jsconst stack = d3.stack().offset(d3.stackOffsetExpand);Source · Applies a zero baseline and normalizes the values for each point such that the topline is always one.stackOffsetDiverging(series, order) ​jsconst stack = d3.stack().offset(d3.stackOffsetDiverging);Source · Positive values are stacked above zero, negative values are stacked below zero, and zero values are stacked at zero.stackOffsetNone(series, order) ​jsconst stack = d3.stack().offset(d3.stackOffsetNone);Source · Applies a zero baseline.stackOffsetSilhouette(series, order) ​jsconst stack = d3.stack().offset(d3.stackOffsetSilhouette);Source · Shifts the baseline down such that the center of the streamgraph is always at zero.stackOffsetWiggle(series, order) ​jsconst stack = d3.stack().offset(d3.stackOffsetWiggle);Source · Shifts the baseline so as to minimize the weighted wiggle of layers. This offset is recommended for streamgraphs in conjunction with the inside-out order. See Stacked Graphs — Geometry & Aesthetics by Bryon & Wattenberg for more information.\n\n\n\nSymbols ​Examples · Symbols provide a categorical shape encoding as in a scatterplot. Symbols are centered at the origin; use a transform to move the symbol to a different position.symbol(type, size) ​Source · Constructs a new symbol generator of the specified type and size. If not specified, type defaults to a circle, and size defaults to 64.jssvg.append("path").attr("d", d3.symbol(d3.symbolCross));symbol(...arguments) ​Source · Generates a symbol for the given arguments. The arguments are arbitrary; they are propagated to the symbol generator’s accessor functions along with the this object. With the default settings, invoking the symbol generator produces a circle of 64 square pixels.jsd3.symbol()() // "M4.514,0A4.514,4.514,0,1,1,-4.514,0A4.514,4.514,0,1,1,4.514,0"If the symbol generator has a context, then the symbol is rendered to this context as a sequence of path method calls and this function returns void. Otherwise, a path data string is returned.symbol.type(type) ​Source · If type is specified, sets the symbol type to the specified function or symbol type and returns this symbol generator.jsconst symbol = d3.symbol().type(d3.symbolCross);If type is a function, the symbol generator’s arguments and this are passed through. This is convenient for use with selection.attr, say in conjunction with an ordinal scale to produce a categorical symbol encoding.jsconst symbolType = d3.scaleOrdinal(d3.symbolsFill);
const symbol = d3.symbol().type((d) => symbolType(d.category));If type is not specified, returns the current symbol type accessor.jssymbol.type() // () => d3.symbolCrossThe symbol type accessor defaults to:jsfunction type() {
  return circle;
}See symbolsFill and symbolsStroke for built-in symbol types. To implement a custom symbol type, pass an object that implements symbolType.draw.symbol.size(size) ​Source · If size is specified, sets the size to the specified function or number and returns this symbol generator.jsconst symbol = d3.symbol().size(100);If size is a function, the symbol generator’s arguments and this are passed through. This is convenient for use with selection.attr, say in conjunction with a linear scale to produce a quantitative size encoding.jsconst symbolSize = d3.scaleLinear([0, 100]);
const symbol = d3.symbol().size((d) => symbolSize(d.value));If size is not specified, returns the current size accessor.jssymbol.size() // () => 100The size accessor defaults to:jsfunction size() {
  return 64;
}symbol.context(context) ​Source · If context is specified, sets the context and returns this symbol generator.jsconst context = canvas.getContext("2d");
const symbol = d3.symbol().context(context);If context is not specified, returns the current context.jssymbol.context() // contextThe context defaults to null. If the context is not null, then the generated symbol is rendered to this context as a sequence of path method calls. Otherwise, a path data string representing the generated symbol is returned.symbol.digits(digits) ​Source · If digits is specified, sets the maximum number of digits after the decimal separator and returns this symbol generator.jsconst symbol = d3.symbol().digits(3);If digits is not specified, returns the current maximum fraction digits, which defaults to 3.jssymbol.digits() // 3This option only applies when the associated context is null, as when this symbol generator is used to produce path data.symbolsFill ​Source · An array containing a set of symbol types designed for filling: circle, cross, diamond, square, star, triangle, and wye. Useful for a categorical shape encoding with an ordinal scale.jsconst symbolType = d3.scaleOrdinal(d3.symbolsFill);symbolsStroke ​Source · An array containing a set of symbol types designed for stroking: circle, plus, times, triangle2, asterisk, square2, and diamond2. Useful for a categorical shape encoding with an ordinal scale.jsconst symbolType = d3.scaleOrdinal(d3.symbolsStroke);symbolAsterisk ​Source · The asterisk symbol type; intended for stroking.symbolCircle ​Source · The circle symbol type; intended for either filling or stroking.symbolCross ​Source · The Greek cross symbol type, with arms of equal length; intended for filling.symbolDiamond ​Source · The rhombus symbol type; intended for filling.symbolDiamond2 ​Source · The rotated square symbol type; intended for stroking.symbolPlus ​Source · The plus symbol type; intended for stroking.symbolSquare ​Source · The square symbol type; intended for filling.symbolSquare2 ​Source · The square2 symbol type; intended for stroking.symbolStar ​Source · The pentagonal star (pentagram) symbol type; intended for filling.symbolTriangle ​Source · The up-pointing triangle symbol type; intended for filling.symbolTriangle2 ​Source · The up-pointing triangle symbol type; intended for stroking.symbolWye ​Source · The Y-shape symbol type; intended for filling.symbolTimes ​Source · The X-shape symbol type; intended for stroking.Custom symbols ​Symbol types are typically not used directly, instead being passed to symbol.type. However, you can define your own symbol type implementation should none of the built-in types satisfy your needs using the following interface. You can also use this low-level interface with a built-in symbol type as an alternative to the symbol generator.jsconst path = d3.pathRound(3);
const circle = d3.symbolCircle.draw(path, 64);
path.toString(); // "M4.514,0A4.514,4.514,0,1,1,-4.514,0A4.514,4.514,0,1,1,4.514,0"symbolType.draw(context, size) ​Renders this symbol type to the specified context with the specified size in square pixels. The context implements the CanvasPathMethods interface. (Note that this is a subset of the CanvasRenderingContext2D interface!) See also d3-path.pointRadial(angle, radius) ​Examples · Source · Returns the point [x, y] for the given angle in radians, with 0 at -y (12 o’clock) and positive angles proceeding clockwise, and the given radius.jsd3.pointRadial(Math.PI / 3, 100) // [86.60254037844386, -50]\n\nSearchK7.9.0GitHub️ 110.0kOn this pageSymbols ​Examples · Symbols provide a categorical shape encoding as in a scatterplot. Symbols are centered at the origin; use a transform to move the symbol to a different position.symbol(type, size) ​Source · Constructs a new symbol generator of the specified type and size. If not specified, type defaults to a circle, and size defaults to 64.jssvg.append("path").attr("d", d3.symbol(d3.symbolCross));symbol(...arguments) ​Source · Generates a symbol for the given arguments. The arguments are arbitrary; they are propagated to the symbol generator’s accessor functions along with the this object. With the default settings, invoking the symbol generator produces a circle of 64 square pixels.jsd3.symbol()() // "M4.514,0A4.514,4.514,0,1,1,-4.514,0A4.514,4.514,0,1,1,4.514,0"If the symbol generator has a context, then the symbol is rendered to this context as a sequence of path method calls and this function returns void. Otherwise, a path data string is returned.symbol.type(type) ​Source · If type is specified, sets the symbol type to the specified function or symbol type and returns this symbol generator.jsconst symbol = d3.symbol().type(d3.symbolCross);If type is a function, the symbol generator’s arguments and this are passed through. This is convenient for use with selection.attr, say in conjunction with an ordinal scale to produce a categorical symbol encoding.jsconst symbolType = d3.scaleOrdinal(d3.symbolsFill);
const symbol = d3.symbol().type((d) => symbolType(d.category));If type is not specified, returns the current symbol type accessor.jssymbol.type() // () => d3.symbolCrossThe symbol type accessor defaults to:jsfunction type() {
  return circle;
}See symbolsFill and symbolsStroke for built-in symbol types. To implement a custom symbol type, pass an object that implements symbolType.draw.symbol.size(size) ​Source · If size is specified, sets the size to the specified function or number and returns this symbol generator.jsconst symbol = d3.symbol().size(100);If size is a function, the symbol generator’s arguments and this are passed through. This is convenient for use with selection.attr, say in conjunction with a linear scale to produce a quantitative size encoding.jsconst symbolSize = d3.scaleLinear([0, 100]);
const symbol = d3.symbol().size((d) => symbolSize(d.value));If size is not specified, returns the current size accessor.jssymbol.size() // () => 100The size accessor defaults to:jsfunction size() {
  return 64;
}symbol.context(context) ​Source · If context is specified, sets the context and returns this symbol generator.jsconst context = canvas.getContext("2d");
const symbol = d3.symbol().context(context);If context is not specified, returns the current context.jssymbol.context() // contextThe context defaults to null. If the context is not null, then the generated symbol is rendered to this context as a sequence of path method calls. Otherwise, a path data string representing the generated symbol is returned.symbol.digits(digits) ​Source · If digits is specified, sets the maximum number of digits after the decimal separator and returns this symbol generator.jsconst symbol = d3.symbol().digits(3);If digits is not specified, returns the current maximum fraction digits, which defaults to 3.jssymbol.digits() // 3This option only applies when the associated context is null, as when this symbol generator is used to produce path data.symbolsFill ​Source · An array containing a set of symbol types designed for filling: circle, cross, diamond, square, star, triangle, and wye. Useful for a categorical shape encoding with an ordinal scale.jsconst symbolType = d3.scaleOrdinal(d3.symbolsFill);symbolsStroke ​Source · An array containing a set of symbol types designed for stroking: circle, plus, times, triangle2, asterisk, square2, and diamond2. Useful for a categorical shape encoding with an ordinal scale.jsconst symbolType = d3.scaleOrdinal(d3.symbolsStroke);symbolAsterisk ​Source · The asterisk symbol type; intended for stroking.symbolCircle ​Source · The circle symbol type; intended for either filling or stroking.symbolCross ​Source · The Greek cross symbol type, with arms of equal length; intended for filling.symbolDiamond ​Source · The rhombus symbol type; intended for filling.symbolDiamond2 ​Source · The rotated square symbol type; intended for stroking.symbolPlus ​Source · The plus symbol type; intended for stroking.symbolSquare ​Source · The square symbol type; intended for filling.symbolSquare2 ​Source · The square2 symbol type; intended for stroking.symbolStar ​Source · The pentagonal star (pentagram) symbol type; intended for filling.symbolTriangle ​Source · The up-pointing triangle symbol type; intended for filling.symbolTriangle2 ​Source · The up-pointing triangle symbol type; intended for stroking.symbolWye ​Source · The Y-shape symbol type; intended for filling.symbolTimes ​Source · The X-shape symbol type; intended for stroking.Custom symbols ​Symbol types are typically not used directly, instead being passed to symbol.type. However, you can define your own symbol type implementation should none of the built-in types satisfy your needs using the following interface. You can also use this low-level interface with a built-in symbol type as an alternative to the symbol generator.jsconst path = d3.pathRound(3);
const circle = d3.symbolCircle.draw(path, 64);
path.toString(); // "M4.514,0A4.514,4.514,0,1,1,-4.514,0A4.514,4.514,0,1,1,4.514,0"symbolType.draw(context, size) ​Renders this symbol type to the specified context with the specified size in square pixels. The context implements the CanvasPathMethods interface. (Note that this is a subset of the CanvasRenderingContext2D interface!) See also d3-path.pointRadial(angle, radius) ​Examples · Source · Returns the point [x, y] for the given angle in radians, with 0 at -y (12 o’clock) and positive angles proceeding clockwise, and the given radius.jsd3.pointRadial(Math.PI / 3, 100) // [86.60254037844386, -50]PagerPrevious pageStacksNext pageRadial areas\n\nSymbols ​Examples · Symbols provide a categorical shape encoding as in a scatterplot. Symbols are centered at the origin; use a transform to move the symbol to a different position.symbol(type, size) ​Source · Constructs a new symbol generator of the specified type and size. If not specified, type defaults to a circle, and size defaults to 64.jssvg.append("path").attr("d", d3.symbol(d3.symbolCross));symbol(...arguments) ​Source · Generates a symbol for the given arguments. The arguments are arbitrary; they are propagated to the symbol generator’s accessor functions along with the this object. With the default settings, invoking the symbol generator produces a circle of 64 square pixels.jsd3.symbol()() // "M4.514,0A4.514,4.514,0,1,1,-4.514,0A4.514,4.514,0,1,1,4.514,0"If the symbol generator has a context, then the symbol is rendered to this context as a sequence of path method calls and this function returns void. Otherwise, a path data string is returned.symbol.type(type) ​Source · If type is specified, sets the symbol type to the specified function or symbol type and returns this symbol generator.jsconst symbol = d3.symbol().type(d3.symbolCross);If type is a function, the symbol generator’s arguments and this are passed through. This is convenient for use with selection.attr, say in conjunction with an ordinal scale to produce a categorical symbol encoding.jsconst symbolType = d3.scaleOrdinal(d3.symbolsFill);
const symbol = d3.symbol().type((d) => symbolType(d.category));If type is not specified, returns the current symbol type accessor.jssymbol.type() // () => d3.symbolCrossThe symbol type accessor defaults to:jsfunction type() {
  return circle;
}See symbolsFill and symbolsStroke for built-in symbol types. To implement a custom symbol type, pass an object that implements symbolType.draw.symbol.size(size) ​Source · If size is specified, sets the size to the specified function or number and returns this symbol generator.jsconst symbol = d3.symbol().size(100);If size is a function, the symbol generator’s arguments and this are passed through. This is convenient for use with selection.attr, say in conjunction with a linear scale to produce a quantitative size encoding.jsconst symbolSize = d3.scaleLinear([0, 100]);
const symbol = d3.symbol().size((d) => symbolSize(d.value));If size is not specified, returns the current size accessor.jssymbol.size() // () => 100The size accessor defaults to:jsfunction size() {
  return 64;
}symbol.context(context) ​Source · If context is specified, sets the context and returns this symbol generator.jsconst context = canvas.getContext("2d");
const symbol = d3.symbol().context(context);If context is not specified, returns the current context.jssymbol.context() // contextThe context defaults to null. If the context is not null, then the generated symbol is rendered to this context as a sequence of path method calls. Otherwise, a path data string representing the generated symbol is returned.symbol.digits(digits) ​Source · If digits is specified, sets the maximum number of digits after the decimal separator and returns this symbol generator.jsconst symbol = d3.symbol().digits(3);If digits is not specified, returns the current maximum fraction digits, which defaults to 3.jssymbol.digits() // 3This option only applies when the associated context is null, as when this symbol generator is used to produce path data.symbolsFill ​Source · An array containing a set of symbol types designed for filling: circle, cross, diamond, square, star, triangle, and wye. Useful for a categorical shape encoding with an ordinal scale.jsconst symbolType = d3.scaleOrdinal(d3.symbolsFill);symbolsStroke ​Source · An array containing a set of symbol types designed for stroking: circle, plus, times, triangle2, asterisk, square2, and diamond2. Useful for a categorical shape encoding with an ordinal scale.jsconst symbolType = d3.scaleOrdinal(d3.symbolsStroke);symbolAsterisk ​Source · The asterisk symbol type; intended for stroking.symbolCircle ​Source · The circle symbol type; intended for either filling or stroking.symbolCross ​Source · The Greek cross symbol type, with arms of equal length; intended for filling.symbolDiamond ​Source · The rhombus symbol type; intended for filling.symbolDiamond2 ​Source · The rotated square symbol type; intended for stroking.symbolPlus ​Source · The plus symbol type; intended for stroking.symbolSquare ​Source · The square symbol type; intended for filling.symbolSquare2 ​Source · The square2 symbol type; intended for stroking.symbolStar ​Source · The pentagonal star (pentagram) symbol type; intended for filling.symbolTriangle ​Source · The up-pointing triangle symbol type; intended for filling.symbolTriangle2 ​Source · The up-pointing triangle symbol type; intended for stroking.symbolWye ​Source · The Y-shape symbol type; intended for filling.symbolTimes ​Source · The X-shape symbol type; intended for stroking.Custom symbols ​Symbol types are typically not used directly, instead being passed to symbol.type. However, you can define your own symbol type implementation should none of the built-in types satisfy your needs using the following interface. You can also use this low-level interface with a built-in symbol type as an alternative to the symbol generator.jsconst path = d3.pathRound(3);
const circle = d3.symbolCircle.draw(path, 64);
path.toString(); // "M4.514,0A4.514,4.514,0,1,1,-4.514,0A4.514,4.514,0,1,1,4.514,0"symbolType.draw(context, size) ​Renders this symbol type to the specified context with the specified size in square pixels. The context implements the CanvasPathMethods interface. (Note that this is a subset of the CanvasRenderingContext2D interface!) See also d3-path.pointRadial(angle, radius) ​Examples · Source · Returns the point [x, y] for the given angle in radians, with 0 at -y (12 o’clock) and positive angles proceeding clockwise, and the given radius.jsd3.pointRadial(Math.PI / 3, 100) // [86.60254037844386, -50]\n\n\n\nRadial areas ​Examples · A radial area generator is like the Cartesian area generator except the x and y accessors are replaced with angle and radius accessors. Radial areas are positioned relative to the origin; use a transform to change the origin.areaRadial() ​Source · Constructs a new radial area generator with the default settings.jsconst area = d3.areaRadial();areaRadial(data) ​Source · Equivalent to area.jssvg.append("path").attr("d", area(data));areaRadial.angle(angle) ​Source · Equivalent to area.x, except the accessor returns the angle in radians, with 0 at -y (12 o’clock).jsconst area = d3.areaRadial().angle((d) => a(d.Date));areaRadial.startAngle(angle) ​Source · Equivalent to area.x0, except the accessor returns the angle in radians, with 0 at -y (12 o’clock). Note: typically angle is used instead of setting separate start and end angles.areaRadial.endAngle(angle) ​Source · Equivalent to area.x1, except the accessor returns the angle in radians, with 0 at -y (12 o’clock). Note: typically angle is used instead of setting separate start and end angles.areaRadial.radius(radius) ​Source · Equivalent to area.y, except the accessor returns the radius: the distance from the origin.jsconst area = d3.areaRadial().radius((d) => r(d.temperature));areaRadial.innerRadius(radius) ​Source · Equivalent to area.y0, except the accessor returns the radius: the distance from the origin.jsconst area = d3.areaRadial().radius((d) => r(d.low));areaRadial.outerRadius(radius) ​Source · Equivalent to area.y1, except the accessor returns the radius: the distance from the origin.jsconst area = d3.areaRadial().radius((d) => r(d.high));areaRadial.defined(defined) ​Source · Equivalent to area.defined.jsconst area = d3.areaRadial().defined((d) => !isNaN(d.temperature));areaRadial.curve(curve) ​Source · Equivalent to area.curve. Note that curveMonotoneX or curveMonotoneY are not recommended for radial areas because they assume that the data is monotonic in x or y, which is typically untrue of radial areas.jsconst area = d3.areaRadial().curve(d3.curveBasisClosed);areaRadial.context(context) ​Source · Equivalent to area.context.jsconst context = canvas.getContext("2d");
const area = d3.areaRadial().context(context);areaRadial.lineInnerRadius() ​An alias for areaRadial.lineStartAngle.areaRadial.lineStartAngle() ​Source · Returns a new radial line generator that has this radial area generator’s current defined accessor, curve and context. The line’s angle accessor is this area’s start angle accessor, and the line’s radius accessor is this area’s inner radius accessor.areaRadial.lineEndAngle() ​Source · Returns a new radial line generator that has this radial area generator’s current defined accessor, curve and context. The line’s angle accessor is this area’s end angle accessor, and the line’s radius accessor is this area’s inner radius accessor.areaRadial.lineOuterRadius() ​Source · Returns a new radial line generator that has this radial area generator’s current defined accessor, curve and context. The line’s angle accessor is this area’s start angle accessor, and the line’s radius accessor is this area’s outer radius accessor.\n\nSearchK7.9.0GitHub️ 110.0kOn this pageRadial areas ​Examples · A radial area generator is like the Cartesian area generator except the x and y accessors are replaced with angle and radius accessors. Radial areas are positioned relative to the origin; use a transform to change the origin.areaRadial() ​Source · Constructs a new radial area generator with the default settings.jsconst area = d3.areaRadial();areaRadial(data) ​Source · Equivalent to area.jssvg.append("path").attr("d", area(data));areaRadial.angle(angle) ​Source · Equivalent to area.x, except the accessor returns the angle in radians, with 0 at -y (12 o’clock).jsconst area = d3.areaRadial().angle((d) => a(d.Date));areaRadial.startAngle(angle) ​Source · Equivalent to area.x0, except the accessor returns the angle in radians, with 0 at -y (12 o’clock). Note: typically angle is used instead of setting separate start and end angles.areaRadial.endAngle(angle) ​Source · Equivalent to area.x1, except the accessor returns the angle in radians, with 0 at -y (12 o’clock). Note: typically angle is used instead of setting separate start and end angles.areaRadial.radius(radius) ​Source · Equivalent to area.y, except the accessor returns the radius: the distance from the origin.jsconst area = d3.areaRadial().radius((d) => r(d.temperature));areaRadial.innerRadius(radius) ​Source · Equivalent to area.y0, except the accessor returns the radius: the distance from the origin.jsconst area = d3.areaRadial().radius((d) => r(d.low));areaRadial.outerRadius(radius) ​Source · Equivalent to area.y1, except the accessor returns the radius: the distance from the origin.jsconst area = d3.areaRadial().radius((d) => r(d.high));areaRadial.defined(defined) ​Source · Equivalent to area.defined.jsconst area = d3.areaRadial().defined((d) => !isNaN(d.temperature));areaRadial.curve(curve) ​Source · Equivalent to area.curve. Note that curveMonotoneX or curveMonotoneY are not recommended for radial areas because they assume that the data is monotonic in x or y, which is typically untrue of radial areas.jsconst area = d3.areaRadial().curve(d3.curveBasisClosed);areaRadial.context(context) ​Source · Equivalent to area.context.jsconst context = canvas.getContext("2d");
const area = d3.areaRadial().context(context);areaRadial.lineInnerRadius() ​An alias for areaRadial.lineStartAngle.areaRadial.lineStartAngle() ​Source · Returns a new radial line generator that has this radial area generator’s current defined accessor, curve and context. The line’s angle accessor is this area’s start angle accessor, and the line’s radius accessor is this area’s inner radius accessor.areaRadial.lineEndAngle() ​Source · Returns a new radial line generator that has this radial area generator’s current defined accessor, curve and context. The line’s angle accessor is this area’s end angle accessor, and the line’s radius accessor is this area’s inner radius accessor.areaRadial.lineOuterRadius() ​Source · Returns a new radial line generator that has this radial area generator’s current defined accessor, curve and context. The line’s angle accessor is this area’s start angle accessor, and the line’s radius accessor is this area’s outer radius accessor.PagerPrevious pageSymbolsNext pageRadial lines\n\nRadial areas ​Examples · A radial area generator is like the Cartesian area generator except the x and y accessors are replaced with angle and radius accessors. Radial areas are positioned relative to the origin; use a transform to change the origin.areaRadial() ​Source · Constructs a new radial area generator with the default settings.jsconst area = d3.areaRadial();areaRadial(data) ​Source · Equivalent to area.jssvg.append("path").attr("d", area(data));areaRadial.angle(angle) ​Source · Equivalent to area.x, except the accessor returns the angle in radians, with 0 at -y (12 o’clock).jsconst area = d3.areaRadial().angle((d) => a(d.Date));areaRadial.startAngle(angle) ​Source · Equivalent to area.x0, except the accessor returns the angle in radians, with 0 at -y (12 o’clock). Note: typically angle is used instead of setting separate start and end angles.areaRadial.endAngle(angle) ​Source · Equivalent to area.x1, except the accessor returns the angle in radians, with 0 at -y (12 o’clock). Note: typically angle is used instead of setting separate start and end angles.areaRadial.radius(radius) ​Source · Equivalent to area.y, except the accessor returns the radius: the distance from the origin.jsconst area = d3.areaRadial().radius((d) => r(d.temperature));areaRadial.innerRadius(radius) ​Source · Equivalent to area.y0, except the accessor returns the radius: the distance from the origin.jsconst area = d3.areaRadial().radius((d) => r(d.low));areaRadial.outerRadius(radius) ​Source · Equivalent to area.y1, except the accessor returns the radius: the distance from the origin.jsconst area = d3.areaRadial().radius((d) => r(d.high));areaRadial.defined(defined) ​Source · Equivalent to area.defined.jsconst area = d3.areaRadial().defined((d) => !isNaN(d.temperature));areaRadial.curve(curve) ​Source · Equivalent to area.curve. Note that curveMonotoneX or curveMonotoneY are not recommended for radial areas because they assume that the data is monotonic in x or y, which is typically untrue of radial areas.jsconst area = d3.areaRadial().curve(d3.curveBasisClosed);areaRadial.context(context) ​Source · Equivalent to area.context.jsconst context = canvas.getContext("2d");
const area = d3.areaRadial().context(context);areaRadial.lineInnerRadius() ​An alias for areaRadial.lineStartAngle.areaRadial.lineStartAngle() ​Source · Returns a new radial line generator that has this radial area generator’s current defined accessor, curve and context. The line’s angle accessor is this area’s start angle accessor, and the line’s radius accessor is this area’s inner radius accessor.areaRadial.lineEndAngle() ​Source · Returns a new radial line generator that has this radial area generator’s current defined accessor, curve and context. The line’s angle accessor is this area’s end angle accessor, and the line’s radius accessor is this area’s inner radius accessor.areaRadial.lineOuterRadius() ​Source · Returns a new radial line generator that has this radial area generator’s current defined accessor, curve and context. The line’s angle accessor is this area’s start angle accessor, and the line’s radius accessor is this area’s outer radius accessor.\n\n\n\nRadial lines ​Examples · A radial line generator is like the Cartesian line generator except the x and y accessors are replaced with angle and radius accessors. Radial lines are positioned relative to the origin; use a transform to change the origin.lineRadial() ​Source · Constructs a new radial line generator with the default settings.jsconst line = d3.lineRadial();lineRadial(data) ​Source · Equivalent to line.jssvg.append("path").attr("d", line(data)).attr("stroke", "currentColor");lineRadial.angle(angle) ​Source · Equivalent to line.x, except the accessor returns the angle in radians, with 0 at -y (12 o’clock).jsconst line = d3.lineRadial().angle((d) => a(d.Date));lineRadial.radius(radius) ​Source · Equivalent to line.y, except the accessor returns the radius: the distance from the origin.jsconst line = d3.lineRadial().radius((d) => r(d.temperature));lineRadial.defined(defined) ​Source · Equivalent to line.defined.jsconst line = d3.lineRadial().defined((d) => !isNaN(d.temperature));lineRadial.curve(curve) ​Source · Equivalent to line.curve. Note that curveMonotoneX or curveMonotoneY are not recommended for radial lines because they assume that the data is monotonic in x or y, which is typically untrue of radial lines.jsconst line = d3.lineRadial().curve(d3.curveBasis);lineRadial.context(context) ​Source · Equivalent to line.context.jsconst context = canvas.getContext("2d");
const line = d3.lineRadial().context(context);\n\nSearchK7.9.0GitHub️ 110.0kOn this pageRadial lines ​Examples · A radial line generator is like the Cartesian line generator except the x and y accessors are replaced with angle and radius accessors. Radial lines are positioned relative to the origin; use a transform to change the origin.lineRadial() ​Source · Constructs a new radial line generator with the default settings.jsconst line = d3.lineRadial();lineRadial(data) ​Source · Equivalent to line.jssvg.append("path").attr("d", line(data)).attr("stroke", "currentColor");lineRadial.angle(angle) ​Source · Equivalent to line.x, except the accessor returns the angle in radians, with 0 at -y (12 o’clock).jsconst line = d3.lineRadial().angle((d) => a(d.Date));lineRadial.radius(radius) ​Source · Equivalent to line.y, except the accessor returns the radius: the distance from the origin.jsconst line = d3.lineRadial().radius((d) => r(d.temperature));lineRadial.defined(defined) ​Source · Equivalent to line.defined.jsconst line = d3.lineRadial().defined((d) => !isNaN(d.temperature));lineRadial.curve(curve) ​Source · Equivalent to line.curve. Note that curveMonotoneX or curveMonotoneY are not recommended for radial lines because they assume that the data is monotonic in x or y, which is typically untrue of radial lines.jsconst line = d3.lineRadial().curve(d3.curveBasis);lineRadial.context(context) ​Source · Equivalent to line.context.jsconst context = canvas.getContext("2d");
const line = d3.lineRadial().context(context);PagerPrevious pageRadial areasNext pageRadial links\n\nRadial lines ​Examples · A radial line generator is like the Cartesian line generator except the x and y accessors are replaced with angle and radius accessors. Radial lines are positioned relative to the origin; use a transform to change the origin.lineRadial() ​Source · Constructs a new radial line generator with the default settings.jsconst line = d3.lineRadial();lineRadial(data) ​Source · Equivalent to line.jssvg.append("path").attr("d", line(data)).attr("stroke", "currentColor");lineRadial.angle(angle) ​Source · Equivalent to line.x, except the accessor returns the angle in radians, with 0 at -y (12 o’clock).jsconst line = d3.lineRadial().angle((d) => a(d.Date));lineRadial.radius(radius) ​Source · Equivalent to line.y, except the accessor returns the radius: the distance from the origin.jsconst line = d3.lineRadial().radius((d) => r(d.temperature));lineRadial.defined(defined) ​Source · Equivalent to line.defined.jsconst line = d3.lineRadial().defined((d) => !isNaN(d.temperature));lineRadial.curve(curve) ​Source · Equivalent to line.curve. Note that curveMonotoneX or curveMonotoneY are not recommended for radial lines because they assume that the data is monotonic in x or y, which is typically untrue of radial lines.jsconst line = d3.lineRadial().curve(d3.curveBasis);lineRadial.context(context) ​Source · Equivalent to line.context.jsconst context = canvas.getContext("2d");
const line = d3.lineRadial().context(context);\n\n\n\nRadial links ​A radial link generator is like the Cartesian link generator except the x and y accessors are replaced with angle and radius accessors. Radial links are positioned relative to the origin; use a transform to change the origin.linkRadial() ​Source · Returns a new link generator with radial tangents. For example, to visualize links in a tree diagram rooted in the center of the display, you might say:jsconst link = d3.linkRadial()
    .angle((d) => d.x)
    .radius((d) => d.y);linkRadial.angle(angle) ​Source · Equivalent to link.x, except the accessor returns the angle in radians, with 0 at -y (12 o’clock).linkRadial.radius(radius) ​Source · Equivalent to link.y, except the accessor returns the radius: the distance from the origin.\n\nSearchK7.9.0GitHub️ 110.0kOn this pageRadial links ​A radial link generator is like the Cartesian link generator except the x and y accessors are replaced with angle and radius accessors. Radial links are positioned relative to the origin; use a transform to change the origin.linkRadial() ​Source · Returns a new link generator with radial tangents. For example, to visualize links in a tree diagram rooted in the center of the display, you might say:jsconst link = d3.linkRadial()
    .angle((d) => d.x)
    .radius((d) => d.y);linkRadial.angle(angle) ​Source · Equivalent to link.x, except the accessor returns the angle in radians, with 0 at -y (12 o’clock).linkRadial.radius(radius) ​Source · Equivalent to link.y, except the accessor returns the radius: the distance from the origin.PagerPrevious pageRadial linesNext paged3-ease\n\nRadial links ​A radial link generator is like the Cartesian link generator except the x and y accessors are replaced with angle and radius accessors. Radial links are positioned relative to the origin; use a transform to change the origin.linkRadial() ​Source · Returns a new link generator with radial tangents. For example, to visualize links in a tree diagram rooted in the center of the display, you might say:jsconst link = d3.linkRadial()
    .angle((d) => d.x)
    .radius((d) => d.y);linkRadial.angle(angle) ​Source · Equivalent to link.x, except the accessor returns the angle in radians, with 0 at -y (12 o’clock).linkRadial.radius(radius) ​Source · Equivalent to link.y, except the accessor returns the radius: the distance from the origin.\n\n\n\nd3-ease ​Examples · Easing is a method of distorting time to control apparent motion in animation. It is most commonly used for slow-in, slow-out. By easing time, animated transitions are smoother and exhibit more plausible motion.The easing types in this module implement the ease method which takes a normalized time t and returns the corresponding “eased” time tʹ. Both the normalized time and the eased time are typically in the range [0,1], where 0 represents the start of the animation and 1 represents the end; some easing types, such as easeElastic, may return eased times slightly outside this range. A good easing type should return 0 if t = 0 and 1 if t = 1.These easing types are largely based on work by Robert Penner.ease(t) ​Given the specified normalized time t, typically in the range [0,1], returns the “eased” time tʹ, also typically in [0,1]. 0 represents the start of the animation and 1 represents the end. A good implementation returns 0 if t = 0 and 1 if t = 1. For example, to apply easeCubic easing:jsconst te = d3.easeCubic(t);To apply custom elastic easing, create your easing function before the animation starts:jsconst ease = d3.easeElastic.period(0.4);Then during the animation, apply the easing function:jsconst te = ease(t);See also transition.ease.easeLinear ​Source · Linear easing; the identity function; linear(t) returns t.easePoly ​Source · Alias for easePolyInOut.easePolyIn ​Polynomial easing; raises t to the specified exponent. If the exponent is not specified, it defaults to 3, equivalent to easeCubicIn.easePolyOut ​Reverse polynomial easing; equivalent to 1 - easePolyIn(1 - t). If the exponent is not specified, it defaults to 3, equivalent to easeCubicOut.easePolyInOut ​Symmetric polynomial easing; scales easePolyIn for t in 0–0.5 and easePolyOut for t in 0.5–1. If the exponent is not specified, it defaults to 3, equivalent to easeCubic.easePoly.exponent(e) ​Exponent:2.00Returns a new polynomial easing with the specified exponent e. For example, to create equivalents of easeLinear, easeQuad, and easeCubic:jsconst linear = d3.easePoly.exponent(1);
const quad = d3.easePoly.exponent(2);
const cubic = d3.easePoly.exponent(3);easeQuad ​Source · Alias for easeQuadInOut.easeQuadIn ​Quadratic easing; equivalent to easePolyIn.exponent(2).easeQuadOut ​Reverse quadratic easing; equivalent to 1 - easeQuadIn(1 - t). Also equivalent to easePolyOut.exponent(2).easeQuadInOut ​Symmetric quadratic easing; scales easeQuadIn for t in 0–0.5 and easeQuadOut for t in 0.5–1. Also equivalent to easePoly.exponent(2).easeCubic ​Source · Alias for easeCubicInOut.easeCubicIn ​Cubic easing; equivalent to easePolyIn.exponent(3).easeCubicOut ​Reverse cubic easing; equivalent to 1 - easeCubicIn(1 - t). Also equivalent to easePolyOut.exponent(3).easeCubicInOut ​Symmetric cubic easing; scales easeCubicIn for t in 0–0.5 and easeCubicOut for t in 0.5–1. Also equivalent to easePoly.exponent(3).easeSin ​Source · Alias for easeSinInOut.easeSinIn ​Sinusoidal easing; returns sin(t).easeSinOut ​Reverse sinusoidal easing; equivalent to 1 - easeSinIn(1 - t).easeSinInOut ​Symmetric sinusoidal easing; scales easeSinIn for t in 0–0.5 and easeSinOut for t in 0.5–1.easeExp ​Source · Alias for easeExpInOut.easeExpIn ​Exponential easing; raises 2 to the exponent 10 × (t - 1).easeExpOut ​Reverse exponential easing; equivalent to 1 - easeExpIn(1 - t).easeExpInOut ​Symmetric exponential easing; scales easeExpIn for t in 0–0.5 and easeExpOut for t in 0.5–1.easeCircle ​Source · Alias for easeCircleInOut.easeCircleIn ​Circular easing.easeCircleOut ​Reverse circular easing; equivalent to 1 - easeCircleIn(1 - t).easeCircleInOut ​Symmetric circular easing; scales easeCircleIn for t in 0–0.5 and easeCircleOut for t in 0.5–1.easeElastic ​Source · Alias for easeElasticOut.easeElasticIn ​Elastic easing, like a rubber band. The amplitude and period of the oscillation are configurable; if not specified, they default to 1 and 0.3, respectively.easeElasticOut ​Reverse elastic easing; equivalent to 1 - elasticIn(1 - t).easeElasticInOut ​Symmetric elastic easing; scales elasticIn for t in 0–0.5 and elasticOut for t in 0.5–1.easeElastic.amplitude(a) ​Amplitude:1.00Returns a new elastic easing with the specified amplitude a. The amplitude a must be greater than or equal to 1.easeElastic.period(p) ​Period:0.30Returns a new elastic easing with the specified period p.easeBack ​Source · Alias for easeBackInOut.easeBackIn ​Anticipatory easing like a dancer bending her knees before jumping off the floor. The degree of overshoot is configurable; if not specified, it defaults to 1.70158.easeBackOut ​Reverse anticipatory easing; equivalent to 1 - easeBackIn(1 - t).easeBackInOut ​Symmetric anticipatory easing; scales easeBackIn for t in 0–0.5 and easeBackOut for t in 0.5–1.easeBack.overshoot(s) ​Overshoot:1.70Returns a new back easing with the specified overshoot s.easeBounce ​Source · Alias for easeBounceOut.easeBounceIn ​Bounce easing, like a rubber ball.easeBounceOut ​Reverse bounce easing; equivalent to 1 - easeBounceIn(1 - t).easeBounceInOut ​Symmetric bounce easing; scales easeBounceIn for t in 0–0.5 and easeBounceOut for t in 0.5–1.\n\nSearchK7.9.0GitHub️ 110.0kOn this paged3-ease ​Examples · Easing is a method of distorting time to control apparent motion in animation. It is most commonly used for slow-in, slow-out. By easing time, animated transitions are smoother and exhibit more plausible motion.The easing types in this module implement the ease method which takes a normalized time t and returns the corresponding “eased” time tʹ. Both the normalized time and the eased time are typically in the range [0,1], where 0 represents the start of the animation and 1 represents the end; some easing types, such as easeElastic, may return eased times slightly outside this range. A good easing type should return 0 if t = 0 and 1 if t = 1.These easing types are largely based on work by Robert Penner.ease(t) ​Given the specified normalized time t, typically in the range [0,1], returns the “eased” time tʹ, also typically in [0,1]. 0 represents the start of the animation and 1 represents the end. A good implementation returns 0 if t = 0 and 1 if t = 1. For example, to apply easeCubic easing:jsconst te = d3.easeCubic(t);To apply custom elastic easing, create your easing function before the animation starts:jsconst ease = d3.easeElastic.period(0.4);Then during the animation, apply the easing function:jsconst te = ease(t);See also transition.ease.easeLinear ​Source · Linear easing; the identity function; linear(t) returns t.easePoly ​Source · Alias for easePolyInOut.easePolyIn ​Polynomial easing; raises t to the specified exponent. If the exponent is not specified, it defaults to 3, equivalent to easeCubicIn.easePolyOut ​Reverse polynomial easing; equivalent to 1 - easePolyIn(1 - t). If the exponent is not specified, it defaults to 3, equivalent to easeCubicOut.easePolyInOut ​Symmetric polynomial easing; scales easePolyIn for t in 0–0.5 and easePolyOut for t in 0.5–1. If the exponent is not specified, it defaults to 3, equivalent to easeCubic.easePoly.exponent(e) ​Exponent:2.00Returns a new polynomial easing with the specified exponent e. For example, to create equivalents of easeLinear, easeQuad, and easeCubic:jsconst linear = d3.easePoly.exponent(1);
const quad = d3.easePoly.exponent(2);
const cubic = d3.easePoly.exponent(3);easeQuad ​Source · Alias for easeQuadInOut.easeQuadIn ​Quadratic easing; equivalent to easePolyIn.exponent(2).easeQuadOut ​Reverse quadratic easing; equivalent to 1 - easeQuadIn(1 - t). Also equivalent to easePolyOut.exponent(2).easeQuadInOut ​Symmetric quadratic easing; scales easeQuadIn for t in 0–0.5 and easeQuadOut for t in 0.5–1. Also equivalent to easePoly.exponent(2).easeCubic ​Source · Alias for easeCubicInOut.easeCubicIn ​Cubic easing; equivalent to easePolyIn.exponent(3).easeCubicOut ​Reverse cubic easing; equivalent to 1 - easeCubicIn(1 - t). Also equivalent to easePolyOut.exponent(3).easeCubicInOut ​Symmetric cubic easing; scales easeCubicIn for t in 0–0.5 and easeCubicOut for t in 0.5–1. Also equivalent to easePoly.exponent(3).easeSin ​Source · Alias for easeSinInOut.easeSinIn ​Sinusoidal easing; returns sin(t).easeSinOut ​Reverse sinusoidal easing; equivalent to 1 - easeSinIn(1 - t).easeSinInOut ​Symmetric sinusoidal easing; scales easeSinIn for t in 0–0.5 and easeSinOut for t in 0.5–1.easeExp ​Source · Alias for easeExpInOut.easeExpIn ​Exponential easing; raises 2 to the exponent 10 × (t - 1).easeExpOut ​Reverse exponential easing; equivalent to 1 - easeExpIn(1 - t).easeExpInOut ​Symmetric exponential easing; scales easeExpIn for t in 0–0.5 and easeExpOut for t in 0.5–1.easeCircle ​Source · Alias for easeCircleInOut.easeCircleIn ​Circular easing.easeCircleOut ​Reverse circular easing; equivalent to 1 - easeCircleIn(1 - t).easeCircleInOut ​Symmetric circular easing; scales easeCircleIn for t in 0–0.5 and easeCircleOut for t in 0.5–1.easeElastic ​Source · Alias for easeElasticOut.easeElasticIn ​Elastic easing, like a rubber band. The amplitude and period of the oscillation are configurable; if not specified, they default to 1 and 0.3, respectively.easeElasticOut ​Reverse elastic easing; equivalent to 1 - elasticIn(1 - t).easeElasticInOut ​Symmetric elastic easing; scales elasticIn for t in 0–0.5 and elasticOut for t in 0.5–1.easeElastic.amplitude(a) ​Amplitude:1.00Returns a new elastic easing with the specified amplitude a. The amplitude a must be greater than or equal to 1.easeElastic.period(p) ​Period:0.30Returns a new elastic easing with the specified period p.easeBack ​Source · Alias for easeBackInOut.easeBackIn ​Anticipatory easing like a dancer bending her knees before jumping off the floor. The degree of overshoot is configurable; if not specified, it defaults to 1.70158.easeBackOut ​Reverse anticipatory easing; equivalent to 1 - easeBackIn(1 - t).easeBackInOut ​Symmetric anticipatory easing; scales easeBackIn for t in 0–0.5 and easeBackOut for t in 0.5–1.easeBack.overshoot(s) ​Overshoot:1.70Returns a new back easing with the specified overshoot s.easeBounce ​Source · Alias for easeBounceOut.easeBounceIn ​Bounce easing, like a rubber ball.easeBounceOut ​Reverse bounce easing; equivalent to 1 - easeBounceIn(1 - t).easeBounceInOut ​Symmetric bounce easing; scales easeBounceIn for t in 0–0.5 and easeBounceOut for t in 0.5–1.PagerPrevious pageRadial linksNext paged3-timer\n\nd3-ease ​Examples · Easing is a method of distorting time to control apparent motion in animation. It is most commonly used for slow-in, slow-out. By easing time, animated transitions are smoother and exhibit more plausible motion.The easing types in this module implement the ease method which takes a normalized time t and returns the corresponding “eased” time tʹ. Both the normalized time and the eased time are typically in the range [0,1], where 0 represents the start of the animation and 1 represents the end; some easing types, such as easeElastic, may return eased times slightly outside this range. A good easing type should return 0 if t = 0 and 1 if t = 1.These easing types are largely based on work by Robert Penner.ease(t) ​Given the specified normalized time t, typically in the range [0,1], returns the “eased” time tʹ, also typically in [0,1]. 0 represents the start of the animation and 1 represents the end. A good implementation returns 0 if t = 0 and 1 if t = 1. For example, to apply easeCubic easing:jsconst te = d3.easeCubic(t);To apply custom elastic easing, create your easing function before the animation starts:jsconst ease = d3.easeElastic.period(0.4);Then during the animation, apply the easing function:jsconst te = ease(t);See also transition.ease.easeLinear ​Source · Linear easing; the identity function; linear(t) returns t.easePoly ​Source · Alias for easePolyInOut.easePolyIn ​Polynomial easing; raises t to the specified exponent. If the exponent is not specified, it defaults to 3, equivalent to easeCubicIn.easePolyOut ​Reverse polynomial easing; equivalent to 1 - easePolyIn(1 - t). If the exponent is not specified, it defaults to 3, equivalent to easeCubicOut.easePolyInOut ​Symmetric polynomial easing; scales easePolyIn for t in 0–0.5 and easePolyOut for t in 0.5–1. If the exponent is not specified, it defaults to 3, equivalent to easeCubic.easePoly.exponent(e) ​Exponent:2.00Returns a new polynomial easing with the specified exponent e. For example, to create equivalents of easeLinear, easeQuad, and easeCubic:jsconst linear = d3.easePoly.exponent(1);
const quad = d3.easePoly.exponent(2);
const cubic = d3.easePoly.exponent(3);easeQuad ​Source · Alias for easeQuadInOut.easeQuadIn ​Quadratic easing; equivalent to easePolyIn.exponent(2).easeQuadOut ​Reverse quadratic easing; equivalent to 1 - easeQuadIn(1 - t). Also equivalent to easePolyOut.exponent(2).easeQuadInOut ​Symmetric quadratic easing; scales easeQuadIn for t in 0–0.5 and easeQuadOut for t in 0.5–1. Also equivalent to easePoly.exponent(2).easeCubic ​Source · Alias for easeCubicInOut.easeCubicIn ​Cubic easing; equivalent to easePolyIn.exponent(3).easeCubicOut ​Reverse cubic easing; equivalent to 1 - easeCubicIn(1 - t). Also equivalent to easePolyOut.exponent(3).easeCubicInOut ​Symmetric cubic easing; scales easeCubicIn for t in 0–0.5 and easeCubicOut for t in 0.5–1. Also equivalent to easePoly.exponent(3).easeSin ​Source · Alias for easeSinInOut.easeSinIn ​Sinusoidal easing; returns sin(t).easeSinOut ​Reverse sinusoidal easing; equivalent to 1 - easeSinIn(1 - t).easeSinInOut ​Symmetric sinusoidal easing; scales easeSinIn for t in 0–0.5 and easeSinOut for t in 0.5–1.easeExp ​Source · Alias for easeExpInOut.easeExpIn ​Exponential easing; raises 2 to the exponent 10 × (t - 1).easeExpOut ​Reverse exponential easing; equivalent to 1 - easeExpIn(1 - t).easeExpInOut ​Symmetric exponential easing; scales easeExpIn for t in 0–0.5 and easeExpOut for t in 0.5–1.easeCircle ​Source · Alias for easeCircleInOut.easeCircleIn ​Circular easing.easeCircleOut ​Reverse circular easing; equivalent to 1 - easeCircleIn(1 - t).easeCircleInOut ​Symmetric circular easing; scales easeCircleIn for t in 0–0.5 and easeCircleOut for t in 0.5–1.easeElastic ​Source · Alias for easeElasticOut.easeElasticIn ​Elastic easing, like a rubber band. The amplitude and period of the oscillation are configurable; if not specified, they default to 1 and 0.3, respectively.easeElasticOut ​Reverse elastic easing; equivalent to 1 - elasticIn(1 - t).easeElasticInOut ​Symmetric elastic easing; scales elasticIn for t in 0–0.5 and elasticOut for t in 0.5–1.easeElastic.amplitude(a) ​Amplitude:1.00Returns a new elastic easing with the specified amplitude a. The amplitude a must be greater than or equal to 1.easeElastic.period(p) ​Period:0.30Returns a new elastic easing with the specified period p.easeBack ​Source · Alias for easeBackInOut.easeBackIn ​Anticipatory easing like a dancer bending her knees before jumping off the floor. The degree of overshoot is configurable; if not specified, it defaults to 1.70158.easeBackOut ​Reverse anticipatory easing; equivalent to 1 - easeBackIn(1 - t).easeBackInOut ​Symmetric anticipatory easing; scales easeBackIn for t in 0–0.5 and easeBackOut for t in 0.5–1.easeBack.overshoot(s) ​Overshoot:1.70Returns a new back easing with the specified overshoot s.easeBounce ​Source · Alias for easeBounceOut.easeBounceIn ​Bounce easing, like a rubber ball.easeBounceOut ​Reverse bounce easing; equivalent to 1 - easeBounceIn(1 - t).easeBounceInOut ​Symmetric bounce easing; scales easeBounceIn for t in 0–0.5 and easeBounceOut for t in 0.5–1.\n\n\n\nd3-timer ​This module provides an efficient queue capable of managing thousands of concurrent animations, while guaranteeing consistent, synchronized timing with concurrent or staged animations. Internally, it uses requestAnimationFrame for fluid animation (if available), switching to setTimeout for delays longer than 24ms.now() ​Source · Returns the current time as defined by performance.now if available, and Date.now if not.jsd3.now() // 1236.3000000715256The current time is updated at the start of a frame; it is thus consistent during the frame, and any timers scheduled during the same frame will be synchronized. If this method is called outside of a frame, such as in response to a user event, the current time is calculated and then fixed until the next frame, again ensuring consistent timing during event handling.timer(callback, delay, time) ​Source · Schedules a new timer, invoking the specified callback repeatedly until the timer is stopped. An optional numeric delay in milliseconds may be specified to invoke the given callback after a delay; if delay is not specified, it defaults to zero. The delay is relative to the specified time in milliseconds; if time is not specified, it defaults to now.The callback is passed the (apparent) elapsed time since the timer became active. For example:jsconst t = d3.timer((elapsed) => {
  console.log(elapsed);
  if (elapsed > 200) t.stop();
}, 150);This produces roughly the following console output:3
25
48
65
85
106
125
146
167
189
209(The exact values may vary depending on your JavaScript runtime and what else your computer is doing.) Note that the first elapsed time is 3ms: this is the elapsed time since the timer started, not since the timer was scheduled. Here the timer started 150ms after it was scheduled due to the specified delay. The apparent elapsed time may be less than the true elapsed time if the page is backgrounded and requestAnimationFrame is paused; in the background, apparent time is frozen.If timer is called within the callback of another timer, the new timer callback (if eligible as determined by the specified delay and time) will be invoked immediately at the end of the current frame, rather than waiting until the next frame. Within a frame, timer callbacks are guaranteed to be invoked in the order they were scheduled, regardless of their start time.timer.restart(callback, delay, time) ​Source · Restart a timer with the specified callback and optional delay and time. This is equivalent to stopping this timer and creating a new timer with the specified arguments, although this timer retains the original invocation priority.timer.stop() ​Source · Stops this timer, preventing subsequent callbacks. This method has no effect if the timer has already stopped.timerFlush() ​Source · Immediately invoke any eligible timer callbacks. Note that zero-delay timers are normally first executed after one frame (~17ms). This can cause a brief flicker because the browser renders the page twice: once at the end of the first event loop, then again immediately on the first timer callback. By flushing the timer queue at the end of the first event loop, you can run any zero-delay timers immediately and avoid the flicker.timeout(callback, delay, time) ​Source · Like timer, except the timer automatically stops on its first callback. A suitable replacement for setTimeout that is guaranteed to not run in the background. The callback is passed the elapsed time.interval(callback, delay, time) ​Source · Like timer, except the callback is invoked only every delay milliseconds; if delay is not specified, this is equivalent to timer. A suitable replacement for setInterval that is guaranteed to not run in the background. The callback is passed the elapsed time.\n\nSearchK7.9.0GitHub️ 110.0kOn this paged3-timer ​This module provides an efficient queue capable of managing thousands of concurrent animations, while guaranteeing consistent, synchronized timing with concurrent or staged animations. Internally, it uses requestAnimationFrame for fluid animation (if available), switching to setTimeout for delays longer than 24ms.now() ​Source · Returns the current time as defined by performance.now if available, and Date.now if not.jsd3.now() // 1236.3000000715256The current time is updated at the start of a frame; it is thus consistent during the frame, and any timers scheduled during the same frame will be synchronized. If this method is called outside of a frame, such as in response to a user event, the current time is calculated and then fixed until the next frame, again ensuring consistent timing during event handling.timer(callback, delay, time) ​Source · Schedules a new timer, invoking the specified callback repeatedly until the timer is stopped. An optional numeric delay in milliseconds may be specified to invoke the given callback after a delay; if delay is not specified, it defaults to zero. The delay is relative to the specified time in milliseconds; if time is not specified, it defaults to now.The callback is passed the (apparent) elapsed time since the timer became active. For example:jsconst t = d3.timer((elapsed) => {
  console.log(elapsed);
  if (elapsed > 200) t.stop();
}, 150);This produces roughly the following console output:3
25
48
65
85
106
125
146
167
189
209(The exact values may vary depending on your JavaScript runtime and what else your computer is doing.) Note that the first elapsed time is 3ms: this is the elapsed time since the timer started, not since the timer was scheduled. Here the timer started 150ms after it was scheduled due to the specified delay. The apparent elapsed time may be less than the true elapsed time if the page is backgrounded and requestAnimationFrame is paused; in the background, apparent time is frozen.If timer is called within the callback of another timer, the new timer callback (if eligible as determined by the specified delay and time) will be invoked immediately at the end of the current frame, rather than waiting until the next frame. Within a frame, timer callbacks are guaranteed to be invoked in the order they were scheduled, regardless of their start time.timer.restart(callback, delay, time) ​Source · Restart a timer with the specified callback and optional delay and time. This is equivalent to stopping this timer and creating a new timer with the specified arguments, although this timer retains the original invocation priority.timer.stop() ​Source · Stops this timer, preventing subsequent callbacks. This method has no effect if the timer has already stopped.timerFlush() ​Source · Immediately invoke any eligible timer callbacks. Note that zero-delay timers are normally first executed after one frame (~17ms). This can cause a brief flicker because the browser renders the page twice: once at the end of the first event loop, then again immediately on the first timer callback. By flushing the timer queue at the end of the first event loop, you can run any zero-delay timers immediately and avoid the flicker.timeout(callback, delay, time) ​Source · Like timer, except the timer automatically stops on its first callback. A suitable replacement for setTimeout that is guaranteed to not run in the background. The callback is passed the elapsed time.interval(callback, delay, time) ​Source · Like timer, except the callback is invoked only every delay milliseconds; if delay is not specified, this is equivalent to timer. A suitable replacement for setInterval that is guaranteed to not run in the background. The callback is passed the elapsed time.PagerPrevious paged3-easeNext paged3-transition\n\nd3-timer ​This module provides an efficient queue capable of managing thousands of concurrent animations, while guaranteeing consistent, synchronized timing with concurrent or staged animations. Internally, it uses requestAnimationFrame for fluid animation (if available), switching to setTimeout for delays longer than 24ms.now() ​Source · Returns the current time as defined by performance.now if available, and Date.now if not.jsd3.now() // 1236.3000000715256The current time is updated at the start of a frame; it is thus consistent during the frame, and any timers scheduled during the same frame will be synchronized. If this method is called outside of a frame, such as in response to a user event, the current time is calculated and then fixed until the next frame, again ensuring consistent timing during event handling.timer(callback, delay, time) ​Source · Schedules a new timer, invoking the specified callback repeatedly until the timer is stopped. An optional numeric delay in milliseconds may be specified to invoke the given callback after a delay; if delay is not specified, it defaults to zero. The delay is relative to the specified time in milliseconds; if time is not specified, it defaults to now.The callback is passed the (apparent) elapsed time since the timer became active. For example:jsconst t = d3.timer((elapsed) => {
  console.log(elapsed);
  if (elapsed > 200) t.stop();
}, 150);This produces roughly the following console output:3
25
48
65
85
106
125
146
167
189
209(The exact values may vary depending on your JavaScript runtime and what else your computer is doing.) Note that the first elapsed time is 3ms: this is the elapsed time since the timer started, not since the timer was scheduled. Here the timer started 150ms after it was scheduled due to the specified delay. The apparent elapsed time may be less than the true elapsed time if the page is backgrounded and requestAnimationFrame is paused; in the background, apparent time is frozen.If timer is called within the callback of another timer, the new timer callback (if eligible as determined by the specified delay and time) will be invoked immediately at the end of the current frame, rather than waiting until the next frame. Within a frame, timer callbacks are guaranteed to be invoked in the order they were scheduled, regardless of their start time.timer.restart(callback, delay, time) ​Source · Restart a timer with the specified callback and optional delay and time. This is equivalent to stopping this timer and creating a new timer with the specified arguments, although this timer retains the original invocation priority.timer.stop() ​Source · Stops this timer, preventing subsequent callbacks. This method has no effect if the timer has already stopped.timerFlush() ​Source · Immediately invoke any eligible timer callbacks. Note that zero-delay timers are normally first executed after one frame (~17ms). This can cause a brief flicker because the browser renders the page twice: once at the end of the first event loop, then again immediately on the first timer callback. By flushing the timer queue at the end of the first event loop, you can run any zero-delay timers immediately and avoid the flicker.timeout(callback, delay, time) ​Source · Like timer, except the timer automatically stops on its first callback. A suitable replacement for setTimeout that is guaranteed to not run in the background. The callback is passed the elapsed time.interval(callback, delay, time) ​Source · Like timer, except the callback is invoked only every delay milliseconds; if delay is not specified, this is equivalent to timer. A suitable replacement for setInterval that is guaranteed to not run in the background. The callback is passed the elapsed time.\n\n\n\nd3-transition ​A transition is a selection-like interface for animating changes to the DOM. Instead of applying changes instantaneously, transitions smoothly interpolate the DOM from its current state to the desired target state over a given duration.To apply a transition, select elements, call selection.transition, and then make the desired changes. For example:jsd3.select("body")
  .transition()
    .style("background-color", "red");Transitions support most selection methods (such as transition.attr and transition.style in place of selection.attr and selection.style), but not all methods are supported; for example, you must append elements or bind data before a transition starts. A transition.remove operator is provided for convenient removal of elements when the transition ends.To compute intermediate state, transitions leverage a variety of built-in interpolators. Colors, numbers, and transforms are automatically detected. Strings with embedded numbers are also detected, as is common with many styles (such as padding or font sizes) and paths. To specify a custom interpolator, use transition.attrTween, transition.styleTween or transition.tween.See one of:Selecting elementsModifying elementsTimingControl flow\n\nSearchK7.9.0GitHub️ 110.0kOn this paged3-transition ​A transition is a selection-like interface for animating changes to the DOM. Instead of applying changes instantaneously, transitions smoothly interpolate the DOM from its current state to the desired target state over a given duration.To apply a transition, select elements, call selection.transition, and then make the desired changes. For example:jsd3.select("body")
  .transition()
    .style("background-color", "red");Transitions support most selection methods (such as transition.attr and transition.style in place of selection.attr and selection.style), but not all methods are supported; for example, you must append elements or bind data before a transition starts. A transition.remove operator is provided for convenient removal of elements when the transition ends.To compute intermediate state, transitions leverage a variety of built-in interpolators. Colors, numbers, and transforms are automatically detected. Strings with embedded numbers are also detected, as is common with many styles (such as padding or font sizes) and paths. To specify a custom interpolator, use transition.attrTween, transition.styleTween or transition.tween.See one of:Selecting elementsModifying elementsTimingControl flowPagerPrevious paged3-timerNext pageSelecting elements\n\nd3-transition ​A transition is a selection-like interface for animating changes to the DOM. Instead of applying changes instantaneously, transitions smoothly interpolate the DOM from its current state to the desired target state over a given duration.To apply a transition, select elements, call selection.transition, and then make the desired changes. For example:jsd3.select("body")
  .transition()
    .style("background-color", "red");Transitions support most selection methods (such as transition.attr and transition.style in place of selection.attr and selection.style), but not all methods are supported; for example, you must append elements or bind data before a transition starts. A transition.remove operator is provided for convenient removal of elements when the transition ends.To compute intermediate state, transitions leverage a variety of built-in interpolators. Colors, numbers, and transforms are automatically detected. Strings with embedded numbers are also detected, as is common with many styles (such as padding or font sizes) and paths. To specify a custom interpolator, use transition.attrTween, transition.styleTween or transition.tween.See one of:Selecting elementsModifying elementsTimingControl flow\n\n\n\nSelecting elements ​Transitions are derived from selections via selection.transition. You can also create a transition on the document root element using d3.transition.selection.transition(name) ​Source · Returns a new transition on the given selection with the specified name. If a name is not specified, null is used. The new transition is only exclusive with other transitions of the same name.If the name is a transition instance, the returned transition has the same id and name as the specified transition. If a transition with the same id already exists on a selected element, the existing transition is returned for that element. Otherwise, the timing of the returned transition is inherited from the existing transition of the same id on the nearest ancestor of each selected element. Thus, this method can be used to synchronize a transition across multiple selections, or to re-select a transition for specific elements and modify its configuration. For example:jsconst t = d3.transition()
    .duration(750)
    .ease(d3.easeLinear);

d3.selectAll(".apple").transition(t)
    .style("fill", "red");

d3.selectAll(".orange").transition(t)
    .style("fill", "orange");If the specified transition is not found on a selected node or its ancestors (such as if the transition already ended), the default timing parameters are used; however, in a future release, this will likely be changed to throw an error. See #59.transition(name) ​Source · Returns a new transition on the root element, document.documentElement, with the specified name. If a name is not specified, null is used. The new transition is only exclusive with other transitions of the same name. The name may also be a transition instance; see selection.transition. This method is equivalent to:jsd3.selection()
  .transition(name)This function can also be used to test for transitions (instanceof d3.transition) or to extend the transition prototype.transition.select(selector) ​Source · For each selected element, selects the first descendant element that matches the specified selector string, if any, and returns a transition on the resulting selection. The selector may be specified either as a selector string or a function. If a function, it is evaluated for each selected element, in order, being passed the current datum (d), the current index (i), and the current group (nodes), with this as the current DOM element. The new transition has the same id, name and timing as this transition; however, if a transition with the same id already exists on a selected element, the existing transition is returned for that element.This method is equivalent to deriving the selection for this transition via transition.selection, creating a subselection via selection.select, and then creating a new transition via selection.transition:jstransition
  .selection()
  .select(selector)
  .transition(transition)transition.selectAll(selector) ​Source · For each selected element, selects all descendant elements that match the specified selector string, if any, and returns a transition on the resulting selection. The selector may be specified either as a selector string or a function. If a function, it is evaluated for each selected element, in order, being passed the current datum (d), the current index (i), and the current group (nodes), with this as the current DOM element. The new transition has the same id, name and timing as this transition; however, if a transition with the same id already exists on a selected element, the existing transition is returned for that element.This method is equivalent to deriving the selection for this transition via transition.selection, creating a subselection via selection.selectAll, and then creating a new transition via selection.transition:jstransition
  .selection()
  .selectAll(selector)
  .transition(transition)transition.selectChild(selector) ​Source · For each selected element, selects the first child element that matches the specified selector string, if any, and returns a transition on the resulting selection. The selector may be specified either as a selector string or a function. If a function, it is evaluated for each selected element, in order, being passed the current datum (d), the current index (i), and the current group (nodes), with this as the current DOM element. The new transition has the same id, name and timing as this transition; however, if a transition with the same id already exists on a selected element, the existing transition is returned for that element.This method is equivalent to deriving the selection for this transition via transition.selection, creating a subselection via selection.selectChild, and then creating a new transition via selection.transition:jstransition
  .selection()
  .selectChild(selector)
  .transition(transition)transition.selectChildren(selector) ​Source · For each selected element, selects all children that match the specified selector string, if any, and returns a transition on the resulting selection. The selector may be specified either as a selector string or a function. If a function, it is evaluated for each selected element, in order, being passed the current datum (d), the current index (i), and the current group (nodes), with this as the current DOM element. The new transition has the same id, name and timing as this transition; however, if a transition with the same id already exists on a selected element, the existing transition is returned for that element.This method is equivalent to deriving the selection for this transition via transition.selection, creating a subselection via selection.selectChildren, and then creating a new transition via selection.transition:jstransition
  .selection()
  .selectChildren(selector)
  .transition(transition)transition.filter(filter) ​Source · For each selected element, selects only the elements that match the specified filter, and returns a transition on the resulting selection. The filter may be specified either as a selector string or a function. If a function, it is evaluated for each selected element, in order, being passed the current datum (d), the current index (i), and the current group (nodes), with this as the current DOM element. The new transition has the same id, name and timing as this transition; however, if a transition with the same id already exists on a selected element, the existing transition is returned for that element.This method is equivalent to deriving the selection for this transition via transition.selection, creating a subselection via selection.filter, and then creating a new transition via selection.transition:jstransition
  .selection()
  .filter(filter)
  .transition(transition)transition.merge(other) ​Source · Returns a new transition merging this transition with the specified other transition, which must have the same id as this transition. The returned transition has the same number of groups, the same parents, the same name and the same id as this transition. Any missing (null) elements in this transition are filled with the corresponding element, if present (not null), from the other transition.This method is equivalent to deriving the selection for this transition via transition.selection, merging with the selection likewise derived from the other transition via selection.merge, and then creating a new transition via selection.transition:jstransition
  .selection()
  .merge(other.selection())
  .transition(transition)transition.transition() ​Source · Returns a new transition on the same selected elements as this transition, scheduled to start when this transition ends. The new transition inherits a reference time equal to this transition’s time plus its delay and duration. The new transition also inherits this transition’s name, duration, and easing. This method can be used to schedule a sequence of chained transitions. For example:jsd3.selectAll(".apple")
  .transition() // First fade to green.
    .style("fill", "green")
  .transition() // Then red.
    .style("fill", "red")
  .transition() // Wait one second. Then brown, and remove.
    .delay(1000)
    .style("fill", "brown")
    .remove();The delay for each transition is relative to its previous transition. Thus, in the above example, apples will stay red for one second before the last transition to brown starts.transition.selection() ​Source · Returns the selection corresponding to this transition.active(node, name) ​Examples · Source · Returns the active transition on the specified node with the specified name, if any. If no name is specified, null is used. Returns null if there is no such active transition on the specified node. This method is useful for creating chained transitions. For example, to initiate disco mode:jsd3.selectAll("circle").transition()
    .delay((d, i) => i * 50)
    .on("start", function repeat() {
        d3.active(this)
            .style("fill", "red")
          .transition()
            .style("fill", "green")
          .transition()
            .style("fill", "blue")
          .transition()
            .on("start", repeat);
      });\n\nSearchK7.9.0GitHub️ 110.0kOn this pageSelecting elements ​Transitions are derived from selections via selection.transition. You can also create a transition on the document root element using d3.transition.selection.transition(name) ​Source · Returns a new transition on the given selection with the specified name. If a name is not specified, null is used. The new transition is only exclusive with other transitions of the same name.If the name is a transition instance, the returned transition has the same id and name as the specified transition. If a transition with the same id already exists on a selected element, the existing transition is returned for that element. Otherwise, the timing of the returned transition is inherited from the existing transition of the same id on the nearest ancestor of each selected element. Thus, this method can be used to synchronize a transition across multiple selections, or to re-select a transition for specific elements and modify its configuration. For example:jsconst t = d3.transition()
    .duration(750)
    .ease(d3.easeLinear);

d3.selectAll(".apple").transition(t)
    .style("fill", "red");

d3.selectAll(".orange").transition(t)
    .style("fill", "orange");If the specified transition is not found on a selected node or its ancestors (such as if the transition already ended), the default timing parameters are used; however, in a future release, this will likely be changed to throw an error. See #59.transition(name) ​Source · Returns a new transition on the root element, document.documentElement, with the specified name. If a name is not specified, null is used. The new transition is only exclusive with other transitions of the same name. The name may also be a transition instance; see selection.transition. This method is equivalent to:jsd3.selection()
  .transition(name)This function can also be used to test for transitions (instanceof d3.transition) or to extend the transition prototype.transition.select(selector) ​Source · For each selected element, selects the first descendant element that matches the specified selector string, if any, and returns a transition on the resulting selection. The selector may be specified either as a selector string or a function. If a function, it is evaluated for each selected element, in order, being passed the current datum (d), the current index (i), and the current group (nodes), with this as the current DOM element. The new transition has the same id, name and timing as this transition; however, if a transition with the same id already exists on a selected element, the existing transition is returned for that element.This method is equivalent to deriving the selection for this transition via transition.selection, creating a subselection via selection.select, and then creating a new transition via selection.transition:jstransition
  .selection()
  .select(selector)
  .transition(transition)transition.selectAll(selector) ​Source · For each selected element, selects all descendant elements that match the specified selector string, if any, and returns a transition on the resulting selection. The selector may be specified either as a selector string or a function. If a function, it is evaluated for each selected element, in order, being passed the current datum (d), the current index (i), and the current group (nodes), with this as the current DOM element. The new transition has the same id, name and timing as this transition; however, if a transition with the same id already exists on a selected element, the existing transition is returned for that element.This method is equivalent to deriving the selection for this transition via transition.selection, creating a subselection via selection.selectAll, and then creating a new transition via selection.transition:jstransition
  .selection()
  .selectAll(selector)
  .transition(transition)transition.selectChild(selector) ​Source · For each selected element, selects the first child element that matches the specified selector string, if any, and returns a transition on the resulting selection. The selector may be specified either as a selector string or a function. If a function, it is evaluated for each selected element, in order, being passed the current datum (d), the current index (i), and the current group (nodes), with this as the current DOM element. The new transition has the same id, name and timing as this transition; however, if a transition with the same id already exists on a selected element, the existing transition is returned for that element.This method is equivalent to deriving the selection for this transition via transition.selection, creating a subselection via selection.selectChild, and then creating a new transition via selection.transition:jstransition
  .selection()
  .selectChild(selector)
  .transition(transition)transition.selectChildren(selector) ​Source · For each selected element, selects all children that match the specified selector string, if any, and returns a transition on the resulting selection. The selector may be specified either as a selector string or a function. If a function, it is evaluated for each selected element, in order, being passed the current datum (d), the current index (i), and the current group (nodes), with this as the current DOM element. The new transition has the same id, name and timing as this transition; however, if a transition with the same id already exists on a selected element, the existing transition is returned for that element.This method is equivalent to deriving the selection for this transition via transition.selection, creating a subselection via selection.selectChildren, and then creating a new transition via selection.transition:jstransition
  .selection()
  .selectChildren(selector)
  .transition(transition)transition.filter(filter) ​Source · For each selected element, selects only the elements that match the specified filter, and returns a transition on the resulting selection. The filter may be specified either as a selector string or a function. If a function, it is evaluated for each selected element, in order, being passed the current datum (d), the current index (i), and the current group (nodes), with this as the current DOM element. The new transition has the same id, name and timing as this transition; however, if a transition with the same id already exists on a selected element, the existing transition is returned for that element.This method is equivalent to deriving the selection for this transition via transition.selection, creating a subselection via selection.filter, and then creating a new transition via selection.transition:jstransition
  .selection()
  .filter(filter)
  .transition(transition)transition.merge(other) ​Source · Returns a new transition merging this transition with the specified other transition, which must have the same id as this transition. The returned transition has the same number of groups, the same parents, the same name and the same id as this transition. Any missing (null) elements in this transition are filled with the corresponding element, if present (not null), from the other transition.This method is equivalent to deriving the selection for this transition via transition.selection, merging with the selection likewise derived from the other transition via selection.merge, and then creating a new transition via selection.transition:jstransition
  .selection()
  .merge(other.selection())
  .transition(transition)transition.transition() ​Source · Returns a new transition on the same selected elements as this transition, scheduled to start when this transition ends. The new transition inherits a reference time equal to this transition’s time plus its delay and duration. The new transition also inherits this transition’s name, duration, and easing. This method can be used to schedule a sequence of chained transitions. For example:jsd3.selectAll(".apple")
  .transition() // First fade to green.
    .style("fill", "green")
  .transition() // Then red.
    .style("fill", "red")
  .transition() // Wait one second. Then brown, and remove.
    .delay(1000)
    .style("fill", "brown")
    .remove();The delay for each transition is relative to its previous transition. Thus, in the above example, apples will stay red for one second before the last transition to brown starts.transition.selection() ​Source · Returns the selection corresponding to this transition.active(node, name) ​Examples · Source · Returns the active transition on the specified node with the specified name, if any. If no name is specified, null is used. Returns null if there is no such active transition on the specified node. This method is useful for creating chained transitions. For example, to initiate disco mode:jsd3.selectAll("circle").transition()
    .delay((d, i) => i * 50)
    .on("start", function repeat() {
        d3.active(this)
            .style("fill", "red")
          .transition()
            .style("fill", "green")
          .transition()
            .style("fill", "blue")
          .transition()
            .on("start", repeat);
      });PagerPrevious paged3-transitionNext pageModifying elements\n\nSelecting elements ​Transitions are derived from selections via selection.transition. You can also create a transition on the document root element using d3.transition.selection.transition(name) ​Source · Returns a new transition on the given selection with the specified name. If a name is not specified, null is used. The new transition is only exclusive with other transitions of the same name.If the name is a transition instance, the returned transition has the same id and name as the specified transition. If a transition with the same id already exists on a selected element, the existing transition is returned for that element. Otherwise, the timing of the returned transition is inherited from the existing transition of the same id on the nearest ancestor of each selected element. Thus, this method can be used to synchronize a transition across multiple selections, or to re-select a transition for specific elements and modify its configuration. For example:jsconst t = d3.transition()
    .duration(750)
    .ease(d3.easeLinear);

d3.selectAll(".apple").transition(t)
    .style("fill", "red");

d3.selectAll(".orange").transition(t)
    .style("fill", "orange");If the specified transition is not found on a selected node or its ancestors (such as if the transition already ended), the default timing parameters are used; however, in a future release, this will likely be changed to throw an error. See #59.transition(name) ​Source · Returns a new transition on the root element, document.documentElement, with the specified name. If a name is not specified, null is used. The new transition is only exclusive with other transitions of the same name. The name may also be a transition instance; see selection.transition. This method is equivalent to:jsd3.selection()
  .transition(name)This function can also be used to test for transitions (instanceof d3.transition) or to extend the transition prototype.transition.select(selector) ​Source · For each selected element, selects the first descendant element that matches the specified selector string, if any, and returns a transition on the resulting selection. The selector may be specified either as a selector string or a function. If a function, it is evaluated for each selected element, in order, being passed the current datum (d), the current index (i), and the current group (nodes), with this as the current DOM element. The new transition has the same id, name and timing as this transition; however, if a transition with the same id already exists on a selected element, the existing transition is returned for that element.This method is equivalent to deriving the selection for this transition via transition.selection, creating a subselection via selection.select, and then creating a new transition via selection.transition:jstransition
  .selection()
  .select(selector)
  .transition(transition)transition.selectAll(selector) ​Source · For each selected element, selects all descendant elements that match the specified selector string, if any, and returns a transition on the resulting selection. The selector may be specified either as a selector string or a function. If a function, it is evaluated for each selected element, in order, being passed the current datum (d), the current index (i), and the current group (nodes), with this as the current DOM element. The new transition has the same id, name and timing as this transition; however, if a transition with the same id already exists on a selected element, the existing transition is returned for that element.This method is equivalent to deriving the selection for this transition via transition.selection, creating a subselection via selection.selectAll, and then creating a new transition via selection.transition:jstransition
  .selection()
  .selectAll(selector)
  .transition(transition)transition.selectChild(selector) ​Source · For each selected element, selects the first child element that matches the specified selector string, if any, and returns a transition on the resulting selection. The selector may be specified either as a selector string or a function. If a function, it is evaluated for each selected element, in order, being passed the current datum (d), the current index (i), and the current group (nodes), with this as the current DOM element. The new transition has the same id, name and timing as this transition; however, if a transition with the same id already exists on a selected element, the existing transition is returned for that element.This method is equivalent to deriving the selection for this transition via transition.selection, creating a subselection via selection.selectChild, and then creating a new transition via selection.transition:jstransition
  .selection()
  .selectChild(selector)
  .transition(transition)transition.selectChildren(selector) ​Source · For each selected element, selects all children that match the specified selector string, if any, and returns a transition on the resulting selection. The selector may be specified either as a selector string or a function. If a function, it is evaluated for each selected element, in order, being passed the current datum (d), the current index (i), and the current group (nodes), with this as the current DOM element. The new transition has the same id, name and timing as this transition; however, if a transition with the same id already exists on a selected element, the existing transition is returned for that element.This method is equivalent to deriving the selection for this transition via transition.selection, creating a subselection via selection.selectChildren, and then creating a new transition via selection.transition:jstransition
  .selection()
  .selectChildren(selector)
  .transition(transition)transition.filter(filter) ​Source · For each selected element, selects only the elements that match the specified filter, and returns a transition on the resulting selection. The filter may be specified either as a selector string or a function. If a function, it is evaluated for each selected element, in order, being passed the current datum (d), the current index (i), and the current group (nodes), with this as the current DOM element. The new transition has the same id, name and timing as this transition; however, if a transition with the same id already exists on a selected element, the existing transition is returned for that element.This method is equivalent to deriving the selection for this transition via transition.selection, creating a subselection via selection.filter, and then creating a new transition via selection.transition:jstransition
  .selection()
  .filter(filter)
  .transition(transition)transition.merge(other) ​Source · Returns a new transition merging this transition with the specified other transition, which must have the same id as this transition. The returned transition has the same number of groups, the same parents, the same name and the same id as this transition. Any missing (null) elements in this transition are filled with the corresponding element, if present (not null), from the other transition.This method is equivalent to deriving the selection for this transition via transition.selection, merging with the selection likewise derived from the other transition via selection.merge, and then creating a new transition via selection.transition:jstransition
  .selection()
  .merge(other.selection())
  .transition(transition)transition.transition() ​Source · Returns a new transition on the same selected elements as this transition, scheduled to start when this transition ends. The new transition inherits a reference time equal to this transition’s time plus its delay and duration. The new transition also inherits this transition’s name, duration, and easing. This method can be used to schedule a sequence of chained transitions. For example:jsd3.selectAll(".apple")
  .transition() // First fade to green.
    .style("fill", "green")
  .transition() // Then red.
    .style("fill", "red")
  .transition() // Wait one second. Then brown, and remove.
    .delay(1000)
    .style("fill", "brown")
    .remove();The delay for each transition is relative to its previous transition. Thus, in the above example, apples will stay red for one second before the last transition to brown starts.transition.selection() ​Source · Returns the selection corresponding to this transition.active(node, name) ​Examples · Source · Returns the active transition on the specified node with the specified name, if any. If no name is specified, null is used. Returns null if there is no such active transition on the specified node. This method is useful for creating chained transitions. For example, to initiate disco mode:jsd3.selectAll("circle").transition()
    .delay((d, i) => i * 50)
    .on("start", function repeat() {
        d3.active(this)
            .style("fill", "red")
          .transition()
            .style("fill", "green")
          .transition()
            .style("fill", "blue")
          .transition()
            .on("start", repeat);
      });\n\n\n\nModifying elements ​After selecting elements and creating a transition with selection.transition, use the transition’s transformation methods to affect document content.transition.attr(name, value) ​Source · For each selected element, assigns the attribute tween for the attribute with the specified name to the specified target value. The starting value of the tween is the attribute’s value when the transition starts. The target value may be specified either as a constant or a function. If a function, it is immediately evaluated for each selected element, in order, being passed the current datum (d), the current index (i), and the current group (nodes), with this as the current DOM element.If the target value is null, the attribute is removed when the transition starts. Otherwise, an interpolator is chosen based on the type of the target value, using the following algorithm:If value is a number, use interpolateNumber.If value is a color or a string coercible to a color, use interpolateRgb.Use interpolateString.To apply a different interpolator, use transition.attrTween.transition.attrTween(name, factory) ​Source · If factory is specified and not null, assigns the attribute tween for the attribute with the specified name to the specified interpolator factory. An interpolator factory is a function that returns an interpolator; when the transition starts, the factory is evaluated for each selected element, in order, being passed the current datum (d), the current index (i), and the current group (nodes), with this as the current DOM element. The returned interpolator will then be invoked for each frame of the transition, in order, being passed the eased time t, typically in the range [0, 1]. Lastly, the return value of the interpolator will be used to set the attribute value. The interpolator must return a string. (To remove an attribute at the start of a transition, use transition.attr; to remove an attribute at the end of a transition, use transition.on to listen for the end event.)If the specified factory is null, removes the previously-assigned attribute tween of the specified name, if any. If factory is not specified, returns the current interpolator factory for attribute with the specified name, or undefined if no such tween exists.For example, to interpolate the fill attribute from red to blue:jstransition.attrTween("fill", () => d3.interpolateRgb("red", "blue"));Or to interpolate from the current fill to blue, like transition.attr:jstransition.attrTween("fill", function() {
  return d3.interpolateRgb(this.getAttribute("fill"), "blue");
});Or to apply a custom rainbow interpolator:jstransition.attrTween("fill", () => (t) => `hsl(${t * 360},100%,50%)`);This method is useful to specify a custom interpolator, such as one that understands SVG paths. A useful technique is data interpolation, where interpolateObject is used to interpolate two data values, and the resulting value is then used (say, with a shape) to compute the new attribute value.transition.style(name, value, priority) ​Source · For each selected element, assigns the style tween for the style with the specified name to the specified target value with the specified priority. The starting value of the tween is the style’s inline value if present, and otherwise its computed value, when the transition starts. The target value may be specified either as a constant or a function. If a function, it is immediately evaluated for each selected element, in order, being passed the current datum (d), the current index (i), and the current group (nodes), with this as the current DOM element.If the target value is null, the style is removed when the transition starts. Otherwise, an interpolator is chosen based on the type of the target value, using the following algorithm:If value is a number, use interpolateNumber.If value is a color or a string coercible to a color, use interpolateRgb.Use interpolateString.To apply a different interpolator, use transition.styleTween.transition.styleTween(name, factory, priority) ​Source · If factory is specified and not null, assigns the style tween for the style with the specified name to the specified interpolator factory. An interpolator factory is a function that returns an interpolator; when the transition starts, the factory is evaluated for each selected element, in order, being passed the current datum (d), the current index (i), and the current group (nodes), with this as the current DOM element. The returned interpolator will then be invoked for each frame of the transition, in order, being passed the eased time t, typically in the range [0, 1]. Lastly, the return value of the interpolator will be used to set the style value with the specified priority. The interpolator must return a string. (To remove an style at the start of a transition, use transition.style; to remove an style at the end of a transition, use transition.on to listen for the end event.)If the specified factory is null, removes the previously-assigned style tween of the specified name, if any. If factory is not specified, returns the current interpolator factory for style with the specified name, or undefined if no such tween exists.For example, to interpolate the fill style from red to blue:jstransition.styleTween("fill", () => d3.interpolateRgb("red", "blue"));Or to interpolate from the current fill to blue, like transition.style:jstransition.styleTween("fill", function() {
  return d3.interpolateRgb(this.style.fill, "blue");
});Or to apply a custom rainbow interpolator:jstransition.styleTween("fill", () => (t) => `hsl(${t * 360},100%,50%)`);This method is useful to specify a custom interpolator, such as with data interpolation, where interpolateObject is used to interpolate two data values, and the resulting value is then used to compute the new style value.transition.text(value) ​Source · For each selected element, sets the text content to the specified target value when the transition starts. The value may be specified either as a constant or a function. If a function, it is immediately evaluated for each selected element, in order, being passed the current datum (d), the current index (i), and the current group (nodes), with this as the current DOM element. The function’s return value is then used to set each element’s text content. A null value will clear the content.To interpolate text rather than to set it on start, use transition.textTween or append a replacement element and cross-fade opacity. Text is not interpolated by default because it is usually undesirable.transition.textTween(factory) ​Source, ExamplesIf factory is specified and not null, assigns the text tween to the specified interpolator factory. An interpolator factory is a function that returns an interpolator; when the transition starts, the factory is evaluated for each selected element, in order, being passed the current datum d and index i, with the this context as the current DOM element. The returned interpolator will then be invoked for each frame of the transition, in order, being passed the eased time t, typically in the range [0, 1]. Lastly, the return value of the interpolator will be used to set the text. The interpolator must return a string.For example, to interpolate the text with integers from 0 to 100:jstransition.textTween(() => d3.interpolateRound(0, 100));If the specified factory is null, removes the previously-assigned text tween, if any. If factory is not specified, returns the current interpolator factory for text, or undefined if no such tween exists.transition.remove() ​Source · For each selected element, removes the element when the transition ends, as long as the element has no other active or pending transitions. If the element has other active or pending transitions, does nothing.transition.tween(name, value) ​Source · For each selected element, assigns the tween with the specified name with the specified value function. The value must be specified as a function that returns a function. When the transition starts, the value function is evaluated for each selected element, in order, being passed the current datum (d), the current index (i), and the current group (nodes), with this as the current DOM element. The returned function is then invoked for each frame of the transition, in order, being passed the eased time t, typically in the range [0, 1]. If the specified value is null, removes the previously-assigned tween of the specified name, if any.For example, to interpolate the fill attribute to blue, like transition.attr:jstransition.tween("attr.fill", function() {
  const i = d3.interpolateRgb(this.getAttribute("fill"), "blue");
  return function(t) {
    this.setAttribute("fill", i(t));
  };
});\n\nSearchK7.9.0GitHub️ 110.0kOn this pageModifying elements ​After selecting elements and creating a transition with selection.transition, use the transition’s transformation methods to affect document content.transition.attr(name, value) ​Source · For each selected element, assigns the attribute tween for the attribute with the specified name to the specified target value. The starting value of the tween is the attribute’s value when the transition starts. The target value may be specified either as a constant or a function. If a function, it is immediately evaluated for each selected element, in order, being passed the current datum (d), the current index (i), and the current group (nodes), with this as the current DOM element.If the target value is null, the attribute is removed when the transition starts. Otherwise, an interpolator is chosen based on the type of the target value, using the following algorithm:If value is a number, use interpolateNumber.If value is a color or a string coercible to a color, use interpolateRgb.Use interpolateString.To apply a different interpolator, use transition.attrTween.transition.attrTween(name, factory) ​Source · If factory is specified and not null, assigns the attribute tween for the attribute with the specified name to the specified interpolator factory. An interpolator factory is a function that returns an interpolator; when the transition starts, the factory is evaluated for each selected element, in order, being passed the current datum (d), the current index (i), and the current group (nodes), with this as the current DOM element. The returned interpolator will then be invoked for each frame of the transition, in order, being passed the eased time t, typically in the range [0, 1]. Lastly, the return value of the interpolator will be used to set the attribute value. The interpolator must return a string. (To remove an attribute at the start of a transition, use transition.attr; to remove an attribute at the end of a transition, use transition.on to listen for the end event.)If the specified factory is null, removes the previously-assigned attribute tween of the specified name, if any. If factory is not specified, returns the current interpolator factory for attribute with the specified name, or undefined if no such tween exists.For example, to interpolate the fill attribute from red to blue:jstransition.attrTween("fill", () => d3.interpolateRgb("red", "blue"));Or to interpolate from the current fill to blue, like transition.attr:jstransition.attrTween("fill", function() {
  return d3.interpolateRgb(this.getAttribute("fill"), "blue");
});Or to apply a custom rainbow interpolator:jstransition.attrTween("fill", () => (t) => `hsl(${t * 360},100%,50%)`);This method is useful to specify a custom interpolator, such as one that understands SVG paths. A useful technique is data interpolation, where interpolateObject is used to interpolate two data values, and the resulting value is then used (say, with a shape) to compute the new attribute value.transition.style(name, value, priority) ​Source · For each selected element, assigns the style tween for the style with the specified name to the specified target value with the specified priority. The starting value of the tween is the style’s inline value if present, and otherwise its computed value, when the transition starts. The target value may be specified either as a constant or a function. If a function, it is immediately evaluated for each selected element, in order, being passed the current datum (d), the current index (i), and the current group (nodes), with this as the current DOM element.If the target value is null, the style is removed when the transition starts. Otherwise, an interpolator is chosen based on the type of the target value, using the following algorithm:If value is a number, use interpolateNumber.If value is a color or a string coercible to a color, use interpolateRgb.Use interpolateString.To apply a different interpolator, use transition.styleTween.transition.styleTween(name, factory, priority) ​Source · If factory is specified and not null, assigns the style tween for the style with the specified name to the specified interpolator factory. An interpolator factory is a function that returns an interpolator; when the transition starts, the factory is evaluated for each selected element, in order, being passed the current datum (d), the current index (i), and the current group (nodes), with this as the current DOM element. The returned interpolator will then be invoked for each frame of the transition, in order, being passed the eased time t, typically in the range [0, 1]. Lastly, the return value of the interpolator will be used to set the style value with the specified priority. The interpolator must return a string. (To remove an style at the start of a transition, use transition.style; to remove an style at the end of a transition, use transition.on to listen for the end event.)If the specified factory is null, removes the previously-assigned style tween of the specified name, if any. If factory is not specified, returns the current interpolator factory for style with the specified name, or undefined if no such tween exists.For example, to interpolate the fill style from red to blue:jstransition.styleTween("fill", () => d3.interpolateRgb("red", "blue"));Or to interpolate from the current fill to blue, like transition.style:jstransition.styleTween("fill", function() {
  return d3.interpolateRgb(this.style.fill, "blue");
});Or to apply a custom rainbow interpolator:jstransition.styleTween("fill", () => (t) => `hsl(${t * 360},100%,50%)`);This method is useful to specify a custom interpolator, such as with data interpolation, where interpolateObject is used to interpolate two data values, and the resulting value is then used to compute the new style value.transition.text(value) ​Source · For each selected element, sets the text content to the specified target value when the transition starts. The value may be specified either as a constant or a function. If a function, it is immediately evaluated for each selected element, in order, being passed the current datum (d), the current index (i), and the current group (nodes), with this as the current DOM element. The function’s return value is then used to set each element’s text content. A null value will clear the content.To interpolate text rather than to set it on start, use transition.textTween or append a replacement element and cross-fade opacity. Text is not interpolated by default because it is usually undesirable.transition.textTween(factory) ​Source, ExamplesIf factory is specified and not null, assigns the text tween to the specified interpolator factory. An interpolator factory is a function that returns an interpolator; when the transition starts, the factory is evaluated for each selected element, in order, being passed the current datum d and index i, with the this context as the current DOM element. The returned interpolator will then be invoked for each frame of the transition, in order, being passed the eased time t, typically in the range [0, 1]. Lastly, the return value of the interpolator will be used to set the text. The interpolator must return a string.For example, to interpolate the text with integers from 0 to 100:jstransition.textTween(() => d3.interpolateRound(0, 100));If the specified factory is null, removes the previously-assigned text tween, if any. If factory is not specified, returns the current interpolator factory for text, or undefined if no such tween exists.transition.remove() ​Source · For each selected element, removes the element when the transition ends, as long as the element has no other active or pending transitions. If the element has other active or pending transitions, does nothing.transition.tween(name, value) ​Source · For each selected element, assigns the tween with the specified name with the specified value function. The value must be specified as a function that returns a function. When the transition starts, the value function is evaluated for each selected element, in order, being passed the current datum (d), the current index (i), and the current group (nodes), with this as the current DOM element. The returned function is then invoked for each frame of the transition, in order, being passed the eased time t, typically in the range [0, 1]. If the specified value is null, removes the previously-assigned tween of the specified name, if any.For example, to interpolate the fill attribute to blue, like transition.attr:jstransition.tween("attr.fill", function() {
  const i = d3.interpolateRgb(this.getAttribute("fill"), "blue");
  return function(t) {
    this.setAttribute("fill", i(t));
  };
});PagerPrevious pageSelecting elementsNext pageTiming\n\nModifying elements ​After selecting elements and creating a transition with selection.transition, use the transition’s transformation methods to affect document content.transition.attr(name, value) ​Source · For each selected element, assigns the attribute tween for the attribute with the specified name to the specified target value. The starting value of the tween is the attribute’s value when the transition starts. The target value may be specified either as a constant or a function. If a function, it is immediately evaluated for each selected element, in order, being passed the current datum (d), the current index (i), and the current group (nodes), with this as the current DOM element.If the target value is null, the attribute is removed when the transition starts. Otherwise, an interpolator is chosen based on the type of the target value, using the following algorithm:If value is a number, use interpolateNumber.If value is a color or a string coercible to a color, use interpolateRgb.Use interpolateString.To apply a different interpolator, use transition.attrTween.transition.attrTween(name, factory) ​Source · If factory is specified and not null, assigns the attribute tween for the attribute with the specified name to the specified interpolator factory. An interpolator factory is a function that returns an interpolator; when the transition starts, the factory is evaluated for each selected element, in order, being passed the current datum (d), the current index (i), and the current group (nodes), with this as the current DOM element. The returned interpolator will then be invoked for each frame of the transition, in order, being passed the eased time t, typically in the range [0, 1]. Lastly, the return value of the interpolator will be used to set the attribute value. The interpolator must return a string. (To remove an attribute at the start of a transition, use transition.attr; to remove an attribute at the end of a transition, use transition.on to listen for the end event.)If the specified factory is null, removes the previously-assigned attribute tween of the specified name, if any. If factory is not specified, returns the current interpolator factory for attribute with the specified name, or undefined if no such tween exists.For example, to interpolate the fill attribute from red to blue:jstransition.attrTween("fill", () => d3.interpolateRgb("red", "blue"));Or to interpolate from the current fill to blue, like transition.attr:jstransition.attrTween("fill", function() {
  return d3.interpolateRgb(this.getAttribute("fill"), "blue");
});Or to apply a custom rainbow interpolator:jstransition.attrTween("fill", () => (t) => `hsl(${t * 360},100%,50%)`);This method is useful to specify a custom interpolator, such as one that understands SVG paths. A useful technique is data interpolation, where interpolateObject is used to interpolate two data values, and the resulting value is then used (say, with a shape) to compute the new attribute value.transition.style(name, value, priority) ​Source · For each selected element, assigns the style tween for the style with the specified name to the specified target value with the specified priority. The starting value of the tween is the style’s inline value if present, and otherwise its computed value, when the transition starts. The target value may be specified either as a constant or a function. If a function, it is immediately evaluated for each selected element, in order, being passed the current datum (d), the current index (i), and the current group (nodes), with this as the current DOM element.If the target value is null, the style is removed when the transition starts. Otherwise, an interpolator is chosen based on the type of the target value, using the following algorithm:If value is a number, use interpolateNumber.If value is a color or a string coercible to a color, use interpolateRgb.Use interpolateString.To apply a different interpolator, use transition.styleTween.transition.styleTween(name, factory, priority) ​Source · If factory is specified and not null, assigns the style tween for the style with the specified name to the specified interpolator factory. An interpolator factory is a function that returns an interpolator; when the transition starts, the factory is evaluated for each selected element, in order, being passed the current datum (d), the current index (i), and the current group (nodes), with this as the current DOM element. The returned interpolator will then be invoked for each frame of the transition, in order, being passed the eased time t, typically in the range [0, 1]. Lastly, the return value of the interpolator will be used to set the style value with the specified priority. The interpolator must return a string. (To remove an style at the start of a transition, use transition.style; to remove an style at the end of a transition, use transition.on to listen for the end event.)If the specified factory is null, removes the previously-assigned style tween of the specified name, if any. If factory is not specified, returns the current interpolator factory for style with the specified name, or undefined if no such tween exists.For example, to interpolate the fill style from red to blue:jstransition.styleTween("fill", () => d3.interpolateRgb("red", "blue"));Or to interpolate from the current fill to blue, like transition.style:jstransition.styleTween("fill", function() {
  return d3.interpolateRgb(this.style.fill, "blue");
});Or to apply a custom rainbow interpolator:jstransition.styleTween("fill", () => (t) => `hsl(${t * 360},100%,50%)`);This method is useful to specify a custom interpolator, such as with data interpolation, where interpolateObject is used to interpolate two data values, and the resulting value is then used to compute the new style value.transition.text(value) ​Source · For each selected element, sets the text content to the specified target value when the transition starts. The value may be specified either as a constant or a function. If a function, it is immediately evaluated for each selected element, in order, being passed the current datum (d), the current index (i), and the current group (nodes), with this as the current DOM element. The function’s return value is then used to set each element’s text content. A null value will clear the content.To interpolate text rather than to set it on start, use transition.textTween or append a replacement element and cross-fade opacity. Text is not interpolated by default because it is usually undesirable.transition.textTween(factory) ​Source, ExamplesIf factory is specified and not null, assigns the text tween to the specified interpolator factory. An interpolator factory is a function that returns an interpolator; when the transition starts, the factory is evaluated for each selected element, in order, being passed the current datum d and index i, with the this context as the current DOM element. The returned interpolator will then be invoked for each frame of the transition, in order, being passed the eased time t, typically in the range [0, 1]. Lastly, the return value of the interpolator will be used to set the text. The interpolator must return a string.For example, to interpolate the text with integers from 0 to 100:jstransition.textTween(() => d3.interpolateRound(0, 100));If the specified factory is null, removes the previously-assigned text tween, if any. If factory is not specified, returns the current interpolator factory for text, or undefined if no such tween exists.transition.remove() ​Source · For each selected element, removes the element when the transition ends, as long as the element has no other active or pending transitions. If the element has other active or pending transitions, does nothing.transition.tween(name, value) ​Source · For each selected element, assigns the tween with the specified name with the specified value function. The value must be specified as a function that returns a function. When the transition starts, the value function is evaluated for each selected element, in order, being passed the current datum (d), the current index (i), and the current group (nodes), with this as the current DOM element. The returned function is then invoked for each frame of the transition, in order, being passed the eased time t, typically in the range [0, 1]. If the specified value is null, removes the previously-assigned tween of the specified name, if any.For example, to interpolate the fill attribute to blue, like transition.attr:jstransition.tween("attr.fill", function() {
  const i = d3.interpolateRgb(this.getAttribute("fill"), "blue");
  return function(t) {
    this.setAttribute("fill", i(t));
  };
});\n\n\n\nTiming ​The easing, delay and duration of a transition is configurable. For example, a per-element delay can be used to stagger the reordering of elements, improving perception. See Animated Transitions in Statistical Data Graphics for recommendations.transition.delay(value) ​Source · For each selected element, sets the transition delay to the specified value in milliseconds.jstransition.delay(250);The value may be specified either as a constant or a function. If a function, it is immediately evaluated for each selected element, in order, being passed the current datum (d), the current index (i), and the current group (nodes), with this as the current DOM element. The function’s return value is then used to set each element’s transition delay. If a delay is not specified, it defaults to zero.If a value is not specified, returns the current value of the delay for the first (non-null) element in the transition. This is generally useful only if you know that the transition contains exactly one element.jstransition.delay() // 250Setting the delay to a multiple of the index i is a convenient way to stagger transitions across a set of elements. For example:jstransition.delay((d, i) => i * 10);Of course, you can also compute the delay as a function of the data, or sort the selection before computed an index-based delay.transition.duration(value) ​Source · For each selected element, sets the transition duration to the specified value in milliseconds.jstransition.duration(750);The value may be specified either as a constant or a function. If a function, it is immediately evaluated for each selected element, in order, being passed the current datum (d), the current index (i), and the current group (nodes), with this as the current DOM element. The function’s return value is then used to set each element’s transition duration. If a duration is not specified, it defaults to 250ms.If a value is not specified, returns the current value of the duration for the first (non-null) element in the transition. This is generally useful only if you know that the transition contains exactly one element.jstransition.duration() // 750transition.ease(value) ​Source · Specifies the transition easing function for all selected elements.jstransition.ease(d3.easeCubic);The value must be specified as a function. The easing function is invoked for each frame of the animation, being passed the normalized time t in the range [0, 1]; it must then return the eased time tʹ which is typically also in the range [0, 1]. A good easing function should return 0 if t = 0 and 1 if t = 1. If an easing function is not specified, it defaults to easeCubic.If a value is not specified, returns the current easing function for the first (non-null) element in the transition. This is generally useful only if you know that the transition contains exactly one element.jstransition.ease() // d3.easeCubictransition.easeVarying(factory) ​Examples · Source · Specifies a factory for the transition easing function.jstransition.easeVarying((d) => d3.easePolyIn.exponent(d.exponent));The factory must be a function. It is invoked for each node of the selection, being passed the current datum (d), the current index (i), and the current group (nodes), with this as the current DOM element. It must return an easing function.\n\nSearchK7.9.0GitHub️ 110.0kOn this pageTiming ​The easing, delay and duration of a transition is configurable. For example, a per-element delay can be used to stagger the reordering of elements, improving perception. See Animated Transitions in Statistical Data Graphics for recommendations.transition.delay(value) ​Source · For each selected element, sets the transition delay to the specified value in milliseconds.jstransition.delay(250);The value may be specified either as a constant or a function. If a function, it is immediately evaluated for each selected element, in order, being passed the current datum (d), the current index (i), and the current group (nodes), with this as the current DOM element. The function’s return value is then used to set each element’s transition delay. If a delay is not specified, it defaults to zero.If a value is not specified, returns the current value of the delay for the first (non-null) element in the transition. This is generally useful only if you know that the transition contains exactly one element.jstransition.delay() // 250Setting the delay to a multiple of the index i is a convenient way to stagger transitions across a set of elements. For example:jstransition.delay((d, i) => i * 10);Of course, you can also compute the delay as a function of the data, or sort the selection before computed an index-based delay.transition.duration(value) ​Source · For each selected element, sets the transition duration to the specified value in milliseconds.jstransition.duration(750);The value may be specified either as a constant or a function. If a function, it is immediately evaluated for each selected element, in order, being passed the current datum (d), the current index (i), and the current group (nodes), with this as the current DOM element. The function’s return value is then used to set each element’s transition duration. If a duration is not specified, it defaults to 250ms.If a value is not specified, returns the current value of the duration for the first (non-null) element in the transition. This is generally useful only if you know that the transition contains exactly one element.jstransition.duration() // 750transition.ease(value) ​Source · Specifies the transition easing function for all selected elements.jstransition.ease(d3.easeCubic);The value must be specified as a function. The easing function is invoked for each frame of the animation, being passed the normalized time t in the range [0, 1]; it must then return the eased time tʹ which is typically also in the range [0, 1]. A good easing function should return 0 if t = 0 and 1 if t = 1. If an easing function is not specified, it defaults to easeCubic.If a value is not specified, returns the current easing function for the first (non-null) element in the transition. This is generally useful only if you know that the transition contains exactly one element.jstransition.ease() // d3.easeCubictransition.easeVarying(factory) ​Examples · Source · Specifies a factory for the transition easing function.jstransition.easeVarying((d) => d3.easePolyIn.exponent(d.exponent));The factory must be a function. It is invoked for each node of the selection, being passed the current datum (d), the current index (i), and the current group (nodes), with this as the current DOM element. It must return an easing function.PagerPrevious pageModifying elementsNext pageControl flow\n\nTiming ​The easing, delay and duration of a transition is configurable. For example, a per-element delay can be used to stagger the reordering of elements, improving perception. See Animated Transitions in Statistical Data Graphics for recommendations.transition.delay(value) ​Source · For each selected element, sets the transition delay to the specified value in milliseconds.jstransition.delay(250);The value may be specified either as a constant or a function. If a function, it is immediately evaluated for each selected element, in order, being passed the current datum (d), the current index (i), and the current group (nodes), with this as the current DOM element. The function’s return value is then used to set each element’s transition delay. If a delay is not specified, it defaults to zero.If a value is not specified, returns the current value of the delay for the first (non-null) element in the transition. This is generally useful only if you know that the transition contains exactly one element.jstransition.delay() // 250Setting the delay to a multiple of the index i is a convenient way to stagger transitions across a set of elements. For example:jstransition.delay((d, i) => i * 10);Of course, you can also compute the delay as a function of the data, or sort the selection before computed an index-based delay.transition.duration(value) ​Source · For each selected element, sets the transition duration to the specified value in milliseconds.jstransition.duration(750);The value may be specified either as a constant or a function. If a function, it is immediately evaluated for each selected element, in order, being passed the current datum (d), the current index (i), and the current group (nodes), with this as the current DOM element. The function’s return value is then used to set each element’s transition duration. If a duration is not specified, it defaults to 250ms.If a value is not specified, returns the current value of the duration for the first (non-null) element in the transition. This is generally useful only if you know that the transition contains exactly one element.jstransition.duration() // 750transition.ease(value) ​Source · Specifies the transition easing function for all selected elements.jstransition.ease(d3.easeCubic);The value must be specified as a function. The easing function is invoked for each frame of the animation, being passed the normalized time t in the range [0, 1]; it must then return the eased time tʹ which is typically also in the range [0, 1]. A good easing function should return 0 if t = 0 and 1 if t = 1. If an easing function is not specified, it defaults to easeCubic.If a value is not specified, returns the current easing function for the first (non-null) element in the transition. This is generally useful only if you know that the transition contains exactly one element.jstransition.ease() // d3.easeCubictransition.easeVarying(factory) ​Examples · Source · Specifies a factory for the transition easing function.jstransition.easeVarying((d) => d3.easePolyIn.exponent(d.exponent));The factory must be a function. It is invoked for each node of the selection, being passed the current datum (d), the current index (i), and the current group (nodes), with this as the current DOM element. It must return an easing function.\n\n\n\nControl flow ​For advanced usage, transitions provide methods for custom control flow.The life of a transition ​Immediately after creating a transition, such as by selection.transition or transition.transition, you may configure the transition using methods such as transition.delay, transition.duration, transition.attr and transition.style. Methods that specify target values (such as transition.attr) are evaluated synchronously; however, methods that require the starting value for interpolation, such as transition.attrTween and transition.styleTween, must be deferred until the transition starts.Shortly after creation, either at the end of the current frame or during the next frame, the transition is scheduled. At this point, the delay and start event listeners may no longer be changed; attempting to do so throws an error with the message “too late: already scheduled” (or if the transition has ended, “transition not found”).When the transition subsequently starts, it interrupts the active transition of the same name on the same element, if any, dispatching an interrupt event to registered listeners. (Note that interrupts happen on start, not creation, and thus even a zero-delay transition will not immediately interrupt the active transition: the old transition is given a final frame. Use selection.interrupt to interrupt immediately.) The starting transition also cancels any pending transitions of the same name on the same element that were created before the starting transition. The transition then dispatches a start event to registered listeners. This is the last moment at which the transition may be modified: the transition’s timing, tweens, and listeners may not be changed when it is running; attempting to do so throws an error with the message “too late: already running” (or if the transition has ended, “transition not found”). The transition initializes its tweens immediately after starting.During the frame the transition starts, but after all transitions starting this frame have been started, the transition invokes its tweens for the first time. Batching tween initialization, which typically involves reading from the DOM, improves performance by avoiding interleaved DOM reads and writes.For each frame that a transition is active, it invokes its tweens with an eased t-value ranging from 0 to 1. Within each frame, the transition invokes its tweens in the order they were registered.When a transition ends, it invokes its tweens a final time with a (non-eased) t-value of 1. It then dispatches an end event to registered listeners. This is the last moment at which the transition may be inspected: after ending, the transition is deleted from the element, and its configuration is destroyed. (A transition’s configuration is also destroyed on interrupt or cancel.) Attempting to inspect a transition after it is destroyed throws an error with the message “transition not found”.selection.interrupt(name) ​Source · Interrupts the active transition of the specified name on the selected elements, and cancels any pending transitions with the specified name, if any. If a name is not specified, null is used.Interrupting a transition on an element has no effect on any transitions on any descendant elements. For example, an axis transition consists of multiple independent, synchronized transitions on the descendants of the axis G element (the tick lines, the tick labels, the domain path, etc.). To interrupt the axis transition, you must therefore interrupt the descendants:jsselection.selectAll("*").interrupt();The universal selector, *, selects all descendant elements. If you also want to interrupt the G element itself:jsselection.interrupt().selectAll("*").interrupt();interrupt(node, name) ​Source · Interrupts the active transition of the specified name on the specified node, and cancels any pending transitions with the specified name, if any. If a name is not specified, null is used. See also selection.interrupt.transition.end() ​Source · Returns a promise that resolves when every selected element finishes transitioning. If any element’s transition is cancelled or interrupted, the promise rejects.transition.on(typenames, listener) ​Source · Adds or removes a listener to each selected element for the specified event typenames. The typenames is one of the following string event types:start - when the transition starts.end - when the transition ends.interrupt - when the transition is interrupted.cancel - when the transition is cancelled.See The Life of a Transition for more. Note that these are not native DOM events as implemented by selection.on and selection.dispatch, but transition events!The type may be optionally followed by a period (.) and a name; the optional name allows multiple callbacks to be registered to receive events of the same type, such as start.foo and start.bar. To specify multiple typenames, separate typenames with spaces, such as interrupt end or start.foo start.bar.When a specified transition event is dispatched on a selected node, the specified listener will be invoked for the transitioning element, being passed the current datum (d), the current index (i), and the current group (nodes), with this as the current DOM element. Listeners always see the latest datum for their element, but the index is a property of the selection and is fixed when the listener is assigned; to update the index, re-assign the listener.If an event listener was previously registered for the same typename on a selected element, the old listener is removed before the new listener is added. To remove a listener, pass null as the listener. To remove all listeners for a given name, pass null as the listener and .foo as the typename, where foo is the name; to remove all listeners with no name, specify . as the typename.If a listener is not specified, returns the currently-assigned listener for the specified event typename on the first (non-null) selected element, if any. If multiple typenames are specified, the first matching listener is returned.transition.each(function) ​Source · Invokes the specified function for each selected element, passing in the current datum (d), the current index (i), and the current group (nodes), with this as the current DOM element. This method can be used to invoke arbitrary code for each selected element, and is useful for creating a context to access parent and child data simultaneously. Equivalent to selection.each.transition.call(function, ...arguments) ​Source · Invokes the specified function exactly once, passing in this transition along with any optional arguments. Returns this transition. This is equivalent to invoking the function by hand but facilitates method chaining. For example, to set several attributes in a reusable function:jsfunction color(transition, fill, stroke) {
  transition
      .style("fill", fill)
      .style("stroke", stroke);
}Now say:jsd3.selectAll("div").transition().call(color, "red", "blue");This is equivalent to:jscolor(d3.selectAll("div").transition(), "red", "blue");Equivalent to selection.call.transition.empty() ​Source · Returns true if this transition contains no (non-null) elements. Equivalent to selection.empty.transition.nodes() ​Source · Returns an array of all (non-null) elements in this transition. Equivalent to selection.nodes.transition.node() ​Source · Returns the first (non-null) element in this transition. If the transition is empty, returns null. Equivalent to selection.node.transition.size() ​Source · Returns the total number of elements in this transition. Equivalent to selection.size.\n\nSearchK7.9.0GitHub️ 110.0kOn this pageControl flow ​For advanced usage, transitions provide methods for custom control flow.The life of a transition ​Immediately after creating a transition, such as by selection.transition or transition.transition, you may configure the transition using methods such as transition.delay, transition.duration, transition.attr and transition.style. Methods that specify target values (such as transition.attr) are evaluated synchronously; however, methods that require the starting value for interpolation, such as transition.attrTween and transition.styleTween, must be deferred until the transition starts.Shortly after creation, either at the end of the current frame or during the next frame, the transition is scheduled. At this point, the delay and start event listeners may no longer be changed; attempting to do so throws an error with the message “too late: already scheduled” (or if the transition has ended, “transition not found”).When the transition subsequently starts, it interrupts the active transition of the same name on the same element, if any, dispatching an interrupt event to registered listeners. (Note that interrupts happen on start, not creation, and thus even a zero-delay transition will not immediately interrupt the active transition: the old transition is given a final frame. Use selection.interrupt to interrupt immediately.) The starting transition also cancels any pending transitions of the same name on the same element that were created before the starting transition. The transition then dispatches a start event to registered listeners. This is the last moment at which the transition may be modified: the transition’s timing, tweens, and listeners may not be changed when it is running; attempting to do so throws an error with the message “too late: already running” (or if the transition has ended, “transition not found”). The transition initializes its tweens immediately after starting.During the frame the transition starts, but after all transitions starting this frame have been started, the transition invokes its tweens for the first time. Batching tween initialization, which typically involves reading from the DOM, improves performance by avoiding interleaved DOM reads and writes.For each frame that a transition is active, it invokes its tweens with an eased t-value ranging from 0 to 1. Within each frame, the transition invokes its tweens in the order they were registered.When a transition ends, it invokes its tweens a final time with a (non-eased) t-value of 1. It then dispatches an end event to registered listeners. This is the last moment at which the transition may be inspected: after ending, the transition is deleted from the element, and its configuration is destroyed. (A transition’s configuration is also destroyed on interrupt or cancel.) Attempting to inspect a transition after it is destroyed throws an error with the message “transition not found”.selection.interrupt(name) ​Source · Interrupts the active transition of the specified name on the selected elements, and cancels any pending transitions with the specified name, if any. If a name is not specified, null is used.Interrupting a transition on an element has no effect on any transitions on any descendant elements. For example, an axis transition consists of multiple independent, synchronized transitions on the descendants of the axis G element (the tick lines, the tick labels, the domain path, etc.). To interrupt the axis transition, you must therefore interrupt the descendants:jsselection.selectAll("*").interrupt();The universal selector, *, selects all descendant elements. If you also want to interrupt the G element itself:jsselection.interrupt().selectAll("*").interrupt();interrupt(node, name) ​Source · Interrupts the active transition of the specified name on the specified node, and cancels any pending transitions with the specified name, if any. If a name is not specified, null is used. See also selection.interrupt.transition.end() ​Source · Returns a promise that resolves when every selected element finishes transitioning. If any element’s transition is cancelled or interrupted, the promise rejects.transition.on(typenames, listener) ​Source · Adds or removes a listener to each selected element for the specified event typenames. The typenames is one of the following string event types:start - when the transition starts.end - when the transition ends.interrupt - when the transition is interrupted.cancel - when the transition is cancelled.See The Life of a Transition for more. Note that these are not native DOM events as implemented by selection.on and selection.dispatch, but transition events!The type may be optionally followed by a period (.) and a name; the optional name allows multiple callbacks to be registered to receive events of the same type, such as start.foo and start.bar. To specify multiple typenames, separate typenames with spaces, such as interrupt end or start.foo start.bar.When a specified transition event is dispatched on a selected node, the specified listener will be invoked for the transitioning element, being passed the current datum (d), the current index (i), and the current group (nodes), with this as the current DOM element. Listeners always see the latest datum for their element, but the index is a property of the selection and is fixed when the listener is assigned; to update the index, re-assign the listener.If an event listener was previously registered for the same typename on a selected element, the old listener is removed before the new listener is added. To remove a listener, pass null as the listener. To remove all listeners for a given name, pass null as the listener and .foo as the typename, where foo is the name; to remove all listeners with no name, specify . as the typename.If a listener is not specified, returns the currently-assigned listener for the specified event typename on the first (non-null) selected element, if any. If multiple typenames are specified, the first matching listener is returned.transition.each(function) ​Source · Invokes the specified function for each selected element, passing in the current datum (d), the current index (i), and the current group (nodes), with this as the current DOM element. This method can be used to invoke arbitrary code for each selected element, and is useful for creating a context to access parent and child data simultaneously. Equivalent to selection.each.transition.call(function, ...arguments) ​Source · Invokes the specified function exactly once, passing in this transition along with any optional arguments. Returns this transition. This is equivalent to invoking the function by hand but facilitates method chaining. For example, to set several attributes in a reusable function:jsfunction color(transition, fill, stroke) {
  transition
      .style("fill", fill)
      .style("stroke", stroke);
}Now say:jsd3.selectAll("div").transition().call(color, "red", "blue");This is equivalent to:jscolor(d3.selectAll("div").transition(), "red", "blue");Equivalent to selection.call.transition.empty() ​Source · Returns true if this transition contains no (non-null) elements. Equivalent to selection.empty.transition.nodes() ​Source · Returns an array of all (non-null) elements in this transition. Equivalent to selection.nodes.transition.node() ​Source · Returns the first (non-null) element in this transition. If the transition is empty, returns null. Equivalent to selection.node.transition.size() ​Source · Returns the total number of elements in this transition. Equivalent to selection.size.PagerPrevious pageTimingNext paged3-brush\n\nControl flow ​For advanced usage, transitions provide methods for custom control flow.The life of a transition ​Immediately after creating a transition, such as by selection.transition or transition.transition, you may configure the transition using methods such as transition.delay, transition.duration, transition.attr and transition.style. Methods that specify target values (such as transition.attr) are evaluated synchronously; however, methods that require the starting value for interpolation, such as transition.attrTween and transition.styleTween, must be deferred until the transition starts.Shortly after creation, either at the end of the current frame or during the next frame, the transition is scheduled. At this point, the delay and start event listeners may no longer be changed; attempting to do so throws an error with the message “too late: already scheduled” (or if the transition has ended, “transition not found”).When the transition subsequently starts, it interrupts the active transition of the same name on the same element, if any, dispatching an interrupt event to registered listeners. (Note that interrupts happen on start, not creation, and thus even a zero-delay transition will not immediately interrupt the active transition: the old transition is given a final frame. Use selection.interrupt to interrupt immediately.) The starting transition also cancels any pending transitions of the same name on the same element that were created before the starting transition. The transition then dispatches a start event to registered listeners. This is the last moment at which the transition may be modified: the transition’s timing, tweens, and listeners may not be changed when it is running; attempting to do so throws an error with the message “too late: already running” (or if the transition has ended, “transition not found”). The transition initializes its tweens immediately after starting.During the frame the transition starts, but after all transitions starting this frame have been started, the transition invokes its tweens for the first time. Batching tween initialization, which typically involves reading from the DOM, improves performance by avoiding interleaved DOM reads and writes.For each frame that a transition is active, it invokes its tweens with an eased t-value ranging from 0 to 1. Within each frame, the transition invokes its tweens in the order they were registered.When a transition ends, it invokes its tweens a final time with a (non-eased) t-value of 1. It then dispatches an end event to registered listeners. This is the last moment at which the transition may be inspected: after ending, the transition is deleted from the element, and its configuration is destroyed. (A transition’s configuration is also destroyed on interrupt or cancel.) Attempting to inspect a transition after it is destroyed throws an error with the message “transition not found”.selection.interrupt(name) ​Source · Interrupts the active transition of the specified name on the selected elements, and cancels any pending transitions with the specified name, if any. If a name is not specified, null is used.Interrupting a transition on an element has no effect on any transitions on any descendant elements. For example, an axis transition consists of multiple independent, synchronized transitions on the descendants of the axis G element (the tick lines, the tick labels, the domain path, etc.). To interrupt the axis transition, you must therefore interrupt the descendants:jsselection.selectAll("*").interrupt();The universal selector, *, selects all descendant elements. If you also want to interrupt the G element itself:jsselection.interrupt().selectAll("*").interrupt();interrupt(node, name) ​Source · Interrupts the active transition of the specified name on the specified node, and cancels any pending transitions with the specified name, if any. If a name is not specified, null is used. See also selection.interrupt.transition.end() ​Source · Returns a promise that resolves when every selected element finishes transitioning. If any element’s transition is cancelled or interrupted, the promise rejects.transition.on(typenames, listener) ​Source · Adds or removes a listener to each selected element for the specified event typenames. The typenames is one of the following string event types:start - when the transition starts.end - when the transition ends.interrupt - when the transition is interrupted.cancel - when the transition is cancelled.See The Life of a Transition for more. Note that these are not native DOM events as implemented by selection.on and selection.dispatch, but transition events!The type may be optionally followed by a period (.) and a name; the optional name allows multiple callbacks to be registered to receive events of the same type, such as start.foo and start.bar. To specify multiple typenames, separate typenames with spaces, such as interrupt end or start.foo start.bar.When a specified transition event is dispatched on a selected node, the specified listener will be invoked for the transitioning element, being passed the current datum (d), the current index (i), and the current group (nodes), with this as the current DOM element. Listeners always see the latest datum for their element, but the index is a property of the selection and is fixed when the listener is assigned; to update the index, re-assign the listener.If an event listener was previously registered for the same typename on a selected element, the old listener is removed before the new listener is added. To remove a listener, pass null as the listener. To remove all listeners for a given name, pass null as the listener and .foo as the typename, where foo is the name; to remove all listeners with no name, specify . as the typename.If a listener is not specified, returns the currently-assigned listener for the specified event typename on the first (non-null) selected element, if any. If multiple typenames are specified, the first matching listener is returned.transition.each(function) ​Source · Invokes the specified function for each selected element, passing in the current datum (d), the current index (i), and the current group (nodes), with this as the current DOM element. This method can be used to invoke arbitrary code for each selected element, and is useful for creating a context to access parent and child data simultaneously. Equivalent to selection.each.transition.call(function, ...arguments) ​Source · Invokes the specified function exactly once, passing in this transition along with any optional arguments. Returns this transition. This is equivalent to invoking the function by hand but facilitates method chaining. For example, to set several attributes in a reusable function:jsfunction color(transition, fill, stroke) {
  transition
      .style("fill", fill)
      .style("stroke", stroke);
}Now say:jsd3.selectAll("div").transition().call(color, "red", "blue");This is equivalent to:jscolor(d3.selectAll("div").transition(), "red", "blue");Equivalent to selection.call.transition.empty() ​Source · Returns true if this transition contains no (non-null) elements. Equivalent to selection.empty.transition.nodes() ​Source · Returns an array of all (non-null) elements in this transition. Equivalent to selection.nodes.transition.node() ​Source · Returns the first (non-null) element in this transition. If the transition is empty, returns null. Equivalent to selection.node.transition.size() ​Source · Returns the total number of elements in this transition. Equivalent to selection.size.\n\n\n\nd3-dispatch ​Dispatching is a low-level interaction mechanism that allows you to register named callbacks and then call them with arbitrary arguments. A variety of D3 interaction components, such as d3-drag, use dispatch to emit events to listeners. Think of this as EventTarget except every listener has a well-defined name so it’s easy to remove or replace them.For example, to create a dispatch for start and end events:jsconst dispatch = d3.dispatch("start", "end");You can then register callbacks for these events using dispatch.on:jsdispatch.on("start", callback1);
dispatch.on("start.foo", callback2);
dispatch.on("end", callback3);Then, you can invoke all the start callbacks using dispatch.call or dispatch.apply:jsdispatch.call("start");Like function.call, you may also specify the this context and any arguments:jsdispatch.call("start", {about: "I am a context object"}, "I am an argument");dispatch(...types) ​Source · Creates a new dispatch for the specified event types. Each type is a string, such as "start" or "end".dispatch.on(typenames, callback) ​Source · Adds, removes or gets the callback for the specified typenames. If a callback function is specified, it is registered for the specified (fully-qualified) typenames. If a callback was already registered for the given typenames, the existing callback is removed before the new callback is added.The specified typenames is a string, such as start or end.foo. The type may be optionally followed by a period (.) and a name; the optional name allows multiple callbacks to be registered to receive events of the same type, such as start.foo and start.bar. To specify multiple typenames, separate typenames with spaces, such as start end or start.foo start.bar.To remove all callbacks for a given name foo, say dispatch.on(".foo", null).If callback is not specified, returns the current callback for the specified typenames, if any. If multiple typenames are specified, the first matching callback is returned.dispatch.copy() ​Source · Returns a copy of this dispatch object. Changes to this dispatch do not affect the returned copy and vice versa.dispatch.call(type, that, ...arguments) ​Source · Like function.call, invokes each registered callback for the specified type, passing the callback the specified ...argument, with that as the this context. See dispatch.apply for more information.dispatch.apply(type, that, arguments) ​Source · Like function.apply, invokes each registered callback for the specified type, passing the callback the specified arguments, with that as the this context. For example, if you wanted to dispatch your custom callbacks after handling a native click event, while preserving the current this context and arguments, you could say:jsselection.on("click", function() {
  dispatch.apply("custom", this, arguments);
});You can pass whatever arguments you want to callbacks; most commonly, you might create an object that represents an event, or pass the current datum (d) and index (i). See function.call and function.apply for further information.\n\nSearchK7.9.0GitHub️ 110.0kOn this paged3-dispatch ​Dispatching is a low-level interaction mechanism that allows you to register named callbacks and then call them with arbitrary arguments. A variety of D3 interaction components, such as d3-drag, use dispatch to emit events to listeners. Think of this as EventTarget except every listener has a well-defined name so it’s easy to remove or replace them.For example, to create a dispatch for start and end events:jsconst dispatch = d3.dispatch("start", "end");You can then register callbacks for these events using dispatch.on:jsdispatch.on("start", callback1);
dispatch.on("start.foo", callback2);
dispatch.on("end", callback3);Then, you can invoke all the start callbacks using dispatch.call or dispatch.apply:jsdispatch.call("start");Like function.call, you may also specify the this context and any arguments:jsdispatch.call("start", {about: "I am a context object"}, "I am an argument");dispatch(...types) ​Source · Creates a new dispatch for the specified event types. Each type is a string, such as "start" or "end".dispatch.on(typenames, callback) ​Source · Adds, removes or gets the callback for the specified typenames. If a callback function is specified, it is registered for the specified (fully-qualified) typenames. If a callback was already registered for the given typenames, the existing callback is removed before the new callback is added.The specified typenames is a string, such as start or end.foo. The type may be optionally followed by a period (.) and a name; the optional name allows multiple callbacks to be registered to receive events of the same type, such as start.foo and start.bar. To specify multiple typenames, separate typenames with spaces, such as start end or start.foo start.bar.To remove all callbacks for a given name foo, say dispatch.on(".foo", null).If callback is not specified, returns the current callback for the specified typenames, if any. If multiple typenames are specified, the first matching callback is returned.dispatch.copy() ​Source · Returns a copy of this dispatch object. Changes to this dispatch do not affect the returned copy and vice versa.dispatch.call(type, that, ...arguments) ​Source · Like function.call, invokes each registered callback for the specified type, passing the callback the specified ...argument, with that as the this context. See dispatch.apply for more information.dispatch.apply(type, that, arguments) ​Source · Like function.apply, invokes each registered callback for the specified type, passing the callback the specified arguments, with that as the this context. For example, if you wanted to dispatch your custom callbacks after handling a native click event, while preserving the current this context and arguments, you could say:jsselection.on("click", function() {
  dispatch.apply("custom", this, arguments);
});You can pass whatever arguments you want to callbacks; most commonly, you might create an object that represents an event, or pass the current datum (d) and index (i). See function.call and function.apply for further information.PagerPrevious paged3-brushNext paged3-drag\n\nd3-dispatch ​Dispatching is a low-level interaction mechanism that allows you to register named callbacks and then call them with arbitrary arguments. A variety of D3 interaction components, such as d3-drag, use dispatch to emit events to listeners. Think of this as EventTarget except every listener has a well-defined name so it’s easy to remove or replace them.For example, to create a dispatch for start and end events:jsconst dispatch = d3.dispatch("start", "end");You can then register callbacks for these events using dispatch.on:jsdispatch.on("start", callback1);
dispatch.on("start.foo", callback2);
dispatch.on("end", callback3);Then, you can invoke all the start callbacks using dispatch.call or dispatch.apply:jsdispatch.call("start");Like function.call, you may also specify the this context and any arguments:jsdispatch.call("start", {about: "I am a context object"}, "I am an argument");dispatch(...types) ​Source · Creates a new dispatch for the specified event types. Each type is a string, such as "start" or "end".dispatch.on(typenames, callback) ​Source · Adds, removes or gets the callback for the specified typenames. If a callback function is specified, it is registered for the specified (fully-qualified) typenames. If a callback was already registered for the given typenames, the existing callback is removed before the new callback is added.The specified typenames is a string, such as start or end.foo. The type may be optionally followed by a period (.) and a name; the optional name allows multiple callbacks to be registered to receive events of the same type, such as start.foo and start.bar. To specify multiple typenames, separate typenames with spaces, such as start end or start.foo start.bar.To remove all callbacks for a given name foo, say dispatch.on(".foo", null).If callback is not specified, returns the current callback for the specified typenames, if any. If multiple typenames are specified, the first matching callback is returned.dispatch.copy() ​Source · Returns a copy of this dispatch object. Changes to this dispatch do not affect the returned copy and vice versa.dispatch.call(type, that, ...arguments) ​Source · Like function.call, invokes each registered callback for the specified type, passing the callback the specified ...argument, with that as the this context. See dispatch.apply for more information.dispatch.apply(type, that, arguments) ​Source · Like function.apply, invokes each registered callback for the specified type, passing the callback the specified arguments, with that as the this context. For example, if you wanted to dispatch your custom callbacks after handling a native click event, while preserving the current this context and arguments, you could say:jsselection.on("click", function() {
  dispatch.apply("custom", this, arguments);
});You can pass whatever arguments you want to callbacks; most commonly, you might create an object that represents an event, or pass the current datum (d) and index (i). See function.call and function.apply for further information.\n\n\n\nd3-drag ​Examples · Drag-and-drop is a popular interaction method for manipulating spatial elements: move the pointer to an object, press and hold to grab it, “drag” the object to a new location, and release to “drop”. D3’s drag behavior provides a flexible abstraction for drag-and-drop. For example, you can drag nodes in a force-directed graph:Or a simulation of colliding circles:The drag behavior isn’t just for moving elements around; there are a variety of ways to respond to a drag gesture. For example, you can use it to lasso elements in a scatterplot, or to paint lines on a canvas:The drag behavior can be combined with other behaviors, such as d3-zoom for zooming:The drag behavior is agnostic about the DOM, so you can use it with SVG, HTML or even Canvas! And you can extend it with advanced selection techniques, such as a Voronoi overlay or a closest-target search:The drag behavior unifies mouse and touch input and avoids browser quirks. In the future the drag behavior will support Pointer Events, too.drag() ​Source · Creates a new drag behavior. The returned behavior, drag, is both an object and a function, and is typically applied to selected elements via selection.call.jsconst drag = d3.drag();drag(selection) ​Source · Applies this drag behavior to the specified selection. This function is typically not invoked directly, and is instead invoked via selection.call. For example, to instantiate a drag behavior and apply it to a selection:jsd3.selectAll(".node").call(d3.drag().on("start", started));Internally, the drag behavior uses selection.on to bind the necessary event listeners for dragging. The listeners use the name .drag, so you can subsequently unbind the drag behavior as follows:jsselection.on(".drag", null);Applying the drag behavior also sets the -webkit-tap-highlight-color style to transparent, disabling the tap highlight on iOS. If you want a different tap highlight color, remove or re-apply this style after applying the drag behavior.drag.container(container) ​Source · If container is specified, sets the container accessor to the specified object or function and returns the drag behavior. If container is not specified, returns the current container accessor, which defaults to:jsfunction container() {
  return this.parentNode;
}The container of a drag gesture determines the coordinate system of subsequent drag events, affecting event.x and event.y. The element returned by the container accessor is subsequently passed to pointer to determine the local coordinates of the pointer.The default container accessor returns the parent node of the element in the originating selection (see drag) that received the initiating input event. This is often appropriate when dragging SVG or HTML elements, since those elements are typically positioned relative to a parent. For dragging graphical elements with a Canvas, however, you may want to redefine the container as the initiating element itself:jsfunction container() {
  return this;
}Alternatively, the container may be specified as the element directly, such as drag.container(canvas).drag.filter(filter) ​Source · If filter is specified, sets the event filter to the specified function and returns the drag behavior. If filter is not specified, returns the current filter, which defaults to:jsfunction filter(event) {
  return !event.ctrlKey && !event.button;
}If the filter returns falsey, the initiating event is ignored and no drag gestures are started. Thus, the filter determines which input events are ignored; the default filter ignores mousedown events on secondary buttons, since those buttons are typically intended for other purposes, such as the context menu.drag.touchable(touchable) ​Source · If touchable is specified, sets the touch support detector to the specified function and returns the drag behavior. If touchable is not specified, returns the current touch support detector, which defaults to:jsfunction touchable() {
  return navigator.maxTouchPoints || ("ontouchstart" in this);
}Touch event listeners are only registered if the detector returns truthy for the corresponding element when the drag behavior is applied. The default detector works well for most browsers that are capable of touch input, but not all; Chrome’s mobile device emulator, for example, fails detection.drag.subject(subject) ​Source · If subject is specified, sets the subject accessor to the specified object or function and returns the drag behavior. If subject is not specified, returns the current subject accessor, which defaults to:jsfunction subject(event, d) {
  return d == null ? {x: event.x, y: event.y} : d;
}The subject of a drag gesture represents the thing being dragged. It is computed when an initiating input event is received, such as a mousedown or touchstart, immediately before the drag gesture starts. The subject is then exposed as event.subject on subsequent drag events for this gesture.The default subject is the datum of the element in the originating selection (see drag) that received the initiating input event; if this datum is undefined, an object representing the coordinates of the pointer is created. When dragging circle elements in SVG, the default subject is thus the datum of the circle being dragged. With Canvas, the default subject is the canvas element’s datum (regardless of where on the canvas you click). In this case, a custom subject accessor would be more appropriate, such as one that picks the closest circle to the mouse within a given search radius:jsfunction subject(event) {
  let n = circles.length,
      i,
      dx,
      dy,
      d2,
      s2 = radius * radius,
      circle,
      subject;

  for (i = 0; i < n; ++i) {
    circle = circles[i];
    dx = event.x - circle.x;
    dy = event.y - circle.y;
    d2 = dx * dx + dy * dy;
    if (d2 < s2) subject = circle, s2 = d2;
  }

  return subject;
}TIPIf necessary, the above can be accelerated using quadtree.find, simulation.find or delaunay.find.The returned subject should be an object that exposes x and y properties, so that the relative position of the subject and the pointer can be preserved during the drag gesture. If the subject is null or undefined, no drag gesture is started for this pointer; however, other starting touches may yet start drag gestures. See also drag.filter.The subject of a drag gesture may not be changed after the gesture starts. The subject accessor is invoked with the same context and arguments as selection.on listeners: the current event (event) and datum d, with the this context as the current DOM element. During the evaluation of the subject accessor, event is a beforestart drag event. Use event.sourceEvent to access the initiating input event and event.identifier to access the touch identifier. The event.x and event.y are relative to the container, and are computed using pointer.drag.clickDistance(distance) ​Source · If distance is specified, sets the maximum distance that the mouse can move between mousedown and mouseup that will trigger a subsequent click event. If at any point between mousedown and mouseup the mouse is greater than or equal to distance from its position on mousedown, the click event following mouseup will be suppressed. If distance is not specified, returns the current distance threshold, which defaults to zero. The distance threshold is measured in client coordinates (event.clientX and event.clientY).drag.on(typenames, listener) ​Source · If listener is specified, sets the event listener for the specified typenames and returns the drag behavior. If an event listener was already registered for the same type and name, the existing listener is removed before the new listener is added. If listener is null, removes the current event listeners for the specified typenames, if any. If listener is not specified, returns the first currently-assigned listener matching the specified typenames, if any. When a specified event is dispatched, each listener will be invoked with the same context and arguments as selection.on listeners: the current event (event) and datum d, with the this context as the current DOM element.The typenames is a string containing one or more typename separated by whitespace. Each typename is a type, optionally followed by a period (.) and a name, such as drag.foo and drag.bar; the name allows multiple listeners to be registered for the same type. The type must be one of the following:start - after a new pointer becomes active (on mousedown or touchstart).drag - after an active pointer moves (on mousemove or touchmove).end - after an active pointer becomes inactive (on mouseup, touchend or touchcancel).See dispatch.on for more.Changes to registered listeners via drag.on during a drag gesture do not affect the current drag gesture. Instead, you must use event.on, which also allows you to register temporary event listeners for the current drag gesture. Separate events are dispatched for each active pointer during a drag gesture. For example, if simultaneously dragging multiple subjects with multiple fingers, a start event is dispatched for each finger, even if both fingers start touching simultaneously. See Drag Events for more.dragDisable(window) ​Source · Prevents native drag-and-drop and text selection on the specified window. As an alternative to preventing the default action of mousedown events (see #9), this method prevents undesirable default actions following mousedown. In supported browsers, this means capturing dragstart and selectstart events, preventing the associated default actions, and immediately stopping their propagation. In browsers that do not support selection events, the user-select CSS property is set to none on the document element. This method is intended to be called on mousedown, followed by dragEnable on mouseup.dragEnable(window, noclick) ​Source · Allows native drag-and-drop and text selection on the specified window; undoes the effect of dragDisable. This method is intended to be called on mouseup, preceded by dragDisable on mousedown. If noclick is true, this method also temporarily suppresses click events. The suppression of click events expires after a zero-millisecond timeout, such that it only suppress the click event that would immediately follow the current mouseup event, if any.Drag events ​When a drag event listener is invoked, it receives the current drag event as its first argument. The event object exposes several fields:target - the associated drag behavior.type - the string “start”, “drag” or “end”; see drag.on.subject - the drag subject, defined by drag.subject.x - the new x-coordinate of the subject; see drag.container.y - the new y coordinate of the subject; see drag.container.dx - the change in x-coordinate since the previous drag event.dy - the change in y coordinate since the previous drag event.identifier - the string “mouse”, or a numeric touch identifier.active - the number of currently active drag gestures (on start and end, not including this one).sourceEvent - the underlying input event, such as mousemove or touchmove.The event.active field is useful for detecting the first start event and the last end event in a sequence of concurrent drag gestures: it is zero when the first drag gesture starts, and zero when the last drag gesture ends.The event object also exposes the event.on method.This table describes how the drag behavior interprets native events:EventListening ElementDrag EventDefault Prevented?mousedown⁵selectionstartno¹mousemove²window¹dragyesmouseup²window¹endyesdragstart²window-yesselectstart²window-yesclick³window-yestouchstartselectionstartno⁴touchmoveselectiondragyestouchendselectionendno⁴touchcancelselectionendno⁴The propagation of all consumed events is immediately stopped. If you want to prevent some events from initiating a drag gesture, use drag.filter.¹ Necessary to capture events outside an iframe; see #9. ² Only applies during an active, mouse-based gesture; see #9. ³ Only applies immediately after some mouse-based gestures; see drag.clickDistance. ⁴ Necessary to allow click emulation on touch input; see #9. ⁵ Ignored if within 500ms of a touch gesture ending; assumes click emulation.event.on(typenames, listener) ​Source · Equivalent to drag.on, but only applies to the current drag gesture. Before the drag gesture starts, a copy of the current drag event listeners is made. This copy is bound to the current drag gesture and modified by event.on. This is useful for temporary listeners that only receive events for the current drag gesture. For example, this start event listener registers temporary drag and end event listeners as closures:jsfunction started(event) {
  const circle = d3.select(this).classed("dragging", true);
  const dragged = (event, d) => circle.raise().attr("cx", d.x = event.x).attr("cy", d.y = event.y);
  const ended = () => circle.classed("dragging", false);
  event.on("drag", dragged).on("end", ended);
}\n\nSearchK7.9.0GitHub️ 110.0kOn this paged3-drag ​Examples · Drag-and-drop is a popular interaction method for manipulating spatial elements: move the pointer to an object, press and hold to grab it, “drag” the object to a new location, and release to “drop”. D3’s drag behavior provides a flexible abstraction for drag-and-drop. For example, you can drag nodes in a force-directed graph:Or a simulation of colliding circles:The drag behavior isn’t just for moving elements around; there are a variety of ways to respond to a drag gesture. For example, you can use it to lasso elements in a scatterplot, or to paint lines on a canvas:The drag behavior can be combined with other behaviors, such as d3-zoom for zooming:The drag behavior is agnostic about the DOM, so you can use it with SVG, HTML or even Canvas! And you can extend it with advanced selection techniques, such as a Voronoi overlay or a closest-target search:The drag behavior unifies mouse and touch input and avoids browser quirks. In the future the drag behavior will support Pointer Events, too.drag() ​Source · Creates a new drag behavior. The returned behavior, drag, is both an object and a function, and is typically applied to selected elements via selection.call.jsconst drag = d3.drag();drag(selection) ​Source · Applies this drag behavior to the specified selection. This function is typically not invoked directly, and is instead invoked via selection.call. For example, to instantiate a drag behavior and apply it to a selection:jsd3.selectAll(".node").call(d3.drag().on("start", started));Internally, the drag behavior uses selection.on to bind the necessary event listeners for dragging. The listeners use the name .drag, so you can subsequently unbind the drag behavior as follows:jsselection.on(".drag", null);Applying the drag behavior also sets the -webkit-tap-highlight-color style to transparent, disabling the tap highlight on iOS. If you want a different tap highlight color, remove or re-apply this style after applying the drag behavior.drag.container(container) ​Source · If container is specified, sets the container accessor to the specified object or function and returns the drag behavior. If container is not specified, returns the current container accessor, which defaults to:jsfunction container() {
  return this.parentNode;
}The container of a drag gesture determines the coordinate system of subsequent drag events, affecting event.x and event.y. The element returned by the container accessor is subsequently passed to pointer to determine the local coordinates of the pointer.The default container accessor returns the parent node of the element in the originating selection (see drag) that received the initiating input event. This is often appropriate when dragging SVG or HTML elements, since those elements are typically positioned relative to a parent. For dragging graphical elements with a Canvas, however, you may want to redefine the container as the initiating element itself:jsfunction container() {
  return this;
}Alternatively, the container may be specified as the element directly, such as drag.container(canvas).drag.filter(filter) ​Source · If filter is specified, sets the event filter to the specified function and returns the drag behavior. If filter is not specified, returns the current filter, which defaults to:jsfunction filter(event) {
  return !event.ctrlKey && !event.button;
}If the filter returns falsey, the initiating event is ignored and no drag gestures are started. Thus, the filter determines which input events are ignored; the default filter ignores mousedown events on secondary buttons, since those buttons are typically intended for other purposes, such as the context menu.drag.touchable(touchable) ​Source · If touchable is specified, sets the touch support detector to the specified function and returns the drag behavior. If touchable is not specified, returns the current touch support detector, which defaults to:jsfunction touchable() {
  return navigator.maxTouchPoints || ("ontouchstart" in this);
}Touch event listeners are only registered if the detector returns truthy for the corresponding element when the drag behavior is applied. The default detector works well for most browsers that are capable of touch input, but not all; Chrome’s mobile device emulator, for example, fails detection.drag.subject(subject) ​Source · If subject is specified, sets the subject accessor to the specified object or function and returns the drag behavior. If subject is not specified, returns the current subject accessor, which defaults to:jsfunction subject(event, d) {
  return d == null ? {x: event.x, y: event.y} : d;
}The subject of a drag gesture represents the thing being dragged. It is computed when an initiating input event is received, such as a mousedown or touchstart, immediately before the drag gesture starts. The subject is then exposed as event.subject on subsequent drag events for this gesture.The default subject is the datum of the element in the originating selection (see drag) that received the initiating input event; if this datum is undefined, an object representing the coordinates of the pointer is created. When dragging circle elements in SVG, the default subject is thus the datum of the circle being dragged. With Canvas, the default subject is the canvas element’s datum (regardless of where on the canvas you click). In this case, a custom subject accessor would be more appropriate, such as one that picks the closest circle to the mouse within a given search radius:jsfunction subject(event) {
  let n = circles.length,
      i,
      dx,
      dy,
      d2,
      s2 = radius * radius,
      circle,
      subject;

  for (i = 0; i < n; ++i) {
    circle = circles[i];
    dx = event.x - circle.x;
    dy = event.y - circle.y;
    d2 = dx * dx + dy * dy;
    if (d2 < s2) subject = circle, s2 = d2;
  }

  return subject;
}TIPIf necessary, the above can be accelerated using quadtree.find, simulation.find or delaunay.find.The returned subject should be an object that exposes x and y properties, so that the relative position of the subject and the pointer can be preserved during the drag gesture. If the subject is null or undefined, no drag gesture is started for this pointer; however, other starting touches may yet start drag gestures. See also drag.filter.The subject of a drag gesture may not be changed after the gesture starts. The subject accessor is invoked with the same context and arguments as selection.on listeners: the current event (event) and datum d, with the this context as the current DOM element. During the evaluation of the subject accessor, event is a beforestart drag event. Use event.sourceEvent to access the initiating input event and event.identifier to access the touch identifier. The event.x and event.y are relative to the container, and are computed using pointer.drag.clickDistance(distance) ​Source · If distance is specified, sets the maximum distance that the mouse can move between mousedown and mouseup that will trigger a subsequent click event. If at any point between mousedown and mouseup the mouse is greater than or equal to distance from its position on mousedown, the click event following mouseup will be suppressed. If distance is not specified, returns the current distance threshold, which defaults to zero. The distance threshold is measured in client coordinates (event.clientX and event.clientY).drag.on(typenames, listener) ​Source · If listener is specified, sets the event listener for the specified typenames and returns the drag behavior. If an event listener was already registered for the same type and name, the existing listener is removed before the new listener is added. If listener is null, removes the current event listeners for the specified typenames, if any. If listener is not specified, returns the first currently-assigned listener matching the specified typenames, if any. When a specified event is dispatched, each listener will be invoked with the same context and arguments as selection.on listeners: the current event (event) and datum d, with the this context as the current DOM element.The typenames is a string containing one or more typename separated by whitespace. Each typename is a type, optionally followed by a period (.) and a name, such as drag.foo and drag.bar; the name allows multiple listeners to be registered for the same type. The type must be one of the following:start - after a new pointer becomes active (on mousedown or touchstart).drag - after an active pointer moves (on mousemove or touchmove).end - after an active pointer becomes inactive (on mouseup, touchend or touchcancel).See dispatch.on for more.Changes to registered listeners via drag.on during a drag gesture do not affect the current drag gesture. Instead, you must use event.on, which also allows you to register temporary event listeners for the current drag gesture. Separate events are dispatched for each active pointer during a drag gesture. For example, if simultaneously dragging multiple subjects with multiple fingers, a start event is dispatched for each finger, even if both fingers start touching simultaneously. See Drag Events for more.dragDisable(window) ​Source · Prevents native drag-and-drop and text selection on the specified window. As an alternative to preventing the default action of mousedown events (see #9), this method prevents undesirable default actions following mousedown. In supported browsers, this means capturing dragstart and selectstart events, preventing the associated default actions, and immediately stopping their propagation. In browsers that do not support selection events, the user-select CSS property is set to none on the document element. This method is intended to be called on mousedown, followed by dragEnable on mouseup.dragEnable(window, noclick) ​Source · Allows native drag-and-drop and text selection on the specified window; undoes the effect of dragDisable. This method is intended to be called on mouseup, preceded by dragDisable on mousedown. If noclick is true, this method also temporarily suppresses click events. The suppression of click events expires after a zero-millisecond timeout, such that it only suppress the click event that would immediately follow the current mouseup event, if any.Drag events ​When a drag event listener is invoked, it receives the current drag event as its first argument. The event object exposes several fields:target - the associated drag behavior.type - the string “start”, “drag” or “end”; see drag.on.subject - the drag subject, defined by drag.subject.x - the new x-coordinate of the subject; see drag.container.y - the new y coordinate of the subject; see drag.container.dx - the change in x-coordinate since the previous drag event.dy - the change in y coordinate since the previous drag event.identifier - the string “mouse”, or a numeric touch identifier.active - the number of currently active drag gestures (on start and end, not including this one).sourceEvent - the underlying input event, such as mousemove or touchmove.The event.active field is useful for detecting the first start event and the last end event in a sequence of concurrent drag gestures: it is zero when the first drag gesture starts, and zero when the last drag gesture ends.The event object also exposes the event.on method.This table describes how the drag behavior interprets native events:EventListening ElementDrag EventDefault Prevented?mousedown⁵selectionstartno¹mousemove²window¹dragyesmouseup²window¹endyesdragstart²window-yesselectstart²window-yesclick³window-yestouchstartselectionstartno⁴touchmoveselectiondragyestouchendselectionendno⁴touchcancelselectionendno⁴The propagation of all consumed events is immediately stopped. If you want to prevent some events from initiating a drag gesture, use drag.filter.¹ Necessary to capture events outside an iframe; see #9. ² Only applies during an active, mouse-based gesture; see #9. ³ Only applies immediately after some mouse-based gestures; see drag.clickDistance. ⁴ Necessary to allow click emulation on touch input; see #9. ⁵ Ignored if within 500ms of a touch gesture ending; assumes click emulation.event.on(typenames, listener) ​Source · Equivalent to drag.on, but only applies to the current drag gesture. Before the drag gesture starts, a copy of the current drag event listeners is made. This copy is bound to the current drag gesture and modified by event.on. This is useful for temporary listeners that only receive events for the current drag gesture. For example, this start event listener registers temporary drag and end event listeners as closures:jsfunction started(event) {
  const circle = d3.select(this).classed("dragging", true);
  const dragged = (event, d) => circle.raise().attr("cx", d.x = event.x).attr("cy", d.y = event.y);
  const ended = () => circle.classed("dragging", false);
  event.on("drag", dragged).on("end", ended);
}PagerPrevious paged3-dispatchNext paged3-zoom\n\nd3-drag ​Examples · Drag-and-drop is a popular interaction method for manipulating spatial elements: move the pointer to an object, press and hold to grab it, “drag” the object to a new location, and release to “drop”. D3’s drag behavior provides a flexible abstraction for drag-and-drop. For example, you can drag nodes in a force-directed graph:Or a simulation of colliding circles:The drag behavior isn’t just for moving elements around; there are a variety of ways to respond to a drag gesture. For example, you can use it to lasso elements in a scatterplot, or to paint lines on a canvas:The drag behavior can be combined with other behaviors, such as d3-zoom for zooming:The drag behavior is agnostic about the DOM, so you can use it with SVG, HTML or even Canvas! And you can extend it with advanced selection techniques, such as a Voronoi overlay or a closest-target search:The drag behavior unifies mouse and touch input and avoids browser quirks. In the future the drag behavior will support Pointer Events, too.drag() ​Source · Creates a new drag behavior. The returned behavior, drag, is both an object and a function, and is typically applied to selected elements via selection.call.jsconst drag = d3.drag();drag(selection) ​Source · Applies this drag behavior to the specified selection. This function is typically not invoked directly, and is instead invoked via selection.call. For example, to instantiate a drag behavior and apply it to a selection:jsd3.selectAll(".node").call(d3.drag().on("start", started));Internally, the drag behavior uses selection.on to bind the necessary event listeners for dragging. The listeners use the name .drag, so you can subsequently unbind the drag behavior as follows:jsselection.on(".drag", null);Applying the drag behavior also sets the -webkit-tap-highlight-color style to transparent, disabling the tap highlight on iOS. If you want a different tap highlight color, remove or re-apply this style after applying the drag behavior.drag.container(container) ​Source · If container is specified, sets the container accessor to the specified object or function and returns the drag behavior. If container is not specified, returns the current container accessor, which defaults to:jsfunction container() {
  return this.parentNode;
}The container of a drag gesture determines the coordinate system of subsequent drag events, affecting event.x and event.y. The element returned by the container accessor is subsequently passed to pointer to determine the local coordinates of the pointer.The default container accessor returns the parent node of the element in the originating selection (see drag) that received the initiating input event. This is often appropriate when dragging SVG or HTML elements, since those elements are typically positioned relative to a parent. For dragging graphical elements with a Canvas, however, you may want to redefine the container as the initiating element itself:jsfunction container() {
  return this;
}Alternatively, the container may be specified as the element directly, such as drag.container(canvas).drag.filter(filter) ​Source · If filter is specified, sets the event filter to the specified function and returns the drag behavior. If filter is not specified, returns the current filter, which defaults to:jsfunction filter(event) {
  return !event.ctrlKey && !event.button;
}If the filter returns falsey, the initiating event is ignored and no drag gestures are started. Thus, the filter determines which input events are ignored; the default filter ignores mousedown events on secondary buttons, since those buttons are typically intended for other purposes, such as the context menu.drag.touchable(touchable) ​Source · If touchable is specified, sets the touch support detector to the specified function and returns the drag behavior. If touchable is not specified, returns the current touch support detector, which defaults to:jsfunction touchable() {
  return navigator.maxTouchPoints || ("ontouchstart" in this);
}Touch event listeners are only registered if the detector returns truthy for the corresponding element when the drag behavior is applied. The default detector works well for most browsers that are capable of touch input, but not all; Chrome’s mobile device emulator, for example, fails detection.drag.subject(subject) ​Source · If subject is specified, sets the subject accessor to the specified object or function and returns the drag behavior. If subject is not specified, returns the current subject accessor, which defaults to:jsfunction subject(event, d) {
  return d == null ? {x: event.x, y: event.y} : d;
}The subject of a drag gesture represents the thing being dragged. It is computed when an initiating input event is received, such as a mousedown or touchstart, immediately before the drag gesture starts. The subject is then exposed as event.subject on subsequent drag events for this gesture.The default subject is the datum of the element in the originating selection (see drag) that received the initiating input event; if this datum is undefined, an object representing the coordinates of the pointer is created. When dragging circle elements in SVG, the default subject is thus the datum of the circle being dragged. With Canvas, the default subject is the canvas element’s datum (regardless of where on the canvas you click). In this case, a custom subject accessor would be more appropriate, such as one that picks the closest circle to the mouse within a given search radius:jsfunction subject(event) {
  let n = circles.length,
      i,
      dx,
      dy,
      d2,
      s2 = radius * radius,
      circle,
      subject;

  for (i = 0; i < n; ++i) {
    circle = circles[i];
    dx = event.x - circle.x;
    dy = event.y - circle.y;
    d2 = dx * dx + dy * dy;
    if (d2 < s2) subject = circle, s2 = d2;
  }

  return subject;
}TIPIf necessary, the above can be accelerated using quadtree.find, simulation.find or delaunay.find.The returned subject should be an object that exposes x and y properties, so that the relative position of the subject and the pointer can be preserved during the drag gesture. If the subject is null or undefined, no drag gesture is started for this pointer; however, other starting touches may yet start drag gestures. See also drag.filter.The subject of a drag gesture may not be changed after the gesture starts. The subject accessor is invoked with the same context and arguments as selection.on listeners: the current event (event) and datum d, with the this context as the current DOM element. During the evaluation of the subject accessor, event is a beforestart drag event. Use event.sourceEvent to access the initiating input event and event.identifier to access the touch identifier. The event.x and event.y are relative to the container, and are computed using pointer.drag.clickDistance(distance) ​Source · If distance is specified, sets the maximum distance that the mouse can move between mousedown and mouseup that will trigger a subsequent click event. If at any point between mousedown and mouseup the mouse is greater than or equal to distance from its position on mousedown, the click event following mouseup will be suppressed. If distance is not specified, returns the current distance threshold, which defaults to zero. The distance threshold is measured in client coordinates (event.clientX and event.clientY).drag.on(typenames, listener) ​Source · If listener is specified, sets the event listener for the specified typenames and returns the drag behavior. If an event listener was already registered for the same type and name, the existing listener is removed before the new listener is added. If listener is null, removes the current event listeners for the specified typenames, if any. If listener is not specified, returns the first currently-assigned listener matching the specified typenames, if any. When a specified event is dispatched, each listener will be invoked with the same context and arguments as selection.on listeners: the current event (event) and datum d, with the this context as the current DOM element.The typenames is a string containing one or more typename separated by whitespace. Each typename is a type, optionally followed by a period (.) and a name, such as drag.foo and drag.bar; the name allows multiple listeners to be registered for the same type. The type must be one of the following:start - after a new pointer becomes active (on mousedown or touchstart).drag - after an active pointer moves (on mousemove or touchmove).end - after an active pointer becomes inactive (on mouseup, touchend or touchcancel).See dispatch.on for more.Changes to registered listeners via drag.on during a drag gesture do not affect the current drag gesture. Instead, you must use event.on, which also allows you to register temporary event listeners for the current drag gesture. Separate events are dispatched for each active pointer during a drag gesture. For example, if simultaneously dragging multiple subjects with multiple fingers, a start event is dispatched for each finger, even if both fingers start touching simultaneously. See Drag Events for more.dragDisable(window) ​Source · Prevents native drag-and-drop and text selection on the specified window. As an alternative to preventing the default action of mousedown events (see #9), this method prevents undesirable default actions following mousedown. In supported browsers, this means capturing dragstart and selectstart events, preventing the associated default actions, and immediately stopping their propagation. In browsers that do not support selection events, the user-select CSS property is set to none on the document element. This method is intended to be called on mousedown, followed by dragEnable on mouseup.dragEnable(window, noclick) ​Source · Allows native drag-and-drop and text selection on the specified window; undoes the effect of dragDisable. This method is intended to be called on mouseup, preceded by dragDisable on mousedown. If noclick is true, this method also temporarily suppresses click events. The suppression of click events expires after a zero-millisecond timeout, such that it only suppress the click event that would immediately follow the current mouseup event, if any.Drag events ​When a drag event listener is invoked, it receives the current drag event as its first argument. The event object exposes several fields:target - the associated drag behavior.type - the string “start”, “drag” or “end”; see drag.on.subject - the drag subject, defined by drag.subject.x - the new x-coordinate of the subject; see drag.container.y - the new y coordinate of the subject; see drag.container.dx - the change in x-coordinate since the previous drag event.dy - the change in y coordinate since the previous drag event.identifier - the string “mouse”, or a numeric touch identifier.active - the number of currently active drag gestures (on start and end, not including this one).sourceEvent - the underlying input event, such as mousemove or touchmove.The event.active field is useful for detecting the first start event and the last end event in a sequence of concurrent drag gestures: it is zero when the first drag gesture starts, and zero when the last drag gesture ends.The event object also exposes the event.on method.This table describes how the drag behavior interprets native events:EventListening ElementDrag EventDefault Prevented?mousedown⁵selectionstartno¹mousemove²window¹dragyesmouseup²window¹endyesdragstart²window-yesselectstart²window-yesclick³window-yestouchstartselectionstartno⁴touchmoveselectiondragyestouchendselectionendno⁴touchcancelselectionendno⁴The propagation of all consumed events is immediately stopped. If you want to prevent some events from initiating a drag gesture, use drag.filter.¹ Necessary to capture events outside an iframe; see #9. ² Only applies during an active, mouse-based gesture; see #9. ³ Only applies immediately after some mouse-based gestures; see drag.clickDistance. ⁴ Necessary to allow click emulation on touch input; see #9. ⁵ Ignored if within 500ms of a touch gesture ending; assumes click emulation.event.on(typenames, listener) ​Source · Equivalent to drag.on, but only applies to the current drag gesture. Before the drag gesture starts, a copy of the current drag event listeners is made. This copy is bound to the current drag gesture and modified by event.on. This is useful for temporary listeners that only receive events for the current drag gesture. For example, this start event listener registers temporary drag and end event listeners as closures:jsfunction started(event) {
  const circle = d3.select(this).classed("dragging", true);
  const dragged = (event, d) => circle.raise().attr("cx", d.x = event.x).attr("cy", d.y = event.y);
  const ended = () => circle.classed("dragging", false);
  event.on("drag", dragged).on("end", ended);
}\n\n\n\nd3-zoom ​Examples · Panning and zooming let the user focus on a region of interest by restricting the view. It uses direct manipulation: click-and-drag to pan (translate), spin the wheel to zoom (scale), or pinch with touch. Panning and zooming are widely used in web-based mapping, but can also be used in visualization such as dense time series and scatterplots.The zoom behavior is a flexible abstraction, handling a surprising variety of input modalities and browser quirks. The zoom behavior is agnostic about the DOM, so you can use it with HTML, SVG, or Canvas. You can use d3-zoom with d3-scale and d3-axis to zoom axes. You can restrict zooming using zoom.scaleExtent and panning using zoom.translateExtent. You can combine d3-zoom with other behaviors such as d3-drag for dragging and d3-brush for focus + context.The zoom behavior can be controlled programmatically using zoom.transform, allowing you to implement user interface controls which drive the display or to stage animated tours through your data. Smooth zoom transitions are based on “Smooth and efficient zooming and panning” by Jarke J. van Wijk and Wim A.A. Nuij.See also d3-tile for examples panning and zooming maps.zoom() ​Source · Creates a new zoom behavior. The returned behavior, zoom, is both an object and a function, and is typically applied to selected elements via selection.call.zoom(selection) ​Source · Applies this zoom behavior to the specified selection, binding the necessary event listeners to allow panning and zooming, and initializing the zoom transform on each selected element to the identity transform if not already defined.This function is typically not invoked directly, and is instead invoked via selection.call. For example, to instantiate a zoom behavior and apply it to a selection:jsselection.call(d3.zoom().on("zoom", zoomed));Internally, the zoom behavior uses selection.on to bind the necessary event listeners for zooming. The listeners use the name .zoom, so you can subsequently unbind the zoom behavior as follows:jsselection.on(".zoom", null);To disable just wheel-driven zooming (say to not interfere with native scrolling), you can remove the zoom behavior’s wheel event listener after applying the zoom behavior to the selection:jsselection
    .call(zoom)
    .on("wheel.zoom", null);Alternatively, use zoom.filter for greater control over which events can initiate zoom gestures.Applying the zoom behavior also sets the -webkit-tap-highlight-color style to transparent, disabling the tap highlight on iOS. If you want a different tap highlight color, remove or re-apply this style after applying the drag behavior.The zoom behavior stores the zoom state on the element to which the zoom behavior was applied, not on the zoom behavior itself. This allows the zoom behavior to be applied to many elements simultaneously with independent zooming. The zoom state can change either on user interaction or programmatically via zoom.transform.To retrieve the zoom state, use event.transform on the current zoom event within a zoom event listener (see zoom.on), or use zoomTransform for a given node. The latter is useful for modifying the zoom state programmatically, say to implement buttons for zooming in and out.zoom.transform(selection, transform, point) ​Source · If selection is a selection, sets the current zoom transform of the selected elements to the specified transform, instantaneously emitting start, zoom and end events.If selection is a transition, defines a “zoom” tween to the specified transform using interpolateZoom, emitting a start event when the transition starts, zoom events for each tick of the transition, and then an end event when the transition ends (or is interrupted). The transition will attempt to minimize the visual movement around the specified point; if the point is not specified, it defaults to the center of the viewport extent.The transform may be specified either as a zoom transform or as a function that returns a zoom transform; similarly, the point may be specified either as a two-element array [x, y] or a function that returns such an array. If a function, it is invoked for each selected element, being passed the current event (event) and datum d, with the this context as the current DOM element.This function is typically not invoked directly, and is instead invoked via selection.call or transition.call. For example, to reset the zoom transform to the identity transform instantaneously:jsselection.call(zoom.transform, d3.zoomIdentity);To smoothly reset the zoom transform to the identity transform over 750 milliseconds:jsselection.transition().duration(750).call(zoom.transform, d3.zoomIdentity);This method requires that you specify the new zoom transform completely, and does not enforce the defined scale extent and translate extent, if any. To derive a new transform from the existing transform, and to enforce the scale and translate extents, see the convenience methods zoom.translateBy, zoom.scaleBy and zoom.scaleTo.zoom.translateBy(selection, x, y) ​Source · If selection is a selection, translates the current zoom transform of the selected elements by x and y, such that the new tx1 = tx0 + kx and ty1 = ty0 + ky. If selection is a transition, defines a “zoom” tween translating the current transform. This method is a convenience method for zoom.transform. The x and y translation amounts may be specified either as numbers or as functions that return numbers. If a function, it is invoked for each selected element, being passed the current datum d and index i, with the this context as the current DOM element.zoom.translateTo(selection, x, y, p) ​Source · If selection is a selection, translates the current zoom transform of the selected elements such that the given position ⟨x,y⟩ appears at given point p. The new tx = px - kx and ty = py - ky. If p is not specified, it defaults to the center of the viewport extent. If selection is a transition, defines a “zoom” tween translating the current transform. This method is a convenience method for zoom.transform. The x and y coordinates may be specified either as numbers or as functions that returns numbers; similarly the p point may be specified either as a two-element array [px,py] or a function. If a function, it is invoked for each selected element, being passed the current datum d and index i, with the this context as the current DOM element.zoom.scaleBy(selection, k, p) ​Source · If selection is a selection, scales the current zoom transform of the selected elements by k, such that the new k₁ = k₀k. The reference point p does move. If p is not specified, it defaults to the center of the viewport extent. If selection is a transition, defines a “zoom” tween translating the current transform. This method is a convenience method for zoom.transform. The k scale factor may be specified either as a number or a function that returns a number; similarly the p point may be specified either as a two-element array [px,py] or a function. If a function, it is invoked for each selected element, being passed the current datum d and index i, with the this context as the current DOM element.zoom.scaleTo(selection, k, p) ​Source · If selection is a selection, scales the current zoom transform of the selected elements to k, such that the new k₁ = k. The reference point p does move. If p is not specified, it defaults to the center of the viewport extent. If selection is a transition, defines a “zoom” tween translating the current transform. This method is a convenience method for zoom.transform. The k scale factor may be specified either as a number or a function that returns a number; similarly the p point may be specified either as a two-element array [px,py] or a function. If a function, it is invoked for each selected element, being passed the current datum d and index i, with the this context as the current DOM element.zoom.constrain(constrain) ​Source · If constrain is specified, sets the transform constraint function to the specified function and returns the zoom behavior. If constrain is not specified, returns the current constraint function, which defaults to:jsfunction constrain(transform, extent, translateExtent) {
  var dx0 = transform.invertX(extent[0][0]) - translateExtent[0][0],
      dx1 = transform.invertX(extent[1][0]) - translateExtent[1][0],
      dy0 = transform.invertY(extent[0][1]) - translateExtent[0][1],
      dy1 = transform.invertY(extent[1][1]) - translateExtent[1][1];
  return transform.translate(
    dx1 > dx0 ? (dx0 + dx1) / 2 : Math.min(0, dx0) || Math.max(0, dx1),
    dy1 > dy0 ? (dy0 + dy1) / 2 : Math.min(0, dy0) || Math.max(0, dy1)
  );
}The constraint function must return a [transform]#zoomTransform) given the current transform, viewport extent and translate extent. The default implementation attempts to ensure that the viewport extent does not go outside the translate extent.zoom.filter(filter) ​Source · If filter is specified, sets the filter to the specified function and returns the zoom behavior. If filter is not specified, returns the current filter, which defaults to:jsfunction filter(event) {
  return (!event.ctrlKey || event.type === 'wheel') && !event.button;
}The filter is passed the current event (event) and datum d, with the this context as the current DOM element. If the filter returns falsey, the initiating event is ignored and no zoom gestures are started. Thus, the filter determines which input events are ignored. The default filter ignores mousedown events on secondary buttons, since those buttons are typically intended for other purposes, such as the context menu.zoom.touchable(touchable) ​Source · If touchable is specified, sets the touch support detector to the specified function and returns the zoom behavior. If touchable is not specified, returns the current touch support detector, which defaults to:jsfunction touchable() {
  return navigator.maxTouchPoints || ("ontouchstart" in this);
}Touch event listeners are only registered if the detector returns truthy for the corresponding element when the zoom behavior is applied. The default detector works well for most browsers that are capable of touch input, but not all; Chrome’s mobile device emulator, for example, fails detection.zoom.wheelDelta(delta) ​Source · If delta is specified, sets the wheel delta function to the specified function and returns the zoom behavior. If delta is not specified, returns the current wheel delta function, which defaults to:jsfunction wheelDelta(event) {
  return -event.deltaY * (event.deltaMode === 1 ? 0.05 : event.deltaMode ? 1 : 0.002) * (event.ctrlKey ? 10 : 1);
}The value Δ returned by the wheel delta function determines the amount of scaling applied in response to a WheelEvent. The scale factor transform.k is multiplied by 2Δ; for example, a Δ of +1 doubles the scale factor, Δ of -1 halves the scale factor.zoom.extent(extent) ​Source · If extent is specified, sets the viewport extent to the specified array of points [[x0, y0], [x1, y1]], where [x0, y0] is the top-left corner of the viewport and [x1, y1] is the bottom-right corner of the viewport, and returns this zoom behavior. The extent may also be specified as a function which returns such an array; if a function, it is invoked for each selected element, being passed the current datum d, with the this context as the current DOM element.If extent is not specified, returns the current extent accessor, which defaults to [[0, 0], [width, height]] where width is the client width of the element and height is its client height; for SVG elements, the nearest ancestor SVG element’s viewBox, or width and height attributes, are used. Alternatively, consider using element.getBoundingClientRect.The viewport extent affects several functions: the center of the viewport remains fixed during changes by zoom.scaleBy and zoom.scaleTo; the viewport center and dimensions affect the path chosen by interpolateZoom; and the viewport extent is needed to enforce the optional translate extent.zoom.scaleExtent(extent) ​Source · If extent is specified, sets the scale extent to the specified array of numbers [k0, k1] where k0 is the minimum allowed scale factor and k1 is the maximum allowed scale factor, and returns this zoom behavior. If extent is not specified, returns the current scale extent, which defaults to [0, ∞]. The scale extent restricts zooming in and out. It is enforced on interaction and when using zoom.scaleBy, zoom.scaleTo and zoom.translateBy; however, it is not enforced when using zoom.transform to set the transform explicitly.If the user tries to zoom by wheeling when already at the corresponding limit of the scale extent, the wheel events will be ignored and not initiate a zoom gesture. This allows the user to scroll down past a zoomable area after zooming in, or to scroll up after zooming out. If you would prefer to always prevent scrolling on wheel input regardless of the scale extent, register a wheel event listener to prevent the browser default behavior:jsselection
    .call(zoom)
    .on("wheel", event => event.preventDefault());zoom.translateExtent(extent) ​Source · If extent is specified, sets the translate extent to the specified array of points [[x0, y0], [x1, y1]], where [x0, y0] is the top-left corner of the world and [x1, y1] is the bottom-right corner of the world, and returns this zoom behavior. If extent is not specified, returns the current translate extent, which defaults to [[-∞, -∞], [+∞, +∞]]. The translate extent restricts panning, and may cause translation on zoom out. It is enforced on interaction and when using zoom.scaleBy, zoom.scaleTo and zoom.translateBy; however, it is not enforced when using zoom.transform to set the transform explicitly.zoom.clickDistance(distance) ​Source · If distance is specified, sets the maximum distance that the mouse can move between mousedown and mouseup that will trigger a subsequent click event. If at any point between mousedown and mouseup the mouse is greater than or equal to distance from its position on mousedown, the click event following mouseup will be suppressed. If distance is not specified, returns the current distance threshold, which defaults to zero. The distance threshold is measured in client coordinates (event.clientX and event.clientY).zoom.tapDistance(distance) ​Source · If distance is specified, sets the maximum distance that a double-tap gesture can move between first touchstart and second touchend that will trigger a subsequent double-click event. If distance is not specified, returns the current distance threshold, which defaults to 10. The distance threshold is measured in client coordinates (event.clientX and event.clientY).zoom.duration(duration) ​Source · If duration is specified, sets the duration for zoom transitions on double-click and double-tap to the specified number of milliseconds and returns the zoom behavior. If duration is not specified, returns the current duration, which defaults to 250 milliseconds. If the duration is not greater than zero, double-click and -tap trigger instantaneous changes to the zoom transform rather than initiating smooth transitions.To disable double-click and double-tap transitions, you can remove the zoom behavior’s dblclick event listener after applying the zoom behavior to the selection:jsselection
    .call(zoom)
    .on("dblclick.zoom", null);zoom.interpolate(interpolate) ​Source · If interpolate is specified, sets the interpolation factory for zoom transitions to the specified function. If interpolate is not specified, returns the current interpolation factory, which defaults to interpolateZoom to implement smooth zooming. To apply direct interpolation between two views, try interpolate instead.zoom.on(typenames, listener) ​Source · If listener is specified, sets the event listener for the specified typenames and returns the zoom behavior. If an event listener was already registered for the same type and name, the existing listener is removed before the new listener is added. If listener is null, removes the current event listeners for the specified typenames, if any. If listener is not specified, returns the first currently-assigned listener matching the specified typenames, if any. When a specified event is dispatched, each listener will be invoked with the same context and arguments as selection.on listeners: the current event (event) and datum d, with the this context as the current DOM element.The typenames is a string containing one or more typename separated by whitespace. Each typename is a type, optionally followed by a period (.) and a name, such as zoom.foo and zoom.bar; the name allows multiple listeners to be registered for the same type. The type must be one of the following:start - after zooming begins (such as on mousedown).zoom - after a change to the zoom transform (such as on mousemove).end - after zooming ends (such as on mouseup ).See dispatch.on for more.Zoom events ​When a zoom event listener is invoked, it receives the current zoom event as a first argument. The event object exposes several fields:event.target - the associated zoom behavior.event.type - the string “start”, “zoom” or “end”; see zoom.on.event.transform - the current zoom transform.event.sourceEvent - the underlying input event, such as mousemove or touchmove.The zoom behavior handles a variety of interaction events:EventListening ElementZoom EventDefault Prevented?mousedown⁵selectionstartno¹mousemove²window¹zoomyesmouseup²window¹endyesdragstart²window-yesselectstart²window-yesclick³window-yesdblclickselectionmultiple⁶yeswheel⁸selectionzoom⁷yestouchstartselectionmultiple⁶no⁴touchmoveselectionzoomyestouchendselectionendno⁴touchcancelselectionendno⁴The propagation of all consumed events is immediately stopped.¹ Necessary to capture events outside an iframe; see d3-drag#9. ² Only applies during an active, mouse-based gesture; see d3-drag#9. ³ Only applies immediately after some mouse-based gestures; see zoom.clickDistance. ⁴ Necessary to allow click emulation on touch input; see d3-drag#9. ⁵ Ignored if within 500ms of a touch gesture ending; assumes click emulation. ⁶ Double-click and double-tap initiate a transition that emits start, zoom and end events; see zoom.tapDistance. ⁷ The first wheel event emits a start event; an end event is emitted when no wheel events are received for 150ms. ⁸ Ignored if already at the corresponding limit of the scale extent.zoomTransform(node) ​Source · Returns the current transform for the specified node. Note that node should typically be a DOM element, not a selection. (A selection may consist of multiple nodes, in different states, and this function only returns a single transform.) If you have a selection, call selection.node first:jsvar transform = d3.zoomTransform(selection.node());In the context of an event listener, the node is typically the element that received the input event (which should be equal to event.transform), this:jsvar transform = d3.zoomTransform(this);Internally, an element’s transform is stored as element.__zoom; however, you should use this method rather than accessing it directly. If the given node has no defined transform, returns the transform of the closest ancestor, or if none exists, the identity transformation. The returned transform represents a two-dimensional transformation matrix of the form:k 0 tx0 k ty0 0 1(This matrix is capable of representing only scale and translation; a future release may also allow rotation, though this would probably not be a backwards-compatible change.) The position ⟨x,y⟩ is transformed to ⟨xk + tx,yk + ty⟩. The transform object exposes the following properties:transform.x - the translation amount tx along the x-axis.transform.y - the translation amount ty along the y-axis.transform.k - the scale factor k.These properties should be considered read-only; instead of mutating a transform, use transform.scale and transform.translate to derive a new transform. Also see zoom.scaleBy, zoom.scaleTo and zoom.translateBy for convenience methods on the zoom behavior. To create a transform with a given k, tx, and ty:jsvar t = d3.zoomIdentity.translate(x, y).scale(k);To apply the transformation to a Canvas 2D context, use context.translate followed by context.scale:jscontext.translate(transform.x, transform.y);
context.scale(transform.k, transform.k);Similarly, to apply the transformation to HTML elements via CSS:jsdiv.style("transform", "translate(" + transform.x + "px," + transform.y + "px) scale(" + transform.k + ")");
div.style("transform-origin", "0 0");To apply the transformation to SVG:jsg.attr("transform", "translate(" + transform.x + "," + transform.y + ") scale(" + transform.k + ")");Or more simply, taking advantage of transform.toString:jsg.attr("transform", transform);Note that the order of transformations matters! The translate must be applied before the scale.zoomIdentity ​Source · The identity transform, where k = 1, tx = ty = 0.new d3.ZoomTransform(k, x, y) ​Source · Returns a transform with scale k and translation (x, y).transform.scale(k) ​Source · Returns a transform whose scale k₁ is equal to k₀k, where k₀ is this transform’s scale.transform.translate(x, y) ​Source · Returns a transform whose translation tx1 and ty1 is equal to tx0 + tk x and ty0 + tk y, where tx0 and ty0 is this transform’s translation and tk is this transform’s scale.transform.apply(point) ​Source · Returns the transformation of the specified point which is a two-element array of numbers [x, y]. The returned point is equal to [xk + tx, yk + ty].transform.applyX(x) ​Source · Returns the transformation of the specified x-coordinate, xk + tx.transform.applyY(y) ​Source · Returns the transformation of the specified y coordinate, yk + ty.transform.invert(point) ​Source · Returns the inverse transformation of the specified point which is a two-element array of numbers [x, y]. The returned point is equal to [(x - tx) / k, (y - ty) / k].transform.invertX(x) ​Source · Returns the inverse transformation of the specified x-coordinate, (x - tx) / k.transform.invertY(y) ​Source · Returns the inverse transformation of the specified y coordinate, (y - ty) / k.transform.rescaleX(x) ​Source · Returns a copy of the continuous scale x whose domain is transformed. This is implemented by first applying the inverse x-transform on the scale’s range, and then applying the inverse scale to compute the corresponding domain:jsfunction rescaleX(x) {
  var range = x.range().map(transform.invertX, transform),
      domain = range.map(x.invert, x);
  return x.copy().domain(domain);
}The scale x must use interpolateNumber; do not use continuous.rangeRound as this reduces the accuracy of continuous.invert and can lead to an inaccurate rescaled domain. This method does not modify the input scale x; x thus represents the untransformed scale, while the returned scale represents its transformed view.transform.rescaleY(y) ​Source · Returns a copy of the continuous scale y whose domain is transformed. This is implemented by first applying the inverse y-transform on the scale’s range, and then applying the inverse scale to compute the corresponding domain:jsfunction rescaleY(y) {
  var range = y.range().map(transform.invertY, transform),
      domain = range.map(y.invert, y);
  return y.copy().domain(domain);
}The scale y must use interpolateNumber; do not use continuous.rangeRound as this reduces the accuracy of continuous.invert and can lead to an inaccurate rescaled domain. This method does not modify the input scale y; y thus represents the untransformed scale, while the returned scale represents its transformed view.transform.toString() ​Source · Returns a string representing the SVG transform corresponding to this transform. Implemented as:jsfunction toString() {
  return "translate(" + this.x + "," + this.y + ") scale(" + this.k + ")";
}\n\nSearchK7.9.0GitHub️ 110.0kOn this paged3-zoom ​Examples · Panning and zooming let the user focus on a region of interest by restricting the view. It uses direct manipulation: click-and-drag to pan (translate), spin the wheel to zoom (scale), or pinch with touch. Panning and zooming are widely used in web-based mapping, but can also be used in visualization such as dense time series and scatterplots.The zoom behavior is a flexible abstraction, handling a surprising variety of input modalities and browser quirks. The zoom behavior is agnostic about the DOM, so you can use it with HTML, SVG, or Canvas. You can use d3-zoom with d3-scale and d3-axis to zoom axes. You can restrict zooming using zoom.scaleExtent and panning using zoom.translateExtent. You can combine d3-zoom with other behaviors such as d3-drag for dragging and d3-brush for focus + context.The zoom behavior can be controlled programmatically using zoom.transform, allowing you to implement user interface controls which drive the display or to stage animated tours through your data. Smooth zoom transitions are based on “Smooth and efficient zooming and panning” by Jarke J. van Wijk and Wim A.A. Nuij.See also d3-tile for examples panning and zooming maps.zoom() ​Source · Creates a new zoom behavior. The returned behavior, zoom, is both an object and a function, and is typically applied to selected elements via selection.call.zoom(selection) ​Source · Applies this zoom behavior to the specified selection, binding the necessary event listeners to allow panning and zooming, and initializing the zoom transform on each selected element to the identity transform if not already defined.This function is typically not invoked directly, and is instead invoked via selection.call. For example, to instantiate a zoom behavior and apply it to a selection:jsselection.call(d3.zoom().on("zoom", zoomed));Internally, the zoom behavior uses selection.on to bind the necessary event listeners for zooming. The listeners use the name .zoom, so you can subsequently unbind the zoom behavior as follows:jsselection.on(".zoom", null);To disable just wheel-driven zooming (say to not interfere with native scrolling), you can remove the zoom behavior’s wheel event listener after applying the zoom behavior to the selection:jsselection
    .call(zoom)
    .on("wheel.zoom", null);Alternatively, use zoom.filter for greater control over which events can initiate zoom gestures.Applying the zoom behavior also sets the -webkit-tap-highlight-color style to transparent, disabling the tap highlight on iOS. If you want a different tap highlight color, remove or re-apply this style after applying the drag behavior.The zoom behavior stores the zoom state on the element to which the zoom behavior was applied, not on the zoom behavior itself. This allows the zoom behavior to be applied to many elements simultaneously with independent zooming. The zoom state can change either on user interaction or programmatically via zoom.transform.To retrieve the zoom state, use event.transform on the current zoom event within a zoom event listener (see zoom.on), or use zoomTransform for a given node. The latter is useful for modifying the zoom state programmatically, say to implement buttons for zooming in and out.zoom.transform(selection, transform, point) ​Source · If selection is a selection, sets the current zoom transform of the selected elements to the specified transform, instantaneously emitting start, zoom and end events.If selection is a transition, defines a “zoom” tween to the specified transform using interpolateZoom, emitting a start event when the transition starts, zoom events for each tick of the transition, and then an end event when the transition ends (or is interrupted). The transition will attempt to minimize the visual movement around the specified point; if the point is not specified, it defaults to the center of the viewport extent.The transform may be specified either as a zoom transform or as a function that returns a zoom transform; similarly, the point may be specified either as a two-element array [x, y] or a function that returns such an array. If a function, it is invoked for each selected element, being passed the current event (event) and datum d, with the this context as the current DOM element.This function is typically not invoked directly, and is instead invoked via selection.call or transition.call. For example, to reset the zoom transform to the identity transform instantaneously:jsselection.call(zoom.transform, d3.zoomIdentity);To smoothly reset the zoom transform to the identity transform over 750 milliseconds:jsselection.transition().duration(750).call(zoom.transform, d3.zoomIdentity);This method requires that you specify the new zoom transform completely, and does not enforce the defined scale extent and translate extent, if any. To derive a new transform from the existing transform, and to enforce the scale and translate extents, see the convenience methods zoom.translateBy, zoom.scaleBy and zoom.scaleTo.zoom.translateBy(selection, x, y) ​Source · If selection is a selection, translates the current zoom transform of the selected elements by x and y, such that the new tx1 = tx0 + kx and ty1 = ty0 + ky. If selection is a transition, defines a “zoom” tween translating the current transform. This method is a convenience method for zoom.transform. The x and y translation amounts may be specified either as numbers or as functions that return numbers. If a function, it is invoked for each selected element, being passed the current datum d and index i, with the this context as the current DOM element.zoom.translateTo(selection, x, y, p) ​Source · If selection is a selection, translates the current zoom transform of the selected elements such that the given position ⟨x,y⟩ appears at given point p. The new tx = px - kx and ty = py - ky. If p is not specified, it defaults to the center of the viewport extent. If selection is a transition, defines a “zoom” tween translating the current transform. This method is a convenience method for zoom.transform. The x and y coordinates may be specified either as numbers or as functions that returns numbers; similarly the p point may be specified either as a two-element array [px,py] or a function. If a function, it is invoked for each selected element, being passed the current datum d and index i, with the this context as the current DOM element.zoom.scaleBy(selection, k, p) ​Source · If selection is a selection, scales the current zoom transform of the selected elements by k, such that the new k₁ = k₀k. The reference point p does move. If p is not specified, it defaults to the center of the viewport extent. If selection is a transition, defines a “zoom” tween translating the current transform. This method is a convenience method for zoom.transform. The k scale factor may be specified either as a number or a function that returns a number; similarly the p point may be specified either as a two-element array [px,py] or a function. If a function, it is invoked for each selected element, being passed the current datum d and index i, with the this context as the current DOM element.zoom.scaleTo(selection, k, p) ​Source · If selection is a selection, scales the current zoom transform of the selected elements to k, such that the new k₁ = k. The reference point p does move. If p is not specified, it defaults to the center of the viewport extent. If selection is a transition, defines a “zoom” tween translating the current transform. This method is a convenience method for zoom.transform. The k scale factor may be specified either as a number or a function that returns a number; similarly the p point may be specified either as a two-element array [px,py] or a function. If a function, it is invoked for each selected element, being passed the current datum d and index i, with the this context as the current DOM element.zoom.constrain(constrain) ​Source · If constrain is specified, sets the transform constraint function to the specified function and returns the zoom behavior. If constrain is not specified, returns the current constraint function, which defaults to:jsfunction constrain(transform, extent, translateExtent) {
  var dx0 = transform.invertX(extent[0][0]) - translateExtent[0][0],
      dx1 = transform.invertX(extent[1][0]) - translateExtent[1][0],
      dy0 = transform.invertY(extent[0][1]) - translateExtent[0][1],
      dy1 = transform.invertY(extent[1][1]) - translateExtent[1][1];
  return transform.translate(
    dx1 > dx0 ? (dx0 + dx1) / 2 : Math.min(0, dx0) || Math.max(0, dx1),
    dy1 > dy0 ? (dy0 + dy1) / 2 : Math.min(0, dy0) || Math.max(0, dy1)
  );
}The constraint function must return a [transform]#zoomTransform) given the current transform, viewport extent and translate extent. The default implementation attempts to ensure that the viewport extent does not go outside the translate extent.zoom.filter(filter) ​Source · If filter is specified, sets the filter to the specified function and returns the zoom behavior. If filter is not specified, returns the current filter, which defaults to:jsfunction filter(event) {
  return (!event.ctrlKey || event.type === 'wheel') && !event.button;
}The filter is passed the current event (event) and datum d, with the this context as the current DOM element. If the filter returns falsey, the initiating event is ignored and no zoom gestures are started. Thus, the filter determines which input events are ignored. The default filter ignores mousedown events on secondary buttons, since those buttons are typically intended for other purposes, such as the context menu.zoom.touchable(touchable) ​Source · If touchable is specified, sets the touch support detector to the specified function and returns the zoom behavior. If touchable is not specified, returns the current touch support detector, which defaults to:jsfunction touchable() {
  return navigator.maxTouchPoints || ("ontouchstart" in this);
}Touch event listeners are only registered if the detector returns truthy for the corresponding element when the zoom behavior is applied. The default detector works well for most browsers that are capable of touch input, but not all; Chrome’s mobile device emulator, for example, fails detection.zoom.wheelDelta(delta) ​Source · If delta is specified, sets the wheel delta function to the specified function and returns the zoom behavior. If delta is not specified, returns the current wheel delta function, which defaults to:jsfunction wheelDelta(event) {
  return -event.deltaY * (event.deltaMode === 1 ? 0.05 : event.deltaMode ? 1 : 0.002) * (event.ctrlKey ? 10 : 1);
}The value Δ returned by the wheel delta function determines the amount of scaling applied in response to a WheelEvent. The scale factor transform.k is multiplied by 2Δ; for example, a Δ of +1 doubles the scale factor, Δ of -1 halves the scale factor.zoom.extent(extent) ​Source · If extent is specified, sets the viewport extent to the specified array of points [[x0, y0], [x1, y1]], where [x0, y0] is the top-left corner of the viewport and [x1, y1] is the bottom-right corner of the viewport, and returns this zoom behavior. The extent may also be specified as a function which returns such an array; if a function, it is invoked for each selected element, being passed the current datum d, with the this context as the current DOM element.If extent is not specified, returns the current extent accessor, which defaults to [[0, 0], [width, height]] where width is the client width of the element and height is its client height; for SVG elements, the nearest ancestor SVG element’s viewBox, or width and height attributes, are used. Alternatively, consider using element.getBoundingClientRect.The viewport extent affects several functions: the center of the viewport remains fixed during changes by zoom.scaleBy and zoom.scaleTo; the viewport center and dimensions affect the path chosen by interpolateZoom; and the viewport extent is needed to enforce the optional translate extent.zoom.scaleExtent(extent) ​Source · If extent is specified, sets the scale extent to the specified array of numbers [k0, k1] where k0 is the minimum allowed scale factor and k1 is the maximum allowed scale factor, and returns this zoom behavior. If extent is not specified, returns the current scale extent, which defaults to [0, ∞]. The scale extent restricts zooming in and out. It is enforced on interaction and when using zoom.scaleBy, zoom.scaleTo and zoom.translateBy; however, it is not enforced when using zoom.transform to set the transform explicitly.If the user tries to zoom by wheeling when already at the corresponding limit of the scale extent, the wheel events will be ignored and not initiate a zoom gesture. This allows the user to scroll down past a zoomable area after zooming in, or to scroll up after zooming out. If you would prefer to always prevent scrolling on wheel input regardless of the scale extent, register a wheel event listener to prevent the browser default behavior:jsselection
    .call(zoom)
    .on("wheel", event => event.preventDefault());zoom.translateExtent(extent) ​Source · If extent is specified, sets the translate extent to the specified array of points [[x0, y0], [x1, y1]], where [x0, y0] is the top-left corner of the world and [x1, y1] is the bottom-right corner of the world, and returns this zoom behavior. If extent is not specified, returns the current translate extent, which defaults to [[-∞, -∞], [+∞, +∞]]. The translate extent restricts panning, and may cause translation on zoom out. It is enforced on interaction and when using zoom.scaleBy, zoom.scaleTo and zoom.translateBy; however, it is not enforced when using zoom.transform to set the transform explicitly.zoom.clickDistance(distance) ​Source · If distance is specified, sets the maximum distance that the mouse can move between mousedown and mouseup that will trigger a subsequent click event. If at any point between mousedown and mouseup the mouse is greater than or equal to distance from its position on mousedown, the click event following mouseup will be suppressed. If distance is not specified, returns the current distance threshold, which defaults to zero. The distance threshold is measured in client coordinates (event.clientX and event.clientY).zoom.tapDistance(distance) ​Source · If distance is specified, sets the maximum distance that a double-tap gesture can move between first touchstart and second touchend that will trigger a subsequent double-click event. If distance is not specified, returns the current distance threshold, which defaults to 10. The distance threshold is measured in client coordinates (event.clientX and event.clientY).zoom.duration(duration) ​Source · If duration is specified, sets the duration for zoom transitions on double-click and double-tap to the specified number of milliseconds and returns the zoom behavior. If duration is not specified, returns the current duration, which defaults to 250 milliseconds. If the duration is not greater than zero, double-click and -tap trigger instantaneous changes to the zoom transform rather than initiating smooth transitions.To disable double-click and double-tap transitions, you can remove the zoom behavior’s dblclick event listener after applying the zoom behavior to the selection:jsselection
    .call(zoom)
    .on("dblclick.zoom", null);zoom.interpolate(interpolate) ​Source · If interpolate is specified, sets the interpolation factory for zoom transitions to the specified function. If interpolate is not specified, returns the current interpolation factory, which defaults to interpolateZoom to implement smooth zooming. To apply direct interpolation between two views, try interpolate instead.zoom.on(typenames, listener) ​Source · If listener is specified, sets the event listener for the specified typenames and returns the zoom behavior. If an event listener was already registered for the same type and name, the existing listener is removed before the new listener is added. If listener is null, removes the current event listeners for the specified typenames, if any. If listener is not specified, returns the first currently-assigned listener matching the specified typenames, if any. When a specified event is dispatched, each listener will be invoked with the same context and arguments as selection.on listeners: the current event (event) and datum d, with the this context as the current DOM element.The typenames is a string containing one or more typename separated by whitespace. Each typename is a type, optionally followed by a period (.) and a name, such as zoom.foo and zoom.bar; the name allows multiple listeners to be registered for the same type. The type must be one of the following:start - after zooming begins (such as on mousedown).zoom - after a change to the zoom transform (such as on mousemove).end - after zooming ends (such as on mouseup ).See dispatch.on for more.Zoom events ​When a zoom event listener is invoked, it receives the current zoom event as a first argument. The event object exposes several fields:event.target - the associated zoom behavior.event.type - the string “start”, “zoom” or “end”; see zoom.on.event.transform - the current zoom transform.event.sourceEvent - the underlying input event, such as mousemove or touchmove.The zoom behavior handles a variety of interaction events:EventListening ElementZoom EventDefault Prevented?mousedown⁵selectionstartno¹mousemove²window¹zoomyesmouseup²window¹endyesdragstart²window-yesselectstart²window-yesclick³window-yesdblclickselectionmultiple⁶yeswheel⁸selectionzoom⁷yestouchstartselectionmultiple⁶no⁴touchmoveselectionzoomyestouchendselectionendno⁴touchcancelselectionendno⁴The propagation of all consumed events is immediately stopped.¹ Necessary to capture events outside an iframe; see d3-drag#9. ² Only applies during an active, mouse-based gesture; see d3-drag#9. ³ Only applies immediately after some mouse-based gestures; see zoom.clickDistance. ⁴ Necessary to allow click emulation on touch input; see d3-drag#9. ⁵ Ignored if within 500ms of a touch gesture ending; assumes click emulation. ⁶ Double-click and double-tap initiate a transition that emits start, zoom and end events; see zoom.tapDistance. ⁷ The first wheel event emits a start event; an end event is emitted when no wheel events are received for 150ms. ⁸ Ignored if already at the corresponding limit of the scale extent.zoomTransform(node) ​Source · Returns the current transform for the specified node. Note that node should typically be a DOM element, not a selection. (A selection may consist of multiple nodes, in different states, and this function only returns a single transform.) If you have a selection, call selection.node first:jsvar transform = d3.zoomTransform(selection.node());In the context of an event listener, the node is typically the element that received the input event (which should be equal to event.transform), this:jsvar transform = d3.zoomTransform(this);Internally, an element’s transform is stored as element.__zoom; however, you should use this method rather than accessing it directly. If the given node has no defined transform, returns the transform of the closest ancestor, or if none exists, the identity transformation. The returned transform represents a two-dimensional transformation matrix of the form:k 0 tx0 k ty0 0 1(This matrix is capable of representing only scale and translation; a future release may also allow rotation, though this would probably not be a backwards-compatible change.) The position ⟨x,y⟩ is transformed to ⟨xk + tx,yk + ty⟩. The transform object exposes the following properties:transform.x - the translation amount tx along the x-axis.transform.y - the translation amount ty along the y-axis.transform.k - the scale factor k.These properties should be considered read-only; instead of mutating a transform, use transform.scale and transform.translate to derive a new transform. Also see zoom.scaleBy, zoom.scaleTo and zoom.translateBy for convenience methods on the zoom behavior. To create a transform with a given k, tx, and ty:jsvar t = d3.zoomIdentity.translate(x, y).scale(k);To apply the transformation to a Canvas 2D context, use context.translate followed by context.scale:jscontext.translate(transform.x, transform.y);
context.scale(transform.k, transform.k);Similarly, to apply the transformation to HTML elements via CSS:jsdiv.style("transform", "translate(" + transform.x + "px," + transform.y + "px) scale(" + transform.k + ")");
div.style("transform-origin", "0 0");To apply the transformation to SVG:jsg.attr("transform", "translate(" + transform.x + "," + transform.y + ") scale(" + transform.k + ")");Or more simply, taking advantage of transform.toString:jsg.attr("transform", transform);Note that the order of transformations matters! The translate must be applied before the scale.zoomIdentity ​Source · The identity transform, where k = 1, tx = ty = 0.new d3.ZoomTransform(k, x, y) ​Source · Returns a transform with scale k and translation (x, y).transform.scale(k) ​Source · Returns a transform whose scale k₁ is equal to k₀k, where k₀ is this transform’s scale.transform.translate(x, y) ​Source · Returns a transform whose translation tx1 and ty1 is equal to tx0 + tk x and ty0 + tk y, where tx0 and ty0 is this transform’s translation and tk is this transform’s scale.transform.apply(point) ​Source · Returns the transformation of the specified point which is a two-element array of numbers [x, y]. The returned point is equal to [xk + tx, yk + ty].transform.applyX(x) ​Source · Returns the transformation of the specified x-coordinate, xk + tx.transform.applyY(y) ​Source · Returns the transformation of the specified y coordinate, yk + ty.transform.invert(point) ​Source · Returns the inverse transformation of the specified point which is a two-element array of numbers [x, y]. The returned point is equal to [(x - tx) / k, (y - ty) / k].transform.invertX(x) ​Source · Returns the inverse transformation of the specified x-coordinate, (x - tx) / k.transform.invertY(y) ​Source · Returns the inverse transformation of the specified y coordinate, (y - ty) / k.transform.rescaleX(x) ​Source · Returns a copy of the continuous scale x whose domain is transformed. This is implemented by first applying the inverse x-transform on the scale’s range, and then applying the inverse scale to compute the corresponding domain:jsfunction rescaleX(x) {
  var range = x.range().map(transform.invertX, transform),
      domain = range.map(x.invert, x);
  return x.copy().domain(domain);
}The scale x must use interpolateNumber; do not use continuous.rangeRound as this reduces the accuracy of continuous.invert and can lead to an inaccurate rescaled domain. This method does not modify the input scale x; x thus represents the untransformed scale, while the returned scale represents its transformed view.transform.rescaleY(y) ​Source · Returns a copy of the continuous scale y whose domain is transformed. This is implemented by first applying the inverse y-transform on the scale’s range, and then applying the inverse scale to compute the corresponding domain:jsfunction rescaleY(y) {
  var range = y.range().map(transform.invertY, transform),
      domain = range.map(y.invert, y);
  return y.copy().domain(domain);
}The scale y must use interpolateNumber; do not use continuous.rangeRound as this reduces the accuracy of continuous.invert and can lead to an inaccurate rescaled domain. This method does not modify the input scale y; y thus represents the untransformed scale, while the returned scale represents its transformed view.transform.toString() ​Source · Returns a string representing the SVG transform corresponding to this transform. Implemented as:jsfunction toString() {
  return "translate(" + this.x + "," + this.y + ") scale(" + this.k + ")";
}PagerPrevious paged3-dragNext paged3-array\n\nd3-zoom ​Examples · Panning and zooming let the user focus on a region of interest by restricting the view. It uses direct manipulation: click-and-drag to pan (translate), spin the wheel to zoom (scale), or pinch with touch. Panning and zooming are widely used in web-based mapping, but can also be used in visualization such as dense time series and scatterplots.The zoom behavior is a flexible abstraction, handling a surprising variety of input modalities and browser quirks. The zoom behavior is agnostic about the DOM, so you can use it with HTML, SVG, or Canvas. You can use d3-zoom with d3-scale and d3-axis to zoom axes. You can restrict zooming using zoom.scaleExtent and panning using zoom.translateExtent. You can combine d3-zoom with other behaviors such as d3-drag for dragging and d3-brush for focus + context.The zoom behavior can be controlled programmatically using zoom.transform, allowing you to implement user interface controls which drive the display or to stage animated tours through your data. Smooth zoom transitions are based on “Smooth and efficient zooming and panning” by Jarke J. van Wijk and Wim A.A. Nuij.See also d3-tile for examples panning and zooming maps.zoom() ​Source · Creates a new zoom behavior. The returned behavior, zoom, is both an object and a function, and is typically applied to selected elements via selection.call.zoom(selection) ​Source · Applies this zoom behavior to the specified selection, binding the necessary event listeners to allow panning and zooming, and initializing the zoom transform on each selected element to the identity transform if not already defined.This function is typically not invoked directly, and is instead invoked via selection.call. For example, to instantiate a zoom behavior and apply it to a selection:jsselection.call(d3.zoom().on("zoom", zoomed));Internally, the zoom behavior uses selection.on to bind the necessary event listeners for zooming. The listeners use the name .zoom, so you can subsequently unbind the zoom behavior as follows:jsselection.on(".zoom", null);To disable just wheel-driven zooming (say to not interfere with native scrolling), you can remove the zoom behavior’s wheel event listener after applying the zoom behavior to the selection:jsselection
    .call(zoom)
    .on("wheel.zoom", null);Alternatively, use zoom.filter for greater control over which events can initiate zoom gestures.Applying the zoom behavior also sets the -webkit-tap-highlight-color style to transparent, disabling the tap highlight on iOS. If you want a different tap highlight color, remove or re-apply this style after applying the drag behavior.The zoom behavior stores the zoom state on the element to which the zoom behavior was applied, not on the zoom behavior itself. This allows the zoom behavior to be applied to many elements simultaneously with independent zooming. The zoom state can change either on user interaction or programmatically via zoom.transform.To retrieve the zoom state, use event.transform on the current zoom event within a zoom event listener (see zoom.on), or use zoomTransform for a given node. The latter is useful for modifying the zoom state programmatically, say to implement buttons for zooming in and out.zoom.transform(selection, transform, point) ​Source · If selection is a selection, sets the current zoom transform of the selected elements to the specified transform, instantaneously emitting start, zoom and end events.If selection is a transition, defines a “zoom” tween to the specified transform using interpolateZoom, emitting a start event when the transition starts, zoom events for each tick of the transition, and then an end event when the transition ends (or is interrupted). The transition will attempt to minimize the visual movement around the specified point; if the point is not specified, it defaults to the center of the viewport extent.The transform may be specified either as a zoom transform or as a function that returns a zoom transform; similarly, the point may be specified either as a two-element array [x, y] or a function that returns such an array. If a function, it is invoked for each selected element, being passed the current event (event) and datum d, with the this context as the current DOM element.This function is typically not invoked directly, and is instead invoked via selection.call or transition.call. For example, to reset the zoom transform to the identity transform instantaneously:jsselection.call(zoom.transform, d3.zoomIdentity);To smoothly reset the zoom transform to the identity transform over 750 milliseconds:jsselection.transition().duration(750).call(zoom.transform, d3.zoomIdentity);This method requires that you specify the new zoom transform completely, and does not enforce the defined scale extent and translate extent, if any. To derive a new transform from the existing transform, and to enforce the scale and translate extents, see the convenience methods zoom.translateBy, zoom.scaleBy and zoom.scaleTo.zoom.translateBy(selection, x, y) ​Source · If selection is a selection, translates the current zoom transform of the selected elements by x and y, such that the new tx1 = tx0 + kx and ty1 = ty0 + ky. If selection is a transition, defines a “zoom” tween translating the current transform. This method is a convenience method for zoom.transform. The x and y translation amounts may be specified either as numbers or as functions that return numbers. If a function, it is invoked for each selected element, being passed the current datum d and index i, with the this context as the current DOM element.zoom.translateTo(selection, x, y, p) ​Source · If selection is a selection, translates the current zoom transform of the selected elements such that the given position ⟨x,y⟩ appears at given point p. The new tx = px - kx and ty = py - ky. If p is not specified, it defaults to the center of the viewport extent. If selection is a transition, defines a “zoom” tween translating the current transform. This method is a convenience method for zoom.transform. The x and y coordinates may be specified either as numbers or as functions that returns numbers; similarly the p point may be specified either as a two-element array [px,py] or a function. If a function, it is invoked for each selected element, being passed the current datum d and index i, with the this context as the current DOM element.zoom.scaleBy(selection, k, p) ​Source · If selection is a selection, scales the current zoom transform of the selected elements by k, such that the new k₁ = k₀k. The reference point p does move. If p is not specified, it defaults to the center of the viewport extent. If selection is a transition, defines a “zoom” tween translating the current transform. This method is a convenience method for zoom.transform. The k scale factor may be specified either as a number or a function that returns a number; similarly the p point may be specified either as a two-element array [px,py] or a function. If a function, it is invoked for each selected element, being passed the current datum d and index i, with the this context as the current DOM element.zoom.scaleTo(selection, k, p) ​Source · If selection is a selection, scales the current zoom transform of the selected elements to k, such that the new k₁ = k. The reference point p does move. If p is not specified, it defaults to the center of the viewport extent. If selection is a transition, defines a “zoom” tween translating the current transform. This method is a convenience method for zoom.transform. The k scale factor may be specified either as a number or a function that returns a number; similarly the p point may be specified either as a two-element array [px,py] or a function. If a function, it is invoked for each selected element, being passed the current datum d and index i, with the this context as the current DOM element.zoom.constrain(constrain) ​Source · If constrain is specified, sets the transform constraint function to the specified function and returns the zoom behavior. If constrain is not specified, returns the current constraint function, which defaults to:jsfunction constrain(transform, extent, translateExtent) {
  var dx0 = transform.invertX(extent[0][0]) - translateExtent[0][0],
      dx1 = transform.invertX(extent[1][0]) - translateExtent[1][0],
      dy0 = transform.invertY(extent[0][1]) - translateExtent[0][1],
      dy1 = transform.invertY(extent[1][1]) - translateExtent[1][1];
  return transform.translate(
    dx1 > dx0 ? (dx0 + dx1) / 2 : Math.min(0, dx0) || Math.max(0, dx1),
    dy1 > dy0 ? (dy0 + dy1) / 2 : Math.min(0, dy0) || Math.max(0, dy1)
  );
}The constraint function must return a [transform]#zoomTransform) given the current transform, viewport extent and translate extent. The default implementation attempts to ensure that the viewport extent does not go outside the translate extent.zoom.filter(filter) ​Source · If filter is specified, sets the filter to the specified function and returns the zoom behavior. If filter is not specified, returns the current filter, which defaults to:jsfunction filter(event) {
  return (!event.ctrlKey || event.type === 'wheel') && !event.button;
}The filter is passed the current event (event) and datum d, with the this context as the current DOM element. If the filter returns falsey, the initiating event is ignored and no zoom gestures are started. Thus, the filter determines which input events are ignored. The default filter ignores mousedown events on secondary buttons, since those buttons are typically intended for other purposes, such as the context menu.zoom.touchable(touchable) ​Source · If touchable is specified, sets the touch support detector to the specified function and returns the zoom behavior. If touchable is not specified, returns the current touch support detector, which defaults to:jsfunction touchable() {
  return navigator.maxTouchPoints || ("ontouchstart" in this);
}Touch event listeners are only registered if the detector returns truthy for the corresponding element when the zoom behavior is applied. The default detector works well for most browsers that are capable of touch input, but not all; Chrome’s mobile device emulator, for example, fails detection.zoom.wheelDelta(delta) ​Source · If delta is specified, sets the wheel delta function to the specified function and returns the zoom behavior. If delta is not specified, returns the current wheel delta function, which defaults to:jsfunction wheelDelta(event) {
  return -event.deltaY * (event.deltaMode === 1 ? 0.05 : event.deltaMode ? 1 : 0.002) * (event.ctrlKey ? 10 : 1);
}The value Δ returned by the wheel delta function determines the amount of scaling applied in response to a WheelEvent. The scale factor transform.k is multiplied by 2Δ; for example, a Δ of +1 doubles the scale factor, Δ of -1 halves the scale factor.zoom.extent(extent) ​Source · If extent is specified, sets the viewport extent to the specified array of points [[x0, y0], [x1, y1]], where [x0, y0] is the top-left corner of the viewport and [x1, y1] is the bottom-right corner of the viewport, and returns this zoom behavior. The extent may also be specified as a function which returns such an array; if a function, it is invoked for each selected element, being passed the current datum d, with the this context as the current DOM element.If extent is not specified, returns the current extent accessor, which defaults to [[0, 0], [width, height]] where width is the client width of the element and height is its client height; for SVG elements, the nearest ancestor SVG element’s viewBox, or width and height attributes, are used. Alternatively, consider using element.getBoundingClientRect.The viewport extent affects several functions: the center of the viewport remains fixed during changes by zoom.scaleBy and zoom.scaleTo; the viewport center and dimensions affect the path chosen by interpolateZoom; and the viewport extent is needed to enforce the optional translate extent.zoom.scaleExtent(extent) ​Source · If extent is specified, sets the scale extent to the specified array of numbers [k0, k1] where k0 is the minimum allowed scale factor and k1 is the maximum allowed scale factor, and returns this zoom behavior. If extent is not specified, returns the current scale extent, which defaults to [0, ∞]. The scale extent restricts zooming in and out. It is enforced on interaction and when using zoom.scaleBy, zoom.scaleTo and zoom.translateBy; however, it is not enforced when using zoom.transform to set the transform explicitly.If the user tries to zoom by wheeling when already at the corresponding limit of the scale extent, the wheel events will be ignored and not initiate a zoom gesture. This allows the user to scroll down past a zoomable area after zooming in, or to scroll up after zooming out. If you would prefer to always prevent scrolling on wheel input regardless of the scale extent, register a wheel event listener to prevent the browser default behavior:jsselection
    .call(zoom)
    .on("wheel", event => event.preventDefault());zoom.translateExtent(extent) ​Source · If extent is specified, sets the translate extent to the specified array of points [[x0, y0], [x1, y1]], where [x0, y0] is the top-left corner of the world and [x1, y1] is the bottom-right corner of the world, and returns this zoom behavior. If extent is not specified, returns the current translate extent, which defaults to [[-∞, -∞], [+∞, +∞]]. The translate extent restricts panning, and may cause translation on zoom out. It is enforced on interaction and when using zoom.scaleBy, zoom.scaleTo and zoom.translateBy; however, it is not enforced when using zoom.transform to set the transform explicitly.zoom.clickDistance(distance) ​Source · If distance is specified, sets the maximum distance that the mouse can move between mousedown and mouseup that will trigger a subsequent click event. If at any point between mousedown and mouseup the mouse is greater than or equal to distance from its position on mousedown, the click event following mouseup will be suppressed. If distance is not specified, returns the current distance threshold, which defaults to zero. The distance threshold is measured in client coordinates (event.clientX and event.clientY).zoom.tapDistance(distance) ​Source · If distance is specified, sets the maximum distance that a double-tap gesture can move between first touchstart and second touchend that will trigger a subsequent double-click event. If distance is not specified, returns the current distance threshold, which defaults to 10. The distance threshold is measured in client coordinates (event.clientX and event.clientY).zoom.duration(duration) ​Source · If duration is specified, sets the duration for zoom transitions on double-click and double-tap to the specified number of milliseconds and returns the zoom behavior. If duration is not specified, returns the current duration, which defaults to 250 milliseconds. If the duration is not greater than zero, double-click and -tap trigger instantaneous changes to the zoom transform rather than initiating smooth transitions.To disable double-click and double-tap transitions, you can remove the zoom behavior’s dblclick event listener after applying the zoom behavior to the selection:jsselection
    .call(zoom)
    .on("dblclick.zoom", null);zoom.interpolate(interpolate) ​Source · If interpolate is specified, sets the interpolation factory for zoom transitions to the specified function. If interpolate is not specified, returns the current interpolation factory, which defaults to interpolateZoom to implement smooth zooming. To apply direct interpolation between two views, try interpolate instead.zoom.on(typenames, listener) ​Source · If listener is specified, sets the event listener for the specified typenames and returns the zoom behavior. If an event listener was already registered for the same type and name, the existing listener is removed before the new listener is added. If listener is null, removes the current event listeners for the specified typenames, if any. If listener is not specified, returns the first currently-assigned listener matching the specified typenames, if any. When a specified event is dispatched, each listener will be invoked with the same context and arguments as selection.on listeners: the current event (event) and datum d, with the this context as the current DOM element.The typenames is a string containing one or more typename separated by whitespace. Each typename is a type, optionally followed by a period (.) and a name, such as zoom.foo and zoom.bar; the name allows multiple listeners to be registered for the same type. The type must be one of the following:start - after zooming begins (such as on mousedown).zoom - after a change to the zoom transform (such as on mousemove).end - after zooming ends (such as on mouseup ).See dispatch.on for more.Zoom events ​When a zoom event listener is invoked, it receives the current zoom event as a first argument. The event object exposes several fields:event.target - the associated zoom behavior.event.type - the string “start”, “zoom” or “end”; see zoom.on.event.transform - the current zoom transform.event.sourceEvent - the underlying input event, such as mousemove or touchmove.The zoom behavior handles a variety of interaction events:EventListening ElementZoom EventDefault Prevented?mousedown⁵selectionstartno¹mousemove²window¹zoomyesmouseup²window¹endyesdragstart²window-yesselectstart²window-yesclick³window-yesdblclickselectionmultiple⁶yeswheel⁸selectionzoom⁷yestouchstartselectionmultiple⁶no⁴touchmoveselectionzoomyestouchendselectionendno⁴touchcancelselectionendno⁴The propagation of all consumed events is immediately stopped.¹ Necessary to capture events outside an iframe; see d3-drag#9. ² Only applies during an active, mouse-based gesture; see d3-drag#9. ³ Only applies immediately after some mouse-based gestures; see zoom.clickDistance. ⁴ Necessary to allow click emulation on touch input; see d3-drag#9. ⁵ Ignored if within 500ms of a touch gesture ending; assumes click emulation. ⁶ Double-click and double-tap initiate a transition that emits start, zoom and end events; see zoom.tapDistance. ⁷ The first wheel event emits a start event; an end event is emitted when no wheel events are received for 150ms. ⁸ Ignored if already at the corresponding limit of the scale extent.zoomTransform(node) ​Source · Returns the current transform for the specified node. Note that node should typically be a DOM element, not a selection. (A selection may consist of multiple nodes, in different states, and this function only returns a single transform.) If you have a selection, call selection.node first:jsvar transform = d3.zoomTransform(selection.node());In the context of an event listener, the node is typically the element that received the input event (which should be equal to event.transform), this:jsvar transform = d3.zoomTransform(this);Internally, an element’s transform is stored as element.__zoom; however, you should use this method rather than accessing it directly. If the given node has no defined transform, returns the transform of the closest ancestor, or if none exists, the identity transformation. The returned transform represents a two-dimensional transformation matrix of the form:k 0 tx0 k ty0 0 1(This matrix is capable of representing only scale and translation; a future release may also allow rotation, though this would probably not be a backwards-compatible change.) The position ⟨x,y⟩ is transformed to ⟨xk + tx,yk + ty⟩. The transform object exposes the following properties:transform.x - the translation amount tx along the x-axis.transform.y - the translation amount ty along the y-axis.transform.k - the scale factor k.These properties should be considered read-only; instead of mutating a transform, use transform.scale and transform.translate to derive a new transform. Also see zoom.scaleBy, zoom.scaleTo and zoom.translateBy for convenience methods on the zoom behavior. To create a transform with a given k, tx, and ty:jsvar t = d3.zoomIdentity.translate(x, y).scale(k);To apply the transformation to a Canvas 2D context, use context.translate followed by context.scale:jscontext.translate(transform.x, transform.y);
context.scale(transform.k, transform.k);Similarly, to apply the transformation to HTML elements via CSS:jsdiv.style("transform", "translate(" + transform.x + "px," + transform.y + "px) scale(" + transform.k + ")");
div.style("transform-origin", "0 0");To apply the transformation to SVG:jsg.attr("transform", "translate(" + transform.x + "," + transform.y + ") scale(" + transform.k + ")");Or more simply, taking advantage of transform.toString:jsg.attr("transform", transform);Note that the order of transformations matters! The translate must be applied before the scale.zoomIdentity ​Source · The identity transform, where k = 1, tx = ty = 0.new d3.ZoomTransform(k, x, y) ​Source · Returns a transform with scale k and translation (x, y).transform.scale(k) ​Source · Returns a transform whose scale k₁ is equal to k₀k, where k₀ is this transform’s scale.transform.translate(x, y) ​Source · Returns a transform whose translation tx1 and ty1 is equal to tx0 + tk x and ty0 + tk y, where tx0 and ty0 is this transform’s translation and tk is this transform’s scale.transform.apply(point) ​Source · Returns the transformation of the specified point which is a two-element array of numbers [x, y]. The returned point is equal to [xk + tx, yk + ty].transform.applyX(x) ​Source · Returns the transformation of the specified x-coordinate, xk + tx.transform.applyY(y) ​Source · Returns the transformation of the specified y coordinate, yk + ty.transform.invert(point) ​Source · Returns the inverse transformation of the specified point which is a two-element array of numbers [x, y]. The returned point is equal to [(x - tx) / k, (y - ty) / k].transform.invertX(x) ​Source · Returns the inverse transformation of the specified x-coordinate, (x - tx) / k.transform.invertY(y) ​Source · Returns the inverse transformation of the specified y coordinate, (y - ty) / k.transform.rescaleX(x) ​Source · Returns a copy of the continuous scale x whose domain is transformed. This is implemented by first applying the inverse x-transform on the scale’s range, and then applying the inverse scale to compute the corresponding domain:jsfunction rescaleX(x) {
  var range = x.range().map(transform.invertX, transform),
      domain = range.map(x.invert, x);
  return x.copy().domain(domain);
}The scale x must use interpolateNumber; do not use continuous.rangeRound as this reduces the accuracy of continuous.invert and can lead to an inaccurate rescaled domain. This method does not modify the input scale x; x thus represents the untransformed scale, while the returned scale represents its transformed view.transform.rescaleY(y) ​Source · Returns a copy of the continuous scale y whose domain is transformed. This is implemented by first applying the inverse y-transform on the scale’s range, and then applying the inverse scale to compute the corresponding domain:jsfunction rescaleY(y) {
  var range = y.range().map(transform.invertY, transform),
      domain = range.map(y.invert, y);
  return y.copy().domain(domain);
}The scale y must use interpolateNumber; do not use continuous.rangeRound as this reduces the accuracy of continuous.invert and can lead to an inaccurate rescaled domain. This method does not modify the input scale y; y thus represents the untransformed scale, while the returned scale represents its transformed view.transform.toString() ​Source · Returns a string representing the SVG transform corresponding to this transform. Implemented as:jsfunction toString() {
  return "translate(" + this.x + "," + this.y + ") scale(" + this.k + ")";
}\n\n\n\nAdding numbers ​Add floating point numbers with full precision.new Adder() ​jsconst adder = new d3.Adder();Examples · Source · Creates a new adder with an initial value of 0.adder.add(number) ​jsadder.add(42)Adds the specified number to the adder’s current value and returns the adder.adder.valueOf() ​jsadder.valueOf() // 42Returns the IEEE 754 double-precision representation of the adder’s current value. Most useful as the short-hand notation +adder, or when coercing as Number(adder).fsum(values, accessor) ​jsd3.fsum([0.1, 0.1, 0.1, 0.1, 0.1, 0.1, 0.1, 0.1, 0.1, 0.1]) // 1Examples · Source · Returns a full-precision summation of the given values. Although slower, d3.fsum can replace d3.sum wherever greater precision is needed.jsd3.fsum(penguins, (d) => d.body_mass_g) // 1437000If an accessor is specified, invokes the given function for each element in the input values, being passed the element d, the index i, and the array data as three arguments; the returned values will then be added.fcumsum(values, accessor) ​jsd3.fcumsum([1, 1e-14, -1]) // [1, 1.00000000000001, 1e-14]Examples · Source · Returns a full-precision cumulative sum of the given values as a Float64Array. Although slower, d3.fcumsum can replace d3.cumsum when greater precision is needed.jsd3.fcumsum(penguins, (d) => d.body_mass_g) // [3750, 7550, 10800, 10800, 14250, …]If an accessor is specified, invokes the given function for each element in the input values, being passed the element d, the index i, and the array data as three arguments; the returned values will then be added.\n\nSearchK7.9.0GitHub️ 110.0kOn this pageAdding numbers ​Add floating point numbers with full precision.new Adder() ​jsconst adder = new d3.Adder();Examples · Source · Creates a new adder with an initial value of 0.adder.add(number) ​jsadder.add(42)Adds the specified number to the adder’s current value and returns the adder.adder.valueOf() ​jsadder.valueOf() // 42Returns the IEEE 754 double-precision representation of the adder’s current value. Most useful as the short-hand notation +adder, or when coercing as Number(adder).fsum(values, accessor) ​jsd3.fsum([0.1, 0.1, 0.1, 0.1, 0.1, 0.1, 0.1, 0.1, 0.1, 0.1]) // 1Examples · Source · Returns a full-precision summation of the given values. Although slower, d3.fsum can replace d3.sum wherever greater precision is needed.jsd3.fsum(penguins, (d) => d.body_mass_g) // 1437000If an accessor is specified, invokes the given function for each element in the input values, being passed the element d, the index i, and the array data as three arguments; the returned values will then be added.fcumsum(values, accessor) ​jsd3.fcumsum([1, 1e-14, -1]) // [1, 1.00000000000001, 1e-14]Examples · Source · Returns a full-precision cumulative sum of the given values as a Float64Array. Although slower, d3.fcumsum can replace d3.cumsum when greater precision is needed.jsd3.fcumsum(penguins, (d) => d.body_mass_g) // [3750, 7550, 10800, 10800, 14250, …]If an accessor is specified, invokes the given function for each element in the input values, being passed the element d, the index i, and the array data as three arguments; the returned values will then be added.PagerPrevious paged3-arrayNext pageBinning data\n\nAdding numbers ​Add floating point numbers with full precision.new Adder() ​jsconst adder = new d3.Adder();Examples · Source · Creates a new adder with an initial value of 0.adder.add(number) ​jsadder.add(42)Adds the specified number to the adder’s current value and returns the adder.adder.valueOf() ​jsadder.valueOf() // 42Returns the IEEE 754 double-precision representation of the adder’s current value. Most useful as the short-hand notation +adder, or when coercing as Number(adder).fsum(values, accessor) ​jsd3.fsum([0.1, 0.1, 0.1, 0.1, 0.1, 0.1, 0.1, 0.1, 0.1, 0.1]) // 1Examples · Source · Returns a full-precision summation of the given values. Although slower, d3.fsum can replace d3.sum wherever greater precision is needed.jsd3.fsum(penguins, (d) => d.body_mass_g) // 1437000If an accessor is specified, invokes the given function for each element in the input values, being passed the element d, the index i, and the array data as three arguments; the returned values will then be added.fcumsum(values, accessor) ​jsd3.fcumsum([1, 1e-14, -1]) // [1, 1.00000000000001, 1e-14]Examples · Source · Returns a full-precision cumulative sum of the given values as a Float64Array. Although slower, d3.fcumsum can replace d3.cumsum when greater precision is needed.jsd3.fcumsum(penguins, (d) => d.body_mass_g) // [3750, 7550, 10800, 10800, 14250, …]If an accessor is specified, invokes the given function for each element in the input values, being passed the element d, the index i, and the array data as three arguments; the returned values will then be added.\n\n\n\nBinning data ​Bin quantitative values into consecutive, non-overlapping intervals, as in histograms. (See also Observable Plot’s bin transform.)bin() ​jsconst bin = d3.bin().value((d) => d.culmen_length_mm);Examples · Source · Constructs a new bin generator with the default settings. The returned bin generator supports method chaining, so this constructor is typically chained with bin.value to assign a value accessor. The returned generator is also a function; pass it data to bin.bin(data) ​jsconst bins = d3.bin().value((d) => d.culmen_length_mm)(penguins);Bins the given iterable of data samples. Returns an array of bins, where each bin is an array containing the associated elements from the input data. Thus, the length of the bin is the number of elements in that bin. Each bin has two additional attributes:x0 - the lower bound of the bin (inclusive).x1 - the upper bound of the bin (exclusive, except for the last bin).Any null or non-comparable values in the given data, or those outside the domain, are ignored.bin.value(value) ​jsconst bin = d3.bin().value((d) => d.culmen_length_mm);If value is specified, sets the value accessor to the specified function or constant and returns this bin generator.jsbin.value() // (d) => d.culmen_length_mmIf value is not specified, returns the current value accessor, which defaults to the identity function.When bins are generated, the value accessor will be invoked for each element in the input data array, being passed the element d, the index i, and the array data as three arguments. The default value accessor assumes that the input data are orderable (comparable), such as numbers or dates. If your data are not, then you should specify an accessor that returns the corresponding orderable value for a given datum.This is similar to mapping your data to values before invoking the bin generator, but has the benefit that the input data remains associated with the returned bins, thereby making it easier to access other fields of the data.bin.domain(domain) ​jsconst bin = d3.bin().domain([0, 1]);If domain is specified, sets the domain accessor to the specified function or array and returns this bin generator.jsbin.domain() // [0, 1]If domain is not specified, returns the current domain accessor, which defaults to extent. The bin domain is defined as an array [min, max], where min is the minimum observable value and max is the maximum observable value; both values are inclusive. Any value outside of this domain will be ignored when the bins are generated.For example, to use a bin generator with a linear scale x, you might say:jsconst bin = d3.bin().domain(x.domain()).thresholds(x.ticks(20));You can then compute the bins from an array of numbers like so:jsconst bins = bin(numbers);If the default extent domain is used and the thresholds are specified as a count (rather than explicit values), then the computed domain will be niced such that all bins are uniform width.Note that the domain accessor is invoked on the materialized array of values, not on the input data array.bin.thresholds(thresholds) ​jsconst bin = d3.bin().thresholds(20);If thresholds is specified as a number, then the domain will be uniformly divided into approximately that many bins; see ticks.jsconst bin = d3.bin().thresholds([0.25, 0.5, 0.75]);If thresholds is specified as an array, sets the thresholds to the specified values and returns this bin generator. Thresholds are defined as an array of values [x0, x1, …]. Any value less than x0 will be placed in the first bin; any value greater than or equal to x0 but less than x1 will be placed in the second bin; and so on. Thus, the generated bins will have thresholds.length + 1 bins. Any threshold values outside the domain are ignored. The first bin.x0 is always equal to the minimum domain value, and the last bin.x1 is always equal to the maximum domain value.jsconst bin = d3.bin().thresholds((values) => [d3.median(values)]);If thresholds is specified as a function, the function will be passed three arguments: the array of input values derived from the data, and the domain represented as min and max. The function may then return either the array of numeric thresholds or the count of bins; in the latter case the domain is divided uniformly into approximately count bins; see ticks. For instance, you might want to use time ticks when binning time-series data; see example.jsbin.thresholds() // () => [0, 0.5, 1]If thresholds is not specified, returns the current threshold generator, which by default implements Sturges’ formula. (Thus by default, the values to be binned must be numbers!)thresholdFreedmanDiaconis(values, min, max) ​jsconst bin = d3.bin().thresholds(d3.thresholdFreedmanDiaconis);Source · Returns the number of bins according to the Freedman–Diaconis rule; the input values must be numbers.thresholdScott(values, min, max) ​jsconst bin = d3.bin().thresholds(d3.thresholdScott);Source · Returns the number of bins according to Scott’s normal reference rule; the input values must be numbers.thresholdSturges(values, min, max) ​jsconst bin = d3.bin().thresholds(d3.thresholdSturges);Source · Returns the number of bins according to Sturges’ formula; the input values must be numbers.\n\nSearchK7.9.0GitHub️ 110.0kOn this pageBinning data ​Bin quantitative values into consecutive, non-overlapping intervals, as in histograms. (See also Observable Plot’s bin transform.)bin() ​jsconst bin = d3.bin().value((d) => d.culmen_length_mm);Examples · Source · Constructs a new bin generator with the default settings. The returned bin generator supports method chaining, so this constructor is typically chained with bin.value to assign a value accessor. The returned generator is also a function; pass it data to bin.bin(data) ​jsconst bins = d3.bin().value((d) => d.culmen_length_mm)(penguins);Bins the given iterable of data samples. Returns an array of bins, where each bin is an array containing the associated elements from the input data. Thus, the length of the bin is the number of elements in that bin. Each bin has two additional attributes:x0 - the lower bound of the bin (inclusive).x1 - the upper bound of the bin (exclusive, except for the last bin).Any null or non-comparable values in the given data, or those outside the domain, are ignored.bin.value(value) ​jsconst bin = d3.bin().value((d) => d.culmen_length_mm);If value is specified, sets the value accessor to the specified function or constant and returns this bin generator.jsbin.value() // (d) => d.culmen_length_mmIf value is not specified, returns the current value accessor, which defaults to the identity function.When bins are generated, the value accessor will be invoked for each element in the input data array, being passed the element d, the index i, and the array data as three arguments. The default value accessor assumes that the input data are orderable (comparable), such as numbers or dates. If your data are not, then you should specify an accessor that returns the corresponding orderable value for a given datum.This is similar to mapping your data to values before invoking the bin generator, but has the benefit that the input data remains associated with the returned bins, thereby making it easier to access other fields of the data.bin.domain(domain) ​jsconst bin = d3.bin().domain([0, 1]);If domain is specified, sets the domain accessor to the specified function or array and returns this bin generator.jsbin.domain() // [0, 1]If domain is not specified, returns the current domain accessor, which defaults to extent. The bin domain is defined as an array [min, max], where min is the minimum observable value and max is the maximum observable value; both values are inclusive. Any value outside of this domain will be ignored when the bins are generated.For example, to use a bin generator with a linear scale x, you might say:jsconst bin = d3.bin().domain(x.domain()).thresholds(x.ticks(20));You can then compute the bins from an array of numbers like so:jsconst bins = bin(numbers);If the default extent domain is used and the thresholds are specified as a count (rather than explicit values), then the computed domain will be niced such that all bins are uniform width.Note that the domain accessor is invoked on the materialized array of values, not on the input data array.bin.thresholds(thresholds) ​jsconst bin = d3.bin().thresholds(20);If thresholds is specified as a number, then the domain will be uniformly divided into approximately that many bins; see ticks.jsconst bin = d3.bin().thresholds([0.25, 0.5, 0.75]);If thresholds is specified as an array, sets the thresholds to the specified values and returns this bin generator. Thresholds are defined as an array of values [x0, x1, …]. Any value less than x0 will be placed in the first bin; any value greater than or equal to x0 but less than x1 will be placed in the second bin; and so on. Thus, the generated bins will have thresholds.length + 1 bins. Any threshold values outside the domain are ignored. The first bin.x0 is always equal to the minimum domain value, and the last bin.x1 is always equal to the maximum domain value.jsconst bin = d3.bin().thresholds((values) => [d3.median(values)]);If thresholds is specified as a function, the function will be passed three arguments: the array of input values derived from the data, and the domain represented as min and max. The function may then return either the array of numeric thresholds or the count of bins; in the latter case the domain is divided uniformly into approximately count bins; see ticks. For instance, you might want to use time ticks when binning time-series data; see example.jsbin.thresholds() // () => [0, 0.5, 1]If thresholds is not specified, returns the current threshold generator, which by default implements Sturges’ formula. (Thus by default, the values to be binned must be numbers!)thresholdFreedmanDiaconis(values, min, max) ​jsconst bin = d3.bin().thresholds(d3.thresholdFreedmanDiaconis);Source · Returns the number of bins according to the Freedman–Diaconis rule; the input values must be numbers.thresholdScott(values, min, max) ​jsconst bin = d3.bin().thresholds(d3.thresholdScott);Source · Returns the number of bins according to Scott’s normal reference rule; the input values must be numbers.thresholdSturges(values, min, max) ​jsconst bin = d3.bin().thresholds(d3.thresholdSturges);Source · Returns the number of bins according to Sturges’ formula; the input values must be numbers.PagerPrevious pageAdding numbersNext pageBisecting data\n\nBinning data ​Bin quantitative values into consecutive, non-overlapping intervals, as in histograms. (See also Observable Plot’s bin transform.)bin() ​jsconst bin = d3.bin().value((d) => d.culmen_length_mm);Examples · Source · Constructs a new bin generator with the default settings. The returned bin generator supports method chaining, so this constructor is typically chained with bin.value to assign a value accessor. The returned generator is also a function; pass it data to bin.bin(data) ​jsconst bins = d3.bin().value((d) => d.culmen_length_mm)(penguins);Bins the given iterable of data samples. Returns an array of bins, where each bin is an array containing the associated elements from the input data. Thus, the length of the bin is the number of elements in that bin. Each bin has two additional attributes:x0 - the lower bound of the bin (inclusive).x1 - the upper bound of the bin (exclusive, except for the last bin).Any null or non-comparable values in the given data, or those outside the domain, are ignored.bin.value(value) ​jsconst bin = d3.bin().value((d) => d.culmen_length_mm);If value is specified, sets the value accessor to the specified function or constant and returns this bin generator.jsbin.value() // (d) => d.culmen_length_mmIf value is not specified, returns the current value accessor, which defaults to the identity function.When bins are generated, the value accessor will be invoked for each element in the input data array, being passed the element d, the index i, and the array data as three arguments. The default value accessor assumes that the input data are orderable (comparable), such as numbers or dates. If your data are not, then you should specify an accessor that returns the corresponding orderable value for a given datum.This is similar to mapping your data to values before invoking the bin generator, but has the benefit that the input data remains associated with the returned bins, thereby making it easier to access other fields of the data.bin.domain(domain) ​jsconst bin = d3.bin().domain([0, 1]);If domain is specified, sets the domain accessor to the specified function or array and returns this bin generator.jsbin.domain() // [0, 1]If domain is not specified, returns the current domain accessor, which defaults to extent. The bin domain is defined as an array [min, max], where min is the minimum observable value and max is the maximum observable value; both values are inclusive. Any value outside of this domain will be ignored when the bins are generated.For example, to use a bin generator with a linear scale x, you might say:jsconst bin = d3.bin().domain(x.domain()).thresholds(x.ticks(20));You can then compute the bins from an array of numbers like so:jsconst bins = bin(numbers);If the default extent domain is used and the thresholds are specified as a count (rather than explicit values), then the computed domain will be niced such that all bins are uniform width.Note that the domain accessor is invoked on the materialized array of values, not on the input data array.bin.thresholds(thresholds) ​jsconst bin = d3.bin().thresholds(20);If thresholds is specified as a number, then the domain will be uniformly divided into approximately that many bins; see ticks.jsconst bin = d3.bin().thresholds([0.25, 0.5, 0.75]);If thresholds is specified as an array, sets the thresholds to the specified values and returns this bin generator. Thresholds are defined as an array of values [x0, x1, …]. Any value less than x0 will be placed in the first bin; any value greater than or equal to x0 but less than x1 will be placed in the second bin; and so on. Thus, the generated bins will have thresholds.length + 1 bins. Any threshold values outside the domain are ignored. The first bin.x0 is always equal to the minimum domain value, and the last bin.x1 is always equal to the maximum domain value.jsconst bin = d3.bin().thresholds((values) => [d3.median(values)]);If thresholds is specified as a function, the function will be passed three arguments: the array of input values derived from the data, and the domain represented as min and max. The function may then return either the array of numeric thresholds or the count of bins; in the latter case the domain is divided uniformly into approximately count bins; see ticks. For instance, you might want to use time ticks when binning time-series data; see example.jsbin.thresholds() // () => [0, 0.5, 1]If thresholds is not specified, returns the current threshold generator, which by default implements Sturges’ formula. (Thus by default, the values to be binned must be numbers!)thresholdFreedmanDiaconis(values, min, max) ​jsconst bin = d3.bin().thresholds(d3.thresholdFreedmanDiaconis);Source · Returns the number of bins according to the Freedman–Diaconis rule; the input values must be numbers.thresholdScott(values, min, max) ​jsconst bin = d3.bin().thresholds(d3.thresholdScott);Source · Returns the number of bins according to Scott’s normal reference rule; the input values must be numbers.thresholdSturges(values, min, max) ​jsconst bin = d3.bin().thresholds(d3.thresholdSturges);Source · Returns the number of bins according to Sturges’ formula; the input values must be numbers.\n\n\n\nBisecting data ​Bisection, or binary search, quickly finds a given value in a sorted array. It is often used to find the position at which to insert a new value into an array while maintaining sorted order.bisector(accessor) ​Examples · Source · Returns a new bisector using the specified accessor function.jsconst bisector = d3.bisector((d) => d.Date);If the given accessor takes two arguments, it is interpreted as a comparator function for comparing an element d in the data with a search value x. Use a comparator rather than an accessor if you want values to be sorted in an order different than natural order, such as in descending rather than ascending order. The above is equivalent to:jsconst bisector = d3.bisector((d, x) => d.Date - x);The bisector can be used to bisect sorted arrays of objects (in contrast to bisect, which is for bisecting primitives).bisector.right(array, x, lo, hi) ​jsd3.bisector((d) => d.Date).right(aapl, new Date("2014-01-02")) // 163Like bisectRight, but using this bisector’s accessor. The code above finds the index of the row immediately following Jan. 2, 2014 in the aapl sample dataset.bisector.left(array, x, lo, hi) ​jsd3.bisector((d) => d.Date).left(aapl, new Date("2014-01-02")) // 162Like bisectLeft, but using this bisector’s accessor. The code above finds the index of the row for Jan. 2, 2014 in the aapl sample dataset.bisector.center(array, x, lo, hi) ​jsd3.bisector((d) => d.Date).center(aapl, new Date("2013-12-31")) // 161Returns the index of the closest value to x in the given sorted array. This expects that the bisector’s accessor returns a quantitative value, or that the bisector’s comparator returns a signed distance; otherwise, this method is equivalent to bisector.left. The arguments lo (inclusive) and hi (exclusive) may be used to specify a subset of the array which should be considered; by default the entire array is used.bisect(array, x, lo, hi) ​jsd3.bisect(aapl.map((d) => d.Date), new Date("2014-01-02")) // 163Alias for bisectRight.bisectRight(array, x, lo, hi) ​jsd3.bisectRight(aapl.map((d) => d.Date), new Date("2014-01-02")) // 163Like bisectLeft, but returns an insertion point which comes after (to the right of) any existing entries equivalent to x in array. The returned insertion point i partitions the array into two halves so that all v <= x for v in array.slice(lo, i) for the left side and all v > x for v in array.slice(i, hi) for the right side. See also bisector.right.bisectLeft(array, x, lo, hi) ​jsd3.bisectLeft(aapl.map((d) => d.Date), new Date("2014-01-02")) // 162Returns the insertion point for x in array to maintain sorted order. The arguments lo and hi may be used to specify a subset of the array which should be considered; by default the entire array is used. If x is already present in array, the insertion point will be before (to the left of) any existing entries. The return value is suitable for use as the first argument to array.splice assuming that array is already sorted. The returned insertion point i partitions the array into two halves so that all v < x for v in array.slice(lo, i) for the left side and all v >= x for v in array.slice(i, hi) for the right side. See also bisector.left.bisectCenter(array, x, lo, hi) ​jsd3.bisectCenter(aapl.map((d) => d.Date), new Date("2013-12-31")) // 161Returns the index of the value closest to x in the given array of numbers. The arguments lo (inclusive) and hi (exclusive) may be used to specify a subset of the array which should be considered; by default the entire array is used. See also bisector.center.\n\nSearchK7.9.0GitHub️ 110.0kOn this pageBisecting data ​Bisection, or binary search, quickly finds a given value in a sorted array. It is often used to find the position at which to insert a new value into an array while maintaining sorted order.bisector(accessor) ​Examples · Source · Returns a new bisector using the specified accessor function.jsconst bisector = d3.bisector((d) => d.Date);If the given accessor takes two arguments, it is interpreted as a comparator function for comparing an element d in the data with a search value x. Use a comparator rather than an accessor if you want values to be sorted in an order different than natural order, such as in descending rather than ascending order. The above is equivalent to:jsconst bisector = d3.bisector((d, x) => d.Date - x);The bisector can be used to bisect sorted arrays of objects (in contrast to bisect, which is for bisecting primitives).bisector.right(array, x, lo, hi) ​jsd3.bisector((d) => d.Date).right(aapl, new Date("2014-01-02")) // 163Like bisectRight, but using this bisector’s accessor. The code above finds the index of the row immediately following Jan. 2, 2014 in the aapl sample dataset.bisector.left(array, x, lo, hi) ​jsd3.bisector((d) => d.Date).left(aapl, new Date("2014-01-02")) // 162Like bisectLeft, but using this bisector’s accessor. The code above finds the index of the row for Jan. 2, 2014 in the aapl sample dataset.bisector.center(array, x, lo, hi) ​jsd3.bisector((d) => d.Date).center(aapl, new Date("2013-12-31")) // 161Returns the index of the closest value to x in the given sorted array. This expects that the bisector’s accessor returns a quantitative value, or that the bisector’s comparator returns a signed distance; otherwise, this method is equivalent to bisector.left. The arguments lo (inclusive) and hi (exclusive) may be used to specify a subset of the array which should be considered; by default the entire array is used.bisect(array, x, lo, hi) ​jsd3.bisect(aapl.map((d) => d.Date), new Date("2014-01-02")) // 163Alias for bisectRight.bisectRight(array, x, lo, hi) ​jsd3.bisectRight(aapl.map((d) => d.Date), new Date("2014-01-02")) // 163Like bisectLeft, but returns an insertion point which comes after (to the right of) any existing entries equivalent to x in array. The returned insertion point i partitions the array into two halves so that all v <= x for v in array.slice(lo, i) for the left side and all v > x for v in array.slice(i, hi) for the right side. See also bisector.right.bisectLeft(array, x, lo, hi) ​jsd3.bisectLeft(aapl.map((d) => d.Date), new Date("2014-01-02")) // 162Returns the insertion point for x in array to maintain sorted order. The arguments lo and hi may be used to specify a subset of the array which should be considered; by default the entire array is used. If x is already present in array, the insertion point will be before (to the left of) any existing entries. The return value is suitable for use as the first argument to array.splice assuming that array is already sorted. The returned insertion point i partitions the array into two halves so that all v < x for v in array.slice(lo, i) for the left side and all v >= x for v in array.slice(i, hi) for the right side. See also bisector.left.bisectCenter(array, x, lo, hi) ​jsd3.bisectCenter(aapl.map((d) => d.Date), new Date("2013-12-31")) // 161Returns the index of the value closest to x in the given array of numbers. The arguments lo (inclusive) and hi (exclusive) may be used to specify a subset of the array which should be considered; by default the entire array is used. See also bisector.center.PagerPrevious pageBinning dataNext pageBlurring data\n\nBisecting data ​Bisection, or binary search, quickly finds a given value in a sorted array. It is often used to find the position at which to insert a new value into an array while maintaining sorted order.bisector(accessor) ​Examples · Source · Returns a new bisector using the specified accessor function.jsconst bisector = d3.bisector((d) => d.Date);If the given accessor takes two arguments, it is interpreted as a comparator function for comparing an element d in the data with a search value x. Use a comparator rather than an accessor if you want values to be sorted in an order different than natural order, such as in descending rather than ascending order. The above is equivalent to:jsconst bisector = d3.bisector((d, x) => d.Date - x);The bisector can be used to bisect sorted arrays of objects (in contrast to bisect, which is for bisecting primitives).bisector.right(array, x, lo, hi) ​jsd3.bisector((d) => d.Date).right(aapl, new Date("2014-01-02")) // 163Like bisectRight, but using this bisector’s accessor. The code above finds the index of the row immediately following Jan. 2, 2014 in the aapl sample dataset.bisector.left(array, x, lo, hi) ​jsd3.bisector((d) => d.Date).left(aapl, new Date("2014-01-02")) // 162Like bisectLeft, but using this bisector’s accessor. The code above finds the index of the row for Jan. 2, 2014 in the aapl sample dataset.bisector.center(array, x, lo, hi) ​jsd3.bisector((d) => d.Date).center(aapl, new Date("2013-12-31")) // 161Returns the index of the closest value to x in the given sorted array. This expects that the bisector’s accessor returns a quantitative value, or that the bisector’s comparator returns a signed distance; otherwise, this method is equivalent to bisector.left. The arguments lo (inclusive) and hi (exclusive) may be used to specify a subset of the array which should be considered; by default the entire array is used.bisect(array, x, lo, hi) ​jsd3.bisect(aapl.map((d) => d.Date), new Date("2014-01-02")) // 163Alias for bisectRight.bisectRight(array, x, lo, hi) ​jsd3.bisectRight(aapl.map((d) => d.Date), new Date("2014-01-02")) // 163Like bisectLeft, but returns an insertion point which comes after (to the right of) any existing entries equivalent to x in array. The returned insertion point i partitions the array into two halves so that all v <= x for v in array.slice(lo, i) for the left side and all v > x for v in array.slice(i, hi) for the right side. See also bisector.right.bisectLeft(array, x, lo, hi) ​jsd3.bisectLeft(aapl.map((d) => d.Date), new Date("2014-01-02")) // 162Returns the insertion point for x in array to maintain sorted order. The arguments lo and hi may be used to specify a subset of the array which should be considered; by default the entire array is used. If x is already present in array, the insertion point will be before (to the left of) any existing entries. The return value is suitable for use as the first argument to array.splice assuming that array is already sorted. The returned insertion point i partitions the array into two halves so that all v < x for v in array.slice(lo, i) for the left side and all v >= x for v in array.slice(i, hi) for the right side. See also bisector.left.bisectCenter(array, x, lo, hi) ​jsd3.bisectCenter(aapl.map((d) => d.Date), new Date("2013-12-31")) // 161Returns the index of the value closest to x in the given array of numbers. The arguments lo (inclusive) and hi (exclusive) may be used to specify a subset of the array which should be considered; by default the entire array is used. See also bisector.center.\n\n\n\nBlurring data ​A box blur implementation for 1D, 2D, and RGBA images; supports fractional radius.blur(data, radius) ​jsconst numbers = d3.cumsum({length: 1000}, () => Math.random() - 0.5);
d3.blur(numbers, 5); // a smoothed random walkExamples · Source · Blurs an array of data in-place by applying three iterations of a moving average transform (box filter) for a fast approximation of a Gaussian kernel of the given radius, a non-negative number. Returns the given data.blur2({data, width, height}, rx, ry) ​jsconst matrix = {
  width: 4,
  height: 3,
  data: [
    1, 0, 0, 0,
    0, 0, 0, 0,
    0, 0, 0, 1
  ]
};

d3.blur2(matrix, 1);Examples · Source · Blurs a matrix of the given width and height in-place by applying a horizontal blur of radius rx and a vertical blur of radius ry (which defaults to rx). The matrix values data are stored in a flat (one-dimensional) array. If height is not specified, it is inferred from the given width and data.length. Returns the blurred matrix {data, width, height}.blurImage(imageData, rx, ry) ​jsconst imageData = context.getImageData(0, 0, width, height);
d3.blurImage(imageData, 5);Examples · Source · Blurs the given ImageData in-place, blurring each of the RGBA layers independently by applying an horizontal blur of radius rx and a vertical blur of radius ry (which defaults to rx). Returns the blurred ImageData.\n\nSearchK7.9.0GitHub️ 110.0kOn this pageBlurring data ​A box blur implementation for 1D, 2D, and RGBA images; supports fractional radius.blur(data, radius) ​jsconst numbers = d3.cumsum({length: 1000}, () => Math.random() - 0.5);
d3.blur(numbers, 5); // a smoothed random walkExamples · Source · Blurs an array of data in-place by applying three iterations of a moving average transform (box filter) for a fast approximation of a Gaussian kernel of the given radius, a non-negative number. Returns the given data.blur2({data, width, height}, rx, ry) ​jsconst matrix = {
  width: 4,
  height: 3,
  data: [
    1, 0, 0, 0,
    0, 0, 0, 0,
    0, 0, 0, 1
  ]
};

d3.blur2(matrix, 1);Examples · Source · Blurs a matrix of the given width and height in-place by applying a horizontal blur of radius rx and a vertical blur of radius ry (which defaults to rx). The matrix values data are stored in a flat (one-dimensional) array. If height is not specified, it is inferred from the given width and data.length. Returns the blurred matrix {data, width, height}.blurImage(imageData, rx, ry) ​jsconst imageData = context.getImageData(0, 0, width, height);
d3.blurImage(imageData, 5);Examples · Source · Blurs the given ImageData in-place, blurring each of the RGBA layers independently by applying an horizontal blur of radius rx and a vertical blur of radius ry (which defaults to rx). Returns the blurred ImageData.PagerPrevious pageBisecting dataNext pageGrouping data\n\nBlurring data ​A box blur implementation for 1D, 2D, and RGBA images; supports fractional radius.blur(data, radius) ​jsconst numbers = d3.cumsum({length: 1000}, () => Math.random() - 0.5);
d3.blur(numbers, 5); // a smoothed random walkExamples · Source · Blurs an array of data in-place by applying three iterations of a moving average transform (box filter) for a fast approximation of a Gaussian kernel of the given radius, a non-negative number. Returns the given data.blur2({data, width, height}, rx, ry) ​jsconst matrix = {
  width: 4,
  height: 3,
  data: [
    1, 0, 0, 0,
    0, 0, 0, 0,
    0, 0, 0, 1
  ]
};

d3.blur2(matrix, 1);Examples · Source · Blurs a matrix of the given width and height in-place by applying a horizontal blur of radius rx and a vertical blur of radius ry (which defaults to rx). The matrix values data are stored in a flat (one-dimensional) array. If height is not specified, it is inferred from the given width and data.length. Returns the blurred matrix {data, width, height}.blurImage(imageData, rx, ry) ​jsconst imageData = context.getImageData(0, 0, width, height);
d3.blurImage(imageData, 5);Examples · Source · Blurs the given ImageData in-place, blurring each of the RGBA layers independently by applying an horizontal blur of radius rx and a vertical blur of radius ry (which defaults to rx). Returns the blurred ImageData.\n\n\n\nGrouping data ​Group discrete values.group(iterable, ...keys) ​Examples · Source · Groups the specified iterable of values into an InternMap from key to array of value. For example, to group the penguins sample dataset by species field:jsconst species = d3.group(penguins, (d) => d.species);To get the elements whose species field is Adelie:jsspecies.get("Adelie") // Array(152)If more than one key is specified, a nested InternMap is returned. For example:jsconst speciesSex = d3.group(penguins, (d) => d.species, (d) => d.sex)To get the penguins whose species is Adelie and whose sex is FEMALE:jsspeciesSex.get("Adelie").get("FEMALE") // Array(73)Elements are returned in the order of the first instance of each key.groups(iterable, ...keys) ​jsconst species = d3.groups(penguins, (d) => d.species); // [["Adelie", Array(152)], …]Equivalent to group, but returns an array of [key, value] entries instead of a map. If more than one key is specified, each value will be a nested array of [key, value] entries. Elements are returned in the order of the first instance of each key.rollup(iterable, reduce, ...keys) ​Examples · Source · Groups and reduces the specified iterable of values into an InternMap from key to reduced value. For example, to group and count the penguins sample dataset by species field:jsconst speciesCount = d3.rollup(penguins, (D) => D.length, (d) => d.species);To get the count of penguins whose species is Adelie:jsspeciesCount.get("Adelie") // 152If more than one key is specified, a nested InternMap is returned. For example:jsconst speciesSexCount = d3.rollup(penguins, (D) => D.length, (d) => d.species, (d) => d.sex);To get the count of penguins whose species is Adelie and whose sex is FEMALE:jsspeciesSexCount.get("Adelie").get("FEMALE") // 73Elements are returned in the order of the first instance of each key.rollups(iterable, reduce, ...keys) ​jsconst speciesCounts = d3.rollups(penguins, (D) => D.length, (d) => d.species); // [["Adelie", 152], …]Equivalent to rollup, but returns an array of [key, value] entries instead of a map. If more than one key is specified, each value will be a nested array of [key, value] entries. Elements are returned in the order of the first instance of each key.index(iterable, ...keys) ​Uses rollup with a reducer that extracts the first element from each group, and throws an error if the group has more than one element. For example, to index the aapl same dataset by date:jsconst aaplDate = d3.index(aapl, (d) => d.Date);You can then quickly retrieve a value by date:jsaaplDate.get(new Date("2013-12-31")).Close // 80.145714Elements are returned in input order.indexes(iterable, ...keys) ​Like index, but returns an array of [key, value] entries instead of a map. This probably isn’t useful for anything, but is included for symmetry with groups and rollups.flatGroup(iterable, ...keys) ​Examples · Source · Equivalent to group, but returns a flat array of [key0, key1, …, values] instead of nested maps; useful for iterating over all groups.flatRollup(iterable, reduce, ...keys) ​Examples · Source · Equivalent to rollup, but returns a flat array of [key0, key1, …, value] instead of nested maps; useful for iterating over all groups.groupSort(iterable, comparator, key) ​Examples · Source · Groups the specified iterable of elements according to the specified key function, sorts the groups according to the specified comparator, and then returns an array of keys in sorted order. For example, to order the species of the penguins sample dataset by ascending median body mass:jsd3.groupSort(penguins, (D) => d3.median(D, (d) => d.body_mass_g), (d) => d.species) // ["Adelie", "Chinstrap", "Gentoo"]For descending order, negate the group value:jsd3.groupSort(penguins, (D) => -d3.median(D, (d) => d.body_mass_g), (d) => d.species) // ["Gentoo", "Adelie", "Chinstrap"]If a comparator is passed instead of an accessor (i.e., if the second argument is a function that takes exactly two arguments), it will be asked to compare two groups a and b and should return a negative value if a should be before b, a positive value if a should be after b, or zero for a partial ordering.\n\nSearchK7.9.0GitHub️ 110.0kOn this pageGrouping data ​Group discrete values.group(iterable, ...keys) ​Examples · Source · Groups the specified iterable of values into an InternMap from key to array of value. For example, to group the penguins sample dataset by species field:jsconst species = d3.group(penguins, (d) => d.species);To get the elements whose species field is Adelie:jsspecies.get("Adelie") // Array(152)If more than one key is specified, a nested InternMap is returned. For example:jsconst speciesSex = d3.group(penguins, (d) => d.species, (d) => d.sex)To get the penguins whose species is Adelie and whose sex is FEMALE:jsspeciesSex.get("Adelie").get("FEMALE") // Array(73)Elements are returned in the order of the first instance of each key.groups(iterable, ...keys) ​jsconst species = d3.groups(penguins, (d) => d.species); // [["Adelie", Array(152)], …]Equivalent to group, but returns an array of [key, value] entries instead of a map. If more than one key is specified, each value will be a nested array of [key, value] entries. Elements are returned in the order of the first instance of each key.rollup(iterable, reduce, ...keys) ​Examples · Source · Groups and reduces the specified iterable of values into an InternMap from key to reduced value. For example, to group and count the penguins sample dataset by species field:jsconst speciesCount = d3.rollup(penguins, (D) => D.length, (d) => d.species);To get the count of penguins whose species is Adelie:jsspeciesCount.get("Adelie") // 152If more than one key is specified, a nested InternMap is returned. For example:jsconst speciesSexCount = d3.rollup(penguins, (D) => D.length, (d) => d.species, (d) => d.sex);To get the count of penguins whose species is Adelie and whose sex is FEMALE:jsspeciesSexCount.get("Adelie").get("FEMALE") // 73Elements are returned in the order of the first instance of each key.rollups(iterable, reduce, ...keys) ​jsconst speciesCounts = d3.rollups(penguins, (D) => D.length, (d) => d.species); // [["Adelie", 152], …]Equivalent to rollup, but returns an array of [key, value] entries instead of a map. If more than one key is specified, each value will be a nested array of [key, value] entries. Elements are returned in the order of the first instance of each key.index(iterable, ...keys) ​Uses rollup with a reducer that extracts the first element from each group, and throws an error if the group has more than one element. For example, to index the aapl same dataset by date:jsconst aaplDate = d3.index(aapl, (d) => d.Date);You can then quickly retrieve a value by date:jsaaplDate.get(new Date("2013-12-31")).Close // 80.145714Elements are returned in input order.indexes(iterable, ...keys) ​Like index, but returns an array of [key, value] entries instead of a map. This probably isn’t useful for anything, but is included for symmetry with groups and rollups.flatGroup(iterable, ...keys) ​Examples · Source · Equivalent to group, but returns a flat array of [key0, key1, …, values] instead of nested maps; useful for iterating over all groups.flatRollup(iterable, reduce, ...keys) ​Examples · Source · Equivalent to rollup, but returns a flat array of [key0, key1, …, value] instead of nested maps; useful for iterating over all groups.groupSort(iterable, comparator, key) ​Examples · Source · Groups the specified iterable of elements according to the specified key function, sorts the groups according to the specified comparator, and then returns an array of keys in sorted order. For example, to order the species of the penguins sample dataset by ascending median body mass:jsd3.groupSort(penguins, (D) => d3.median(D, (d) => d.body_mass_g), (d) => d.species) // ["Adelie", "Chinstrap", "Gentoo"]For descending order, negate the group value:jsd3.groupSort(penguins, (D) => -d3.median(D, (d) => d.body_mass_g), (d) => d.species) // ["Gentoo", "Adelie", "Chinstrap"]If a comparator is passed instead of an accessor (i.e., if the second argument is a function that takes exactly two arguments), it will be asked to compare two groups a and b and should return a negative value if a should be before b, a positive value if a should be after b, or zero for a partial ordering.PagerPrevious pageBlurring dataNext pageInterning values\n\nGrouping data ​Group discrete values.group(iterable, ...keys) ​Examples · Source · Groups the specified iterable of values into an InternMap from key to array of value. For example, to group the penguins sample dataset by species field:jsconst species = d3.group(penguins, (d) => d.species);To get the elements whose species field is Adelie:jsspecies.get("Adelie") // Array(152)If more than one key is specified, a nested InternMap is returned. For example:jsconst speciesSex = d3.group(penguins, (d) => d.species, (d) => d.sex)To get the penguins whose species is Adelie and whose sex is FEMALE:jsspeciesSex.get("Adelie").get("FEMALE") // Array(73)Elements are returned in the order of the first instance of each key.groups(iterable, ...keys) ​jsconst species = d3.groups(penguins, (d) => d.species); // [["Adelie", Array(152)], …]Equivalent to group, but returns an array of [key, value] entries instead of a map. If more than one key is specified, each value will be a nested array of [key, value] entries. Elements are returned in the order of the first instance of each key.rollup(iterable, reduce, ...keys) ​Examples · Source · Groups and reduces the specified iterable of values into an InternMap from key to reduced value. For example, to group and count the penguins sample dataset by species field:jsconst speciesCount = d3.rollup(penguins, (D) => D.length, (d) => d.species);To get the count of penguins whose species is Adelie:jsspeciesCount.get("Adelie") // 152If more than one key is specified, a nested InternMap is returned. For example:jsconst speciesSexCount = d3.rollup(penguins, (D) => D.length, (d) => d.species, (d) => d.sex);To get the count of penguins whose species is Adelie and whose sex is FEMALE:jsspeciesSexCount.get("Adelie").get("FEMALE") // 73Elements are returned in the order of the first instance of each key.rollups(iterable, reduce, ...keys) ​jsconst speciesCounts = d3.rollups(penguins, (D) => D.length, (d) => d.species); // [["Adelie", 152], …]Equivalent to rollup, but returns an array of [key, value] entries instead of a map. If more than one key is specified, each value will be a nested array of [key, value] entries. Elements are returned in the order of the first instance of each key.index(iterable, ...keys) ​Uses rollup with a reducer that extracts the first element from each group, and throws an error if the group has more than one element. For example, to index the aapl same dataset by date:jsconst aaplDate = d3.index(aapl, (d) => d.Date);You can then quickly retrieve a value by date:jsaaplDate.get(new Date("2013-12-31")).Close // 80.145714Elements are returned in input order.indexes(iterable, ...keys) ​Like index, but returns an array of [key, value] entries instead of a map. This probably isn’t useful for anything, but is included for symmetry with groups and rollups.flatGroup(iterable, ...keys) ​Examples · Source · Equivalent to group, but returns a flat array of [key0, key1, …, values] instead of nested maps; useful for iterating over all groups.flatRollup(iterable, reduce, ...keys) ​Examples · Source · Equivalent to rollup, but returns a flat array of [key0, key1, …, value] instead of nested maps; useful for iterating over all groups.groupSort(iterable, comparator, key) ​Examples · Source · Groups the specified iterable of elements according to the specified key function, sorts the groups according to the specified comparator, and then returns an array of keys in sorted order. For example, to order the species of the penguins sample dataset by ascending median body mass:jsd3.groupSort(penguins, (D) => d3.median(D, (d) => d.body_mass_g), (d) => d.species) // ["Adelie", "Chinstrap", "Gentoo"]For descending order, negate the group value:jsd3.groupSort(penguins, (D) => -d3.median(D, (d) => d.body_mass_g), (d) => d.species) // ["Gentoo", "Adelie", "Chinstrap"]If a comparator is passed instead of an accessor (i.e., if the second argument is a function that takes exactly two arguments), it will be asked to compare two groups a and b and should return a negative value if a should be before b, a positive value if a should be after b, or zero for a partial ordering.\n\n\n\nInterning values ​The InternMap and InternSet classes extend the native JavaScript Map and Set classes, respectively, allowing Dates and other non-primitive keys by bypassing the SameValueZero algorithm when determining key equality. d3.group, d3.rollup and d3.index use an InternMap rather than a native Map.new InternMap(iterable, key) ​jsconst valueByDate = new d3.InternMap([
  [new Date("2021-01-01"), 42],
  [new Date("2022-01-01"), 12],
  [new Date("2023-01-01"), 45]
]);Examples · Source · Constructs a new Map given the specified iterable of [key, value] entries. The keys are interned using the specified key function which defaults to object.valueOf for non-primitive values. For example, to retrieve a value keyed by a given date:jsvalueByDate.get(new Date("2022-01-01")) // 12new InternSet(iterable, key) ​jsconst dates = new d3.InternSet([
  new Date("2021-01-01"),
  new Date("2022-01-01"),
  new Date("2023-01-01")
]);Examples · Source · Constructs a new Set given the specified iterable of values. The values are interned using the specified key function which defaults to object.valueOf for non-primitive values. For example, to query for a given date:jsdates.has(new Date("2022-01-01")) // true\n\nSearchK7.9.0GitHub️ 110.0kOn this pageInterning values ​The InternMap and InternSet classes extend the native JavaScript Map and Set classes, respectively, allowing Dates and other non-primitive keys by bypassing the SameValueZero algorithm when determining key equality. d3.group, d3.rollup and d3.index use an InternMap rather than a native Map.new InternMap(iterable, key) ​jsconst valueByDate = new d3.InternMap([
  [new Date("2021-01-01"), 42],
  [new Date("2022-01-01"), 12],
  [new Date("2023-01-01"), 45]
]);Examples · Source · Constructs a new Map given the specified iterable of [key, value] entries. The keys are interned using the specified key function which defaults to object.valueOf for non-primitive values. For example, to retrieve a value keyed by a given date:jsvalueByDate.get(new Date("2022-01-01")) // 12new InternSet(iterable, key) ​jsconst dates = new d3.InternSet([
  new Date("2021-01-01"),
  new Date("2022-01-01"),
  new Date("2023-01-01")
]);Examples · Source · Constructs a new Set given the specified iterable of values. The values are interned using the specified key function which defaults to object.valueOf for non-primitive values. For example, to query for a given date:jsdates.has(new Date("2022-01-01")) // truePagerPrevious pageGrouping dataNext pageSet operations\n\nInterning values ​The InternMap and InternSet classes extend the native JavaScript Map and Set classes, respectively, allowing Dates and other non-primitive keys by bypassing the SameValueZero algorithm when determining key equality. d3.group, d3.rollup and d3.index use an InternMap rather than a native Map.new InternMap(iterable, key) ​jsconst valueByDate = new d3.InternMap([
  [new Date("2021-01-01"), 42],
  [new Date("2022-01-01"), 12],
  [new Date("2023-01-01"), 45]
]);Examples · Source · Constructs a new Map given the specified iterable of [key, value] entries. The keys are interned using the specified key function which defaults to object.valueOf for non-primitive values. For example, to retrieve a value keyed by a given date:jsvalueByDate.get(new Date("2022-01-01")) // 12new InternSet(iterable, key) ​jsconst dates = new d3.InternSet([
  new Date("2021-01-01"),
  new Date("2022-01-01"),
  new Date("2023-01-01")
]);Examples · Source · Constructs a new Set given the specified iterable of values. The values are interned using the specified key function which defaults to object.valueOf for non-primitive values. For example, to query for a given date:jsdates.has(new Date("2022-01-01")) // true\n\n\n\nSet operations ​Logical set operations for any iterable.difference(iterable, ...others) ​Source · Returns a new InternSet containing every value in iterable that is not in any of the others iterables.jsd3.difference([0, 1, 2, 0], [1]) // Set {0, 2}union(...iterables) ​Source · Returns a new InternSet containing every (distinct) value that appears in any of the given iterables. The order of values in the returned set is based on their first occurrence in the given iterables.jsd3.union([0, 2, 1, 0], [1, 3]) // Set {0, 2, 1, 3}intersection(...iterables) ​Source · Returns a new InternSet containing every (distinct) value that appears in all of the given iterables. The order of values in the returned set is based on their first occurrence in the given iterables.jsd3.intersection([0, 2, 1, 0], [1, 3]) // Set {1}superset(a, b) ​Source · Returns true if a is a superset of b: if every value in the given iterable b is also in the given iterable a.jsd3.superset([0, 2, 1, 3, 0], [1, 3]) // truesubset(a, b) ​Source · Returns true if a is a subset of b: if every value in the given iterable a is also in the given iterable b.jsd3.subset([1, 3], [0, 2, 1, 3, 0]) // truedisjoint(a, b) ​Source · Returns true if a and b are disjoint: if a and b contain no shared value.jsd3.disjoint([1, 3], [2, 4]) // true\n\nSearchK7.9.0GitHub️ 110.0kOn this pageSet operations ​Logical set operations for any iterable.difference(iterable, ...others) ​Source · Returns a new InternSet containing every value in iterable that is not in any of the others iterables.jsd3.difference([0, 1, 2, 0], [1]) // Set {0, 2}union(...iterables) ​Source · Returns a new InternSet containing every (distinct) value that appears in any of the given iterables. The order of values in the returned set is based on their first occurrence in the given iterables.jsd3.union([0, 2, 1, 0], [1, 3]) // Set {0, 2, 1, 3}intersection(...iterables) ​Source · Returns a new InternSet containing every (distinct) value that appears in all of the given iterables. The order of values in the returned set is based on their first occurrence in the given iterables.jsd3.intersection([0, 2, 1, 0], [1, 3]) // Set {1}superset(a, b) ​Source · Returns true if a is a superset of b: if every value in the given iterable b is also in the given iterable a.jsd3.superset([0, 2, 1, 3, 0], [1, 3]) // truesubset(a, b) ​Source · Returns true if a is a subset of b: if every value in the given iterable a is also in the given iterable b.jsd3.subset([1, 3], [0, 2, 1, 3, 0]) // truedisjoint(a, b) ​Source · Returns true if a and b are disjoint: if a and b contain no shared value.jsd3.disjoint([1, 3], [2, 4]) // truePagerPrevious pageInterning valuesNext pageSorting data\n\nSet operations ​Logical set operations for any iterable.difference(iterable, ...others) ​Source · Returns a new InternSet containing every value in iterable that is not in any of the others iterables.jsd3.difference([0, 1, 2, 0], [1]) // Set {0, 2}union(...iterables) ​Source · Returns a new InternSet containing every (distinct) value that appears in any of the given iterables. The order of values in the returned set is based on their first occurrence in the given iterables.jsd3.union([0, 2, 1, 0], [1, 3]) // Set {0, 2, 1, 3}intersection(...iterables) ​Source · Returns a new InternSet containing every (distinct) value that appears in all of the given iterables. The order of values in the returned set is based on their first occurrence in the given iterables.jsd3.intersection([0, 2, 1, 0], [1, 3]) // Set {1}superset(a, b) ​Source · Returns true if a is a superset of b: if every value in the given iterable b is also in the given iterable a.jsd3.superset([0, 2, 1, 3, 0], [1, 3]) // truesubset(a, b) ​Source · Returns true if a is a subset of b: if every value in the given iterable a is also in the given iterable b.jsd3.subset([1, 3], [0, 2, 1, 3, 0]) // truedisjoint(a, b) ​Source · Returns true if a and b are disjoint: if a and b contain no shared value.jsd3.disjoint([1, 3], [2, 4]) // true\n\n\n\nSorting data ​Sort values; see also bisect.ascending(a, b) ​Examples · Source · Returns -1 if a is less than b, 1 if a is greater than b, 0 if a and b are equivalent, and otherwise NaN.js[39, 21, 1, 104, 22].sort(d3.ascending) // [1, 21, 22, 39, 104]This is the comparator function for natural order, and can be used with array.sort to arrange elements in ascending order.descending(a, b) ​Examples · Source · Returns -1 if a is greater than b, 1 if a is less than b, 0 if a and b are equivalent, and otherwise NaN.js[39, 21, 1, 104, 22].sort(d3.descending) // [104, 39, 22, 21, 1]This is the comparator function for natural order, and can be used with array.sort to arrange elements in descending order.permute(source, keys) ​Examples · Source · Returns a permutation of the specified source array or object using the specified iterable of keys. The returned array contains the corresponding property of the source object for each key in keys, in order.jsd3.permute(["a", "b", "c"], [1, 2, 0]) // returns ["b", "c", "a"]The given source need not be an array; for example, given an objectjsconst object = {yield: 27, variety: "Manchuria", year: 1931, site: "University Farm"};three fields could be extract like sojsd3.permute(object, ["site", "variety", "yield"]) // ["University Farm", "Manchuria", 27]quickselect(array, k, lo, hi, compare) ​Examples · Source · Rearranges the elements of array between lo and hi (inclusive) in-place such that array[k] is the (k - lo + 1)-th smallest value and array.slice(lo, k) are the k smallest elements, according to the given compare function, and returns the given array. If lo is not specified, it defaults to zero; if hi is not specified, it defaults to array.length - 1; if compare is not specified, it defaults to ascending.For example, given an array of numbers:jsconst numbers = [65, 28, 59, 33, 21, 56, 22, 95, 50, 12, 90, 53, 28, 77, 39];To select the smallest 8 elements:jsd3.quickselect(numbers, 8)The rearranged numbers isjs[39, 28, 28, 33, 21, 12, 22, 50, 53, 56, 59, 65, 90, 77, 95]
//                               ^^ numbers[k]where numbers[8] is 53: greater than the preceding k elements and less than the following elements. Implemented by Volodymyr Agafonkin’s quickselect.reverse(iterable) ​Source · Returns an array containing the values in the given iterable in reverse order.jsd3.reverse(new Set([0, 2, 3, 1])) // [1, 3, 2, 0]Equivalent to array.reverse, except that it does not mutate the given input and works with any iterable.shuffle(array, start, stop) ​Examples · Source · Randomizes the order of the specified array in-place using the Fisher–Yates shuffle and returns the array.jsd3.shuffle([..."abcdefg"]) // ["e", "c", "a", "d", "b", "g", "f"], perhapsIf start is specified, it is the starting index (inclusive) of the array to shuffle; if start is not specified, it defaults to zero. If stop is specified, it is the ending index (exclusive) of the array to shuffle; if stop is not specified, it defaults to array.length. For example, to shuffle the first ten elements of the array: shuffle(array, 0, 10).shuffler(random) ​Source · Returns a shuffle function given the specified random source.jsd3.shuffler(d3.randomLcg(42))([0, 1, 2, 3, 4, 5, 6, 7, 8, 9]) // [5, 3, 7, 6, 8, 9, 1, 4, 0, 2]Often used with d3.randomLcg for a deterministic shuffle.sort(iterable, comparator) ​Source · Returns an array containing the values in the given iterable in the sorted order defined by the given comparator or accessor function. If comparator is not specified, it defaults to d3.ascending.jsd3.sort(new Set([0, 2, 3, 1])) // [0, 1, 2, 3]If an accessor (a function that does not take exactly two arguments) is specified,jsd3.sort(data, (d) => d.value)it is equivalent to a comparator using natural order:jsd3.sort(data, (a, b) => d3.ascending(a.value, b.value))The accessor is only invoked once per element, and thus the returned sorted order is consistent even if the accessor is nondeterministic. Multiple accessors may be specified to break ties.jsd3.sort(points, ({x}) => x, ({y}) => y)The above is equivalent to:jsd3.sort(data, (a, b) => d3.ascending(a.x, b.x) || d3.ascending(a.y, b.y))Unlike array.sort, d3.sort does not mutate the given input, the comparator defaults to natural order instead of lexicographic order, and the input can be any iterable.\n\nSearchK7.9.0GitHub️ 110.0kOn this pageSorting data ​Sort values; see also bisect.ascending(a, b) ​Examples · Source · Returns -1 if a is less than b, 1 if a is greater than b, 0 if a and b are equivalent, and otherwise NaN.js[39, 21, 1, 104, 22].sort(d3.ascending) // [1, 21, 22, 39, 104]This is the comparator function for natural order, and can be used with array.sort to arrange elements in ascending order.descending(a, b) ​Examples · Source · Returns -1 if a is greater than b, 1 if a is less than b, 0 if a and b are equivalent, and otherwise NaN.js[39, 21, 1, 104, 22].sort(d3.descending) // [104, 39, 22, 21, 1]This is the comparator function for natural order, and can be used with array.sort to arrange elements in descending order.permute(source, keys) ​Examples · Source · Returns a permutation of the specified source array or object using the specified iterable of keys. The returned array contains the corresponding property of the source object for each key in keys, in order.jsd3.permute(["a", "b", "c"], [1, 2, 0]) // returns ["b", "c", "a"]The given source need not be an array; for example, given an objectjsconst object = {yield: 27, variety: "Manchuria", year: 1931, site: "University Farm"};three fields could be extract like sojsd3.permute(object, ["site", "variety", "yield"]) // ["University Farm", "Manchuria", 27]quickselect(array, k, lo, hi, compare) ​Examples · Source · Rearranges the elements of array between lo and hi (inclusive) in-place such that array[k] is the (k - lo + 1)-th smallest value and array.slice(lo, k) are the k smallest elements, according to the given compare function, and returns the given array. If lo is not specified, it defaults to zero; if hi is not specified, it defaults to array.length - 1; if compare is not specified, it defaults to ascending.For example, given an array of numbers:jsconst numbers = [65, 28, 59, 33, 21, 56, 22, 95, 50, 12, 90, 53, 28, 77, 39];To select the smallest 8 elements:jsd3.quickselect(numbers, 8)The rearranged numbers isjs[39, 28, 28, 33, 21, 12, 22, 50, 53, 56, 59, 65, 90, 77, 95]
//                               ^^ numbers[k]where numbers[8] is 53: greater than the preceding k elements and less than the following elements. Implemented by Volodymyr Agafonkin’s quickselect.reverse(iterable) ​Source · Returns an array containing the values in the given iterable in reverse order.jsd3.reverse(new Set([0, 2, 3, 1])) // [1, 3, 2, 0]Equivalent to array.reverse, except that it does not mutate the given input and works with any iterable.shuffle(array, start, stop) ​Examples · Source · Randomizes the order of the specified array in-place using the Fisher–Yates shuffle and returns the array.jsd3.shuffle([..."abcdefg"]) // ["e", "c", "a", "d", "b", "g", "f"], perhapsIf start is specified, it is the starting index (inclusive) of the array to shuffle; if start is not specified, it defaults to zero. If stop is specified, it is the ending index (exclusive) of the array to shuffle; if stop is not specified, it defaults to array.length. For example, to shuffle the first ten elements of the array: shuffle(array, 0, 10).shuffler(random) ​Source · Returns a shuffle function given the specified random source.jsd3.shuffler(d3.randomLcg(42))([0, 1, 2, 3, 4, 5, 6, 7, 8, 9]) // [5, 3, 7, 6, 8, 9, 1, 4, 0, 2]Often used with d3.randomLcg for a deterministic shuffle.sort(iterable, comparator) ​Source · Returns an array containing the values in the given iterable in the sorted order defined by the given comparator or accessor function. If comparator is not specified, it defaults to d3.ascending.jsd3.sort(new Set([0, 2, 3, 1])) // [0, 1, 2, 3]If an accessor (a function that does not take exactly two arguments) is specified,jsd3.sort(data, (d) => d.value)it is equivalent to a comparator using natural order:jsd3.sort(data, (a, b) => d3.ascending(a.value, b.value))The accessor is only invoked once per element, and thus the returned sorted order is consistent even if the accessor is nondeterministic. Multiple accessors may be specified to break ties.jsd3.sort(points, ({x}) => x, ({y}) => y)The above is equivalent to:jsd3.sort(data, (a, b) => d3.ascending(a.x, b.x) || d3.ascending(a.y, b.y))Unlike array.sort, d3.sort does not mutate the given input, the comparator defaults to natural order instead of lexicographic order, and the input can be any iterable.PagerPrevious pageSet operationsNext pageSummarizing data\n\nSorting data ​Sort values; see also bisect.ascending(a, b) ​Examples · Source · Returns -1 if a is less than b, 1 if a is greater than b, 0 if a and b are equivalent, and otherwise NaN.js[39, 21, 1, 104, 22].sort(d3.ascending) // [1, 21, 22, 39, 104]This is the comparator function for natural order, and can be used with array.sort to arrange elements in ascending order.descending(a, b) ​Examples · Source · Returns -1 if a is greater than b, 1 if a is less than b, 0 if a and b are equivalent, and otherwise NaN.js[39, 21, 1, 104, 22].sort(d3.descending) // [104, 39, 22, 21, 1]This is the comparator function for natural order, and can be used with array.sort to arrange elements in descending order.permute(source, keys) ​Examples · Source · Returns a permutation of the specified source array or object using the specified iterable of keys. The returned array contains the corresponding property of the source object for each key in keys, in order.jsd3.permute(["a", "b", "c"], [1, 2, 0]) // returns ["b", "c", "a"]The given source need not be an array; for example, given an objectjsconst object = {yield: 27, variety: "Manchuria", year: 1931, site: "University Farm"};three fields could be extract like sojsd3.permute(object, ["site", "variety", "yield"]) // ["University Farm", "Manchuria", 27]quickselect(array, k, lo, hi, compare) ​Examples · Source · Rearranges the elements of array between lo and hi (inclusive) in-place such that array[k] is the (k - lo + 1)-th smallest value and array.slice(lo, k) are the k smallest elements, according to the given compare function, and returns the given array. If lo is not specified, it defaults to zero; if hi is not specified, it defaults to array.length - 1; if compare is not specified, it defaults to ascending.For example, given an array of numbers:jsconst numbers = [65, 28, 59, 33, 21, 56, 22, 95, 50, 12, 90, 53, 28, 77, 39];To select the smallest 8 elements:jsd3.quickselect(numbers, 8)The rearranged numbers isjs[39, 28, 28, 33, 21, 12, 22, 50, 53, 56, 59, 65, 90, 77, 95]
//                               ^^ numbers[k]where numbers[8] is 53: greater than the preceding k elements and less than the following elements. Implemented by Volodymyr Agafonkin’s quickselect.reverse(iterable) ​Source · Returns an array containing the values in the given iterable in reverse order.jsd3.reverse(new Set([0, 2, 3, 1])) // [1, 3, 2, 0]Equivalent to array.reverse, except that it does not mutate the given input and works with any iterable.shuffle(array, start, stop) ​Examples · Source · Randomizes the order of the specified array in-place using the Fisher–Yates shuffle and returns the array.jsd3.shuffle([..."abcdefg"]) // ["e", "c", "a", "d", "b", "g", "f"], perhapsIf start is specified, it is the starting index (inclusive) of the array to shuffle; if start is not specified, it defaults to zero. If stop is specified, it is the ending index (exclusive) of the array to shuffle; if stop is not specified, it defaults to array.length. For example, to shuffle the first ten elements of the array: shuffle(array, 0, 10).shuffler(random) ​Source · Returns a shuffle function given the specified random source.jsd3.shuffler(d3.randomLcg(42))([0, 1, 2, 3, 4, 5, 6, 7, 8, 9]) // [5, 3, 7, 6, 8, 9, 1, 4, 0, 2]Often used with d3.randomLcg for a deterministic shuffle.sort(iterable, comparator) ​Source · Returns an array containing the values in the given iterable in the sorted order defined by the given comparator or accessor function. If comparator is not specified, it defaults to d3.ascending.jsd3.sort(new Set([0, 2, 3, 1])) // [0, 1, 2, 3]If an accessor (a function that does not take exactly two arguments) is specified,jsd3.sort(data, (d) => d.value)it is equivalent to a comparator using natural order:jsd3.sort(data, (a, b) => d3.ascending(a.value, b.value))The accessor is only invoked once per element, and thus the returned sorted order is consistent even if the accessor is nondeterministic. Multiple accessors may be specified to break ties.jsd3.sort(points, ({x}) => x, ({y}) => y)The above is equivalent to:jsd3.sort(data, (a, b) => d3.ascending(a.x, b.x) || d3.ascending(a.y, b.y))Unlike array.sort, d3.sort does not mutate the given input, the comparator defaults to natural order instead of lexicographic order, and the input can be any iterable.\n\n\n\nSummarizing data ​Compute summary statistics.count(iterable, accessor) ​jsd3.count(penguins, (d) => d.body_mass_g) // 342Examples · Source · Returns the number of valid number values (i.e., not null, NaN, or undefined) in the specified iterable; accepts an accessor.min(iterable, accessor) ​Examples · Source · Returns the minimum value in the given iterable using natural order.jsd3.min([3, 2, 1, 1, 6, 2, 4]) // 1Unlike Math.min, d3.min does not coerce the inputs to numbers; for example, the minimum of the strings ["20", "3"] is "20", while the minimum of the numbers [20, 3] is 3.jsd3.min(["bob", "alice", "carol"]) // "alice"jsd3.min([new Date("2018-01-01"), new Date("2011-03-09")]) // 2011-03-09Also unlike Math.min, this method ignores undefined, null and NaN values, which is useful for ignoring missing data.jsd3.min([3, 2, 1, NaN, 4]) // 1An optional accessor function may be specified, which is similar to calling Array.from before computing the minimum value. The accessor function is repeatedly passed an element from the given iterable (often d) and the zero-based index (i).jsd3.min(alphabet, (d) => d.frequency) // 0.00074Because undefined values are ignored, you can use the accessor function to ignore values. For example, to get the frequency of the least-common letter than is not Z:jsd3.min(alphabet, (d) => d.letter === "Z" ? NaN : d.frequency) // 0.00095If the iterable contains no comparable values, returns undefined.jsd3.min([]) // undefinedjsd3.min(alphabet, (d) => d.doesnotexist) // undefinedSee also extent and least.minIndex(iterable, accessor) ​Source · Like min, but returns the index of the minimum value rather than the value itself.jsd3.minIndex([3, 2, 1, 1, 6, 2, 4]) // 2This method can find the least element according to the given accessor, similar to least:jsd3.minIndex(alphabet, (d) => d.frequency) // 25jsalphabet[d3.minIndex(alphabet, (d) => d.frequency)] // {letter: "Z", frequency: 0.00074}See also leastIndex.max(iterable, accessor) ​Examples · Source · Returns the maximum value in the given iterable using natural order.jsd3.max([3, 2, 1, 1, 6, 2, 4]) // 6Unlike Math.max, d3.max does not coerce the inputs to numbers; for example, the maximum of the strings ["20", "3"] is "3", while the maximum of the numbers [20, 3] is 20.jsd3.max(["bob", "alice", "carol"]) // "carol"jsd3.max([new Date("2018-01-01"), new Date("2011-03-09")]) // 2018-01-01Also unlike Math.max, this method ignores undefined, null and NaN values, which is useful for ignoring missing data.jsd3.max([3, 2, 1, NaN, 4]) // 4An optional accessor function may be specified, which is similar to calling Array.from before computing the maximum value. The accessor function is repeatedly passed an element from the given iterable (often d) and the zero-based index (i).jsd3.max(alphabet, (d) => d.frequency) // 0.12702Because undefined values are ignored, you can use the accessor function to ignore values. For example, to get the frequency of the most-common letter than is not E:jsd3.max(alphabet, (d) => d.letter === "E" ? NaN : d.frequency) // 0.09056If the iterable contains no comparable values, returns undefined.jsd3.max([]) // undefinedjsd3.max(alphabet, (d) => d.doesnotexist) // undefinedSee also extent and greatest.maxIndex(iterable, accessor) ​Source · Like max, but returns the index of the maximum value rather than the value itself.jsd3.maxIndex([3, 2, 1, 1, 6, 2, 4]) // 2This method can find the greatest element according to the given accessor, similar to greatest:jsd3.maxIndex(alphabet, (d) => d.frequency) // 0jsalphabet[d3.maxIndex(alphabet, (d) => d.frequency)] // {letter: "E", frequency: 0.12702}See also greatestIndex.least(iterable, comparator) ​Examples · Source · Returns the least element of the specified iterable according to the specified comparator.jsd3.least(alphabet, (a, b) => a.frequency - b.frequency) // {letter: "Z", frequency: 0.00074}jsd3.least(alphabet, (a, b) => b.frequency - a.frequency) // {letter: "E", frequency: 0.12702}If the comparator takes a single argument, is interpreted as an accessor and the returned elements are compared using natural order.jsd3.least(alphabet, (d) => d.frequency) // {letter: "Z", frequency: 0.00074}jsd3.least(alphabet, (d) => -d.frequency) // {letter: "E", frequency: 0.12702}If comparator is not specified, it defaults to ascending.jsd3.least(alphabet.map((d) => d.frequency)) // 0.00074If the given iterable contains no comparable elements (i.e., the comparator returns NaN when comparing each element to itself), returns undefined.jsd3.least([]) // undefinedThis function is similar to min, except it allows the use of a comparator rather than an accessor.leastIndex(iterable, comparator) ​Source · Returns the index of the least element of the specified iterable according to the specified comparator or accessor. If the given iterable contains no comparable elements (i.e., the comparator returns NaN when comparing each element to itself), returns -1. If comparator is not specified, it defaults to ascending. For example:jsconst array = [{foo: 42}, {foo: 91}];
d3.leastIndex(array, (a, b) => a.foo - b.foo); // 0
d3.leastIndex(array, (a, b) => b.foo - a.foo); // 1
d3.leastIndex(array, (d) => d.foo); // 0This function is similar to minIndex, except it allows the use of a comparator rather than an accessor.greatest(iterable, comparator) ​Examples · Source · Returns the greatest element of the specified iterable according to the specified comparator or accessor. If the given iterable contains no comparable elements (i.e., the comparator returns NaN when comparing each element to itself), returns undefined. If comparator is not specified, it defaults to ascending. For example:jsconst array = [{foo: 42}, {foo: 91}];
d3.greatest(array, (a, b) => a.foo - b.foo); // {foo: 91}
d3.greatest(array, (a, b) => b.foo - a.foo); // {foo: 42}
d3.greatest(array, (d) => d.foo); // {foo: 91}This function is similar to max, except it allows the use of a comparator rather than an accessor.greatestIndex(iterable, comparator) ​Source · Returns the index of the greatest element of the specified iterable according to the specified comparator or accessor. If the given iterable contains no comparable elements (i.e., the comparator returns NaN when comparing each element to itself), returns -1. If comparator is not specified, it defaults to ascending. For example:jsconst array = [{foo: 42}, {foo: 91}];
d3.greatestIndex(array, (a, b) => a.foo - b.foo); // 1
d3.greatestIndex(array, (a, b) => b.foo - a.foo); // 0
d3.greatestIndex(array, (d) => d.foo); // 1This function is similar to maxIndex, except it allows the use of a comparator rather than an accessor.extent(iterable, accessor) ​Examples · Source · Returns the minimum and maximum value in the given iterable using natural order.jsd3.extent([3, 2, 1, 1, 6, 2, 4]) // [1, 6]An optional accessor function may be specified, which is equivalent to calling Array.from before computing the extent.jsd3.extent(alphabet, (d) => d.frequency) // [0.00074, 0.12702]If the iterable contains no comparable values, returns [undefined, undefined].jsd3.extent(alphabet, (d) => d.doesnotexist) // [undefined, undefined]mode(iterable, accessor) ​Examples · Source · Returns the mode of the given iterable, i.e. the value which appears the most often. Ignores undefined, null and NaN values.jsd3.mode([1, 2, 2, 2, 3, 3]) // 2An optional accessor function may be specified, which is equivalent to calling Array.from before computing the mode.jsd3.mode(penguins, (d) => d.island) // "Biscoe"In case of equality, returns the first of the relevant values. If the iterable contains no comparable values, returns undefined.sum(iterable, accessor) ​Examples · Source · Returns the sum of the given iterable of numbers. Ignores undefined, null and NaN values.jsd3.sum([1, 2, 2, 2, NaN, 3, null]) // 10An optional accessor function may be specified, which is equivalent to calling Array.from before computing the sum.jsd3.sum(penguins, (d) => d.body_mass_g) // 1437000If the iterable contains no numbers, returns 0. See also fsum.mean(iterable, accessor) ​Examples · Source · Returns the mean of the given iterable of numbers. Ignores undefined, null and NaN values.jsd3.mean([1, 2, 2, 2, NaN, 3, null]) // 2An optional accessor function may be specified, which is equivalent to calling Array.from before computing the mean.jsd3.mean(penguins, (d) => d.body_mass_g) // 4201.754385964912If the iterable contains no numbers, returns undefined.median(iterable, accessor) ​Examples · Source · Returns the median of the given iterable of numbers using the R-7 method. Ignores undefined, null and NaN values.jsd3.median([1, 2, 2, 2, NaN, 3, null]) // 2An optional accessor function may be specified, which is equivalent to calling Array.from before computing the median.jsd3.median(penguins, (d) => d.body_mass_g) // 4050If the iterable contains no numbers, returns undefined.medianIndex(array, accessor) ​Source · Like median, but returns the index of the element to the left of the median.jsd3.medianIndex([1, 2, 2, 2, NaN, 3, null]) // 2cumsum(iterable, accessor) ​Examples · Source · Returns the cumulative sum of the given iterable of numbers, as a Float64Array of the same length.jsd3.cumsum([1, 1, 2, 3, 5]) // [1, 2, 4, 7, 12]An optional accessor function may be specified, which is equivalent to calling Array.from before computing the cumulative sum.jsd3.cumsum(penguins, (d) => d.body_mass_g) // [3750, 7550, 10800, 10800, …]This method ignores undefined and NaN values; this is useful for ignoring missing data. If the iterable contains no numbers, returns zeros. See also fcumsum.quantile(iterable, p, accessor) ​Examples · Source · Returns the p-quantile of the given iterable of numbers, where p is a number in the range [0, 1]. For example, the median can be computed using p = 0.5, the first quartile at p = 0.25, and the third quartile at p = 0.75. This particular implementation uses the R-7 method, which is the default for the R programming language and Excel.jsconst numbers = [0, 10, 30];
d3.quantile(numbers, 0); // 0
d3.quantile(numbers, 0.5); // 10
d3.quantile(numbers, 1); // 30
d3.quantile(numbers, 0.25); // 5
d3.quantile(numbers, 0.75); // 20
d3.quantile(numbers, 0.1); // 2An optional accessor function may be specified, which is equivalent to calling array.map before computing the quantile.quantileIndex(array, p, accessor) ​Source · Similar to quantile, but returns the index to the left of p.quantileSorted(array, p, accessor) ​Examples · Source · Similar to quantile, but expects the input to be a sorted array of values. In contrast with quantile, the accessor is only called on the elements needed to compute the quantile.rank(iterable, comparator) ​Examples · Source · Returns an array with the rank of each value in the iterable, i.e. the zero-based index of the value when the iterable is sorted. Nullish values are sorted to the end and ranked NaN. An optional comparator or accessor function may be specified; the latter is equivalent to calling array.map before computing the ranks. If comparator is not specified, it defaults to ascending. Ties (equivalent values) all get the same rank, defined as the first time the value is found.jsd3.rank([{x: 1}, {}, {x: 2}, {x: 0}], d => d.x); // [1, NaN, 2, 0]
d3.rank(["b", "c", "b", "a"]); // [1, 3, 1, 0]
d3.rank([1, 2, 3], d3.descending); // [2, 1, 0]variance(iterable, accessor) ​Examples · Source · Returns an unbiased estimator of the population variance of the given iterable of numbers using Welford’s algorithm. If the iterable has fewer than two numbers, returns undefined. An optional accessor function may be specified, which is equivalent to calling Array.from before computing the variance. This method ignores undefined and NaN values; this is useful for ignoring missing data.deviation(iterable, accessor) ​Examples · Source · Returns the standard deviation, defined as the square root of the bias-corrected variance, of the given iterable of numbers. If the iterable has fewer than two numbers, returns undefined. An optional accessor function may be specified, which is equivalent to calling Array.from before computing the standard deviation. This method ignores undefined and NaN values; this is useful for ignoring missing data.every(iterable, test) ​Source · Returns true if the given test function returns true for every value in the given iterable. This method returns as soon as test returns a non-truthy value or all values are iterated over. Equivalent to array.every:jsd3.every(new Set([1, 3, 5, 7]), x => x & 1) // truesome(iterable, test) ​Source · Returns true if the given test function returns true for any value in the given iterable. This method returns as soon as test returns a truthy value or all values are iterated over. Equivalent to array.some:jsd3.some(new Set([0, 2, 3, 4]), x => x & 1) // true\n\nSearchK7.9.0GitHub️ 110.0kOn this pageSummarizing data ​Compute summary statistics.count(iterable, accessor) ​jsd3.count(penguins, (d) => d.body_mass_g) // 342Examples · Source · Returns the number of valid number values (i.e., not null, NaN, or undefined) in the specified iterable; accepts an accessor.min(iterable, accessor) ​Examples · Source · Returns the minimum value in the given iterable using natural order.jsd3.min([3, 2, 1, 1, 6, 2, 4]) // 1Unlike Math.min, d3.min does not coerce the inputs to numbers; for example, the minimum of the strings ["20", "3"] is "20", while the minimum of the numbers [20, 3] is 3.jsd3.min(["bob", "alice", "carol"]) // "alice"jsd3.min([new Date("2018-01-01"), new Date("2011-03-09")]) // 2011-03-09Also unlike Math.min, this method ignores undefined, null and NaN values, which is useful for ignoring missing data.jsd3.min([3, 2, 1, NaN, 4]) // 1An optional accessor function may be specified, which is similar to calling Array.from before computing the minimum value. The accessor function is repeatedly passed an element from the given iterable (often d) and the zero-based index (i).jsd3.min(alphabet, (d) => d.frequency) // 0.00074Because undefined values are ignored, you can use the accessor function to ignore values. For example, to get the frequency of the least-common letter than is not Z:jsd3.min(alphabet, (d) => d.letter === "Z" ? NaN : d.frequency) // 0.00095If the iterable contains no comparable values, returns undefined.jsd3.min([]) // undefinedjsd3.min(alphabet, (d) => d.doesnotexist) // undefinedSee also extent and least.minIndex(iterable, accessor) ​Source · Like min, but returns the index of the minimum value rather than the value itself.jsd3.minIndex([3, 2, 1, 1, 6, 2, 4]) // 2This method can find the least element according to the given accessor, similar to least:jsd3.minIndex(alphabet, (d) => d.frequency) // 25jsalphabet[d3.minIndex(alphabet, (d) => d.frequency)] // {letter: "Z", frequency: 0.00074}See also leastIndex.max(iterable, accessor) ​Examples · Source · Returns the maximum value in the given iterable using natural order.jsd3.max([3, 2, 1, 1, 6, 2, 4]) // 6Unlike Math.max, d3.max does not coerce the inputs to numbers; for example, the maximum of the strings ["20", "3"] is "3", while the maximum of the numbers [20, 3] is 20.jsd3.max(["bob", "alice", "carol"]) // "carol"jsd3.max([new Date("2018-01-01"), new Date("2011-03-09")]) // 2018-01-01Also unlike Math.max, this method ignores undefined, null and NaN values, which is useful for ignoring missing data.jsd3.max([3, 2, 1, NaN, 4]) // 4An optional accessor function may be specified, which is similar to calling Array.from before computing the maximum value. The accessor function is repeatedly passed an element from the given iterable (often d) and the zero-based index (i).jsd3.max(alphabet, (d) => d.frequency) // 0.12702Because undefined values are ignored, you can use the accessor function to ignore values. For example, to get the frequency of the most-common letter than is not E:jsd3.max(alphabet, (d) => d.letter === "E" ? NaN : d.frequency) // 0.09056If the iterable contains no comparable values, returns undefined.jsd3.max([]) // undefinedjsd3.max(alphabet, (d) => d.doesnotexist) // undefinedSee also extent and greatest.maxIndex(iterable, accessor) ​Source · Like max, but returns the index of the maximum value rather than the value itself.jsd3.maxIndex([3, 2, 1, 1, 6, 2, 4]) // 2This method can find the greatest element according to the given accessor, similar to greatest:jsd3.maxIndex(alphabet, (d) => d.frequency) // 0jsalphabet[d3.maxIndex(alphabet, (d) => d.frequency)] // {letter: "E", frequency: 0.12702}See also greatestIndex.least(iterable, comparator) ​Examples · Source · Returns the least element of the specified iterable according to the specified comparator.jsd3.least(alphabet, (a, b) => a.frequency - b.frequency) // {letter: "Z", frequency: 0.00074}jsd3.least(alphabet, (a, b) => b.frequency - a.frequency) // {letter: "E", frequency: 0.12702}If the comparator takes a single argument, is interpreted as an accessor and the returned elements are compared using natural order.jsd3.least(alphabet, (d) => d.frequency) // {letter: "Z", frequency: 0.00074}jsd3.least(alphabet, (d) => -d.frequency) // {letter: "E", frequency: 0.12702}If comparator is not specified, it defaults to ascending.jsd3.least(alphabet.map((d) => d.frequency)) // 0.00074If the given iterable contains no comparable elements (i.e., the comparator returns NaN when comparing each element to itself), returns undefined.jsd3.least([]) // undefinedThis function is similar to min, except it allows the use of a comparator rather than an accessor.leastIndex(iterable, comparator) ​Source · Returns the index of the least element of the specified iterable according to the specified comparator or accessor. If the given iterable contains no comparable elements (i.e., the comparator returns NaN when comparing each element to itself), returns -1. If comparator is not specified, it defaults to ascending. For example:jsconst array = [{foo: 42}, {foo: 91}];
d3.leastIndex(array, (a, b) => a.foo - b.foo); // 0
d3.leastIndex(array, (a, b) => b.foo - a.foo); // 1
d3.leastIndex(array, (d) => d.foo); // 0This function is similar to minIndex, except it allows the use of a comparator rather than an accessor.greatest(iterable, comparator) ​Examples · Source · Returns the greatest element of the specified iterable according to the specified comparator or accessor. If the given iterable contains no comparable elements (i.e., the comparator returns NaN when comparing each element to itself), returns undefined. If comparator is not specified, it defaults to ascending. For example:jsconst array = [{foo: 42}, {foo: 91}];
d3.greatest(array, (a, b) => a.foo - b.foo); // {foo: 91}
d3.greatest(array, (a, b) => b.foo - a.foo); // {foo: 42}
d3.greatest(array, (d) => d.foo); // {foo: 91}This function is similar to max, except it allows the use of a comparator rather than an accessor.greatestIndex(iterable, comparator) ​Source · Returns the index of the greatest element of the specified iterable according to the specified comparator or accessor. If the given iterable contains no comparable elements (i.e., the comparator returns NaN when comparing each element to itself), returns -1. If comparator is not specified, it defaults to ascending. For example:jsconst array = [{foo: 42}, {foo: 91}];
d3.greatestIndex(array, (a, b) => a.foo - b.foo); // 1
d3.greatestIndex(array, (a, b) => b.foo - a.foo); // 0
d3.greatestIndex(array, (d) => d.foo); // 1This function is similar to maxIndex, except it allows the use of a comparator rather than an accessor.extent(iterable, accessor) ​Examples · Source · Returns the minimum and maximum value in the given iterable using natural order.jsd3.extent([3, 2, 1, 1, 6, 2, 4]) // [1, 6]An optional accessor function may be specified, which is equivalent to calling Array.from before computing the extent.jsd3.extent(alphabet, (d) => d.frequency) // [0.00074, 0.12702]If the iterable contains no comparable values, returns [undefined, undefined].jsd3.extent(alphabet, (d) => d.doesnotexist) // [undefined, undefined]mode(iterable, accessor) ​Examples · Source · Returns the mode of the given iterable, i.e. the value which appears the most often. Ignores undefined, null and NaN values.jsd3.mode([1, 2, 2, 2, 3, 3]) // 2An optional accessor function may be specified, which is equivalent to calling Array.from before computing the mode.jsd3.mode(penguins, (d) => d.island) // "Biscoe"In case of equality, returns the first of the relevant values. If the iterable contains no comparable values, returns undefined.sum(iterable, accessor) ​Examples · Source · Returns the sum of the given iterable of numbers. Ignores undefined, null and NaN values.jsd3.sum([1, 2, 2, 2, NaN, 3, null]) // 10An optional accessor function may be specified, which is equivalent to calling Array.from before computing the sum.jsd3.sum(penguins, (d) => d.body_mass_g) // 1437000If the iterable contains no numbers, returns 0. See also fsum.mean(iterable, accessor) ​Examples · Source · Returns the mean of the given iterable of numbers. Ignores undefined, null and NaN values.jsd3.mean([1, 2, 2, 2, NaN, 3, null]) // 2An optional accessor function may be specified, which is equivalent to calling Array.from before computing the mean.jsd3.mean(penguins, (d) => d.body_mass_g) // 4201.754385964912If the iterable contains no numbers, returns undefined.median(iterable, accessor) ​Examples · Source · Returns the median of the given iterable of numbers using the R-7 method. Ignores undefined, null and NaN values.jsd3.median([1, 2, 2, 2, NaN, 3, null]) // 2An optional accessor function may be specified, which is equivalent to calling Array.from before computing the median.jsd3.median(penguins, (d) => d.body_mass_g) // 4050If the iterable contains no numbers, returns undefined.medianIndex(array, accessor) ​Source · Like median, but returns the index of the element to the left of the median.jsd3.medianIndex([1, 2, 2, 2, NaN, 3, null]) // 2cumsum(iterable, accessor) ​Examples · Source · Returns the cumulative sum of the given iterable of numbers, as a Float64Array of the same length.jsd3.cumsum([1, 1, 2, 3, 5]) // [1, 2, 4, 7, 12]An optional accessor function may be specified, which is equivalent to calling Array.from before computing the cumulative sum.jsd3.cumsum(penguins, (d) => d.body_mass_g) // [3750, 7550, 10800, 10800, …]This method ignores undefined and NaN values; this is useful for ignoring missing data. If the iterable contains no numbers, returns zeros. See also fcumsum.quantile(iterable, p, accessor) ​Examples · Source · Returns the p-quantile of the given iterable of numbers, where p is a number in the range [0, 1]. For example, the median can be computed using p = 0.5, the first quartile at p = 0.25, and the third quartile at p = 0.75. This particular implementation uses the R-7 method, which is the default for the R programming language and Excel.jsconst numbers = [0, 10, 30];
d3.quantile(numbers, 0); // 0
d3.quantile(numbers, 0.5); // 10
d3.quantile(numbers, 1); // 30
d3.quantile(numbers, 0.25); // 5
d3.quantile(numbers, 0.75); // 20
d3.quantile(numbers, 0.1); // 2An optional accessor function may be specified, which is equivalent to calling array.map before computing the quantile.quantileIndex(array, p, accessor) ​Source · Similar to quantile, but returns the index to the left of p.quantileSorted(array, p, accessor) ​Examples · Source · Similar to quantile, but expects the input to be a sorted array of values. In contrast with quantile, the accessor is only called on the elements needed to compute the quantile.rank(iterable, comparator) ​Examples · Source · Returns an array with the rank of each value in the iterable, i.e. the zero-based index of the value when the iterable is sorted. Nullish values are sorted to the end and ranked NaN. An optional comparator or accessor function may be specified; the latter is equivalent to calling array.map before computing the ranks. If comparator is not specified, it defaults to ascending. Ties (equivalent values) all get the same rank, defined as the first time the value is found.jsd3.rank([{x: 1}, {}, {x: 2}, {x: 0}], d => d.x); // [1, NaN, 2, 0]
d3.rank(["b", "c", "b", "a"]); // [1, 3, 1, 0]
d3.rank([1, 2, 3], d3.descending); // [2, 1, 0]variance(iterable, accessor) ​Examples · Source · Returns an unbiased estimator of the population variance of the given iterable of numbers using Welford’s algorithm. If the iterable has fewer than two numbers, returns undefined. An optional accessor function may be specified, which is equivalent to calling Array.from before computing the variance. This method ignores undefined and NaN values; this is useful for ignoring missing data.deviation(iterable, accessor) ​Examples · Source · Returns the standard deviation, defined as the square root of the bias-corrected variance, of the given iterable of numbers. If the iterable has fewer than two numbers, returns undefined. An optional accessor function may be specified, which is equivalent to calling Array.from before computing the standard deviation. This method ignores undefined and NaN values; this is useful for ignoring missing data.every(iterable, test) ​Source · Returns true if the given test function returns true for every value in the given iterable. This method returns as soon as test returns a non-truthy value or all values are iterated over. Equivalent to array.every:jsd3.every(new Set([1, 3, 5, 7]), x => x & 1) // truesome(iterable, test) ​Source · Returns true if the given test function returns true for any value in the given iterable. This method returns as soon as test returns a truthy value or all values are iterated over. Equivalent to array.some:jsd3.some(new Set([0, 2, 3, 4]), x => x & 1) // truePagerPrevious pageSorting dataNext pageTicks\n\nSummarizing data ​Compute summary statistics.count(iterable, accessor) ​jsd3.count(penguins, (d) => d.body_mass_g) // 342Examples · Source · Returns the number of valid number values (i.e., not null, NaN, or undefined) in the specified iterable; accepts an accessor.min(iterable, accessor) ​Examples · Source · Returns the minimum value in the given iterable using natural order.jsd3.min([3, 2, 1, 1, 6, 2, 4]) // 1Unlike Math.min, d3.min does not coerce the inputs to numbers; for example, the minimum of the strings ["20", "3"] is "20", while the minimum of the numbers [20, 3] is 3.jsd3.min(["bob", "alice", "carol"]) // "alice"jsd3.min([new Date("2018-01-01"), new Date("2011-03-09")]) // 2011-03-09Also unlike Math.min, this method ignores undefined, null and NaN values, which is useful for ignoring missing data.jsd3.min([3, 2, 1, NaN, 4]) // 1An optional accessor function may be specified, which is similar to calling Array.from before computing the minimum value. The accessor function is repeatedly passed an element from the given iterable (often d) and the zero-based index (i).jsd3.min(alphabet, (d) => d.frequency) // 0.00074Because undefined values are ignored, you can use the accessor function to ignore values. For example, to get the frequency of the least-common letter than is not Z:jsd3.min(alphabet, (d) => d.letter === "Z" ? NaN : d.frequency) // 0.00095If the iterable contains no comparable values, returns undefined.jsd3.min([]) // undefinedjsd3.min(alphabet, (d) => d.doesnotexist) // undefinedSee also extent and least.minIndex(iterable, accessor) ​Source · Like min, but returns the index of the minimum value rather than the value itself.jsd3.minIndex([3, 2, 1, 1, 6, 2, 4]) // 2This method can find the least element according to the given accessor, similar to least:jsd3.minIndex(alphabet, (d) => d.frequency) // 25jsalphabet[d3.minIndex(alphabet, (d) => d.frequency)] // {letter: "Z", frequency: 0.00074}See also leastIndex.max(iterable, accessor) ​Examples · Source · Returns the maximum value in the given iterable using natural order.jsd3.max([3, 2, 1, 1, 6, 2, 4]) // 6Unlike Math.max, d3.max does not coerce the inputs to numbers; for example, the maximum of the strings ["20", "3"] is "3", while the maximum of the numbers [20, 3] is 20.jsd3.max(["bob", "alice", "carol"]) // "carol"jsd3.max([new Date("2018-01-01"), new Date("2011-03-09")]) // 2018-01-01Also unlike Math.max, this method ignores undefined, null and NaN values, which is useful for ignoring missing data.jsd3.max([3, 2, 1, NaN, 4]) // 4An optional accessor function may be specified, which is similar to calling Array.from before computing the maximum value. The accessor function is repeatedly passed an element from the given iterable (often d) and the zero-based index (i).jsd3.max(alphabet, (d) => d.frequency) // 0.12702Because undefined values are ignored, you can use the accessor function to ignore values. For example, to get the frequency of the most-common letter than is not E:jsd3.max(alphabet, (d) => d.letter === "E" ? NaN : d.frequency) // 0.09056If the iterable contains no comparable values, returns undefined.jsd3.max([]) // undefinedjsd3.max(alphabet, (d) => d.doesnotexist) // undefinedSee also extent and greatest.maxIndex(iterable, accessor) ​Source · Like max, but returns the index of the maximum value rather than the value itself.jsd3.maxIndex([3, 2, 1, 1, 6, 2, 4]) // 2This method can find the greatest element according to the given accessor, similar to greatest:jsd3.maxIndex(alphabet, (d) => d.frequency) // 0jsalphabet[d3.maxIndex(alphabet, (d) => d.frequency)] // {letter: "E", frequency: 0.12702}See also greatestIndex.least(iterable, comparator) ​Examples · Source · Returns the least element of the specified iterable according to the specified comparator.jsd3.least(alphabet, (a, b) => a.frequency - b.frequency) // {letter: "Z", frequency: 0.00074}jsd3.least(alphabet, (a, b) => b.frequency - a.frequency) // {letter: "E", frequency: 0.12702}If the comparator takes a single argument, is interpreted as an accessor and the returned elements are compared using natural order.jsd3.least(alphabet, (d) => d.frequency) // {letter: "Z", frequency: 0.00074}jsd3.least(alphabet, (d) => -d.frequency) // {letter: "E", frequency: 0.12702}If comparator is not specified, it defaults to ascending.jsd3.least(alphabet.map((d) => d.frequency)) // 0.00074If the given iterable contains no comparable elements (i.e., the comparator returns NaN when comparing each element to itself), returns undefined.jsd3.least([]) // undefinedThis function is similar to min, except it allows the use of a comparator rather than an accessor.leastIndex(iterable, comparator) ​Source · Returns the index of the least element of the specified iterable according to the specified comparator or accessor. If the given iterable contains no comparable elements (i.e., the comparator returns NaN when comparing each element to itself), returns -1. If comparator is not specified, it defaults to ascending. For example:jsconst array = [{foo: 42}, {foo: 91}];
d3.leastIndex(array, (a, b) => a.foo - b.foo); // 0
d3.leastIndex(array, (a, b) => b.foo - a.foo); // 1
d3.leastIndex(array, (d) => d.foo); // 0This function is similar to minIndex, except it allows the use of a comparator rather than an accessor.greatest(iterable, comparator) ​Examples · Source · Returns the greatest element of the specified iterable according to the specified comparator or accessor. If the given iterable contains no comparable elements (i.e., the comparator returns NaN when comparing each element to itself), returns undefined. If comparator is not specified, it defaults to ascending. For example:jsconst array = [{foo: 42}, {foo: 91}];
d3.greatest(array, (a, b) => a.foo - b.foo); // {foo: 91}
d3.greatest(array, (a, b) => b.foo - a.foo); // {foo: 42}
d3.greatest(array, (d) => d.foo); // {foo: 91}This function is similar to max, except it allows the use of a comparator rather than an accessor.greatestIndex(iterable, comparator) ​Source · Returns the index of the greatest element of the specified iterable according to the specified comparator or accessor. If the given iterable contains no comparable elements (i.e., the comparator returns NaN when comparing each element to itself), returns -1. If comparator is not specified, it defaults to ascending. For example:jsconst array = [{foo: 42}, {foo: 91}];
d3.greatestIndex(array, (a, b) => a.foo - b.foo); // 1
d3.greatestIndex(array, (a, b) => b.foo - a.foo); // 0
d3.greatestIndex(array, (d) => d.foo); // 1This function is similar to maxIndex, except it allows the use of a comparator rather than an accessor.extent(iterable, accessor) ​Examples · Source · Returns the minimum and maximum value in the given iterable using natural order.jsd3.extent([3, 2, 1, 1, 6, 2, 4]) // [1, 6]An optional accessor function may be specified, which is equivalent to calling Array.from before computing the extent.jsd3.extent(alphabet, (d) => d.frequency) // [0.00074, 0.12702]If the iterable contains no comparable values, returns [undefined, undefined].jsd3.extent(alphabet, (d) => d.doesnotexist) // [undefined, undefined]mode(iterable, accessor) ​Examples · Source · Returns the mode of the given iterable, i.e. the value which appears the most often. Ignores undefined, null and NaN values.jsd3.mode([1, 2, 2, 2, 3, 3]) // 2An optional accessor function may be specified, which is equivalent to calling Array.from before computing the mode.jsd3.mode(penguins, (d) => d.island) // "Biscoe"In case of equality, returns the first of the relevant values. If the iterable contains no comparable values, returns undefined.sum(iterable, accessor) ​Examples · Source · Returns the sum of the given iterable of numbers. Ignores undefined, null and NaN values.jsd3.sum([1, 2, 2, 2, NaN, 3, null]) // 10An optional accessor function may be specified, which is equivalent to calling Array.from before computing the sum.jsd3.sum(penguins, (d) => d.body_mass_g) // 1437000If the iterable contains no numbers, returns 0. See also fsum.mean(iterable, accessor) ​Examples · Source · Returns the mean of the given iterable of numbers. Ignores undefined, null and NaN values.jsd3.mean([1, 2, 2, 2, NaN, 3, null]) // 2An optional accessor function may be specified, which is equivalent to calling Array.from before computing the mean.jsd3.mean(penguins, (d) => d.body_mass_g) // 4201.754385964912If the iterable contains no numbers, returns undefined.median(iterable, accessor) ​Examples · Source · Returns the median of the given iterable of numbers using the R-7 method. Ignores undefined, null and NaN values.jsd3.median([1, 2, 2, 2, NaN, 3, null]) // 2An optional accessor function may be specified, which is equivalent to calling Array.from before computing the median.jsd3.median(penguins, (d) => d.body_mass_g) // 4050If the iterable contains no numbers, returns undefined.medianIndex(array, accessor) ​Source · Like median, but returns the index of the element to the left of the median.jsd3.medianIndex([1, 2, 2, 2, NaN, 3, null]) // 2cumsum(iterable, accessor) ​Examples · Source · Returns the cumulative sum of the given iterable of numbers, as a Float64Array of the same length.jsd3.cumsum([1, 1, 2, 3, 5]) // [1, 2, 4, 7, 12]An optional accessor function may be specified, which is equivalent to calling Array.from before computing the cumulative sum.jsd3.cumsum(penguins, (d) => d.body_mass_g) // [3750, 7550, 10800, 10800, …]This method ignores undefined and NaN values; this is useful for ignoring missing data. If the iterable contains no numbers, returns zeros. See also fcumsum.quantile(iterable, p, accessor) ​Examples · Source · Returns the p-quantile of the given iterable of numbers, where p is a number in the range [0, 1]. For example, the median can be computed using p = 0.5, the first quartile at p = 0.25, and the third quartile at p = 0.75. This particular implementation uses the R-7 method, which is the default for the R programming language and Excel.jsconst numbers = [0, 10, 30];
d3.quantile(numbers, 0); // 0
d3.quantile(numbers, 0.5); // 10
d3.quantile(numbers, 1); // 30
d3.quantile(numbers, 0.25); // 5
d3.quantile(numbers, 0.75); // 20
d3.quantile(numbers, 0.1); // 2An optional accessor function may be specified, which is equivalent to calling array.map before computing the quantile.quantileIndex(array, p, accessor) ​Source · Similar to quantile, but returns the index to the left of p.quantileSorted(array, p, accessor) ​Examples · Source · Similar to quantile, but expects the input to be a sorted array of values. In contrast with quantile, the accessor is only called on the elements needed to compute the quantile.rank(iterable, comparator) ​Examples · Source · Returns an array with the rank of each value in the iterable, i.e. the zero-based index of the value when the iterable is sorted. Nullish values are sorted to the end and ranked NaN. An optional comparator or accessor function may be specified; the latter is equivalent to calling array.map before computing the ranks. If comparator is not specified, it defaults to ascending. Ties (equivalent values) all get the same rank, defined as the first time the value is found.jsd3.rank([{x: 1}, {}, {x: 2}, {x: 0}], d => d.x); // [1, NaN, 2, 0]
d3.rank(["b", "c", "b", "a"]); // [1, 3, 1, 0]
d3.rank([1, 2, 3], d3.descending); // [2, 1, 0]variance(iterable, accessor) ​Examples · Source · Returns an unbiased estimator of the population variance of the given iterable of numbers using Welford’s algorithm. If the iterable has fewer than two numbers, returns undefined. An optional accessor function may be specified, which is equivalent to calling Array.from before computing the variance. This method ignores undefined and NaN values; this is useful for ignoring missing data.deviation(iterable, accessor) ​Examples · Source · Returns the standard deviation, defined as the square root of the bias-corrected variance, of the given iterable of numbers. If the iterable has fewer than two numbers, returns undefined. An optional accessor function may be specified, which is equivalent to calling Array.from before computing the standard deviation. This method ignores undefined and NaN values; this is useful for ignoring missing data.every(iterable, test) ​Source · Returns true if the given test function returns true for every value in the given iterable. This method returns as soon as test returns a non-truthy value or all values are iterated over. Equivalent to array.every:jsd3.every(new Set([1, 3, 5, 7]), x => x & 1) // truesome(iterable, test) ​Source · Returns true if the given test function returns true for any value in the given iterable. This method returns as soon as test returns a truthy value or all values are iterated over. Equivalent to array.some:jsd3.some(new Set([0, 2, 3, 4]), x => x & 1) // true\n\n\n\nTicks ​Generate representative values from a continuous interval.ticks(start, stop, count) ​Examples · Source · Returns an array of approximately count + 1 uniformly-spaced, nicely-rounded values between start and stop (inclusive). Each value is a power of ten multiplied by 1, 2 or 5.jsd3.ticks(1, 9, 5) // [2, 4, 6, 8]jsd3.ticks(1, 9, 20) // [1, 1.5, 2, 2.5, 3, 3.5, 4, 4.5, 5, 5.5, 6, 6.5, 7, 7.5, 8, 8.5, 9]Ticks are inclusive in the sense that they may include the specified start and stop values if (and only if) they are exact, nicely-rounded values consistent with the inferred step. More formally, each returned tick t satisfies start ≤ t and t ≤ stop.tickIncrement(start, stop, count) ​Source · Like d3.tickStep, except requires that start is always less than or equal to stop, and if the tick step for the given start, stop and count would be less than one, returns the negative inverse tick step instead.jsd3.tickIncrement(1, 9, 5) // 2jsd3.tickIncrement(1, 9, 20) // -2, meaning a tick step 0.5This method is always guaranteed to return an integer, and is used by d3.ticks to guarantee that the returned tick values are represented as precisely as possible in IEEE 754 floating point.tickStep(start, stop, count) ​Source · Returns the difference between adjacent tick values if the same arguments were passed to d3.ticks: a nicely-rounded value that is a power of ten multiplied by 1, 2 or 5.jsd3.tickStep(1, 9, 5) // 2If stop is less than start, may return a negative tick step to indicate descending ticks.jsd3.tickStep(9, 1, 5) // -2Note that due to the limited precision of IEEE 754 floating point, the returned value may not be exact decimals; use d3-format to format numbers for human consumption.nice(start, stop, count) ​Source · Returns a new interval [niceStart, niceStop] covering the given interval [start, stop] and where niceStart and niceStop are guaranteed to align with the corresponding tick step.jsd3.nice(1, 9, 5) // [0, 10]Like d3.tickIncrement, this requires that start is less than or equal to stop.range(start, stop, step) ​Examples · Source · Returns an array containing an arithmetic progression, similar to the Python built-in range. This method is often used to iterate over a sequence of uniformly-spaced numeric values, such as the indexes of an array or the ticks of a linear scale. (See also d3.ticks for nicely-rounded values.)jsd3.range(6) // [0, 1, 2, 3, 4, 5]If step is omitted, it defaults to 1. If start is omitted, it defaults to 0. The stop value is exclusive; it is not included in the result. If step is positive, the last element is the largest start + i * step less than stop; if step is negative, the last element is the smallest start + i * step greater than stop.jsd3.range(5, -1, -1) // [5, 4, 3, 2, 1, 0]If the returned array would contain an infinite number of values, an empty range is returned.jsd3.range(Infinity) // []The arguments are not required to be integers; however, the results are more predictable if they are. The values in the returned array are defined as start + i * step, where i is an integer from zero to one minus the total number of elements in the returned array.jsd3.range(0, 1, 0.2) // [0, 0.2, 0.4, 0.6000000000000001, 0.8]This behavior is due to IEEE 754 double-precision floating point, which defines 0.2 * 3 = 0.6000000000000001. Use d3-format to format numbers for human consumption with appropriate rounding; see also linear.tickFormat in d3-scale. Likewise, if the returned array should have a specific length, consider using array.map on an integer range.jsd3.range(0, 1, 1 / 49) // 👎 returns 50 elements!jsd3.range(49).map((d) => d / 49) // 👍 returns 49 elements\n\nSearchK7.9.0GitHub️ 110.0kOn this pageTicks ​Generate representative values from a continuous interval.ticks(start, stop, count) ​Examples · Source · Returns an array of approximately count + 1 uniformly-spaced, nicely-rounded values between start and stop (inclusive). Each value is a power of ten multiplied by 1, 2 or 5.jsd3.ticks(1, 9, 5) // [2, 4, 6, 8]jsd3.ticks(1, 9, 20) // [1, 1.5, 2, 2.5, 3, 3.5, 4, 4.5, 5, 5.5, 6, 6.5, 7, 7.5, 8, 8.5, 9]Ticks are inclusive in the sense that they may include the specified start and stop values if (and only if) they are exact, nicely-rounded values consistent with the inferred step. More formally, each returned tick t satisfies start ≤ t and t ≤ stop.tickIncrement(start, stop, count) ​Source · Like d3.tickStep, except requires that start is always less than or equal to stop, and if the tick step for the given start, stop and count would be less than one, returns the negative inverse tick step instead.jsd3.tickIncrement(1, 9, 5) // 2jsd3.tickIncrement(1, 9, 20) // -2, meaning a tick step 0.5This method is always guaranteed to return an integer, and is used by d3.ticks to guarantee that the returned tick values are represented as precisely as possible in IEEE 754 floating point.tickStep(start, stop, count) ​Source · Returns the difference between adjacent tick values if the same arguments were passed to d3.ticks: a nicely-rounded value that is a power of ten multiplied by 1, 2 or 5.jsd3.tickStep(1, 9, 5) // 2If stop is less than start, may return a negative tick step to indicate descending ticks.jsd3.tickStep(9, 1, 5) // -2Note that due to the limited precision of IEEE 754 floating point, the returned value may not be exact decimals; use d3-format to format numbers for human consumption.nice(start, stop, count) ​Source · Returns a new interval [niceStart, niceStop] covering the given interval [start, stop] and where niceStart and niceStop are guaranteed to align with the corresponding tick step.jsd3.nice(1, 9, 5) // [0, 10]Like d3.tickIncrement, this requires that start is less than or equal to stop.range(start, stop, step) ​Examples · Source · Returns an array containing an arithmetic progression, similar to the Python built-in range. This method is often used to iterate over a sequence of uniformly-spaced numeric values, such as the indexes of an array or the ticks of a linear scale. (See also d3.ticks for nicely-rounded values.)jsd3.range(6) // [0, 1, 2, 3, 4, 5]If step is omitted, it defaults to 1. If start is omitted, it defaults to 0. The stop value is exclusive; it is not included in the result. If step is positive, the last element is the largest start + i * step less than stop; if step is negative, the last element is the smallest start + i * step greater than stop.jsd3.range(5, -1, -1) // [5, 4, 3, 2, 1, 0]If the returned array would contain an infinite number of values, an empty range is returned.jsd3.range(Infinity) // []The arguments are not required to be integers; however, the results are more predictable if they are. The values in the returned array are defined as start + i * step, where i is an integer from zero to one minus the total number of elements in the returned array.jsd3.range(0, 1, 0.2) // [0, 0.2, 0.4, 0.6000000000000001, 0.8]This behavior is due to IEEE 754 double-precision floating point, which defines 0.2 * 3 = 0.6000000000000001. Use d3-format to format numbers for human consumption with appropriate rounding; see also linear.tickFormat in d3-scale. Likewise, if the returned array should have a specific length, consider using array.map on an integer range.jsd3.range(0, 1, 1 / 49) // 👎 returns 50 elements!jsd3.range(49).map((d) => d / 49) // 👍 returns 49 elementsPagerPrevious pageSummarizing dataNext pageTransforming data\n\nTicks ​Generate representative values from a continuous interval.ticks(start, stop, count) ​Examples · Source · Returns an array of approximately count + 1 uniformly-spaced, nicely-rounded values between start and stop (inclusive). Each value is a power of ten multiplied by 1, 2 or 5.jsd3.ticks(1, 9, 5) // [2, 4, 6, 8]jsd3.ticks(1, 9, 20) // [1, 1.5, 2, 2.5, 3, 3.5, 4, 4.5, 5, 5.5, 6, 6.5, 7, 7.5, 8, 8.5, 9]Ticks are inclusive in the sense that they may include the specified start and stop values if (and only if) they are exact, nicely-rounded values consistent with the inferred step. More formally, each returned tick t satisfies start ≤ t and t ≤ stop.tickIncrement(start, stop, count) ​Source · Like d3.tickStep, except requires that start is always less than or equal to stop, and if the tick step for the given start, stop and count would be less than one, returns the negative inverse tick step instead.jsd3.tickIncrement(1, 9, 5) // 2jsd3.tickIncrement(1, 9, 20) // -2, meaning a tick step 0.5This method is always guaranteed to return an integer, and is used by d3.ticks to guarantee that the returned tick values are represented as precisely as possible in IEEE 754 floating point.tickStep(start, stop, count) ​Source · Returns the difference between adjacent tick values if the same arguments were passed to d3.ticks: a nicely-rounded value that is a power of ten multiplied by 1, 2 or 5.jsd3.tickStep(1, 9, 5) // 2If stop is less than start, may return a negative tick step to indicate descending ticks.jsd3.tickStep(9, 1, 5) // -2Note that due to the limited precision of IEEE 754 floating point, the returned value may not be exact decimals; use d3-format to format numbers for human consumption.nice(start, stop, count) ​Source · Returns a new interval [niceStart, niceStop] covering the given interval [start, stop] and where niceStart and niceStop are guaranteed to align with the corresponding tick step.jsd3.nice(1, 9, 5) // [0, 10]Like d3.tickIncrement, this requires that start is less than or equal to stop.range(start, stop, step) ​Examples · Source · Returns an array containing an arithmetic progression, similar to the Python built-in range. This method is often used to iterate over a sequence of uniformly-spaced numeric values, such as the indexes of an array or the ticks of a linear scale. (See also d3.ticks for nicely-rounded values.)jsd3.range(6) // [0, 1, 2, 3, 4, 5]If step is omitted, it defaults to 1. If start is omitted, it defaults to 0. The stop value is exclusive; it is not included in the result. If step is positive, the last element is the largest start + i * step less than stop; if step is negative, the last element is the smallest start + i * step greater than stop.jsd3.range(5, -1, -1) // [5, 4, 3, 2, 1, 0]If the returned array would contain an infinite number of values, an empty range is returned.jsd3.range(Infinity) // []The arguments are not required to be integers; however, the results are more predictable if they are. The values in the returned array are defined as start + i * step, where i is an integer from zero to one minus the total number of elements in the returned array.jsd3.range(0, 1, 0.2) // [0, 0.2, 0.4, 0.6000000000000001, 0.8]This behavior is due to IEEE 754 double-precision floating point, which defines 0.2 * 3 = 0.6000000000000001. Use d3-format to format numbers for human consumption with appropriate rounding; see also linear.tickFormat in d3-scale. Likewise, if the returned array should have a specific length, consider using array.map on an integer range.jsd3.range(0, 1, 1 / 49) // 👎 returns 50 elements!jsd3.range(49).map((d) => d / 49) // 👍 returns 49 elements\n\n\n\nTransforming data ​Transform arrays and generate new arrays.cross(...iterables, reducer) ​Examples · Source · Returns the Cartesian product of the specified iterables.jsd3.cross([1, 2], ["x", "y"]) // [[1, "x"], [1, "y"], [2, "x"], [2, "y"]]If a reducer is specified, it is invoked for each combination of elements from each of the given iterables, and returns the corresponding reduced value.jsd3.cross([1, 2], ["x", "y"], (a, b) => a + b) // ["1x", "1y", "2x", "2y"]merge(iterables) ​Examples · Source · Merges the specified iterable of iterables into a new flat array. This method is similar to the built-in array.concat method, but is more convenient when you have an array of arrays or an iterable of iterables.jsd3.merge([[1], [2, 3]]) // [1, 2, 3]jsd3.merge(new Set([new Set([1]), new Set([2, 3])])) // [1, 2, 3]pairs(iterable, reducer) ​Examples · Source · Returns an array of adjacent pairs of elements from the specified iterable, in order. If the specified iterable has fewer than two elements, returns the empty array.jsd3.pairs([1, 2, 3, 4]) // [[1, 2], [2, 3], [3, 4]]If a reducer function is specified, it is successively passed an element i - 1 and element i from the iterable.jsd3.pairs([1, 1, 2, 3, 5], (a, b) => b - a) // [0, 1, 1, 2]transpose(matrix) ​Examples · Source · Uses the zip operator as a two-dimensional matrix transpose.jsd3.transpose([["Alice", "Bob", "Carol"], [32, 13, 14]]) // [["Alice", 32], ["Bob", 13], ["Carol", 14]]jsd3.transpose([["Alice", 32], ["Bob", 13], ["Carol", 14]]) // [["Alice", "Bob", "Carol"], [32, 13, 14]]zip(...arrays) ​Examples · Source · Returns an array of arrays, where the ith array contains the ith element from each of the argument arrays. The returned array is truncated in length to the shortest array in arrays. If arrays contains only a single array, the returned array contains one-element arrays. With no arguments, the returned array is empty.jsd3.zip(["Alice", "Bob", "Carol"], [32, 13, 14]) // [["Alice", 32], ["Bob", 13], ["Carol", 14]]filter(iterable, test) ​Source · Returns a new array containing the values from iterable, in order, for which the given test function returns true.jsd3.filter(new Set([0, 2, 3, 4]), (d) => d & 1) // [3]Like array.filter, but works with any iterable.map(iterable, mapper) ​Source · Returns a new array containing the mapped values from iterable, in order, as defined by given mapper function.jsd3.map(new Set([0, 2, 3, 4]), (d) => d & 1) // [0, 0, 1, 0]Like array.map, but works with any iterable.reduce(iterable, reducer, initialValue) ​Source · Returns the reduced value defined by given reducer function, which is repeatedly invoked for each value in iterable, being passed the current reduced value and the next value.jsd3.reduce(new Set([0, 2, 3, 4]), (p, v) => p + v, 0) // 9Like array.reduce, but works with any iterable.\n\nSearchK7.9.0GitHub️ 110.0kOn this pageTransforming data ​Transform arrays and generate new arrays.cross(...iterables, reducer) ​Examples · Source · Returns the Cartesian product of the specified iterables.jsd3.cross([1, 2], ["x", "y"]) // [[1, "x"], [1, "y"], [2, "x"], [2, "y"]]If a reducer is specified, it is invoked for each combination of elements from each of the given iterables, and returns the corresponding reduced value.jsd3.cross([1, 2], ["x", "y"], (a, b) => a + b) // ["1x", "1y", "2x", "2y"]merge(iterables) ​Examples · Source · Merges the specified iterable of iterables into a new flat array. This method is similar to the built-in array.concat method, but is more convenient when you have an array of arrays or an iterable of iterables.jsd3.merge([[1], [2, 3]]) // [1, 2, 3]jsd3.merge(new Set([new Set([1]), new Set([2, 3])])) // [1, 2, 3]pairs(iterable, reducer) ​Examples · Source · Returns an array of adjacent pairs of elements from the specified iterable, in order. If the specified iterable has fewer than two elements, returns the empty array.jsd3.pairs([1, 2, 3, 4]) // [[1, 2], [2, 3], [3, 4]]If a reducer function is specified, it is successively passed an element i - 1 and element i from the iterable.jsd3.pairs([1, 1, 2, 3, 5], (a, b) => b - a) // [0, 1, 1, 2]transpose(matrix) ​Examples · Source · Uses the zip operator as a two-dimensional matrix transpose.jsd3.transpose([["Alice", "Bob", "Carol"], [32, 13, 14]]) // [["Alice", 32], ["Bob", 13], ["Carol", 14]]jsd3.transpose([["Alice", 32], ["Bob", 13], ["Carol", 14]]) // [["Alice", "Bob", "Carol"], [32, 13, 14]]zip(...arrays) ​Examples · Source · Returns an array of arrays, where the ith array contains the ith element from each of the argument arrays. The returned array is truncated in length to the shortest array in arrays. If arrays contains only a single array, the returned array contains one-element arrays. With no arguments, the returned array is empty.jsd3.zip(["Alice", "Bob", "Carol"], [32, 13, 14]) // [["Alice", 32], ["Bob", 13], ["Carol", 14]]filter(iterable, test) ​Source · Returns a new array containing the values from iterable, in order, for which the given test function returns true.jsd3.filter(new Set([0, 2, 3, 4]), (d) => d & 1) // [3]Like array.filter, but works with any iterable.map(iterable, mapper) ​Source · Returns a new array containing the mapped values from iterable, in order, as defined by given mapper function.jsd3.map(new Set([0, 2, 3, 4]), (d) => d & 1) // [0, 0, 1, 0]Like array.map, but works with any iterable.reduce(iterable, reducer, initialValue) ​Source · Returns the reduced value defined by given reducer function, which is repeatedly invoked for each value in iterable, being passed the current reduced value and the next value.jsd3.reduce(new Set([0, 2, 3, 4]), (p, v) => p + v, 0) // 9Like array.reduce, but works with any iterable.PagerPrevious pageTicksNext paged3-dsv\n\nTransforming data ​Transform arrays and generate new arrays.cross(...iterables, reducer) ​Examples · Source · Returns the Cartesian product of the specified iterables.jsd3.cross([1, 2], ["x", "y"]) // [[1, "x"], [1, "y"], [2, "x"], [2, "y"]]If a reducer is specified, it is invoked for each combination of elements from each of the given iterables, and returns the corresponding reduced value.jsd3.cross([1, 2], ["x", "y"], (a, b) => a + b) // ["1x", "1y", "2x", "2y"]merge(iterables) ​Examples · Source · Merges the specified iterable of iterables into a new flat array. This method is similar to the built-in array.concat method, but is more convenient when you have an array of arrays or an iterable of iterables.jsd3.merge([[1], [2, 3]]) // [1, 2, 3]jsd3.merge(new Set([new Set([1]), new Set([2, 3])])) // [1, 2, 3]pairs(iterable, reducer) ​Examples · Source · Returns an array of adjacent pairs of elements from the specified iterable, in order. If the specified iterable has fewer than two elements, returns the empty array.jsd3.pairs([1, 2, 3, 4]) // [[1, 2], [2, 3], [3, 4]]If a reducer function is specified, it is successively passed an element i - 1 and element i from the iterable.jsd3.pairs([1, 1, 2, 3, 5], (a, b) => b - a) // [0, 1, 1, 2]transpose(matrix) ​Examples · Source · Uses the zip operator as a two-dimensional matrix transpose.jsd3.transpose([["Alice", "Bob", "Carol"], [32, 13, 14]]) // [["Alice", 32], ["Bob", 13], ["Carol", 14]]jsd3.transpose([["Alice", 32], ["Bob", 13], ["Carol", 14]]) // [["Alice", "Bob", "Carol"], [32, 13, 14]]zip(...arrays) ​Examples · Source · Returns an array of arrays, where the ith array contains the ith element from each of the argument arrays. The returned array is truncated in length to the shortest array in arrays. If arrays contains only a single array, the returned array contains one-element arrays. With no arguments, the returned array is empty.jsd3.zip(["Alice", "Bob", "Carol"], [32, 13, 14]) // [["Alice", 32], ["Bob", 13], ["Carol", 14]]filter(iterable, test) ​Source · Returns a new array containing the values from iterable, in order, for which the given test function returns true.jsd3.filter(new Set([0, 2, 3, 4]), (d) => d & 1) // [3]Like array.filter, but works with any iterable.map(iterable, mapper) ​Source · Returns a new array containing the mapped values from iterable, in order, as defined by given mapper function.jsd3.map(new Set([0, 2, 3, 4]), (d) => d & 1) // [0, 0, 1, 0]Like array.map, but works with any iterable.reduce(iterable, reducer, initialValue) ​Source · Returns the reduced value defined by given reducer function, which is repeatedly invoked for each value in iterable, being passed the current reduced value and the next value.jsd3.reduce(new Set([0, 2, 3, 4]), (p, v) => p + v, 0) // 9Like array.reduce, but works with any iterable.\n\n\n\nd3-dsv ​This module provides a parser and formatter for delimiter-separated values, most commonly comma-separated values (CSV) or tab-separated values (TSV). These tabular formats are popular with spreadsheet programs such as Microsoft Excel, and are often more space-efficient than JSON. This implementation is based on RFC 4180.For example, to parse:jsd3.csvParse("foo,bar\n1,2") // [{foo: "1", bar: "2"}, columns: ["foo", "bar"]]jsd3.tsvParse("foo\tbar\n1\t2") // [{foo: "1", bar: "2"}, columns: ["foo", "bar"]]To format:jsd3.csvFormat([{foo: "1", bar: "2"}]) // "foo,bar\n1,2"jsd3.tsvFormat([{foo: "1", bar: "2"}]) // "foo\tbar\n1\t2"To use a different delimiter, such as “|” for pipe-separated values, use d3.dsvFormat:jsd3.dsvFormat("|").parse("foo|bar\n1|2")) // [{foo: "1", bar: "2"}, columns: ["foo", "bar"]]For easy loading of DSV files in a browser, see d3-fetch’s d3.csv, d3.tsv and d3.dsv methods.dsvFormat(delimiter) ​jsconst csv = d3.dsvFormat(",");Source · Constructs a new DSV parser and formatter for the specified delimiter. The delimiter must be a single character (i.e., a single 16-bit code unit); so, ASCII delimiters are fine, but emoji delimiters are not.dsv.parse(string, row) ​CAUTIONThis method requires the unsafe-eval content security policy.jsd3.csvParse("foo,bar\n1,2") // [{foo: "1", bar: "2"}, columns: ["foo", "bar"]]Source · Parses the specified string, which must be in the delimiter-separated values format with the appropriate delimiter, returning an array of objects representing the parsed rows.Unlike dsv.parseRows, this method requires that the first line of the DSV content contains a delimiter-separated list of column names; these column names become the attributes on the returned objects. For example, consider the following CSV file:Year,Make,Model,Length
1997,Ford,E350,2.34
2000,Mercury,Cougar,2.38The resulting JavaScript array is:js[
  {"Year": "1997", "Make": "Ford", "Model": "E350", "Length": "2.34"},
  {"Year": "2000", "Make": "Mercury", "Model": "Cougar", "Length": "2.38"}
]The returned array also exposes a columns property containing the column names in input order (in contrast to Object.keys, whose iteration order is arbitrary). For example:jsdata.columns // ["Year", "Make", "Model", "Length"]If the column names are not unique, only the last value is returned for each name; to access all values, use dsv.parseRows instead (see example).If a row conversion function is not specified, field values are strings. For safety, there is no automatic conversion to numbers, dates, or other types. In some cases, JavaScript may coerce strings to numbers for you automatically (for example, using the + operator), but better is to specify a row conversion function. See d3.autoType for a convenient row conversion function that infers and coerces common types like numbers and strings.If a row conversion function is specified, the specified function is invoked for each row, being passed an object representing the current row (d), the index (i) starting at zero for the first non-header row, and the array of column names. If the returned value is null or undefined, the row is skipped and will be omitted from the array returned by dsv.parse; otherwise, the returned value defines the corresponding row object. For example:jsconst data = d3.csvParse(string, (d) => {
  return {
    year: new Date(+d.Year, 0, 1), // lowercase and convert "Year" to Date
    make: d.Make, // lowercase
    model: d.Model, // lowercase
    length: +d.Length // lowercase and convert "Length" to number
  };
});Note: using + or Number rather than parseInt or parseFloat is typically faster, though more restrictive. For example, "30px" when coerced using + returns NaN, while parseInt and parseFloat return 30.dsv.parseRows(string, row) ​jsd3.csvParseRows("foo,bar\n1,2") // [["foo", "bar"], ["1", "2"]]Source · Parses the specified string, which must be in the delimiter-separated values format with the appropriate delimiter, returning an array of arrays representing the parsed rows.Unlike dsv.parse, this method treats the header line as a standard row, and should be used whenever DSV content does not contain a header. Each row is represented as an array rather than an object. Rows may have variable length. For example, consider the following CSV file, which notably lacks a header line:1997,Ford,E350,2.34
2000,Mercury,Cougar,2.38The resulting JavaScript array is:js[
  ["1997", "Ford", "E350", "2.34"],
  ["2000", "Mercury", "Cougar", "2.38"]
]If a row conversion function is not specified, field values are strings. For safety, there is no automatic conversion to numbers, dates, or other types. In some cases, JavaScript may coerce strings to numbers for you automatically (for example, using the + operator), but better is to specify a row conversion function. See d3.autoType for a convenient row conversion function that infers and coerces common types like numbers and strings.If a row conversion function is specified, the specified function is invoked for each row, being passed an array representing the current row (d), the index (i) starting at zero for the first row, and the array of column names. If the returned value is null or undefined, the row is skipped and will be omitted from the array returned by dsv.parse; otherwise, the returned value defines the corresponding row object. For example:jsconst data = d3.csvParseRows(string, (d, i) => {
  return {
    year: new Date(+d[0], 0, 1), // convert first column to Date
    make: d[1],
    model: d[2],
    length: +d[3] // convert fourth column to number
  };
});In effect, row is similar to applying a map and filter operator to the returned rows.dsv.format(rows, columns) ​jsd3.csvFormat([{foo: "1", bar: "2"}]) // "foo,bar\n1,2"jsd3.csvFormat([{foo: "1", bar: "2"}], ["foo"]) // "foo\n1"Source · Formats the specified array of object rows as delimiter-separated values, returning a string. This operation is the inverse of dsv.parse. Each row will be separated by a newline (\n), and each column within each row will be separated by the delimiter (such as a comma, ,). Values that contain either the delimiter, a double-quote (") or a newline will be escaped using double-quotes.If columns is not specified, the list of column names that forms the header row is determined by the union of all properties on all objects in rows; the order of columns is nondeterministic. If columns is specified, it is an array of strings representing the column names. For example:jsconst string = d3.csvFormat(data, ["year", "make", "model", "length"]);All fields on each row object will be coerced to strings. If the field value is null or undefined, the empty string is used. If the field value is a Date, the ECMAScript date-time string format (a subset of ISO 8601) is used: for example, dates at UTC midnight are formatted as YYYY-MM-DD. For more control over which and how fields are formatted, first map rows to an array of array of string, and then use dsv.formatRows.dsv.formatBody(rows, columns) ​jsd3.csvFormatBody([{foo: "1", bar: "2"}]) // "1,2"jsd3.csvFormatBody([{foo: "1", bar: "2"}], ["foo"]) // "1"Source · Equivalent to dsv.format, but omits the header row. This is useful, for example, when appending rows to an existing file.dsv.formatRows(rows) ​jsd3.csvFormatRows([["foo", "bar"], ["1", "2"]]) // "foo,bar\n1,2"Source · Formats the specified array of array of string rows as delimiter-separated values, returning a string. This operation is the reverse of dsv.parseRows. Each row will be separated by a newline (\n), and each column within each row will be separated by the delimiter (such as a comma, ,). Values that contain either the delimiter, a double-quote (") or a newline will be escaped using double-quotes.To convert an array of objects to an array of arrays while explicitly specifying the columns, use array.map. For example:jsconst string = d3.csvFormatRows(data.map((d, i) => {
  return [
    d.year.getUTCFullYear(), // Assuming d.year is a Date object.
    d.make,
    d.model,
    d.length
  ];
}));If you like, you can also array.concat this result with an array of column names to generate the first row:jsconst string = d3.csvFormatRows([[
    "year",
    "make",
    "model",
    "length"
  ]].concat(data.map((d, i) => {
  return [
    d.year.getUTCFullYear(), // Assuming d.year is a Date object.
    d.make,
    d.model,
    d.length
  ];
})));dsv.formatRow(row) ​jsd3.csvFormatRow(["foo", "bar"]) // "foo,bar"Source · Formats a single array row of strings as delimiter-separated values, returning a string. Each column within the row will be separated by the delimiter (such as a comma, ,). Values that contain either the delimiter, a double-quote (") or a newline will be escaped using double-quotes.dsv.formatValue(value) ​jsd3.csvFormatValue("foo") // "foo"Source · Format a single value or string as a delimiter-separated value, returning a string. A value that contains either the delimiter, a double-quote (") or a newline will be escaped using double-quotes.csvParse(string, row) ​Equivalent to d3.dsvFormat(",").parse.csvParseRows(string, row) ​Equivalent to d3.dsvFormat(",").parseRows.csvFormat(rows, columns) ​Equivalent to d3.dsvFormat(",").format.csvFormatBody(rows, columns) ​Equivalent to d3.dsvFormat(",").formatBody.csvFormatRows(rows) ​Equivalent to d3.dsvFormat(",").formatRows.csvFormatRow(row) ​Equivalent to d3.dsvFormat(",").formatRow.csvFormatValue(value) ​Equivalent to d3.dsvFormat(",").formatValue.tsvParse(string, row) ​Equivalent to d3.dsvFormat("\t").parse.tsvParseRows(string, row) ​Equivalent to d3.dsvFormat("\t").parseRows.tsvFormat(rows, columns) ​Equivalent to d3.dsvFormat("\t").format.tsvFormatBody(rows, columns) ​Equivalent to d3.dsvFormat("\t").formatBody.tsvFormatRows(rows) ​Equivalent to d3.dsvFormat("\t").formatRows.tsvFormatRow(row) ​Equivalent to d3.dsvFormat("\t").formatRow.tsvFormatValue(value) ​Equivalent to d3.dsvFormat("\t").formatValue.autoType(object) ​Source · Given an object (or array) representing a parsed row, infers the types of values on the object and coerces them accordingly, returning the mutated object. This function is intended to be used as a row accessor function in conjunction with dsv.parse and dsv.parseRows. For example, consider the following CSV file:Year,Make,Model,Length
1997,Ford,E350,2.34
2000,Mercury,Cougar,2.38When used with d3.csvParse,jsd3.csvParse(string, d3.autoType)the resulting JavaScript array is:js[
  {"Year": 1997, "Make": "Ford", "Model": "E350", "Length": 2.34},
  {"Year": 2000, "Make": "Mercury", "Model": "Cougar", "Length": 2.38}
]Type inference works as follows. For each value in the given object, the trimmed value is computed; the value is then re-assigned as follows:If empty, then null.If exactly "true", then true.If exactly "false", then false.If exactly "NaN", then NaN.Otherwise, if coercible to a number, then a number.Otherwise, if a date-only or date-time string, then a Date.Otherwise, a string (the original untrimmed value).Values with leading zeroes may be coerced to numbers; for example "08904" coerces to 8904. However, extra characters such as commas or units (e.g., "$1.00", "(123)", "1,234" or "32px") will prevent number coercion, resulting in a string.Date strings must be in ECMAScript’s subset of the ISO 8601 format. When a date-only string such as YYYY-MM-DD is specified, the inferred time is midnight UTC; however, if a date-time string such as YYYY-MM-DDTHH:MM is specified without a time zone, it is assumed to be local time.Automatic type inference is primarily intended to provide safe, predictable behavior in conjunction with dsv.format and dsv.formatRows for common JavaScript types. If you need different behavior, you should implement your own row accessor function.For more, see the d3.autoType notebook.Content security policy ​If a content security policy is in place, note that dsv.parse requires unsafe-eval in the script-src directive, due to the (safe) use of dynamic code generation for fast parsing. (See source.) Alternatively, use dsv.parseRows.Byte-order marks ​DSV files sometimes begin with a byte order mark (BOM); saving a spreadsheet in CSV UTF-8 format from Microsoft Excel, for example, will include a BOM. On the web this is not usually a problem because the UTF-8 decode algorithm specified in the Encoding standard removes the BOM. Node.js, on the other hand, does not remove the BOM when decoding UTF-8.If the BOM is not removed, the first character of the text is a zero-width non-breaking space. So if a CSV file with a BOM is parsed by d3.csvParse, the first column’s name will begin with a zero-width non-breaking space. This can be hard to spot since this character is usually invisible when printed.To remove the BOM before parsing, consider using strip-bom.\n\nSearchK7.9.0GitHub️ 110.0kOn this paged3-dsv ​This module provides a parser and formatter for delimiter-separated values, most commonly comma-separated values (CSV) or tab-separated values (TSV). These tabular formats are popular with spreadsheet programs such as Microsoft Excel, and are often more space-efficient than JSON. This implementation is based on RFC 4180.For example, to parse:jsd3.csvParse("foo,bar\n1,2") // [{foo: "1", bar: "2"}, columns: ["foo", "bar"]]jsd3.tsvParse("foo\tbar\n1\t2") // [{foo: "1", bar: "2"}, columns: ["foo", "bar"]]To format:jsd3.csvFormat([{foo: "1", bar: "2"}]) // "foo,bar\n1,2"jsd3.tsvFormat([{foo: "1", bar: "2"}]) // "foo\tbar\n1\t2"To use a different delimiter, such as “|” for pipe-separated values, use d3.dsvFormat:jsd3.dsvFormat("|").parse("foo|bar\n1|2")) // [{foo: "1", bar: "2"}, columns: ["foo", "bar"]]For easy loading of DSV files in a browser, see d3-fetch’s d3.csv, d3.tsv and d3.dsv methods.dsvFormat(delimiter) ​jsconst csv = d3.dsvFormat(",");Source · Constructs a new DSV parser and formatter for the specified delimiter. The delimiter must be a single character (i.e., a single 16-bit code unit); so, ASCII delimiters are fine, but emoji delimiters are not.dsv.parse(string, row) ​CAUTIONThis method requires the unsafe-eval content security policy.jsd3.csvParse("foo,bar\n1,2") // [{foo: "1", bar: "2"}, columns: ["foo", "bar"]]Source · Parses the specified string, which must be in the delimiter-separated values format with the appropriate delimiter, returning an array of objects representing the parsed rows.Unlike dsv.parseRows, this method requires that the first line of the DSV content contains a delimiter-separated list of column names; these column names become the attributes on the returned objects. For example, consider the following CSV file:Year,Make,Model,Length
1997,Ford,E350,2.34
2000,Mercury,Cougar,2.38The resulting JavaScript array is:js[
  {"Year": "1997", "Make": "Ford", "Model": "E350", "Length": "2.34"},
  {"Year": "2000", "Make": "Mercury", "Model": "Cougar", "Length": "2.38"}
]The returned array also exposes a columns property containing the column names in input order (in contrast to Object.keys, whose iteration order is arbitrary). For example:jsdata.columns // ["Year", "Make", "Model", "Length"]If the column names are not unique, only the last value is returned for each name; to access all values, use dsv.parseRows instead (see example).If a row conversion function is not specified, field values are strings. For safety, there is no automatic conversion to numbers, dates, or other types. In some cases, JavaScript may coerce strings to numbers for you automatically (for example, using the + operator), but better is to specify a row conversion function. See d3.autoType for a convenient row conversion function that infers and coerces common types like numbers and strings.If a row conversion function is specified, the specified function is invoked for each row, being passed an object representing the current row (d), the index (i) starting at zero for the first non-header row, and the array of column names. If the returned value is null or undefined, the row is skipped and will be omitted from the array returned by dsv.parse; otherwise, the returned value defines the corresponding row object. For example:jsconst data = d3.csvParse(string, (d) => {
  return {
    year: new Date(+d.Year, 0, 1), // lowercase and convert "Year" to Date
    make: d.Make, // lowercase
    model: d.Model, // lowercase
    length: +d.Length // lowercase and convert "Length" to number
  };
});Note: using + or Number rather than parseInt or parseFloat is typically faster, though more restrictive. For example, "30px" when coerced using + returns NaN, while parseInt and parseFloat return 30.dsv.parseRows(string, row) ​jsd3.csvParseRows("foo,bar\n1,2") // [["foo", "bar"], ["1", "2"]]Source · Parses the specified string, which must be in the delimiter-separated values format with the appropriate delimiter, returning an array of arrays representing the parsed rows.Unlike dsv.parse, this method treats the header line as a standard row, and should be used whenever DSV content does not contain a header. Each row is represented as an array rather than an object. Rows may have variable length. For example, consider the following CSV file, which notably lacks a header line:1997,Ford,E350,2.34
2000,Mercury,Cougar,2.38The resulting JavaScript array is:js[
  ["1997", "Ford", "E350", "2.34"],
  ["2000", "Mercury", "Cougar", "2.38"]
]If a row conversion function is not specified, field values are strings. For safety, there is no automatic conversion to numbers, dates, or other types. In some cases, JavaScript may coerce strings to numbers for you automatically (for example, using the + operator), but better is to specify a row conversion function. See d3.autoType for a convenient row conversion function that infers and coerces common types like numbers and strings.If a row conversion function is specified, the specified function is invoked for each row, being passed an array representing the current row (d), the index (i) starting at zero for the first row, and the array of column names. If the returned value is null or undefined, the row is skipped and will be omitted from the array returned by dsv.parse; otherwise, the returned value defines the corresponding row object. For example:jsconst data = d3.csvParseRows(string, (d, i) => {
  return {
    year: new Date(+d[0], 0, 1), // convert first column to Date
    make: d[1],
    model: d[2],
    length: +d[3] // convert fourth column to number
  };
});In effect, row is similar to applying a map and filter operator to the returned rows.dsv.format(rows, columns) ​jsd3.csvFormat([{foo: "1", bar: "2"}]) // "foo,bar\n1,2"jsd3.csvFormat([{foo: "1", bar: "2"}], ["foo"]) // "foo\n1"Source · Formats the specified array of object rows as delimiter-separated values, returning a string. This operation is the inverse of dsv.parse. Each row will be separated by a newline (\n), and each column within each row will be separated by the delimiter (such as a comma, ,). Values that contain either the delimiter, a double-quote (") or a newline will be escaped using double-quotes.If columns is not specified, the list of column names that forms the header row is determined by the union of all properties on all objects in rows; the order of columns is nondeterministic. If columns is specified, it is an array of strings representing the column names. For example:jsconst string = d3.csvFormat(data, ["year", "make", "model", "length"]);All fields on each row object will be coerced to strings. If the field value is null or undefined, the empty string is used. If the field value is a Date, the ECMAScript date-time string format (a subset of ISO 8601) is used: for example, dates at UTC midnight are formatted as YYYY-MM-DD. For more control over which and how fields are formatted, first map rows to an array of array of string, and then use dsv.formatRows.dsv.formatBody(rows, columns) ​jsd3.csvFormatBody([{foo: "1", bar: "2"}]) // "1,2"jsd3.csvFormatBody([{foo: "1", bar: "2"}], ["foo"]) // "1"Source · Equivalent to dsv.format, but omits the header row. This is useful, for example, when appending rows to an existing file.dsv.formatRows(rows) ​jsd3.csvFormatRows([["foo", "bar"], ["1", "2"]]) // "foo,bar\n1,2"Source · Formats the specified array of array of string rows as delimiter-separated values, returning a string. This operation is the reverse of dsv.parseRows. Each row will be separated by a newline (\n), and each column within each row will be separated by the delimiter (such as a comma, ,). Values that contain either the delimiter, a double-quote (") or a newline will be escaped using double-quotes.To convert an array of objects to an array of arrays while explicitly specifying the columns, use array.map. For example:jsconst string = d3.csvFormatRows(data.map((d, i) => {
  return [
    d.year.getUTCFullYear(), // Assuming d.year is a Date object.
    d.make,
    d.model,
    d.length
  ];
}));If you like, you can also array.concat this result with an array of column names to generate the first row:jsconst string = d3.csvFormatRows([[
    "year",
    "make",
    "model",
    "length"
  ]].concat(data.map((d, i) => {
  return [
    d.year.getUTCFullYear(), // Assuming d.year is a Date object.
    d.make,
    d.model,
    d.length
  ];
})));dsv.formatRow(row) ​jsd3.csvFormatRow(["foo", "bar"]) // "foo,bar"Source · Formats a single array row of strings as delimiter-separated values, returning a string. Each column within the row will be separated by the delimiter (such as a comma, ,). Values that contain either the delimiter, a double-quote (") or a newline will be escaped using double-quotes.dsv.formatValue(value) ​jsd3.csvFormatValue("foo") // "foo"Source · Format a single value or string as a delimiter-separated value, returning a string. A value that contains either the delimiter, a double-quote (") or a newline will be escaped using double-quotes.csvParse(string, row) ​Equivalent to d3.dsvFormat(",").parse.csvParseRows(string, row) ​Equivalent to d3.dsvFormat(",").parseRows.csvFormat(rows, columns) ​Equivalent to d3.dsvFormat(",").format.csvFormatBody(rows, columns) ​Equivalent to d3.dsvFormat(",").formatBody.csvFormatRows(rows) ​Equivalent to d3.dsvFormat(",").formatRows.csvFormatRow(row) ​Equivalent to d3.dsvFormat(",").formatRow.csvFormatValue(value) ​Equivalent to d3.dsvFormat(",").formatValue.tsvParse(string, row) ​Equivalent to d3.dsvFormat("\t").parse.tsvParseRows(string, row) ​Equivalent to d3.dsvFormat("\t").parseRows.tsvFormat(rows, columns) ​Equivalent to d3.dsvFormat("\t").format.tsvFormatBody(rows, columns) ​Equivalent to d3.dsvFormat("\t").formatBody.tsvFormatRows(rows) ​Equivalent to d3.dsvFormat("\t").formatRows.tsvFormatRow(row) ​Equivalent to d3.dsvFormat("\t").formatRow.tsvFormatValue(value) ​Equivalent to d3.dsvFormat("\t").formatValue.autoType(object) ​Source · Given an object (or array) representing a parsed row, infers the types of values on the object and coerces them accordingly, returning the mutated object. This function is intended to be used as a row accessor function in conjunction with dsv.parse and dsv.parseRows. For example, consider the following CSV file:Year,Make,Model,Length
1997,Ford,E350,2.34
2000,Mercury,Cougar,2.38When used with d3.csvParse,jsd3.csvParse(string, d3.autoType)the resulting JavaScript array is:js[
  {"Year": 1997, "Make": "Ford", "Model": "E350", "Length": 2.34},
  {"Year": 2000, "Make": "Mercury", "Model": "Cougar", "Length": 2.38}
]Type inference works as follows. For each value in the given object, the trimmed value is computed; the value is then re-assigned as follows:If empty, then null.If exactly "true", then true.If exactly "false", then false.If exactly "NaN", then NaN.Otherwise, if coercible to a number, then a number.Otherwise, if a date-only or date-time string, then a Date.Otherwise, a string (the original untrimmed value).Values with leading zeroes may be coerced to numbers; for example "08904" coerces to 8904. However, extra characters such as commas or units (e.g., "$1.00", "(123)", "1,234" or "32px") will prevent number coercion, resulting in a string.Date strings must be in ECMAScript’s subset of the ISO 8601 format. When a date-only string such as YYYY-MM-DD is specified, the inferred time is midnight UTC; however, if a date-time string such as YYYY-MM-DDTHH:MM is specified without a time zone, it is assumed to be local time.Automatic type inference is primarily intended to provide safe, predictable behavior in conjunction with dsv.format and dsv.formatRows for common JavaScript types. If you need different behavior, you should implement your own row accessor function.For more, see the d3.autoType notebook.Content security policy ​If a content security policy is in place, note that dsv.parse requires unsafe-eval in the script-src directive, due to the (safe) use of dynamic code generation for fast parsing. (See source.) Alternatively, use dsv.parseRows.Byte-order marks ​DSV files sometimes begin with a byte order mark (BOM); saving a spreadsheet in CSV UTF-8 format from Microsoft Excel, for example, will include a BOM. On the web this is not usually a problem because the UTF-8 decode algorithm specified in the Encoding standard removes the BOM. Node.js, on the other hand, does not remove the BOM when decoding UTF-8.If the BOM is not removed, the first character of the text is a zero-width non-breaking space. So if a CSV file with a BOM is parsed by d3.csvParse, the first column’s name will begin with a zero-width non-breaking space. This can be hard to spot since this character is usually invisible when printed.To remove the BOM before parsing, consider using strip-bom.PagerPrevious pageTransforming dataNext paged3-fetch\n\nd3-dsv ​This module provides a parser and formatter for delimiter-separated values, most commonly comma-separated values (CSV) or tab-separated values (TSV). These tabular formats are popular with spreadsheet programs such as Microsoft Excel, and are often more space-efficient than JSON. This implementation is based on RFC 4180.For example, to parse:jsd3.csvParse("foo,bar\n1,2") // [{foo: "1", bar: "2"}, columns: ["foo", "bar"]]jsd3.tsvParse("foo\tbar\n1\t2") // [{foo: "1", bar: "2"}, columns: ["foo", "bar"]]To format:jsd3.csvFormat([{foo: "1", bar: "2"}]) // "foo,bar\n1,2"jsd3.tsvFormat([{foo: "1", bar: "2"}]) // "foo\tbar\n1\t2"To use a different delimiter, such as “|” for pipe-separated values, use d3.dsvFormat:jsd3.dsvFormat("|").parse("foo|bar\n1|2")) // [{foo: "1", bar: "2"}, columns: ["foo", "bar"]]For easy loading of DSV files in a browser, see d3-fetch’s d3.csv, d3.tsv and d3.dsv methods.dsvFormat(delimiter) ​jsconst csv = d3.dsvFormat(",");Source · Constructs a new DSV parser and formatter for the specified delimiter. The delimiter must be a single character (i.e., a single 16-bit code unit); so, ASCII delimiters are fine, but emoji delimiters are not.dsv.parse(string, row) ​CAUTIONThis method requires the unsafe-eval content security policy.jsd3.csvParse("foo,bar\n1,2") // [{foo: "1", bar: "2"}, columns: ["foo", "bar"]]Source · Parses the specified string, which must be in the delimiter-separated values format with the appropriate delimiter, returning an array of objects representing the parsed rows.Unlike dsv.parseRows, this method requires that the first line of the DSV content contains a delimiter-separated list of column names; these column names become the attributes on the returned objects. For example, consider the following CSV file:Year,Make,Model,Length
1997,Ford,E350,2.34
2000,Mercury,Cougar,2.38The resulting JavaScript array is:js[
  {"Year": "1997", "Make": "Ford", "Model": "E350", "Length": "2.34"},
  {"Year": "2000", "Make": "Mercury", "Model": "Cougar", "Length": "2.38"}
]The returned array also exposes a columns property containing the column names in input order (in contrast to Object.keys, whose iteration order is arbitrary). For example:jsdata.columns // ["Year", "Make", "Model", "Length"]If the column names are not unique, only the last value is returned for each name; to access all values, use dsv.parseRows instead (see example).If a row conversion function is not specified, field values are strings. For safety, there is no automatic conversion to numbers, dates, or other types. In some cases, JavaScript may coerce strings to numbers for you automatically (for example, using the + operator), but better is to specify a row conversion function. See d3.autoType for a convenient row conversion function that infers and coerces common types like numbers and strings.If a row conversion function is specified, the specified function is invoked for each row, being passed an object representing the current row (d), the index (i) starting at zero for the first non-header row, and the array of column names. If the returned value is null or undefined, the row is skipped and will be omitted from the array returned by dsv.parse; otherwise, the returned value defines the corresponding row object. For example:jsconst data = d3.csvParse(string, (d) => {
  return {
    year: new Date(+d.Year, 0, 1), // lowercase and convert "Year" to Date
    make: d.Make, // lowercase
    model: d.Model, // lowercase
    length: +d.Length // lowercase and convert "Length" to number
  };
});Note: using + or Number rather than parseInt or parseFloat is typically faster, though more restrictive. For example, "30px" when coerced using + returns NaN, while parseInt and parseFloat return 30.dsv.parseRows(string, row) ​jsd3.csvParseRows("foo,bar\n1,2") // [["foo", "bar"], ["1", "2"]]Source · Parses the specified string, which must be in the delimiter-separated values format with the appropriate delimiter, returning an array of arrays representing the parsed rows.Unlike dsv.parse, this method treats the header line as a standard row, and should be used whenever DSV content does not contain a header. Each row is represented as an array rather than an object. Rows may have variable length. For example, consider the following CSV file, which notably lacks a header line:1997,Ford,E350,2.34
2000,Mercury,Cougar,2.38The resulting JavaScript array is:js[
  ["1997", "Ford", "E350", "2.34"],
  ["2000", "Mercury", "Cougar", "2.38"]
]If a row conversion function is not specified, field values are strings. For safety, there is no automatic conversion to numbers, dates, or other types. In some cases, JavaScript may coerce strings to numbers for you automatically (for example, using the + operator), but better is to specify a row conversion function. See d3.autoType for a convenient row conversion function that infers and coerces common types like numbers and strings.If a row conversion function is specified, the specified function is invoked for each row, being passed an array representing the current row (d), the index (i) starting at zero for the first row, and the array of column names. If the returned value is null or undefined, the row is skipped and will be omitted from the array returned by dsv.parse; otherwise, the returned value defines the corresponding row object. For example:jsconst data = d3.csvParseRows(string, (d, i) => {
  return {
    year: new Date(+d[0], 0, 1), // convert first column to Date
    make: d[1],
    model: d[2],
    length: +d[3] // convert fourth column to number
  };
});In effect, row is similar to applying a map and filter operator to the returned rows.dsv.format(rows, columns) ​jsd3.csvFormat([{foo: "1", bar: "2"}]) // "foo,bar\n1,2"jsd3.csvFormat([{foo: "1", bar: "2"}], ["foo"]) // "foo\n1"Source · Formats the specified array of object rows as delimiter-separated values, returning a string. This operation is the inverse of dsv.parse. Each row will be separated by a newline (\n), and each column within each row will be separated by the delimiter (such as a comma, ,). Values that contain either the delimiter, a double-quote (") or a newline will be escaped using double-quotes.If columns is not specified, the list of column names that forms the header row is determined by the union of all properties on all objects in rows; the order of columns is nondeterministic. If columns is specified, it is an array of strings representing the column names. For example:jsconst string = d3.csvFormat(data, ["year", "make", "model", "length"]);All fields on each row object will be coerced to strings. If the field value is null or undefined, the empty string is used. If the field value is a Date, the ECMAScript date-time string format (a subset of ISO 8601) is used: for example, dates at UTC midnight are formatted as YYYY-MM-DD. For more control over which and how fields are formatted, first map rows to an array of array of string, and then use dsv.formatRows.dsv.formatBody(rows, columns) ​jsd3.csvFormatBody([{foo: "1", bar: "2"}]) // "1,2"jsd3.csvFormatBody([{foo: "1", bar: "2"}], ["foo"]) // "1"Source · Equivalent to dsv.format, but omits the header row. This is useful, for example, when appending rows to an existing file.dsv.formatRows(rows) ​jsd3.csvFormatRows([["foo", "bar"], ["1", "2"]]) // "foo,bar\n1,2"Source · Formats the specified array of array of string rows as delimiter-separated values, returning a string. This operation is the reverse of dsv.parseRows. Each row will be separated by a newline (\n), and each column within each row will be separated by the delimiter (such as a comma, ,). Values that contain either the delimiter, a double-quote (") or a newline will be escaped using double-quotes.To convert an array of objects to an array of arrays while explicitly specifying the columns, use array.map. For example:jsconst string = d3.csvFormatRows(data.map((d, i) => {
  return [
    d.year.getUTCFullYear(), // Assuming d.year is a Date object.
    d.make,
    d.model,
    d.length
  ];
}));If you like, you can also array.concat this result with an array of column names to generate the first row:jsconst string = d3.csvFormatRows([[
    "year",
    "make",
    "model",
    "length"
  ]].concat(data.map((d, i) => {
  return [
    d.year.getUTCFullYear(), // Assuming d.year is a Date object.
    d.make,
    d.model,
    d.length
  ];
})));dsv.formatRow(row) ​jsd3.csvFormatRow(["foo", "bar"]) // "foo,bar"Source · Formats a single array row of strings as delimiter-separated values, returning a string. Each column within the row will be separated by the delimiter (such as a comma, ,). Values that contain either the delimiter, a double-quote (") or a newline will be escaped using double-quotes.dsv.formatValue(value) ​jsd3.csvFormatValue("foo") // "foo"Source · Format a single value or string as a delimiter-separated value, returning a string. A value that contains either the delimiter, a double-quote (") or a newline will be escaped using double-quotes.csvParse(string, row) ​Equivalent to d3.dsvFormat(",").parse.csvParseRows(string, row) ​Equivalent to d3.dsvFormat(",").parseRows.csvFormat(rows, columns) ​Equivalent to d3.dsvFormat(",").format.csvFormatBody(rows, columns) ​Equivalent to d3.dsvFormat(",").formatBody.csvFormatRows(rows) ​Equivalent to d3.dsvFormat(",").formatRows.csvFormatRow(row) ​Equivalent to d3.dsvFormat(",").formatRow.csvFormatValue(value) ​Equivalent to d3.dsvFormat(",").formatValue.tsvParse(string, row) ​Equivalent to d3.dsvFormat("\t").parse.tsvParseRows(string, row) ​Equivalent to d3.dsvFormat("\t").parseRows.tsvFormat(rows, columns) ​Equivalent to d3.dsvFormat("\t").format.tsvFormatBody(rows, columns) ​Equivalent to d3.dsvFormat("\t").formatBody.tsvFormatRows(rows) ​Equivalent to d3.dsvFormat("\t").formatRows.tsvFormatRow(row) ​Equivalent to d3.dsvFormat("\t").formatRow.tsvFormatValue(value) ​Equivalent to d3.dsvFormat("\t").formatValue.autoType(object) ​Source · Given an object (or array) representing a parsed row, infers the types of values on the object and coerces them accordingly, returning the mutated object. This function is intended to be used as a row accessor function in conjunction with dsv.parse and dsv.parseRows. For example, consider the following CSV file:Year,Make,Model,Length
1997,Ford,E350,2.34
2000,Mercury,Cougar,2.38When used with d3.csvParse,jsd3.csvParse(string, d3.autoType)the resulting JavaScript array is:js[
  {"Year": 1997, "Make": "Ford", "Model": "E350", "Length": 2.34},
  {"Year": 2000, "Make": "Mercury", "Model": "Cougar", "Length": 2.38}
]Type inference works as follows. For each value in the given object, the trimmed value is computed; the value is then re-assigned as follows:If empty, then null.If exactly "true", then true.If exactly "false", then false.If exactly "NaN", then NaN.Otherwise, if coercible to a number, then a number.Otherwise, if a date-only or date-time string, then a Date.Otherwise, a string (the original untrimmed value).Values with leading zeroes may be coerced to numbers; for example "08904" coerces to 8904. However, extra characters such as commas or units (e.g., "$1.00", "(123)", "1,234" or "32px") will prevent number coercion, resulting in a string.Date strings must be in ECMAScript’s subset of the ISO 8601 format. When a date-only string such as YYYY-MM-DD is specified, the inferred time is midnight UTC; however, if a date-time string such as YYYY-MM-DDTHH:MM is specified without a time zone, it is assumed to be local time.Automatic type inference is primarily intended to provide safe, predictable behavior in conjunction with dsv.format and dsv.formatRows for common JavaScript types. If you need different behavior, you should implement your own row accessor function.For more, see the d3.autoType notebook.Content security policy ​If a content security policy is in place, note that dsv.parse requires unsafe-eval in the script-src directive, due to the (safe) use of dynamic code generation for fast parsing. (See source.) Alternatively, use dsv.parseRows.Byte-order marks ​DSV files sometimes begin with a byte order mark (BOM); saving a spreadsheet in CSV UTF-8 format from Microsoft Excel, for example, will include a BOM. On the web this is not usually a problem because the UTF-8 decode algorithm specified in the Encoding standard removes the BOM. Node.js, on the other hand, does not remove the BOM when decoding UTF-8.If the BOM is not removed, the first character of the text is a zero-width non-breaking space. So if a CSV file with a BOM is parsed by d3.csvParse, the first column’s name will begin with a zero-width non-breaking space. This can be hard to spot since this character is usually invisible when printed.To remove the BOM before parsing, consider using strip-bom.\n\n\n\nd3-fetch ​This module provides convenient parsing on top of Fetch. For example, to load a text file:jsconst text = await d3.text("hello-world.txt"); // "Hello, world!"To load and parse a CSV file:jsconst data = await d3.csv("hello-world.csv"); // [{"Hello": "world"}, …]This module has built-in support for parsing JSON, CSV, and TSV. You can parse additional formats by using text directly. (This module replaced d3-request.)blob(input, init) ​jsconst blob = await d3.blob("example.db");Source · Fetches the binary file at the specified input URL as a Blob. If init is specified, it is passed along to the underlying call to fetch; see RequestInit for allowed fields.buffer(input, init) ​jsconst buffer = await d3.buffer("example.db");Source · Fetches the binary file at the specified input URL as an ArrayBuffer. If init is specified, it is passed along to the underlying call to fetch; see RequestInit for allowed fields.csv(input, init, row) ​jsconst data = await d3.csv("example.csv");Source · Equivalent to d3.dsv with the comma character as the delimiter.dsv(delimiter, input, init, row) ​jsconst data = await d3.dsv(",", "example.csv");Source · Fetches the DSV file at the specified input URL. If init is specified, it is passed along to the underlying call to fetch; see RequestInit for allowed fields. An optional row conversion function may be specified to map and filter row objects to a more-specific representation; see dsv.parse for details. For example:jsconst data = await d3.dsv(",", "example.csv", (d) => {
  return {
    year: new Date(+d.Year, 0, 1), // convert "Year" column to Date
    make: d.Make,
    model: d.Model,
    length: +d.Length // convert "Length" column to number
  };
});If only one of init and row is specified, it is interpreted as the row conversion function if it is a function, and otherwise an init object. See also d3.csv and d3.tsv.html(input, init) ​jsconst document = await d3.html("example.html");Source · Fetches the file at the specified input URL as text and then parses it as HTML. If init is specified, it is passed along to the underlying call to fetch; see RequestInit for allowed fields.image(input, init) ​jsconst image = await d3.image("example.png");Source · Fetches the image at the specified input URL. If init is specified, sets any additional properties on the image before loading. For example, to enable an anonymous cross-origin request:jsconst image = await d3.image("https://example.com/image.png", {crossOrigin: "anonymous"});json(input, init) ​jsconst data = await d3.json("example.json");Source · Fetches the JSON file at the specified input URL. If init is specified, it is passed along to the underlying call to fetch; see RequestInit for allowed fields. If the server returns a status code of 204 No Content or 205 Reset Content, the promise resolves to undefined.svg(input, init) ​jsconst document = await d3.svg("example.svg");Source · Fetches the file at the specified input URL as text and then parses it as SVG. If init is specified, it is passed along to the underlying call to fetch; see RequestInit for allowed fields.text(input, init) ​jsconst text = await d3.text("example.txt");Source · Fetches the text file at the specified input URL. If init is specified, it is passed along to the underlying call to fetch; see RequestInit for allowed fields.tsv(input, init, row) ​jsconst data = await d3.tsv("example.tsv");Source · Equivalent to d3.dsv with the tab character as the delimiter.xml(input, init) ​jsconst document = await d3.xml("example.xml");Source · Fetches the file at the specified input URL as text and then parses it as XML. If init is specified, it is passed along to the underlying call to fetch; see RequestInit for allowed fields.\n\nSearchK7.9.0GitHub️ 110.0kOn this paged3-fetch ​This module provides convenient parsing on top of Fetch. For example, to load a text file:jsconst text = await d3.text("hello-world.txt"); // "Hello, world!"To load and parse a CSV file:jsconst data = await d3.csv("hello-world.csv"); // [{"Hello": "world"}, …]This module has built-in support for parsing JSON, CSV, and TSV. You can parse additional formats by using text directly. (This module replaced d3-request.)blob(input, init) ​jsconst blob = await d3.blob("example.db");Source · Fetches the binary file at the specified input URL as a Blob. If init is specified, it is passed along to the underlying call to fetch; see RequestInit for allowed fields.buffer(input, init) ​jsconst buffer = await d3.buffer("example.db");Source · Fetches the binary file at the specified input URL as an ArrayBuffer. If init is specified, it is passed along to the underlying call to fetch; see RequestInit for allowed fields.csv(input, init, row) ​jsconst data = await d3.csv("example.csv");Source · Equivalent to d3.dsv with the comma character as the delimiter.dsv(delimiter, input, init, row) ​jsconst data = await d3.dsv(",", "example.csv");Source · Fetches the DSV file at the specified input URL. If init is specified, it is passed along to the underlying call to fetch; see RequestInit for allowed fields. An optional row conversion function may be specified to map and filter row objects to a more-specific representation; see dsv.parse for details. For example:jsconst data = await d3.dsv(",", "example.csv", (d) => {
  return {
    year: new Date(+d.Year, 0, 1), // convert "Year" column to Date
    make: d.Make,
    model: d.Model,
    length: +d.Length // convert "Length" column to number
  };
});If only one of init and row is specified, it is interpreted as the row conversion function if it is a function, and otherwise an init object. See also d3.csv and d3.tsv.html(input, init) ​jsconst document = await d3.html("example.html");Source · Fetches the file at the specified input URL as text and then parses it as HTML. If init is specified, it is passed along to the underlying call to fetch; see RequestInit for allowed fields.image(input, init) ​jsconst image = await d3.image("example.png");Source · Fetches the image at the specified input URL. If init is specified, sets any additional properties on the image before loading. For example, to enable an anonymous cross-origin request:jsconst image = await d3.image("https://example.com/image.png", {crossOrigin: "anonymous"});json(input, init) ​jsconst data = await d3.json("example.json");Source · Fetches the JSON file at the specified input URL. If init is specified, it is passed along to the underlying call to fetch; see RequestInit for allowed fields. If the server returns a status code of 204 No Content or 205 Reset Content, the promise resolves to undefined.svg(input, init) ​jsconst document = await d3.svg("example.svg");Source · Fetches the file at the specified input URL as text and then parses it as SVG. If init is specified, it is passed along to the underlying call to fetch; see RequestInit for allowed fields.text(input, init) ​jsconst text = await d3.text("example.txt");Source · Fetches the text file at the specified input URL. If init is specified, it is passed along to the underlying call to fetch; see RequestInit for allowed fields.tsv(input, init, row) ​jsconst data = await d3.tsv("example.tsv");Source · Equivalent to d3.dsv with the tab character as the delimiter.xml(input, init) ​jsconst document = await d3.xml("example.xml");Source · Fetches the file at the specified input URL as text and then parses it as XML. If init is specified, it is passed along to the underlying call to fetch; see RequestInit for allowed fields.PagerPrevious paged3-dsvNext paged3-format\n\nd3-fetch ​This module provides convenient parsing on top of Fetch. For example, to load a text file:jsconst text = await d3.text("hello-world.txt"); // "Hello, world!"To load and parse a CSV file:jsconst data = await d3.csv("hello-world.csv"); // [{"Hello": "world"}, …]This module has built-in support for parsing JSON, CSV, and TSV. You can parse additional formats by using text directly. (This module replaced d3-request.)blob(input, init) ​jsconst blob = await d3.blob("example.db");Source · Fetches the binary file at the specified input URL as a Blob. If init is specified, it is passed along to the underlying call to fetch; see RequestInit for allowed fields.buffer(input, init) ​jsconst buffer = await d3.buffer("example.db");Source · Fetches the binary file at the specified input URL as an ArrayBuffer. If init is specified, it is passed along to the underlying call to fetch; see RequestInit for allowed fields.csv(input, init, row) ​jsconst data = await d3.csv("example.csv");Source · Equivalent to d3.dsv with the comma character as the delimiter.dsv(delimiter, input, init, row) ​jsconst data = await d3.dsv(",", "example.csv");Source · Fetches the DSV file at the specified input URL. If init is specified, it is passed along to the underlying call to fetch; see RequestInit for allowed fields. An optional row conversion function may be specified to map and filter row objects to a more-specific representation; see dsv.parse for details. For example:jsconst data = await d3.dsv(",", "example.csv", (d) => {
  return {
    year: new Date(+d.Year, 0, 1), // convert "Year" column to Date
    make: d.Make,
    model: d.Model,
    length: +d.Length // convert "Length" column to number
  };
});If only one of init and row is specified, it is interpreted as the row conversion function if it is a function, and otherwise an init object. See also d3.csv and d3.tsv.html(input, init) ​jsconst document = await d3.html("example.html");Source · Fetches the file at the specified input URL as text and then parses it as HTML. If init is specified, it is passed along to the underlying call to fetch; see RequestInit for allowed fields.image(input, init) ​jsconst image = await d3.image("example.png");Source · Fetches the image at the specified input URL. If init is specified, sets any additional properties on the image before loading. For example, to enable an anonymous cross-origin request:jsconst image = await d3.image("https://example.com/image.png", {crossOrigin: "anonymous"});json(input, init) ​jsconst data = await d3.json("example.json");Source · Fetches the JSON file at the specified input URL. If init is specified, it is passed along to the underlying call to fetch; see RequestInit for allowed fields. If the server returns a status code of 204 No Content or 205 Reset Content, the promise resolves to undefined.svg(input, init) ​jsconst document = await d3.svg("example.svg");Source · Fetches the file at the specified input URL as text and then parses it as SVG. If init is specified, it is passed along to the underlying call to fetch; see RequestInit for allowed fields.text(input, init) ​jsconst text = await d3.text("example.txt");Source · Fetches the text file at the specified input URL. If init is specified, it is passed along to the underlying call to fetch; see RequestInit for allowed fields.tsv(input, init, row) ​jsconst data = await d3.tsv("example.tsv");Source · Equivalent to d3.dsv with the tab character as the delimiter.xml(input, init) ​jsconst document = await d3.xml("example.xml");Source · Fetches the file at the specified input URL as text and then parses it as XML. If init is specified, it is passed along to the underlying call to fetch; see RequestInit for allowed fields.\n\n\n\nd3-format ​Ever noticed how sometimes JavaScript doesn’t display numbers the way you expect? Like, you tried to print tenths with a simple loop:jsfor (let i = 0; i < 10; ++i) {
  console.log(0.1 * i);
}And you got this:0
0.1
0.2
0.30000000000000004
0.4
0.5
0.6000000000000001
0.7000000000000001
0.8
0.9Welcome to binary floating point! ಠ_ಠYet rounding error is not the only reason to customize number formatting. A table of numbers should be formatted consistently for comparison; above, 0.0 would be better than 0. Large numbers should have grouped digits (e.g., 42,000) or be in scientific or metric notation (4.2e+4, 42k). Currencies should have fixed precision ($3.50). Reported numerical results should be rounded to significant digits (4021 becomes 4000). Number formats should appropriate to the reader’s locale (42.000,00 or 42,000.00). The list goes on.Formatting numbers for human consumption is the purpose of d3-format, which is modeled after Python 3’s format specification mini-language (PEP 3101). Revisiting the example above:jsconst f = d3.format(".1f");
for (let i = 0; i < 10; ++i) {
  console.log(f(0.1 * i));
}Now you get this:0.0
0.1
0.2
0.3
0.4
0.5
0.6
0.7
0.8
0.9But d3-format is much more than an alias for number.toFixed! A few more examples:jsd3.format(".0%")(0.123) // rounded percentage, "12%"jsd3.format("($.2f")(-3.5) // localized fixed-point currency, "(£3.50)"jsd3.format("+20")(42) // space-filled and signed, "                 +42"jsd3.format(".^20")(42) // dot-filled and centered, ".........42........."jsd3.format(".2s")(42e6) // SI-prefix with two significant digits, "42M"jsd3.format("#x")(48879) // prefixed lowercase hexadecimal, "0xbeef"jsd3.format(",.2r")(4223) // grouped thousands with two significant digits, "4,200"See locale.format for a detailed specification, and try running d3.formatSpecifier on the above formats to decode their meaning.Also see number.toLocaleString.format(specifier) ​jsconst f = d3.format(".2f");Source · An alias for locale.format on the default locale.formatPrefix(specifier, value) ​jsconst f = d3.formatPrefix(",.0", 1e-6);Source · An alias for locale.formatPrefix on the default locale.formatLocale(definition) ​jsconst enUs = d3.formatLocale({
  thousands: ",",
  grouping: [3],
  currency: ["$", ""]
});Source · Returns a locale object for the specified definition with locale.format and locale.formatPrefix methods. The definition must include the following properties:decimal - the decimal point (e.g., ".").thousands - the group separator (e.g., ",").grouping - the array of group sizes (e.g., [3]), cycled as needed.currency - the currency prefix and suffix (e.g., ["$", ""]).numerals - optional; an array of ten strings to replace the numerals 0-9.percent - optional; the percent sign (defaults to "%").minus - optional; the minus sign (defaults to "−").nan - optional; the not-a-number value (defaults "NaN").Note that the thousands property is a misnomer, as the grouping definition allows groups other than thousands.formatDefaultLocale(definition) ​jsconst enUs = d3.formatDefaultLocale({
  thousands: ",",
  grouping: [3],
  currency: ["$", ""]
});Source · Equivalent to d3.formatLocale, except it also redefines d3.format and d3.formatPrefix to the new locale’s locale.format and locale.formatPrefix. If you do not set a default locale, it defaults to U.S. English.locale.format(specifier) ​jsconst f = d3.format(".2f");Source · Returns a new format function for the given string specifier. The returned function takes a number as the only argument, and returns a string representing the formatted number. The general form of a specifier is:[​[fill]align][sign][symbol][0][width][,][.precision][~][type]The fill can be any character. The presence of a fill character is signaled by the align character following it, which must be one of the following:> - Forces the field to be right-aligned within the available space. (Default behavior).< - Forces the field to be left-aligned within the available space.^ - Forces the field to be centered within the available space.= - like >, but with any sign and symbol to the left of any padding.The sign can be:- - nothing for zero or positive and a minus sign for negative. (Default behavior.)+ - a plus sign for zero or positive and a minus sign for negative.( - nothing for zero or positive and parentheses for negative.  (space) - a space for zero or positive and a minus sign for negative.The symbol can be:$ - apply currency symbols per the locale definition.# - for binary, octal, or hexadecimal notation, prefix by 0b, 0o, or 0x, respectively.The zero (0) option enables zero-padding; this implicitly sets fill to 0 and align to =. The width defines the minimum field width; if not specified, then the width will be determined by the content. The comma (,) option enables the use of a group separator, such as a comma for thousands.Depending on the type, the precision either indicates the number of digits that follow the decimal point (types f and %), or the number of significant digits (types ​, e, g, r, s and p). If the precision is not specified, it defaults to 6 for all types except ​ (none), which defaults to 12. Precision is ignored for integer formats (types b, o, d, x, and X) and character data (type c). See precisionFixed and precisionRound for help picking an appropriate precision.The ~ option trims insignificant trailing zeros across all format types. This is most commonly used in conjunction with types r, e, s and %. For example:jsd3.format("s")(1500) // "1.50000k"jsd3.format("~s")(1500) // "1.5k"The available type values are:e - exponent notation.f - fixed point notation.g - either decimal or exponent notation, rounded to significant digits.r - decimal notation, rounded to significant digits.s - decimal notation with an SI prefix, rounded to significant digits.% - multiply by 100, and then decimal notation with a percent sign.p - multiply by 100, round to significant digits, and then decimal notation with a percent sign.b - binary notation, rounded to integer.o - octal notation, rounded to integer.d - decimal notation, rounded to integer.x - hexadecimal notation, using lower-case letters, rounded to integer.X - hexadecimal notation, using upper-case letters, rounded to integer.c - character data, for a string of text.The type ​ (none) is also supported as shorthand for ~g (with a default precision of 12 instead of 6), and the type n is shorthand for ,g. For the g, n and ​ (none) types, decimal notation is used if the resulting string would have precision or fewer digits; otherwise, exponent notation is used. For example:jsd3.format(".2")(42) // "42"jsd3.format(".2")(4.2) // "4.2"jsd3.format(".1")(42) // "4e+1"jsd3.format(".1")(4.2) // "4"locale.formatPrefix(specifier, value) ​jsconst f = d3.formatPrefix(",.0", 1e-6);Source · Equivalent to locale.format, except the returned function will convert values to the units of the appropriate SI prefix for the specified numeric reference value before formatting in fixed point notation. The following prefixes are supported:y - yocto, 10⁻²⁴z - zepto, 10⁻²¹a - atto, 10⁻¹⁸f - femto, 10⁻¹⁵p - pico, 10⁻¹²n - nano, 10⁻⁹µ - micro, 10⁻⁶m - milli, 10⁻³​ (none) - 10⁰k - kilo, 10³M - mega, 10⁶G - giga, 10⁹T - tera, 10¹²P - peta, 10¹⁵E - exa, 10¹⁸Z - zetta, 10²¹Y - yotta, 10²⁴Unlike locale.format with the s format type, this method returns a formatter with a consistent SI prefix, rather than computing the prefix dynamically for each number. In addition, the precision for the given specifier represents the number of digits past the decimal point (as with f fixed point notation), not the number of significant digits. For example:jsconst f = d3.formatPrefix(",.0", 1e-6);
f(0.00042); // "420µ"
f(0.0042); // "4,200µ"This method is useful when formatting multiple numbers in the same units for easy comparison. See precisionPrefix for help picking an appropriate precision.formatSpecifier(specifier) ​jsd3.formatSpecifier(".1f")Source · Parses the specified specifier, returning an object with exposed fields that correspond to the format specification mini-language and a toString method that reconstructs the specifier. For example, formatSpecifier("s") returns:jsFormatSpecifier {
  "fill": " ",
  "align": ">",
  "sign": "-",
  "symbol": "",
  "zero": false,
  "width": undefined,
  "comma": false,
  "precision": undefined,
  "trim": false,
  "type": "s"
}This method is useful for understanding how format specifiers are parsed and for deriving new specifiers. For example, you might compute an appropriate precision based on the numbers you want to format using precisionFixed and then create a new format:jsconst s = d3.formatSpecifier("f");
s.precision = d3.precisionFixed(0.01);
const f = d3.format(s);
f(42); // "42.00";new d3.FormatSpecifier(specifier) ​jsnew d3.FormatSpecifier({type: "f", precision: 1})Source · Given the specified specifier object, returning an object with exposed fields that correspond to the format specification mini-language and a toString method that reconstructs the specifier. For example, new FormatSpecifier({type: "s"}) returns:jsFormatSpecifier {
  "fill": " ",
  "align": ">",
  "sign": "-",
  "symbol": "",
  "zero": false,
  "width": undefined,
  "comma": false,
  "precision": undefined,
  "trim": false,
  "type": "s"
}precisionFixed(step) ​jsd3.precisionFixed(0.01) // 2Source · Returns a suggested decimal precision for fixed point notation given the specified numeric step value. The step represents the minimum absolute difference between values that will be formatted. (This assumes that the values to be formatted are also multiples of step.) For example, given the numbers 1, 1.5, and 2, the step should be 0.5 and the suggested precision is 1:jsconst p = d3.precisionFixed(0.5);
const f = d3.format("." + p + "f");
f(1);   // "1.0"
f(1.5); // "1.5"
f(2);   // "2.0"Whereas for the numbers 1, 2 and 3, the step should be 1 and the suggested precision is 0:jsconst p = d3.precisionFixed(1);
const f = d3.format("." + p + "f");
f(1); // "1"
f(2); // "2"
f(3); // "3"Note: for the % format type, subtract two:jsconst p = Math.max(0, d3.precisionFixed(0.05) - 2);
const f = d3.format("." + p + "%");
f(0.45); // "45%"
f(0.50); // "50%"
f(0.55); // "55%"precisionPrefix(step, value) ​jsd3.precisionPrefix(1e5, 1.3e6) // 1Source · Returns a suggested decimal precision for use with locale.formatPrefix given the specified numeric step and reference value. The step represents the minimum absolute difference between values that will be formatted, and value determines which SI prefix will be used. (This assumes that the values to be formatted are also multiples of step.) For example, given the numbers 1.1e6, 1.2e6, and 1.3e6, the step should be 1e5, the value could be 1.3e6, and the suggested precision is 1:jsconst p = d3.precisionPrefix(1e5, 1.3e6);
const f = d3.formatPrefix("." + p, 1.3e6);
f(1.1e6); // "1.1M"
f(1.2e6); // "1.2M"
f(1.3e6); // "1.3M"precisionRound(step, max) ​jsd3.precisionRound(0.01, 1.01) // 3Source · Returns a suggested decimal precision for format types that round to significant digits given the specified numeric step and max values. The step represents the minimum absolute difference between values that will be formatted, and the max represents the largest absolute value that will be formatted. (This assumes that the values to be formatted are also multiples of step.) For example, given the numbers 0.99, 1.0, and 1.01, the step should be 0.01, the max should be 1.01, and the suggested precision is 3:jsconst p = d3.precisionRound(0.01, 1.01);
const f = d3.format("." + p + "r");
f(0.99); // "0.990"
f(1.0);  // "1.00"
f(1.01); // "1.01"Whereas for the numbers 0.9, 1.0, and 1.1, the step should be 0.1, the max should be 1.1, and the suggested precision is 2:jsconst p = d3.precisionRound(0.1, 1.1);
const f = d3.format("." + p + "r");
f(0.9); // "0.90"
f(1.0); // "1.0"
f(1.1); // "1.1"Note: for the e format type, subtract one:jsconst p = Math.max(0, d3.precisionRound(0.01, 1.01) - 1);
const f = d3.format("." + p + "e");
f(0.01); // "1.00e-2"
f(1.01); // "1.01e+0"\n\nSearchK7.9.0GitHub️ 110.0kOn this paged3-format ​Ever noticed how sometimes JavaScript doesn’t display numbers the way you expect? Like, you tried to print tenths with a simple loop:jsfor (let i = 0; i < 10; ++i) {
  console.log(0.1 * i);
}And you got this:0
0.1
0.2
0.30000000000000004
0.4
0.5
0.6000000000000001
0.7000000000000001
0.8
0.9Welcome to binary floating point! ಠ_ಠYet rounding error is not the only reason to customize number formatting. A table of numbers should be formatted consistently for comparison; above, 0.0 would be better than 0. Large numbers should have grouped digits (e.g., 42,000) or be in scientific or metric notation (4.2e+4, 42k). Currencies should have fixed precision ($3.50). Reported numerical results should be rounded to significant digits (4021 becomes 4000). Number formats should appropriate to the reader’s locale (42.000,00 or 42,000.00). The list goes on.Formatting numbers for human consumption is the purpose of d3-format, which is modeled after Python 3’s format specification mini-language (PEP 3101). Revisiting the example above:jsconst f = d3.format(".1f");
for (let i = 0; i < 10; ++i) {
  console.log(f(0.1 * i));
}Now you get this:0.0
0.1
0.2
0.3
0.4
0.5
0.6
0.7
0.8
0.9But d3-format is much more than an alias for number.toFixed! A few more examples:jsd3.format(".0%")(0.123) // rounded percentage, "12%"jsd3.format("($.2f")(-3.5) // localized fixed-point currency, "(£3.50)"jsd3.format("+20")(42) // space-filled and signed, "                 +42"jsd3.format(".^20")(42) // dot-filled and centered, ".........42........."jsd3.format(".2s")(42e6) // SI-prefix with two significant digits, "42M"jsd3.format("#x")(48879) // prefixed lowercase hexadecimal, "0xbeef"jsd3.format(",.2r")(4223) // grouped thousands with two significant digits, "4,200"See locale.format for a detailed specification, and try running d3.formatSpecifier on the above formats to decode their meaning.Also see number.toLocaleString.format(specifier) ​jsconst f = d3.format(".2f");Source · An alias for locale.format on the default locale.formatPrefix(specifier, value) ​jsconst f = d3.formatPrefix(",.0", 1e-6);Source · An alias for locale.formatPrefix on the default locale.formatLocale(definition) ​jsconst enUs = d3.formatLocale({
  thousands: ",",
  grouping: [3],
  currency: ["$", ""]
});Source · Returns a locale object for the specified definition with locale.format and locale.formatPrefix methods. The definition must include the following properties:decimal - the decimal point (e.g., ".").thousands - the group separator (e.g., ",").grouping - the array of group sizes (e.g., [3]), cycled as needed.currency - the currency prefix and suffix (e.g., ["$", ""]).numerals - optional; an array of ten strings to replace the numerals 0-9.percent - optional; the percent sign (defaults to "%").minus - optional; the minus sign (defaults to "−").nan - optional; the not-a-number value (defaults "NaN").Note that the thousands property is a misnomer, as the grouping definition allows groups other than thousands.formatDefaultLocale(definition) ​jsconst enUs = d3.formatDefaultLocale({
  thousands: ",",
  grouping: [3],
  currency: ["$", ""]
});Source · Equivalent to d3.formatLocale, except it also redefines d3.format and d3.formatPrefix to the new locale’s locale.format and locale.formatPrefix. If you do not set a default locale, it defaults to U.S. English.locale.format(specifier) ​jsconst f = d3.format(".2f");Source · Returns a new format function for the given string specifier. The returned function takes a number as the only argument, and returns a string representing the formatted number. The general form of a specifier is:[​[fill]align][sign][symbol][0][width][,][.precision][~][type]The fill can be any character. The presence of a fill character is signaled by the align character following it, which must be one of the following:> - Forces the field to be right-aligned within the available space. (Default behavior).< - Forces the field to be left-aligned within the available space.^ - Forces the field to be centered within the available space.= - like >, but with any sign and symbol to the left of any padding.The sign can be:- - nothing for zero or positive and a minus sign for negative. (Default behavior.)+ - a plus sign for zero or positive and a minus sign for negative.( - nothing for zero or positive and parentheses for negative.  (space) - a space for zero or positive and a minus sign for negative.The symbol can be:$ - apply currency symbols per the locale definition.# - for binary, octal, or hexadecimal notation, prefix by 0b, 0o, or 0x, respectively.The zero (0) option enables zero-padding; this implicitly sets fill to 0 and align to =. The width defines the minimum field width; if not specified, then the width will be determined by the content. The comma (,) option enables the use of a group separator, such as a comma for thousands.Depending on the type, the precision either indicates the number of digits that follow the decimal point (types f and %), or the number of significant digits (types ​, e, g, r, s and p). If the precision is not specified, it defaults to 6 for all types except ​ (none), which defaults to 12. Precision is ignored for integer formats (types b, o, d, x, and X) and character data (type c). See precisionFixed and precisionRound for help picking an appropriate precision.The ~ option trims insignificant trailing zeros across all format types. This is most commonly used in conjunction with types r, e, s and %. For example:jsd3.format("s")(1500) // "1.50000k"jsd3.format("~s")(1500) // "1.5k"The available type values are:e - exponent notation.f - fixed point notation.g - either decimal or exponent notation, rounded to significant digits.r - decimal notation, rounded to significant digits.s - decimal notation with an SI prefix, rounded to significant digits.% - multiply by 100, and then decimal notation with a percent sign.p - multiply by 100, round to significant digits, and then decimal notation with a percent sign.b - binary notation, rounded to integer.o - octal notation, rounded to integer.d - decimal notation, rounded to integer.x - hexadecimal notation, using lower-case letters, rounded to integer.X - hexadecimal notation, using upper-case letters, rounded to integer.c - character data, for a string of text.The type ​ (none) is also supported as shorthand for ~g (with a default precision of 12 instead of 6), and the type n is shorthand for ,g. For the g, n and ​ (none) types, decimal notation is used if the resulting string would have precision or fewer digits; otherwise, exponent notation is used. For example:jsd3.format(".2")(42) // "42"jsd3.format(".2")(4.2) // "4.2"jsd3.format(".1")(42) // "4e+1"jsd3.format(".1")(4.2) // "4"locale.formatPrefix(specifier, value) ​jsconst f = d3.formatPrefix(",.0", 1e-6);Source · Equivalent to locale.format, except the returned function will convert values to the units of the appropriate SI prefix for the specified numeric reference value before formatting in fixed point notation. The following prefixes are supported:y - yocto, 10⁻²⁴z - zepto, 10⁻²¹a - atto, 10⁻¹⁸f - femto, 10⁻¹⁵p - pico, 10⁻¹²n - nano, 10⁻⁹µ - micro, 10⁻⁶m - milli, 10⁻³​ (none) - 10⁰k - kilo, 10³M - mega, 10⁶G - giga, 10⁹T - tera, 10¹²P - peta, 10¹⁵E - exa, 10¹⁸Z - zetta, 10²¹Y - yotta, 10²⁴Unlike locale.format with the s format type, this method returns a formatter with a consistent SI prefix, rather than computing the prefix dynamically for each number. In addition, the precision for the given specifier represents the number of digits past the decimal point (as with f fixed point notation), not the number of significant digits. For example:jsconst f = d3.formatPrefix(",.0", 1e-6);
f(0.00042); // "420µ"
f(0.0042); // "4,200µ"This method is useful when formatting multiple numbers in the same units for easy comparison. See precisionPrefix for help picking an appropriate precision.formatSpecifier(specifier) ​jsd3.formatSpecifier(".1f")Source · Parses the specified specifier, returning an object with exposed fields that correspond to the format specification mini-language and a toString method that reconstructs the specifier. For example, formatSpecifier("s") returns:jsFormatSpecifier {
  "fill": " ",
  "align": ">",
  "sign": "-",
  "symbol": "",
  "zero": false,
  "width": undefined,
  "comma": false,
  "precision": undefined,
  "trim": false,
  "type": "s"
}This method is useful for understanding how format specifiers are parsed and for deriving new specifiers. For example, you might compute an appropriate precision based on the numbers you want to format using precisionFixed and then create a new format:jsconst s = d3.formatSpecifier("f");
s.precision = d3.precisionFixed(0.01);
const f = d3.format(s);
f(42); // "42.00";new d3.FormatSpecifier(specifier) ​jsnew d3.FormatSpecifier({type: "f", precision: 1})Source · Given the specified specifier object, returning an object with exposed fields that correspond to the format specification mini-language and a toString method that reconstructs the specifier. For example, new FormatSpecifier({type: "s"}) returns:jsFormatSpecifier {
  "fill": " ",
  "align": ">",
  "sign": "-",
  "symbol": "",
  "zero": false,
  "width": undefined,
  "comma": false,
  "precision": undefined,
  "trim": false,
  "type": "s"
}precisionFixed(step) ​jsd3.precisionFixed(0.01) // 2Source · Returns a suggested decimal precision for fixed point notation given the specified numeric step value. The step represents the minimum absolute difference between values that will be formatted. (This assumes that the values to be formatted are also multiples of step.) For example, given the numbers 1, 1.5, and 2, the step should be 0.5 and the suggested precision is 1:jsconst p = d3.precisionFixed(0.5);
const f = d3.format("." + p + "f");
f(1);   // "1.0"
f(1.5); // "1.5"
f(2);   // "2.0"Whereas for the numbers 1, 2 and 3, the step should be 1 and the suggested precision is 0:jsconst p = d3.precisionFixed(1);
const f = d3.format("." + p + "f");
f(1); // "1"
f(2); // "2"
f(3); // "3"Note: for the % format type, subtract two:jsconst p = Math.max(0, d3.precisionFixed(0.05) - 2);
const f = d3.format("." + p + "%");
f(0.45); // "45%"
f(0.50); // "50%"
f(0.55); // "55%"precisionPrefix(step, value) ​jsd3.precisionPrefix(1e5, 1.3e6) // 1Source · Returns a suggested decimal precision for use with locale.formatPrefix given the specified numeric step and reference value. The step represents the minimum absolute difference between values that will be formatted, and value determines which SI prefix will be used. (This assumes that the values to be formatted are also multiples of step.) For example, given the numbers 1.1e6, 1.2e6, and 1.3e6, the step should be 1e5, the value could be 1.3e6, and the suggested precision is 1:jsconst p = d3.precisionPrefix(1e5, 1.3e6);
const f = d3.formatPrefix("." + p, 1.3e6);
f(1.1e6); // "1.1M"
f(1.2e6); // "1.2M"
f(1.3e6); // "1.3M"precisionRound(step, max) ​jsd3.precisionRound(0.01, 1.01) // 3Source · Returns a suggested decimal precision for format types that round to significant digits given the specified numeric step and max values. The step represents the minimum absolute difference between values that will be formatted, and the max represents the largest absolute value that will be formatted. (This assumes that the values to be formatted are also multiples of step.) For example, given the numbers 0.99, 1.0, and 1.01, the step should be 0.01, the max should be 1.01, and the suggested precision is 3:jsconst p = d3.precisionRound(0.01, 1.01);
const f = d3.format("." + p + "r");
f(0.99); // "0.990"
f(1.0);  // "1.00"
f(1.01); // "1.01"Whereas for the numbers 0.9, 1.0, and 1.1, the step should be 0.1, the max should be 1.1, and the suggested precision is 2:jsconst p = d3.precisionRound(0.1, 1.1);
const f = d3.format("." + p + "r");
f(0.9); // "0.90"
f(1.0); // "1.0"
f(1.1); // "1.1"Note: for the e format type, subtract one:jsconst p = Math.max(0, d3.precisionRound(0.01, 1.01) - 1);
const f = d3.format("." + p + "e");
f(0.01); // "1.00e-2"
f(1.01); // "1.01e+0"PagerPrevious paged3-fetchNext paged3-random\n\nd3-format ​Ever noticed how sometimes JavaScript doesn’t display numbers the way you expect? Like, you tried to print tenths with a simple loop:jsfor (let i = 0; i < 10; ++i) {
  console.log(0.1 * i);
}And you got this:0
0.1
0.2
0.30000000000000004
0.4
0.5
0.6000000000000001
0.7000000000000001
0.8
0.9Welcome to binary floating point! ಠ_ಠYet rounding error is not the only reason to customize number formatting. A table of numbers should be formatted consistently for comparison; above, 0.0 would be better than 0. Large numbers should have grouped digits (e.g., 42,000) or be in scientific or metric notation (4.2e+4, 42k). Currencies should have fixed precision ($3.50). Reported numerical results should be rounded to significant digits (4021 becomes 4000). Number formats should appropriate to the reader’s locale (42.000,00 or 42,000.00). The list goes on.Formatting numbers for human consumption is the purpose of d3-format, which is modeled after Python 3’s format specification mini-language (PEP 3101). Revisiting the example above:jsconst f = d3.format(".1f");
for (let i = 0; i < 10; ++i) {
  console.log(f(0.1 * i));
}Now you get this:0.0
0.1
0.2
0.3
0.4
0.5
0.6
0.7
0.8
0.9But d3-format is much more than an alias for number.toFixed! A few more examples:jsd3.format(".0%")(0.123) // rounded percentage, "12%"jsd3.format("($.2f")(-3.5) // localized fixed-point currency, "(£3.50)"jsd3.format("+20")(42) // space-filled and signed, "                 +42"jsd3.format(".^20")(42) // dot-filled and centered, ".........42........."jsd3.format(".2s")(42e6) // SI-prefix with two significant digits, "42M"jsd3.format("#x")(48879) // prefixed lowercase hexadecimal, "0xbeef"jsd3.format(",.2r")(4223) // grouped thousands with two significant digits, "4,200"See locale.format for a detailed specification, and try running d3.formatSpecifier on the above formats to decode their meaning.Also see number.toLocaleString.format(specifier) ​jsconst f = d3.format(".2f");Source · An alias for locale.format on the default locale.formatPrefix(specifier, value) ​jsconst f = d3.formatPrefix(",.0", 1e-6);Source · An alias for locale.formatPrefix on the default locale.formatLocale(definition) ​jsconst enUs = d3.formatLocale({
  thousands: ",",
  grouping: [3],
  currency: ["$", ""]
});Source · Returns a locale object for the specified definition with locale.format and locale.formatPrefix methods. The definition must include the following properties:decimal - the decimal point (e.g., ".").thousands - the group separator (e.g., ",").grouping - the array of group sizes (e.g., [3]), cycled as needed.currency - the currency prefix and suffix (e.g., ["$", ""]).numerals - optional; an array of ten strings to replace the numerals 0-9.percent - optional; the percent sign (defaults to "%").minus - optional; the minus sign (defaults to "−").nan - optional; the not-a-number value (defaults "NaN").Note that the thousands property is a misnomer, as the grouping definition allows groups other than thousands.formatDefaultLocale(definition) ​jsconst enUs = d3.formatDefaultLocale({
  thousands: ",",
  grouping: [3],
  currency: ["$", ""]
});Source · Equivalent to d3.formatLocale, except it also redefines d3.format and d3.formatPrefix to the new locale’s locale.format and locale.formatPrefix. If you do not set a default locale, it defaults to U.S. English.locale.format(specifier) ​jsconst f = d3.format(".2f");Source · Returns a new format function for the given string specifier. The returned function takes a number as the only argument, and returns a string representing the formatted number. The general form of a specifier is:[​[fill]align][sign][symbol][0][width][,][.precision][~][type]The fill can be any character. The presence of a fill character is signaled by the align character following it, which must be one of the following:> - Forces the field to be right-aligned within the available space. (Default behavior).< - Forces the field to be left-aligned within the available space.^ - Forces the field to be centered within the available space.= - like >, but with any sign and symbol to the left of any padding.The sign can be:- - nothing for zero or positive and a minus sign for negative. (Default behavior.)+ - a plus sign for zero or positive and a minus sign for negative.( - nothing for zero or positive and parentheses for negative.  (space) - a space for zero or positive and a minus sign for negative.The symbol can be:$ - apply currency symbols per the locale definition.# - for binary, octal, or hexadecimal notation, prefix by 0b, 0o, or 0x, respectively.The zero (0) option enables zero-padding; this implicitly sets fill to 0 and align to =. The width defines the minimum field width; if not specified, then the width will be determined by the content. The comma (,) option enables the use of a group separator, such as a comma for thousands.Depending on the type, the precision either indicates the number of digits that follow the decimal point (types f and %), or the number of significant digits (types ​, e, g, r, s and p). If the precision is not specified, it defaults to 6 for all types except ​ (none), which defaults to 12. Precision is ignored for integer formats (types b, o, d, x, and X) and character data (type c). See precisionFixed and precisionRound for help picking an appropriate precision.The ~ option trims insignificant trailing zeros across all format types. This is most commonly used in conjunction with types r, e, s and %. For example:jsd3.format("s")(1500) // "1.50000k"jsd3.format("~s")(1500) // "1.5k"The available type values are:e - exponent notation.f - fixed point notation.g - either decimal or exponent notation, rounded to significant digits.r - decimal notation, rounded to significant digits.s - decimal notation with an SI prefix, rounded to significant digits.% - multiply by 100, and then decimal notation with a percent sign.p - multiply by 100, round to significant digits, and then decimal notation with a percent sign.b - binary notation, rounded to integer.o - octal notation, rounded to integer.d - decimal notation, rounded to integer.x - hexadecimal notation, using lower-case letters, rounded to integer.X - hexadecimal notation, using upper-case letters, rounded to integer.c - character data, for a string of text.The type ​ (none) is also supported as shorthand for ~g (with a default precision of 12 instead of 6), and the type n is shorthand for ,g. For the g, n and ​ (none) types, decimal notation is used if the resulting string would have precision or fewer digits; otherwise, exponent notation is used. For example:jsd3.format(".2")(42) // "42"jsd3.format(".2")(4.2) // "4.2"jsd3.format(".1")(42) // "4e+1"jsd3.format(".1")(4.2) // "4"locale.formatPrefix(specifier, value) ​jsconst f = d3.formatPrefix(",.0", 1e-6);Source · Equivalent to locale.format, except the returned function will convert values to the units of the appropriate SI prefix for the specified numeric reference value before formatting in fixed point notation. The following prefixes are supported:y - yocto, 10⁻²⁴z - zepto, 10⁻²¹a - atto, 10⁻¹⁸f - femto, 10⁻¹⁵p - pico, 10⁻¹²n - nano, 10⁻⁹µ - micro, 10⁻⁶m - milli, 10⁻³​ (none) - 10⁰k - kilo, 10³M - mega, 10⁶G - giga, 10⁹T - tera, 10¹²P - peta, 10¹⁵E - exa, 10¹⁸Z - zetta, 10²¹Y - yotta, 10²⁴Unlike locale.format with the s format type, this method returns a formatter with a consistent SI prefix, rather than computing the prefix dynamically for each number. In addition, the precision for the given specifier represents the number of digits past the decimal point (as with f fixed point notation), not the number of significant digits. For example:jsconst f = d3.formatPrefix(",.0", 1e-6);
f(0.00042); // "420µ"
f(0.0042); // "4,200µ"This method is useful when formatting multiple numbers in the same units for easy comparison. See precisionPrefix for help picking an appropriate precision.formatSpecifier(specifier) ​jsd3.formatSpecifier(".1f")Source · Parses the specified specifier, returning an object with exposed fields that correspond to the format specification mini-language and a toString method that reconstructs the specifier. For example, formatSpecifier("s") returns:jsFormatSpecifier {
  "fill": " ",
  "align": ">",
  "sign": "-",
  "symbol": "",
  "zero": false,
  "width": undefined,
  "comma": false,
  "precision": undefined,
  "trim": false,
  "type": "s"
}This method is useful for understanding how format specifiers are parsed and for deriving new specifiers. For example, you might compute an appropriate precision based on the numbers you want to format using precisionFixed and then create a new format:jsconst s = d3.formatSpecifier("f");
s.precision = d3.precisionFixed(0.01);
const f = d3.format(s);
f(42); // "42.00";new d3.FormatSpecifier(specifier) ​jsnew d3.FormatSpecifier({type: "f", precision: 1})Source · Given the specified specifier object, returning an object with exposed fields that correspond to the format specification mini-language and a toString method that reconstructs the specifier. For example, new FormatSpecifier({type: "s"}) returns:jsFormatSpecifier {
  "fill": " ",
  "align": ">",
  "sign": "-",
  "symbol": "",
  "zero": false,
  "width": undefined,
  "comma": false,
  "precision": undefined,
  "trim": false,
  "type": "s"
}precisionFixed(step) ​jsd3.precisionFixed(0.01) // 2Source · Returns a suggested decimal precision for fixed point notation given the specified numeric step value. The step represents the minimum absolute difference between values that will be formatted. (This assumes that the values to be formatted are also multiples of step.) For example, given the numbers 1, 1.5, and 2, the step should be 0.5 and the suggested precision is 1:jsconst p = d3.precisionFixed(0.5);
const f = d3.format("." + p + "f");
f(1);   // "1.0"
f(1.5); // "1.5"
f(2);   // "2.0"Whereas for the numbers 1, 2 and 3, the step should be 1 and the suggested precision is 0:jsconst p = d3.precisionFixed(1);
const f = d3.format("." + p + "f");
f(1); // "1"
f(2); // "2"
f(3); // "3"Note: for the % format type, subtract two:jsconst p = Math.max(0, d3.precisionFixed(0.05) - 2);
const f = d3.format("." + p + "%");
f(0.45); // "45%"
f(0.50); // "50%"
f(0.55); // "55%"precisionPrefix(step, value) ​jsd3.precisionPrefix(1e5, 1.3e6) // 1Source · Returns a suggested decimal precision for use with locale.formatPrefix given the specified numeric step and reference value. The step represents the minimum absolute difference between values that will be formatted, and value determines which SI prefix will be used. (This assumes that the values to be formatted are also multiples of step.) For example, given the numbers 1.1e6, 1.2e6, and 1.3e6, the step should be 1e5, the value could be 1.3e6, and the suggested precision is 1:jsconst p = d3.precisionPrefix(1e5, 1.3e6);
const f = d3.formatPrefix("." + p, 1.3e6);
f(1.1e6); // "1.1M"
f(1.2e6); // "1.2M"
f(1.3e6); // "1.3M"precisionRound(step, max) ​jsd3.precisionRound(0.01, 1.01) // 3Source · Returns a suggested decimal precision for format types that round to significant digits given the specified numeric step and max values. The step represents the minimum absolute difference between values that will be formatted, and the max represents the largest absolute value that will be formatted. (This assumes that the values to be formatted are also multiples of step.) For example, given the numbers 0.99, 1.0, and 1.01, the step should be 0.01, the max should be 1.01, and the suggested precision is 3:jsconst p = d3.precisionRound(0.01, 1.01);
const f = d3.format("." + p + "r");
f(0.99); // "0.990"
f(1.0);  // "1.00"
f(1.01); // "1.01"Whereas for the numbers 0.9, 1.0, and 1.1, the step should be 0.1, the max should be 1.1, and the suggested precision is 2:jsconst p = d3.precisionRound(0.1, 1.1);
const f = d3.format("." + p + "r");
f(0.9); // "0.90"
f(1.0); // "1.0"
f(1.1); // "1.1"Note: for the e format type, subtract one:jsconst p = Math.max(0, d3.precisionRound(0.01, 1.01) - 1);
const f = d3.format("." + p + "e");
f(0.01); // "1.00e-2"
f(1.01); // "1.01e+0"\n\n\n\nd3-random ​Generate random numbers from various distributions. For seeded random number generation, see random.source and randomLcg.randomUniform(min, max) ​jsd3.randomUniform(6) // generate numbers ≥0 and <6Examples · Source · Returns a function for generating random numbers with a uniform distribution. The minimum allowed value of a returned number is min (inclusive), and the maximum is max (exclusive). If min is not specified, it defaults to 0; if max is not specified, it defaults to 1. For example:randomInt(min, max) ​jsd3.randomInt(100) // generate integers ≥0 and <100Examples · Source · Returns a function for generating random integers with a uniform distribution. The minimum allowed value of a returned number is ⌊min⌋ (inclusive), and the maximum is ⌊max - 1⌋ (inclusive). If min is not specified, it defaults to 0. For example:randomNormal(mu, sigma) ​jsd3.randomNormal(0, 1) // mean of 0, and standard deviation of 1Examples · Source · Returns a function for generating random numbers with a normal (Gaussian) distribution. The expected value of the generated numbers is mu, with the given standard deviation sigma. If mu is not specified, it defaults to 0; if sigma is not specified, it defaults to 1.randomLogNormal(mu, sigma) ​jsd3.randomLogNormal(0, 1)Examples · Source · Returns a function for generating random numbers with a log-normal distribution. The expected value of the random variable’s natural logarithm is mu, with the given standard deviation sigma. If mu is not specified, it defaults to 0; if sigma is not specified, it defaults to 1.randomBates(n) ​jsd3.randomBates(3) // generates numbers between 0 and 1Examples · Source · Returns a function for generating random numbers with a Bates distribution with n independent variables. The case of fractional n is handled as with d3.randomIrwinHall, and d3.randomBates(0) is equivalent to d3.randomUniform().randomIrwinHall(n) ​jsd3.randomIrwinHall(3) // generates numbers between 0 and 3Examples · Source · Returns a function for generating random numbers with an Irwin–Hall distribution with n independent variables. If the fractional part of n is non-zero, this is treated as adding d3.randomUniform() times that fractional part to the integral part.randomExponential(lambda) ​jsd3.randomExponential(1 / 40)Examples · Source · Returns a function for generating random numbers with an exponential distribution with the rate lambda; equivalent to time between events in a Poisson process with a mean of 1 / lambda. For example, randomExponential(1 / 40) generates random times between events where, on average, one event occurs every 40 units of time.randomPareto(alpha) ​jsd3.randomPareto(6)Examples · Source · Returns a function for generating random numbers with a Pareto distribution with the shape alpha. The value alpha must be a positive value.randomBernoulli(p) ​jsd3.randomBernoulli(0.5)Examples · Source · Returns a function for generating either 1 or 0 according to a Bernoulli distribution with 1 being returned with success probability p and 0 with failure probability q = 1 - p. The value p is in the range [0, 1].randomGeometric(p) ​jsd3.randomGeometric(0.1)Examples · Source · Returns a function for generating numbers with a geometric distribution with success probability p. The value p is in the range [0, 1].randomBinomial(n, p) ​jsd3.randomBinomial(40, 0.5)Examples · Source · Returns a function for generating random numbers with a binomial distribution with n the number of trials and p the probability of success in each trial. The value n is greater or equal to 0, and the value p is in the range [0, 1].randomGamma(k, theta) ​jsd3.randomGamma(2, 1)Examples · Source · Returns a function for generating random numbers with a gamma distribution with k the shape parameter and theta the scale parameter. The value k must be a positive value; if theta is not specified, it defaults to 1.randomBeta(alpha, beta) ​jsd3.randomBeta(3, 1.5)Examples · Source · Returns a function for generating random numbers with a beta distribution with alpha and beta shape parameters, which must both be positive.randomWeibull(k, a, b) ​jsd3.randomWeibull(10)Examples · Source · Returns a function for generating random numbers with one of the generalized extreme value distributions, depending on k:If k is positive, the Weibull distribution with shape parameter kIf k is zero, the Gumbel distributionIf k is negative, the Fréchet distribution with shape parameter −kIn all three cases, a is the location parameter and b is the scale parameter. If a is not specified, it defaults to 0; if b is not specified, it defaults to 1.randomCauchy(a, b) ​jsd3.randomCauchy(0, 1) // above, clipped to [-5, 5] because “fat tails”Examples · Source · Returns a function for generating random numbers with a Cauchy distribution. a and b have the same meanings and default values as in d3.randomWeibull.randomLogistic(a, b) ​jsd3.randomLogistic(0, 1)Examples · Source · Returns a function for generating random numbers with a logistic distribution. a and b have the same meanings and default values as in d3.randomWeibull.randomPoisson(lambda) ​jsd3.randomPoisson(400)Examples · Source · Returns a function for generating random numbers with a Poisson distribution with mean lambda.random.source(source) ​jsconst seed = 0.44871573888282423; // any number in [0, 1)
const random = d3.randomNormal.source(d3.randomLcg(seed))(0, 1);
random(); // -0.6253955998897069Examples · Returns the same type of function for generating random numbers but where the given random number generator source is used as the source of randomness instead of Math.random. The given random number generator must implement the same interface as Math.random and only return values in the range [0, 1). This is useful when a seeded random number generator is preferable to Math.random.randomLcg(seed) ​jsd3.randomLcg(42)Examples · Source · Returns a linear congruential generator; this function can be called repeatedly to obtain pseudorandom values well-distributed on the interval [0,1) and with a long period (up to 1 billion numbers), similar to Math.random. A seed can be specified as a real number in the interval [0,1) or as any integer. In the latter case, only the lower 32 bits are considered. Two generators instanced with the same seed generate the same sequence, allowing to create reproducible pseudo-random experiments. If the seed is not specified, one is chosen using Math.random.\n\nSearchK7.9.0GitHub️ 110.0kOn this paged3-random ​Generate random numbers from various distributions. For seeded random number generation, see random.source and randomLcg.randomUniform(min, max) ​jsd3.randomUniform(6) // generate numbers ≥0 and <6Examples · Source · Returns a function for generating random numbers with a uniform distribution. The minimum allowed value of a returned number is min (inclusive), and the maximum is max (exclusive). If min is not specified, it defaults to 0; if max is not specified, it defaults to 1. For example:randomInt(min, max) ​jsd3.randomInt(100) // generate integers ≥0 and <100Examples · Source · Returns a function for generating random integers with a uniform distribution. The minimum allowed value of a returned number is ⌊min⌋ (inclusive), and the maximum is ⌊max - 1⌋ (inclusive). If min is not specified, it defaults to 0. For example:randomNormal(mu, sigma) ​jsd3.randomNormal(0, 1) // mean of 0, and standard deviation of 1Examples · Source · Returns a function for generating random numbers with a normal (Gaussian) distribution. The expected value of the generated numbers is mu, with the given standard deviation sigma. If mu is not specified, it defaults to 0; if sigma is not specified, it defaults to 1.randomLogNormal(mu, sigma) ​jsd3.randomLogNormal(0, 1)Examples · Source · Returns a function for generating random numbers with a log-normal distribution. The expected value of the random variable’s natural logarithm is mu, with the given standard deviation sigma. If mu is not specified, it defaults to 0; if sigma is not specified, it defaults to 1.randomBates(n) ​jsd3.randomBates(3) // generates numbers between 0 and 1Examples · Source · Returns a function for generating random numbers with a Bates distribution with n independent variables. The case of fractional n is handled as with d3.randomIrwinHall, and d3.randomBates(0) is equivalent to d3.randomUniform().randomIrwinHall(n) ​jsd3.randomIrwinHall(3) // generates numbers between 0 and 3Examples · Source · Returns a function for generating random numbers with an Irwin–Hall distribution with n independent variables. If the fractional part of n is non-zero, this is treated as adding d3.randomUniform() times that fractional part to the integral part.randomExponential(lambda) ​jsd3.randomExponential(1 / 40)Examples · Source · Returns a function for generating random numbers with an exponential distribution with the rate lambda; equivalent to time between events in a Poisson process with a mean of 1 / lambda. For example, randomExponential(1 / 40) generates random times between events where, on average, one event occurs every 40 units of time.randomPareto(alpha) ​jsd3.randomPareto(6)Examples · Source · Returns a function for generating random numbers with a Pareto distribution with the shape alpha. The value alpha must be a positive value.randomBernoulli(p) ​jsd3.randomBernoulli(0.5)Examples · Source · Returns a function for generating either 1 or 0 according to a Bernoulli distribution with 1 being returned with success probability p and 0 with failure probability q = 1 - p. The value p is in the range [0, 1].randomGeometric(p) ​jsd3.randomGeometric(0.1)Examples · Source · Returns a function for generating numbers with a geometric distribution with success probability p. The value p is in the range [0, 1].randomBinomial(n, p) ​jsd3.randomBinomial(40, 0.5)Examples · Source · Returns a function for generating random numbers with a binomial distribution with n the number of trials and p the probability of success in each trial. The value n is greater or equal to 0, and the value p is in the range [0, 1].randomGamma(k, theta) ​jsd3.randomGamma(2, 1)Examples · Source · Returns a function for generating random numbers with a gamma distribution with k the shape parameter and theta the scale parameter. The value k must be a positive value; if theta is not specified, it defaults to 1.randomBeta(alpha, beta) ​jsd3.randomBeta(3, 1.5)Examples · Source · Returns a function for generating random numbers with a beta distribution with alpha and beta shape parameters, which must both be positive.randomWeibull(k, a, b) ​jsd3.randomWeibull(10)Examples · Source · Returns a function for generating random numbers with one of the generalized extreme value distributions, depending on k:If k is positive, the Weibull distribution with shape parameter kIf k is zero, the Gumbel distributionIf k is negative, the Fréchet distribution with shape parameter −kIn all three cases, a is the location parameter and b is the scale parameter. If a is not specified, it defaults to 0; if b is not specified, it defaults to 1.randomCauchy(a, b) ​jsd3.randomCauchy(0, 1) // above, clipped to [-5, 5] because “fat tails”Examples · Source · Returns a function for generating random numbers with a Cauchy distribution. a and b have the same meanings and default values as in d3.randomWeibull.randomLogistic(a, b) ​jsd3.randomLogistic(0, 1)Examples · Source · Returns a function for generating random numbers with a logistic distribution. a and b have the same meanings and default values as in d3.randomWeibull.randomPoisson(lambda) ​jsd3.randomPoisson(400)Examples · Source · Returns a function for generating random numbers with a Poisson distribution with mean lambda.random.source(source) ​jsconst seed = 0.44871573888282423; // any number in [0, 1)
const random = d3.randomNormal.source(d3.randomLcg(seed))(0, 1);
random(); // -0.6253955998897069Examples · Returns the same type of function for generating random numbers but where the given random number generator source is used as the source of randomness instead of Math.random. The given random number generator must implement the same interface as Math.random and only return values in the range [0, 1). This is useful when a seeded random number generator is preferable to Math.random.randomLcg(seed) ​jsd3.randomLcg(42)Examples · Source · Returns a linear congruential generator; this function can be called repeatedly to obtain pseudorandom values well-distributed on the interval [0,1) and with a long period (up to 1 billion numbers), similar to Math.random. A seed can be specified as a real number in the interval [0,1) or as any integer. In the latter case, only the lower 32 bits are considered. Two generators instanced with the same seed generate the same sequence, allowing to create reproducible pseudo-random experiments. If the seed is not specified, one is chosen using Math.random.PagerPrevious paged3-formatNext paged3-time\n\nd3-random ​Generate random numbers from various distributions. For seeded random number generation, see random.source and randomLcg.randomUniform(min, max) ​jsd3.randomUniform(6) // generate numbers ≥0 and <6Examples · Source · Returns a function for generating random numbers with a uniform distribution. The minimum allowed value of a returned number is min (inclusive), and the maximum is max (exclusive). If min is not specified, it defaults to 0; if max is not specified, it defaults to 1. For example:randomInt(min, max) ​jsd3.randomInt(100) // generate integers ≥0 and <100Examples · Source · Returns a function for generating random integers with a uniform distribution. The minimum allowed value of a returned number is ⌊min⌋ (inclusive), and the maximum is ⌊max - 1⌋ (inclusive). If min is not specified, it defaults to 0. For example:randomNormal(mu, sigma) ​jsd3.randomNormal(0, 1) // mean of 0, and standard deviation of 1Examples · Source · Returns a function for generating random numbers with a normal (Gaussian) distribution. The expected value of the generated numbers is mu, with the given standard deviation sigma. If mu is not specified, it defaults to 0; if sigma is not specified, it defaults to 1.randomLogNormal(mu, sigma) ​jsd3.randomLogNormal(0, 1)Examples · Source · Returns a function for generating random numbers with a log-normal distribution. The expected value of the random variable’s natural logarithm is mu, with the given standard deviation sigma. If mu is not specified, it defaults to 0; if sigma is not specified, it defaults to 1.randomBates(n) ​jsd3.randomBates(3) // generates numbers between 0 and 1Examples · Source · Returns a function for generating random numbers with a Bates distribution with n independent variables. The case of fractional n is handled as with d3.randomIrwinHall, and d3.randomBates(0) is equivalent to d3.randomUniform().randomIrwinHall(n) ​jsd3.randomIrwinHall(3) // generates numbers between 0 and 3Examples · Source · Returns a function for generating random numbers with an Irwin–Hall distribution with n independent variables. If the fractional part of n is non-zero, this is treated as adding d3.randomUniform() times that fractional part to the integral part.randomExponential(lambda) ​jsd3.randomExponential(1 / 40)Examples · Source · Returns a function for generating random numbers with an exponential distribution with the rate lambda; equivalent to time between events in a Poisson process with a mean of 1 / lambda. For example, randomExponential(1 / 40) generates random times between events where, on average, one event occurs every 40 units of time.randomPareto(alpha) ​jsd3.randomPareto(6)Examples · Source · Returns a function for generating random numbers with a Pareto distribution with the shape alpha. The value alpha must be a positive value.randomBernoulli(p) ​jsd3.randomBernoulli(0.5)Examples · Source · Returns a function for generating either 1 or 0 according to a Bernoulli distribution with 1 being returned with success probability p and 0 with failure probability q = 1 - p. The value p is in the range [0, 1].randomGeometric(p) ​jsd3.randomGeometric(0.1)Examples · Source · Returns a function for generating numbers with a geometric distribution with success probability p. The value p is in the range [0, 1].randomBinomial(n, p) ​jsd3.randomBinomial(40, 0.5)Examples · Source · Returns a function for generating random numbers with a binomial distribution with n the number of trials and p the probability of success in each trial. The value n is greater or equal to 0, and the value p is in the range [0, 1].randomGamma(k, theta) ​jsd3.randomGamma(2, 1)Examples · Source · Returns a function for generating random numbers with a gamma distribution with k the shape parameter and theta the scale parameter. The value k must be a positive value; if theta is not specified, it defaults to 1.randomBeta(alpha, beta) ​jsd3.randomBeta(3, 1.5)Examples · Source · Returns a function for generating random numbers with a beta distribution with alpha and beta shape parameters, which must both be positive.randomWeibull(k, a, b) ​jsd3.randomWeibull(10)Examples · Source · Returns a function for generating random numbers with one of the generalized extreme value distributions, depending on k:If k is positive, the Weibull distribution with shape parameter kIf k is zero, the Gumbel distributionIf k is negative, the Fréchet distribution with shape parameter −kIn all three cases, a is the location parameter and b is the scale parameter. If a is not specified, it defaults to 0; if b is not specified, it defaults to 1.randomCauchy(a, b) ​jsd3.randomCauchy(0, 1) // above, clipped to [-5, 5] because “fat tails”Examples · Source · Returns a function for generating random numbers with a Cauchy distribution. a and b have the same meanings and default values as in d3.randomWeibull.randomLogistic(a, b) ​jsd3.randomLogistic(0, 1)Examples · Source · Returns a function for generating random numbers with a logistic distribution. a and b have the same meanings and default values as in d3.randomWeibull.randomPoisson(lambda) ​jsd3.randomPoisson(400)Examples · Source · Returns a function for generating random numbers with a Poisson distribution with mean lambda.random.source(source) ​jsconst seed = 0.44871573888282423; // any number in [0, 1)
const random = d3.randomNormal.source(d3.randomLcg(seed))(0, 1);
random(); // -0.6253955998897069Examples · Returns the same type of function for generating random numbers but where the given random number generator source is used as the source of randomness instead of Math.random. The given random number generator must implement the same interface as Math.random and only return values in the range [0, 1). This is useful when a seeded random number generator is preferable to Math.random.randomLcg(seed) ​jsd3.randomLcg(42)Examples · Source · Returns a linear congruential generator; this function can be called repeatedly to obtain pseudorandom values well-distributed on the interval [0,1) and with a long period (up to 1 billion numbers), similar to Math.random. A seed can be specified as a real number in the interval [0,1) or as any integer. In the latter case, only the lower 32 bits are considered. Two generators instanced with the same seed generate the same sequence, allowing to create reproducible pseudo-random experiments. If the seed is not specified, one is chosen using Math.random.\n\n\n\nd3-time ​When visualizing time series data, analyzing temporal patterns, or working with time in general, the irregularities of conventional time units quickly become apparent. In the Gregorian calendar, for example, most months have 31 days but some have 28, 29 or 30; most years have 365 days but leap years have 366; and with daylight saving, most days have 24 hours but some have 23 or 25. Adding to complexity, daylight saving conventions vary around the world.As a result of these temporal peculiarities, it can be difficult to perform seemingly-trivial tasks. For example, if you want to compute the number of days that have passed between two dates, you can’t simply subtract and divide by 24 hours (86,400,000 ms):jsconst start = new Date(2015, 02, 01); // 2015-03-01T00:00
const end = new Date(2015, 03, 01); // 2015-04-01T00:00
const days = (end - start) / 864e5; // 30.958333333333332, oops! 🤯You can, however, use d3.timeDay.count:jsd3.timeDay.count(start, end) // 31 😌The day interval is one of several provided by d3-time. Each interval represents a conventional unit of time — hours, weeks, months, etc. — and has methods to calculate boundary dates. For example, d3.timeDay computes midnight (typically 12:00 AM local time) of the corresponding day. In addition to rounding and counting, intervals can also be used to generate arrays of boundary dates. For example, to compute each Sunday in the current month:jsconst start = d3.timeMonth.floor(new Date(2015, 0, 15)); // 2015-01-01T00:00
const stop = d3.timeMonth.ceil(new Date(2015, 0, 15)); // 2015-02-01T00:00
const weeks = d3.timeWeek.range(start, stop); // [2015-01-04T00:00, 2015-01-11T00:00, 2015-01-18T00:00, 2015-01-25T00:00]The d3-time module does not implement its own calendaring system; it merely implements a convenient API for calendar math on top of ECMAScript Date. Thus, it ignores leap seconds and can only work with the local time zone and Coordinated Universal Time (UTC).This module is used by D3’s time scales to generate sensible ticks, by D3’s time format, and can also be used directly to do things like calendar layouts.interval(date) ​jsd3.utcMonday() // the latest preceding Monday, UTC timeSource · Equivalent to interval.floor, except if date is not specified, it defaults to the current time. For example, d3.timeYear(date) and d3.timeYear.floor(date) are equivalent.interval.floor(date) ​jsd3.utcMonday.floor(new Date()) // the latest preceding Monday, UTC timeSource · Returns a new date representing the latest interval boundary date before or equal to date. For example, d3.timeDay.floor(date) typically returns 12:00 AM local time on the given date.This method is idempotent: if the specified date is already floored to the current interval, a new date with an identical time is returned. Furthermore, the returned date is the minimum expressible value of the associated interval, such that interval.floor(interval.floor(date) - 1) returns the preceding interval boundary date.Note that the == and === operators do not compare by value with Date objects, and thus you cannot use them to tell whether the specified date has already been floored. Instead, coerce to a number and then compare:js// Returns true if the specified date is a day boundary.
function isDay(date) {
  return +d3.timeDay.floor(date) === +date;
}This is more reliable than testing whether the time is 12:00 AM, as in some time zones midnight may not exist due to daylight saving.interval.round(date) ​jsd3.utcMonday.round(new Date()) // the previous or following Monday, whichever is closerSource · Returns a new date representing the closest interval boundary date to date. For example, d3.timeDay.round(date) typically returns 12:00 AM local time on the given date if it is on or before noon, and 12:00 AM of the following day if it is after noon.This method is idempotent: if the specified date is already rounded to the current interval, a new date with an identical time is returned.interval.ceil(date) ​jsd3.utcMonday.ceil(new Date()) // the following MondaySource · Returns a new date representing the earliest interval boundary date after or equal to date. For example, d3.timeDay.ceil(date) typically returns 12:00 AM local time on the date following the given date.This method is idempotent: if the specified date is already ceilinged to the current interval, a new date with an identical time is returned. Furthermore, the returned date is the maximum expressible value of the associated interval, such that interval.ceil(interval.ceil(date) + 1) returns the following interval boundary date.interval.offset(date, step) ​jsd3.utcDay.offset(new Date(), 1) // the same time tomorrowSource · Returns a new date equal to date plus step intervals. If step is not specified it defaults to 1. If step is negative, then the returned date will be before the specified date; if step is zero, then a copy of the specified date is returned; if step is not an integer, it is floored. This method does not round the specified date to the interval. For example, if date is today at 5:34 PM, then d3.timeDay.offset(date, 1) returns 5:34 PM tomorrow (even if daylight saving changes!).interval.range(start, stop, step) ​jsd3.utcDay.range(new Date("2014-01-01"), new Date("2015-01-01")) // every day in 2014Source · Returns an array of dates representing every interval boundary after or equal to start (inclusive) and before stop (exclusive). If step is specified, then every stepth boundary will be returned; for example, for the d3.timeDay interval a step of 2 will return every other day. If step is not an integer, it is floored.The first date in the returned array is the earliest boundary after or equal to start; subsequent dates are offset by step intervals and floored. Thus, two overlapping ranges may be consistent. For example, this range contains odd days:jsd3.timeDay.range(new Date(2015, 0, 1), new Date(2015, 0, 7), 2) // [2015-01-01T00:00, 2015-01-03T00:00, 2015-01-05T00:00]While this contains even days:jsd3.timeDay.range(new Date(2015, 0, 2), new Date(2015, 0, 8), 2) // [2015-01-02T00:00, 2015-01-04T00:00, 2015-01-06T00:00]To make ranges consistent when a step is specified, use interval.every instead.For convenience, aliases for interval.range are also provided as plural forms of the corresponding interval, such as utcMondays.interval.filter(test) ​Source · Returns a new interval that is a filtered subset of this interval using the specified test function. The test function is passed a date and should return true if and only if the specified date should be considered part of the interval. For example, to create an interval that returns the 1st, 11th, 21th and 31th (if it exists) of each month:jsd3.timeDay.filter((d) => (d.getDate() - 1) % 10 === 0)The returned filtered interval does not support interval.count. See also interval.every.interval.every(step) ​jsd3.unixDay.every(3)Source · Returns a filtered view of this interval representing every stepth date. The meaning of step is dependent on this interval’s parent interval as defined by the field function. For example, d3.timeMinute.every(15) returns an interval representing every fifteen minutes, starting on the hour: :00, :15, :30, :45, etc. Note that for some intervals, the resulting dates may not be uniformly-spaced; d3.timeDay’s parent interval is d3.timeMonth, and thus the interval number resets at the start of each month. If step is not valid, returns null. If step is one, returns this interval.This method can be used in conjunction with interval.range to ensure that two overlapping ranges are consistent. For example, this range contains odd days:jsd3.timeDay.every(2).range(new Date(2015, 0, 1), new Date(2015, 0, 7)) // [2015-01-01T00:00, 2015-01-03T00:00, 2015-01-05T00:00]As does this one:jsd3.timeDay.every(2).range(new Date(2015, 0, 2), new Date(2015, 0, 8)) // [2015-01-03T00:00, 2015-01-05T00:00, 2015-01-07T00:00]The returned filtered interval does not support interval.count. See also interval.filter.interval.count(start, end) ​Source · Returns the number of interval boundaries after start (exclusive) and before or equal to end (inclusive). Note that this behavior is slightly different than interval.range because its purpose is to return the zero-based number of the specified end date relative to the specified start date. For example, to compute the current zero-based day-of-year number:jsd3.timeDay.count(d3.timeYear(now), now) // 177Likewise, to compute the current zero-based week-of-year number for weeks that start on Sunday:jsd3.timeSunday.count(d3.timeYear(now), now) // 25timeInterval(floor, offset, count, field) ​jsconst utcDay = d3.timeInterval(
  (date) => date.setUTCHours(0, 0, 0, 0), // floor
  (date, step) => date.setUTCDate(date.getUTCDate() + step), // offset
  (start, end) => (end - start) / 864e5, // count
  (date) => date.getUTCDate() - 1 // field
);Source · Constructs a new custom interval given the specified floor and offset functions and an optional count function.The floor function takes a single date as an argument and rounds it down to the nearest interval boundary.The offset function takes a date and an integer step as arguments and advances the specified date by the specified number of boundaries; the step may be positive, negative or zero.The optional count function takes a start date and an end date, already floored to the current interval, and returns the number of boundaries between the start (exclusive) and end (inclusive). If a count function is not specified, the returned interval does not expose interval.count or interval.every methods. Note: due to an internal optimization, the specified count function must not invoke interval.count on other time intervals.The optional field function takes a date, already floored to the current interval, and returns the field value of the specified date, corresponding to the number of boundaries between this date (exclusive) and the latest previous parent boundary. For example, for the d3.timeDay interval, this returns the number of days since the start of the month. If a field function is not specified, it defaults to counting the number of interval boundaries since the UNIX epoch of January 1, 1970 UTC. The field function defines the behavior of interval.every.timeMillisecond ​Source · Milliseconds in local time; the shortest available time unit.timeSecond ​Source · Seconds in local time (e.g., 01:23:45.0000 AM); 1,000 milliseconds.timeMinute ​Source · Minutes in local time (e.g., 01:02:00 AM); 60 seconds. Note that ECMAScript ignores leap seconds.timeHour ​Source · Hours in local time (e.g., 01:00 AM); 60 minutes. Note that advancing time by one hour in local time can return the same hour or skip an hour due to daylight saving.timeDay ​Source · Days in local time (e.g., February 7, 2012 at 12:00 AM); typically 24 hours. Days in local time may range from 23 to 25 hours due to daylight saving. d3.unixDay is like d3.utcDay, except it counts days since the UNIX epoch (January 1, 1970) such that interval.every returns uniformly-spaced dates rather than varying based on day-of-month.timeWeek ​Source · Alias for d3.timeSunday; 7 days and typically 168 hours. Weeks in local time may range from 167 to 169 hours due to daylight saving.timeSunday ​Source · Sunday-based weeks in local time (e.g., February 5, 2012 at 12:00 AM).timeMonday ​Source · Monday-based weeks in local time (e.g., February 6, 2012 at 12:00 AM).timeTuesday ​Source · Tuesday-based weeks in local time (e.g., February 7, 2012 at 12:00 AM).timeWednesday ​Source · Wednesday-based weeks in local time (e.g., February 8, 2012 at 12:00 AM).timeThursday ​Source · Thursday-based weeks in local time (e.g., February 9, 2012 at 12:00 AM).timeFriday ​Source · Friday-based weeks in local time (e.g., February 10, 2012 at 12:00 AM).timeSaturday ​Source · Saturday-based weeks in local time (e.g., February 11, 2012 at 12:00 AM).timeMonth ​Source · Months in local time (e.g., February 1, 2012 at 12:00 AM); ranges from 28 to 31 days.timeYear ​Source · Years in local time (e.g., January 1, 2012 at 12:00 AM); ranges from 365 to 366 days.utcMillisecond ​Source · Milliseconds in UTC time; the shortest available time unit.utcSecond ​Source · Seconds in UTC time (e.g., 01:23:45.0000 AM); 1,000 milliseconds.utcMinute ​Source · Minutes in UTC time (e.g., 01:02:00 AM); 60 seconds. Note that ECMAScript ignores leap seconds.utcHour ​Source · Hours in UTC time (e.g., 01:00 AM); 60 minutes.utcDay ​Source · Days in UTC time (e.g., February 7, 2012 at 12:00 AM); 24 hours.utcWeek ​Source · Alias for d3.timeSunday; 7 days and 168 hours.utcSunday ​Source · Sunday-based weeks in UTC time (e.g., February 5, 2012 at 12:00 AM).utcMonday ​Source · Monday-based weeks in UTC time (e.g., February 6, 2012 at 12:00 AM).utcTuesday ​Source · Tuesday-based weeks in UTC time (e.g., February 7, 2012 at 12:00 AM).utcWednesday ​Source · Wednesday-based weeks in UTC time (e.g., February 8, 2012 at 12:00 AM).utcThursday ​Source · Thursday-based weeks in UTC time (e.g., February 9, 2012 at 12:00 AM).utcFriday ​Source · Friday-based weeks in UTC time (e.g., February 10, 2012 at 12:00 AM).utcSaturday ​Source · Saturday-based weeks in UTC time (e.g., February 11, 2012 at 12:00 AM).utcMonth ​Source · Months in UTC time (e.g., February 1, 2012 at 12:00 AM); ranges from 28 to 31 days.utcYear ​Source · Years in UTC time (e.g., January 1, 2012 at 12:00 AM); ranges from 365 to 366 days.unixDay ​Like d3.utcDay, except it counts days since the UNIX epoch (January 1, 1970) such that interval.every returns uniformly-spaced dates rather than varying based on day-of-month.timeMilliseconds(start, stop, step) ​Alias for d3.timeMillisecond.range.timeSeconds(start, stop, step) ​Alias for d3.timeSecond.range.timeMinutes(start, stop, step) ​Alias for d3.timeMinute.range.timeHours(start, stop, step) ​Alias for d3.timeHour.range.timeDays(start, stop, step) ​Alias for d3.timeDay.range.timeWeeks(start, stop, step) ​Alias for d3.timeWeek.range.timeSundays(start, stop, step) ​Alias for d3.timeSunday.range.timeMondays(start, stop, step) ​Alias for d3.timeMonday.range.timeTuesdays(start, stop, step) ​Alias for d3.timeTuesday.range.timeWednesdays(start, stop, step) ​Alias for d3.timeWednesday.range.timeThursdays(start, stop, step) ​Alias for d3.timeThursday.range.timeFridays(start, stop, step) ​Alias for d3.timeFriday.range.timeSaturdays(start, stop, step) ​Alias for d3.timeSaturday.range.timeMonths(start, stop, step) ​Alias for d3.timeMonth.range.timeYears(start, stop, step) ​Alias for d3.timeYear.range.utcMilliseconds(start, stop, step) ​Alias for d3.utcMillisecond.range.utcSeconds(start, stop, step) ​Alias for d3.utcSecond.range.utcMinutes(start, stop, step) ​Alias for d3.utcMinute.range.utcHours(start, stop, step) ​Alias for d3.utcHour.range.utcDays(start, stop, step) ​Alias for d3.utcDay.range.utcWeeks(start, stop, step) ​Alias for d3.utcWeek.range.utcSundays(start, stop, step) ​Alias for d3.utcSunday.range.utcMondays(start, stop, step) ​Alias for d3.utcMonday.range.utcTuesdays(start, stop, step) ​Alias for d3.utcTuesday.range.utcWednesdays(start, stop, step) ​Alias for d3.utcWednesday.range.utcThursdays(start, stop, step) ​Alias for d3.utcThursday.range.utcFridays(start, stop, step) ​Alias for d3.utcFriday.range.utcSaturdays(start, stop, step) ​Alias for d3.utcSaturday.range.utcMonths(start, stop, step) ​Alias for d3.utcMonth.range.utcYears(start, stop, step) ​Alias for d3.utcYear.range.timeTicks(start, stop, count) ​Source · Equivalent to d3.utcTicks, but in local time.timeTickInterval(start, stop, count) ​Source · Returns the time interval that would be used by d3.timeTicks given the same arguments.utcTicks(start, stop, count) ​Source · Returns an array of approximately count dates at regular intervals between start and stop (inclusive). If stop is before start, dates are returned in reverse chronological order; otherwise dates are returned in chronological order. The following UTC time intervals are considered:1 second5 seconds15 seconds30 seconds1 minute5 minutes15 minutes30 minutes1 hour3 hours6 hours12 hours1 day2 days1 week1 month3 months1 yearMultiples of milliseconds (for small ranges) and years (for large ranges) are also considered, following the rules of d3.ticks. The interval producing the number of dates that is closest to count is used. For example:jsconst start = new Date("1970-03-01");
const stop = new Date("1996-03-19");
const count = 4;
const ticks = d3.utcTicks(start, stop, count); // [1975-01-01, 1980-01-01, 1985-01-01, 1990-01-01, 1995-01-01]If count is a time interval, this function behaves similarly to interval.range except that both start and stop are inclusive and it may return dates in reverse chronological order if stop is before start.utcTickInterval(start, stop, count) ​Source · Returns the time interval that would be used by d3.utcTicks given the same arguments. If there is no associated interval, such as when start or stop is invalid, returns null.jsconst start = new Date("1970-03-01");
const stop = new Date("1996-03-19");
const count = 4;
const interval = d3.utcTickInterval(start, stop, count); // d3.utcYear.every(5)\n\nSearchK7.9.0GitHub️ 110.0kOn this paged3-time ​When visualizing time series data, analyzing temporal patterns, or working with time in general, the irregularities of conventional time units quickly become apparent. In the Gregorian calendar, for example, most months have 31 days but some have 28, 29 or 30; most years have 365 days but leap years have 366; and with daylight saving, most days have 24 hours but some have 23 or 25. Adding to complexity, daylight saving conventions vary around the world.As a result of these temporal peculiarities, it can be difficult to perform seemingly-trivial tasks. For example, if you want to compute the number of days that have passed between two dates, you can’t simply subtract and divide by 24 hours (86,400,000 ms):jsconst start = new Date(2015, 02, 01); // 2015-03-01T00:00
const end = new Date(2015, 03, 01); // 2015-04-01T00:00
const days = (end - start) / 864e5; // 30.958333333333332, oops! 🤯You can, however, use d3.timeDay.count:jsd3.timeDay.count(start, end) // 31 😌The day interval is one of several provided by d3-time. Each interval represents a conventional unit of time — hours, weeks, months, etc. — and has methods to calculate boundary dates. For example, d3.timeDay computes midnight (typically 12:00 AM local time) of the corresponding day. In addition to rounding and counting, intervals can also be used to generate arrays of boundary dates. For example, to compute each Sunday in the current month:jsconst start = d3.timeMonth.floor(new Date(2015, 0, 15)); // 2015-01-01T00:00
const stop = d3.timeMonth.ceil(new Date(2015, 0, 15)); // 2015-02-01T00:00
const weeks = d3.timeWeek.range(start, stop); // [2015-01-04T00:00, 2015-01-11T00:00, 2015-01-18T00:00, 2015-01-25T00:00]The d3-time module does not implement its own calendaring system; it merely implements a convenient API for calendar math on top of ECMAScript Date. Thus, it ignores leap seconds and can only work with the local time zone and Coordinated Universal Time (UTC).This module is used by D3’s time scales to generate sensible ticks, by D3’s time format, and can also be used directly to do things like calendar layouts.interval(date) ​jsd3.utcMonday() // the latest preceding Monday, UTC timeSource · Equivalent to interval.floor, except if date is not specified, it defaults to the current time. For example, d3.timeYear(date) and d3.timeYear.floor(date) are equivalent.interval.floor(date) ​jsd3.utcMonday.floor(new Date()) // the latest preceding Monday, UTC timeSource · Returns a new date representing the latest interval boundary date before or equal to date. For example, d3.timeDay.floor(date) typically returns 12:00 AM local time on the given date.This method is idempotent: if the specified date is already floored to the current interval, a new date with an identical time is returned. Furthermore, the returned date is the minimum expressible value of the associated interval, such that interval.floor(interval.floor(date) - 1) returns the preceding interval boundary date.Note that the == and === operators do not compare by value with Date objects, and thus you cannot use them to tell whether the specified date has already been floored. Instead, coerce to a number and then compare:js// Returns true if the specified date is a day boundary.
function isDay(date) {
  return +d3.timeDay.floor(date) === +date;
}This is more reliable than testing whether the time is 12:00 AM, as in some time zones midnight may not exist due to daylight saving.interval.round(date) ​jsd3.utcMonday.round(new Date()) // the previous or following Monday, whichever is closerSource · Returns a new date representing the closest interval boundary date to date. For example, d3.timeDay.round(date) typically returns 12:00 AM local time on the given date if it is on or before noon, and 12:00 AM of the following day if it is after noon.This method is idempotent: if the specified date is already rounded to the current interval, a new date with an identical time is returned.interval.ceil(date) ​jsd3.utcMonday.ceil(new Date()) // the following MondaySource · Returns a new date representing the earliest interval boundary date after or equal to date. For example, d3.timeDay.ceil(date) typically returns 12:00 AM local time on the date following the given date.This method is idempotent: if the specified date is already ceilinged to the current interval, a new date with an identical time is returned. Furthermore, the returned date is the maximum expressible value of the associated interval, such that interval.ceil(interval.ceil(date) + 1) returns the following interval boundary date.interval.offset(date, step) ​jsd3.utcDay.offset(new Date(), 1) // the same time tomorrowSource · Returns a new date equal to date plus step intervals. If step is not specified it defaults to 1. If step is negative, then the returned date will be before the specified date; if step is zero, then a copy of the specified date is returned; if step is not an integer, it is floored. This method does not round the specified date to the interval. For example, if date is today at 5:34 PM, then d3.timeDay.offset(date, 1) returns 5:34 PM tomorrow (even if daylight saving changes!).interval.range(start, stop, step) ​jsd3.utcDay.range(new Date("2014-01-01"), new Date("2015-01-01")) // every day in 2014Source · Returns an array of dates representing every interval boundary after or equal to start (inclusive) and before stop (exclusive). If step is specified, then every stepth boundary will be returned; for example, for the d3.timeDay interval a step of 2 will return every other day. If step is not an integer, it is floored.The first date in the returned array is the earliest boundary after or equal to start; subsequent dates are offset by step intervals and floored. Thus, two overlapping ranges may be consistent. For example, this range contains odd days:jsd3.timeDay.range(new Date(2015, 0, 1), new Date(2015, 0, 7), 2) // [2015-01-01T00:00, 2015-01-03T00:00, 2015-01-05T00:00]While this contains even days:jsd3.timeDay.range(new Date(2015, 0, 2), new Date(2015, 0, 8), 2) // [2015-01-02T00:00, 2015-01-04T00:00, 2015-01-06T00:00]To make ranges consistent when a step is specified, use interval.every instead.For convenience, aliases for interval.range are also provided as plural forms of the corresponding interval, such as utcMondays.interval.filter(test) ​Source · Returns a new interval that is a filtered subset of this interval using the specified test function. The test function is passed a date and should return true if and only if the specified date should be considered part of the interval. For example, to create an interval that returns the 1st, 11th, 21th and 31th (if it exists) of each month:jsd3.timeDay.filter((d) => (d.getDate() - 1) % 10 === 0)The returned filtered interval does not support interval.count. See also interval.every.interval.every(step) ​jsd3.unixDay.every(3)Source · Returns a filtered view of this interval representing every stepth date. The meaning of step is dependent on this interval’s parent interval as defined by the field function. For example, d3.timeMinute.every(15) returns an interval representing every fifteen minutes, starting on the hour: :00, :15, :30, :45, etc. Note that for some intervals, the resulting dates may not be uniformly-spaced; d3.timeDay’s parent interval is d3.timeMonth, and thus the interval number resets at the start of each month. If step is not valid, returns null. If step is one, returns this interval.This method can be used in conjunction with interval.range to ensure that two overlapping ranges are consistent. For example, this range contains odd days:jsd3.timeDay.every(2).range(new Date(2015, 0, 1), new Date(2015, 0, 7)) // [2015-01-01T00:00, 2015-01-03T00:00, 2015-01-05T00:00]As does this one:jsd3.timeDay.every(2).range(new Date(2015, 0, 2), new Date(2015, 0, 8)) // [2015-01-03T00:00, 2015-01-05T00:00, 2015-01-07T00:00]The returned filtered interval does not support interval.count. See also interval.filter.interval.count(start, end) ​Source · Returns the number of interval boundaries after start (exclusive) and before or equal to end (inclusive). Note that this behavior is slightly different than interval.range because its purpose is to return the zero-based number of the specified end date relative to the specified start date. For example, to compute the current zero-based day-of-year number:jsd3.timeDay.count(d3.timeYear(now), now) // 177Likewise, to compute the current zero-based week-of-year number for weeks that start on Sunday:jsd3.timeSunday.count(d3.timeYear(now), now) // 25timeInterval(floor, offset, count, field) ​jsconst utcDay = d3.timeInterval(
  (date) => date.setUTCHours(0, 0, 0, 0), // floor
  (date, step) => date.setUTCDate(date.getUTCDate() + step), // offset
  (start, end) => (end - start) / 864e5, // count
  (date) => date.getUTCDate() - 1 // field
);Source · Constructs a new custom interval given the specified floor and offset functions and an optional count function.The floor function takes a single date as an argument and rounds it down to the nearest interval boundary.The offset function takes a date and an integer step as arguments and advances the specified date by the specified number of boundaries; the step may be positive, negative or zero.The optional count function takes a start date and an end date, already floored to the current interval, and returns the number of boundaries between the start (exclusive) and end (inclusive). If a count function is not specified, the returned interval does not expose interval.count or interval.every methods. Note: due to an internal optimization, the specified count function must not invoke interval.count on other time intervals.The optional field function takes a date, already floored to the current interval, and returns the field value of the specified date, corresponding to the number of boundaries between this date (exclusive) and the latest previous parent boundary. For example, for the d3.timeDay interval, this returns the number of days since the start of the month. If a field function is not specified, it defaults to counting the number of interval boundaries since the UNIX epoch of January 1, 1970 UTC. The field function defines the behavior of interval.every.timeMillisecond ​Source · Milliseconds in local time; the shortest available time unit.timeSecond ​Source · Seconds in local time (e.g., 01:23:45.0000 AM); 1,000 milliseconds.timeMinute ​Source · Minutes in local time (e.g., 01:02:00 AM); 60 seconds. Note that ECMAScript ignores leap seconds.timeHour ​Source · Hours in local time (e.g., 01:00 AM); 60 minutes. Note that advancing time by one hour in local time can return the same hour or skip an hour due to daylight saving.timeDay ​Source · Days in local time (e.g., February 7, 2012 at 12:00 AM); typically 24 hours. Days in local time may range from 23 to 25 hours due to daylight saving. d3.unixDay is like d3.utcDay, except it counts days since the UNIX epoch (January 1, 1970) such that interval.every returns uniformly-spaced dates rather than varying based on day-of-month.timeWeek ​Source · Alias for d3.timeSunday; 7 days and typically 168 hours. Weeks in local time may range from 167 to 169 hours due to daylight saving.timeSunday ​Source · Sunday-based weeks in local time (e.g., February 5, 2012 at 12:00 AM).timeMonday ​Source · Monday-based weeks in local time (e.g., February 6, 2012 at 12:00 AM).timeTuesday ​Source · Tuesday-based weeks in local time (e.g., February 7, 2012 at 12:00 AM).timeWednesday ​Source · Wednesday-based weeks in local time (e.g., February 8, 2012 at 12:00 AM).timeThursday ​Source · Thursday-based weeks in local time (e.g., February 9, 2012 at 12:00 AM).timeFriday ​Source · Friday-based weeks in local time (e.g., February 10, 2012 at 12:00 AM).timeSaturday ​Source · Saturday-based weeks in local time (e.g., February 11, 2012 at 12:00 AM).timeMonth ​Source · Months in local time (e.g., February 1, 2012 at 12:00 AM); ranges from 28 to 31 days.timeYear ​Source · Years in local time (e.g., January 1, 2012 at 12:00 AM); ranges from 365 to 366 days.utcMillisecond ​Source · Milliseconds in UTC time; the shortest available time unit.utcSecond ​Source · Seconds in UTC time (e.g., 01:23:45.0000 AM); 1,000 milliseconds.utcMinute ​Source · Minutes in UTC time (e.g., 01:02:00 AM); 60 seconds. Note that ECMAScript ignores leap seconds.utcHour ​Source · Hours in UTC time (e.g., 01:00 AM); 60 minutes.utcDay ​Source · Days in UTC time (e.g., February 7, 2012 at 12:00 AM); 24 hours.utcWeek ​Source · Alias for d3.timeSunday; 7 days and 168 hours.utcSunday ​Source · Sunday-based weeks in UTC time (e.g., February 5, 2012 at 12:00 AM).utcMonday ​Source · Monday-based weeks in UTC time (e.g., February 6, 2012 at 12:00 AM).utcTuesday ​Source · Tuesday-based weeks in UTC time (e.g., February 7, 2012 at 12:00 AM).utcWednesday ​Source · Wednesday-based weeks in UTC time (e.g., February 8, 2012 at 12:00 AM).utcThursday ​Source · Thursday-based weeks in UTC time (e.g., February 9, 2012 at 12:00 AM).utcFriday ​Source · Friday-based weeks in UTC time (e.g., February 10, 2012 at 12:00 AM).utcSaturday ​Source · Saturday-based weeks in UTC time (e.g., February 11, 2012 at 12:00 AM).utcMonth ​Source · Months in UTC time (e.g., February 1, 2012 at 12:00 AM); ranges from 28 to 31 days.utcYear ​Source · Years in UTC time (e.g., January 1, 2012 at 12:00 AM); ranges from 365 to 366 days.unixDay ​Like d3.utcDay, except it counts days since the UNIX epoch (January 1, 1970) such that interval.every returns uniformly-spaced dates rather than varying based on day-of-month.timeMilliseconds(start, stop, step) ​Alias for d3.timeMillisecond.range.timeSeconds(start, stop, step) ​Alias for d3.timeSecond.range.timeMinutes(start, stop, step) ​Alias for d3.timeMinute.range.timeHours(start, stop, step) ​Alias for d3.timeHour.range.timeDays(start, stop, step) ​Alias for d3.timeDay.range.timeWeeks(start, stop, step) ​Alias for d3.timeWeek.range.timeSundays(start, stop, step) ​Alias for d3.timeSunday.range.timeMondays(start, stop, step) ​Alias for d3.timeMonday.range.timeTuesdays(start, stop, step) ​Alias for d3.timeTuesday.range.timeWednesdays(start, stop, step) ​Alias for d3.timeWednesday.range.timeThursdays(start, stop, step) ​Alias for d3.timeThursday.range.timeFridays(start, stop, step) ​Alias for d3.timeFriday.range.timeSaturdays(start, stop, step) ​Alias for d3.timeSaturday.range.timeMonths(start, stop, step) ​Alias for d3.timeMonth.range.timeYears(start, stop, step) ​Alias for d3.timeYear.range.utcMilliseconds(start, stop, step) ​Alias for d3.utcMillisecond.range.utcSeconds(start, stop, step) ​Alias for d3.utcSecond.range.utcMinutes(start, stop, step) ​Alias for d3.utcMinute.range.utcHours(start, stop, step) ​Alias for d3.utcHour.range.utcDays(start, stop, step) ​Alias for d3.utcDay.range.utcWeeks(start, stop, step) ​Alias for d3.utcWeek.range.utcSundays(start, stop, step) ​Alias for d3.utcSunday.range.utcMondays(start, stop, step) ​Alias for d3.utcMonday.range.utcTuesdays(start, stop, step) ​Alias for d3.utcTuesday.range.utcWednesdays(start, stop, step) ​Alias for d3.utcWednesday.range.utcThursdays(start, stop, step) ​Alias for d3.utcThursday.range.utcFridays(start, stop, step) ​Alias for d3.utcFriday.range.utcSaturdays(start, stop, step) ​Alias for d3.utcSaturday.range.utcMonths(start, stop, step) ​Alias for d3.utcMonth.range.utcYears(start, stop, step) ​Alias for d3.utcYear.range.timeTicks(start, stop, count) ​Source · Equivalent to d3.utcTicks, but in local time.timeTickInterval(start, stop, count) ​Source · Returns the time interval that would be used by d3.timeTicks given the same arguments.utcTicks(start, stop, count) ​Source · Returns an array of approximately count dates at regular intervals between start and stop (inclusive). If stop is before start, dates are returned in reverse chronological order; otherwise dates are returned in chronological order. The following UTC time intervals are considered:1 second5 seconds15 seconds30 seconds1 minute5 minutes15 minutes30 minutes1 hour3 hours6 hours12 hours1 day2 days1 week1 month3 months1 yearMultiples of milliseconds (for small ranges) and years (for large ranges) are also considered, following the rules of d3.ticks. The interval producing the number of dates that is closest to count is used. For example:jsconst start = new Date("1970-03-01");
const stop = new Date("1996-03-19");
const count = 4;
const ticks = d3.utcTicks(start, stop, count); // [1975-01-01, 1980-01-01, 1985-01-01, 1990-01-01, 1995-01-01]If count is a time interval, this function behaves similarly to interval.range except that both start and stop are inclusive and it may return dates in reverse chronological order if stop is before start.utcTickInterval(start, stop, count) ​Source · Returns the time interval that would be used by d3.utcTicks given the same arguments. If there is no associated interval, such as when start or stop is invalid, returns null.jsconst start = new Date("1970-03-01");
const stop = new Date("1996-03-19");
const count = 4;
const interval = d3.utcTickInterval(start, stop, count); // d3.utcYear.every(5)PagerPrevious paged3-randomNext paged3-time-format\n\nd3-time ​When visualizing time series data, analyzing temporal patterns, or working with time in general, the irregularities of conventional time units quickly become apparent. In the Gregorian calendar, for example, most months have 31 days but some have 28, 29 or 30; most years have 365 days but leap years have 366; and with daylight saving, most days have 24 hours but some have 23 or 25. Adding to complexity, daylight saving conventions vary around the world.As a result of these temporal peculiarities, it can be difficult to perform seemingly-trivial tasks. For example, if you want to compute the number of days that have passed between two dates, you can’t simply subtract and divide by 24 hours (86,400,000 ms):jsconst start = new Date(2015, 02, 01); // 2015-03-01T00:00
const end = new Date(2015, 03, 01); // 2015-04-01T00:00
const days = (end - start) / 864e5; // 30.958333333333332, oops! 🤯You can, however, use d3.timeDay.count:jsd3.timeDay.count(start, end) // 31 😌The day interval is one of several provided by d3-time. Each interval represents a conventional unit of time — hours, weeks, months, etc. — and has methods to calculate boundary dates. For example, d3.timeDay computes midnight (typically 12:00 AM local time) of the corresponding day. In addition to rounding and counting, intervals can also be used to generate arrays of boundary dates. For example, to compute each Sunday in the current month:jsconst start = d3.timeMonth.floor(new Date(2015, 0, 15)); // 2015-01-01T00:00
const stop = d3.timeMonth.ceil(new Date(2015, 0, 15)); // 2015-02-01T00:00
const weeks = d3.timeWeek.range(start, stop); // [2015-01-04T00:00, 2015-01-11T00:00, 2015-01-18T00:00, 2015-01-25T00:00]The d3-time module does not implement its own calendaring system; it merely implements a convenient API for calendar math on top of ECMAScript Date. Thus, it ignores leap seconds and can only work with the local time zone and Coordinated Universal Time (UTC).This module is used by D3’s time scales to generate sensible ticks, by D3’s time format, and can also be used directly to do things like calendar layouts.interval(date) ​jsd3.utcMonday() // the latest preceding Monday, UTC timeSource · Equivalent to interval.floor, except if date is not specified, it defaults to the current time. For example, d3.timeYear(date) and d3.timeYear.floor(date) are equivalent.interval.floor(date) ​jsd3.utcMonday.floor(new Date()) // the latest preceding Monday, UTC timeSource · Returns a new date representing the latest interval boundary date before or equal to date. For example, d3.timeDay.floor(date) typically returns 12:00 AM local time on the given date.This method is idempotent: if the specified date is already floored to the current interval, a new date with an identical time is returned. Furthermore, the returned date is the minimum expressible value of the associated interval, such that interval.floor(interval.floor(date) - 1) returns the preceding interval boundary date.Note that the == and === operators do not compare by value with Date objects, and thus you cannot use them to tell whether the specified date has already been floored. Instead, coerce to a number and then compare:js// Returns true if the specified date is a day boundary.
function isDay(date) {
  return +d3.timeDay.floor(date) === +date;
}This is more reliable than testing whether the time is 12:00 AM, as in some time zones midnight may not exist due to daylight saving.interval.round(date) ​jsd3.utcMonday.round(new Date()) // the previous or following Monday, whichever is closerSource · Returns a new date representing the closest interval boundary date to date. For example, d3.timeDay.round(date) typically returns 12:00 AM local time on the given date if it is on or before noon, and 12:00 AM of the following day if it is after noon.This method is idempotent: if the specified date is already rounded to the current interval, a new date with an identical time is returned.interval.ceil(date) ​jsd3.utcMonday.ceil(new Date()) // the following MondaySource · Returns a new date representing the earliest interval boundary date after or equal to date. For example, d3.timeDay.ceil(date) typically returns 12:00 AM local time on the date following the given date.This method is idempotent: if the specified date is already ceilinged to the current interval, a new date with an identical time is returned. Furthermore, the returned date is the maximum expressible value of the associated interval, such that interval.ceil(interval.ceil(date) + 1) returns the following interval boundary date.interval.offset(date, step) ​jsd3.utcDay.offset(new Date(), 1) // the same time tomorrowSource · Returns a new date equal to date plus step intervals. If step is not specified it defaults to 1. If step is negative, then the returned date will be before the specified date; if step is zero, then a copy of the specified date is returned; if step is not an integer, it is floored. This method does not round the specified date to the interval. For example, if date is today at 5:34 PM, then d3.timeDay.offset(date, 1) returns 5:34 PM tomorrow (even if daylight saving changes!).interval.range(start, stop, step) ​jsd3.utcDay.range(new Date("2014-01-01"), new Date("2015-01-01")) // every day in 2014Source · Returns an array of dates representing every interval boundary after or equal to start (inclusive) and before stop (exclusive). If step is specified, then every stepth boundary will be returned; for example, for the d3.timeDay interval a step of 2 will return every other day. If step is not an integer, it is floored.The first date in the returned array is the earliest boundary after or equal to start; subsequent dates are offset by step intervals and floored. Thus, two overlapping ranges may be consistent. For example, this range contains odd days:jsd3.timeDay.range(new Date(2015, 0, 1), new Date(2015, 0, 7), 2) // [2015-01-01T00:00, 2015-01-03T00:00, 2015-01-05T00:00]While this contains even days:jsd3.timeDay.range(new Date(2015, 0, 2), new Date(2015, 0, 8), 2) // [2015-01-02T00:00, 2015-01-04T00:00, 2015-01-06T00:00]To make ranges consistent when a step is specified, use interval.every instead.For convenience, aliases for interval.range are also provided as plural forms of the corresponding interval, such as utcMondays.interval.filter(test) ​Source · Returns a new interval that is a filtered subset of this interval using the specified test function. The test function is passed a date and should return true if and only if the specified date should be considered part of the interval. For example, to create an interval that returns the 1st, 11th, 21th and 31th (if it exists) of each month:jsd3.timeDay.filter((d) => (d.getDate() - 1) % 10 === 0)The returned filtered interval does not support interval.count. See also interval.every.interval.every(step) ​jsd3.unixDay.every(3)Source · Returns a filtered view of this interval representing every stepth date. The meaning of step is dependent on this interval’s parent interval as defined by the field function. For example, d3.timeMinute.every(15) returns an interval representing every fifteen minutes, starting on the hour: :00, :15, :30, :45, etc. Note that for some intervals, the resulting dates may not be uniformly-spaced; d3.timeDay’s parent interval is d3.timeMonth, and thus the interval number resets at the start of each month. If step is not valid, returns null. If step is one, returns this interval.This method can be used in conjunction with interval.range to ensure that two overlapping ranges are consistent. For example, this range contains odd days:jsd3.timeDay.every(2).range(new Date(2015, 0, 1), new Date(2015, 0, 7)) // [2015-01-01T00:00, 2015-01-03T00:00, 2015-01-05T00:00]As does this one:jsd3.timeDay.every(2).range(new Date(2015, 0, 2), new Date(2015, 0, 8)) // [2015-01-03T00:00, 2015-01-05T00:00, 2015-01-07T00:00]The returned filtered interval does not support interval.count. See also interval.filter.interval.count(start, end) ​Source · Returns the number of interval boundaries after start (exclusive) and before or equal to end (inclusive). Note that this behavior is slightly different than interval.range because its purpose is to return the zero-based number of the specified end date relative to the specified start date. For example, to compute the current zero-based day-of-year number:jsd3.timeDay.count(d3.timeYear(now), now) // 177Likewise, to compute the current zero-based week-of-year number for weeks that start on Sunday:jsd3.timeSunday.count(d3.timeYear(now), now) // 25timeInterval(floor, offset, count, field) ​jsconst utcDay = d3.timeInterval(
  (date) => date.setUTCHours(0, 0, 0, 0), // floor
  (date, step) => date.setUTCDate(date.getUTCDate() + step), // offset
  (start, end) => (end - start) / 864e5, // count
  (date) => date.getUTCDate() - 1 // field
);Source · Constructs a new custom interval given the specified floor and offset functions and an optional count function.The floor function takes a single date as an argument and rounds it down to the nearest interval boundary.The offset function takes a date and an integer step as arguments and advances the specified date by the specified number of boundaries; the step may be positive, negative or zero.The optional count function takes a start date and an end date, already floored to the current interval, and returns the number of boundaries between the start (exclusive) and end (inclusive). If a count function is not specified, the returned interval does not expose interval.count or interval.every methods. Note: due to an internal optimization, the specified count function must not invoke interval.count on other time intervals.The optional field function takes a date, already floored to the current interval, and returns the field value of the specified date, corresponding to the number of boundaries between this date (exclusive) and the latest previous parent boundary. For example, for the d3.timeDay interval, this returns the number of days since the start of the month. If a field function is not specified, it defaults to counting the number of interval boundaries since the UNIX epoch of January 1, 1970 UTC. The field function defines the behavior of interval.every.timeMillisecond ​Source · Milliseconds in local time; the shortest available time unit.timeSecond ​Source · Seconds in local time (e.g., 01:23:45.0000 AM); 1,000 milliseconds.timeMinute ​Source · Minutes in local time (e.g., 01:02:00 AM); 60 seconds. Note that ECMAScript ignores leap seconds.timeHour ​Source · Hours in local time (e.g., 01:00 AM); 60 minutes. Note that advancing time by one hour in local time can return the same hour or skip an hour due to daylight saving.timeDay ​Source · Days in local time (e.g., February 7, 2012 at 12:00 AM); typically 24 hours. Days in local time may range from 23 to 25 hours due to daylight saving. d3.unixDay is like d3.utcDay, except it counts days since the UNIX epoch (January 1, 1970) such that interval.every returns uniformly-spaced dates rather than varying based on day-of-month.timeWeek ​Source · Alias for d3.timeSunday; 7 days and typically 168 hours. Weeks in local time may range from 167 to 169 hours due to daylight saving.timeSunday ​Source · Sunday-based weeks in local time (e.g., February 5, 2012 at 12:00 AM).timeMonday ​Source · Monday-based weeks in local time (e.g., February 6, 2012 at 12:00 AM).timeTuesday ​Source · Tuesday-based weeks in local time (e.g., February 7, 2012 at 12:00 AM).timeWednesday ​Source · Wednesday-based weeks in local time (e.g., February 8, 2012 at 12:00 AM).timeThursday ​Source · Thursday-based weeks in local time (e.g., February 9, 2012 at 12:00 AM).timeFriday ​Source · Friday-based weeks in local time (e.g., February 10, 2012 at 12:00 AM).timeSaturday ​Source · Saturday-based weeks in local time (e.g., February 11, 2012 at 12:00 AM).timeMonth ​Source · Months in local time (e.g., February 1, 2012 at 12:00 AM); ranges from 28 to 31 days.timeYear ​Source · Years in local time (e.g., January 1, 2012 at 12:00 AM); ranges from 365 to 366 days.utcMillisecond ​Source · Milliseconds in UTC time; the shortest available time unit.utcSecond ​Source · Seconds in UTC time (e.g., 01:23:45.0000 AM); 1,000 milliseconds.utcMinute ​Source · Minutes in UTC time (e.g., 01:02:00 AM); 60 seconds. Note that ECMAScript ignores leap seconds.utcHour ​Source · Hours in UTC time (e.g., 01:00 AM); 60 minutes.utcDay ​Source · Days in UTC time (e.g., February 7, 2012 at 12:00 AM); 24 hours.utcWeek ​Source · Alias for d3.timeSunday; 7 days and 168 hours.utcSunday ​Source · Sunday-based weeks in UTC time (e.g., February 5, 2012 at 12:00 AM).utcMonday ​Source · Monday-based weeks in UTC time (e.g., February 6, 2012 at 12:00 AM).utcTuesday ​Source · Tuesday-based weeks in UTC time (e.g., February 7, 2012 at 12:00 AM).utcWednesday ​Source · Wednesday-based weeks in UTC time (e.g., February 8, 2012 at 12:00 AM).utcThursday ​Source · Thursday-based weeks in UTC time (e.g., February 9, 2012 at 12:00 AM).utcFriday ​Source · Friday-based weeks in UTC time (e.g., February 10, 2012 at 12:00 AM).utcSaturday ​Source · Saturday-based weeks in UTC time (e.g., February 11, 2012 at 12:00 AM).utcMonth ​Source · Months in UTC time (e.g., February 1, 2012 at 12:00 AM); ranges from 28 to 31 days.utcYear ​Source · Years in UTC time (e.g., January 1, 2012 at 12:00 AM); ranges from 365 to 366 days.unixDay ​Like d3.utcDay, except it counts days since the UNIX epoch (January 1, 1970) such that interval.every returns uniformly-spaced dates rather than varying based on day-of-month.timeMilliseconds(start, stop, step) ​Alias for d3.timeMillisecond.range.timeSeconds(start, stop, step) ​Alias for d3.timeSecond.range.timeMinutes(start, stop, step) ​Alias for d3.timeMinute.range.timeHours(start, stop, step) ​Alias for d3.timeHour.range.timeDays(start, stop, step) ​Alias for d3.timeDay.range.timeWeeks(start, stop, step) ​Alias for d3.timeWeek.range.timeSundays(start, stop, step) ​Alias for d3.timeSunday.range.timeMondays(start, stop, step) ​Alias for d3.timeMonday.range.timeTuesdays(start, stop, step) ​Alias for d3.timeTuesday.range.timeWednesdays(start, stop, step) ​Alias for d3.timeWednesday.range.timeThursdays(start, stop, step) ​Alias for d3.timeThursday.range.timeFridays(start, stop, step) ​Alias for d3.timeFriday.range.timeSaturdays(start, stop, step) ​Alias for d3.timeSaturday.range.timeMonths(start, stop, step) ​Alias for d3.timeMonth.range.timeYears(start, stop, step) ​Alias for d3.timeYear.range.utcMilliseconds(start, stop, step) ​Alias for d3.utcMillisecond.range.utcSeconds(start, stop, step) ​Alias for d3.utcSecond.range.utcMinutes(start, stop, step) ​Alias for d3.utcMinute.range.utcHours(start, stop, step) ​Alias for d3.utcHour.range.utcDays(start, stop, step) ​Alias for d3.utcDay.range.utcWeeks(start, stop, step) ​Alias for d3.utcWeek.range.utcSundays(start, stop, step) ​Alias for d3.utcSunday.range.utcMondays(start, stop, step) ​Alias for d3.utcMonday.range.utcTuesdays(start, stop, step) ​Alias for d3.utcTuesday.range.utcWednesdays(start, stop, step) ​Alias for d3.utcWednesday.range.utcThursdays(start, stop, step) ​Alias for d3.utcThursday.range.utcFridays(start, stop, step) ​Alias for d3.utcFriday.range.utcSaturdays(start, stop, step) ​Alias for d3.utcSaturday.range.utcMonths(start, stop, step) ​Alias for d3.utcMonth.range.utcYears(start, stop, step) ​Alias for d3.utcYear.range.timeTicks(start, stop, count) ​Source · Equivalent to d3.utcTicks, but in local time.timeTickInterval(start, stop, count) ​Source · Returns the time interval that would be used by d3.timeTicks given the same arguments.utcTicks(start, stop, count) ​Source · Returns an array of approximately count dates at regular intervals between start and stop (inclusive). If stop is before start, dates are returned in reverse chronological order; otherwise dates are returned in chronological order. The following UTC time intervals are considered:1 second5 seconds15 seconds30 seconds1 minute5 minutes15 minutes30 minutes1 hour3 hours6 hours12 hours1 day2 days1 week1 month3 months1 yearMultiples of milliseconds (for small ranges) and years (for large ranges) are also considered, following the rules of d3.ticks. The interval producing the number of dates that is closest to count is used. For example:jsconst start = new Date("1970-03-01");
const stop = new Date("1996-03-19");
const count = 4;
const ticks = d3.utcTicks(start, stop, count); // [1975-01-01, 1980-01-01, 1985-01-01, 1990-01-01, 1995-01-01]If count is a time interval, this function behaves similarly to interval.range except that both start and stop are inclusive and it may return dates in reverse chronological order if stop is before start.utcTickInterval(start, stop, count) ​Source · Returns the time interval that would be used by d3.utcTicks given the same arguments. If there is no associated interval, such as when start or stop is invalid, returns null.jsconst start = new Date("1970-03-01");
const stop = new Date("1996-03-19");
const count = 4;
const interval = d3.utcTickInterval(start, stop, count); // d3.utcYear.every(5)\n\n\n\nd3-time-format ​This module provides an approximate JavaScript implementation of the venerable strptime and strftime functions from the C standard library, and can be used to parse or format dates in a variety of locale-specific representations. To format a date, create a formatter from a specifier (a string with the desired format directives, indicated by %); then pass a date to the formatter, which returns a string. For example, to convert the current date to a human-readable string:jsconst formatTime = d3.utcFormat("%B %d, %Y");
formatTime(new Date()); // "May 31, 2023"Likewise, to convert a string back to a date, create a parser:jsconst parseTime = d3.utcParse("%B %d, %Y");
parseTime("June 30, 2015"); // 2023-05-31You can implement more elaborate conditional time formats, too. For example, here’s a multi-scale time format using time intervals:jsconst formatMillisecond = d3.utcFormat(".%L"),
    formatSecond = d3.utcFormat(":%S"),
    formatMinute = d3.utcFormat("%I:%M"),
    formatHour = d3.utcFormat("%I %p"),
    formatDay = d3.utcFormat("%a %d"),
    formatWeek = d3.utcFormat("%b %d"),
    formatMonth = d3.utcFormat("%B"),
    formatYear = d3.utcFormat("%Y");

function multiFormat(date) {
  return (d3.utcSecond(date) < date ? formatMillisecond
      : d3.utcMinute(date) < date ? formatSecond
      : d3.utcHour(date) < date ? formatMinute
      : d3.utcDay(date) < date ? formatHour
      : d3.utcMonth(date) < date ? (d3.utcWeek(date) < date ? formatDay : formatWeek)
      : d3.utcYear(date) < date ? formatMonth
      : formatYear)(date);
}This module is used by D3 time scales to generate human-readable ticks.Also see date.toLocaleString.timeFormat(specifier) ​jsd3.timeFormat("%b %d")An alias for locale.format on the default locale.timeParse(specifier) ​jsd3.timeParse("%b %d")An alias for locale.parse on the default locale.utcFormat(specifier) ​jsd3.utcFormat("%b %d")An alias for locale.utcFormat on the default locale.utcParse(specifier) ​jsd3.utcParse("%b %d")An alias for locale.utcParse on the default locale.isoFormat ​jsd3.isoFormat(new Date()) // "2023-05-31T18:17:36.788Z"Source · The full ISO 8601 UTC time formatter. Where available, this method will use Date.toISOString to format.isoParse ​jsd3.isoParse("2023-05-31T18:17:36.788Z")Source · The full ISO 8601 UTC time parser. Where available, this method will use the Date constructor to parse strings. If you depend on strict validation of the input format according to ISO 8601, you should construct a UTC parser function:jsconst strictIsoParse = d3.utcParse("%Y-%m-%dT%H:%M:%S.%LZ");locale.format(specifier) ​jsd3.timeFormat("%b %d")Source · Returns a new formatter for the given string specifier. The specifier string may contain the following directives:%a - abbreviated weekday name.*%A - full weekday name.*%b - abbreviated month name.*%B - full month name.*%c - the locale’s date and time, such as %x, %X.*%d - zero-padded day of the month as a decimal number [01,31].%e - space-padded day of the month as a decimal number [ 1,31]; equivalent to %_d.%f - microseconds as a decimal number [000000, 999999].%g - ISO 8601 week-based year without century as a decimal number [00,99].%G - ISO 8601 week-based year with century as a decimal number.%H - hour (24-hour clock) as a decimal number [00,23].%I - hour (12-hour clock) as a decimal number [01,12].%j - day of the year as a decimal number [001,366].%m - month as a decimal number [01,12].%M - minute as a decimal number [00,59].%L - milliseconds as a decimal number [000, 999].%p - either AM or PM.*%q - quarter of the year as a decimal number [1,4].%Q - milliseconds since UNIX epoch.%s - seconds since UNIX epoch.%S - second as a decimal number [00,61].%u - Monday-based (ISO 8601) weekday as a decimal number [1,7].%U - Sunday-based week of the year as a decimal number [00,53].%V - ISO 8601 week of the year as a decimal number [01, 53].%w - Sunday-based weekday as a decimal number [0,6].%W - Monday-based week of the year as a decimal number [00,53].%x - the locale’s date, such as %-m/%-d/%Y.*%X - the locale’s time, such as %-I:%M:%S %p.*%y - year without century as a decimal number [00,99].%Y - year with century as a decimal number, such as 1999.%Z - time zone offset, such as -0700, -07:00, -07, or Z.%% - a literal percent sign (%).Directives marked with an asterisk (*) may be affected by the locale definition.For %U, all days in a new year preceding the first Sunday are considered to be in week 0. For %W, all days in a new year preceding the first Monday are considered to be in week 0. Week numbers are computed using interval.count. For example, 2015-52 and 2016-00 represent Monday, December 28, 2015, while 2015-53 and 2016-01 represent Monday, January 4, 2016. This differs from the ISO week date specification (%V), which uses a more complicated definition!For %V,%g and %G, per the strftime man page:In this system, weeks start on a Monday, and are numbered from 01, for the first week, up to 52 or 53, for the last week. Week 1 is the first week where four or more days fall within the new year (or, synonymously, week 01 is: the first week of the year that contains a Thursday; or, the week that has 4 January in it). If the ISO week number belongs to the previous or next year, that year is used instead.The % sign indicating a directive may be immediately followed by a padding modifier:0 - zero-padding_ - space-padding- - disable paddingIf no padding modifier is specified, the default is 0 for all directives except %e, which defaults to _. (In some implementations of strftime and strptime, a directive may include an optional field width or precision; this feature is not yet implemented.)The returned function formats a specified date, returning the corresponding string.jsconst formatMonth = d3.timeFormat("%B"),
    formatDay = d3.timeFormat("%A"),
    date = new Date(2014, 4, 1); // Thu May 01 2014 00:00:00 GMT-0700 (PDT)

formatMonth(date); // "May"
formatDay(date); // "Thursday"locale.parse(specifier) ​jsd3.timeParse("%b %d")Source · Returns a new parser for the given string specifier. The specifier string may contain the same directives as locale.format. The %d and %e directives are considered equivalent for parsing.The returned function parses a specified string, returning the corresponding date or null if the string could not be parsed according to this format’s specifier. Parsing is strict: if the specified string does not exactly match the associated specifier, this method returns null. For example, if the associated specifier is %Y-%m-%dT%H:%M:%SZ, then the string "2011-07-01T19:15:28Z" will be parsed as expected, but "2011-07-01T19:15:28", "2011-07-01 19:15:28" and "2011-07-01" will return null. (Note that the literal Z here is different from the time zone offset directive %Z.) If a more flexible parser is desired, try multiple formats sequentially until one returns non-null.locale.utcFormat(specifier) ​jsd3.utcFormat("%b %d")Source · Equivalent to locale.format, except all directives are interpreted as Coordinated Universal Time (UTC) rather than local time.locale.utcParse(specifier) ​jsd3.utcParse("%b %d")Source · Equivalent to locale.parse, except all directives are interpreted as Coordinated Universal Time (UTC) rather than local time.timeFormatLocale(definition) ​jsconst enUs = d3.timeFormatLocale({
  dateTime: "%x, %X",
  date: "%-m/%-d/%Y",
  time: "%-I:%M:%S %p",
  periods: ["AM", "PM"],
  days: ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"],
  shortDays: ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"],
  months: ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"],
  shortMonths: ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"]
});Source · Returns a locale object for the specified definition with locale.format, locale.parse, locale.utcFormat, locale.utcParse methods. The definition must include the following properties:dateTime - the date and time (%c) format specifier (e.g., "%a %b %e %X %Y").date - the date (%x) format specifier (e.g., "%m/%d/%Y").time - the time (%X) format specifier (e.g., "%H:%M:%S").periods - the A.M. and P.M. equivalents (e.g., ["AM", "PM"]).days - the full names of the weekdays, starting with Sunday.shortDays - the abbreviated names of the weekdays, starting with Sunday.months - the full names of the months (starting with January).shortMonths - the abbreviated names of the months (starting with January).timeFormatDefaultLocale(definition) ​jsconst enUs = d3.timeFormatDefaultLocale({
  dateTime: "%x, %X",
  date: "%-m/%-d/%Y",
  time: "%-I:%M:%S %p",
  periods: ["AM", "PM"],
  days: ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"],
  shortDays: ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"],
  months: ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"],
  shortMonths: ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"]
});Source · Equivalent to d3.timeFormatLocale, except it also redefines d3.timeFormat, d3.timeParse, d3.utcFormat and d3.utcParse to the new locale’s locale.format, locale.parse, locale.utcFormat and locale.utcParse. If you do not set a default locale, it defaults to U.S. English.\n\nSearchK7.9.0GitHub️ 110.0kOn this paged3-time-format ​This module provides an approximate JavaScript implementation of the venerable strptime and strftime functions from the C standard library, and can be used to parse or format dates in a variety of locale-specific representations. To format a date, create a formatter from a specifier (a string with the desired format directives, indicated by %); then pass a date to the formatter, which returns a string. For example, to convert the current date to a human-readable string:jsconst formatTime = d3.utcFormat("%B %d, %Y");
formatTime(new Date()); // "May 31, 2023"Likewise, to convert a string back to a date, create a parser:jsconst parseTime = d3.utcParse("%B %d, %Y");
parseTime("June 30, 2015"); // 2023-05-31You can implement more elaborate conditional time formats, too. For example, here’s a multi-scale time format using time intervals:jsconst formatMillisecond = d3.utcFormat(".%L"),
    formatSecond = d3.utcFormat(":%S"),
    formatMinute = d3.utcFormat("%I:%M"),
    formatHour = d3.utcFormat("%I %p"),
    formatDay = d3.utcFormat("%a %d"),
    formatWeek = d3.utcFormat("%b %d"),
    formatMonth = d3.utcFormat("%B"),
    formatYear = d3.utcFormat("%Y");

function multiFormat(date) {
  return (d3.utcSecond(date) < date ? formatMillisecond
      : d3.utcMinute(date) < date ? formatSecond
      : d3.utcHour(date) < date ? formatMinute
      : d3.utcDay(date) < date ? formatHour
      : d3.utcMonth(date) < date ? (d3.utcWeek(date) < date ? formatDay : formatWeek)
      : d3.utcYear(date) < date ? formatMonth
      : formatYear)(date);
}This module is used by D3 time scales to generate human-readable ticks.Also see date.toLocaleString.timeFormat(specifier) ​jsd3.timeFormat("%b %d")An alias for locale.format on the default locale.timeParse(specifier) ​jsd3.timeParse("%b %d")An alias for locale.parse on the default locale.utcFormat(specifier) ​jsd3.utcFormat("%b %d")An alias for locale.utcFormat on the default locale.utcParse(specifier) ​jsd3.utcParse("%b %d")An alias for locale.utcParse on the default locale.isoFormat ​jsd3.isoFormat(new Date()) // "2023-05-31T18:17:36.788Z"Source · The full ISO 8601 UTC time formatter. Where available, this method will use Date.toISOString to format.isoParse ​jsd3.isoParse("2023-05-31T18:17:36.788Z")Source · The full ISO 8601 UTC time parser. Where available, this method will use the Date constructor to parse strings. If you depend on strict validation of the input format according to ISO 8601, you should construct a UTC parser function:jsconst strictIsoParse = d3.utcParse("%Y-%m-%dT%H:%M:%S.%LZ");locale.format(specifier) ​jsd3.timeFormat("%b %d")Source · Returns a new formatter for the given string specifier. The specifier string may contain the following directives:%a - abbreviated weekday name.*%A - full weekday name.*%b - abbreviated month name.*%B - full month name.*%c - the locale’s date and time, such as %x, %X.*%d - zero-padded day of the month as a decimal number [01,31].%e - space-padded day of the month as a decimal number [ 1,31]; equivalent to %_d.%f - microseconds as a decimal number [000000, 999999].%g - ISO 8601 week-based year without century as a decimal number [00,99].%G - ISO 8601 week-based year with century as a decimal number.%H - hour (24-hour clock) as a decimal number [00,23].%I - hour (12-hour clock) as a decimal number [01,12].%j - day of the year as a decimal number [001,366].%m - month as a decimal number [01,12].%M - minute as a decimal number [00,59].%L - milliseconds as a decimal number [000, 999].%p - either AM or PM.*%q - quarter of the year as a decimal number [1,4].%Q - milliseconds since UNIX epoch.%s - seconds since UNIX epoch.%S - second as a decimal number [00,61].%u - Monday-based (ISO 8601) weekday as a decimal number [1,7].%U - Sunday-based week of the year as a decimal number [00,53].%V - ISO 8601 week of the year as a decimal number [01, 53].%w - Sunday-based weekday as a decimal number [0,6].%W - Monday-based week of the year as a decimal number [00,53].%x - the locale’s date, such as %-m/%-d/%Y.*%X - the locale’s time, such as %-I:%M:%S %p.*%y - year without century as a decimal number [00,99].%Y - year with century as a decimal number, such as 1999.%Z - time zone offset, such as -0700, -07:00, -07, or Z.%% - a literal percent sign (%).Directives marked with an asterisk (*) may be affected by the locale definition.For %U, all days in a new year preceding the first Sunday are considered to be in week 0. For %W, all days in a new year preceding the first Monday are considered to be in week 0. Week numbers are computed using interval.count. For example, 2015-52 and 2016-00 represent Monday, December 28, 2015, while 2015-53 and 2016-01 represent Monday, January 4, 2016. This differs from the ISO week date specification (%V), which uses a more complicated definition!For %V,%g and %G, per the strftime man page:In this system, weeks start on a Monday, and are numbered from 01, for the first week, up to 52 or 53, for the last week. Week 1 is the first week where four or more days fall within the new year (or, synonymously, week 01 is: the first week of the year that contains a Thursday; or, the week that has 4 January in it). If the ISO week number belongs to the previous or next year, that year is used instead.The % sign indicating a directive may be immediately followed by a padding modifier:0 - zero-padding_ - space-padding- - disable paddingIf no padding modifier is specified, the default is 0 for all directives except %e, which defaults to _. (In some implementations of strftime and strptime, a directive may include an optional field width or precision; this feature is not yet implemented.)The returned function formats a specified date, returning the corresponding string.jsconst formatMonth = d3.timeFormat("%B"),
    formatDay = d3.timeFormat("%A"),
    date = new Date(2014, 4, 1); // Thu May 01 2014 00:00:00 GMT-0700 (PDT)

formatMonth(date); // "May"
formatDay(date); // "Thursday"locale.parse(specifier) ​jsd3.timeParse("%b %d")Source · Returns a new parser for the given string specifier. The specifier string may contain the same directives as locale.format. The %d and %e directives are considered equivalent for parsing.The returned function parses a specified string, returning the corresponding date or null if the string could not be parsed according to this format’s specifier. Parsing is strict: if the specified string does not exactly match the associated specifier, this method returns null. For example, if the associated specifier is %Y-%m-%dT%H:%M:%SZ, then the string "2011-07-01T19:15:28Z" will be parsed as expected, but "2011-07-01T19:15:28", "2011-07-01 19:15:28" and "2011-07-01" will return null. (Note that the literal Z here is different from the time zone offset directive %Z.) If a more flexible parser is desired, try multiple formats sequentially until one returns non-null.locale.utcFormat(specifier) ​jsd3.utcFormat("%b %d")Source · Equivalent to locale.format, except all directives are interpreted as Coordinated Universal Time (UTC) rather than local time.locale.utcParse(specifier) ​jsd3.utcParse("%b %d")Source · Equivalent to locale.parse, except all directives are interpreted as Coordinated Universal Time (UTC) rather than local time.timeFormatLocale(definition) ​jsconst enUs = d3.timeFormatLocale({
  dateTime: "%x, %X",
  date: "%-m/%-d/%Y",
  time: "%-I:%M:%S %p",
  periods: ["AM", "PM"],
  days: ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"],
  shortDays: ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"],
  months: ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"],
  shortMonths: ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"]
});Source · Returns a locale object for the specified definition with locale.format, locale.parse, locale.utcFormat, locale.utcParse methods. The definition must include the following properties:dateTime - the date and time (%c) format specifier (e.g., "%a %b %e %X %Y").date - the date (%x) format specifier (e.g., "%m/%d/%Y").time - the time (%X) format specifier (e.g., "%H:%M:%S").periods - the A.M. and P.M. equivalents (e.g., ["AM", "PM"]).days - the full names of the weekdays, starting with Sunday.shortDays - the abbreviated names of the weekdays, starting with Sunday.months - the full names of the months (starting with January).shortMonths - the abbreviated names of the months (starting with January).timeFormatDefaultLocale(definition) ​jsconst enUs = d3.timeFormatDefaultLocale({
  dateTime: "%x, %X",
  date: "%-m/%-d/%Y",
  time: "%-I:%M:%S %p",
  periods: ["AM", "PM"],
  days: ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"],
  shortDays: ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"],
  months: ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"],
  shortMonths: ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"]
});Source · Equivalent to d3.timeFormatLocale, except it also redefines d3.timeFormat, d3.timeParse, d3.utcFormat and d3.utcParse to the new locale’s locale.format, locale.parse, locale.utcFormat and locale.utcParse. If you do not set a default locale, it defaults to U.S. English.PagerPrevious paged3-time\n\nd3-time-format ​This module provides an approximate JavaScript implementation of the venerable strptime and strftime functions from the C standard library, and can be used to parse or format dates in a variety of locale-specific representations. To format a date, create a formatter from a specifier (a string with the desired format directives, indicated by %); then pass a date to the formatter, which returns a string. For example, to convert the current date to a human-readable string:jsconst formatTime = d3.utcFormat("%B %d, %Y");
formatTime(new Date()); // "May 31, 2023"Likewise, to convert a string back to a date, create a parser:jsconst parseTime = d3.utcParse("%B %d, %Y");
parseTime("June 30, 2015"); // 2023-05-31You can implement more elaborate conditional time formats, too. For example, here’s a multi-scale time format using time intervals:jsconst formatMillisecond = d3.utcFormat(".%L"),
    formatSecond = d3.utcFormat(":%S"),
    formatMinute = d3.utcFormat("%I:%M"),
    formatHour = d3.utcFormat("%I %p"),
    formatDay = d3.utcFormat("%a %d"),
    formatWeek = d3.utcFormat("%b %d"),
    formatMonth = d3.utcFormat("%B"),
    formatYear = d3.utcFormat("%Y");

function multiFormat(date) {
  return (d3.utcSecond(date) < date ? formatMillisecond
      : d3.utcMinute(date) < date ? formatSecond
      : d3.utcHour(date) < date ? formatMinute
      : d3.utcDay(date) < date ? formatHour
      : d3.utcMonth(date) < date ? (d3.utcWeek(date) < date ? formatDay : formatWeek)
      : d3.utcYear(date) < date ? formatMonth
      : formatYear)(date);
}This module is used by D3 time scales to generate human-readable ticks.Also see date.toLocaleString.timeFormat(specifier) ​jsd3.timeFormat("%b %d")An alias for locale.format on the default locale.timeParse(specifier) ​jsd3.timeParse("%b %d")An alias for locale.parse on the default locale.utcFormat(specifier) ​jsd3.utcFormat("%b %d")An alias for locale.utcFormat on the default locale.utcParse(specifier) ​jsd3.utcParse("%b %d")An alias for locale.utcParse on the default locale.isoFormat ​jsd3.isoFormat(new Date()) // "2023-05-31T18:17:36.788Z"Source · The full ISO 8601 UTC time formatter. Where available, this method will use Date.toISOString to format.isoParse ​jsd3.isoParse("2023-05-31T18:17:36.788Z")Source · The full ISO 8601 UTC time parser. Where available, this method will use the Date constructor to parse strings. If you depend on strict validation of the input format according to ISO 8601, you should construct a UTC parser function:jsconst strictIsoParse = d3.utcParse("%Y-%m-%dT%H:%M:%S.%LZ");locale.format(specifier) ​jsd3.timeFormat("%b %d")Source · Returns a new formatter for the given string specifier. The specifier string may contain the following directives:%a - abbreviated weekday name.*%A - full weekday name.*%b - abbreviated month name.*%B - full month name.*%c - the locale’s date and time, such as %x, %X.*%d - zero-padded day of the month as a decimal number [01,31].%e - space-padded day of the month as a decimal number [ 1,31]; equivalent to %_d.%f - microseconds as a decimal number [000000, 999999].%g - ISO 8601 week-based year without century as a decimal number [00,99].%G - ISO 8601 week-based year with century as a decimal number.%H - hour (24-hour clock) as a decimal number [00,23].%I - hour (12-hour clock) as a decimal number [01,12].%j - day of the year as a decimal number [001,366].%m - month as a decimal number [01,12].%M - minute as a decimal number [00,59].%L - milliseconds as a decimal number [000, 999].%p - either AM or PM.*%q - quarter of the year as a decimal number [1,4].%Q - milliseconds since UNIX epoch.%s - seconds since UNIX epoch.%S - second as a decimal number [00,61].%u - Monday-based (ISO 8601) weekday as a decimal number [1,7].%U - Sunday-based week of the year as a decimal number [00,53].%V - ISO 8601 week of the year as a decimal number [01, 53].%w - Sunday-based weekday as a decimal number [0,6].%W - Monday-based week of the year as a decimal number [00,53].%x - the locale’s date, such as %-m/%-d/%Y.*%X - the locale’s time, such as %-I:%M:%S %p.*%y - year without century as a decimal number [00,99].%Y - year with century as a decimal number, such as 1999.%Z - time zone offset, such as -0700, -07:00, -07, or Z.%% - a literal percent sign (%).Directives marked with an asterisk (*) may be affected by the locale definition.For %U, all days in a new year preceding the first Sunday are considered to be in week 0. For %W, all days in a new year preceding the first Monday are considered to be in week 0. Week numbers are computed using interval.count. For example, 2015-52 and 2016-00 represent Monday, December 28, 2015, while 2015-53 and 2016-01 represent Monday, January 4, 2016. This differs from the ISO week date specification (%V), which uses a more complicated definition!For %V,%g and %G, per the strftime man page:In this system, weeks start on a Monday, and are numbered from 01, for the first week, up to 52 or 53, for the last week. Week 1 is the first week where four or more days fall within the new year (or, synonymously, week 01 is: the first week of the year that contains a Thursday; or, the week that has 4 January in it). If the ISO week number belongs to the previous or next year, that year is used instead.The % sign indicating a directive may be immediately followed by a padding modifier:0 - zero-padding_ - space-padding- - disable paddingIf no padding modifier is specified, the default is 0 for all directives except %e, which defaults to _. (In some implementations of strftime and strptime, a directive may include an optional field width or precision; this feature is not yet implemented.)The returned function formats a specified date, returning the corresponding string.jsconst formatMonth = d3.timeFormat("%B"),
    formatDay = d3.timeFormat("%A"),
    date = new Date(2014, 4, 1); // Thu May 01 2014 00:00:00 GMT-0700 (PDT)

formatMonth(date); // "May"
formatDay(date); // "Thursday"locale.parse(specifier) ​jsd3.timeParse("%b %d")Source · Returns a new parser for the given string specifier. The specifier string may contain the same directives as locale.format. The %d and %e directives are considered equivalent for parsing.The returned function parses a specified string, returning the corresponding date or null if the string could not be parsed according to this format’s specifier. Parsing is strict: if the specified string does not exactly match the associated specifier, this method returns null. For example, if the associated specifier is %Y-%m-%dT%H:%M:%SZ, then the string "2011-07-01T19:15:28Z" will be parsed as expected, but "2011-07-01T19:15:28", "2011-07-01 19:15:28" and "2011-07-01" will return null. (Note that the literal Z here is different from the time zone offset directive %Z.) If a more flexible parser is desired, try multiple formats sequentially until one returns non-null.locale.utcFormat(specifier) ​jsd3.utcFormat("%b %d")Source · Equivalent to locale.format, except all directives are interpreted as Coordinated Universal Time (UTC) rather than local time.locale.utcParse(specifier) ​jsd3.utcParse("%b %d")Source · Equivalent to locale.parse, except all directives are interpreted as Coordinated Universal Time (UTC) rather than local time.timeFormatLocale(definition) ​jsconst enUs = d3.timeFormatLocale({
  dateTime: "%x, %X",
  date: "%-m/%-d/%Y",
  time: "%-I:%M:%S %p",
  periods: ["AM", "PM"],
  days: ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"],
  shortDays: ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"],
  months: ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"],
  shortMonths: ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"]
});Source · Returns a locale object for the specified definition with locale.format, locale.parse, locale.utcFormat, locale.utcParse methods. The definition must include the following properties:dateTime - the date and time (%c) format specifier (e.g., "%a %b %e %X %Y").date - the date (%x) format specifier (e.g., "%m/%d/%Y").time - the time (%X) format specifier (e.g., "%H:%M:%S").periods - the A.M. and P.M. equivalents (e.g., ["AM", "PM"]).days - the full names of the weekdays, starting with Sunday.shortDays - the abbreviated names of the weekdays, starting with Sunday.months - the full names of the months (starting with January).shortMonths - the abbreviated names of the months (starting with January).timeFormatDefaultLocale(definition) ​jsconst enUs = d3.timeFormatDefaultLocale({
  dateTime: "%x, %X",
  date: "%-m/%-d/%Y",
  time: "%-I:%M:%S %p",
  periods: ["AM", "PM"],
  days: ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"],
  shortDays: ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"],
  months: ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"],
  shortMonths: ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"]
});Source · Equivalent to d3.timeFormatLocale, except it also redefines d3.timeFormat, d3.timeParse, d3.utcFormat and d3.utcParse to the new locale’s locale.format, locale.parse, locale.utcFormat and locale.utcParse. If you do not set a default locale, it defaults to U.S. English.\n\n\n\nGetting started ​D3 works in any JavaScript environment.Try D3 online ​The fastest way to get started (and get help) with D3 is on Observable! D3 is available by default in notebooks as part of Observable’s standard library. To create something with D3, return the generated DOM element from a cell. Here is a blank chart to get you started:js{
  // Declare the chart dimensions and margins.
  const width = 640;
  const height = 400;
  const marginTop = 20;
  const marginRight = 20;
  const marginBottom = 30;
  const marginLeft = 40;

  // Declare the x (horizontal position) scale.
  const x = d3.scaleUtc()
      .domain([new Date("2023-01-01"), new Date("2024-01-01")])
      .range([marginLeft, width - marginRight]);

  // Declare the y (vertical position) scale.
  const y = d3.scaleLinear()
      .domain([0, 100])
      .range([height - marginBottom, marginTop]);

  // Create the SVG container.
  const svg = d3.create("svg")
      .attr("width", width)
      .attr("height", height);

  // Add the x-axis.
  svg.append("g")
      .attr("transform", `translate(0,${height - marginBottom})`)
      .call(d3.axisBottom(x));

  // Add the y-axis.
  svg.append("g")
      .attr("transform", `translate(${marginLeft},0)`)
      .call(d3.axisLeft(y));

  // Return the SVG element.
  return svg.node();
}As a more complete example, try one of these starter templates:Area chartBar chartDonut chartHistogramLine chartSee the D3 gallery for more forkable examples.Observable includes a few D3 snippets when you click + to add a cell (type “d3” when the cell menu is open to filter), as well as convenient sample datasets to try out D3 features. Or upload a CSV or JSON file to start playing with your data. You can also fork any of the hundreds of notebooks we’ve published for a head start.Observable is free for public use. Sign up for a Pro account to connect to private databases, collaborate on private notebooks, and more.D3 in vanilla HTML ​In vanilla HTML, you can load D3 from a CDN such as jsDelivr or you can download it locally. We recommend using the CDN-hosted ES module bundle. But for those who need it, we also provide a UMD bundle that exports the d3 global when loaded as a plain script.ESM + CDNUMD + CDNUMD + localhtml<!DOCTYPE html>
<div id="container"></div>
<script type="module">

import * as d3 from "https://cdn.jsdelivr.net/npm/d3@7/+esm";

// Declare the chart dimensions and margins.
const width = 640;
const height = 400;
const marginTop = 20;
const marginRight = 20;
const marginBottom = 30;
const marginLeft = 40;

// Declare the x (horizontal position) scale.
const x = d3.scaleUtc()
    .domain([new Date("2023-01-01"), new Date("2024-01-01")])
    .range([marginLeft, width - marginRight]);

// Declare the y (vertical position) scale.
const y = d3.scaleLinear()
    .domain([0, 100])
    .range([height - marginBottom, marginTop]);

// Create the SVG container.
const svg = d3.create("svg")
    .attr("width", width)
    .attr("height", height);

// Add the x-axis.
svg.append("g")
    .attr("transform", `translate(0,${height - marginBottom})`)
    .call(d3.axisBottom(x));

// Add the y-axis.
svg.append("g")
    .attr("transform", `translate(${marginLeft},0)`)
    .call(d3.axisLeft(y));

// Append the SVG element.
container.append(svg.node());

</script>html<!DOCTYPE html>
<div id="container"></div>
<script src="https://cdn.jsdelivr.net/npm/d3@7"></script>
<script type="module">

// Declare the chart dimensions and margins.
const width = 640;
const height = 400;
const marginTop = 20;
const marginRight = 20;
const marginBottom = 30;
const marginLeft = 40;

// Declare the x (horizontal position) scale.
const x = d3.scaleUtc()
    .domain([new Date("2023-01-01"), new Date("2024-01-01")])
    .range([marginLeft, width - marginRight]);

// Declare the y (vertical position) scale.
const y = d3.scaleLinear()
    .domain([0, 100])
    .range([height - marginBottom, marginTop]);

// Create the SVG container.
const svg = d3.create("svg")
    .attr("width", width)
    .attr("height", height);

// Add the x-axis.
svg.append("g")
    .attr("transform", `translate(0,${height - marginBottom})`)
    .call(d3.axisBottom(x));

// Add the y-axis.
svg.append("g")
    .attr("transform", `translate(${marginLeft},0)`)
    .call(d3.axisLeft(y));

// Append the SVG element.
container.append(svg.node());

</script>html<!DOCTYPE html>
<div id="container"></div>
<script src="d3.js"></script>
<script type="module">

// Declare the chart dimensions and margins.
const width = 640;
const height = 400;
const marginTop = 20;
const marginRight = 20;
const marginBottom = 30;
const marginLeft = 40;

// Declare the x (horizontal position) scale.
const x = d3.scaleUtc()
    .domain([new Date("2023-01-01"), new Date("2024-01-01")])
    .range([marginLeft, width - marginRight]);

// Declare the y (vertical position) scale.
const y = d3.scaleLinear()
    .domain([0, 100])
    .range([height - marginBottom, marginTop]);

// Create the SVG container.
const svg = d3.create("svg")
    .attr("width", width)
    .attr("height", height);

// Add the x-axis.
svg.append("g")
    .attr("transform", `translate(0,${height - marginBottom})`)
    .call(d3.axisBottom(x));

// Add the y-axis.
svg.append("g")
    .attr("transform", `translate(${marginLeft},0)`)
    .call(d3.axisLeft(y));

// Append the SVG element.
container.append(svg.node());

</script>You can also import and destructure individual D3 modules like so:html<script type="module">

import {forceSimulation, forceCollide, forceX} from "https://cdn.jsdelivr.net/npm/d3-force@3/+esm";

const nodes = [{}, {}];
const simulation = forceSimulation(nodes)
    .force("x", forceX())
    .force("collide", forceCollide(5))
    .on("tick", () => console.log(nodes[0].x));

</script>If you’d prefer to run D3 locally (or offline), you can download the UMD bundles of D3 here:d3.v7.jsd3.v7.min.jsThen, create an index.html file as shown above in the UMD + local tab. Use the non-minified bundle for debugging, and the minified bundle for faster performance in production.Installing from npm ​If you’re developing a web application using Node, you can install D3 via yarn, npm, pnpm, or your preferred package manager.yarnnpmpnpmbashyarn add d3bashnpm install d3bashpnpm add d3You can then load D3 into your app as:jsimport * as d3 from "d3";You can instead import specific symbols if you prefer:jsimport {select, selectAll} from "d3";Alternatively you can install and import from D3 submodules:jsimport {mean, median} from "d3-array";TypeScript declarations are available via DefinitelyTyped.D3 in React ​Most D3 modules (including d3-scale, d3-array, d3-interpolate, and d3-format) don’t interact with the DOM, so there is no difference when using them in React. You can use them in JSX for purely declarative visualization, such as the line plot below.LinePlot.jsxjsximport * as d3 from "d3";

export default function LinePlot({
  data,
  width = 640,
  height = 400,
  marginTop = 20,
  marginRight = 20,
  marginBottom = 20,
  marginLeft = 20
}) {
  const x = d3.scaleLinear([0, data.length - 1], [marginLeft, width - marginRight]);
  const y = d3.scaleLinear(d3.extent(data), [height - marginBottom, marginTop]);
  const line = d3.line((d, i) => x(i), y);
  return (
    <svg width={width} height={height}>
      <path fill="none" stroke="currentColor" strokeWidth="1.5" d={line(data)} />
      <g fill="white" stroke="currentColor" strokeWidth="1.5">
        {data.map((d, i) => (<circle key={i} cx={x(i)} cy={y(d)} r="2.5" />))}
      </g>
    </svg>
  );
}Sandbox ↗︎D3 modules that operate on selections (including d3-selection, d3-transition, and d3-axis) do manipulate the DOM, which competes with React’s virtual DOM. In those cases, you can attach a ref to an element and pass it to D3 in a useEffect hook.LinePlot.jsxjsximport * as d3 from "d3";
import {useRef, useEffect} from "react";

export default function LinePlot({
  data,
  width = 640,
  height = 400,
  marginTop = 20,
  marginRight = 20,
  marginBottom = 30,
  marginLeft = 40
}) {
  const gx = useRef();
  const gy = useRef();
  const x = d3.scaleLinear([0, data.length - 1], [marginLeft, width - marginRight]);
  const y = d3.scaleLinear(d3.extent(data), [height - marginBottom, marginTop]);
  const line = d3.line((d, i) => x(i), y);
  useEffect(() => void d3.select(gx.current).call(d3.axisBottom(x)), [gx, x]);
  useEffect(() => void d3.select(gy.current).call(d3.axisLeft(y)), [gy, y]);
  return (
    <svg width={width} height={height}>
      <g ref={gx} transform={`translate(0,${height - marginBottom})`} />
      <g ref={gy} transform={`translate(${marginLeft},0)`} />
      <path fill="none" stroke="currentColor" strokeWidth="1.5" d={line(data)} />
      <g fill="white" stroke="currentColor" strokeWidth="1.5">
        {data.map((d, i) => (<circle key={i} cx={x(i)} cy={y(d)} r="2.5" />))}
      </g>
    </svg>
  );
}Sandbox ↗︎For more guidance using D3 in React, see Amelia Wattenberger’s post.D3 in Svelte ​As with React, you can use Svelte exclusively for rendering if you like, and only use D3 modules that don’t manipulate the DOM. Here is a line plot of an array of numbers that uses d3-shape and d3-scale.LinePlot.sveltesvelte<script>
  import * as d3 from 'd3';

  export let data;
  export let width = 640;
  export let height = 400;
  export let marginTop = 20;
  export let marginRight = 20;
  export let marginBottom = 20;
  export let marginLeft = 20;

  $: x = d3.scaleLinear([0, data.length - 1], [marginLeft, width - marginRight]);
  $: y = d3.scaleLinear(d3.extent(data), [height - marginBottom, marginTop]);
  $: line = d3.line((d, i) => x(i), y);
</script>
<svg width={width} height={height}>
  <path fill="none" stroke="currentColor" stroke-width="1.5" d={line(data)} />
  <g fill="white" stroke="currentColor" stroke-width="1.5">
    {#each data as d, i}
      <circle key={i} cx={x(i)} cy={y(d)} r="2.5" />
    {/each}
  </g>
</svg>REPL ↗︎Svelte’s reactive statements ($:) pair nicely with D3 data joins for efficient updates. Below, we use them to render dynamic axes as the data changes.LinePlot.sveltesvelte<script>
  import * as d3 from 'd3';

  export let data;
  export let width = 640;
  export let height = 400;
  export let marginTop = 20;
  export let marginRight = 20;
  export let marginBottom = 30;
  export let marginLeft = 40;

  let gx;
  let gy;

  $: x = d3.scaleLinear([0, data.length - 1], [marginLeft, width - marginRight]);
  $: y = d3.scaleLinear(d3.extent(data), [height - marginBottom, marginTop]);
  $: line = d3.line((d, i) => x(i), y);
  $: d3.select(gy).call(d3.axisLeft(y));
  $: d3.select(gx).call(d3.axisBottom(x));
</script>
<svg width={width} height={height}>
  <g bind:this={gx} transform="translate(0,{height - marginBottom})" />
  <g bind:this={gy} transform="translate({marginLeft},0)" />
  <path fill="none" stroke="currentColor" stroke-width="1.5" d={line(data)} />
  <g fill="white" stroke="currentColor" stroke-width="1.5">
    {#each data as d, i}
      <circle key={i} cx={x(i)} cy={y(d)} r="2.5" />
    {/each}
  </g>
</svg>REPL ↗︎\n\nSearchK7.9.0GitHub️ 110.0kOn this pageGetting started ​D3 works in any JavaScript environment.Try D3 online ​The fastest way to get started (and get help) with D3 is on Observable! D3 is available by default in notebooks as part of Observable’s standard library. To create something with D3, return the generated DOM element from a cell. Here is a blank chart to get you started:js{
  // Declare the chart dimensions and margins.
  const width = 640;
  const height = 400;
  const marginTop = 20;
  const marginRight = 20;
  const marginBottom = 30;
  const marginLeft = 40;

  // Declare the x (horizontal position) scale.
  const x = d3.scaleUtc()
      .domain([new Date("2023-01-01"), new Date("2024-01-01")])
      .range([marginLeft, width - marginRight]);

  // Declare the y (vertical position) scale.
  const y = d3.scaleLinear()
      .domain([0, 100])
      .range([height - marginBottom, marginTop]);

  // Create the SVG container.
  const svg = d3.create("svg")
      .attr("width", width)
      .attr("height", height);

  // Add the x-axis.
  svg.append("g")
      .attr("transform", `translate(0,${height - marginBottom})`)
      .call(d3.axisBottom(x));

  // Add the y-axis.
  svg.append("g")
      .attr("transform", `translate(${marginLeft},0)`)
      .call(d3.axisLeft(y));

  // Return the SVG element.
  return svg.node();
}As a more complete example, try one of these starter templates:Area chartBar chartDonut chartHistogramLine chartSee the D3 gallery for more forkable examples.Observable includes a few D3 snippets when you click + to add a cell (type “d3” when the cell menu is open to filter), as well as convenient sample datasets to try out D3 features. Or upload a CSV or JSON file to start playing with your data. You can also fork any of the hundreds of notebooks we’ve published for a head start.Observable is free for public use. Sign up for a Pro account to connect to private databases, collaborate on private notebooks, and more.D3 in vanilla HTML ​In vanilla HTML, you can load D3 from a CDN such as jsDelivr or you can download it locally. We recommend using the CDN-hosted ES module bundle. But for those who need it, we also provide a UMD bundle that exports the d3 global when loaded as a plain script.ESM + CDNUMD + CDNUMD + localhtml<!DOCTYPE html>
<div id="container"></div>
<script type="module">

import * as d3 from "https://cdn.jsdelivr.net/npm/d3@7/+esm";

// Declare the chart dimensions and margins.
const width = 640;
const height = 400;
const marginTop = 20;
const marginRight = 20;
const marginBottom = 30;
const marginLeft = 40;

// Declare the x (horizontal position) scale.
const x = d3.scaleUtc()
    .domain([new Date("2023-01-01"), new Date("2024-01-01")])
    .range([marginLeft, width - marginRight]);

// Declare the y (vertical position) scale.
const y = d3.scaleLinear()
    .domain([0, 100])
    .range([height - marginBottom, marginTop]);

// Create the SVG container.
const svg = d3.create("svg")
    .attr("width", width)
    .attr("height", height);

// Add the x-axis.
svg.append("g")
    .attr("transform", `translate(0,${height - marginBottom})`)
    .call(d3.axisBottom(x));

// Add the y-axis.
svg.append("g")
    .attr("transform", `translate(${marginLeft},0)`)
    .call(d3.axisLeft(y));

// Append the SVG element.
container.append(svg.node());

</script>html<!DOCTYPE html>
<div id="container"></div>
<script src="https://cdn.jsdelivr.net/npm/d3@7"></script>
<script type="module">

// Declare the chart dimensions and margins.
const width = 640;
const height = 400;
const marginTop = 20;
const marginRight = 20;
const marginBottom = 30;
const marginLeft = 40;

// Declare the x (horizontal position) scale.
const x = d3.scaleUtc()
    .domain([new Date("2023-01-01"), new Date("2024-01-01")])
    .range([marginLeft, width - marginRight]);

// Declare the y (vertical position) scale.
const y = d3.scaleLinear()
    .domain([0, 100])
    .range([height - marginBottom, marginTop]);

// Create the SVG container.
const svg = d3.create("svg")
    .attr("width", width)
    .attr("height", height);

// Add the x-axis.
svg.append("g")
    .attr("transform", `translate(0,${height - marginBottom})`)
    .call(d3.axisBottom(x));

// Add the y-axis.
svg.append("g")
    .attr("transform", `translate(${marginLeft},0)`)
    .call(d3.axisLeft(y));

// Append the SVG element.
container.append(svg.node());

</script>html<!DOCTYPE html>
<div id="container"></div>
<script src="d3.js"></script>
<script type="module">

// Declare the chart dimensions and margins.
const width = 640;
const height = 400;
const marginTop = 20;
const marginRight = 20;
const marginBottom = 30;
const marginLeft = 40;

// Declare the x (horizontal position) scale.
const x = d3.scaleUtc()
    .domain([new Date("2023-01-01"), new Date("2024-01-01")])
    .range([marginLeft, width - marginRight]);

// Declare the y (vertical position) scale.
const y = d3.scaleLinear()
    .domain([0, 100])
    .range([height - marginBottom, marginTop]);

// Create the SVG container.
const svg = d3.create("svg")
    .attr("width", width)
    .attr("height", height);

// Add the x-axis.
svg.append("g")
    .attr("transform", `translate(0,${height - marginBottom})`)
    .call(d3.axisBottom(x));

// Add the y-axis.
svg.append("g")
    .attr("transform", `translate(${marginLeft},0)`)
    .call(d3.axisLeft(y));

// Append the SVG element.
container.append(svg.node());

</script>You can also import and destructure individual D3 modules like so:html<script type="module">

import {forceSimulation, forceCollide, forceX} from "https://cdn.jsdelivr.net/npm/d3-force@3/+esm";

const nodes = [{}, {}];
const simulation = forceSimulation(nodes)
    .force("x", forceX())
    .force("collide", forceCollide(5))
    .on("tick", () => console.log(nodes[0].x));

</script>If you’d prefer to run D3 locally (or offline), you can download the UMD bundles of D3 here:d3.v7.jsd3.v7.min.jsThen, create an index.html file as shown above in the UMD + local tab. Use the non-minified bundle for debugging, and the minified bundle for faster performance in production.Installing from npm ​If you’re developing a web application using Node, you can install D3 via yarn, npm, pnpm, or your preferred package manager.yarnnpmpnpmbashyarn add d3bashnpm install d3bashpnpm add d3You can then load D3 into your app as:jsimport * as d3 from "d3";You can instead import specific symbols if you prefer:jsimport {select, selectAll} from "d3";Alternatively you can install and import from D3 submodules:jsimport {mean, median} from "d3-array";TypeScript declarations are available via DefinitelyTyped.D3 in React ​Most D3 modules (including d3-scale, d3-array, d3-interpolate, and d3-format) don’t interact with the DOM, so there is no difference when using them in React. You can use them in JSX for purely declarative visualization, such as the line plot below.LinePlot.jsxjsximport * as d3 from "d3";

export default function LinePlot({
  data,
  width = 640,
  height = 400,
  marginTop = 20,
  marginRight = 20,
  marginBottom = 20,
  marginLeft = 20
}) {
  const x = d3.scaleLinear([0, data.length - 1], [marginLeft, width - marginRight]);
  const y = d3.scaleLinear(d3.extent(data), [height - marginBottom, marginTop]);
  const line = d3.line((d, i) => x(i), y);
  return (
    <svg width={width} height={height}>
      <path fill="none" stroke="currentColor" strokeWidth="1.5" d={line(data)} />
      <g fill="white" stroke="currentColor" strokeWidth="1.5">
        {data.map((d, i) => (<circle key={i} cx={x(i)} cy={y(d)} r="2.5" />))}
      </g>
    </svg>
  );
}Sandbox ↗︎D3 modules that operate on selections (including d3-selection, d3-transition, and d3-axis) do manipulate the DOM, which competes with React’s virtual DOM. In those cases, you can attach a ref to an element and pass it to D3 in a useEffect hook.LinePlot.jsxjsximport * as d3 from "d3";
import {useRef, useEffect} from "react";

export default function LinePlot({
  data,
  width = 640,
  height = 400,
  marginTop = 20,
  marginRight = 20,
  marginBottom = 30,
  marginLeft = 40
}) {
  const gx = useRef();
  const gy = useRef();
  const x = d3.scaleLinear([0, data.length - 1], [marginLeft, width - marginRight]);
  const y = d3.scaleLinear(d3.extent(data), [height - marginBottom, marginTop]);
  const line = d3.line((d, i) => x(i), y);
  useEffect(() => void d3.select(gx.current).call(d3.axisBottom(x)), [gx, x]);
  useEffect(() => void d3.select(gy.current).call(d3.axisLeft(y)), [gy, y]);
  return (
    <svg width={width} height={height}>
      <g ref={gx} transform={`translate(0,${height - marginBottom})`} />
      <g ref={gy} transform={`translate(${marginLeft},0)`} />
      <path fill="none" stroke="currentColor" strokeWidth="1.5" d={line(data)} />
      <g fill="white" stroke="currentColor" strokeWidth="1.5">
        {data.map((d, i) => (<circle key={i} cx={x(i)} cy={y(d)} r="2.5" />))}
      </g>
    </svg>
  );
}Sandbox ↗︎For more guidance using D3 in React, see Amelia Wattenberger’s post.D3 in Svelte ​As with React, you can use Svelte exclusively for rendering if you like, and only use D3 modules that don’t manipulate the DOM. Here is a line plot of an array of numbers that uses d3-shape and d3-scale.LinePlot.sveltesvelte<script>
  import * as d3 from 'd3';

  export let data;
  export let width = 640;
  export let height = 400;
  export let marginTop = 20;
  export let marginRight = 20;
  export let marginBottom = 20;
  export let marginLeft = 20;

  $: x = d3.scaleLinear([0, data.length - 1], [marginLeft, width - marginRight]);
  $: y = d3.scaleLinear(d3.extent(data), [height - marginBottom, marginTop]);
  $: line = d3.line((d, i) => x(i), y);
</script>
<svg width={width} height={height}>
  <path fill="none" stroke="currentColor" stroke-width="1.5" d={line(data)} />
  <g fill="white" stroke="currentColor" stroke-width="1.5">
    {#each data as d, i}
      <circle key={i} cx={x(i)} cy={y(d)} r="2.5" />
    {/each}
  </g>
</svg>REPL ↗︎Svelte’s reactive statements ($:) pair nicely with D3 data joins for efficient updates. Below, we use them to render dynamic axes as the data changes.LinePlot.sveltesvelte<script>
  import * as d3 from 'd3';

  export let data;
  export let width = 640;
  export let height = 400;
  export let marginTop = 20;
  export let marginRight = 20;
  export let marginBottom = 30;
  export let marginLeft = 40;

  let gx;
  let gy;

  $: x = d3.scaleLinear([0, data.length - 1], [marginLeft, width - marginRight]);
  $: y = d3.scaleLinear(d3.extent(data), [height - marginBottom, marginTop]);
  $: line = d3.line((d, i) => x(i), y);
  $: d3.select(gy).call(d3.axisLeft(y));
  $: d3.select(gx).call(d3.axisBottom(x));
</script>
<svg width={width} height={height}>
  <g bind:this={gx} transform="translate(0,{height - marginBottom})" />
  <g bind:this={gy} transform="translate({marginLeft},0)" />
  <path fill="none" stroke="currentColor" stroke-width="1.5" d={line(data)} />
  <g fill="white" stroke="currentColor" stroke-width="1.5">
    {#each data as d, i}
      <circle key={i} cx={x(i)} cy={y(d)} r="2.5" />
    {/each}
  </g>
</svg>REPL ↗︎PagerPrevious pageWhat is D3?Next pageAPI index\n\nGetting started ​D3 works in any JavaScript environment.Try D3 online ​The fastest way to get started (and get help) with D3 is on Observable! D3 is available by default in notebooks as part of Observable’s standard library. To create something with D3, return the generated DOM element from a cell. Here is a blank chart to get you started:js{
  // Declare the chart dimensions and margins.
  const width = 640;
  const height = 400;
  const marginTop = 20;
  const marginRight = 20;
  const marginBottom = 30;
  const marginLeft = 40;

  // Declare the x (horizontal position) scale.
  const x = d3.scaleUtc()
      .domain([new Date("2023-01-01"), new Date("2024-01-01")])
      .range([marginLeft, width - marginRight]);

  // Declare the y (vertical position) scale.
  const y = d3.scaleLinear()
      .domain([0, 100])
      .range([height - marginBottom, marginTop]);

  // Create the SVG container.
  const svg = d3.create("svg")
      .attr("width", width)
      .attr("height", height);

  // Add the x-axis.
  svg.append("g")
      .attr("transform", `translate(0,${height - marginBottom})`)
      .call(d3.axisBottom(x));

  // Add the y-axis.
  svg.append("g")
      .attr("transform", `translate(${marginLeft},0)`)
      .call(d3.axisLeft(y));

  // Return the SVG element.
  return svg.node();
}As a more complete example, try one of these starter templates:Area chartBar chartDonut chartHistogramLine chartSee the D3 gallery for more forkable examples.Observable includes a few D3 snippets when you click + to add a cell (type “d3” when the cell menu is open to filter), as well as convenient sample datasets to try out D3 features. Or upload a CSV or JSON file to start playing with your data. You can also fork any of the hundreds of notebooks we’ve published for a head start.Observable is free for public use. Sign up for a Pro account to connect to private databases, collaborate on private notebooks, and more.D3 in vanilla HTML ​In vanilla HTML, you can load D3 from a CDN such as jsDelivr or you can download it locally. We recommend using the CDN-hosted ES module bundle. But for those who need it, we also provide a UMD bundle that exports the d3 global when loaded as a plain script.ESM + CDNUMD + CDNUMD + localhtml<!DOCTYPE html>
<div id="container"></div>
<script type="module">

import * as d3 from "https://cdn.jsdelivr.net/npm/d3@7/+esm";

// Declare the chart dimensions and margins.
const width = 640;
const height = 400;
const marginTop = 20;
const marginRight = 20;
const marginBottom = 30;
const marginLeft = 40;

// Declare the x (horizontal position) scale.
const x = d3.scaleUtc()
    .domain([new Date("2023-01-01"), new Date("2024-01-01")])
    .range([marginLeft, width - marginRight]);

// Declare the y (vertical position) scale.
const y = d3.scaleLinear()
    .domain([0, 100])
    .range([height - marginBottom, marginTop]);

// Create the SVG container.
const svg = d3.create("svg")
    .attr("width", width)
    .attr("height", height);

// Add the x-axis.
svg.append("g")
    .attr("transform", `translate(0,${height - marginBottom})`)
    .call(d3.axisBottom(x));

// Add the y-axis.
svg.append("g")
    .attr("transform", `translate(${marginLeft},0)`)
    .call(d3.axisLeft(y));

// Append the SVG element.
container.append(svg.node());

</script>html<!DOCTYPE html>
<div id="container"></div>
<script src="https://cdn.jsdelivr.net/npm/d3@7"></script>
<script type="module">

// Declare the chart dimensions and margins.
const width = 640;
const height = 400;
const marginTop = 20;
const marginRight = 20;
const marginBottom = 30;
const marginLeft = 40;

// Declare the x (horizontal position) scale.
const x = d3.scaleUtc()
    .domain([new Date("2023-01-01"), new Date("2024-01-01")])
    .range([marginLeft, width - marginRight]);

// Declare the y (vertical position) scale.
const y = d3.scaleLinear()
    .domain([0, 100])
    .range([height - marginBottom, marginTop]);

// Create the SVG container.
const svg = d3.create("svg")
    .attr("width", width)
    .attr("height", height);

// Add the x-axis.
svg.append("g")
    .attr("transform", `translate(0,${height - marginBottom})`)
    .call(d3.axisBottom(x));

// Add the y-axis.
svg.append("g")
    .attr("transform", `translate(${marginLeft},0)`)
    .call(d3.axisLeft(y));

// Append the SVG element.
container.append(svg.node());

</script>html<!DOCTYPE html>
<div id="container"></div>
<script src="d3.js"></script>
<script type="module">

// Declare the chart dimensions and margins.
const width = 640;
const height = 400;
const marginTop = 20;
const marginRight = 20;
const marginBottom = 30;
const marginLeft = 40;

// Declare the x (horizontal position) scale.
const x = d3.scaleUtc()
    .domain([new Date("2023-01-01"), new Date("2024-01-01")])
    .range([marginLeft, width - marginRight]);

// Declare the y (vertical position) scale.
const y = d3.scaleLinear()
    .domain([0, 100])
    .range([height - marginBottom, marginTop]);

// Create the SVG container.
const svg = d3.create("svg")
    .attr("width", width)
    .attr("height", height);

// Add the x-axis.
svg.append("g")
    .attr("transform", `translate(0,${height - marginBottom})`)
    .call(d3.axisBottom(x));

// Add the y-axis.
svg.append("g")
    .attr("transform", `translate(${marginLeft},0)`)
    .call(d3.axisLeft(y));

// Append the SVG element.
container.append(svg.node());

</script>You can also import and destructure individual D3 modules like so:html<script type="module">

import {forceSimulation, forceCollide, forceX} from "https://cdn.jsdelivr.net/npm/d3-force@3/+esm";

const nodes = [{}, {}];
const simulation = forceSimulation(nodes)
    .force("x", forceX())
    .force("collide", forceCollide(5))
    .on("tick", () => console.log(nodes[0].x));

</script>If you’d prefer to run D3 locally (or offline), you can download the UMD bundles of D3 here:d3.v7.jsd3.v7.min.jsThen, create an index.html file as shown above in the UMD + local tab. Use the non-minified bundle for debugging, and the minified bundle for faster performance in production.Installing from npm ​If you’re developing a web application using Node, you can install D3 via yarn, npm, pnpm, or your preferred package manager.yarnnpmpnpmbashyarn add d3bashnpm install d3bashpnpm add d3You can then load D3 into your app as:jsimport * as d3 from "d3";You can instead import specific symbols if you prefer:jsimport {select, selectAll} from "d3";Alternatively you can install and import from D3 submodules:jsimport {mean, median} from "d3-array";TypeScript declarations are available via DefinitelyTyped.D3 in React ​Most D3 modules (including d3-scale, d3-array, d3-interpolate, and d3-format) don’t interact with the DOM, so there is no difference when using them in React. You can use them in JSX for purely declarative visualization, such as the line plot below.LinePlot.jsxjsximport * as d3 from "d3";

export default function LinePlot({
  data,
  width = 640,
  height = 400,
  marginTop = 20,
  marginRight = 20,
  marginBottom = 20,
  marginLeft = 20
}) {
  const x = d3.scaleLinear([0, data.length - 1], [marginLeft, width - marginRight]);
  const y = d3.scaleLinear(d3.extent(data), [height - marginBottom, marginTop]);
  const line = d3.line((d, i) => x(i), y);
  return (
    <svg width={width} height={height}>
      <path fill="none" stroke="currentColor" strokeWidth="1.5" d={line(data)} />
      <g fill="white" stroke="currentColor" strokeWidth="1.5">
        {data.map((d, i) => (<circle key={i} cx={x(i)} cy={y(d)} r="2.5" />))}
      </g>
    </svg>
  );
}Sandbox ↗︎D3 modules that operate on selections (including d3-selection, d3-transition, and d3-axis) do manipulate the DOM, which competes with React’s virtual DOM. In those cases, you can attach a ref to an element and pass it to D3 in a useEffect hook.LinePlot.jsxjsximport * as d3 from "d3";
import {useRef, useEffect} from "react";

export default function LinePlot({
  data,
  width = 640,
  height = 400,
  marginTop = 20,
  marginRight = 20,
  marginBottom = 30,
  marginLeft = 40
}) {
  const gx = useRef();
  const gy = useRef();
  const x = d3.scaleLinear([0, data.length - 1], [marginLeft, width - marginRight]);
  const y = d3.scaleLinear(d3.extent(data), [height - marginBottom, marginTop]);
  const line = d3.line((d, i) => x(i), y);
  useEffect(() => void d3.select(gx.current).call(d3.axisBottom(x)), [gx, x]);
  useEffect(() => void d3.select(gy.current).call(d3.axisLeft(y)), [gy, y]);
  return (
    <svg width={width} height={height}>
      <g ref={gx} transform={`translate(0,${height - marginBottom})`} />
      <g ref={gy} transform={`translate(${marginLeft},0)`} />
      <path fill="none" stroke="currentColor" strokeWidth="1.5" d={line(data)} />
      <g fill="white" stroke="currentColor" strokeWidth="1.5">
        {data.map((d, i) => (<circle key={i} cx={x(i)} cy={y(d)} r="2.5" />))}
      </g>
    </svg>
  );
}Sandbox ↗︎For more guidance using D3 in React, see Amelia Wattenberger’s post.D3 in Svelte ​As with React, you can use Svelte exclusively for rendering if you like, and only use D3 modules that don’t manipulate the DOM. Here is a line plot of an array of numbers that uses d3-shape and d3-scale.LinePlot.sveltesvelte<script>
  import * as d3 from 'd3';

  export let data;
  export let width = 640;
  export let height = 400;
  export let marginTop = 20;
  export let marginRight = 20;
  export let marginBottom = 20;
  export let marginLeft = 20;

  $: x = d3.scaleLinear([0, data.length - 1], [marginLeft, width - marginRight]);
  $: y = d3.scaleLinear(d3.extent(data), [height - marginBottom, marginTop]);
  $: line = d3.line((d, i) => x(i), y);
</script>
<svg width={width} height={height}>
  <path fill="none" stroke="currentColor" stroke-width="1.5" d={line(data)} />
  <g fill="white" stroke="currentColor" stroke-width="1.5">
    {#each data as d, i}
      <circle key={i} cx={x(i)} cy={y(d)} r="2.5" />
    {/each}
  </g>
</svg>REPL ↗︎Svelte’s reactive statements ($:) pair nicely with D3 data joins for efficient updates. Below, we use them to render dynamic axes as the data changes.LinePlot.sveltesvelte<script>
  import * as d3 from 'd3';

  export let data;
  export let width = 640;
  export let height = 400;
  export let marginTop = 20;
  export let marginRight = 20;
  export let marginBottom = 30;
  export let marginLeft = 40;

  let gx;
  let gy;

  $: x = d3.scaleLinear([0, data.length - 1], [marginLeft, width - marginRight]);
  $: y = d3.scaleLinear(d3.extent(data), [height - marginBottom, marginTop]);
  $: line = d3.line((d, i) => x(i), y);
  $: d3.select(gy).call(d3.axisLeft(y));
  $: d3.select(gx).call(d3.axisBottom(x));
</script>
<svg width={width} height={height}>
  <g bind:this={gx} transform="translate(0,{height - marginBottom})" />
  <g bind:this={gy} transform="translate({marginLeft},0)" />
  <path fill="none" stroke="currentColor" stroke-width="1.5" d={line(data)} />
  <g fill="white" stroke="currentColor" stroke-width="1.5">
    {#each data as d, i}
      <circle key={i} cx={x(i)} cy={y(d)} r="2.5" />
    {/each}
  </g>
</svg>REPL ↗︎\n\n\n\nGetting started ​D3 works in any JavaScript environment.Try D3 online ​The fastest way to get started (and get help) with D3 is on Observable! D3 is available by default in notebooks as part of Observable’s standard library. To create something with D3, return the generated DOM element from a cell. Here is a blank chart to get you started:js{
  // Declare the chart dimensions and margins.
  const width = 640;
  const height = 400;
  const marginTop = 20;
  const marginRight = 20;
  const marginBottom = 30;
  const marginLeft = 40;

  // Declare the x (horizontal position) scale.
  const x = d3.scaleUtc()
      .domain([new Date("2023-01-01"), new Date("2024-01-01")])
      .range([marginLeft, width - marginRight]);

  // Declare the y (vertical position) scale.
  const y = d3.scaleLinear()
      .domain([0, 100])
      .range([height - marginBottom, marginTop]);

  // Create the SVG container.
  const svg = d3.create("svg")
      .attr("width", width)
      .attr("height", height);

  // Add the x-axis.
  svg.append("g")
      .attr("transform", `translate(0,${height - marginBottom})`)
      .call(d3.axisBottom(x));

  // Add the y-axis.
  svg.append("g")
      .attr("transform", `translate(${marginLeft},0)`)
      .call(d3.axisLeft(y));

  // Return the SVG element.
  return svg.node();
}As a more complete example, try one of these starter templates:Area chartBar chartDonut chartHistogramLine chartSee the D3 gallery for more forkable examples.Observable includes a few D3 snippets when you click + to add a cell (type “d3” when the cell menu is open to filter), as well as convenient sample datasets to try out D3 features. Or upload a CSV or JSON file to start playing with your data. You can also fork any of the hundreds of notebooks we’ve published for a head start.Observable is free for public use. Sign up for a Pro account to connect to private databases, collaborate on private notebooks, and more.D3 in vanilla HTML ​In vanilla HTML, you can load D3 from a CDN such as jsDelivr or you can download it locally. We recommend using the CDN-hosted ES module bundle. But for those who need it, we also provide a UMD bundle that exports the d3 global when loaded as a plain script.ESM + CDNUMD + CDNUMD + localhtml<!DOCTYPE html>
<div id="container"></div>
<script type="module">

import * as d3 from "https://cdn.jsdelivr.net/npm/d3@7/+esm";

// Declare the chart dimensions and margins.
const width = 640;
const height = 400;
const marginTop = 20;
const marginRight = 20;
const marginBottom = 30;
const marginLeft = 40;

// Declare the x (horizontal position) scale.
const x = d3.scaleUtc()
    .domain([new Date("2023-01-01"), new Date("2024-01-01")])
    .range([marginLeft, width - marginRight]);

// Declare the y (vertical position) scale.
const y = d3.scaleLinear()
    .domain([0, 100])
    .range([height - marginBottom, marginTop]);

// Create the SVG container.
const svg = d3.create("svg")
    .attr("width", width)
    .attr("height", height);

// Add the x-axis.
svg.append("g")
    .attr("transform", `translate(0,${height - marginBottom})`)
    .call(d3.axisBottom(x));

// Add the y-axis.
svg.append("g")
    .attr("transform", `translate(${marginLeft},0)`)
    .call(d3.axisLeft(y));

// Append the SVG element.
container.append(svg.node());

</script>html<!DOCTYPE html>
<div id="container"></div>
<script src="https://cdn.jsdelivr.net/npm/d3@7"></script>
<script type="module">

// Declare the chart dimensions and margins.
const width = 640;
const height = 400;
const marginTop = 20;
const marginRight = 20;
const marginBottom = 30;
const marginLeft = 40;

// Declare the x (horizontal position) scale.
const x = d3.scaleUtc()
    .domain([new Date("2023-01-01"), new Date("2024-01-01")])
    .range([marginLeft, width - marginRight]);

// Declare the y (vertical position) scale.
const y = d3.scaleLinear()
    .domain([0, 100])
    .range([height - marginBottom, marginTop]);

// Create the SVG container.
const svg = d3.create("svg")
    .attr("width", width)
    .attr("height", height);

// Add the x-axis.
svg.append("g")
    .attr("transform", `translate(0,${height - marginBottom})`)
    .call(d3.axisBottom(x));

// Add the y-axis.
svg.append("g")
    .attr("transform", `translate(${marginLeft},0)`)
    .call(d3.axisLeft(y));

// Append the SVG element.
container.append(svg.node());

</script>html<!DOCTYPE html>
<div id="container"></div>
<script src="d3.js"></script>
<script type="module">

// Declare the chart dimensions and margins.
const width = 640;
const height = 400;
const marginTop = 20;
const marginRight = 20;
const marginBottom = 30;
const marginLeft = 40;

// Declare the x (horizontal position) scale.
const x = d3.scaleUtc()
    .domain([new Date("2023-01-01"), new Date("2024-01-01")])
    .range([marginLeft, width - marginRight]);

// Declare the y (vertical position) scale.
const y = d3.scaleLinear()
    .domain([0, 100])
    .range([height - marginBottom, marginTop]);

// Create the SVG container.
const svg = d3.create("svg")
    .attr("width", width)
    .attr("height", height);

// Add the x-axis.
svg.append("g")
    .attr("transform", `translate(0,${height - marginBottom})`)
    .call(d3.axisBottom(x));

// Add the y-axis.
svg.append("g")
    .attr("transform", `translate(${marginLeft},0)`)
    .call(d3.axisLeft(y));

// Append the SVG element.
container.append(svg.node());

</script>You can also import and destructure individual D3 modules like so:html<script type="module">

import {forceSimulation, forceCollide, forceX} from "https://cdn.jsdelivr.net/npm/d3-force@3/+esm";

const nodes = [{}, {}];
const simulation = forceSimulation(nodes)
    .force("x", forceX())
    .force("collide", forceCollide(5))
    .on("tick", () => console.log(nodes[0].x));

</script>If you’d prefer to run D3 locally (or offline), you can download the UMD bundles of D3 here:d3.v7.jsd3.v7.min.jsThen, create an index.html file as shown above in the UMD + local tab. Use the non-minified bundle for debugging, and the minified bundle for faster performance in production.Installing from npm ​If you’re developing a web application using Node, you can install D3 via yarn, npm, pnpm, or your preferred package manager.yarnnpmpnpmbashyarn add d3bashnpm install d3bashpnpm add d3You can then load D3 into your app as:jsimport * as d3 from "d3";You can instead import specific symbols if you prefer:jsimport {select, selectAll} from "d3";Alternatively you can install and import from D3 submodules:jsimport {mean, median} from "d3-array";TypeScript declarations are available via DefinitelyTyped.D3 in React ​Most D3 modules (including d3-scale, d3-array, d3-interpolate, and d3-format) don’t interact with the DOM, so there is no difference when using them in React. You can use them in JSX for purely declarative visualization, such as the line plot below.LinePlot.jsxjsximport * as d3 from "d3";

export default function LinePlot({
  data,
  width = 640,
  height = 400,
  marginTop = 20,
  marginRight = 20,
  marginBottom = 20,
  marginLeft = 20
}) {
  const x = d3.scaleLinear([0, data.length - 1], [marginLeft, width - marginRight]);
  const y = d3.scaleLinear(d3.extent(data), [height - marginBottom, marginTop]);
  const line = d3.line((d, i) => x(i), y);
  return (
    <svg width={width} height={height}>
      <path fill="none" stroke="currentColor" strokeWidth="1.5" d={line(data)} />
      <g fill="white" stroke="currentColor" strokeWidth="1.5">
        {data.map((d, i) => (<circle key={i} cx={x(i)} cy={y(d)} r="2.5" />))}
      </g>
    </svg>
  );
}Sandbox ↗︎D3 modules that operate on selections (including d3-selection, d3-transition, and d3-axis) do manipulate the DOM, which competes with React’s virtual DOM. In those cases, you can attach a ref to an element and pass it to D3 in a useEffect hook.LinePlot.jsxjsximport * as d3 from "d3";
import {useRef, useEffect} from "react";

export default function LinePlot({
  data,
  width = 640,
  height = 400,
  marginTop = 20,
  marginRight = 20,
  marginBottom = 30,
  marginLeft = 40
}) {
  const gx = useRef();
  const gy = useRef();
  const x = d3.scaleLinear([0, data.length - 1], [marginLeft, width - marginRight]);
  const y = d3.scaleLinear(d3.extent(data), [height - marginBottom, marginTop]);
  const line = d3.line((d, i) => x(i), y);
  useEffect(() => void d3.select(gx.current).call(d3.axisBottom(x)), [gx, x]);
  useEffect(() => void d3.select(gy.current).call(d3.axisLeft(y)), [gy, y]);
  return (
    <svg width={width} height={height}>
      <g ref={gx} transform={`translate(0,${height - marginBottom})`} />
      <g ref={gy} transform={`translate(${marginLeft},0)`} />
      <path fill="none" stroke="currentColor" strokeWidth="1.5" d={line(data)} />
      <g fill="white" stroke="currentColor" strokeWidth="1.5">
        {data.map((d, i) => (<circle key={i} cx={x(i)} cy={y(d)} r="2.5" />))}
      </g>
    </svg>
  );
}Sandbox ↗︎For more guidance using D3 in React, see Amelia Wattenberger’s post.D3 in Svelte ​As with React, you can use Svelte exclusively for rendering if you like, and only use D3 modules that don’t manipulate the DOM. Here is a line plot of an array of numbers that uses d3-shape and d3-scale.LinePlot.sveltesvelte<script>
  import * as d3 from 'd3';

  export let data;
  export let width = 640;
  export let height = 400;
  export let marginTop = 20;
  export let marginRight = 20;
  export let marginBottom = 20;
  export let marginLeft = 20;

  $: x = d3.scaleLinear([0, data.length - 1], [marginLeft, width - marginRight]);
  $: y = d3.scaleLinear(d3.extent(data), [height - marginBottom, marginTop]);
  $: line = d3.line((d, i) => x(i), y);
</script>
<svg width={width} height={height}>
  <path fill="none" stroke="currentColor" stroke-width="1.5" d={line(data)} />
  <g fill="white" stroke="currentColor" stroke-width="1.5">
    {#each data as d, i}
      <circle key={i} cx={x(i)} cy={y(d)} r="2.5" />
    {/each}
  </g>
</svg>REPL ↗︎Svelte’s reactive statements ($:) pair nicely with D3 data joins for efficient updates. Below, we use them to render dynamic axes as the data changes.LinePlot.sveltesvelte<script>
  import * as d3 from 'd3';

  export let data;
  export let width = 640;
  export let height = 400;
  export let marginTop = 20;
  export let marginRight = 20;
  export let marginBottom = 30;
  export let marginLeft = 40;

  let gx;
  let gy;

  $: x = d3.scaleLinear([0, data.length - 1], [marginLeft, width - marginRight]);
  $: y = d3.scaleLinear(d3.extent(data), [height - marginBottom, marginTop]);
  $: line = d3.line((d, i) => x(i), y);
  $: d3.select(gy).call(d3.axisLeft(y));
  $: d3.select(gx).call(d3.axisBottom(x));
</script>
<svg width={width} height={height}>
  <g bind:this={gx} transform="translate(0,{height - marginBottom})" />
  <g bind:this={gy} transform="translate({marginLeft},0)" />
  <path fill="none" stroke="currentColor" stroke-width="1.5" d={line(data)} />
  <g fill="white" stroke="currentColor" stroke-width="1.5">
    {#each data as d, i}
      <circle key={i} cx={x(i)} cy={y(d)} r="2.5" />
    {/each}
  </g>
</svg>REPL ↗︎\n\nSearchK7.9.0GitHub️ 110.0kOn this pageGetting started ​D3 works in any JavaScript environment.Try D3 online ​The fastest way to get started (and get help) with D3 is on Observable! D3 is available by default in notebooks as part of Observable’s standard library. To create something with D3, return the generated DOM element from a cell. Here is a blank chart to get you started:js{
  // Declare the chart dimensions and margins.
  const width = 640;
  const height = 400;
  const marginTop = 20;
  const marginRight = 20;
  const marginBottom = 30;
  const marginLeft = 40;

  // Declare the x (horizontal position) scale.
  const x = d3.scaleUtc()
      .domain([new Date("2023-01-01"), new Date("2024-01-01")])
      .range([marginLeft, width - marginRight]);

  // Declare the y (vertical position) scale.
  const y = d3.scaleLinear()
      .domain([0, 100])
      .range([height - marginBottom, marginTop]);

  // Create the SVG container.
  const svg = d3.create("svg")
      .attr("width", width)
      .attr("height", height);

  // Add the x-axis.
  svg.append("g")
      .attr("transform", `translate(0,${height - marginBottom})`)
      .call(d3.axisBottom(x));

  // Add the y-axis.
  svg.append("g")
      .attr("transform", `translate(${marginLeft},0)`)
      .call(d3.axisLeft(y));

  // Return the SVG element.
  return svg.node();
}As a more complete example, try one of these starter templates:Area chartBar chartDonut chartHistogramLine chartSee the D3 gallery for more forkable examples.Observable includes a few D3 snippets when you click + to add a cell (type “d3” when the cell menu is open to filter), as well as convenient sample datasets to try out D3 features. Or upload a CSV or JSON file to start playing with your data. You can also fork any of the hundreds of notebooks we’ve published for a head start.Observable is free for public use. Sign up for a Pro account to connect to private databases, collaborate on private notebooks, and more.D3 in vanilla HTML ​In vanilla HTML, you can load D3 from a CDN such as jsDelivr or you can download it locally. We recommend using the CDN-hosted ES module bundle. But for those who need it, we also provide a UMD bundle that exports the d3 global when loaded as a plain script.ESM + CDNUMD + CDNUMD + localhtml<!DOCTYPE html>
<div id="container"></div>
<script type="module">

import * as d3 from "https://cdn.jsdelivr.net/npm/d3@7/+esm";

// Declare the chart dimensions and margins.
const width = 640;
const height = 400;
const marginTop = 20;
const marginRight = 20;
const marginBottom = 30;
const marginLeft = 40;

// Declare the x (horizontal position) scale.
const x = d3.scaleUtc()
    .domain([new Date("2023-01-01"), new Date("2024-01-01")])
    .range([marginLeft, width - marginRight]);

// Declare the y (vertical position) scale.
const y = d3.scaleLinear()
    .domain([0, 100])
    .range([height - marginBottom, marginTop]);

// Create the SVG container.
const svg = d3.create("svg")
    .attr("width", width)
    .attr("height", height);

// Add the x-axis.
svg.append("g")
    .attr("transform", `translate(0,${height - marginBottom})`)
    .call(d3.axisBottom(x));

// Add the y-axis.
svg.append("g")
    .attr("transform", `translate(${marginLeft},0)`)
    .call(d3.axisLeft(y));

// Append the SVG element.
container.append(svg.node());

</script>html<!DOCTYPE html>
<div id="container"></div>
<script src="https://cdn.jsdelivr.net/npm/d3@7"></script>
<script type="module">

// Declare the chart dimensions and margins.
const width = 640;
const height = 400;
const marginTop = 20;
const marginRight = 20;
const marginBottom = 30;
const marginLeft = 40;

// Declare the x (horizontal position) scale.
const x = d3.scaleUtc()
    .domain([new Date("2023-01-01"), new Date("2024-01-01")])
    .range([marginLeft, width - marginRight]);

// Declare the y (vertical position) scale.
const y = d3.scaleLinear()
    .domain([0, 100])
    .range([height - marginBottom, marginTop]);

// Create the SVG container.
const svg = d3.create("svg")
    .attr("width", width)
    .attr("height", height);

// Add the x-axis.
svg.append("g")
    .attr("transform", `translate(0,${height - marginBottom})`)
    .call(d3.axisBottom(x));

// Add the y-axis.
svg.append("g")
    .attr("transform", `translate(${marginLeft},0)`)
    .call(d3.axisLeft(y));

// Append the SVG element.
container.append(svg.node());

</script>html<!DOCTYPE html>
<div id="container"></div>
<script src="d3.js"></script>
<script type="module">

// Declare the chart dimensions and margins.
const width = 640;
const height = 400;
const marginTop = 20;
const marginRight = 20;
const marginBottom = 30;
const marginLeft = 40;

// Declare the x (horizontal position) scale.
const x = d3.scaleUtc()
    .domain([new Date("2023-01-01"), new Date("2024-01-01")])
    .range([marginLeft, width - marginRight]);

// Declare the y (vertical position) scale.
const y = d3.scaleLinear()
    .domain([0, 100])
    .range([height - marginBottom, marginTop]);

// Create the SVG container.
const svg = d3.create("svg")
    .attr("width", width)
    .attr("height", height);

// Add the x-axis.
svg.append("g")
    .attr("transform", `translate(0,${height - marginBottom})`)
    .call(d3.axisBottom(x));

// Add the y-axis.
svg.append("g")
    .attr("transform", `translate(${marginLeft},0)`)
    .call(d3.axisLeft(y));

// Append the SVG element.
container.append(svg.node());

</script>You can also import and destructure individual D3 modules like so:html<script type="module">

import {forceSimulation, forceCollide, forceX} from "https://cdn.jsdelivr.net/npm/d3-force@3/+esm";

const nodes = [{}, {}];
const simulation = forceSimulation(nodes)
    .force("x", forceX())
    .force("collide", forceCollide(5))
    .on("tick", () => console.log(nodes[0].x));

</script>If you’d prefer to run D3 locally (or offline), you can download the UMD bundles of D3 here:d3.v7.jsd3.v7.min.jsThen, create an index.html file as shown above in the UMD + local tab. Use the non-minified bundle for debugging, and the minified bundle for faster performance in production.Installing from npm ​If you’re developing a web application using Node, you can install D3 via yarn, npm, pnpm, or your preferred package manager.yarnnpmpnpmbashyarn add d3bashnpm install d3bashpnpm add d3You can then load D3 into your app as:jsimport * as d3 from "d3";You can instead import specific symbols if you prefer:jsimport {select, selectAll} from "d3";Alternatively you can install and import from D3 submodules:jsimport {mean, median} from "d3-array";TypeScript declarations are available via DefinitelyTyped.D3 in React ​Most D3 modules (including d3-scale, d3-array, d3-interpolate, and d3-format) don’t interact with the DOM, so there is no difference when using them in React. You can use them in JSX for purely declarative visualization, such as the line plot below.LinePlot.jsxjsximport * as d3 from "d3";

export default function LinePlot({
  data,
  width = 640,
  height = 400,
  marginTop = 20,
  marginRight = 20,
  marginBottom = 20,
  marginLeft = 20
}) {
  const x = d3.scaleLinear([0, data.length - 1], [marginLeft, width - marginRight]);
  const y = d3.scaleLinear(d3.extent(data), [height - marginBottom, marginTop]);
  const line = d3.line((d, i) => x(i), y);
  return (
    <svg width={width} height={height}>
      <path fill="none" stroke="currentColor" strokeWidth="1.5" d={line(data)} />
      <g fill="white" stroke="currentColor" strokeWidth="1.5">
        {data.map((d, i) => (<circle key={i} cx={x(i)} cy={y(d)} r="2.5" />))}
      </g>
    </svg>
  );
}Sandbox ↗︎D3 modules that operate on selections (including d3-selection, d3-transition, and d3-axis) do manipulate the DOM, which competes with React’s virtual DOM. In those cases, you can attach a ref to an element and pass it to D3 in a useEffect hook.LinePlot.jsxjsximport * as d3 from "d3";
import {useRef, useEffect} from "react";

export default function LinePlot({
  data,
  width = 640,
  height = 400,
  marginTop = 20,
  marginRight = 20,
  marginBottom = 30,
  marginLeft = 40
}) {
  const gx = useRef();
  const gy = useRef();
  const x = d3.scaleLinear([0, data.length - 1], [marginLeft, width - marginRight]);
  const y = d3.scaleLinear(d3.extent(data), [height - marginBottom, marginTop]);
  const line = d3.line((d, i) => x(i), y);
  useEffect(() => void d3.select(gx.current).call(d3.axisBottom(x)), [gx, x]);
  useEffect(() => void d3.select(gy.current).call(d3.axisLeft(y)), [gy, y]);
  return (
    <svg width={width} height={height}>
      <g ref={gx} transform={`translate(0,${height - marginBottom})`} />
      <g ref={gy} transform={`translate(${marginLeft},0)`} />
      <path fill="none" stroke="currentColor" strokeWidth="1.5" d={line(data)} />
      <g fill="white" stroke="currentColor" strokeWidth="1.5">
        {data.map((d, i) => (<circle key={i} cx={x(i)} cy={y(d)} r="2.5" />))}
      </g>
    </svg>
  );
}Sandbox ↗︎For more guidance using D3 in React, see Amelia Wattenberger’s post.D3 in Svelte ​As with React, you can use Svelte exclusively for rendering if you like, and only use D3 modules that don’t manipulate the DOM. Here is a line plot of an array of numbers that uses d3-shape and d3-scale.LinePlot.sveltesvelte<script>
  import * as d3 from 'd3';

  export let data;
  export let width = 640;
  export let height = 400;
  export let marginTop = 20;
  export let marginRight = 20;
  export let marginBottom = 20;
  export let marginLeft = 20;

  $: x = d3.scaleLinear([0, data.length - 1], [marginLeft, width - marginRight]);
  $: y = d3.scaleLinear(d3.extent(data), [height - marginBottom, marginTop]);
  $: line = d3.line((d, i) => x(i), y);
</script>
<svg width={width} height={height}>
  <path fill="none" stroke="currentColor" stroke-width="1.5" d={line(data)} />
  <g fill="white" stroke="currentColor" stroke-width="1.5">
    {#each data as d, i}
      <circle key={i} cx={x(i)} cy={y(d)} r="2.5" />
    {/each}
  </g>
</svg>REPL ↗︎Svelte’s reactive statements ($:) pair nicely with D3 data joins for efficient updates. Below, we use them to render dynamic axes as the data changes.LinePlot.sveltesvelte<script>
  import * as d3 from 'd3';

  export let data;
  export let width = 640;
  export let height = 400;
  export let marginTop = 20;
  export let marginRight = 20;
  export let marginBottom = 30;
  export let marginLeft = 40;

  let gx;
  let gy;

  $: x = d3.scaleLinear([0, data.length - 1], [marginLeft, width - marginRight]);
  $: y = d3.scaleLinear(d3.extent(data), [height - marginBottom, marginTop]);
  $: line = d3.line((d, i) => x(i), y);
  $: d3.select(gy).call(d3.axisLeft(y));
  $: d3.select(gx).call(d3.axisBottom(x));
</script>
<svg width={width} height={height}>
  <g bind:this={gx} transform="translate(0,{height - marginBottom})" />
  <g bind:this={gy} transform="translate({marginLeft},0)" />
  <path fill="none" stroke="currentColor" stroke-width="1.5" d={line(data)} />
  <g fill="white" stroke="currentColor" stroke-width="1.5">
    {#each data as d, i}
      <circle key={i} cx={x(i)} cy={y(d)} r="2.5" />
    {/each}
  </g>
</svg>REPL ↗︎PagerPrevious pageWhat is D3?Next pageAPI index\n\nGetting started ​D3 works in any JavaScript environment.Try D3 online ​The fastest way to get started (and get help) with D3 is on Observable! D3 is available by default in notebooks as part of Observable’s standard library. To create something with D3, return the generated DOM element from a cell. Here is a blank chart to get you started:js{
  // Declare the chart dimensions and margins.
  const width = 640;
  const height = 400;
  const marginTop = 20;
  const marginRight = 20;
  const marginBottom = 30;
  const marginLeft = 40;

  // Declare the x (horizontal position) scale.
  const x = d3.scaleUtc()
      .domain([new Date("2023-01-01"), new Date("2024-01-01")])
      .range([marginLeft, width - marginRight]);

  // Declare the y (vertical position) scale.
  const y = d3.scaleLinear()
      .domain([0, 100])
      .range([height - marginBottom, marginTop]);

  // Create the SVG container.
  const svg = d3.create("svg")
      .attr("width", width)
      .attr("height", height);

  // Add the x-axis.
  svg.append("g")
      .attr("transform", `translate(0,${height - marginBottom})`)
      .call(d3.axisBottom(x));

  // Add the y-axis.
  svg.append("g")
      .attr("transform", `translate(${marginLeft},0)`)
      .call(d3.axisLeft(y));

  // Return the SVG element.
  return svg.node();
}As a more complete example, try one of these starter templates:Area chartBar chartDonut chartHistogramLine chartSee the D3 gallery for more forkable examples.Observable includes a few D3 snippets when you click + to add a cell (type “d3” when the cell menu is open to filter), as well as convenient sample datasets to try out D3 features. Or upload a CSV or JSON file to start playing with your data. You can also fork any of the hundreds of notebooks we’ve published for a head start.Observable is free for public use. Sign up for a Pro account to connect to private databases, collaborate on private notebooks, and more.D3 in vanilla HTML ​In vanilla HTML, you can load D3 from a CDN such as jsDelivr or you can download it locally. We recommend using the CDN-hosted ES module bundle. But for those who need it, we also provide a UMD bundle that exports the d3 global when loaded as a plain script.ESM + CDNUMD + CDNUMD + localhtml<!DOCTYPE html>
<div id="container"></div>
<script type="module">

import * as d3 from "https://cdn.jsdelivr.net/npm/d3@7/+esm";

// Declare the chart dimensions and margins.
const width = 640;
const height = 400;
const marginTop = 20;
const marginRight = 20;
const marginBottom = 30;
const marginLeft = 40;

// Declare the x (horizontal position) scale.
const x = d3.scaleUtc()
    .domain([new Date("2023-01-01"), new Date("2024-01-01")])
    .range([marginLeft, width - marginRight]);

// Declare the y (vertical position) scale.
const y = d3.scaleLinear()
    .domain([0, 100])
    .range([height - marginBottom, marginTop]);

// Create the SVG container.
const svg = d3.create("svg")
    .attr("width", width)
    .attr("height", height);

// Add the x-axis.
svg.append("g")
    .attr("transform", `translate(0,${height - marginBottom})`)
    .call(d3.axisBottom(x));

// Add the y-axis.
svg.append("g")
    .attr("transform", `translate(${marginLeft},0)`)
    .call(d3.axisLeft(y));

// Append the SVG element.
container.append(svg.node());

</script>html<!DOCTYPE html>
<div id="container"></div>
<script src="https://cdn.jsdelivr.net/npm/d3@7"></script>
<script type="module">

// Declare the chart dimensions and margins.
const width = 640;
const height = 400;
const marginTop = 20;
const marginRight = 20;
const marginBottom = 30;
const marginLeft = 40;

// Declare the x (horizontal position) scale.
const x = d3.scaleUtc()
    .domain([new Date("2023-01-01"), new Date("2024-01-01")])
    .range([marginLeft, width - marginRight]);

// Declare the y (vertical position) scale.
const y = d3.scaleLinear()
    .domain([0, 100])
    .range([height - marginBottom, marginTop]);

// Create the SVG container.
const svg = d3.create("svg")
    .attr("width", width)
    .attr("height", height);

// Add the x-axis.
svg.append("g")
    .attr("transform", `translate(0,${height - marginBottom})`)
    .call(d3.axisBottom(x));

// Add the y-axis.
svg.append("g")
    .attr("transform", `translate(${marginLeft},0)`)
    .call(d3.axisLeft(y));

// Append the SVG element.
container.append(svg.node());

</script>html<!DOCTYPE html>
<div id="container"></div>
<script src="d3.js"></script>
<script type="module">

// Declare the chart dimensions and margins.
const width = 640;
const height = 400;
const marginTop = 20;
const marginRight = 20;
const marginBottom = 30;
const marginLeft = 40;

// Declare the x (horizontal position) scale.
const x = d3.scaleUtc()
    .domain([new Date("2023-01-01"), new Date("2024-01-01")])
    .range([marginLeft, width - marginRight]);

// Declare the y (vertical position) scale.
const y = d3.scaleLinear()
    .domain([0, 100])
    .range([height - marginBottom, marginTop]);

// Create the SVG container.
const svg = d3.create("svg")
    .attr("width", width)
    .attr("height", height);

// Add the x-axis.
svg.append("g")
    .attr("transform", `translate(0,${height - marginBottom})`)
    .call(d3.axisBottom(x));

// Add the y-axis.
svg.append("g")
    .attr("transform", `translate(${marginLeft},0)`)
    .call(d3.axisLeft(y));

// Append the SVG element.
container.append(svg.node());

</script>You can also import and destructure individual D3 modules like so:html<script type="module">

import {forceSimulation, forceCollide, forceX} from "https://cdn.jsdelivr.net/npm/d3-force@3/+esm";

const nodes = [{}, {}];
const simulation = forceSimulation(nodes)
    .force("x", forceX())
    .force("collide", forceCollide(5))
    .on("tick", () => console.log(nodes[0].x));

</script>If you’d prefer to run D3 locally (or offline), you can download the UMD bundles of D3 here:d3.v7.jsd3.v7.min.jsThen, create an index.html file as shown above in the UMD + local tab. Use the non-minified bundle for debugging, and the minified bundle for faster performance in production.Installing from npm ​If you’re developing a web application using Node, you can install D3 via yarn, npm, pnpm, or your preferred package manager.yarnnpmpnpmbashyarn add d3bashnpm install d3bashpnpm add d3You can then load D3 into your app as:jsimport * as d3 from "d3";You can instead import specific symbols if you prefer:jsimport {select, selectAll} from "d3";Alternatively you can install and import from D3 submodules:jsimport {mean, median} from "d3-array";TypeScript declarations are available via DefinitelyTyped.D3 in React ​Most D3 modules (including d3-scale, d3-array, d3-interpolate, and d3-format) don’t interact with the DOM, so there is no difference when using them in React. You can use them in JSX for purely declarative visualization, such as the line plot below.LinePlot.jsxjsximport * as d3 from "d3";

export default function LinePlot({
  data,
  width = 640,
  height = 400,
  marginTop = 20,
  marginRight = 20,
  marginBottom = 20,
  marginLeft = 20
}) {
  const x = d3.scaleLinear([0, data.length - 1], [marginLeft, width - marginRight]);
  const y = d3.scaleLinear(d3.extent(data), [height - marginBottom, marginTop]);
  const line = d3.line((d, i) => x(i), y);
  return (
    <svg width={width} height={height}>
      <path fill="none" stroke="currentColor" strokeWidth="1.5" d={line(data)} />
      <g fill="white" stroke="currentColor" strokeWidth="1.5">
        {data.map((d, i) => (<circle key={i} cx={x(i)} cy={y(d)} r="2.5" />))}
      </g>
    </svg>
  );
}Sandbox ↗︎D3 modules that operate on selections (including d3-selection, d3-transition, and d3-axis) do manipulate the DOM, which competes with React’s virtual DOM. In those cases, you can attach a ref to an element and pass it to D3 in a useEffect hook.LinePlot.jsxjsximport * as d3 from "d3";
import {useRef, useEffect} from "react";

export default function LinePlot({
  data,
  width = 640,
  height = 400,
  marginTop = 20,
  marginRight = 20,
  marginBottom = 30,
  marginLeft = 40
}) {
  const gx = useRef();
  const gy = useRef();
  const x = d3.scaleLinear([0, data.length - 1], [marginLeft, width - marginRight]);
  const y = d3.scaleLinear(d3.extent(data), [height - marginBottom, marginTop]);
  const line = d3.line((d, i) => x(i), y);
  useEffect(() => void d3.select(gx.current).call(d3.axisBottom(x)), [gx, x]);
  useEffect(() => void d3.select(gy.current).call(d3.axisLeft(y)), [gy, y]);
  return (
    <svg width={width} height={height}>
      <g ref={gx} transform={`translate(0,${height - marginBottom})`} />
      <g ref={gy} transform={`translate(${marginLeft},0)`} />
      <path fill="none" stroke="currentColor" strokeWidth="1.5" d={line(data)} />
      <g fill="white" stroke="currentColor" strokeWidth="1.5">
        {data.map((d, i) => (<circle key={i} cx={x(i)} cy={y(d)} r="2.5" />))}
      </g>
    </svg>
  );
}Sandbox ↗︎For more guidance using D3 in React, see Amelia Wattenberger’s post.D3 in Svelte ​As with React, you can use Svelte exclusively for rendering if you like, and only use D3 modules that don’t manipulate the DOM. Here is a line plot of an array of numbers that uses d3-shape and d3-scale.LinePlot.sveltesvelte<script>
  import * as d3 from 'd3';

  export let data;
  export let width = 640;
  export let height = 400;
  export let marginTop = 20;
  export let marginRight = 20;
  export let marginBottom = 20;
  export let marginLeft = 20;

  $: x = d3.scaleLinear([0, data.length - 1], [marginLeft, width - marginRight]);
  $: y = d3.scaleLinear(d3.extent(data), [height - marginBottom, marginTop]);
  $: line = d3.line((d, i) => x(i), y);
</script>
<svg width={width} height={height}>
  <path fill="none" stroke="currentColor" stroke-width="1.5" d={line(data)} />
  <g fill="white" stroke="currentColor" stroke-width="1.5">
    {#each data as d, i}
      <circle key={i} cx={x(i)} cy={y(d)} r="2.5" />
    {/each}
  </g>
</svg>REPL ↗︎Svelte’s reactive statements ($:) pair nicely with D3 data joins for efficient updates. Below, we use them to render dynamic axes as the data changes.LinePlot.sveltesvelte<script>
  import * as d3 from 'd3';

  export let data;
  export let width = 640;
  export let height = 400;
  export let marginTop = 20;
  export let marginRight = 20;
  export let marginBottom = 30;
  export let marginLeft = 40;

  let gx;
  let gy;

  $: x = d3.scaleLinear([0, data.length - 1], [marginLeft, width - marginRight]);
  $: y = d3.scaleLinear(d3.extent(data), [height - marginBottom, marginTop]);
  $: line = d3.line((d, i) => x(i), y);
  $: d3.select(gy).call(d3.axisLeft(y));
  $: d3.select(gx).call(d3.axisBottom(x));
</script>
<svg width={width} height={height}>
  <g bind:this={gx} transform="translate(0,{height - marginBottom})" />
  <g bind:this={gy} transform="translate({marginLeft},0)" />
  <path fill="none" stroke="currentColor" stroke-width="1.5" d={line(data)} />
  <g fill="white" stroke="currentColor" stroke-width="1.5">
    {#each data as d, i}
      <circle key={i} cx={x(i)} cy={y(d)} r="2.5" />
    {/each}
  </g>
</svg>REPL ↗︎\n\n\n\nGetting started ​D3 works in any JavaScript environment.Try D3 online ​The fastest way to get started (and get help) with D3 is on Observable! D3 is available by default in notebooks as part of Observable’s standard library. To create something with D3, return the generated DOM element from a cell. Here is a blank chart to get you started:js{
  // Declare the chart dimensions and margins.
  const width = 640;
  const height = 400;
  const marginTop = 20;
  const marginRight = 20;
  const marginBottom = 30;
  const marginLeft = 40;

  // Declare the x (horizontal position) scale.
  const x = d3.scaleUtc()
      .domain([new Date("2023-01-01"), new Date("2024-01-01")])
      .range([marginLeft, width - marginRight]);

  // Declare the y (vertical position) scale.
  const y = d3.scaleLinear()
      .domain([0, 100])
      .range([height - marginBottom, marginTop]);

  // Create the SVG container.
  const svg = d3.create("svg")
      .attr("width", width)
      .attr("height", height);

  // Add the x-axis.
  svg.append("g")
      .attr("transform", `translate(0,${height - marginBottom})`)
      .call(d3.axisBottom(x));

  // Add the y-axis.
  svg.append("g")
      .attr("transform", `translate(${marginLeft},0)`)
      .call(d3.axisLeft(y));

  // Return the SVG element.
  return svg.node();
}As a more complete example, try one of these starter templates:Area chartBar chartDonut chartHistogramLine chartSee the D3 gallery for more forkable examples.Observable includes a few D3 snippets when you click + to add a cell (type “d3” when the cell menu is open to filter), as well as convenient sample datasets to try out D3 features. Or upload a CSV or JSON file to start playing with your data. You can also fork any of the hundreds of notebooks we’ve published for a head start.Observable is free for public use. Sign up for a Pro account to connect to private databases, collaborate on private notebooks, and more.D3 in vanilla HTML ​In vanilla HTML, you can load D3 from a CDN such as jsDelivr or you can download it locally. We recommend using the CDN-hosted ES module bundle. But for those who need it, we also provide a UMD bundle that exports the d3 global when loaded as a plain script.ESM + CDNUMD + CDNUMD + localhtml<!DOCTYPE html>
<div id="container"></div>
<script type="module">

import * as d3 from "https://cdn.jsdelivr.net/npm/d3@7/+esm";

// Declare the chart dimensions and margins.
const width = 640;
const height = 400;
const marginTop = 20;
const marginRight = 20;
const marginBottom = 30;
const marginLeft = 40;

// Declare the x (horizontal position) scale.
const x = d3.scaleUtc()
    .domain([new Date("2023-01-01"), new Date("2024-01-01")])
    .range([marginLeft, width - marginRight]);

// Declare the y (vertical position) scale.
const y = d3.scaleLinear()
    .domain([0, 100])
    .range([height - marginBottom, marginTop]);

// Create the SVG container.
const svg = d3.create("svg")
    .attr("width", width)
    .attr("height", height);

// Add the x-axis.
svg.append("g")
    .attr("transform", `translate(0,${height - marginBottom})`)
    .call(d3.axisBottom(x));

// Add the y-axis.
svg.append("g")
    .attr("transform", `translate(${marginLeft},0)`)
    .call(d3.axisLeft(y));

// Append the SVG element.
container.append(svg.node());

</script>html<!DOCTYPE html>
<div id="container"></div>
<script src="https://cdn.jsdelivr.net/npm/d3@7"></script>
<script type="module">

// Declare the chart dimensions and margins.
const width = 640;
const height = 400;
const marginTop = 20;
const marginRight = 20;
const marginBottom = 30;
const marginLeft = 40;

// Declare the x (horizontal position) scale.
const x = d3.scaleUtc()
    .domain([new Date("2023-01-01"), new Date("2024-01-01")])
    .range([marginLeft, width - marginRight]);

// Declare the y (vertical position) scale.
const y = d3.scaleLinear()
    .domain([0, 100])
    .range([height - marginBottom, marginTop]);

// Create the SVG container.
const svg = d3.create("svg")
    .attr("width", width)
    .attr("height", height);

// Add the x-axis.
svg.append("g")
    .attr("transform", `translate(0,${height - marginBottom})`)
    .call(d3.axisBottom(x));

// Add the y-axis.
svg.append("g")
    .attr("transform", `translate(${marginLeft},0)`)
    .call(d3.axisLeft(y));

// Append the SVG element.
container.append(svg.node());

</script>html<!DOCTYPE html>
<div id="container"></div>
<script src="d3.js"></script>
<script type="module">

// Declare the chart dimensions and margins.
const width = 640;
const height = 400;
const marginTop = 20;
const marginRight = 20;
const marginBottom = 30;
const marginLeft = 40;

// Declare the x (horizontal position) scale.
const x = d3.scaleUtc()
    .domain([new Date("2023-01-01"), new Date("2024-01-01")])
    .range([marginLeft, width - marginRight]);

// Declare the y (vertical position) scale.
const y = d3.scaleLinear()
    .domain([0, 100])
    .range([height - marginBottom, marginTop]);

// Create the SVG container.
const svg = d3.create("svg")
    .attr("width", width)
    .attr("height", height);

// Add the x-axis.
svg.append("g")
    .attr("transform", `translate(0,${height - marginBottom})`)
    .call(d3.axisBottom(x));

// Add the y-axis.
svg.append("g")
    .attr("transform", `translate(${marginLeft},0)`)
    .call(d3.axisLeft(y));

// Append the SVG element.
container.append(svg.node());

</script>You can also import and destructure individual D3 modules like so:html<script type="module">

import {forceSimulation, forceCollide, forceX} from "https://cdn.jsdelivr.net/npm/d3-force@3/+esm";

const nodes = [{}, {}];
const simulation = forceSimulation(nodes)
    .force("x", forceX())
    .force("collide", forceCollide(5))
    .on("tick", () => console.log(nodes[0].x));

</script>If you’d prefer to run D3 locally (or offline), you can download the UMD bundles of D3 here:d3.v7.jsd3.v7.min.jsThen, create an index.html file as shown above in the UMD + local tab. Use the non-minified bundle for debugging, and the minified bundle for faster performance in production.Installing from npm ​If you’re developing a web application using Node, you can install D3 via yarn, npm, pnpm, or your preferred package manager.yarnnpmpnpmbashyarn add d3bashnpm install d3bashpnpm add d3You can then load D3 into your app as:jsimport * as d3 from "d3";You can instead import specific symbols if you prefer:jsimport {select, selectAll} from "d3";Alternatively you can install and import from D3 submodules:jsimport {mean, median} from "d3-array";TypeScript declarations are available via DefinitelyTyped.D3 in React ​Most D3 modules (including d3-scale, d3-array, d3-interpolate, and d3-format) don’t interact with the DOM, so there is no difference when using them in React. You can use them in JSX for purely declarative visualization, such as the line plot below.LinePlot.jsxjsximport * as d3 from "d3";

export default function LinePlot({
  data,
  width = 640,
  height = 400,
  marginTop = 20,
  marginRight = 20,
  marginBottom = 20,
  marginLeft = 20
}) {
  const x = d3.scaleLinear([0, data.length - 1], [marginLeft, width - marginRight]);
  const y = d3.scaleLinear(d3.extent(data), [height - marginBottom, marginTop]);
  const line = d3.line((d, i) => x(i), y);
  return (
    <svg width={width} height={height}>
      <path fill="none" stroke="currentColor" strokeWidth="1.5" d={line(data)} />
      <g fill="white" stroke="currentColor" strokeWidth="1.5">
        {data.map((d, i) => (<circle key={i} cx={x(i)} cy={y(d)} r="2.5" />))}
      </g>
    </svg>
  );
}Sandbox ↗︎D3 modules that operate on selections (including d3-selection, d3-transition, and d3-axis) do manipulate the DOM, which competes with React’s virtual DOM. In those cases, you can attach a ref to an element and pass it to D3 in a useEffect hook.LinePlot.jsxjsximport * as d3 from "d3";
import {useRef, useEffect} from "react";

export default function LinePlot({
  data,
  width = 640,
  height = 400,
  marginTop = 20,
  marginRight = 20,
  marginBottom = 30,
  marginLeft = 40
}) {
  const gx = useRef();
  const gy = useRef();
  const x = d3.scaleLinear([0, data.length - 1], [marginLeft, width - marginRight]);
  const y = d3.scaleLinear(d3.extent(data), [height - marginBottom, marginTop]);
  const line = d3.line((d, i) => x(i), y);
  useEffect(() => void d3.select(gx.current).call(d3.axisBottom(x)), [gx, x]);
  useEffect(() => void d3.select(gy.current).call(d3.axisLeft(y)), [gy, y]);
  return (
    <svg width={width} height={height}>
      <g ref={gx} transform={`translate(0,${height - marginBottom})`} />
      <g ref={gy} transform={`translate(${marginLeft},0)`} />
      <path fill="none" stroke="currentColor" strokeWidth="1.5" d={line(data)} />
      <g fill="white" stroke="currentColor" strokeWidth="1.5">
        {data.map((d, i) => (<circle key={i} cx={x(i)} cy={y(d)} r="2.5" />))}
      </g>
    </svg>
  );
}Sandbox ↗︎For more guidance using D3 in React, see Amelia Wattenberger’s post.D3 in Svelte ​As with React, you can use Svelte exclusively for rendering if you like, and only use D3 modules that don’t manipulate the DOM. Here is a line plot of an array of numbers that uses d3-shape and d3-scale.LinePlot.sveltesvelte<script>
  import * as d3 from 'd3';

  export let data;
  export let width = 640;
  export let height = 400;
  export let marginTop = 20;
  export let marginRight = 20;
  export let marginBottom = 20;
  export let marginLeft = 20;

  $: x = d3.scaleLinear([0, data.length - 1], [marginLeft, width - marginRight]);
  $: y = d3.scaleLinear(d3.extent(data), [height - marginBottom, marginTop]);
  $: line = d3.line((d, i) => x(i), y);
</script>
<svg width={width} height={height}>
  <path fill="none" stroke="currentColor" stroke-width="1.5" d={line(data)} />
  <g fill="white" stroke="currentColor" stroke-width="1.5">
    {#each data as d, i}
      <circle key={i} cx={x(i)} cy={y(d)} r="2.5" />
    {/each}
  </g>
</svg>REPL ↗︎Svelte’s reactive statements ($:) pair nicely with D3 data joins for efficient updates. Below, we use them to render dynamic axes as the data changes.LinePlot.sveltesvelte<script>
  import * as d3 from 'd3';

  export let data;
  export let width = 640;
  export let height = 400;
  export let marginTop = 20;
  export let marginRight = 20;
  export let marginBottom = 30;
  export let marginLeft = 40;

  let gx;
  let gy;

  $: x = d3.scaleLinear([0, data.length - 1], [marginLeft, width - marginRight]);
  $: y = d3.scaleLinear(d3.extent(data), [height - marginBottom, marginTop]);
  $: line = d3.line((d, i) => x(i), y);
  $: d3.select(gy).call(d3.axisLeft(y));
  $: d3.select(gx).call(d3.axisBottom(x));
</script>
<svg width={width} height={height}>
  <g bind:this={gx} transform="translate(0,{height - marginBottom})" />
  <g bind:this={gy} transform="translate({marginLeft},0)" />
  <path fill="none" stroke="currentColor" stroke-width="1.5" d={line(data)} />
  <g fill="white" stroke="currentColor" stroke-width="1.5">
    {#each data as d, i}
      <circle key={i} cx={x(i)} cy={y(d)} r="2.5" />
    {/each}
  </g>
</svg>REPL ↗︎\n\nSearchK7.9.0GitHub️ 110.0kOn this pageGetting started ​D3 works in any JavaScript environment.Try D3 online ​The fastest way to get started (and get help) with D3 is on Observable! D3 is available by default in notebooks as part of Observable’s standard library. To create something with D3, return the generated DOM element from a cell. Here is a blank chart to get you started:js{
  // Declare the chart dimensions and margins.
  const width = 640;
  const height = 400;
  const marginTop = 20;
  const marginRight = 20;
  const marginBottom = 30;
  const marginLeft = 40;

  // Declare the x (horizontal position) scale.
  const x = d3.scaleUtc()
      .domain([new Date("2023-01-01"), new Date("2024-01-01")])
      .range([marginLeft, width - marginRight]);

  // Declare the y (vertical position) scale.
  const y = d3.scaleLinear()
      .domain([0, 100])
      .range([height - marginBottom, marginTop]);

  // Create the SVG container.
  const svg = d3.create("svg")
      .attr("width", width)
      .attr("height", height);

  // Add the x-axis.
  svg.append("g")
      .attr("transform", `translate(0,${height - marginBottom})`)
      .call(d3.axisBottom(x));

  // Add the y-axis.
  svg.append("g")
      .attr("transform", `translate(${marginLeft},0)`)
      .call(d3.axisLeft(y));

  // Return the SVG element.
  return svg.node();
}As a more complete example, try one of these starter templates:Area chartBar chartDonut chartHistogramLine chartSee the D3 gallery for more forkable examples.Observable includes a few D3 snippets when you click + to add a cell (type “d3” when the cell menu is open to filter), as well as convenient sample datasets to try out D3 features. Or upload a CSV or JSON file to start playing with your data. You can also fork any of the hundreds of notebooks we’ve published for a head start.Observable is free for public use. Sign up for a Pro account to connect to private databases, collaborate on private notebooks, and more.D3 in vanilla HTML ​In vanilla HTML, you can load D3 from a CDN such as jsDelivr or you can download it locally. We recommend using the CDN-hosted ES module bundle. But for those who need it, we also provide a UMD bundle that exports the d3 global when loaded as a plain script.ESM + CDNUMD + CDNUMD + localhtml<!DOCTYPE html>
<div id="container"></div>
<script type="module">

import * as d3 from "https://cdn.jsdelivr.net/npm/d3@7/+esm";

// Declare the chart dimensions and margins.
const width = 640;
const height = 400;
const marginTop = 20;
const marginRight = 20;
const marginBottom = 30;
const marginLeft = 40;

// Declare the x (horizontal position) scale.
const x = d3.scaleUtc()
    .domain([new Date("2023-01-01"), new Date("2024-01-01")])
    .range([marginLeft, width - marginRight]);

// Declare the y (vertical position) scale.
const y = d3.scaleLinear()
    .domain([0, 100])
    .range([height - marginBottom, marginTop]);

// Create the SVG container.
const svg = d3.create("svg")
    .attr("width", width)
    .attr("height", height);

// Add the x-axis.
svg.append("g")
    .attr("transform", `translate(0,${height - marginBottom})`)
    .call(d3.axisBottom(x));

// Add the y-axis.
svg.append("g")
    .attr("transform", `translate(${marginLeft},0)`)
    .call(d3.axisLeft(y));

// Append the SVG element.
container.append(svg.node());

</script>html<!DOCTYPE html>
<div id="container"></div>
<script src="https://cdn.jsdelivr.net/npm/d3@7"></script>
<script type="module">

// Declare the chart dimensions and margins.
const width = 640;
const height = 400;
const marginTop = 20;
const marginRight = 20;
const marginBottom = 30;
const marginLeft = 40;

// Declare the x (horizontal position) scale.
const x = d3.scaleUtc()
    .domain([new Date("2023-01-01"), new Date("2024-01-01")])
    .range([marginLeft, width - marginRight]);

// Declare the y (vertical position) scale.
const y = d3.scaleLinear()
    .domain([0, 100])
    .range([height - marginBottom, marginTop]);

// Create the SVG container.
const svg = d3.create("svg")
    .attr("width", width)
    .attr("height", height);

// Add the x-axis.
svg.append("g")
    .attr("transform", `translate(0,${height - marginBottom})`)
    .call(d3.axisBottom(x));

// Add the y-axis.
svg.append("g")
    .attr("transform", `translate(${marginLeft},0)`)
    .call(d3.axisLeft(y));

// Append the SVG element.
container.append(svg.node());

</script>html<!DOCTYPE html>
<div id="container"></div>
<script src="d3.js"></script>
<script type="module">

// Declare the chart dimensions and margins.
const width = 640;
const height = 400;
const marginTop = 20;
const marginRight = 20;
const marginBottom = 30;
const marginLeft = 40;

// Declare the x (horizontal position) scale.
const x = d3.scaleUtc()
    .domain([new Date("2023-01-01"), new Date("2024-01-01")])
    .range([marginLeft, width - marginRight]);

// Declare the y (vertical position) scale.
const y = d3.scaleLinear()
    .domain([0, 100])
    .range([height - marginBottom, marginTop]);

// Create the SVG container.
const svg = d3.create("svg")
    .attr("width", width)
    .attr("height", height);

// Add the x-axis.
svg.append("g")
    .attr("transform", `translate(0,${height - marginBottom})`)
    .call(d3.axisBottom(x));

// Add the y-axis.
svg.append("g")
    .attr("transform", `translate(${marginLeft},0)`)
    .call(d3.axisLeft(y));

// Append the SVG element.
container.append(svg.node());

</script>You can also import and destructure individual D3 modules like so:html<script type="module">

import {forceSimulation, forceCollide, forceX} from "https://cdn.jsdelivr.net/npm/d3-force@3/+esm";

const nodes = [{}, {}];
const simulation = forceSimulation(nodes)
    .force("x", forceX())
    .force("collide", forceCollide(5))
    .on("tick", () => console.log(nodes[0].x));

</script>If you’d prefer to run D3 locally (or offline), you can download the UMD bundles of D3 here:d3.v7.jsd3.v7.min.jsThen, create an index.html file as shown above in the UMD + local tab. Use the non-minified bundle for debugging, and the minified bundle for faster performance in production.Installing from npm ​If you’re developing a web application using Node, you can install D3 via yarn, npm, pnpm, or your preferred package manager.yarnnpmpnpmbashyarn add d3bashnpm install d3bashpnpm add d3You can then load D3 into your app as:jsimport * as d3 from "d3";You can instead import specific symbols if you prefer:jsimport {select, selectAll} from "d3";Alternatively you can install and import from D3 submodules:jsimport {mean, median} from "d3-array";TypeScript declarations are available via DefinitelyTyped.D3 in React ​Most D3 modules (including d3-scale, d3-array, d3-interpolate, and d3-format) don’t interact with the DOM, so there is no difference when using them in React. You can use them in JSX for purely declarative visualization, such as the line plot below.LinePlot.jsxjsximport * as d3 from "d3";

export default function LinePlot({
  data,
  width = 640,
  height = 400,
  marginTop = 20,
  marginRight = 20,
  marginBottom = 20,
  marginLeft = 20
}) {
  const x = d3.scaleLinear([0, data.length - 1], [marginLeft, width - marginRight]);
  const y = d3.scaleLinear(d3.extent(data), [height - marginBottom, marginTop]);
  const line = d3.line((d, i) => x(i), y);
  return (
    <svg width={width} height={height}>
      <path fill="none" stroke="currentColor" strokeWidth="1.5" d={line(data)} />
      <g fill="white" stroke="currentColor" strokeWidth="1.5">
        {data.map((d, i) => (<circle key={i} cx={x(i)} cy={y(d)} r="2.5" />))}
      </g>
    </svg>
  );
}Sandbox ↗︎D3 modules that operate on selections (including d3-selection, d3-transition, and d3-axis) do manipulate the DOM, which competes with React’s virtual DOM. In those cases, you can attach a ref to an element and pass it to D3 in a useEffect hook.LinePlot.jsxjsximport * as d3 from "d3";
import {useRef, useEffect} from "react";

export default function LinePlot({
  data,
  width = 640,
  height = 400,
  marginTop = 20,
  marginRight = 20,
  marginBottom = 30,
  marginLeft = 40
}) {
  const gx = useRef();
  const gy = useRef();
  const x = d3.scaleLinear([0, data.length - 1], [marginLeft, width - marginRight]);
  const y = d3.scaleLinear(d3.extent(data), [height - marginBottom, marginTop]);
  const line = d3.line((d, i) => x(i), y);
  useEffect(() => void d3.select(gx.current).call(d3.axisBottom(x)), [gx, x]);
  useEffect(() => void d3.select(gy.current).call(d3.axisLeft(y)), [gy, y]);
  return (
    <svg width={width} height={height}>
      <g ref={gx} transform={`translate(0,${height - marginBottom})`} />
      <g ref={gy} transform={`translate(${marginLeft},0)`} />
      <path fill="none" stroke="currentColor" strokeWidth="1.5" d={line(data)} />
      <g fill="white" stroke="currentColor" strokeWidth="1.5">
        {data.map((d, i) => (<circle key={i} cx={x(i)} cy={y(d)} r="2.5" />))}
      </g>
    </svg>
  );
}Sandbox ↗︎For more guidance using D3 in React, see Amelia Wattenberger’s post.D3 in Svelte ​As with React, you can use Svelte exclusively for rendering if you like, and only use D3 modules that don’t manipulate the DOM. Here is a line plot of an array of numbers that uses d3-shape and d3-scale.LinePlot.sveltesvelte<script>
  import * as d3 from 'd3';

  export let data;
  export let width = 640;
  export let height = 400;
  export let marginTop = 20;
  export let marginRight = 20;
  export let marginBottom = 20;
  export let marginLeft = 20;

  $: x = d3.scaleLinear([0, data.length - 1], [marginLeft, width - marginRight]);
  $: y = d3.scaleLinear(d3.extent(data), [height - marginBottom, marginTop]);
  $: line = d3.line((d, i) => x(i), y);
</script>
<svg width={width} height={height}>
  <path fill="none" stroke="currentColor" stroke-width="1.5" d={line(data)} />
  <g fill="white" stroke="currentColor" stroke-width="1.5">
    {#each data as d, i}
      <circle key={i} cx={x(i)} cy={y(d)} r="2.5" />
    {/each}
  </g>
</svg>REPL ↗︎Svelte’s reactive statements ($:) pair nicely with D3 data joins for efficient updates. Below, we use them to render dynamic axes as the data changes.LinePlot.sveltesvelte<script>
  import * as d3 from 'd3';

  export let data;
  export let width = 640;
  export let height = 400;
  export let marginTop = 20;
  export let marginRight = 20;
  export let marginBottom = 30;
  export let marginLeft = 40;

  let gx;
  let gy;

  $: x = d3.scaleLinear([0, data.length - 1], [marginLeft, width - marginRight]);
  $: y = d3.scaleLinear(d3.extent(data), [height - marginBottom, marginTop]);
  $: line = d3.line((d, i) => x(i), y);
  $: d3.select(gy).call(d3.axisLeft(y));
  $: d3.select(gx).call(d3.axisBottom(x));
</script>
<svg width={width} height={height}>
  <g bind:this={gx} transform="translate(0,{height - marginBottom})" />
  <g bind:this={gy} transform="translate({marginLeft},0)" />
  <path fill="none" stroke="currentColor" stroke-width="1.5" d={line(data)} />
  <g fill="white" stroke="currentColor" stroke-width="1.5">
    {#each data as d, i}
      <circle key={i} cx={x(i)} cy={y(d)} r="2.5" />
    {/each}
  </g>
</svg>REPL ↗︎PagerPrevious pageWhat is D3?Next pageAPI index\n\nGetting started ​D3 works in any JavaScript environment.Try D3 online ​The fastest way to get started (and get help) with D3 is on Observable! D3 is available by default in notebooks as part of Observable’s standard library. To create something with D3, return the generated DOM element from a cell. Here is a blank chart to get you started:js{
  // Declare the chart dimensions and margins.
  const width = 640;
  const height = 400;
  const marginTop = 20;
  const marginRight = 20;
  const marginBottom = 30;
  const marginLeft = 40;

  // Declare the x (horizontal position) scale.
  const x = d3.scaleUtc()
      .domain([new Date("2023-01-01"), new Date("2024-01-01")])
      .range([marginLeft, width - marginRight]);

  // Declare the y (vertical position) scale.
  const y = d3.scaleLinear()
      .domain([0, 100])
      .range([height - marginBottom, marginTop]);

  // Create the SVG container.
  const svg = d3.create("svg")
      .attr("width", width)
      .attr("height", height);

  // Add the x-axis.
  svg.append("g")
      .attr("transform", `translate(0,${height - marginBottom})`)
      .call(d3.axisBottom(x));

  // Add the y-axis.
  svg.append("g")
      .attr("transform", `translate(${marginLeft},0)`)
      .call(d3.axisLeft(y));

  // Return the SVG element.
  return svg.node();
}As a more complete example, try one of these starter templates:Area chartBar chartDonut chartHistogramLine chartSee the D3 gallery for more forkable examples.Observable includes a few D3 snippets when you click + to add a cell (type “d3” when the cell menu is open to filter), as well as convenient sample datasets to try out D3 features. Or upload a CSV or JSON file to start playing with your data. You can also fork any of the hundreds of notebooks we’ve published for a head start.Observable is free for public use. Sign up for a Pro account to connect to private databases, collaborate on private notebooks, and more.D3 in vanilla HTML ​In vanilla HTML, you can load D3 from a CDN such as jsDelivr or you can download it locally. We recommend using the CDN-hosted ES module bundle. But for those who need it, we also provide a UMD bundle that exports the d3 global when loaded as a plain script.ESM + CDNUMD + CDNUMD + localhtml<!DOCTYPE html>
<div id="container"></div>
<script type="module">

import * as d3 from "https://cdn.jsdelivr.net/npm/d3@7/+esm";

// Declare the chart dimensions and margins.
const width = 640;
const height = 400;
const marginTop = 20;
const marginRight = 20;
const marginBottom = 30;
const marginLeft = 40;

// Declare the x (horizontal position) scale.
const x = d3.scaleUtc()
    .domain([new Date("2023-01-01"), new Date("2024-01-01")])
    .range([marginLeft, width - marginRight]);

// Declare the y (vertical position) scale.
const y = d3.scaleLinear()
    .domain([0, 100])
    .range([height - marginBottom, marginTop]);

// Create the SVG container.
const svg = d3.create("svg")
    .attr("width", width)
    .attr("height", height);

// Add the x-axis.
svg.append("g")
    .attr("transform", `translate(0,${height - marginBottom})`)
    .call(d3.axisBottom(x));

// Add the y-axis.
svg.append("g")
    .attr("transform", `translate(${marginLeft},0)`)
    .call(d3.axisLeft(y));

// Append the SVG element.
container.append(svg.node());

</script>html<!DOCTYPE html>
<div id="container"></div>
<script src="https://cdn.jsdelivr.net/npm/d3@7"></script>
<script type="module">

// Declare the chart dimensions and margins.
const width = 640;
const height = 400;
const marginTop = 20;
const marginRight = 20;
const marginBottom = 30;
const marginLeft = 40;

// Declare the x (horizontal position) scale.
const x = d3.scaleUtc()
    .domain([new Date("2023-01-01"), new Date("2024-01-01")])
    .range([marginLeft, width - marginRight]);

// Declare the y (vertical position) scale.
const y = d3.scaleLinear()
    .domain([0, 100])
    .range([height - marginBottom, marginTop]);

// Create the SVG container.
const svg = d3.create("svg")
    .attr("width", width)
    .attr("height", height);

// Add the x-axis.
svg.append("g")
    .attr("transform", `translate(0,${height - marginBottom})`)
    .call(d3.axisBottom(x));

// Add the y-axis.
svg.append("g")
    .attr("transform", `translate(${marginLeft},0)`)
    .call(d3.axisLeft(y));

// Append the SVG element.
container.append(svg.node());

</script>html<!DOCTYPE html>
<div id="container"></div>
<script src="d3.js"></script>
<script type="module">

// Declare the chart dimensions and margins.
const width = 640;
const height = 400;
const marginTop = 20;
const marginRight = 20;
const marginBottom = 30;
const marginLeft = 40;

// Declare the x (horizontal position) scale.
const x = d3.scaleUtc()
    .domain([new Date("2023-01-01"), new Date("2024-01-01")])
    .range([marginLeft, width - marginRight]);

// Declare the y (vertical position) scale.
const y = d3.scaleLinear()
    .domain([0, 100])
    .range([height - marginBottom, marginTop]);

// Create the SVG container.
const svg = d3.create("svg")
    .attr("width", width)
    .attr("height", height);

// Add the x-axis.
svg.append("g")
    .attr("transform", `translate(0,${height - marginBottom})`)
    .call(d3.axisBottom(x));

// Add the y-axis.
svg.append("g")
    .attr("transform", `translate(${marginLeft},0)`)
    .call(d3.axisLeft(y));

// Append the SVG element.
container.append(svg.node());

</script>You can also import and destructure individual D3 modules like so:html<script type="module">

import {forceSimulation, forceCollide, forceX} from "https://cdn.jsdelivr.net/npm/d3-force@3/+esm";

const nodes = [{}, {}];
const simulation = forceSimulation(nodes)
    .force("x", forceX())
    .force("collide", forceCollide(5))
    .on("tick", () => console.log(nodes[0].x));

</script>If you’d prefer to run D3 locally (or offline), you can download the UMD bundles of D3 here:d3.v7.jsd3.v7.min.jsThen, create an index.html file as shown above in the UMD + local tab. Use the non-minified bundle for debugging, and the minified bundle for faster performance in production.Installing from npm ​If you’re developing a web application using Node, you can install D3 via yarn, npm, pnpm, or your preferred package manager.yarnnpmpnpmbashyarn add d3bashnpm install d3bashpnpm add d3You can then load D3 into your app as:jsimport * as d3 from "d3";You can instead import specific symbols if you prefer:jsimport {select, selectAll} from "d3";Alternatively you can install and import from D3 submodules:jsimport {mean, median} from "d3-array";TypeScript declarations are available via DefinitelyTyped.D3 in React ​Most D3 modules (including d3-scale, d3-array, d3-interpolate, and d3-format) don’t interact with the DOM, so there is no difference when using them in React. You can use them in JSX for purely declarative visualization, such as the line plot below.LinePlot.jsxjsximport * as d3 from "d3";

export default function LinePlot({
  data,
  width = 640,
  height = 400,
  marginTop = 20,
  marginRight = 20,
  marginBottom = 20,
  marginLeft = 20
}) {
  const x = d3.scaleLinear([0, data.length - 1], [marginLeft, width - marginRight]);
  const y = d3.scaleLinear(d3.extent(data), [height - marginBottom, marginTop]);
  const line = d3.line((d, i) => x(i), y);
  return (
    <svg width={width} height={height}>
      <path fill="none" stroke="currentColor" strokeWidth="1.5" d={line(data)} />
      <g fill="white" stroke="currentColor" strokeWidth="1.5">
        {data.map((d, i) => (<circle key={i} cx={x(i)} cy={y(d)} r="2.5" />))}
      </g>
    </svg>
  );
}Sandbox ↗︎D3 modules that operate on selections (including d3-selection, d3-transition, and d3-axis) do manipulate the DOM, which competes with React’s virtual DOM. In those cases, you can attach a ref to an element and pass it to D3 in a useEffect hook.LinePlot.jsxjsximport * as d3 from "d3";
import {useRef, useEffect} from "react";

export default function LinePlot({
  data,
  width = 640,
  height = 400,
  marginTop = 20,
  marginRight = 20,
  marginBottom = 30,
  marginLeft = 40
}) {
  const gx = useRef();
  const gy = useRef();
  const x = d3.scaleLinear([0, data.length - 1], [marginLeft, width - marginRight]);
  const y = d3.scaleLinear(d3.extent(data), [height - marginBottom, marginTop]);
  const line = d3.line((d, i) => x(i), y);
  useEffect(() => void d3.select(gx.current).call(d3.axisBottom(x)), [gx, x]);
  useEffect(() => void d3.select(gy.current).call(d3.axisLeft(y)), [gy, y]);
  return (
    <svg width={width} height={height}>
      <g ref={gx} transform={`translate(0,${height - marginBottom})`} />
      <g ref={gy} transform={`translate(${marginLeft},0)`} />
      <path fill="none" stroke="currentColor" strokeWidth="1.5" d={line(data)} />
      <g fill="white" stroke="currentColor" strokeWidth="1.5">
        {data.map((d, i) => (<circle key={i} cx={x(i)} cy={y(d)} r="2.5" />))}
      </g>
    </svg>
  );
}Sandbox ↗︎For more guidance using D3 in React, see Amelia Wattenberger’s post.D3 in Svelte ​As with React, you can use Svelte exclusively for rendering if you like, and only use D3 modules that don’t manipulate the DOM. Here is a line plot of an array of numbers that uses d3-shape and d3-scale.LinePlot.sveltesvelte<script>
  import * as d3 from 'd3';

  export let data;
  export let width = 640;
  export let height = 400;
  export let marginTop = 20;
  export let marginRight = 20;
  export let marginBottom = 20;
  export let marginLeft = 20;

  $: x = d3.scaleLinear([0, data.length - 1], [marginLeft, width - marginRight]);
  $: y = d3.scaleLinear(d3.extent(data), [height - marginBottom, marginTop]);
  $: line = d3.line((d, i) => x(i), y);
</script>
<svg width={width} height={height}>
  <path fill="none" stroke="currentColor" stroke-width="1.5" d={line(data)} />
  <g fill="white" stroke="currentColor" stroke-width="1.5">
    {#each data as d, i}
      <circle key={i} cx={x(i)} cy={y(d)} r="2.5" />
    {/each}
  </g>
</svg>REPL ↗︎Svelte’s reactive statements ($:) pair nicely with D3 data joins for efficient updates. Below, we use them to render dynamic axes as the data changes.LinePlot.sveltesvelte<script>
  import * as d3 from 'd3';

  export let data;
  export let width = 640;
  export let height = 400;
  export let marginTop = 20;
  export let marginRight = 20;
  export let marginBottom = 30;
  export let marginLeft = 40;

  let gx;
  let gy;

  $: x = d3.scaleLinear([0, data.length - 1], [marginLeft, width - marginRight]);
  $: y = d3.scaleLinear(d3.extent(data), [height - marginBottom, marginTop]);
  $: line = d3.line((d, i) => x(i), y);
  $: d3.select(gy).call(d3.axisLeft(y));
  $: d3.select(gx).call(d3.axisBottom(x));
</script>
<svg width={width} height={height}>
  <g bind:this={gx} transform="translate(0,{height - marginBottom})" />
  <g bind:this={gy} transform="translate({marginLeft},0)" />
  <path fill="none" stroke="currentColor" stroke-width="1.5" d={line(data)} />
  <g fill="white" stroke="currentColor" stroke-width="1.5">
    {#each data as d, i}
      <circle key={i} cx={x(i)} cy={y(d)} r="2.5" />
    {/each}
  </g>
</svg>REPL ↗︎\n\n\n\nGetting started ​D3 works in any JavaScript environment.Try D3 online ​The fastest way to get started (and get help) with D3 is on Observable! D3 is available by default in notebooks as part of Observable’s standard library. To create something with D3, return the generated DOM element from a cell. Here is a blank chart to get you started:js{
  // Declare the chart dimensions and margins.
  const width = 640;
  const height = 400;
  const marginTop = 20;
  const marginRight = 20;
  const marginBottom = 30;
  const marginLeft = 40;

  // Declare the x (horizontal position) scale.
  const x = d3.scaleUtc()
      .domain([new Date("2023-01-01"), new Date("2024-01-01")])
      .range([marginLeft, width - marginRight]);

  // Declare the y (vertical position) scale.
  const y = d3.scaleLinear()
      .domain([0, 100])
      .range([height - marginBottom, marginTop]);

  // Create the SVG container.
  const svg = d3.create("svg")
      .attr("width", width)
      .attr("height", height);

  // Add the x-axis.
  svg.append("g")
      .attr("transform", `translate(0,${height - marginBottom})`)
      .call(d3.axisBottom(x));

  // Add the y-axis.
  svg.append("g")
      .attr("transform", `translate(${marginLeft},0)`)
      .call(d3.axisLeft(y));

  // Return the SVG element.
  return svg.node();
}As a more complete example, try one of these starter templates:Area chartBar chartDonut chartHistogramLine chartSee the D3 gallery for more forkable examples.Observable includes a few D3 snippets when you click + to add a cell (type “d3” when the cell menu is open to filter), as well as convenient sample datasets to try out D3 features. Or upload a CSV or JSON file to start playing with your data. You can also fork any of the hundreds of notebooks we’ve published for a head start.Observable is free for public use. Sign up for a Pro account to connect to private databases, collaborate on private notebooks, and more.D3 in vanilla HTML ​In vanilla HTML, you can load D3 from a CDN such as jsDelivr or you can download it locally. We recommend using the CDN-hosted ES module bundle. But for those who need it, we also provide a UMD bundle that exports the d3 global when loaded as a plain script.ESM + CDNUMD + CDNUMD + localhtml<!DOCTYPE html>
<div id="container"></div>
<script type="module">

import * as d3 from "https://cdn.jsdelivr.net/npm/d3@7/+esm";

// Declare the chart dimensions and margins.
const width = 640;
const height = 400;
const marginTop = 20;
const marginRight = 20;
const marginBottom = 30;
const marginLeft = 40;

// Declare the x (horizontal position) scale.
const x = d3.scaleUtc()
    .domain([new Date("2023-01-01"), new Date("2024-01-01")])
    .range([marginLeft, width - marginRight]);

// Declare the y (vertical position) scale.
const y = d3.scaleLinear()
    .domain([0, 100])
    .range([height - marginBottom, marginTop]);

// Create the SVG container.
const svg = d3.create("svg")
    .attr("width", width)
    .attr("height", height);

// Add the x-axis.
svg.append("g")
    .attr("transform", `translate(0,${height - marginBottom})`)
    .call(d3.axisBottom(x));

// Add the y-axis.
svg.append("g")
    .attr("transform", `translate(${marginLeft},0)`)
    .call(d3.axisLeft(y));

// Append the SVG element.
container.append(svg.node());

</script>html<!DOCTYPE html>
<div id="container"></div>
<script src="https://cdn.jsdelivr.net/npm/d3@7"></script>
<script type="module">

// Declare the chart dimensions and margins.
const width = 640;
const height = 400;
const marginTop = 20;
const marginRight = 20;
const marginBottom = 30;
const marginLeft = 40;

// Declare the x (horizontal position) scale.
const x = d3.scaleUtc()
    .domain([new Date("2023-01-01"), new Date("2024-01-01")])
    .range([marginLeft, width - marginRight]);

// Declare the y (vertical position) scale.
const y = d3.scaleLinear()
    .domain([0, 100])
    .range([height - marginBottom, marginTop]);

// Create the SVG container.
const svg = d3.create("svg")
    .attr("width", width)
    .attr("height", height);

// Add the x-axis.
svg.append("g")
    .attr("transform", `translate(0,${height - marginBottom})`)
    .call(d3.axisBottom(x));

// Add the y-axis.
svg.append("g")
    .attr("transform", `translate(${marginLeft},0)`)
    .call(d3.axisLeft(y));

// Append the SVG element.
container.append(svg.node());

</script>html<!DOCTYPE html>
<div id="container"></div>
<script src="d3.js"></script>
<script type="module">

// Declare the chart dimensions and margins.
const width = 640;
const height = 400;
const marginTop = 20;
const marginRight = 20;
const marginBottom = 30;
const marginLeft = 40;

// Declare the x (horizontal position) scale.
const x = d3.scaleUtc()
    .domain([new Date("2023-01-01"), new Date("2024-01-01")])
    .range([marginLeft, width - marginRight]);

// Declare the y (vertical position) scale.
const y = d3.scaleLinear()
    .domain([0, 100])
    .range([height - marginBottom, marginTop]);

// Create the SVG container.
const svg = d3.create("svg")
    .attr("width", width)
    .attr("height", height);

// Add the x-axis.
svg.append("g")
    .attr("transform", `translate(0,${height - marginBottom})`)
    .call(d3.axisBottom(x));

// Add the y-axis.
svg.append("g")
    .attr("transform", `translate(${marginLeft},0)`)
    .call(d3.axisLeft(y));

// Append the SVG element.
container.append(svg.node());

</script>You can also import and destructure individual D3 modules like so:html<script type="module">

import {forceSimulation, forceCollide, forceX} from "https://cdn.jsdelivr.net/npm/d3-force@3/+esm";

const nodes = [{}, {}];
const simulation = forceSimulation(nodes)
    .force("x", forceX())
    .force("collide", forceCollide(5))
    .on("tick", () => console.log(nodes[0].x));

</script>If you’d prefer to run D3 locally (or offline), you can download the UMD bundles of D3 here:d3.v7.jsd3.v7.min.jsThen, create an index.html file as shown above in the UMD + local tab. Use the non-minified bundle for debugging, and the minified bundle for faster performance in production.Installing from npm ​If you’re developing a web application using Node, you can install D3 via yarn, npm, pnpm, or your preferred package manager.yarnnpmpnpmbashyarn add d3bashnpm install d3bashpnpm add d3You can then load D3 into your app as:jsimport * as d3 from "d3";You can instead import specific symbols if you prefer:jsimport {select, selectAll} from "d3";Alternatively you can install and import from D3 submodules:jsimport {mean, median} from "d3-array";TypeScript declarations are available via DefinitelyTyped.D3 in React ​Most D3 modules (including d3-scale, d3-array, d3-interpolate, and d3-format) don’t interact with the DOM, so there is no difference when using them in React. You can use them in JSX for purely declarative visualization, such as the line plot below.LinePlot.jsxjsximport * as d3 from "d3";

export default function LinePlot({
  data,
  width = 640,
  height = 400,
  marginTop = 20,
  marginRight = 20,
  marginBottom = 20,
  marginLeft = 20
}) {
  const x = d3.scaleLinear([0, data.length - 1], [marginLeft, width - marginRight]);
  const y = d3.scaleLinear(d3.extent(data), [height - marginBottom, marginTop]);
  const line = d3.line((d, i) => x(i), y);
  return (
    <svg width={width} height={height}>
      <path fill="none" stroke="currentColor" strokeWidth="1.5" d={line(data)} />
      <g fill="white" stroke="currentColor" strokeWidth="1.5">
        {data.map((d, i) => (<circle key={i} cx={x(i)} cy={y(d)} r="2.5" />))}
      </g>
    </svg>
  );
}Sandbox ↗︎D3 modules that operate on selections (including d3-selection, d3-transition, and d3-axis) do manipulate the DOM, which competes with React’s virtual DOM. In those cases, you can attach a ref to an element and pass it to D3 in a useEffect hook.LinePlot.jsxjsximport * as d3 from "d3";
import {useRef, useEffect} from "react";

export default function LinePlot({
  data,
  width = 640,
  height = 400,
  marginTop = 20,
  marginRight = 20,
  marginBottom = 30,
  marginLeft = 40
}) {
  const gx = useRef();
  const gy = useRef();
  const x = d3.scaleLinear([0, data.length - 1], [marginLeft, width - marginRight]);
  const y = d3.scaleLinear(d3.extent(data), [height - marginBottom, marginTop]);
  const line = d3.line((d, i) => x(i), y);
  useEffect(() => void d3.select(gx.current).call(d3.axisBottom(x)), [gx, x]);
  useEffect(() => void d3.select(gy.current).call(d3.axisLeft(y)), [gy, y]);
  return (
    <svg width={width} height={height}>
      <g ref={gx} transform={`translate(0,${height - marginBottom})`} />
      <g ref={gy} transform={`translate(${marginLeft},0)`} />
      <path fill="none" stroke="currentColor" strokeWidth="1.5" d={line(data)} />
      <g fill="white" stroke="currentColor" strokeWidth="1.5">
        {data.map((d, i) => (<circle key={i} cx={x(i)} cy={y(d)} r="2.5" />))}
      </g>
    </svg>
  );
}Sandbox ↗︎For more guidance using D3 in React, see Amelia Wattenberger’s post.D3 in Svelte ​As with React, you can use Svelte exclusively for rendering if you like, and only use D3 modules that don’t manipulate the DOM. Here is a line plot of an array of numbers that uses d3-shape and d3-scale.LinePlot.sveltesvelte<script>
  import * as d3 from 'd3';

  export let data;
  export let width = 640;
  export let height = 400;
  export let marginTop = 20;
  export let marginRight = 20;
  export let marginBottom = 20;
  export let marginLeft = 20;

  $: x = d3.scaleLinear([0, data.length - 1], [marginLeft, width - marginRight]);
  $: y = d3.scaleLinear(d3.extent(data), [height - marginBottom, marginTop]);
  $: line = d3.line((d, i) => x(i), y);
</script>
<svg width={width} height={height}>
  <path fill="none" stroke="currentColor" stroke-width="1.5" d={line(data)} />
  <g fill="white" stroke="currentColor" stroke-width="1.5">
    {#each data as d, i}
      <circle key={i} cx={x(i)} cy={y(d)} r="2.5" />
    {/each}
  </g>
</svg>REPL ↗︎Svelte’s reactive statements ($:) pair nicely with D3 data joins for efficient updates. Below, we use them to render dynamic axes as the data changes.LinePlot.sveltesvelte<script>
  import * as d3 from 'd3';

  export let data;
  export let width = 640;
  export let height = 400;
  export let marginTop = 20;
  export let marginRight = 20;
  export let marginBottom = 30;
  export let marginLeft = 40;

  let gx;
  let gy;

  $: x = d3.scaleLinear([0, data.length - 1], [marginLeft, width - marginRight]);
  $: y = d3.scaleLinear(d3.extent(data), [height - marginBottom, marginTop]);
  $: line = d3.line((d, i) => x(i), y);
  $: d3.select(gy).call(d3.axisLeft(y));
  $: d3.select(gx).call(d3.axisBottom(x));
</script>
<svg width={width} height={height}>
  <g bind:this={gx} transform="translate(0,{height - marginBottom})" />
  <g bind:this={gy} transform="translate({marginLeft},0)" />
  <path fill="none" stroke="currentColor" stroke-width="1.5" d={line(data)} />
  <g fill="white" stroke="currentColor" stroke-width="1.5">
    {#each data as d, i}
      <circle key={i} cx={x(i)} cy={y(d)} r="2.5" />
    {/each}
  </g>
</svg>REPL ↗︎\n\nSearchK7.9.0GitHub️ 110.0kOn this pageGetting started ​D3 works in any JavaScript environment.Try D3 online ​The fastest way to get started (and get help) with D3 is on Observable! D3 is available by default in notebooks as part of Observable’s standard library. To create something with D3, return the generated DOM element from a cell. Here is a blank chart to get you started:js{
  // Declare the chart dimensions and margins.
  const width = 640;
  const height = 400;
  const marginTop = 20;
  const marginRight = 20;
  const marginBottom = 30;
  const marginLeft = 40;

  // Declare the x (horizontal position) scale.
  const x = d3.scaleUtc()
      .domain([new Date("2023-01-01"), new Date("2024-01-01")])
      .range([marginLeft, width - marginRight]);

  // Declare the y (vertical position) scale.
  const y = d3.scaleLinear()
      .domain([0, 100])
      .range([height - marginBottom, marginTop]);

  // Create the SVG container.
  const svg = d3.create("svg")
      .attr("width", width)
      .attr("height", height);

  // Add the x-axis.
  svg.append("g")
      .attr("transform", `translate(0,${height - marginBottom})`)
      .call(d3.axisBottom(x));

  // Add the y-axis.
  svg.append("g")
      .attr("transform", `translate(${marginLeft},0)`)
      .call(d3.axisLeft(y));

  // Return the SVG element.
  return svg.node();
}As a more complete example, try one of these starter templates:Area chartBar chartDonut chartHistogramLine chartSee the D3 gallery for more forkable examples.Observable includes a few D3 snippets when you click + to add a cell (type “d3” when the cell menu is open to filter), as well as convenient sample datasets to try out D3 features. Or upload a CSV or JSON file to start playing with your data. You can also fork any of the hundreds of notebooks we’ve published for a head start.Observable is free for public use. Sign up for a Pro account to connect to private databases, collaborate on private notebooks, and more.D3 in vanilla HTML ​In vanilla HTML, you can load D3 from a CDN such as jsDelivr or you can download it locally. We recommend using the CDN-hosted ES module bundle. But for those who need it, we also provide a UMD bundle that exports the d3 global when loaded as a plain script.ESM + CDNUMD + CDNUMD + localhtml<!DOCTYPE html>
<div id="container"></div>
<script type="module">

import * as d3 from "https://cdn.jsdelivr.net/npm/d3@7/+esm";

// Declare the chart dimensions and margins.
const width = 640;
const height = 400;
const marginTop = 20;
const marginRight = 20;
const marginBottom = 30;
const marginLeft = 40;

// Declare the x (horizontal position) scale.
const x = d3.scaleUtc()
    .domain([new Date("2023-01-01"), new Date("2024-01-01")])
    .range([marginLeft, width - marginRight]);

// Declare the y (vertical position) scale.
const y = d3.scaleLinear()
    .domain([0, 100])
    .range([height - marginBottom, marginTop]);

// Create the SVG container.
const svg = d3.create("svg")
    .attr("width", width)
    .attr("height", height);

// Add the x-axis.
svg.append("g")
    .attr("transform", `translate(0,${height - marginBottom})`)
    .call(d3.axisBottom(x));

// Add the y-axis.
svg.append("g")
    .attr("transform", `translate(${marginLeft},0)`)
    .call(d3.axisLeft(y));

// Append the SVG element.
container.append(svg.node());

</script>html<!DOCTYPE html>
<div id="container"></div>
<script src="https://cdn.jsdelivr.net/npm/d3@7"></script>
<script type="module">

// Declare the chart dimensions and margins.
const width = 640;
const height = 400;
const marginTop = 20;
const marginRight = 20;
const marginBottom = 30;
const marginLeft = 40;

// Declare the x (horizontal position) scale.
const x = d3.scaleUtc()
    .domain([new Date("2023-01-01"), new Date("2024-01-01")])
    .range([marginLeft, width - marginRight]);

// Declare the y (vertical position) scale.
const y = d3.scaleLinear()
    .domain([0, 100])
    .range([height - marginBottom, marginTop]);

// Create the SVG container.
const svg = d3.create("svg")
    .attr("width", width)
    .attr("height", height);

// Add the x-axis.
svg.append("g")
    .attr("transform", `translate(0,${height - marginBottom})`)
    .call(d3.axisBottom(x));

// Add the y-axis.
svg.append("g")
    .attr("transform", `translate(${marginLeft},0)`)
    .call(d3.axisLeft(y));

// Append the SVG element.
container.append(svg.node());

</script>html<!DOCTYPE html>
<div id="container"></div>
<script src="d3.js"></script>
<script type="module">

// Declare the chart dimensions and margins.
const width = 640;
const height = 400;
const marginTop = 20;
const marginRight = 20;
const marginBottom = 30;
const marginLeft = 40;

// Declare the x (horizontal position) scale.
const x = d3.scaleUtc()
    .domain([new Date("2023-01-01"), new Date("2024-01-01")])
    .range([marginLeft, width - marginRight]);

// Declare the y (vertical position) scale.
const y = d3.scaleLinear()
    .domain([0, 100])
    .range([height - marginBottom, marginTop]);

// Create the SVG container.
const svg = d3.create("svg")
    .attr("width", width)
    .attr("height", height);

// Add the x-axis.
svg.append("g")
    .attr("transform", `translate(0,${height - marginBottom})`)
    .call(d3.axisBottom(x));

// Add the y-axis.
svg.append("g")
    .attr("transform", `translate(${marginLeft},0)`)
    .call(d3.axisLeft(y));

// Append the SVG element.
container.append(svg.node());

</script>You can also import and destructure individual D3 modules like so:html<script type="module">

import {forceSimulation, forceCollide, forceX} from "https://cdn.jsdelivr.net/npm/d3-force@3/+esm";

const nodes = [{}, {}];
const simulation = forceSimulation(nodes)
    .force("x", forceX())
    .force("collide", forceCollide(5))
    .on("tick", () => console.log(nodes[0].x));

</script>If you’d prefer to run D3 locally (or offline), you can download the UMD bundles of D3 here:d3.v7.jsd3.v7.min.jsThen, create an index.html file as shown above in the UMD + local tab. Use the non-minified bundle for debugging, and the minified bundle for faster performance in production.Installing from npm ​If you’re developing a web application using Node, you can install D3 via yarn, npm, pnpm, or your preferred package manager.yarnnpmpnpmbashyarn add d3bashnpm install d3bashpnpm add d3You can then load D3 into your app as:jsimport * as d3 from "d3";You can instead import specific symbols if you prefer:jsimport {select, selectAll} from "d3";Alternatively you can install and import from D3 submodules:jsimport {mean, median} from "d3-array";TypeScript declarations are available via DefinitelyTyped.D3 in React ​Most D3 modules (including d3-scale, d3-array, d3-interpolate, and d3-format) don’t interact with the DOM, so there is no difference when using them in React. You can use them in JSX for purely declarative visualization, such as the line plot below.LinePlot.jsxjsximport * as d3 from "d3";

export default function LinePlot({
  data,
  width = 640,
  height = 400,
  marginTop = 20,
  marginRight = 20,
  marginBottom = 20,
  marginLeft = 20
}) {
  const x = d3.scaleLinear([0, data.length - 1], [marginLeft, width - marginRight]);
  const y = d3.scaleLinear(d3.extent(data), [height - marginBottom, marginTop]);
  const line = d3.line((d, i) => x(i), y);
  return (
    <svg width={width} height={height}>
      <path fill="none" stroke="currentColor" strokeWidth="1.5" d={line(data)} />
      <g fill="white" stroke="currentColor" strokeWidth="1.5">
        {data.map((d, i) => (<circle key={i} cx={x(i)} cy={y(d)} r="2.5" />))}
      </g>
    </svg>
  );
}Sandbox ↗︎D3 modules that operate on selections (including d3-selection, d3-transition, and d3-axis) do manipulate the DOM, which competes with React’s virtual DOM. In those cases, you can attach a ref to an element and pass it to D3 in a useEffect hook.LinePlot.jsxjsximport * as d3 from "d3";
import {useRef, useEffect} from "react";

export default function LinePlot({
  data,
  width = 640,
  height = 400,
  marginTop = 20,
  marginRight = 20,
  marginBottom = 30,
  marginLeft = 40
}) {
  const gx = useRef();
  const gy = useRef();
  const x = d3.scaleLinear([0, data.length - 1], [marginLeft, width - marginRight]);
  const y = d3.scaleLinear(d3.extent(data), [height - marginBottom, marginTop]);
  const line = d3.line((d, i) => x(i), y);
  useEffect(() => void d3.select(gx.current).call(d3.axisBottom(x)), [gx, x]);
  useEffect(() => void d3.select(gy.current).call(d3.axisLeft(y)), [gy, y]);
  return (
    <svg width={width} height={height}>
      <g ref={gx} transform={`translate(0,${height - marginBottom})`} />
      <g ref={gy} transform={`translate(${marginLeft},0)`} />
      <path fill="none" stroke="currentColor" strokeWidth="1.5" d={line(data)} />
      <g fill="white" stroke="currentColor" strokeWidth="1.5">
        {data.map((d, i) => (<circle key={i} cx={x(i)} cy={y(d)} r="2.5" />))}
      </g>
    </svg>
  );
}Sandbox ↗︎For more guidance using D3 in React, see Amelia Wattenberger’s post.D3 in Svelte ​As with React, you can use Svelte exclusively for rendering if you like, and only use D3 modules that don’t manipulate the DOM. Here is a line plot of an array of numbers that uses d3-shape and d3-scale.LinePlot.sveltesvelte<script>
  import * as d3 from 'd3';

  export let data;
  export let width = 640;
  export let height = 400;
  export let marginTop = 20;
  export let marginRight = 20;
  export let marginBottom = 20;
  export let marginLeft = 20;

  $: x = d3.scaleLinear([0, data.length - 1], [marginLeft, width - marginRight]);
  $: y = d3.scaleLinear(d3.extent(data), [height - marginBottom, marginTop]);
  $: line = d3.line((d, i) => x(i), y);
</script>
<svg width={width} height={height}>
  <path fill="none" stroke="currentColor" stroke-width="1.5" d={line(data)} />
  <g fill="white" stroke="currentColor" stroke-width="1.5">
    {#each data as d, i}
      <circle key={i} cx={x(i)} cy={y(d)} r="2.5" />
    {/each}
  </g>
</svg>REPL ↗︎Svelte’s reactive statements ($:) pair nicely with D3 data joins for efficient updates. Below, we use them to render dynamic axes as the data changes.LinePlot.sveltesvelte<script>
  import * as d3 from 'd3';

  export let data;
  export let width = 640;
  export let height = 400;
  export let marginTop = 20;
  export let marginRight = 20;
  export let marginBottom = 30;
  export let marginLeft = 40;

  let gx;
  let gy;

  $: x = d3.scaleLinear([0, data.length - 1], [marginLeft, width - marginRight]);
  $: y = d3.scaleLinear(d3.extent(data), [height - marginBottom, marginTop]);
  $: line = d3.line((d, i) => x(i), y);
  $: d3.select(gy).call(d3.axisLeft(y));
  $: d3.select(gx).call(d3.axisBottom(x));
</script>
<svg width={width} height={height}>
  <g bind:this={gx} transform="translate(0,{height - marginBottom})" />
  <g bind:this={gy} transform="translate({marginLeft},0)" />
  <path fill="none" stroke="currentColor" stroke-width="1.5" d={line(data)} />
  <g fill="white" stroke="currentColor" stroke-width="1.5">
    {#each data as d, i}
      <circle key={i} cx={x(i)} cy={y(d)} r="2.5" />
    {/each}
  </g>
</svg>REPL ↗︎PagerPrevious pageWhat is D3?Next pageAPI index\n\nGetting started ​D3 works in any JavaScript environment.Try D3 online ​The fastest way to get started (and get help) with D3 is on Observable! D3 is available by default in notebooks as part of Observable’s standard library. To create something with D3, return the generated DOM element from a cell. Here is a blank chart to get you started:js{
  // Declare the chart dimensions and margins.
  const width = 640;
  const height = 400;
  const marginTop = 20;
  const marginRight = 20;
  const marginBottom = 30;
  const marginLeft = 40;

  // Declare the x (horizontal position) scale.
  const x = d3.scaleUtc()
      .domain([new Date("2023-01-01"), new Date("2024-01-01")])
      .range([marginLeft, width - marginRight]);

  // Declare the y (vertical position) scale.
  const y = d3.scaleLinear()
      .domain([0, 100])
      .range([height - marginBottom, marginTop]);

  // Create the SVG container.
  const svg = d3.create("svg")
      .attr("width", width)
      .attr("height", height);

  // Add the x-axis.
  svg.append("g")
      .attr("transform", `translate(0,${height - marginBottom})`)
      .call(d3.axisBottom(x));

  // Add the y-axis.
  svg.append("g")
      .attr("transform", `translate(${marginLeft},0)`)
      .call(d3.axisLeft(y));

  // Return the SVG element.
  return svg.node();
}As a more complete example, try one of these starter templates:Area chartBar chartDonut chartHistogramLine chartSee the D3 gallery for more forkable examples.Observable includes a few D3 snippets when you click + to add a cell (type “d3” when the cell menu is open to filter), as well as convenient sample datasets to try out D3 features. Or upload a CSV or JSON file to start playing with your data. You can also fork any of the hundreds of notebooks we’ve published for a head start.Observable is free for public use. Sign up for a Pro account to connect to private databases, collaborate on private notebooks, and more.D3 in vanilla HTML ​In vanilla HTML, you can load D3 from a CDN such as jsDelivr or you can download it locally. We recommend using the CDN-hosted ES module bundle. But for those who need it, we also provide a UMD bundle that exports the d3 global when loaded as a plain script.ESM + CDNUMD + CDNUMD + localhtml<!DOCTYPE html>
<div id="container"></div>
<script type="module">

import * as d3 from "https://cdn.jsdelivr.net/npm/d3@7/+esm";

// Declare the chart dimensions and margins.
const width = 640;
const height = 400;
const marginTop = 20;
const marginRight = 20;
const marginBottom = 30;
const marginLeft = 40;

// Declare the x (horizontal position) scale.
const x = d3.scaleUtc()
    .domain([new Date("2023-01-01"), new Date("2024-01-01")])
    .range([marginLeft, width - marginRight]);

// Declare the y (vertical position) scale.
const y = d3.scaleLinear()
    .domain([0, 100])
    .range([height - marginBottom, marginTop]);

// Create the SVG container.
const svg = d3.create("svg")
    .attr("width", width)
    .attr("height", height);

// Add the x-axis.
svg.append("g")
    .attr("transform", `translate(0,${height - marginBottom})`)
    .call(d3.axisBottom(x));

// Add the y-axis.
svg.append("g")
    .attr("transform", `translate(${marginLeft},0)`)
    .call(d3.axisLeft(y));

// Append the SVG element.
container.append(svg.node());

</script>html<!DOCTYPE html>
<div id="container"></div>
<script src="https://cdn.jsdelivr.net/npm/d3@7"></script>
<script type="module">

// Declare the chart dimensions and margins.
const width = 640;
const height = 400;
const marginTop = 20;
const marginRight = 20;
const marginBottom = 30;
const marginLeft = 40;

// Declare the x (horizontal position) scale.
const x = d3.scaleUtc()
    .domain([new Date("2023-01-01"), new Date("2024-01-01")])
    .range([marginLeft, width - marginRight]);

// Declare the y (vertical position) scale.
const y = d3.scaleLinear()
    .domain([0, 100])
    .range([height - marginBottom, marginTop]);

// Create the SVG container.
const svg = d3.create("svg")
    .attr("width", width)
    .attr("height", height);

// Add the x-axis.
svg.append("g")
    .attr("transform", `translate(0,${height - marginBottom})`)
    .call(d3.axisBottom(x));

// Add the y-axis.
svg.append("g")
    .attr("transform", `translate(${marginLeft},0)`)
    .call(d3.axisLeft(y));

// Append the SVG element.
container.append(svg.node());

</script>html<!DOCTYPE html>
<div id="container"></div>
<script src="d3.js"></script>
<script type="module">

// Declare the chart dimensions and margins.
const width = 640;
const height = 400;
const marginTop = 20;
const marginRight = 20;
const marginBottom = 30;
const marginLeft = 40;

// Declare the x (horizontal position) scale.
const x = d3.scaleUtc()
    .domain([new Date("2023-01-01"), new Date("2024-01-01")])
    .range([marginLeft, width - marginRight]);

// Declare the y (vertical position) scale.
const y = d3.scaleLinear()
    .domain([0, 100])
    .range([height - marginBottom, marginTop]);

// Create the SVG container.
const svg = d3.create("svg")
    .attr("width", width)
    .attr("height", height);

// Add the x-axis.
svg.append("g")
    .attr("transform", `translate(0,${height - marginBottom})`)
    .call(d3.axisBottom(x));

// Add the y-axis.
svg.append("g")
    .attr("transform", `translate(${marginLeft},0)`)
    .call(d3.axisLeft(y));

// Append the SVG element.
container.append(svg.node());

</script>You can also import and destructure individual D3 modules like so:html<script type="module">

import {forceSimulation, forceCollide, forceX} from "https://cdn.jsdelivr.net/npm/d3-force@3/+esm";

const nodes = [{}, {}];
const simulation = forceSimulation(nodes)
    .force("x", forceX())
    .force("collide", forceCollide(5))
    .on("tick", () => console.log(nodes[0].x));

</script>If you’d prefer to run D3 locally (or offline), you can download the UMD bundles of D3 here:d3.v7.jsd3.v7.min.jsThen, create an index.html file as shown above in the UMD + local tab. Use the non-minified bundle for debugging, and the minified bundle for faster performance in production.Installing from npm ​If you’re developing a web application using Node, you can install D3 via yarn, npm, pnpm, or your preferred package manager.yarnnpmpnpmbashyarn add d3bashnpm install d3bashpnpm add d3You can then load D3 into your app as:jsimport * as d3 from "d3";You can instead import specific symbols if you prefer:jsimport {select, selectAll} from "d3";Alternatively you can install and import from D3 submodules:jsimport {mean, median} from "d3-array";TypeScript declarations are available via DefinitelyTyped.D3 in React ​Most D3 modules (including d3-scale, d3-array, d3-interpolate, and d3-format) don’t interact with the DOM, so there is no difference when using them in React. You can use them in JSX for purely declarative visualization, such as the line plot below.LinePlot.jsxjsximport * as d3 from "d3";

export default function LinePlot({
  data,
  width = 640,
  height = 400,
  marginTop = 20,
  marginRight = 20,
  marginBottom = 20,
  marginLeft = 20
}) {
  const x = d3.scaleLinear([0, data.length - 1], [marginLeft, width - marginRight]);
  const y = d3.scaleLinear(d3.extent(data), [height - marginBottom, marginTop]);
  const line = d3.line((d, i) => x(i), y);
  return (
    <svg width={width} height={height}>
      <path fill="none" stroke="currentColor" strokeWidth="1.5" d={line(data)} />
      <g fill="white" stroke="currentColor" strokeWidth="1.5">
        {data.map((d, i) => (<circle key={i} cx={x(i)} cy={y(d)} r="2.5" />))}
      </g>
    </svg>
  );
}Sandbox ↗︎D3 modules that operate on selections (including d3-selection, d3-transition, and d3-axis) do manipulate the DOM, which competes with React’s virtual DOM. In those cases, you can attach a ref to an element and pass it to D3 in a useEffect hook.LinePlot.jsxjsximport * as d3 from "d3";
import {useRef, useEffect} from "react";

export default function LinePlot({
  data,
  width = 640,
  height = 400,
  marginTop = 20,
  marginRight = 20,
  marginBottom = 30,
  marginLeft = 40
}) {
  const gx = useRef();
  const gy = useRef();
  const x = d3.scaleLinear([0, data.length - 1], [marginLeft, width - marginRight]);
  const y = d3.scaleLinear(d3.extent(data), [height - marginBottom, marginTop]);
  const line = d3.line((d, i) => x(i), y);
  useEffect(() => void d3.select(gx.current).call(d3.axisBottom(x)), [gx, x]);
  useEffect(() => void d3.select(gy.current).call(d3.axisLeft(y)), [gy, y]);
  return (
    <svg width={width} height={height}>
      <g ref={gx} transform={`translate(0,${height - marginBottom})`} />
      <g ref={gy} transform={`translate(${marginLeft},0)`} />
      <path fill="none" stroke="currentColor" strokeWidth="1.5" d={line(data)} />
      <g fill="white" stroke="currentColor" strokeWidth="1.5">
        {data.map((d, i) => (<circle key={i} cx={x(i)} cy={y(d)} r="2.5" />))}
      </g>
    </svg>
  );
}Sandbox ↗︎For more guidance using D3 in React, see Amelia Wattenberger’s post.D3 in Svelte ​As with React, you can use Svelte exclusively for rendering if you like, and only use D3 modules that don’t manipulate the DOM. Here is a line plot of an array of numbers that uses d3-shape and d3-scale.LinePlot.sveltesvelte<script>
  import * as d3 from 'd3';

  export let data;
  export let width = 640;
  export let height = 400;
  export let marginTop = 20;
  export let marginRight = 20;
  export let marginBottom = 20;
  export let marginLeft = 20;

  $: x = d3.scaleLinear([0, data.length - 1], [marginLeft, width - marginRight]);
  $: y = d3.scaleLinear(d3.extent(data), [height - marginBottom, marginTop]);
  $: line = d3.line((d, i) => x(i), y);
</script>
<svg width={width} height={height}>
  <path fill="none" stroke="currentColor" stroke-width="1.5" d={line(data)} />
  <g fill="white" stroke="currentColor" stroke-width="1.5">
    {#each data as d, i}
      <circle key={i} cx={x(i)} cy={y(d)} r="2.5" />
    {/each}
  </g>
</svg>REPL ↗︎Svelte’s reactive statements ($:) pair nicely with D3 data joins for efficient updates. Below, we use them to render dynamic axes as the data changes.LinePlot.sveltesvelte<script>
  import * as d3 from 'd3';

  export let data;
  export let width = 640;
  export let height = 400;
  export let marginTop = 20;
  export let marginRight = 20;
  export let marginBottom = 30;
  export let marginLeft = 40;

  let gx;
  let gy;

  $: x = d3.scaleLinear([0, data.length - 1], [marginLeft, width - marginRight]);
  $: y = d3.scaleLinear(d3.extent(data), [height - marginBottom, marginTop]);
  $: line = d3.line((d, i) => x(i), y);
  $: d3.select(gy).call(d3.axisLeft(y));
  $: d3.select(gx).call(d3.axisBottom(x));
</script>
<svg width={width} height={height}>
  <g bind:this={gx} transform="translate(0,{height - marginBottom})" />
  <g bind:this={gy} transform="translate({marginLeft},0)" />
  <path fill="none" stroke="currentColor" stroke-width="1.5" d={line(data)} />
  <g fill="white" stroke="currentColor" stroke-width="1.5">
    {#each data as d, i}
      <circle key={i} cx={x(i)} cy={y(d)} r="2.5" />
    {/each}
  </g>
</svg>REPL ↗︎\n\n\n\nGetting started ​D3 works in any JavaScript environment.Try D3 online ​The fastest way to get started (and get help) with D3 is on Observable! D3 is available by default in notebooks as part of Observable’s standard library. To create something with D3, return the generated DOM element from a cell. Here is a blank chart to get you started:js{
  // Declare the chart dimensions and margins.
  const width = 640;
  const height = 400;
  const marginTop = 20;
  const marginRight = 20;
  const marginBottom = 30;
  const marginLeft = 40;

  // Declare the x (horizontal position) scale.
  const x = d3.scaleUtc()
      .domain([new Date("2023-01-01"), new Date("2024-01-01")])
      .range([marginLeft, width - marginRight]);

  // Declare the y (vertical position) scale.
  const y = d3.scaleLinear()
      .domain([0, 100])
      .range([height - marginBottom, marginTop]);

  // Create the SVG container.
  const svg = d3.create("svg")
      .attr("width", width)
      .attr("height", height);

  // Add the x-axis.
  svg.append("g")
      .attr("transform", `translate(0,${height - marginBottom})`)
      .call(d3.axisBottom(x));

  // Add the y-axis.
  svg.append("g")
      .attr("transform", `translate(${marginLeft},0)`)
      .call(d3.axisLeft(y));

  // Return the SVG element.
  return svg.node();
}As a more complete example, try one of these starter templates:Area chartBar chartDonut chartHistogramLine chartSee the D3 gallery for more forkable examples.Observable includes a few D3 snippets when you click + to add a cell (type “d3” when the cell menu is open to filter), as well as convenient sample datasets to try out D3 features. Or upload a CSV or JSON file to start playing with your data. You can also fork any of the hundreds of notebooks we’ve published for a head start.Observable is free for public use. Sign up for a Pro account to connect to private databases, collaborate on private notebooks, and more.D3 in vanilla HTML ​In vanilla HTML, you can load D3 from a CDN such as jsDelivr or you can download it locally. We recommend using the CDN-hosted ES module bundle. But for those who need it, we also provide a UMD bundle that exports the d3 global when loaded as a plain script.ESM + CDNUMD + CDNUMD + localhtml<!DOCTYPE html>
<div id="container"></div>
<script type="module">

import * as d3 from "https://cdn.jsdelivr.net/npm/d3@7/+esm";

// Declare the chart dimensions and margins.
const width = 640;
const height = 400;
const marginTop = 20;
const marginRight = 20;
const marginBottom = 30;
const marginLeft = 40;

// Declare the x (horizontal position) scale.
const x = d3.scaleUtc()
    .domain([new Date("2023-01-01"), new Date("2024-01-01")])
    .range([marginLeft, width - marginRight]);

// Declare the y (vertical position) scale.
const y = d3.scaleLinear()
    .domain([0, 100])
    .range([height - marginBottom, marginTop]);

// Create the SVG container.
const svg = d3.create("svg")
    .attr("width", width)
    .attr("height", height);

// Add the x-axis.
svg.append("g")
    .attr("transform", `translate(0,${height - marginBottom})`)
    .call(d3.axisBottom(x));

// Add the y-axis.
svg.append("g")
    .attr("transform", `translate(${marginLeft},0)`)
    .call(d3.axisLeft(y));

// Append the SVG element.
container.append(svg.node());

</script>html<!DOCTYPE html>
<div id="container"></div>
<script src="https://cdn.jsdelivr.net/npm/d3@7"></script>
<script type="module">

// Declare the chart dimensions and margins.
const width = 640;
const height = 400;
const marginTop = 20;
const marginRight = 20;
const marginBottom = 30;
const marginLeft = 40;

// Declare the x (horizontal position) scale.
const x = d3.scaleUtc()
    .domain([new Date("2023-01-01"), new Date("2024-01-01")])
    .range([marginLeft, width - marginRight]);

// Declare the y (vertical position) scale.
const y = d3.scaleLinear()
    .domain([0, 100])
    .range([height - marginBottom, marginTop]);

// Create the SVG container.
const svg = d3.create("svg")
    .attr("width", width)
    .attr("height", height);

// Add the x-axis.
svg.append("g")
    .attr("transform", `translate(0,${height - marginBottom})`)
    .call(d3.axisBottom(x));

// Add the y-axis.
svg.append("g")
    .attr("transform", `translate(${marginLeft},0)`)
    .call(d3.axisLeft(y));

// Append the SVG element.
container.append(svg.node());

</script>html<!DOCTYPE html>
<div id="container"></div>
<script src="d3.js"></script>
<script type="module">

// Declare the chart dimensions and margins.
const width = 640;
const height = 400;
const marginTop = 20;
const marginRight = 20;
const marginBottom = 30;
const marginLeft = 40;

// Declare the x (horizontal position) scale.
const x = d3.scaleUtc()
    .domain([new Date("2023-01-01"), new Date("2024-01-01")])
    .range([marginLeft, width - marginRight]);

// Declare the y (vertical position) scale.
const y = d3.scaleLinear()
    .domain([0, 100])
    .range([height - marginBottom, marginTop]);

// Create the SVG container.
const svg = d3.create("svg")
    .attr("width", width)
    .attr("height", height);

// Add the x-axis.
svg.append("g")
    .attr("transform", `translate(0,${height - marginBottom})`)
    .call(d3.axisBottom(x));

// Add the y-axis.
svg.append("g")
    .attr("transform", `translate(${marginLeft},0)`)
    .call(d3.axisLeft(y));

// Append the SVG element.
container.append(svg.node());

</script>You can also import and destructure individual D3 modules like so:html<script type="module">

import {forceSimulation, forceCollide, forceX} from "https://cdn.jsdelivr.net/npm/d3-force@3/+esm";

const nodes = [{}, {}];
const simulation = forceSimulation(nodes)
    .force("x", forceX())
    .force("collide", forceCollide(5))
    .on("tick", () => console.log(nodes[0].x));

</script>If you’d prefer to run D3 locally (or offline), you can download the UMD bundles of D3 here:d3.v7.jsd3.v7.min.jsThen, create an index.html file as shown above in the UMD + local tab. Use the non-minified bundle for debugging, and the minified bundle for faster performance in production.Installing from npm ​If you’re developing a web application using Node, you can install D3 via yarn, npm, pnpm, or your preferred package manager.yarnnpmpnpmbashyarn add d3bashnpm install d3bashpnpm add d3You can then load D3 into your app as:jsimport * as d3 from "d3";You can instead import specific symbols if you prefer:jsimport {select, selectAll} from "d3";Alternatively you can install and import from D3 submodules:jsimport {mean, median} from "d3-array";TypeScript declarations are available via DefinitelyTyped.D3 in React ​Most D3 modules (including d3-scale, d3-array, d3-interpolate, and d3-format) don’t interact with the DOM, so there is no difference when using them in React. You can use them in JSX for purely declarative visualization, such as the line plot below.LinePlot.jsxjsximport * as d3 from "d3";

export default function LinePlot({
  data,
  width = 640,
  height = 400,
  marginTop = 20,
  marginRight = 20,
  marginBottom = 20,
  marginLeft = 20
}) {
  const x = d3.scaleLinear([0, data.length - 1], [marginLeft, width - marginRight]);
  const y = d3.scaleLinear(d3.extent(data), [height - marginBottom, marginTop]);
  const line = d3.line((d, i) => x(i), y);
  return (
    <svg width={width} height={height}>
      <path fill="none" stroke="currentColor" strokeWidth="1.5" d={line(data)} />
      <g fill="white" stroke="currentColor" strokeWidth="1.5">
        {data.map((d, i) => (<circle key={i} cx={x(i)} cy={y(d)} r="2.5" />))}
      </g>
    </svg>
  );
}Sandbox ↗︎D3 modules that operate on selections (including d3-selection, d3-transition, and d3-axis) do manipulate the DOM, which competes with React’s virtual DOM. In those cases, you can attach a ref to an element and pass it to D3 in a useEffect hook.LinePlot.jsxjsximport * as d3 from "d3";
import {useRef, useEffect} from "react";

export default function LinePlot({
  data,
  width = 640,
  height = 400,
  marginTop = 20,
  marginRight = 20,
  marginBottom = 30,
  marginLeft = 40
}) {
  const gx = useRef();
  const gy = useRef();
  const x = d3.scaleLinear([0, data.length - 1], [marginLeft, width - marginRight]);
  const y = d3.scaleLinear(d3.extent(data), [height - marginBottom, marginTop]);
  const line = d3.line((d, i) => x(i), y);
  useEffect(() => void d3.select(gx.current).call(d3.axisBottom(x)), [gx, x]);
  useEffect(() => void d3.select(gy.current).call(d3.axisLeft(y)), [gy, y]);
  return (
    <svg width={width} height={height}>
      <g ref={gx} transform={`translate(0,${height - marginBottom})`} />
      <g ref={gy} transform={`translate(${marginLeft},0)`} />
      <path fill="none" stroke="currentColor" strokeWidth="1.5" d={line(data)} />
      <g fill="white" stroke="currentColor" strokeWidth="1.5">
        {data.map((d, i) => (<circle key={i} cx={x(i)} cy={y(d)} r="2.5" />))}
      </g>
    </svg>
  );
}Sandbox ↗︎For more guidance using D3 in React, see Amelia Wattenberger’s post.D3 in Svelte ​As with React, you can use Svelte exclusively for rendering if you like, and only use D3 modules that don’t manipulate the DOM. Here is a line plot of an array of numbers that uses d3-shape and d3-scale.LinePlot.sveltesvelte<script>
  import * as d3 from 'd3';

  export let data;
  export let width = 640;
  export let height = 400;
  export let marginTop = 20;
  export let marginRight = 20;
  export let marginBottom = 20;
  export let marginLeft = 20;

  $: x = d3.scaleLinear([0, data.length - 1], [marginLeft, width - marginRight]);
  $: y = d3.scaleLinear(d3.extent(data), [height - marginBottom, marginTop]);
  $: line = d3.line((d, i) => x(i), y);
</script>
<svg width={width} height={height}>
  <path fill="none" stroke="currentColor" stroke-width="1.5" d={line(data)} />
  <g fill="white" stroke="currentColor" stroke-width="1.5">
    {#each data as d, i}
      <circle key={i} cx={x(i)} cy={y(d)} r="2.5" />
    {/each}
  </g>
</svg>REPL ↗︎Svelte’s reactive statements ($:) pair nicely with D3 data joins for efficient updates. Below, we use them to render dynamic axes as the data changes.LinePlot.sveltesvelte<script>
  import * as d3 from 'd3';

  export let data;
  export let width = 640;
  export let height = 400;
  export let marginTop = 20;
  export let marginRight = 20;
  export let marginBottom = 30;
  export let marginLeft = 40;

  let gx;
  let gy;

  $: x = d3.scaleLinear([0, data.length - 1], [marginLeft, width - marginRight]);
  $: y = d3.scaleLinear(d3.extent(data), [height - marginBottom, marginTop]);
  $: line = d3.line((d, i) => x(i), y);
  $: d3.select(gy).call(d3.axisLeft(y));
  $: d3.select(gx).call(d3.axisBottom(x));
</script>
<svg width={width} height={height}>
  <g bind:this={gx} transform="translate(0,{height - marginBottom})" />
  <g bind:this={gy} transform="translate({marginLeft},0)" />
  <path fill="none" stroke="currentColor" stroke-width="1.5" d={line(data)} />
  <g fill="white" stroke="currentColor" stroke-width="1.5">
    {#each data as d, i}
      <circle key={i} cx={x(i)} cy={y(d)} r="2.5" />
    {/each}
  </g>
</svg>REPL ↗︎\n\nSearchK7.9.0GitHub️ 110.0kOn this pageGetting started ​D3 works in any JavaScript environment.Try D3 online ​The fastest way to get started (and get help) with D3 is on Observable! D3 is available by default in notebooks as part of Observable’s standard library. To create something with D3, return the generated DOM element from a cell. Here is a blank chart to get you started:js{
  // Declare the chart dimensions and margins.
  const width = 640;
  const height = 400;
  const marginTop = 20;
  const marginRight = 20;
  const marginBottom = 30;
  const marginLeft = 40;

  // Declare the x (horizontal position) scale.
  const x = d3.scaleUtc()
      .domain([new Date("2023-01-01"), new Date("2024-01-01")])
      .range([marginLeft, width - marginRight]);

  // Declare the y (vertical position) scale.
  const y = d3.scaleLinear()
      .domain([0, 100])
      .range([height - marginBottom, marginTop]);

  // Create the SVG container.
  const svg = d3.create("svg")
      .attr("width", width)
      .attr("height", height);

  // Add the x-axis.
  svg.append("g")
      .attr("transform", `translate(0,${height - marginBottom})`)
      .call(d3.axisBottom(x));

  // Add the y-axis.
  svg.append("g")
      .attr("transform", `translate(${marginLeft},0)`)
      .call(d3.axisLeft(y));

  // Return the SVG element.
  return svg.node();
}As a more complete example, try one of these starter templates:Area chartBar chartDonut chartHistogramLine chartSee the D3 gallery for more forkable examples.Observable includes a few D3 snippets when you click + to add a cell (type “d3” when the cell menu is open to filter), as well as convenient sample datasets to try out D3 features. Or upload a CSV or JSON file to start playing with your data. You can also fork any of the hundreds of notebooks we’ve published for a head start.Observable is free for public use. Sign up for a Pro account to connect to private databases, collaborate on private notebooks, and more.D3 in vanilla HTML ​In vanilla HTML, you can load D3 from a CDN such as jsDelivr or you can download it locally. We recommend using the CDN-hosted ES module bundle. But for those who need it, we also provide a UMD bundle that exports the d3 global when loaded as a plain script.ESM + CDNUMD + CDNUMD + localhtml<!DOCTYPE html>
<div id="container"></div>
<script type="module">

import * as d3 from "https://cdn.jsdelivr.net/npm/d3@7/+esm";

// Declare the chart dimensions and margins.
const width = 640;
const height = 400;
const marginTop = 20;
const marginRight = 20;
const marginBottom = 30;
const marginLeft = 40;

// Declare the x (horizontal position) scale.
const x = d3.scaleUtc()
    .domain([new Date("2023-01-01"), new Date("2024-01-01")])
    .range([marginLeft, width - marginRight]);

// Declare the y (vertical position) scale.
const y = d3.scaleLinear()
    .domain([0, 100])
    .range([height - marginBottom, marginTop]);

// Create the SVG container.
const svg = d3.create("svg")
    .attr("width", width)
    .attr("height", height);

// Add the x-axis.
svg.append("g")
    .attr("transform", `translate(0,${height - marginBottom})`)
    .call(d3.axisBottom(x));

// Add the y-axis.
svg.append("g")
    .attr("transform", `translate(${marginLeft},0)`)
    .call(d3.axisLeft(y));

// Append the SVG element.
container.append(svg.node());

</script>html<!DOCTYPE html>
<div id="container"></div>
<script src="https://cdn.jsdelivr.net/npm/d3@7"></script>
<script type="module">

// Declare the chart dimensions and margins.
const width = 640;
const height = 400;
const marginTop = 20;
const marginRight = 20;
const marginBottom = 30;
const marginLeft = 40;

// Declare the x (horizontal position) scale.
const x = d3.scaleUtc()
    .domain([new Date("2023-01-01"), new Date("2024-01-01")])
    .range([marginLeft, width - marginRight]);

// Declare the y (vertical position) scale.
const y = d3.scaleLinear()
    .domain([0, 100])
    .range([height - marginBottom, marginTop]);

// Create the SVG container.
const svg = d3.create("svg")
    .attr("width", width)
    .attr("height", height);

// Add the x-axis.
svg.append("g")
    .attr("transform", `translate(0,${height - marginBottom})`)
    .call(d3.axisBottom(x));

// Add the y-axis.
svg.append("g")
    .attr("transform", `translate(${marginLeft},0)`)
    .call(d3.axisLeft(y));

// Append the SVG element.
container.append(svg.node());

</script>html<!DOCTYPE html>
<div id="container"></div>
<script src="d3.js"></script>
<script type="module">

// Declare the chart dimensions and margins.
const width = 640;
const height = 400;
const marginTop = 20;
const marginRight = 20;
const marginBottom = 30;
const marginLeft = 40;

// Declare the x (horizontal position) scale.
const x = d3.scaleUtc()
    .domain([new Date("2023-01-01"), new Date("2024-01-01")])
    .range([marginLeft, width - marginRight]);

// Declare the y (vertical position) scale.
const y = d3.scaleLinear()
    .domain([0, 100])
    .range([height - marginBottom, marginTop]);

// Create the SVG container.
const svg = d3.create("svg")
    .attr("width", width)
    .attr("height", height);

// Add the x-axis.
svg.append("g")
    .attr("transform", `translate(0,${height - marginBottom})`)
    .call(d3.axisBottom(x));

// Add the y-axis.
svg.append("g")
    .attr("transform", `translate(${marginLeft},0)`)
    .call(d3.axisLeft(y));

// Append the SVG element.
container.append(svg.node());

</script>You can also import and destructure individual D3 modules like so:html<script type="module">

import {forceSimulation, forceCollide, forceX} from "https://cdn.jsdelivr.net/npm/d3-force@3/+esm";

const nodes = [{}, {}];
const simulation = forceSimulation(nodes)
    .force("x", forceX())
    .force("collide", forceCollide(5))
    .on("tick", () => console.log(nodes[0].x));

</script>If you’d prefer to run D3 locally (or offline), you can download the UMD bundles of D3 here:d3.v7.jsd3.v7.min.jsThen, create an index.html file as shown above in the UMD + local tab. Use the non-minified bundle for debugging, and the minified bundle for faster performance in production.Installing from npm ​If you’re developing a web application using Node, you can install D3 via yarn, npm, pnpm, or your preferred package manager.yarnnpmpnpmbashyarn add d3bashnpm install d3bashpnpm add d3You can then load D3 into your app as:jsimport * as d3 from "d3";You can instead import specific symbols if you prefer:jsimport {select, selectAll} from "d3";Alternatively you can install and import from D3 submodules:jsimport {mean, median} from "d3-array";TypeScript declarations are available via DefinitelyTyped.D3 in React ​Most D3 modules (including d3-scale, d3-array, d3-interpolate, and d3-format) don’t interact with the DOM, so there is no difference when using them in React. You can use them in JSX for purely declarative visualization, such as the line plot below.LinePlot.jsxjsximport * as d3 from "d3";

export default function LinePlot({
  data,
  width = 640,
  height = 400,
  marginTop = 20,
  marginRight = 20,
  marginBottom = 20,
  marginLeft = 20
}) {
  const x = d3.scaleLinear([0, data.length - 1], [marginLeft, width - marginRight]);
  const y = d3.scaleLinear(d3.extent(data), [height - marginBottom, marginTop]);
  const line = d3.line((d, i) => x(i), y);
  return (
    <svg width={width} height={height}>
      <path fill="none" stroke="currentColor" strokeWidth="1.5" d={line(data)} />
      <g fill="white" stroke="currentColor" strokeWidth="1.5">
        {data.map((d, i) => (<circle key={i} cx={x(i)} cy={y(d)} r="2.5" />))}
      </g>
    </svg>
  );
}Sandbox ↗︎D3 modules that operate on selections (including d3-selection, d3-transition, and d3-axis) do manipulate the DOM, which competes with React’s virtual DOM. In those cases, you can attach a ref to an element and pass it to D3 in a useEffect hook.LinePlot.jsxjsximport * as d3 from "d3";
import {useRef, useEffect} from "react";

export default function LinePlot({
  data,
  width = 640,
  height = 400,
  marginTop = 20,
  marginRight = 20,
  marginBottom = 30,
  marginLeft = 40
}) {
  const gx = useRef();
  const gy = useRef();
  const x = d3.scaleLinear([0, data.length - 1], [marginLeft, width - marginRight]);
  const y = d3.scaleLinear(d3.extent(data), [height - marginBottom, marginTop]);
  const line = d3.line((d, i) => x(i), y);
  useEffect(() => void d3.select(gx.current).call(d3.axisBottom(x)), [gx, x]);
  useEffect(() => void d3.select(gy.current).call(d3.axisLeft(y)), [gy, y]);
  return (
    <svg width={width} height={height}>
      <g ref={gx} transform={`translate(0,${height - marginBottom})`} />
      <g ref={gy} transform={`translate(${marginLeft},0)`} />
      <path fill="none" stroke="currentColor" strokeWidth="1.5" d={line(data)} />
      <g fill="white" stroke="currentColor" strokeWidth="1.5">
        {data.map((d, i) => (<circle key={i} cx={x(i)} cy={y(d)} r="2.5" />))}
      </g>
    </svg>
  );
}Sandbox ↗︎For more guidance using D3 in React, see Amelia Wattenberger’s post.D3 in Svelte ​As with React, you can use Svelte exclusively for rendering if you like, and only use D3 modules that don’t manipulate the DOM. Here is a line plot of an array of numbers that uses d3-shape and d3-scale.LinePlot.sveltesvelte<script>
  import * as d3 from 'd3';

  export let data;
  export let width = 640;
  export let height = 400;
  export let marginTop = 20;
  export let marginRight = 20;
  export let marginBottom = 20;
  export let marginLeft = 20;

  $: x = d3.scaleLinear([0, data.length - 1], [marginLeft, width - marginRight]);
  $: y = d3.scaleLinear(d3.extent(data), [height - marginBottom, marginTop]);
  $: line = d3.line((d, i) => x(i), y);
</script>
<svg width={width} height={height}>
  <path fill="none" stroke="currentColor" stroke-width="1.5" d={line(data)} />
  <g fill="white" stroke="currentColor" stroke-width="1.5">
    {#each data as d, i}
      <circle key={i} cx={x(i)} cy={y(d)} r="2.5" />
    {/each}
  </g>
</svg>REPL ↗︎Svelte’s reactive statements ($:) pair nicely with D3 data joins for efficient updates. Below, we use them to render dynamic axes as the data changes.LinePlot.sveltesvelte<script>
  import * as d3 from 'd3';

  export let data;
  export let width = 640;
  export let height = 400;
  export let marginTop = 20;
  export let marginRight = 20;
  export let marginBottom = 30;
  export let marginLeft = 40;

  let gx;
  let gy;

  $: x = d3.scaleLinear([0, data.length - 1], [marginLeft, width - marginRight]);
  $: y = d3.scaleLinear(d3.extent(data), [height - marginBottom, marginTop]);
  $: line = d3.line((d, i) => x(i), y);
  $: d3.select(gy).call(d3.axisLeft(y));
  $: d3.select(gx).call(d3.axisBottom(x));
</script>
<svg width={width} height={height}>
  <g bind:this={gx} transform="translate(0,{height - marginBottom})" />
  <g bind:this={gy} transform="translate({marginLeft},0)" />
  <path fill="none" stroke="currentColor" stroke-width="1.5" d={line(data)} />
  <g fill="white" stroke="currentColor" stroke-width="1.5">
    {#each data as d, i}
      <circle key={i} cx={x(i)} cy={y(d)} r="2.5" />
    {/each}
  </g>
</svg>REPL ↗︎PagerPrevious pageWhat is D3?Next pageAPI index\n\nGetting started ​D3 works in any JavaScript environment.Try D3 online ​The fastest way to get started (and get help) with D3 is on Observable! D3 is available by default in notebooks as part of Observable’s standard library. To create something with D3, return the generated DOM element from a cell. Here is a blank chart to get you started:js{
  // Declare the chart dimensions and margins.
  const width = 640;
  const height = 400;
  const marginTop = 20;
  const marginRight = 20;
  const marginBottom = 30;
  const marginLeft = 40;

  // Declare the x (horizontal position) scale.
  const x = d3.scaleUtc()
      .domain([new Date("2023-01-01"), new Date("2024-01-01")])
      .range([marginLeft, width - marginRight]);

  // Declare the y (vertical position) scale.
  const y = d3.scaleLinear()
      .domain([0, 100])
      .range([height - marginBottom, marginTop]);

  // Create the SVG container.
  const svg = d3.create("svg")
      .attr("width", width)
      .attr("height", height);

  // Add the x-axis.
  svg.append("g")
      .attr("transform", `translate(0,${height - marginBottom})`)
      .call(d3.axisBottom(x));

  // Add the y-axis.
  svg.append("g")
      .attr("transform", `translate(${marginLeft},0)`)
      .call(d3.axisLeft(y));

  // Return the SVG element.
  return svg.node();
}As a more complete example, try one of these starter templates:Area chartBar chartDonut chartHistogramLine chartSee the D3 gallery for more forkable examples.Observable includes a few D3 snippets when you click + to add a cell (type “d3” when the cell menu is open to filter), as well as convenient sample datasets to try out D3 features. Or upload a CSV or JSON file to start playing with your data. You can also fork any of the hundreds of notebooks we’ve published for a head start.Observable is free for public use. Sign up for a Pro account to connect to private databases, collaborate on private notebooks, and more.D3 in vanilla HTML ​In vanilla HTML, you can load D3 from a CDN such as jsDelivr or you can download it locally. We recommend using the CDN-hosted ES module bundle. But for those who need it, we also provide a UMD bundle that exports the d3 global when loaded as a plain script.ESM + CDNUMD + CDNUMD + localhtml<!DOCTYPE html>
<div id="container"></div>
<script type="module">

import * as d3 from "https://cdn.jsdelivr.net/npm/d3@7/+esm";

// Declare the chart dimensions and margins.
const width = 640;
const height = 400;
const marginTop = 20;
const marginRight = 20;
const marginBottom = 30;
const marginLeft = 40;

// Declare the x (horizontal position) scale.
const x = d3.scaleUtc()
    .domain([new Date("2023-01-01"), new Date("2024-01-01")])
    .range([marginLeft, width - marginRight]);

// Declare the y (vertical position) scale.
const y = d3.scaleLinear()
    .domain([0, 100])
    .range([height - marginBottom, marginTop]);

// Create the SVG container.
const svg = d3.create("svg")
    .attr("width", width)
    .attr("height", height);

// Add the x-axis.
svg.append("g")
    .attr("transform", `translate(0,${height - marginBottom})`)
    .call(d3.axisBottom(x));

// Add the y-axis.
svg.append("g")
    .attr("transform", `translate(${marginLeft},0)`)
    .call(d3.axisLeft(y));

// Append the SVG element.
container.append(svg.node());

</script>html<!DOCTYPE html>
<div id="container"></div>
<script src="https://cdn.jsdelivr.net/npm/d3@7"></script>
<script type="module">

// Declare the chart dimensions and margins.
const width = 640;
const height = 400;
const marginTop = 20;
const marginRight = 20;
const marginBottom = 30;
const marginLeft = 40;

// Declare the x (horizontal position) scale.
const x = d3.scaleUtc()
    .domain([new Date("2023-01-01"), new Date("2024-01-01")])
    .range([marginLeft, width - marginRight]);

// Declare the y (vertical position) scale.
const y = d3.scaleLinear()
    .domain([0, 100])
    .range([height - marginBottom, marginTop]);

// Create the SVG container.
const svg = d3.create("svg")
    .attr("width", width)
    .attr("height", height);

// Add the x-axis.
svg.append("g")
    .attr("transform", `translate(0,${height - marginBottom})`)
    .call(d3.axisBottom(x));

// Add the y-axis.
svg.append("g")
    .attr("transform", `translate(${marginLeft},0)`)
    .call(d3.axisLeft(y));

// Append the SVG element.
container.append(svg.node());

</script>html<!DOCTYPE html>
<div id="container"></div>
<script src="d3.js"></script>
<script type="module">

// Declare the chart dimensions and margins.
const width = 640;
const height = 400;
const marginTop = 20;
const marginRight = 20;
const marginBottom = 30;
const marginLeft = 40;

// Declare the x (horizontal position) scale.
const x = d3.scaleUtc()
    .domain([new Date("2023-01-01"), new Date("2024-01-01")])
    .range([marginLeft, width - marginRight]);

// Declare the y (vertical position) scale.
const y = d3.scaleLinear()
    .domain([0, 100])
    .range([height - marginBottom, marginTop]);

// Create the SVG container.
const svg = d3.create("svg")
    .attr("width", width)
    .attr("height", height);

// Add the x-axis.
svg.append("g")
    .attr("transform", `translate(0,${height - marginBottom})`)
    .call(d3.axisBottom(x));

// Add the y-axis.
svg.append("g")
    .attr("transform", `translate(${marginLeft},0)`)
    .call(d3.axisLeft(y));

// Append the SVG element.
container.append(svg.node());

</script>You can also import and destructure individual D3 modules like so:html<script type="module">

import {forceSimulation, forceCollide, forceX} from "https://cdn.jsdelivr.net/npm/d3-force@3/+esm";

const nodes = [{}, {}];
const simulation = forceSimulation(nodes)
    .force("x", forceX())
    .force("collide", forceCollide(5))
    .on("tick", () => console.log(nodes[0].x));

</script>If you’d prefer to run D3 locally (or offline), you can download the UMD bundles of D3 here:d3.v7.jsd3.v7.min.jsThen, create an index.html file as shown above in the UMD + local tab. Use the non-minified bundle for debugging, and the minified bundle for faster performance in production.Installing from npm ​If you’re developing a web application using Node, you can install D3 via yarn, npm, pnpm, or your preferred package manager.yarnnpmpnpmbashyarn add d3bashnpm install d3bashpnpm add d3You can then load D3 into your app as:jsimport * as d3 from "d3";You can instead import specific symbols if you prefer:jsimport {select, selectAll} from "d3";Alternatively you can install and import from D3 submodules:jsimport {mean, median} from "d3-array";TypeScript declarations are available via DefinitelyTyped.D3 in React ​Most D3 modules (including d3-scale, d3-array, d3-interpolate, and d3-format) don’t interact with the DOM, so there is no difference when using them in React. You can use them in JSX for purely declarative visualization, such as the line plot below.LinePlot.jsxjsximport * as d3 from "d3";

export default function LinePlot({
  data,
  width = 640,
  height = 400,
  marginTop = 20,
  marginRight = 20,
  marginBottom = 20,
  marginLeft = 20
}) {
  const x = d3.scaleLinear([0, data.length - 1], [marginLeft, width - marginRight]);
  const y = d3.scaleLinear(d3.extent(data), [height - marginBottom, marginTop]);
  const line = d3.line((d, i) => x(i), y);
  return (
    <svg width={width} height={height}>
      <path fill="none" stroke="currentColor" strokeWidth="1.5" d={line(data)} />
      <g fill="white" stroke="currentColor" strokeWidth="1.5">
        {data.map((d, i) => (<circle key={i} cx={x(i)} cy={y(d)} r="2.5" />))}
      </g>
    </svg>
  );
}Sandbox ↗︎D3 modules that operate on selections (including d3-selection, d3-transition, and d3-axis) do manipulate the DOM, which competes with React’s virtual DOM. In those cases, you can attach a ref to an element and pass it to D3 in a useEffect hook.LinePlot.jsxjsximport * as d3 from "d3";
import {useRef, useEffect} from "react";

export default function LinePlot({
  data,
  width = 640,
  height = 400,
  marginTop = 20,
  marginRight = 20,
  marginBottom = 30,
  marginLeft = 40
}) {
  const gx = useRef();
  const gy = useRef();
  const x = d3.scaleLinear([0, data.length - 1], [marginLeft, width - marginRight]);
  const y = d3.scaleLinear(d3.extent(data), [height - marginBottom, marginTop]);
  const line = d3.line((d, i) => x(i), y);
  useEffect(() => void d3.select(gx.current).call(d3.axisBottom(x)), [gx, x]);
  useEffect(() => void d3.select(gy.current).call(d3.axisLeft(y)), [gy, y]);
  return (
    <svg width={width} height={height}>
      <g ref={gx} transform={`translate(0,${height - marginBottom})`} />
      <g ref={gy} transform={`translate(${marginLeft},0)`} />
      <path fill="none" stroke="currentColor" strokeWidth="1.5" d={line(data)} />
      <g fill="white" stroke="currentColor" strokeWidth="1.5">
        {data.map((d, i) => (<circle key={i} cx={x(i)} cy={y(d)} r="2.5" />))}
      </g>
    </svg>
  );
}Sandbox ↗︎For more guidance using D3 in React, see Amelia Wattenberger’s post.D3 in Svelte ​As with React, you can use Svelte exclusively for rendering if you like, and only use D3 modules that don’t manipulate the DOM. Here is a line plot of an array of numbers that uses d3-shape and d3-scale.LinePlot.sveltesvelte<script>
  import * as d3 from 'd3';

  export let data;
  export let width = 640;
  export let height = 400;
  export let marginTop = 20;
  export let marginRight = 20;
  export let marginBottom = 20;
  export let marginLeft = 20;

  $: x = d3.scaleLinear([0, data.length - 1], [marginLeft, width - marginRight]);
  $: y = d3.scaleLinear(d3.extent(data), [height - marginBottom, marginTop]);
  $: line = d3.line((d, i) => x(i), y);
</script>
<svg width={width} height={height}>
  <path fill="none" stroke="currentColor" stroke-width="1.5" d={line(data)} />
  <g fill="white" stroke="currentColor" stroke-width="1.5">
    {#each data as d, i}
      <circle key={i} cx={x(i)} cy={y(d)} r="2.5" />
    {/each}
  </g>
</svg>REPL ↗︎Svelte’s reactive statements ($:) pair nicely with D3 data joins for efficient updates. Below, we use them to render dynamic axes as the data changes.LinePlot.sveltesvelte<script>
  import * as d3 from 'd3';

  export let data;
  export let width = 640;
  export let height = 400;
  export let marginTop = 20;
  export let marginRight = 20;
  export let marginBottom = 30;
  export let marginLeft = 40;

  let gx;
  let gy;

  $: x = d3.scaleLinear([0, data.length - 1], [marginLeft, width - marginRight]);
  $: y = d3.scaleLinear(d3.extent(data), [height - marginBottom, marginTop]);
  $: line = d3.line((d, i) => x(i), y);
  $: d3.select(gy).call(d3.axisLeft(y));
  $: d3.select(gx).call(d3.axisBottom(x));
</script>
<svg width={width} height={height}>
  <g bind:this={gx} transform="translate(0,{height - marginBottom})" />
  <g bind:this={gy} transform="translate({marginLeft},0)" />
  <path fill="none" stroke="currentColor" stroke-width="1.5" d={line(data)} />
  <g fill="white" stroke="currentColor" stroke-width="1.5">
    {#each data as d, i}
      <circle key={i} cx={x(i)} cy={y(d)} r="2.5" />
    {/each}
  </g>
</svg>REPL ↗︎\n\n\n\nGetting started ​D3 works in any JavaScript environment.Try D3 online ​The fastest way to get started (and get help) with D3 is on Observable! D3 is available by default in notebooks as part of Observable’s standard library. To create something with D3, return the generated DOM element from a cell. Here is a blank chart to get you started:js{
  // Declare the chart dimensions and margins.
  const width = 640;
  const height = 400;
  const marginTop = 20;
  const marginRight = 20;
  const marginBottom = 30;
  const marginLeft = 40;

  // Declare the x (horizontal position) scale.
  const x = d3.scaleUtc()
      .domain([new Date("2023-01-01"), new Date("2024-01-01")])
      .range([marginLeft, width - marginRight]);

  // Declare the y (vertical position) scale.
  const y = d3.scaleLinear()
      .domain([0, 100])
      .range([height - marginBottom, marginTop]);

  // Create the SVG container.
  const svg = d3.create("svg")
      .attr("width", width)
      .attr("height", height);

  // Add the x-axis.
  svg.append("g")
      .attr("transform", `translate(0,${height - marginBottom})`)
      .call(d3.axisBottom(x));

  // Add the y-axis.
  svg.append("g")
      .attr("transform", `translate(${marginLeft},0)`)
      .call(d3.axisLeft(y));

  // Return the SVG element.
  return svg.node();
}As a more complete example, try one of these starter templates:Area chartBar chartDonut chartHistogramLine chartSee the D3 gallery for more forkable examples.Observable includes a few D3 snippets when you click + to add a cell (type “d3” when the cell menu is open to filter), as well as convenient sample datasets to try out D3 features. Or upload a CSV or JSON file to start playing with your data. You can also fork any of the hundreds of notebooks we’ve published for a head start.Observable is free for public use. Sign up for a Pro account to connect to private databases, collaborate on private notebooks, and more.D3 in vanilla HTML ​In vanilla HTML, you can load D3 from a CDN such as jsDelivr or you can download it locally. We recommend using the CDN-hosted ES module bundle. But for those who need it, we also provide a UMD bundle that exports the d3 global when loaded as a plain script.ESM + CDNUMD + CDNUMD + localhtml<!DOCTYPE html>
<div id="container"></div>
<script type="module">

import * as d3 from "https://cdn.jsdelivr.net/npm/d3@7/+esm";

// Declare the chart dimensions and margins.
const width = 640;
const height = 400;
const marginTop = 20;
const marginRight = 20;
const marginBottom = 30;
const marginLeft = 40;

// Declare the x (horizontal position) scale.
const x = d3.scaleUtc()
    .domain([new Date("2023-01-01"), new Date("2024-01-01")])
    .range([marginLeft, width - marginRight]);

// Declare the y (vertical position) scale.
const y = d3.scaleLinear()
    .domain([0, 100])
    .range([height - marginBottom, marginTop]);

// Create the SVG container.
const svg = d3.create("svg")
    .attr("width", width)
    .attr("height", height);

// Add the x-axis.
svg.append("g")
    .attr("transform", `translate(0,${height - marginBottom})`)
    .call(d3.axisBottom(x));

// Add the y-axis.
svg.append("g")
    .attr("transform", `translate(${marginLeft},0)`)
    .call(d3.axisLeft(y));

// Append the SVG element.
container.append(svg.node());

</script>html<!DOCTYPE html>
<div id="container"></div>
<script src="https://cdn.jsdelivr.net/npm/d3@7"></script>
<script type="module">

// Declare the chart dimensions and margins.
const width = 640;
const height = 400;
const marginTop = 20;
const marginRight = 20;
const marginBottom = 30;
const marginLeft = 40;

// Declare the x (horizontal position) scale.
const x = d3.scaleUtc()
    .domain([new Date("2023-01-01"), new Date("2024-01-01")])
    .range([marginLeft, width - marginRight]);

// Declare the y (vertical position) scale.
const y = d3.scaleLinear()
    .domain([0, 100])
    .range([height - marginBottom, marginTop]);

// Create the SVG container.
const svg = d3.create("svg")
    .attr("width", width)
    .attr("height", height);

// Add the x-axis.
svg.append("g")
    .attr("transform", `translate(0,${height - marginBottom})`)
    .call(d3.axisBottom(x));

// Add the y-axis.
svg.append("g")
    .attr("transform", `translate(${marginLeft},0)`)
    .call(d3.axisLeft(y));

// Append the SVG element.
container.append(svg.node());

</script>html<!DOCTYPE html>
<div id="container"></div>
<script src="d3.js"></script>
<script type="module">

// Declare the chart dimensions and margins.
const width = 640;
const height = 400;
const marginTop = 20;
const marginRight = 20;
const marginBottom = 30;
const marginLeft = 40;

// Declare the x (horizontal position) scale.
const x = d3.scaleUtc()
    .domain([new Date("2023-01-01"), new Date("2024-01-01")])
    .range([marginLeft, width - marginRight]);

// Declare the y (vertical position) scale.
const y = d3.scaleLinear()
    .domain([0, 100])
    .range([height - marginBottom, marginTop]);

// Create the SVG container.
const svg = d3.create("svg")
    .attr("width", width)
    .attr("height", height);

// Add the x-axis.
svg.append("g")
    .attr("transform", `translate(0,${height - marginBottom})`)
    .call(d3.axisBottom(x));

// Add the y-axis.
svg.append("g")
    .attr("transform", `translate(${marginLeft},0)`)
    .call(d3.axisLeft(y));

// Append the SVG element.
container.append(svg.node());

</script>You can also import and destructure individual D3 modules like so:html<script type="module">

import {forceSimulation, forceCollide, forceX} from "https://cdn.jsdelivr.net/npm/d3-force@3/+esm";

const nodes = [{}, {}];
const simulation = forceSimulation(nodes)
    .force("x", forceX())
    .force("collide", forceCollide(5))
    .on("tick", () => console.log(nodes[0].x));

</script>If you’d prefer to run D3 locally (or offline), you can download the UMD bundles of D3 here:d3.v7.jsd3.v7.min.jsThen, create an index.html file as shown above in the UMD + local tab. Use the non-minified bundle for debugging, and the minified bundle for faster performance in production.Installing from npm ​If you’re developing a web application using Node, you can install D3 via yarn, npm, pnpm, or your preferred package manager.yarnnpmpnpmbashyarn add d3bashnpm install d3bashpnpm add d3You can then load D3 into your app as:jsimport * as d3 from "d3";You can instead import specific symbols if you prefer:jsimport {select, selectAll} from "d3";Alternatively you can install and import from D3 submodules:jsimport {mean, median} from "d3-array";TypeScript declarations are available via DefinitelyTyped.D3 in React ​Most D3 modules (including d3-scale, d3-array, d3-interpolate, and d3-format) don’t interact with the DOM, so there is no difference when using them in React. You can use them in JSX for purely declarative visualization, such as the line plot below.LinePlot.jsxjsximport * as d3 from "d3";

export default function LinePlot({
  data,
  width = 640,
  height = 400,
  marginTop = 20,
  marginRight = 20,
  marginBottom = 20,
  marginLeft = 20
}) {
  const x = d3.scaleLinear([0, data.length - 1], [marginLeft, width - marginRight]);
  const y = d3.scaleLinear(d3.extent(data), [height - marginBottom, marginTop]);
  const line = d3.line((d, i) => x(i), y);
  return (
    <svg width={width} height={height}>
      <path fill="none" stroke="currentColor" strokeWidth="1.5" d={line(data)} />
      <g fill="white" stroke="currentColor" strokeWidth="1.5">
        {data.map((d, i) => (<circle key={i} cx={x(i)} cy={y(d)} r="2.5" />))}
      </g>
    </svg>
  );
}Sandbox ↗︎D3 modules that operate on selections (including d3-selection, d3-transition, and d3-axis) do manipulate the DOM, which competes with React’s virtual DOM. In those cases, you can attach a ref to an element and pass it to D3 in a useEffect hook.LinePlot.jsxjsximport * as d3 from "d3";
import {useRef, useEffect} from "react";

export default function LinePlot({
  data,
  width = 640,
  height = 400,
  marginTop = 20,
  marginRight = 20,
  marginBottom = 30,
  marginLeft = 40
}) {
  const gx = useRef();
  const gy = useRef();
  const x = d3.scaleLinear([0, data.length - 1], [marginLeft, width - marginRight]);
  const y = d3.scaleLinear(d3.extent(data), [height - marginBottom, marginTop]);
  const line = d3.line((d, i) => x(i), y);
  useEffect(() => void d3.select(gx.current).call(d3.axisBottom(x)), [gx, x]);
  useEffect(() => void d3.select(gy.current).call(d3.axisLeft(y)), [gy, y]);
  return (
    <svg width={width} height={height}>
      <g ref={gx} transform={`translate(0,${height - marginBottom})`} />
      <g ref={gy} transform={`translate(${marginLeft},0)`} />
      <path fill="none" stroke="currentColor" strokeWidth="1.5" d={line(data)} />
      <g fill="white" stroke="currentColor" strokeWidth="1.5">
        {data.map((d, i) => (<circle key={i} cx={x(i)} cy={y(d)} r="2.5" />))}
      </g>
    </svg>
  );
}Sandbox ↗︎For more guidance using D3 in React, see Amelia Wattenberger’s post.D3 in Svelte ​As with React, you can use Svelte exclusively for rendering if you like, and only use D3 modules that don’t manipulate the DOM. Here is a line plot of an array of numbers that uses d3-shape and d3-scale.LinePlot.sveltesvelte<script>
  import * as d3 from 'd3';

  export let data;
  export let width = 640;
  export let height = 400;
  export let marginTop = 20;
  export let marginRight = 20;
  export let marginBottom = 20;
  export let marginLeft = 20;

  $: x = d3.scaleLinear([0, data.length - 1], [marginLeft, width - marginRight]);
  $: y = d3.scaleLinear(d3.extent(data), [height - marginBottom, marginTop]);
  $: line = d3.line((d, i) => x(i), y);
</script>
<svg width={width} height={height}>
  <path fill="none" stroke="currentColor" stroke-width="1.5" d={line(data)} />
  <g fill="white" stroke="currentColor" stroke-width="1.5">
    {#each data as d, i}
      <circle key={i} cx={x(i)} cy={y(d)} r="2.5" />
    {/each}
  </g>
</svg>REPL ↗︎Svelte’s reactive statements ($:) pair nicely with D3 data joins for efficient updates. Below, we use them to render dynamic axes as the data changes.LinePlot.sveltesvelte<script>
  import * as d3 from 'd3';

  export let data;
  export let width = 640;
  export let height = 400;
  export let marginTop = 20;
  export let marginRight = 20;
  export let marginBottom = 30;
  export let marginLeft = 40;

  let gx;
  let gy;

  $: x = d3.scaleLinear([0, data.length - 1], [marginLeft, width - marginRight]);
  $: y = d3.scaleLinear(d3.extent(data), [height - marginBottom, marginTop]);
  $: line = d3.line((d, i) => x(i), y);
  $: d3.select(gy).call(d3.axisLeft(y));
  $: d3.select(gx).call(d3.axisBottom(x));
</script>
<svg width={width} height={height}>
  <g bind:this={gx} transform="translate(0,{height - marginBottom})" />
  <g bind:this={gy} transform="translate({marginLeft},0)" />
  <path fill="none" stroke="currentColor" stroke-width="1.5" d={line(data)} />
  <g fill="white" stroke="currentColor" stroke-width="1.5">
    {#each data as d, i}
      <circle key={i} cx={x(i)} cy={y(d)} r="2.5" />
    {/each}
  </g>
</svg>REPL ↗︎\n\nSearchK7.9.0GitHub️ 110.0kOn this pageGetting started ​D3 works in any JavaScript environment.Try D3 online ​The fastest way to get started (and get help) with D3 is on Observable! D3 is available by default in notebooks as part of Observable’s standard library. To create something with D3, return the generated DOM element from a cell. Here is a blank chart to get you started:js{
  // Declare the chart dimensions and margins.
  const width = 640;
  const height = 400;
  const marginTop = 20;
  const marginRight = 20;
  const marginBottom = 30;
  const marginLeft = 40;

  // Declare the x (horizontal position) scale.
  const x = d3.scaleUtc()
      .domain([new Date("2023-01-01"), new Date("2024-01-01")])
      .range([marginLeft, width - marginRight]);

  // Declare the y (vertical position) scale.
  const y = d3.scaleLinear()
      .domain([0, 100])
      .range([height - marginBottom, marginTop]);

  // Create the SVG container.
  const svg = d3.create("svg")
      .attr("width", width)
      .attr("height", height);

  // Add the x-axis.
  svg.append("g")
      .attr("transform", `translate(0,${height - marginBottom})`)
      .call(d3.axisBottom(x));

  // Add the y-axis.
  svg.append("g")
      .attr("transform", `translate(${marginLeft},0)`)
      .call(d3.axisLeft(y));

  // Return the SVG element.
  return svg.node();
}As a more complete example, try one of these starter templates:Area chartBar chartDonut chartHistogramLine chartSee the D3 gallery for more forkable examples.Observable includes a few D3 snippets when you click + to add a cell (type “d3” when the cell menu is open to filter), as well as convenient sample datasets to try out D3 features. Or upload a CSV or JSON file to start playing with your data. You can also fork any of the hundreds of notebooks we’ve published for a head start.Observable is free for public use. Sign up for a Pro account to connect to private databases, collaborate on private notebooks, and more.D3 in vanilla HTML ​In vanilla HTML, you can load D3 from a CDN such as jsDelivr or you can download it locally. We recommend using the CDN-hosted ES module bundle. But for those who need it, we also provide a UMD bundle that exports the d3 global when loaded as a plain script.ESM + CDNUMD + CDNUMD + localhtml<!DOCTYPE html>
<div id="container"></div>
<script type="module">

import * as d3 from "https://cdn.jsdelivr.net/npm/d3@7/+esm";

// Declare the chart dimensions and margins.
const width = 640;
const height = 400;
const marginTop = 20;
const marginRight = 20;
const marginBottom = 30;
const marginLeft = 40;

// Declare the x (horizontal position) scale.
const x = d3.scaleUtc()
    .domain([new Date("2023-01-01"), new Date("2024-01-01")])
    .range([marginLeft, width - marginRight]);

// Declare the y (vertical position) scale.
const y = d3.scaleLinear()
    .domain([0, 100])
    .range([height - marginBottom, marginTop]);

// Create the SVG container.
const svg = d3.create("svg")
    .attr("width", width)
    .attr("height", height);

// Add the x-axis.
svg.append("g")
    .attr("transform", `translate(0,${height - marginBottom})`)
    .call(d3.axisBottom(x));

// Add the y-axis.
svg.append("g")
    .attr("transform", `translate(${marginLeft},0)`)
    .call(d3.axisLeft(y));

// Append the SVG element.
container.append(svg.node());

</script>html<!DOCTYPE html>
<div id="container"></div>
<script src="https://cdn.jsdelivr.net/npm/d3@7"></script>
<script type="module">

// Declare the chart dimensions and margins.
const width = 640;
const height = 400;
const marginTop = 20;
const marginRight = 20;
const marginBottom = 30;
const marginLeft = 40;

// Declare the x (horizontal position) scale.
const x = d3.scaleUtc()
    .domain([new Date("2023-01-01"), new Date("2024-01-01")])
    .range([marginLeft, width - marginRight]);

// Declare the y (vertical position) scale.
const y = d3.scaleLinear()
    .domain([0, 100])
    .range([height - marginBottom, marginTop]);

// Create the SVG container.
const svg = d3.create("svg")
    .attr("width", width)
    .attr("height", height);

// Add the x-axis.
svg.append("g")
    .attr("transform", `translate(0,${height - marginBottom})`)
    .call(d3.axisBottom(x));

// Add the y-axis.
svg.append("g")
    .attr("transform", `translate(${marginLeft},0)`)
    .call(d3.axisLeft(y));

// Append the SVG element.
container.append(svg.node());

</script>html<!DOCTYPE html>
<div id="container"></div>
<script src="d3.js"></script>
<script type="module">

// Declare the chart dimensions and margins.
const width = 640;
const height = 400;
const marginTop = 20;
const marginRight = 20;
const marginBottom = 30;
const marginLeft = 40;

// Declare the x (horizontal position) scale.
const x = d3.scaleUtc()
    .domain([new Date("2023-01-01"), new Date("2024-01-01")])
    .range([marginLeft, width - marginRight]);

// Declare the y (vertical position) scale.
const y = d3.scaleLinear()
    .domain([0, 100])
    .range([height - marginBottom, marginTop]);

// Create the SVG container.
const svg = d3.create("svg")
    .attr("width", width)
    .attr("height", height);

// Add the x-axis.
svg.append("g")
    .attr("transform", `translate(0,${height - marginBottom})`)
    .call(d3.axisBottom(x));

// Add the y-axis.
svg.append("g")
    .attr("transform", `translate(${marginLeft},0)`)
    .call(d3.axisLeft(y));

// Append the SVG element.
container.append(svg.node());

</script>You can also import and destructure individual D3 modules like so:html<script type="module">

import {forceSimulation, forceCollide, forceX} from "https://cdn.jsdelivr.net/npm/d3-force@3/+esm";

const nodes = [{}, {}];
const simulation = forceSimulation(nodes)
    .force("x", forceX())
    .force("collide", forceCollide(5))
    .on("tick", () => console.log(nodes[0].x));

</script>If you’d prefer to run D3 locally (or offline), you can download the UMD bundles of D3 here:d3.v7.jsd3.v7.min.jsThen, create an index.html file as shown above in the UMD + local tab. Use the non-minified bundle for debugging, and the minified bundle for faster performance in production.Installing from npm ​If you’re developing a web application using Node, you can install D3 via yarn, npm, pnpm, or your preferred package manager.yarnnpmpnpmbashyarn add d3bashnpm install d3bashpnpm add d3You can then load D3 into your app as:jsimport * as d3 from "d3";You can instead import specific symbols if you prefer:jsimport {select, selectAll} from "d3";Alternatively you can install and import from D3 submodules:jsimport {mean, median} from "d3-array";TypeScript declarations are available via DefinitelyTyped.D3 in React ​Most D3 modules (including d3-scale, d3-array, d3-interpolate, and d3-format) don’t interact with the DOM, so there is no difference when using them in React. You can use them in JSX for purely declarative visualization, such as the line plot below.LinePlot.jsxjsximport * as d3 from "d3";

export default function LinePlot({
  data,
  width = 640,
  height = 400,
  marginTop = 20,
  marginRight = 20,
  marginBottom = 20,
  marginLeft = 20
}) {
  const x = d3.scaleLinear([0, data.length - 1], [marginLeft, width - marginRight]);
  const y = d3.scaleLinear(d3.extent(data), [height - marginBottom, marginTop]);
  const line = d3.line((d, i) => x(i), y);
  return (
    <svg width={width} height={height}>
      <path fill="none" stroke="currentColor" strokeWidth="1.5" d={line(data)} />
      <g fill="white" stroke="currentColor" strokeWidth="1.5">
        {data.map((d, i) => (<circle key={i} cx={x(i)} cy={y(d)} r="2.5" />))}
      </g>
    </svg>
  );
}Sandbox ↗︎D3 modules that operate on selections (including d3-selection, d3-transition, and d3-axis) do manipulate the DOM, which competes with React’s virtual DOM. In those cases, you can attach a ref to an element and pass it to D3 in a useEffect hook.LinePlot.jsxjsximport * as d3 from "d3";
import {useRef, useEffect} from "react";

export default function LinePlot({
  data,
  width = 640,
  height = 400,
  marginTop = 20,
  marginRight = 20,
  marginBottom = 30,
  marginLeft = 40
}) {
  const gx = useRef();
  const gy = useRef();
  const x = d3.scaleLinear([0, data.length - 1], [marginLeft, width - marginRight]);
  const y = d3.scaleLinear(d3.extent(data), [height - marginBottom, marginTop]);
  const line = d3.line((d, i) => x(i), y);
  useEffect(() => void d3.select(gx.current).call(d3.axisBottom(x)), [gx, x]);
  useEffect(() => void d3.select(gy.current).call(d3.axisLeft(y)), [gy, y]);
  return (
    <svg width={width} height={height}>
      <g ref={gx} transform={`translate(0,${height - marginBottom})`} />
      <g ref={gy} transform={`translate(${marginLeft},0)`} />
      <path fill="none" stroke="currentColor" strokeWidth="1.5" d={line(data)} />
      <g fill="white" stroke="currentColor" strokeWidth="1.5">
        {data.map((d, i) => (<circle key={i} cx={x(i)} cy={y(d)} r="2.5" />))}
      </g>
    </svg>
  );
}Sandbox ↗︎For more guidance using D3 in React, see Amelia Wattenberger’s post.D3 in Svelte ​As with React, you can use Svelte exclusively for rendering if you like, and only use D3 modules that don’t manipulate the DOM. Here is a line plot of an array of numbers that uses d3-shape and d3-scale.LinePlot.sveltesvelte<script>
  import * as d3 from 'd3';

  export let data;
  export let width = 640;
  export let height = 400;
  export let marginTop = 20;
  export let marginRight = 20;
  export let marginBottom = 20;
  export let marginLeft = 20;

  $: x = d3.scaleLinear([0, data.length - 1], [marginLeft, width - marginRight]);
  $: y = d3.scaleLinear(d3.extent(data), [height - marginBottom, marginTop]);
  $: line = d3.line((d, i) => x(i), y);
</script>
<svg width={width} height={height}>
  <path fill="none" stroke="currentColor" stroke-width="1.5" d={line(data)} />
  <g fill="white" stroke="currentColor" stroke-width="1.5">
    {#each data as d, i}
      <circle key={i} cx={x(i)} cy={y(d)} r="2.5" />
    {/each}
  </g>
</svg>REPL ↗︎Svelte’s reactive statements ($:) pair nicely with D3 data joins for efficient updates. Below, we use them to render dynamic axes as the data changes.LinePlot.sveltesvelte<script>
  import * as d3 from 'd3';

  export let data;
  export let width = 640;
  export let height = 400;
  export let marginTop = 20;
  export let marginRight = 20;
  export let marginBottom = 30;
  export let marginLeft = 40;

  let gx;
  let gy;

  $: x = d3.scaleLinear([0, data.length - 1], [marginLeft, width - marginRight]);
  $: y = d3.scaleLinear(d3.extent(data), [height - marginBottom, marginTop]);
  $: line = d3.line((d, i) => x(i), y);
  $: d3.select(gy).call(d3.axisLeft(y));
  $: d3.select(gx).call(d3.axisBottom(x));
</script>
<svg width={width} height={height}>
  <g bind:this={gx} transform="translate(0,{height - marginBottom})" />
  <g bind:this={gy} transform="translate({marginLeft},0)" />
  <path fill="none" stroke="currentColor" stroke-width="1.5" d={line(data)} />
  <g fill="white" stroke="currentColor" stroke-width="1.5">
    {#each data as d, i}
      <circle key={i} cx={x(i)} cy={y(d)} r="2.5" />
    {/each}
  </g>
</svg>REPL ↗︎PagerPrevious pageWhat is D3?Next pageAPI index\n\nGetting started ​D3 works in any JavaScript environment.Try D3 online ​The fastest way to get started (and get help) with D3 is on Observable! D3 is available by default in notebooks as part of Observable’s standard library. To create something with D3, return the generated DOM element from a cell. Here is a blank chart to get you started:js{
  // Declare the chart dimensions and margins.
  const width = 640;
  const height = 400;
  const marginTop = 20;
  const marginRight = 20;
  const marginBottom = 30;
  const marginLeft = 40;

  // Declare the x (horizontal position) scale.
  const x = d3.scaleUtc()
      .domain([new Date("2023-01-01"), new Date("2024-01-01")])
      .range([marginLeft, width - marginRight]);

  // Declare the y (vertical position) scale.
  const y = d3.scaleLinear()
      .domain([0, 100])
      .range([height - marginBottom, marginTop]);

  // Create the SVG container.
  const svg = d3.create("svg")
      .attr("width", width)
      .attr("height", height);

  // Add the x-axis.
  svg.append("g")
      .attr("transform", `translate(0,${height - marginBottom})`)
      .call(d3.axisBottom(x));

  // Add the y-axis.
  svg.append("g")
      .attr("transform", `translate(${marginLeft},0)`)
      .call(d3.axisLeft(y));

  // Return the SVG element.
  return svg.node();
}As a more complete example, try one of these starter templates:Area chartBar chartDonut chartHistogramLine chartSee the D3 gallery for more forkable examples.Observable includes a few D3 snippets when you click + to add a cell (type “d3” when the cell menu is open to filter), as well as convenient sample datasets to try out D3 features. Or upload a CSV or JSON file to start playing with your data. You can also fork any of the hundreds of notebooks we’ve published for a head start.Observable is free for public use. Sign up for a Pro account to connect to private databases, collaborate on private notebooks, and more.D3 in vanilla HTML ​In vanilla HTML, you can load D3 from a CDN such as jsDelivr or you can download it locally. We recommend using the CDN-hosted ES module bundle. But for those who need it, we also provide a UMD bundle that exports the d3 global when loaded as a plain script.ESM + CDNUMD + CDNUMD + localhtml<!DOCTYPE html>
<div id="container"></div>
<script type="module">

import * as d3 from "https://cdn.jsdelivr.net/npm/d3@7/+esm";

// Declare the chart dimensions and margins.
const width = 640;
const height = 400;
const marginTop = 20;
const marginRight = 20;
const marginBottom = 30;
const marginLeft = 40;

// Declare the x (horizontal position) scale.
const x = d3.scaleUtc()
    .domain([new Date("2023-01-01"), new Date("2024-01-01")])
    .range([marginLeft, width - marginRight]);

// Declare the y (vertical position) scale.
const y = d3.scaleLinear()
    .domain([0, 100])
    .range([height - marginBottom, marginTop]);

// Create the SVG container.
const svg = d3.create("svg")
    .attr("width", width)
    .attr("height", height);

// Add the x-axis.
svg.append("g")
    .attr("transform", `translate(0,${height - marginBottom})`)
    .call(d3.axisBottom(x));

// Add the y-axis.
svg.append("g")
    .attr("transform", `translate(${marginLeft},0)`)
    .call(d3.axisLeft(y));

// Append the SVG element.
container.append(svg.node());

</script>html<!DOCTYPE html>
<div id="container"></div>
<script src="https://cdn.jsdelivr.net/npm/d3@7"></script>
<script type="module">

// Declare the chart dimensions and margins.
const width = 640;
const height = 400;
const marginTop = 20;
const marginRight = 20;
const marginBottom = 30;
const marginLeft = 40;

// Declare the x (horizontal position) scale.
const x = d3.scaleUtc()
    .domain([new Date("2023-01-01"), new Date("2024-01-01")])
    .range([marginLeft, width - marginRight]);

// Declare the y (vertical position) scale.
const y = d3.scaleLinear()
    .domain([0, 100])
    .range([height - marginBottom, marginTop]);

// Create the SVG container.
const svg = d3.create("svg")
    .attr("width", width)
    .attr("height", height);

// Add the x-axis.
svg.append("g")
    .attr("transform", `translate(0,${height - marginBottom})`)
    .call(d3.axisBottom(x));

// Add the y-axis.
svg.append("g")
    .attr("transform", `translate(${marginLeft},0)`)
    .call(d3.axisLeft(y));

// Append the SVG element.
container.append(svg.node());

</script>html<!DOCTYPE html>
<div id="container"></div>
<script src="d3.js"></script>
<script type="module">

// Declare the chart dimensions and margins.
const width = 640;
const height = 400;
const marginTop = 20;
const marginRight = 20;
const marginBottom = 30;
const marginLeft = 40;

// Declare the x (horizontal position) scale.
const x = d3.scaleUtc()
    .domain([new Date("2023-01-01"), new Date("2024-01-01")])
    .range([marginLeft, width - marginRight]);

// Declare the y (vertical position) scale.
const y = d3.scaleLinear()
    .domain([0, 100])
    .range([height - marginBottom, marginTop]);

// Create the SVG container.
const svg = d3.create("svg")
    .attr("width", width)
    .attr("height", height);

// Add the x-axis.
svg.append("g")
    .attr("transform", `translate(0,${height - marginBottom})`)
    .call(d3.axisBottom(x));

// Add the y-axis.
svg.append("g")
    .attr("transform", `translate(${marginLeft},0)`)
    .call(d3.axisLeft(y));

// Append the SVG element.
container.append(svg.node());

</script>You can also import and destructure individual D3 modules like so:html<script type="module">

import {forceSimulation, forceCollide, forceX} from "https://cdn.jsdelivr.net/npm/d3-force@3/+esm";

const nodes = [{}, {}];
const simulation = forceSimulation(nodes)
    .force("x", forceX())
    .force("collide", forceCollide(5))
    .on("tick", () => console.log(nodes[0].x));

</script>If you’d prefer to run D3 locally (or offline), you can download the UMD bundles of D3 here:d3.v7.jsd3.v7.min.jsThen, create an index.html file as shown above in the UMD + local tab. Use the non-minified bundle for debugging, and the minified bundle for faster performance in production.Installing from npm ​If you’re developing a web application using Node, you can install D3 via yarn, npm, pnpm, or your preferred package manager.yarnnpmpnpmbashyarn add d3bashnpm install d3bashpnpm add d3You can then load D3 into your app as:jsimport * as d3 from "d3";You can instead import specific symbols if you prefer:jsimport {select, selectAll} from "d3";Alternatively you can install and import from D3 submodules:jsimport {mean, median} from "d3-array";TypeScript declarations are available via DefinitelyTyped.D3 in React ​Most D3 modules (including d3-scale, d3-array, d3-interpolate, and d3-format) don’t interact with the DOM, so there is no difference when using them in React. You can use them in JSX for purely declarative visualization, such as the line plot below.LinePlot.jsxjsximport * as d3 from "d3";

export default function LinePlot({
  data,
  width = 640,
  height = 400,
  marginTop = 20,
  marginRight = 20,
  marginBottom = 20,
  marginLeft = 20
}) {
  const x = d3.scaleLinear([0, data.length - 1], [marginLeft, width - marginRight]);
  const y = d3.scaleLinear(d3.extent(data), [height - marginBottom, marginTop]);
  const line = d3.line((d, i) => x(i), y);
  return (
    <svg width={width} height={height}>
      <path fill="none" stroke="currentColor" strokeWidth="1.5" d={line(data)} />
      <g fill="white" stroke="currentColor" strokeWidth="1.5">
        {data.map((d, i) => (<circle key={i} cx={x(i)} cy={y(d)} r="2.5" />))}
      </g>
    </svg>
  );
}Sandbox ↗︎D3 modules that operate on selections (including d3-selection, d3-transition, and d3-axis) do manipulate the DOM, which competes with React’s virtual DOM. In those cases, you can attach a ref to an element and pass it to D3 in a useEffect hook.LinePlot.jsxjsximport * as d3 from "d3";
import {useRef, useEffect} from "react";

export default function LinePlot({
  data,
  width = 640,
  height = 400,
  marginTop = 20,
  marginRight = 20,
  marginBottom = 30,
  marginLeft = 40
}) {
  const gx = useRef();
  const gy = useRef();
  const x = d3.scaleLinear([0, data.length - 1], [marginLeft, width - marginRight]);
  const y = d3.scaleLinear(d3.extent(data), [height - marginBottom, marginTop]);
  const line = d3.line((d, i) => x(i), y);
  useEffect(() => void d3.select(gx.current).call(d3.axisBottom(x)), [gx, x]);
  useEffect(() => void d3.select(gy.current).call(d3.axisLeft(y)), [gy, y]);
  return (
    <svg width={width} height={height}>
      <g ref={gx} transform={`translate(0,${height - marginBottom})`} />
      <g ref={gy} transform={`translate(${marginLeft},0)`} />
      <path fill="none" stroke="currentColor" strokeWidth="1.5" d={line(data)} />
      <g fill="white" stroke="currentColor" strokeWidth="1.5">
        {data.map((d, i) => (<circle key={i} cx={x(i)} cy={y(d)} r="2.5" />))}
      </g>
    </svg>
  );
}Sandbox ↗︎For more guidance using D3 in React, see Amelia Wattenberger’s post.D3 in Svelte ​As with React, you can use Svelte exclusively for rendering if you like, and only use D3 modules that don’t manipulate the DOM. Here is a line plot of an array of numbers that uses d3-shape and d3-scale.LinePlot.sveltesvelte<script>
  import * as d3 from 'd3';

  export let data;
  export let width = 640;
  export let height = 400;
  export let marginTop = 20;
  export let marginRight = 20;
  export let marginBottom = 20;
  export let marginLeft = 20;

  $: x = d3.scaleLinear([0, data.length - 1], [marginLeft, width - marginRight]);
  $: y = d3.scaleLinear(d3.extent(data), [height - marginBottom, marginTop]);
  $: line = d3.line((d, i) => x(i), y);
</script>
<svg width={width} height={height}>
  <path fill="none" stroke="currentColor" stroke-width="1.5" d={line(data)} />
  <g fill="white" stroke="currentColor" stroke-width="1.5">
    {#each data as d, i}
      <circle key={i} cx={x(i)} cy={y(d)} r="2.5" />
    {/each}
  </g>
</svg>REPL ↗︎Svelte’s reactive statements ($:) pair nicely with D3 data joins for efficient updates. Below, we use them to render dynamic axes as the data changes.LinePlot.sveltesvelte<script>
  import * as d3 from 'd3';

  export let data;
  export let width = 640;
  export let height = 400;
  export let marginTop = 20;
  export let marginRight = 20;
  export let marginBottom = 30;
  export let marginLeft = 40;

  let gx;
  let gy;

  $: x = d3.scaleLinear([0, data.length - 1], [marginLeft, width - marginRight]);
  $: y = d3.scaleLinear(d3.extent(data), [height - marginBottom, marginTop]);
  $: line = d3.line((d, i) => x(i), y);
  $: d3.select(gy).call(d3.axisLeft(y));
  $: d3.select(gx).call(d3.axisBottom(x));
</script>
<svg width={width} height={height}>
  <g bind:this={gx} transform="translate(0,{height - marginBottom})" />
  <g bind:this={gy} transform="translate({marginLeft},0)" />
  <path fill="none" stroke="currentColor" stroke-width="1.5" d={line(data)} />
  <g fill="white" stroke="currentColor" stroke-width="1.5">
    {#each data as d, i}
      <circle key={i} cx={x(i)} cy={y(d)} r="2.5" />
    {/each}
  </g>
</svg>REPL ↗︎\n\n\n\nWhat is D3? ​D3 (or D3.js) is a free, open-source JavaScript library for visualizing data. Its low-level approach built on web standards offers unparalleled flexibility in authoring dynamic, data-driven graphics. For more than a decade D3 has powered groundbreaking and award-winning visualizations, become a foundational building block of higher-level chart libraries, and fostered a vibrant community of data practitioners around the world.D3 “slingshotted the field into growth, diversification and creativity that has been unprecedented” and “changed how millions of data visualizations are created across newsrooms, websites, and personal portfolios,” remarked the Information is Beautiful 2022 Test of Time Award. The IEEE VIS 2021 Test of Time Award noted, “By creating a framework that was compelling and easy for web developers to use to author interactive visualizations, the authors have undeniably helped to bring data visualization to the mainstream. [D3] is a cornerstone contribution to this conference specifically and more generally to the success of our field as a whole.”D3 was created by Mike Bostock in 2011. Mike co-authored the D3 paper with Jeff Heer and Vadim Ogievetsky at Stanford. Jason Davies made major contributions to D3 from 2011 to 2013, most notably to D3’s geographic projection system. Philippe Rivière has been a major contributor to D3 and its documentation since 2016. Over the years, countless kind individuals have contributed to D3 by sharing code and ideas, by teaching and answering questions, and by bringing people together to further the practice of visualization. Mike and Philippe now maintain D3 and Observable Plot at Observable.D3 is a low-level toolbox ​D3 is not a charting library in the traditional sense. It has no concept of “charts”. When you visualize data with D3, you compose a variety of primitives.To make a stacked area chart, you might usea CSV parser to load data,a time scale for horizontal position (x),a linear scale for vertical position (y),an ordinal scale and categorical scheme for color,a stack layout for arranging values,an area shape with a linear curve for generating SVG path data,axes for documenting the position encodings, andselections for creating SVG elements.That’s a lot to take in, right? But take a deep breath — you don’t have to learn everything at once. Each piece can be used independently, so you can learn them individually before you fit them together. D3 is not a single monolith but rather a suite of 30 discrete libraries (or “modules”). We bundle these modules together for convenience rather than necessity so your tools are within reach as you iterate on your design.What all’s in the D3 toolbox? We recommend exploring the documentation and examples to get a sense of what’s relevant to you.TIPUnless you need D3’s low-level control, we recommend our high-level sister library: Observable Plot. Whereas a histogram in D3 might require 50 lines of code, Plot can do it in one! Plot’s concise yet expressive API lets you focus more on analyzing and visualizing data instead of web development. You can even combine Plot and D3 for the best of both.D3 is flexible ​Because D3 has no overarching “chart” abstraction, even a basic chart may require a few dozen lines of code. On the upside, all the pieces are laid out in front of you and you have complete control over what happens. You can tailor the visualization to achieve exactly what you want. D3 has no default presentation of your data — there’s just the code you write yourself. (Or copy from an example.)Consider D3 an alternative to “doing everything yourself”, not an alternative to a high-level charting library. If you aren’t satisfied with other tools and you’re thinking of rolling your own charts using SVG or Canvas (or even WebGL), you might as well peruse D3’s toolbox! There’s almost certainly something here that will help you build the chart of your dreams without imposing on your creativity.D3 works with the web ​D3 doesn’t introduce a new graphical representation; instead, you use D3 directly with web standards such as SVG and Canvas.The name “D3” is short for data-driven documents, where documents refers to the Document Object Model (DOM) standard that represents the contents of a webpage. While some of D3’s modules (such as selections and transitions) touch the DOM, others (including scales and shapes) only operate on data. D3 can also be paired with web frameworks such as React, Vue, and Svelte; see the getting started guide for recommendations.D3’s embrace of web standards brings many benefits. For example, you can use external stylesheets to alter the appearance of charts (even in response to media queries, say for responsive charts or dark mode); you can use the debugger and element inspector to review what your code is doing; and D3’s synchronous, imperative evaluation model — calling selection.attr immediately mutates the DOM — can make it easier to debug than frameworks with complex asynchronous runtimes.D3 is for bespoke visualization ​D3 makes things possible, not necessarily easy; even simple things that should be easy are often not. To paraphrase Amanda Cox: “Use D3 if you think it’s perfectly normal to write a hundred lines of code for a bar chart.”If you need maximal expressiveness for your bespoke visualization, you should consider D3. D3 makes sense for media organizations such as The New York Times or The Pudding, where a single graphic may be seen by a million readers, and where a team of editors can work together to advance the state of the art in visual communication.On the other hand, D3 is overkill for throwing together a private dashboard or a one-off analysis. Don’t get seduced by whizbang examples: many of them took an immense effort to implement! If you’re constrained by time (and who isn’t?), you’d likely produce a better visualization or analysis with Observable Plot.D3 is for dynamic visualization ​D3’s most novel concept is its data join: given a set of data and a set of DOM elements, the data join allows you to apply separate operations for entering, updating, and exiting elements. If you’re only creating static charts (charts that don’t animate or respond to user input), you may find this concept unintuitive or even bizarre because it’s not needed.The data join exists so that you can control exactly what happens when your data changes and update the display in response. This direct control allows extremely performant updates — you only touch the elements and attributes that need changing, without diffing the DOM — and smooth animated transitions between states. D3 shines for dynamic, interactive visualizations. (Try option-clicking the state toggles in “512 Paths to the White House” from 2012. Really.)\n\nSearchK7.9.0GitHub️ 110.0kOn this pageWhat is D3? ​D3 (or D3.js) is a free, open-source JavaScript library for visualizing data. Its low-level approach built on web standards offers unparalleled flexibility in authoring dynamic, data-driven graphics. For more than a decade D3 has powered groundbreaking and award-winning visualizations, become a foundational building block of higher-level chart libraries, and fostered a vibrant community of data practitioners around the world.D3 “slingshotted the field into growth, diversification and creativity that has been unprecedented” and “changed how millions of data visualizations are created across newsrooms, websites, and personal portfolios,” remarked the Information is Beautiful 2022 Test of Time Award. The IEEE VIS 2021 Test of Time Award noted, “By creating a framework that was compelling and easy for web developers to use to author interactive visualizations, the authors have undeniably helped to bring data visualization to the mainstream. [D3] is a cornerstone contribution to this conference specifically and more generally to the success of our field as a whole.”D3 was created by Mike Bostock in 2011. Mike co-authored the D3 paper with Jeff Heer and Vadim Ogievetsky at Stanford. Jason Davies made major contributions to D3 from 2011 to 2013, most notably to D3’s geographic projection system. Philippe Rivière has been a major contributor to D3 and its documentation since 2016. Over the years, countless kind individuals have contributed to D3 by sharing code and ideas, by teaching and answering questions, and by bringing people together to further the practice of visualization. Mike and Philippe now maintain D3 and Observable Plot at Observable.D3 is a low-level toolbox ​D3 is not a charting library in the traditional sense. It has no concept of “charts”. When you visualize data with D3, you compose a variety of primitives.To make a stacked area chart, you might usea CSV parser to load data,a time scale for horizontal position (x),a linear scale for vertical position (y),an ordinal scale and categorical scheme for color,a stack layout for arranging values,an area shape with a linear curve for generating SVG path data,axes for documenting the position encodings, andselections for creating SVG elements.That’s a lot to take in, right? But take a deep breath — you don’t have to learn everything at once. Each piece can be used independently, so you can learn them individually before you fit them together. D3 is not a single monolith but rather a suite of 30 discrete libraries (or “modules”). We bundle these modules together for convenience rather than necessity so your tools are within reach as you iterate on your design.What all’s in the D3 toolbox? We recommend exploring the documentation and examples to get a sense of what’s relevant to you.TIPUnless you need D3’s low-level control, we recommend our high-level sister library: Observable Plot. Whereas a histogram in D3 might require 50 lines of code, Plot can do it in one! Plot’s concise yet expressive API lets you focus more on analyzing and visualizing data instead of web development. You can even combine Plot and D3 for the best of both.D3 is flexible ​Because D3 has no overarching “chart” abstraction, even a basic chart may require a few dozen lines of code. On the upside, all the pieces are laid out in front of you and you have complete control over what happens. You can tailor the visualization to achieve exactly what you want. D3 has no default presentation of your data — there’s just the code you write yourself. (Or copy from an example.)Consider D3 an alternative to “doing everything yourself”, not an alternative to a high-level charting library. If you aren’t satisfied with other tools and you’re thinking of rolling your own charts using SVG or Canvas (or even WebGL), you might as well peruse D3’s toolbox! There’s almost certainly something here that will help you build the chart of your dreams without imposing on your creativity.D3 works with the web ​D3 doesn’t introduce a new graphical representation; instead, you use D3 directly with web standards such as SVG and Canvas.The name “D3” is short for data-driven documents, where documents refers to the Document Object Model (DOM) standard that represents the contents of a webpage. While some of D3’s modules (such as selections and transitions) touch the DOM, others (including scales and shapes) only operate on data. D3 can also be paired with web frameworks such as React, Vue, and Svelte; see the getting started guide for recommendations.D3’s embrace of web standards brings many benefits. For example, you can use external stylesheets to alter the appearance of charts (even in response to media queries, say for responsive charts or dark mode); you can use the debugger and element inspector to review what your code is doing; and D3’s synchronous, imperative evaluation model — calling selection.attr immediately mutates the DOM — can make it easier to debug than frameworks with complex asynchronous runtimes.D3 is for bespoke visualization ​D3 makes things possible, not necessarily easy; even simple things that should be easy are often not. To paraphrase Amanda Cox: “Use D3 if you think it’s perfectly normal to write a hundred lines of code for a bar chart.”If you need maximal expressiveness for your bespoke visualization, you should consider D3. D3 makes sense for media organizations such as The New York Times or The Pudding, where a single graphic may be seen by a million readers, and where a team of editors can work together to advance the state of the art in visual communication.On the other hand, D3 is overkill for throwing together a private dashboard or a one-off analysis. Don’t get seduced by whizbang examples: many of them took an immense effort to implement! If you’re constrained by time (and who isn’t?), you’d likely produce a better visualization or analysis with Observable Plot.D3 is for dynamic visualization ​D3’s most novel concept is its data join: given a set of data and a set of DOM elements, the data join allows you to apply separate operations for entering, updating, and exiting elements. If you’re only creating static charts (charts that don’t animate or respond to user input), you may find this concept unintuitive or even bizarre because it’s not needed.The data join exists so that you can control exactly what happens when your data changes and update the display in response. This direct control allows extremely performant updates — you only touch the elements and attributes that need changing, without diffing the DOM — and smooth animated transitions between states. D3 shines for dynamic, interactive visualizations. (Try option-clicking the state toggles in “512 Paths to the White House” from 2012. Really.)PagerNext pageGetting started\n\nWhat is D3? ​D3 (or D3.js) is a free, open-source JavaScript library for visualizing data. Its low-level approach built on web standards offers unparalleled flexibility in authoring dynamic, data-driven graphics. For more than a decade D3 has powered groundbreaking and award-winning visualizations, become a foundational building block of higher-level chart libraries, and fostered a vibrant community of data practitioners around the world.D3 “slingshotted the field into growth, diversification and creativity that has been unprecedented” and “changed how millions of data visualizations are created across newsrooms, websites, and personal portfolios,” remarked the Information is Beautiful 2022 Test of Time Award. The IEEE VIS 2021 Test of Time Award noted, “By creating a framework that was compelling and easy for web developers to use to author interactive visualizations, the authors have undeniably helped to bring data visualization to the mainstream. [D3] is a cornerstone contribution to this conference specifically and more generally to the success of our field as a whole.”D3 was created by Mike Bostock in 2011. Mike co-authored the D3 paper with Jeff Heer and Vadim Ogievetsky at Stanford. Jason Davies made major contributions to D3 from 2011 to 2013, most notably to D3’s geographic projection system. Philippe Rivière has been a major contributor to D3 and its documentation since 2016. Over the years, countless kind individuals have contributed to D3 by sharing code and ideas, by teaching and answering questions, and by bringing people together to further the practice of visualization. Mike and Philippe now maintain D3 and Observable Plot at Observable.D3 is a low-level toolbox ​D3 is not a charting library in the traditional sense. It has no concept of “charts”. When you visualize data with D3, you compose a variety of primitives.To make a stacked area chart, you might usea CSV parser to load data,a time scale for horizontal position (x),a linear scale for vertical position (y),an ordinal scale and categorical scheme for color,a stack layout for arranging values,an area shape with a linear curve for generating SVG path data,axes for documenting the position encodings, andselections for creating SVG elements.That’s a lot to take in, right? But take a deep breath — you don’t have to learn everything at once. Each piece can be used independently, so you can learn them individually before you fit them together. D3 is not a single monolith but rather a suite of 30 discrete libraries (or “modules”). We bundle these modules together for convenience rather than necessity so your tools are within reach as you iterate on your design.What all’s in the D3 toolbox? We recommend exploring the documentation and examples to get a sense of what’s relevant to you.TIPUnless you need D3’s low-level control, we recommend our high-level sister library: Observable Plot. Whereas a histogram in D3 might require 50 lines of code, Plot can do it in one! Plot’s concise yet expressive API lets you focus more on analyzing and visualizing data instead of web development. You can even combine Plot and D3 for the best of both.D3 is flexible ​Because D3 has no overarching “chart” abstraction, even a basic chart may require a few dozen lines of code. On the upside, all the pieces are laid out in front of you and you have complete control over what happens. You can tailor the visualization to achieve exactly what you want. D3 has no default presentation of your data — there’s just the code you write yourself. (Or copy from an example.)Consider D3 an alternative to “doing everything yourself”, not an alternative to a high-level charting library. If you aren’t satisfied with other tools and you’re thinking of rolling your own charts using SVG or Canvas (or even WebGL), you might as well peruse D3’s toolbox! There’s almost certainly something here that will help you build the chart of your dreams without imposing on your creativity.D3 works with the web ​D3 doesn’t introduce a new graphical representation; instead, you use D3 directly with web standards such as SVG and Canvas.The name “D3” is short for data-driven documents, where documents refers to the Document Object Model (DOM) standard that represents the contents of a webpage. While some of D3’s modules (such as selections and transitions) touch the DOM, others (including scales and shapes) only operate on data. D3 can also be paired with web frameworks such as React, Vue, and Svelte; see the getting started guide for recommendations.D3’s embrace of web standards brings many benefits. For example, you can use external stylesheets to alter the appearance of charts (even in response to media queries, say for responsive charts or dark mode); you can use the debugger and element inspector to review what your code is doing; and D3’s synchronous, imperative evaluation model — calling selection.attr immediately mutates the DOM — can make it easier to debug than frameworks with complex asynchronous runtimes.D3 is for bespoke visualization ​D3 makes things possible, not necessarily easy; even simple things that should be easy are often not. To paraphrase Amanda Cox: “Use D3 if you think it’s perfectly normal to write a hundred lines of code for a bar chart.”If you need maximal expressiveness for your bespoke visualization, you should consider D3. D3 makes sense for media organizations such as The New York Times or The Pudding, where a single graphic may be seen by a million readers, and where a team of editors can work together to advance the state of the art in visual communication.On the other hand, D3 is overkill for throwing together a private dashboard or a one-off analysis. Don’t get seduced by whizbang examples: many of them took an immense effort to implement! If you’re constrained by time (and who isn’t?), you’d likely produce a better visualization or analysis with Observable Plot.D3 is for dynamic visualization ​D3’s most novel concept is its data join: given a set of data and a set of DOM elements, the data join allows you to apply separate operations for entering, updating, and exiting elements. If you’re only creating static charts (charts that don’t animate or respond to user input), you may find this concept unintuitive or even bizarre because it’s not needed.The data join exists so that you can control exactly what happens when your data changes and update the display in response. This direct control allows extremely performant updates — you only touch the elements and attributes that need changing, without diffing the DOM — and smooth animated transitions between states. D3 shines for dynamic, interactive visualizations. (Try option-clicking the state toggles in “512 Paths to the White House” from 2012. Really.)\n\n\n\nWhat is D3? ​D3 (or D3.js) is a free, open-source JavaScript library for visualizing data. Its low-level approach built on web standards offers unparalleled flexibility in authoring dynamic, data-driven graphics. For more than a decade D3 has powered groundbreaking and award-winning visualizations, become a foundational building block of higher-level chart libraries, and fostered a vibrant community of data practitioners around the world.D3 “slingshotted the field into growth, diversification and creativity that has been unprecedented” and “changed how millions of data visualizations are created across newsrooms, websites, and personal portfolios,” remarked the Information is Beautiful 2022 Test of Time Award. The IEEE VIS 2021 Test of Time Award noted, “By creating a framework that was compelling and easy for web developers to use to author interactive visualizations, the authors have undeniably helped to bring data visualization to the mainstream. [D3] is a cornerstone contribution to this conference specifically and more generally to the success of our field as a whole.”D3 was created by Mike Bostock in 2011. Mike co-authored the D3 paper with Jeff Heer and Vadim Ogievetsky at Stanford. Jason Davies made major contributions to D3 from 2011 to 2013, most notably to D3’s geographic projection system. Philippe Rivière has been a major contributor to D3 and its documentation since 2016. Over the years, countless kind individuals have contributed to D3 by sharing code and ideas, by teaching and answering questions, and by bringing people together to further the practice of visualization. Mike and Philippe now maintain D3 and Observable Plot at Observable.D3 is a low-level toolbox ​D3 is not a charting library in the traditional sense. It has no concept of “charts”. When you visualize data with D3, you compose a variety of primitives.To make a stacked area chart, you might usea CSV parser to load data,a time scale for horizontal position (x),a linear scale for vertical position (y),an ordinal scale and categorical scheme for color,a stack layout for arranging values,an area shape with a linear curve for generating SVG path data,axes for documenting the position encodings, andselections for creating SVG elements.That’s a lot to take in, right? But take a deep breath — you don’t have to learn everything at once. Each piece can be used independently, so you can learn them individually before you fit them together. D3 is not a single monolith but rather a suite of 30 discrete libraries (or “modules”). We bundle these modules together for convenience rather than necessity so your tools are within reach as you iterate on your design.What all’s in the D3 toolbox? We recommend exploring the documentation and examples to get a sense of what’s relevant to you.TIPUnless you need D3’s low-level control, we recommend our high-level sister library: Observable Plot. Whereas a histogram in D3 might require 50 lines of code, Plot can do it in one! Plot’s concise yet expressive API lets you focus more on analyzing and visualizing data instead of web development. You can even combine Plot and D3 for the best of both.D3 is flexible ​Because D3 has no overarching “chart” abstraction, even a basic chart may require a few dozen lines of code. On the upside, all the pieces are laid out in front of you and you have complete control over what happens. You can tailor the visualization to achieve exactly what you want. D3 has no default presentation of your data — there’s just the code you write yourself. (Or copy from an example.)Consider D3 an alternative to “doing everything yourself”, not an alternative to a high-level charting library. If you aren’t satisfied with other tools and you’re thinking of rolling your own charts using SVG or Canvas (or even WebGL), you might as well peruse D3’s toolbox! There’s almost certainly something here that will help you build the chart of your dreams without imposing on your creativity.D3 works with the web ​D3 doesn’t introduce a new graphical representation; instead, you use D3 directly with web standards such as SVG and Canvas.The name “D3” is short for data-driven documents, where documents refers to the Document Object Model (DOM) standard that represents the contents of a webpage. While some of D3’s modules (such as selections and transitions) touch the DOM, others (including scales and shapes) only operate on data. D3 can also be paired with web frameworks such as React, Vue, and Svelte; see the getting started guide for recommendations.D3’s embrace of web standards brings many benefits. For example, you can use external stylesheets to alter the appearance of charts (even in response to media queries, say for responsive charts or dark mode); you can use the debugger and element inspector to review what your code is doing; and D3’s synchronous, imperative evaluation model — calling selection.attr immediately mutates the DOM — can make it easier to debug than frameworks with complex asynchronous runtimes.D3 is for bespoke visualization ​D3 makes things possible, not necessarily easy; even simple things that should be easy are often not. To paraphrase Amanda Cox: “Use D3 if you think it’s perfectly normal to write a hundred lines of code for a bar chart.”If you need maximal expressiveness for your bespoke visualization, you should consider D3. D3 makes sense for media organizations such as The New York Times or The Pudding, where a single graphic may be seen by a million readers, and where a team of editors can work together to advance the state of the art in visual communication.On the other hand, D3 is overkill for throwing together a private dashboard or a one-off analysis. Don’t get seduced by whizbang examples: many of them took an immense effort to implement! If you’re constrained by time (and who isn’t?), you’d likely produce a better visualization or analysis with Observable Plot.D3 is for dynamic visualization ​D3’s most novel concept is its data join: given a set of data and a set of DOM elements, the data join allows you to apply separate operations for entering, updating, and exiting elements. If you’re only creating static charts (charts that don’t animate or respond to user input), you may find this concept unintuitive or even bizarre because it’s not needed.The data join exists so that you can control exactly what happens when your data changes and update the display in response. This direct control allows extremely performant updates — you only touch the elements and attributes that need changing, without diffing the DOM — and smooth animated transitions between states. D3 shines for dynamic, interactive visualizations. (Try option-clicking the state toggles in “512 Paths to the White House” from 2012. Really.)\n\nSearchK7.9.0GitHub️ 110.0kOn this pageWhat is D3? ​D3 (or D3.js) is a free, open-source JavaScript library for visualizing data. Its low-level approach built on web standards offers unparalleled flexibility in authoring dynamic, data-driven graphics. For more than a decade D3 has powered groundbreaking and award-winning visualizations, become a foundational building block of higher-level chart libraries, and fostered a vibrant community of data practitioners around the world.D3 “slingshotted the field into growth, diversification and creativity that has been unprecedented” and “changed how millions of data visualizations are created across newsrooms, websites, and personal portfolios,” remarked the Information is Beautiful 2022 Test of Time Award. The IEEE VIS 2021 Test of Time Award noted, “By creating a framework that was compelling and easy for web developers to use to author interactive visualizations, the authors have undeniably helped to bring data visualization to the mainstream. [D3] is a cornerstone contribution to this conference specifically and more generally to the success of our field as a whole.”D3 was created by Mike Bostock in 2011. Mike co-authored the D3 paper with Jeff Heer and Vadim Ogievetsky at Stanford. Jason Davies made major contributions to D3 from 2011 to 2013, most notably to D3’s geographic projection system. Philippe Rivière has been a major contributor to D3 and its documentation since 2016. Over the years, countless kind individuals have contributed to D3 by sharing code and ideas, by teaching and answering questions, and by bringing people together to further the practice of visualization. Mike and Philippe now maintain D3 and Observable Plot at Observable.D3 is a low-level toolbox ​D3 is not a charting library in the traditional sense. It has no concept of “charts”. When you visualize data with D3, you compose a variety of primitives.To make a stacked area chart, you might usea CSV parser to load data,a time scale for horizontal position (x),a linear scale for vertical position (y),an ordinal scale and categorical scheme for color,a stack layout for arranging values,an area shape with a linear curve for generating SVG path data,axes for documenting the position encodings, andselections for creating SVG elements.That’s a lot to take in, right? But take a deep breath — you don’t have to learn everything at once. Each piece can be used independently, so you can learn them individually before you fit them together. D3 is not a single monolith but rather a suite of 30 discrete libraries (or “modules”). We bundle these modules together for convenience rather than necessity so your tools are within reach as you iterate on your design.What all’s in the D3 toolbox? We recommend exploring the documentation and examples to get a sense of what’s relevant to you.TIPUnless you need D3’s low-level control, we recommend our high-level sister library: Observable Plot. Whereas a histogram in D3 might require 50 lines of code, Plot can do it in one! Plot’s concise yet expressive API lets you focus more on analyzing and visualizing data instead of web development. You can even combine Plot and D3 for the best of both.D3 is flexible ​Because D3 has no overarching “chart” abstraction, even a basic chart may require a few dozen lines of code. On the upside, all the pieces are laid out in front of you and you have complete control over what happens. You can tailor the visualization to achieve exactly what you want. D3 has no default presentation of your data — there’s just the code you write yourself. (Or copy from an example.)Consider D3 an alternative to “doing everything yourself”, not an alternative to a high-level charting library. If you aren’t satisfied with other tools and you’re thinking of rolling your own charts using SVG or Canvas (or even WebGL), you might as well peruse D3’s toolbox! There’s almost certainly something here that will help you build the chart of your dreams without imposing on your creativity.D3 works with the web ​D3 doesn’t introduce a new graphical representation; instead, you use D3 directly with web standards such as SVG and Canvas.The name “D3” is short for data-driven documents, where documents refers to the Document Object Model (DOM) standard that represents the contents of a webpage. While some of D3’s modules (such as selections and transitions) touch the DOM, others (including scales and shapes) only operate on data. D3 can also be paired with web frameworks such as React, Vue, and Svelte; see the getting started guide for recommendations.D3’s embrace of web standards brings many benefits. For example, you can use external stylesheets to alter the appearance of charts (even in response to media queries, say for responsive charts or dark mode); you can use the debugger and element inspector to review what your code is doing; and D3’s synchronous, imperative evaluation model — calling selection.attr immediately mutates the DOM — can make it easier to debug than frameworks with complex asynchronous runtimes.D3 is for bespoke visualization ​D3 makes things possible, not necessarily easy; even simple things that should be easy are often not. To paraphrase Amanda Cox: “Use D3 if you think it’s perfectly normal to write a hundred lines of code for a bar chart.”If you need maximal expressiveness for your bespoke visualization, you should consider D3. D3 makes sense for media organizations such as The New York Times or The Pudding, where a single graphic may be seen by a million readers, and where a team of editors can work together to advance the state of the art in visual communication.On the other hand, D3 is overkill for throwing together a private dashboard or a one-off analysis. Don’t get seduced by whizbang examples: many of them took an immense effort to implement! If you’re constrained by time (and who isn’t?), you’d likely produce a better visualization or analysis with Observable Plot.D3 is for dynamic visualization ​D3’s most novel concept is its data join: given a set of data and a set of DOM elements, the data join allows you to apply separate operations for entering, updating, and exiting elements. If you’re only creating static charts (charts that don’t animate or respond to user input), you may find this concept unintuitive or even bizarre because it’s not needed.The data join exists so that you can control exactly what happens when your data changes and update the display in response. This direct control allows extremely performant updates — you only touch the elements and attributes that need changing, without diffing the DOM — and smooth animated transitions between states. D3 shines for dynamic, interactive visualizations. (Try option-clicking the state toggles in “512 Paths to the White House” from 2012. Really.)PagerNext pageGetting started\n\nWhat is D3? ​D3 (or D3.js) is a free, open-source JavaScript library for visualizing data. Its low-level approach built on web standards offers unparalleled flexibility in authoring dynamic, data-driven graphics. For more than a decade D3 has powered groundbreaking and award-winning visualizations, become a foundational building block of higher-level chart libraries, and fostered a vibrant community of data practitioners around the world.D3 “slingshotted the field into growth, diversification and creativity that has been unprecedented” and “changed how millions of data visualizations are created across newsrooms, websites, and personal portfolios,” remarked the Information is Beautiful 2022 Test of Time Award. The IEEE VIS 2021 Test of Time Award noted, “By creating a framework that was compelling and easy for web developers to use to author interactive visualizations, the authors have undeniably helped to bring data visualization to the mainstream. [D3] is a cornerstone contribution to this conference specifically and more generally to the success of our field as a whole.”D3 was created by Mike Bostock in 2011. Mike co-authored the D3 paper with Jeff Heer and Vadim Ogievetsky at Stanford. Jason Davies made major contributions to D3 from 2011 to 2013, most notably to D3’s geographic projection system. Philippe Rivière has been a major contributor to D3 and its documentation since 2016. Over the years, countless kind individuals have contributed to D3 by sharing code and ideas, by teaching and answering questions, and by bringing people together to further the practice of visualization. Mike and Philippe now maintain D3 and Observable Plot at Observable.D3 is a low-level toolbox ​D3 is not a charting library in the traditional sense. It has no concept of “charts”. When you visualize data with D3, you compose a variety of primitives.To make a stacked area chart, you might usea CSV parser to load data,a time scale for horizontal position (x),a linear scale for vertical position (y),an ordinal scale and categorical scheme for color,a stack layout for arranging values,an area shape with a linear curve for generating SVG path data,axes for documenting the position encodings, andselections for creating SVG elements.That’s a lot to take in, right? But take a deep breath — you don’t have to learn everything at once. Each piece can be used independently, so you can learn them individually before you fit them together. D3 is not a single monolith but rather a suite of 30 discrete libraries (or “modules”). We bundle these modules together for convenience rather than necessity so your tools are within reach as you iterate on your design.What all’s in the D3 toolbox? We recommend exploring the documentation and examples to get a sense of what’s relevant to you.TIPUnless you need D3’s low-level control, we recommend our high-level sister library: Observable Plot. Whereas a histogram in D3 might require 50 lines of code, Plot can do it in one! Plot’s concise yet expressive API lets you focus more on analyzing and visualizing data instead of web development. You can even combine Plot and D3 for the best of both.D3 is flexible ​Because D3 has no overarching “chart” abstraction, even a basic chart may require a few dozen lines of code. On the upside, all the pieces are laid out in front of you and you have complete control over what happens. You can tailor the visualization to achieve exactly what you want. D3 has no default presentation of your data — there’s just the code you write yourself. (Or copy from an example.)Consider D3 an alternative to “doing everything yourself”, not an alternative to a high-level charting library. If you aren’t satisfied with other tools and you’re thinking of rolling your own charts using SVG or Canvas (or even WebGL), you might as well peruse D3’s toolbox! There’s almost certainly something here that will help you build the chart of your dreams without imposing on your creativity.D3 works with the web ​D3 doesn’t introduce a new graphical representation; instead, you use D3 directly with web standards such as SVG and Canvas.The name “D3” is short for data-driven documents, where documents refers to the Document Object Model (DOM) standard that represents the contents of a webpage. While some of D3’s modules (such as selections and transitions) touch the DOM, others (including scales and shapes) only operate on data. D3 can also be paired with web frameworks such as React, Vue, and Svelte; see the getting started guide for recommendations.D3’s embrace of web standards brings many benefits. For example, you can use external stylesheets to alter the appearance of charts (even in response to media queries, say for responsive charts or dark mode); you can use the debugger and element inspector to review what your code is doing; and D3’s synchronous, imperative evaluation model — calling selection.attr immediately mutates the DOM — can make it easier to debug than frameworks with complex asynchronous runtimes.D3 is for bespoke visualization ​D3 makes things possible, not necessarily easy; even simple things that should be easy are often not. To paraphrase Amanda Cox: “Use D3 if you think it’s perfectly normal to write a hundred lines of code for a bar chart.”If you need maximal expressiveness for your bespoke visualization, you should consider D3. D3 makes sense for media organizations such as The New York Times or The Pudding, where a single graphic may be seen by a million readers, and where a team of editors can work together to advance the state of the art in visual communication.On the other hand, D3 is overkill for throwing together a private dashboard or a one-off analysis. Don’t get seduced by whizbang examples: many of them took an immense effort to implement! If you’re constrained by time (and who isn’t?), you’d likely produce a better visualization or analysis with Observable Plot.D3 is for dynamic visualization ​D3’s most novel concept is its data join: given a set of data and a set of DOM elements, the data join allows you to apply separate operations for entering, updating, and exiting elements. If you’re only creating static charts (charts that don’t animate or respond to user input), you may find this concept unintuitive or even bizarre because it’s not needed.The data join exists so that you can control exactly what happens when your data changes and update the display in response. This direct control allows extremely performant updates — you only touch the elements and attributes that need changing, without diffing the DOM — and smooth animated transitions between states. D3 shines for dynamic, interactive visualizations. (Try option-clicking the state toggles in “512 Paths to the White House” from 2012. Really.)\n\n\n\nWhat is D3? ​D3 (or D3.js) is a free, open-source JavaScript library for visualizing data. Its low-level approach built on web standards offers unparalleled flexibility in authoring dynamic, data-driven graphics. For more than a decade D3 has powered groundbreaking and award-winning visualizations, become a foundational building block of higher-level chart libraries, and fostered a vibrant community of data practitioners around the world.D3 “slingshotted the field into growth, diversification and creativity that has been unprecedented” and “changed how millions of data visualizations are created across newsrooms, websites, and personal portfolios,” remarked the Information is Beautiful 2022 Test of Time Award. The IEEE VIS 2021 Test of Time Award noted, “By creating a framework that was compelling and easy for web developers to use to author interactive visualizations, the authors have undeniably helped to bring data visualization to the mainstream. [D3] is a cornerstone contribution to this conference specifically and more generally to the success of our field as a whole.”D3 was created by Mike Bostock in 2011. Mike co-authored the D3 paper with Jeff Heer and Vadim Ogievetsky at Stanford. Jason Davies made major contributions to D3 from 2011 to 2013, most notably to D3’s geographic projection system. Philippe Rivière has been a major contributor to D3 and its documentation since 2016. Over the years, countless kind individuals have contributed to D3 by sharing code and ideas, by teaching and answering questions, and by bringing people together to further the practice of visualization. Mike and Philippe now maintain D3 and Observable Plot at Observable.D3 is a low-level toolbox ​D3 is not a charting library in the traditional sense. It has no concept of “charts”. When you visualize data with D3, you compose a variety of primitives.To make a stacked area chart, you might usea CSV parser to load data,a time scale for horizontal position (x),a linear scale for vertical position (y),an ordinal scale and categorical scheme for color,a stack layout for arranging values,an area shape with a linear curve for generating SVG path data,axes for documenting the position encodings, andselections for creating SVG elements.That’s a lot to take in, right? But take a deep breath — you don’t have to learn everything at once. Each piece can be used independently, so you can learn them individually before you fit them together. D3 is not a single monolith but rather a suite of 30 discrete libraries (or “modules”). We bundle these modules together for convenience rather than necessity so your tools are within reach as you iterate on your design.What all’s in the D3 toolbox? We recommend exploring the documentation and examples to get a sense of what’s relevant to you.TIPUnless you need D3’s low-level control, we recommend our high-level sister library: Observable Plot. Whereas a histogram in D3 might require 50 lines of code, Plot can do it in one! Plot’s concise yet expressive API lets you focus more on analyzing and visualizing data instead of web development. You can even combine Plot and D3 for the best of both.D3 is flexible ​Because D3 has no overarching “chart” abstraction, even a basic chart may require a few dozen lines of code. On the upside, all the pieces are laid out in front of you and you have complete control over what happens. You can tailor the visualization to achieve exactly what you want. D3 has no default presentation of your data — there’s just the code you write yourself. (Or copy from an example.)Consider D3 an alternative to “doing everything yourself”, not an alternative to a high-level charting library. If you aren’t satisfied with other tools and you’re thinking of rolling your own charts using SVG or Canvas (or even WebGL), you might as well peruse D3’s toolbox! There’s almost certainly something here that will help you build the chart of your dreams without imposing on your creativity.D3 works with the web ​D3 doesn’t introduce a new graphical representation; instead, you use D3 directly with web standards such as SVG and Canvas.The name “D3” is short for data-driven documents, where documents refers to the Document Object Model (DOM) standard that represents the contents of a webpage. While some of D3’s modules (such as selections and transitions) touch the DOM, others (including scales and shapes) only operate on data. D3 can also be paired with web frameworks such as React, Vue, and Svelte; see the getting started guide for recommendations.D3’s embrace of web standards brings many benefits. For example, you can use external stylesheets to alter the appearance of charts (even in response to media queries, say for responsive charts or dark mode); you can use the debugger and element inspector to review what your code is doing; and D3’s synchronous, imperative evaluation model — calling selection.attr immediately mutates the DOM — can make it easier to debug than frameworks with complex asynchronous runtimes.D3 is for bespoke visualization ​D3 makes things possible, not necessarily easy; even simple things that should be easy are often not. To paraphrase Amanda Cox: “Use D3 if you think it’s perfectly normal to write a hundred lines of code for a bar chart.”If you need maximal expressiveness for your bespoke visualization, you should consider D3. D3 makes sense for media organizations such as The New York Times or The Pudding, where a single graphic may be seen by a million readers, and where a team of editors can work together to advance the state of the art in visual communication.On the other hand, D3 is overkill for throwing together a private dashboard or a one-off analysis. Don’t get seduced by whizbang examples: many of them took an immense effort to implement! If you’re constrained by time (and who isn’t?), you’d likely produce a better visualization or analysis with Observable Plot.D3 is for dynamic visualization ​D3’s most novel concept is its data join: given a set of data and a set of DOM elements, the data join allows you to apply separate operations for entering, updating, and exiting elements. If you’re only creating static charts (charts that don’t animate or respond to user input), you may find this concept unintuitive or even bizarre because it’s not needed.The data join exists so that you can control exactly what happens when your data changes and update the display in response. This direct control allows extremely performant updates — you only touch the elements and attributes that need changing, without diffing the DOM — and smooth animated transitions between states. D3 shines for dynamic, interactive visualizations. (Try option-clicking the state toggles in “512 Paths to the White House” from 2012. Really.)\n\nSearchK7.9.0GitHub️ 110.0kOn this pageWhat is D3? ​D3 (or D3.js) is a free, open-source JavaScript library for visualizing data. Its low-level approach built on web standards offers unparalleled flexibility in authoring dynamic, data-driven graphics. For more than a decade D3 has powered groundbreaking and award-winning visualizations, become a foundational building block of higher-level chart libraries, and fostered a vibrant community of data practitioners around the world.D3 “slingshotted the field into growth, diversification and creativity that has been unprecedented” and “changed how millions of data visualizations are created across newsrooms, websites, and personal portfolios,” remarked the Information is Beautiful 2022 Test of Time Award. The IEEE VIS 2021 Test of Time Award noted, “By creating a framework that was compelling and easy for web developers to use to author interactive visualizations, the authors have undeniably helped to bring data visualization to the mainstream. [D3] is a cornerstone contribution to this conference specifically and more generally to the success of our field as a whole.”D3 was created by Mike Bostock in 2011. Mike co-authored the D3 paper with Jeff Heer and Vadim Ogievetsky at Stanford. Jason Davies made major contributions to D3 from 2011 to 2013, most notably to D3’s geographic projection system. Philippe Rivière has been a major contributor to D3 and its documentation since 2016. Over the years, countless kind individuals have contributed to D3 by sharing code and ideas, by teaching and answering questions, and by bringing people together to further the practice of visualization. Mike and Philippe now maintain D3 and Observable Plot at Observable.D3 is a low-level toolbox ​D3 is not a charting library in the traditional sense. It has no concept of “charts”. When you visualize data with D3, you compose a variety of primitives.To make a stacked area chart, you might usea CSV parser to load data,a time scale for horizontal position (x),a linear scale for vertical position (y),an ordinal scale and categorical scheme for color,a stack layout for arranging values,an area shape with a linear curve for generating SVG path data,axes for documenting the position encodings, andselections for creating SVG elements.That’s a lot to take in, right? But take a deep breath — you don’t have to learn everything at once. Each piece can be used independently, so you can learn them individually before you fit them together. D3 is not a single monolith but rather a suite of 30 discrete libraries (or “modules”). We bundle these modules together for convenience rather than necessity so your tools are within reach as you iterate on your design.What all’s in the D3 toolbox? We recommend exploring the documentation and examples to get a sense of what’s relevant to you.TIPUnless you need D3’s low-level control, we recommend our high-level sister library: Observable Plot. Whereas a histogram in D3 might require 50 lines of code, Plot can do it in one! Plot’s concise yet expressive API lets you focus more on analyzing and visualizing data instead of web development. You can even combine Plot and D3 for the best of both.D3 is flexible ​Because D3 has no overarching “chart” abstraction, even a basic chart may require a few dozen lines of code. On the upside, all the pieces are laid out in front of you and you have complete control over what happens. You can tailor the visualization to achieve exactly what you want. D3 has no default presentation of your data — there’s just the code you write yourself. (Or copy from an example.)Consider D3 an alternative to “doing everything yourself”, not an alternative to a high-level charting library. If you aren’t satisfied with other tools and you’re thinking of rolling your own charts using SVG or Canvas (or even WebGL), you might as well peruse D3’s toolbox! There’s almost certainly something here that will help you build the chart of your dreams without imposing on your creativity.D3 works with the web ​D3 doesn’t introduce a new graphical representation; instead, you use D3 directly with web standards such as SVG and Canvas.The name “D3” is short for data-driven documents, where documents refers to the Document Object Model (DOM) standard that represents the contents of a webpage. While some of D3’s modules (such as selections and transitions) touch the DOM, others (including scales and shapes) only operate on data. D3 can also be paired with web frameworks such as React, Vue, and Svelte; see the getting started guide for recommendations.D3’s embrace of web standards brings many benefits. For example, you can use external stylesheets to alter the appearance of charts (even in response to media queries, say for responsive charts or dark mode); you can use the debugger and element inspector to review what your code is doing; and D3’s synchronous, imperative evaluation model — calling selection.attr immediately mutates the DOM — can make it easier to debug than frameworks with complex asynchronous runtimes.D3 is for bespoke visualization ​D3 makes things possible, not necessarily easy; even simple things that should be easy are often not. To paraphrase Amanda Cox: “Use D3 if you think it’s perfectly normal to write a hundred lines of code for a bar chart.”If you need maximal expressiveness for your bespoke visualization, you should consider D3. D3 makes sense for media organizations such as The New York Times or The Pudding, where a single graphic may be seen by a million readers, and where a team of editors can work together to advance the state of the art in visual communication.On the other hand, D3 is overkill for throwing together a private dashboard or a one-off analysis. Don’t get seduced by whizbang examples: many of them took an immense effort to implement! If you’re constrained by time (and who isn’t?), you’d likely produce a better visualization or analysis with Observable Plot.D3 is for dynamic visualization ​D3’s most novel concept is its data join: given a set of data and a set of DOM elements, the data join allows you to apply separate operations for entering, updating, and exiting elements. If you’re only creating static charts (charts that don’t animate or respond to user input), you may find this concept unintuitive or even bizarre because it’s not needed.The data join exists so that you can control exactly what happens when your data changes and update the display in response. This direct control allows extremely performant updates — you only touch the elements and attributes that need changing, without diffing the DOM — and smooth animated transitions between states. D3 shines for dynamic, interactive visualizations. (Try option-clicking the state toggles in “512 Paths to the White House” from 2012. Really.)PagerNext pageGetting started\n\nWhat is D3? ​D3 (or D3.js) is a free, open-source JavaScript library for visualizing data. Its low-level approach built on web standards offers unparalleled flexibility in authoring dynamic, data-driven graphics. For more than a decade D3 has powered groundbreaking and award-winning visualizations, become a foundational building block of higher-level chart libraries, and fostered a vibrant community of data practitioners around the world.D3 “slingshotted the field into growth, diversification and creativity that has been unprecedented” and “changed how millions of data visualizations are created across newsrooms, websites, and personal portfolios,” remarked the Information is Beautiful 2022 Test of Time Award. The IEEE VIS 2021 Test of Time Award noted, “By creating a framework that was compelling and easy for web developers to use to author interactive visualizations, the authors have undeniably helped to bring data visualization to the mainstream. [D3] is a cornerstone contribution to this conference specifically and more generally to the success of our field as a whole.”D3 was created by Mike Bostock in 2011. Mike co-authored the D3 paper with Jeff Heer and Vadim Ogievetsky at Stanford. Jason Davies made major contributions to D3 from 2011 to 2013, most notably to D3’s geographic projection system. Philippe Rivière has been a major contributor to D3 and its documentation since 2016. Over the years, countless kind individuals have contributed to D3 by sharing code and ideas, by teaching and answering questions, and by bringing people together to further the practice of visualization. Mike and Philippe now maintain D3 and Observable Plot at Observable.D3 is a low-level toolbox ​D3 is not a charting library in the traditional sense. It has no concept of “charts”. When you visualize data with D3, you compose a variety of primitives.To make a stacked area chart, you might usea CSV parser to load data,a time scale for horizontal position (x),a linear scale for vertical position (y),an ordinal scale and categorical scheme for color,a stack layout for arranging values,an area shape with a linear curve for generating SVG path data,axes for documenting the position encodings, andselections for creating SVG elements.That’s a lot to take in, right? But take a deep breath — you don’t have to learn everything at once. Each piece can be used independently, so you can learn them individually before you fit them together. D3 is not a single monolith but rather a suite of 30 discrete libraries (or “modules”). We bundle these modules together for convenience rather than necessity so your tools are within reach as you iterate on your design.What all’s in the D3 toolbox? We recommend exploring the documentation and examples to get a sense of what’s relevant to you.TIPUnless you need D3’s low-level control, we recommend our high-level sister library: Observable Plot. Whereas a histogram in D3 might require 50 lines of code, Plot can do it in one! Plot’s concise yet expressive API lets you focus more on analyzing and visualizing data instead of web development. You can even combine Plot and D3 for the best of both.D3 is flexible ​Because D3 has no overarching “chart” abstraction, even a basic chart may require a few dozen lines of code. On the upside, all the pieces are laid out in front of you and you have complete control over what happens. You can tailor the visualization to achieve exactly what you want. D3 has no default presentation of your data — there’s just the code you write yourself. (Or copy from an example.)Consider D3 an alternative to “doing everything yourself”, not an alternative to a high-level charting library. If you aren’t satisfied with other tools and you’re thinking of rolling your own charts using SVG or Canvas (or even WebGL), you might as well peruse D3’s toolbox! There’s almost certainly something here that will help you build the chart of your dreams without imposing on your creativity.D3 works with the web ​D3 doesn’t introduce a new graphical representation; instead, you use D3 directly with web standards such as SVG and Canvas.The name “D3” is short for data-driven documents, where documents refers to the Document Object Model (DOM) standard that represents the contents of a webpage. While some of D3’s modules (such as selections and transitions) touch the DOM, others (including scales and shapes) only operate on data. D3 can also be paired with web frameworks such as React, Vue, and Svelte; see the getting started guide for recommendations.D3’s embrace of web standards brings many benefits. For example, you can use external stylesheets to alter the appearance of charts (even in response to media queries, say for responsive charts or dark mode); you can use the debugger and element inspector to review what your code is doing; and D3’s synchronous, imperative evaluation model — calling selection.attr immediately mutates the DOM — can make it easier to debug than frameworks with complex asynchronous runtimes.D3 is for bespoke visualization ​D3 makes things possible, not necessarily easy; even simple things that should be easy are often not. To paraphrase Amanda Cox: “Use D3 if you think it’s perfectly normal to write a hundred lines of code for a bar chart.”If you need maximal expressiveness for your bespoke visualization, you should consider D3. D3 makes sense for media organizations such as The New York Times or The Pudding, where a single graphic may be seen by a million readers, and where a team of editors can work together to advance the state of the art in visual communication.On the other hand, D3 is overkill for throwing together a private dashboard or a one-off analysis. Don’t get seduced by whizbang examples: many of them took an immense effort to implement! If you’re constrained by time (and who isn’t?), you’d likely produce a better visualization or analysis with Observable Plot.D3 is for dynamic visualization ​D3’s most novel concept is its data join: given a set of data and a set of DOM elements, the data join allows you to apply separate operations for entering, updating, and exiting elements. If you’re only creating static charts (charts that don’t animate or respond to user input), you may find this concept unintuitive or even bizarre because it’s not needed.The data join exists so that you can control exactly what happens when your data changes and update the display in response. This direct control allows extremely performant updates — you only touch the elements and attributes that need changing, without diffing the DOM — and smooth animated transitions between states. D3 shines for dynamic, interactive visualizations. (Try option-clicking the state toggles in “512 Paths to the White House” from 2012. Really.)\n\n\n\nWhat is D3? ​D3 (or D3.js) is a free, open-source JavaScript library for visualizing data. Its low-level approach built on web standards offers unparalleled flexibility in authoring dynamic, data-driven graphics. For more than a decade D3 has powered groundbreaking and award-winning visualizations, become a foundational building block of higher-level chart libraries, and fostered a vibrant community of data practitioners around the world.D3 “slingshotted the field into growth, diversification and creativity that has been unprecedented” and “changed how millions of data visualizations are created across newsrooms, websites, and personal portfolios,” remarked the Information is Beautiful 2022 Test of Time Award. The IEEE VIS 2021 Test of Time Award noted, “By creating a framework that was compelling and easy for web developers to use to author interactive visualizations, the authors have undeniably helped to bring data visualization to the mainstream. [D3] is a cornerstone contribution to this conference specifically and more generally to the success of our field as a whole.”D3 was created by Mike Bostock in 2011. Mike co-authored the D3 paper with Jeff Heer and Vadim Ogievetsky at Stanford. Jason Davies made major contributions to D3 from 2011 to 2013, most notably to D3’s geographic projection system. Philippe Rivière has been a major contributor to D3 and its documentation since 2016. Over the years, countless kind individuals have contributed to D3 by sharing code and ideas, by teaching and answering questions, and by bringing people together to further the practice of visualization. Mike and Philippe now maintain D3 and Observable Plot at Observable.D3 is a low-level toolbox ​D3 is not a charting library in the traditional sense. It has no concept of “charts”. When you visualize data with D3, you compose a variety of primitives.To make a stacked area chart, you might usea CSV parser to load data,a time scale for horizontal position (x),a linear scale for vertical position (y),an ordinal scale and categorical scheme for color,a stack layout for arranging values,an area shape with a linear curve for generating SVG path data,axes for documenting the position encodings, andselections for creating SVG elements.That’s a lot to take in, right? But take a deep breath — you don’t have to learn everything at once. Each piece can be used independently, so you can learn them individually before you fit them together. D3 is not a single monolith but rather a suite of 30 discrete libraries (or “modules”). We bundle these modules together for convenience rather than necessity so your tools are within reach as you iterate on your design.What all’s in the D3 toolbox? We recommend exploring the documentation and examples to get a sense of what’s relevant to you.TIPUnless you need D3’s low-level control, we recommend our high-level sister library: Observable Plot. Whereas a histogram in D3 might require 50 lines of code, Plot can do it in one! Plot’s concise yet expressive API lets you focus more on analyzing and visualizing data instead of web development. You can even combine Plot and D3 for the best of both.D3 is flexible ​Because D3 has no overarching “chart” abstraction, even a basic chart may require a few dozen lines of code. On the upside, all the pieces are laid out in front of you and you have complete control over what happens. You can tailor the visualization to achieve exactly what you want. D3 has no default presentation of your data — there’s just the code you write yourself. (Or copy from an example.)Consider D3 an alternative to “doing everything yourself”, not an alternative to a high-level charting library. If you aren’t satisfied with other tools and you’re thinking of rolling your own charts using SVG or Canvas (or even WebGL), you might as well peruse D3’s toolbox! There’s almost certainly something here that will help you build the chart of your dreams without imposing on your creativity.D3 works with the web ​D3 doesn’t introduce a new graphical representation; instead, you use D3 directly with web standards such as SVG and Canvas.The name “D3” is short for data-driven documents, where documents refers to the Document Object Model (DOM) standard that represents the contents of a webpage. While some of D3’s modules (such as selections and transitions) touch the DOM, others (including scales and shapes) only operate on data. D3 can also be paired with web frameworks such as React, Vue, and Svelte; see the getting started guide for recommendations.D3’s embrace of web standards brings many benefits. For example, you can use external stylesheets to alter the appearance of charts (even in response to media queries, say for responsive charts or dark mode); you can use the debugger and element inspector to review what your code is doing; and D3’s synchronous, imperative evaluation model — calling selection.attr immediately mutates the DOM — can make it easier to debug than frameworks with complex asynchronous runtimes.D3 is for bespoke visualization ​D3 makes things possible, not necessarily easy; even simple things that should be easy are often not. To paraphrase Amanda Cox: “Use D3 if you think it’s perfectly normal to write a hundred lines of code for a bar chart.”If you need maximal expressiveness for your bespoke visualization, you should consider D3. D3 makes sense for media organizations such as The New York Times or The Pudding, where a single graphic may be seen by a million readers, and where a team of editors can work together to advance the state of the art in visual communication.On the other hand, D3 is overkill for throwing together a private dashboard or a one-off analysis. Don’t get seduced by whizbang examples: many of them took an immense effort to implement! If you’re constrained by time (and who isn’t?), you’d likely produce a better visualization or analysis with Observable Plot.D3 is for dynamic visualization ​D3’s most novel concept is its data join: given a set of data and a set of DOM elements, the data join allows you to apply separate operations for entering, updating, and exiting elements. If you’re only creating static charts (charts that don’t animate or respond to user input), you may find this concept unintuitive or even bizarre because it’s not needed.The data join exists so that you can control exactly what happens when your data changes and update the display in response. This direct control allows extremely performant updates — you only touch the elements and attributes that need changing, without diffing the DOM — and smooth animated transitions between states. D3 shines for dynamic, interactive visualizations. (Try option-clicking the state toggles in “512 Paths to the White House” from 2012. Really.)\n\nSearchK7.9.0GitHub️ 110.0kOn this pageWhat is D3? ​D3 (or D3.js) is a free, open-source JavaScript library for visualizing data. Its low-level approach built on web standards offers unparalleled flexibility in authoring dynamic, data-driven graphics. For more than a decade D3 has powered groundbreaking and award-winning visualizations, become a foundational building block of higher-level chart libraries, and fostered a vibrant community of data practitioners around the world.D3 “slingshotted the field into growth, diversification and creativity that has been unprecedented” and “changed how millions of data visualizations are created across newsrooms, websites, and personal portfolios,” remarked the Information is Beautiful 2022 Test of Time Award. The IEEE VIS 2021 Test of Time Award noted, “By creating a framework that was compelling and easy for web developers to use to author interactive visualizations, the authors have undeniably helped to bring data visualization to the mainstream. [D3] is a cornerstone contribution to this conference specifically and more generally to the success of our field as a whole.”D3 was created by Mike Bostock in 2011. Mike co-authored the D3 paper with Jeff Heer and Vadim Ogievetsky at Stanford. Jason Davies made major contributions to D3 from 2011 to 2013, most notably to D3’s geographic projection system. Philippe Rivière has been a major contributor to D3 and its documentation since 2016. Over the years, countless kind individuals have contributed to D3 by sharing code and ideas, by teaching and answering questions, and by bringing people together to further the practice of visualization. Mike and Philippe now maintain D3 and Observable Plot at Observable.D3 is a low-level toolbox ​D3 is not a charting library in the traditional sense. It has no concept of “charts”. When you visualize data with D3, you compose a variety of primitives.To make a stacked area chart, you might usea CSV parser to load data,a time scale for horizontal position (x),a linear scale for vertical position (y),an ordinal scale and categorical scheme for color,a stack layout for arranging values,an area shape with a linear curve for generating SVG path data,axes for documenting the position encodings, andselections for creating SVG elements.That’s a lot to take in, right? But take a deep breath — you don’t have to learn everything at once. Each piece can be used independently, so you can learn them individually before you fit them together. D3 is not a single monolith but rather a suite of 30 discrete libraries (or “modules”). We bundle these modules together for convenience rather than necessity so your tools are within reach as you iterate on your design.What all’s in the D3 toolbox? We recommend exploring the documentation and examples to get a sense of what’s relevant to you.TIPUnless you need D3’s low-level control, we recommend our high-level sister library: Observable Plot. Whereas a histogram in D3 might require 50 lines of code, Plot can do it in one! Plot’s concise yet expressive API lets you focus more on analyzing and visualizing data instead of web development. You can even combine Plot and D3 for the best of both.D3 is flexible ​Because D3 has no overarching “chart” abstraction, even a basic chart may require a few dozen lines of code. On the upside, all the pieces are laid out in front of you and you have complete control over what happens. You can tailor the visualization to achieve exactly what you want. D3 has no default presentation of your data — there’s just the code you write yourself. (Or copy from an example.)Consider D3 an alternative to “doing everything yourself”, not an alternative to a high-level charting library. If you aren’t satisfied with other tools and you’re thinking of rolling your own charts using SVG or Canvas (or even WebGL), you might as well peruse D3’s toolbox! There’s almost certainly something here that will help you build the chart of your dreams without imposing on your creativity.D3 works with the web ​D3 doesn’t introduce a new graphical representation; instead, you use D3 directly with web standards such as SVG and Canvas.The name “D3” is short for data-driven documents, where documents refers to the Document Object Model (DOM) standard that represents the contents of a webpage. While some of D3’s modules (such as selections and transitions) touch the DOM, others (including scales and shapes) only operate on data. D3 can also be paired with web frameworks such as React, Vue, and Svelte; see the getting started guide for recommendations.D3’s embrace of web standards brings many benefits. For example, you can use external stylesheets to alter the appearance of charts (even in response to media queries, say for responsive charts or dark mode); you can use the debugger and element inspector to review what your code is doing; and D3’s synchronous, imperative evaluation model — calling selection.attr immediately mutates the DOM — can make it easier to debug than frameworks with complex asynchronous runtimes.D3 is for bespoke visualization ​D3 makes things possible, not necessarily easy; even simple things that should be easy are often not. To paraphrase Amanda Cox: “Use D3 if you think it’s perfectly normal to write a hundred lines of code for a bar chart.”If you need maximal expressiveness for your bespoke visualization, you should consider D3. D3 makes sense for media organizations such as The New York Times or The Pudding, where a single graphic may be seen by a million readers, and where a team of editors can work together to advance the state of the art in visual communication.On the other hand, D3 is overkill for throwing together a private dashboard or a one-off analysis. Don’t get seduced by whizbang examples: many of them took an immense effort to implement! If you’re constrained by time (and who isn’t?), you’d likely produce a better visualization or analysis with Observable Plot.D3 is for dynamic visualization ​D3’s most novel concept is its data join: given a set of data and a set of DOM elements, the data join allows you to apply separate operations for entering, updating, and exiting elements. If you’re only creating static charts (charts that don’t animate or respond to user input), you may find this concept unintuitive or even bizarre because it’s not needed.The data join exists so that you can control exactly what happens when your data changes and update the display in response. This direct control allows extremely performant updates — you only touch the elements and attributes that need changing, without diffing the DOM — and smooth animated transitions between states. D3 shines for dynamic, interactive visualizations. (Try option-clicking the state toggles in “512 Paths to the White House” from 2012. Really.)PagerNext pageGetting started\n\nWhat is D3? ​D3 (or D3.js) is a free, open-source JavaScript library for visualizing data. Its low-level approach built on web standards offers unparalleled flexibility in authoring dynamic, data-driven graphics. For more than a decade D3 has powered groundbreaking and award-winning visualizations, become a foundational building block of higher-level chart libraries, and fostered a vibrant community of data practitioners around the world.D3 “slingshotted the field into growth, diversification and creativity that has been unprecedented” and “changed how millions of data visualizations are created across newsrooms, websites, and personal portfolios,” remarked the Information is Beautiful 2022 Test of Time Award. The IEEE VIS 2021 Test of Time Award noted, “By creating a framework that was compelling and easy for web developers to use to author interactive visualizations, the authors have undeniably helped to bring data visualization to the mainstream. [D3] is a cornerstone contribution to this conference specifically and more generally to the success of our field as a whole.”D3 was created by Mike Bostock in 2011. Mike co-authored the D3 paper with Jeff Heer and Vadim Ogievetsky at Stanford. Jason Davies made major contributions to D3 from 2011 to 2013, most notably to D3’s geographic projection system. Philippe Rivière has been a major contributor to D3 and its documentation since 2016. Over the years, countless kind individuals have contributed to D3 by sharing code and ideas, by teaching and answering questions, and by bringing people together to further the practice of visualization. Mike and Philippe now maintain D3 and Observable Plot at Observable.D3 is a low-level toolbox ​D3 is not a charting library in the traditional sense. It has no concept of “charts”. When you visualize data with D3, you compose a variety of primitives.To make a stacked area chart, you might usea CSV parser to load data,a time scale for horizontal position (x),a linear scale for vertical position (y),an ordinal scale and categorical scheme for color,a stack layout for arranging values,an area shape with a linear curve for generating SVG path data,axes for documenting the position encodings, andselections for creating SVG elements.That’s a lot to take in, right? But take a deep breath — you don’t have to learn everything at once. Each piece can be used independently, so you can learn them individually before you fit them together. D3 is not a single monolith but rather a suite of 30 discrete libraries (or “modules”). We bundle these modules together for convenience rather than necessity so your tools are within reach as you iterate on your design.What all’s in the D3 toolbox? We recommend exploring the documentation and examples to get a sense of what’s relevant to you.TIPUnless you need D3’s low-level control, we recommend our high-level sister library: Observable Plot. Whereas a histogram in D3 might require 50 lines of code, Plot can do it in one! Plot’s concise yet expressive API lets you focus more on analyzing and visualizing data instead of web development. You can even combine Plot and D3 for the best of both.D3 is flexible ​Because D3 has no overarching “chart” abstraction, even a basic chart may require a few dozen lines of code. On the upside, all the pieces are laid out in front of you and you have complete control over what happens. You can tailor the visualization to achieve exactly what you want. D3 has no default presentation of your data — there’s just the code you write yourself. (Or copy from an example.)Consider D3 an alternative to “doing everything yourself”, not an alternative to a high-level charting library. If you aren’t satisfied with other tools and you’re thinking of rolling your own charts using SVG or Canvas (or even WebGL), you might as well peruse D3’s toolbox! There’s almost certainly something here that will help you build the chart of your dreams without imposing on your creativity.D3 works with the web ​D3 doesn’t introduce a new graphical representation; instead, you use D3 directly with web standards such as SVG and Canvas.The name “D3” is short for data-driven documents, where documents refers to the Document Object Model (DOM) standard that represents the contents of a webpage. While some of D3’s modules (such as selections and transitions) touch the DOM, others (including scales and shapes) only operate on data. D3 can also be paired with web frameworks such as React, Vue, and Svelte; see the getting started guide for recommendations.D3’s embrace of web standards brings many benefits. For example, you can use external stylesheets to alter the appearance of charts (even in response to media queries, say for responsive charts or dark mode); you can use the debugger and element inspector to review what your code is doing; and D3’s synchronous, imperative evaluation model — calling selection.attr immediately mutates the DOM — can make it easier to debug than frameworks with complex asynchronous runtimes.D3 is for bespoke visualization ​D3 makes things possible, not necessarily easy; even simple things that should be easy are often not. To paraphrase Amanda Cox: “Use D3 if you think it’s perfectly normal to write a hundred lines of code for a bar chart.”If you need maximal expressiveness for your bespoke visualization, you should consider D3. D3 makes sense for media organizations such as The New York Times or The Pudding, where a single graphic may be seen by a million readers, and where a team of editors can work together to advance the state of the art in visual communication.On the other hand, D3 is overkill for throwing together a private dashboard or a one-off analysis. Don’t get seduced by whizbang examples: many of them took an immense effort to implement! If you’re constrained by time (and who isn’t?), you’d likely produce a better visualization or analysis with Observable Plot.D3 is for dynamic visualization ​D3’s most novel concept is its data join: given a set of data and a set of DOM elements, the data join allows you to apply separate operations for entering, updating, and exiting elements. If you’re only creating static charts (charts that don’t animate or respond to user input), you may find this concept unintuitive or even bizarre because it’s not needed.The data join exists so that you can control exactly what happens when your data changes and update the display in response. This direct control allows extremely performant updates — you only touch the elements and attributes that need changing, without diffing the DOM — and smooth animated transitions between states. D3 shines for dynamic, interactive visualizations. (Try option-clicking the state toggles in “512 Paths to the White House” from 2012. Really.)\n\n\n\nWhat is D3? ​D3 (or D3.js) is a free, open-source JavaScript library for visualizing data. Its low-level approach built on web standards offers unparalleled flexibility in authoring dynamic, data-driven graphics. For more than a decade D3 has powered groundbreaking and award-winning visualizations, become a foundational building block of higher-level chart libraries, and fostered a vibrant community of data practitioners around the world.D3 “slingshotted the field into growth, diversification and creativity that has been unprecedented” and “changed how millions of data visualizations are created across newsrooms, websites, and personal portfolios,” remarked the Information is Beautiful 2022 Test of Time Award. The IEEE VIS 2021 Test of Time Award noted, “By creating a framework that was compelling and easy for web developers to use to author interactive visualizations, the authors have undeniably helped to bring data visualization to the mainstream. [D3] is a cornerstone contribution to this conference specifically and more generally to the success of our field as a whole.”D3 was created by Mike Bostock in 2011. Mike co-authored the D3 paper with Jeff Heer and Vadim Ogievetsky at Stanford. Jason Davies made major contributions to D3 from 2011 to 2013, most notably to D3’s geographic projection system. Philippe Rivière has been a major contributor to D3 and its documentation since 2016. Over the years, countless kind individuals have contributed to D3 by sharing code and ideas, by teaching and answering questions, and by bringing people together to further the practice of visualization. Mike and Philippe now maintain D3 and Observable Plot at Observable.D3 is a low-level toolbox ​D3 is not a charting library in the traditional sense. It has no concept of “charts”. When you visualize data with D3, you compose a variety of primitives.To make a stacked area chart, you might usea CSV parser to load data,a time scale for horizontal position (x),a linear scale for vertical position (y),an ordinal scale and categorical scheme for color,a stack layout for arranging values,an area shape with a linear curve for generating SVG path data,axes for documenting the position encodings, andselections for creating SVG elements.That’s a lot to take in, right? But take a deep breath — you don’t have to learn everything at once. Each piece can be used independently, so you can learn them individually before you fit them together. D3 is not a single monolith but rather a suite of 30 discrete libraries (or “modules”). We bundle these modules together for convenience rather than necessity so your tools are within reach as you iterate on your design.What all’s in the D3 toolbox? We recommend exploring the documentation and examples to get a sense of what’s relevant to you.TIPUnless you need D3’s low-level control, we recommend our high-level sister library: Observable Plot. Whereas a histogram in D3 might require 50 lines of code, Plot can do it in one! Plot’s concise yet expressive API lets you focus more on analyzing and visualizing data instead of web development. You can even combine Plot and D3 for the best of both.D3 is flexible ​Because D3 has no overarching “chart” abstraction, even a basic chart may require a few dozen lines of code. On the upside, all the pieces are laid out in front of you and you have complete control over what happens. You can tailor the visualization to achieve exactly what you want. D3 has no default presentation of your data — there’s just the code you write yourself. (Or copy from an example.)Consider D3 an alternative to “doing everything yourself”, not an alternative to a high-level charting library. If you aren’t satisfied with other tools and you’re thinking of rolling your own charts using SVG or Canvas (or even WebGL), you might as well peruse D3’s toolbox! There’s almost certainly something here that will help you build the chart of your dreams without imposing on your creativity.D3 works with the web ​D3 doesn’t introduce a new graphical representation; instead, you use D3 directly with web standards such as SVG and Canvas.The name “D3” is short for data-driven documents, where documents refers to the Document Object Model (DOM) standard that represents the contents of a webpage. While some of D3’s modules (such as selections and transitions) touch the DOM, others (including scales and shapes) only operate on data. D3 can also be paired with web frameworks such as React, Vue, and Svelte; see the getting started guide for recommendations.D3’s embrace of web standards brings many benefits. For example, you can use external stylesheets to alter the appearance of charts (even in response to media queries, say for responsive charts or dark mode); you can use the debugger and element inspector to review what your code is doing; and D3’s synchronous, imperative evaluation model — calling selection.attr immediately mutates the DOM — can make it easier to debug than frameworks with complex asynchronous runtimes.D3 is for bespoke visualization ​D3 makes things possible, not necessarily easy; even simple things that should be easy are often not. To paraphrase Amanda Cox: “Use D3 if you think it’s perfectly normal to write a hundred lines of code for a bar chart.”If you need maximal expressiveness for your bespoke visualization, you should consider D3. D3 makes sense for media organizations such as The New York Times or The Pudding, where a single graphic may be seen by a million readers, and where a team of editors can work together to advance the state of the art in visual communication.On the other hand, D3 is overkill for throwing together a private dashboard or a one-off analysis. Don’t get seduced by whizbang examples: many of them took an immense effort to implement! If you’re constrained by time (and who isn’t?), you’d likely produce a better visualization or analysis with Observable Plot.D3 is for dynamic visualization ​D3’s most novel concept is its data join: given a set of data and a set of DOM elements, the data join allows you to apply separate operations for entering, updating, and exiting elements. If you’re only creating static charts (charts that don’t animate or respond to user input), you may find this concept unintuitive or even bizarre because it’s not needed.The data join exists so that you can control exactly what happens when your data changes and update the display in response. This direct control allows extremely performant updates — you only touch the elements and attributes that need changing, without diffing the DOM — and smooth animated transitions between states. D3 shines for dynamic, interactive visualizations. (Try option-clicking the state toggles in “512 Paths to the White House” from 2012. Really.)\n\nSearchK7.9.0GitHub️ 110.0kOn this pageWhat is D3? ​D3 (or D3.js) is a free, open-source JavaScript library for visualizing data. Its low-level approach built on web standards offers unparalleled flexibility in authoring dynamic, data-driven graphics. For more than a decade D3 has powered groundbreaking and award-winning visualizations, become a foundational building block of higher-level chart libraries, and fostered a vibrant community of data practitioners around the world.D3 “slingshotted the field into growth, diversification and creativity that has been unprecedented” and “changed how millions of data visualizations are created across newsrooms, websites, and personal portfolios,” remarked the Information is Beautiful 2022 Test of Time Award. The IEEE VIS 2021 Test of Time Award noted, “By creating a framework that was compelling and easy for web developers to use to author interactive visualizations, the authors have undeniably helped to bring data visualization to the mainstream. [D3] is a cornerstone contribution to this conference specifically and more generally to the success of our field as a whole.”D3 was created by Mike Bostock in 2011. Mike co-authored the D3 paper with Jeff Heer and Vadim Ogievetsky at Stanford. Jason Davies made major contributions to D3 from 2011 to 2013, most notably to D3’s geographic projection system. Philippe Rivière has been a major contributor to D3 and its documentation since 2016. Over the years, countless kind individuals have contributed to D3 by sharing code and ideas, by teaching and answering questions, and by bringing people together to further the practice of visualization. Mike and Philippe now maintain D3 and Observable Plot at Observable.D3 is a low-level toolbox ​D3 is not a charting library in the traditional sense. It has no concept of “charts”. When you visualize data with D3, you compose a variety of primitives.To make a stacked area chart, you might usea CSV parser to load data,a time scale for horizontal position (x),a linear scale for vertical position (y),an ordinal scale and categorical scheme for color,a stack layout for arranging values,an area shape with a linear curve for generating SVG path data,axes for documenting the position encodings, andselections for creating SVG elements.That’s a lot to take in, right? But take a deep breath — you don’t have to learn everything at once. Each piece can be used independently, so you can learn them individually before you fit them together. D3 is not a single monolith but rather a suite of 30 discrete libraries (or “modules”). We bundle these modules together for convenience rather than necessity so your tools are within reach as you iterate on your design.What all’s in the D3 toolbox? We recommend exploring the documentation and examples to get a sense of what’s relevant to you.TIPUnless you need D3’s low-level control, we recommend our high-level sister library: Observable Plot. Whereas a histogram in D3 might require 50 lines of code, Plot can do it in one! Plot’s concise yet expressive API lets you focus more on analyzing and visualizing data instead of web development. You can even combine Plot and D3 for the best of both.D3 is flexible ​Because D3 has no overarching “chart” abstraction, even a basic chart may require a few dozen lines of code. On the upside, all the pieces are laid out in front of you and you have complete control over what happens. You can tailor the visualization to achieve exactly what you want. D3 has no default presentation of your data — there’s just the code you write yourself. (Or copy from an example.)Consider D3 an alternative to “doing everything yourself”, not an alternative to a high-level charting library. If you aren’t satisfied with other tools and you’re thinking of rolling your own charts using SVG or Canvas (or even WebGL), you might as well peruse D3’s toolbox! There’s almost certainly something here that will help you build the chart of your dreams without imposing on your creativity.D3 works with the web ​D3 doesn’t introduce a new graphical representation; instead, you use D3 directly with web standards such as SVG and Canvas.The name “D3” is short for data-driven documents, where documents refers to the Document Object Model (DOM) standard that represents the contents of a webpage. While some of D3’s modules (such as selections and transitions) touch the DOM, others (including scales and shapes) only operate on data. D3 can also be paired with web frameworks such as React, Vue, and Svelte; see the getting started guide for recommendations.D3’s embrace of web standards brings many benefits. For example, you can use external stylesheets to alter the appearance of charts (even in response to media queries, say for responsive charts or dark mode); you can use the debugger and element inspector to review what your code is doing; and D3’s synchronous, imperative evaluation model — calling selection.attr immediately mutates the DOM — can make it easier to debug than frameworks with complex asynchronous runtimes.D3 is for bespoke visualization ​D3 makes things possible, not necessarily easy; even simple things that should be easy are often not. To paraphrase Amanda Cox: “Use D3 if you think it’s perfectly normal to write a hundred lines of code for a bar chart.”If you need maximal expressiveness for your bespoke visualization, you should consider D3. D3 makes sense for media organizations such as The New York Times or The Pudding, where a single graphic may be seen by a million readers, and where a team of editors can work together to advance the state of the art in visual communication.On the other hand, D3 is overkill for throwing together a private dashboard or a one-off analysis. Don’t get seduced by whizbang examples: many of them took an immense effort to implement! If you’re constrained by time (and who isn’t?), you’d likely produce a better visualization or analysis with Observable Plot.D3 is for dynamic visualization ​D3’s most novel concept is its data join: given a set of data and a set of DOM elements, the data join allows you to apply separate operations for entering, updating, and exiting elements. If you’re only creating static charts (charts that don’t animate or respond to user input), you may find this concept unintuitive or even bizarre because it’s not needed.The data join exists so that you can control exactly what happens when your data changes and update the display in response. This direct control allows extremely performant updates — you only touch the elements and attributes that need changing, without diffing the DOM — and smooth animated transitions between states. D3 shines for dynamic, interactive visualizations. (Try option-clicking the state toggles in “512 Paths to the White House” from 2012. Really.)PagerNext pageGetting started\n\nWhat is D3? ​D3 (or D3.js) is a free, open-source JavaScript library for visualizing data. Its low-level approach built on web standards offers unparalleled flexibility in authoring dynamic, data-driven graphics. For more than a decade D3 has powered groundbreaking and award-winning visualizations, become a foundational building block of higher-level chart libraries, and fostered a vibrant community of data practitioners around the world.D3 “slingshotted the field into growth, diversification and creativity that has been unprecedented” and “changed how millions of data visualizations are created across newsrooms, websites, and personal portfolios,” remarked the Information is Beautiful 2022 Test of Time Award. The IEEE VIS 2021 Test of Time Award noted, “By creating a framework that was compelling and easy for web developers to use to author interactive visualizations, the authors have undeniably helped to bring data visualization to the mainstream. [D3] is a cornerstone contribution to this conference specifically and more generally to the success of our field as a whole.”D3 was created by Mike Bostock in 2011. Mike co-authored the D3 paper with Jeff Heer and Vadim Ogievetsky at Stanford. Jason Davies made major contributions to D3 from 2011 to 2013, most notably to D3’s geographic projection system. Philippe Rivière has been a major contributor to D3 and its documentation since 2016. Over the years, countless kind individuals have contributed to D3 by sharing code and ideas, by teaching and answering questions, and by bringing people together to further the practice of visualization. Mike and Philippe now maintain D3 and Observable Plot at Observable.D3 is a low-level toolbox ​D3 is not a charting library in the traditional sense. It has no concept of “charts”. When you visualize data with D3, you compose a variety of primitives.To make a stacked area chart, you might usea CSV parser to load data,a time scale for horizontal position (x),a linear scale for vertical position (y),an ordinal scale and categorical scheme for color,a stack layout for arranging values,an area shape with a linear curve for generating SVG path data,axes for documenting the position encodings, andselections for creating SVG elements.That’s a lot to take in, right? But take a deep breath — you don’t have to learn everything at once. Each piece can be used independently, so you can learn them individually before you fit them together. D3 is not a single monolith but rather a suite of 30 discrete libraries (or “modules”). We bundle these modules together for convenience rather than necessity so your tools are within reach as you iterate on your design.What all’s in the D3 toolbox? We recommend exploring the documentation and examples to get a sense of what’s relevant to you.TIPUnless you need D3’s low-level control, we recommend our high-level sister library: Observable Plot. Whereas a histogram in D3 might require 50 lines of code, Plot can do it in one! Plot’s concise yet expressive API lets you focus more on analyzing and visualizing data instead of web development. You can even combine Plot and D3 for the best of both.D3 is flexible ​Because D3 has no overarching “chart” abstraction, even a basic chart may require a few dozen lines of code. On the upside, all the pieces are laid out in front of you and you have complete control over what happens. You can tailor the visualization to achieve exactly what you want. D3 has no default presentation of your data — there’s just the code you write yourself. (Or copy from an example.)Consider D3 an alternative to “doing everything yourself”, not an alternative to a high-level charting library. If you aren’t satisfied with other tools and you’re thinking of rolling your own charts using SVG or Canvas (or even WebGL), you might as well peruse D3’s toolbox! There’s almost certainly something here that will help you build the chart of your dreams without imposing on your creativity.D3 works with the web ​D3 doesn’t introduce a new graphical representation; instead, you use D3 directly with web standards such as SVG and Canvas.The name “D3” is short for data-driven documents, where documents refers to the Document Object Model (DOM) standard that represents the contents of a webpage. While some of D3’s modules (such as selections and transitions) touch the DOM, others (including scales and shapes) only operate on data. D3 can also be paired with web frameworks such as React, Vue, and Svelte; see the getting started guide for recommendations.D3’s embrace of web standards brings many benefits. For example, you can use external stylesheets to alter the appearance of charts (even in response to media queries, say for responsive charts or dark mode); you can use the debugger and element inspector to review what your code is doing; and D3’s synchronous, imperative evaluation model — calling selection.attr immediately mutates the DOM — can make it easier to debug than frameworks with complex asynchronous runtimes.D3 is for bespoke visualization ​D3 makes things possible, not necessarily easy; even simple things that should be easy are often not. To paraphrase Amanda Cox: “Use D3 if you think it’s perfectly normal to write a hundred lines of code for a bar chart.”If you need maximal expressiveness for your bespoke visualization, you should consider D3. D3 makes sense for media organizations such as The New York Times or The Pudding, where a single graphic may be seen by a million readers, and where a team of editors can work together to advance the state of the art in visual communication.On the other hand, D3 is overkill for throwing together a private dashboard or a one-off analysis. Don’t get seduced by whizbang examples: many of them took an immense effort to implement! If you’re constrained by time (and who isn’t?), you’d likely produce a better visualization or analysis with Observable Plot.D3 is for dynamic visualization ​D3’s most novel concept is its data join: given a set of data and a set of DOM elements, the data join allows you to apply separate operations for entering, updating, and exiting elements. If you’re only creating static charts (charts that don’t animate or respond to user input), you may find this concept unintuitive or even bizarre because it’s not needed.The data join exists so that you can control exactly what happens when your data changes and update the display in response. This direct control allows extremely performant updates — you only touch the elements and attributes that need changing, without diffing the DOM — and smooth animated transitions between states. D3 shines for dynamic, interactive visualizations. (Try option-clicking the state toggles in “512 Paths to the White House” from 2012. Really.)\n\n\n\nModifying elements ​After selecting elements, use the selection to modify the elements. For example, to set the class and color style of all paragraph elements in the current document:jsd3.selectAll("p")
    .attr("class", "graf")
    .style("color", "red");Selection methods typically return the current selection, or a new selection, allowing the concise application of multiple operations on a given selection via method chaining. The above is equivalent to:jsconst p = d3.selectAll("p");
p.attr("class", "graf");
p.style("color", "red");Selections are immutable. All selection methods that affect which elements are selected (or their order) return a new selection rather than modifying the current selection. However, note that elements are necessarily mutable, as selections drive transformations of the document!selection.attr(name, value) ​Source · If a value is specified, sets the attribute with the specified name to the specified value on the selected elements and returns this selection.jsselection.attr("color", "red")If the value is a constant, all elements are given the same attribute value; otherwise, if the value is a function, it is evaluated for each selected element, in order, being passed the current datum (d), the current index (i), and the current group (nodes), with this as the current DOM element (nodes[i]). The function’s return value is then used to set each element’s attribute. A null value will remove the specified attribute.jsselection.attr("color") // "red"If a value is not specified, returns the current value of the specified attribute for the first (non-null) element in the selection. This is generally useful only if you know that the selection contains exactly one element.The specified name may have a namespace prefix, such as xlink:href to specify the href attribute in the XLink namespace. See namespaces for the map of supported namespaces; additional namespaces can be registered by adding to the map.selection.classed(names, value) ​Source · If a value is specified, assigns or unassigns the specified CSS class names on the selected elements by setting the class attribute or modifying the classList property and returns this selection.jsselection.classed("foo", true)The specified names is a string of space-separated class names. For example, to assign the classes foo and bar to the selected elements:jsselection.classed("foo bar", true)If the value is truthy, then all elements are assigned the specified classes; otherwise, the classes are unassigned.jsselection.classed("foo", () => Math.random() > 0.5)If the value is a function, it is evaluated for each selected element, in order, being passed the current datum (d), the current index (i), and the current group (nodes), with this as the current DOM element (nodes[i]). The function’s return value is then used to assign or unassign classes on each element.jsselection.classed("foo") // true, perhapsIf a value is not specified, returns true if and only if the first (non-null) selected element has the specified classes. This is generally useful only if you know the selection contains exactly one element.selection.style(name, value, priority) ​Source · If a value is specified, sets the style property with the specified name to the specified value on the selected elements and returns this selection.jsselection.style("color", "red")If the value is a constant, then all elements are given the same style property value; otherwise, if the value is a function, it is evaluated for each selected element, in order, being passed the current datum (d), the current index (i), and the current group (nodes), with this as the current DOM element (nodes[i]). The function’s return value is then used to set each element’s style property. A null value will remove the style property. An optional priority may also be specified, either as null or the string important (without the exclamation point).jsselection.style("color") // "red"If a value is not specified, returns the current value of the specified style property for the first (non-null) element in the selection. The current value is defined as the element’s inline value, if present, and otherwise its computed value. Accessing the current style value is generally useful only if you know the selection contains exactly one element.CAUTIONUnlike many SVG attributes, CSS styles typically have associated units. For example, 3px is a valid stroke-width property value, while 3 is not. Some browsers implicitly assign the px (pixel) unit to numeric values, but not all browsers do: IE, for example, throws an “invalid arguments” error!selection.property(name, value) ​Source · Some HTML elements have special properties that are not addressable using attributes or styles, such as a form field’s text value and a checkbox’s checked boolean. Use this method to get or set these properties.jsselection.property("checked", true)If a value is specified, sets the property with the specified name to the specified value on selected elements. If the value is a constant, then all elements are given the same property value; otherwise, if the value is a function, it is evaluated for each selected element, in order, being passed the current datum (d), the current index (i), and the current group (nodes), with this as the current DOM element (nodes[i]). The function’s return value is then used to set each element’s property. A null value will delete the specified property.jsselection.property("checked") // true, perhapsIf a value is not specified, returns the value of the specified property for the first (non-null) element in the selection. This is generally useful only if you know the selection contains exactly one element.selection.text(value) ​Source · If a value is specified, sets the text content to the specified value on all selected elements, replacing any existing child elements.jsselection.text("Hello, world!")If the value is a constant, then all elements are given the same text content; otherwise, if the value is a function, it is evaluated for each selected element, in order, being passed the current datum (d), the current index (i), and the current group (nodes), with this as the current DOM element (nodes[i]). The function’s return value is then used to set each element’s text content. A null value will clear the content.jsselection.text() // "Hello, world!"If a value is not specified, returns the text content for the first (non-null) element in the selection. This is generally useful only if you know the selection contains exactly one element.selection.html(value) ​Source · If a value is specified, sets the inner HTML to the specified value on all selected elements, replacing any existing child elements.jsselection.html("Hello, <i>world</i>!")If the value is a constant, then all elements are given the same inner HTML; otherwise, if the value is a function, it is evaluated for each selected element, in order, being passed the current datum (d), the current index (i), and the current group (nodes), with this as the current DOM element (nodes[i]). The function’s return value is then used to set each element’s inner HTML. A null value will clear the content.jsselection.html() // "Hello, <i>world</i>!"If a value is not specified, returns the inner HTML for the first (non-null) element in the selection. This is generally useful only if you know the selection contains exactly one element.Use selection.append or selection.insert instead to create data-driven content; this method is intended for when you want a little bit of HTML, say for rich formatting. Also, selection.html is only supported on HTML elements. SVG elements and other non-HTML elements do not support the innerHTML property, and thus are incompatible with selection.html. Consider using XMLSerializer to convert a DOM subtree to text. See also the innersvg polyfill, which provides a shim to support the innerHTML property on SVG elements.selection.append(type) ​Source · If the specified type is a string, appends a new element of this type (tag name) as the last child of each selected element, or before the next following sibling in the update selection if this is an enter selection. The latter behavior for enter selections allows you to insert elements into the DOM in an order consistent with the new bound data; however, note that selection.order may still be required if updating elements change order (i.e., if the order of new data is inconsistent with old data).If the specified type is a function, it is evaluated for each selected element, in order, being passed the current datum (d), the current index (i), and the current group (nodes), with this as the current DOM element (nodes[i]). This function should return an element to be appended. (The function typically creates a new element, but it may instead return an existing element.) For example, to append a paragraph to each DIV element:jsd3.selectAll("div").append("p");This is equivalent to:jsd3.selectAll("div").append(() => document.createElement("p"));Which is equivalent to:jsd3.selectAll("div").select(function() {
  return this.appendChild(document.createElement("p"));
});In both cases, this method returns a new selection containing the appended elements. Each new element inherits the data of the current elements, if any, in the same manner as selection.select.The specified name may have a namespace prefix, such as svg:text to specify a text attribute in the SVG namespace. See namespaces for the map of supported namespaces; additional namespaces can be registered by adding to the map. If no namespace is specified, the namespace will be inherited from the parent element; or, if the name is one of the known prefixes, the corresponding namespace will be used (for example, svg implies svg:svg).selection.insert(type, before) ​Source · If the specified type is a string, inserts a new element of this type (tag name) before the first element matching the specified before selector for each selected element. For example, a before selector :first-child will prepend nodes before the first child. If before is not specified, it defaults to null. (To append elements in an order consistent with bound data, use selection.append.)Both type and before may instead be specified as functions which are evaluated for each selected element, in order, being passed the current datum (d), the current index (i), and the current group (nodes), with this as the current DOM element (nodes[i]). The type function should return an element to be inserted; the before function should return the child element before which the element should be inserted. For example, to append a paragraph to each DIV element:jsd3.selectAll("div").insert("p");This is equivalent to:jsd3.selectAll("div").insert(() => document.createElement("p"));Which is equivalent to:jsd3.selectAll("div").select(function() {
  return this.insertBefore(document.createElement("p"), null);
});In both cases, this method returns a new selection containing the appended elements. Each new element inherits the data of the current elements, if any, in the same manner as selection.select.The specified name may have a namespace prefix, such as svg:text to specify a text attribute in the SVG namespace. See namespaces for the map of supported namespaces; additional namespaces can be registered by adding to the map. If no namespace is specified, the namespace will be inherited from the parent element; or, if the name is one of the known prefixes, the corresponding namespace will be used (for example, svg implies svg:svg).selection.remove() ​Source · Removes the selected elements from the document. Returns this selection (the removed elements) which are now detached from the DOM. There is not currently a dedicated API to add removed elements back to the document; however, you can pass a function to selection.append or selection.insert to re-add elements.selection.clone(deep) ​Source · Inserts clones of the selected elements immediately following the selected elements and returns a selection of the newly added clones. If deep is truthy, the descendant nodes of the selected elements will be cloned as well. Otherwise, only the elements themselves will be cloned. Equivalent to:jsselection.select(function() {
  return this.parentNode.insertBefore(this.cloneNode(deep), this.nextSibling);
});selection.sort(compare) ​Source · Returns a new selection that contains a copy of each group in this selection sorted according to the compare function. After sorting, re-inserts elements to match the resulting order (per selection.order).The compare function, which defaults to ascending, is passed two elements’ data a and b to compare. It should return either a negative, positive, or zero value. If negative, then a should be before b; if positive, then a should be after b; otherwise, a and b are considered equal and the order is arbitrary.selection.order() ​Source · Re-inserts elements into the document such that the document order of each group matches the selection order. This is equivalent to calling selection.sort if the data is already sorted, but much faster.selection.raise() ​Source · Re-inserts each selected element, in order, as the last child of its parent. Equivalent to:jsselection.each(function() {
  this.parentNode.appendChild(this);
});selection.lower() ​Source · Re-inserts each selected element, in order, as the first child of its parent. Equivalent to:jsselection.each(function() {
  this.parentNode.insertBefore(this, this.parentNode.firstChild);
});create(name) ​Source · Given the specified element name, returns a single-element selection containing a detached element of the given name in the current document. This method assumes the HTML namespace, so you must specify a namespace explicitly when creating SVG or other non-HTML elements; see namespace for details on supported namespace prefixes.jsd3.create("svg") // equivalent to svg:svgjsd3.create("svg:svg") // more explicitlyjsd3.create("svg:g") // an SVG G elementjsd3.create("g") // an HTML G (unknown) elementcreator(name) ​Source · Given the specified element name, returns a function which creates an element of the given name, assuming that this is the parent element. This method is used internally by selection.append and selection.insert to create new elements. For example, this:jsselection.append("div");Is equivalent to:jsselection.append(d3.creator("div"));See namespace for details on supported namespace prefixes, such as for SVG elements.\n\nSearchK7.9.0GitHub️ 110.0kOn this pageModifying elements ​After selecting elements, use the selection to modify the elements. For example, to set the class and color style of all paragraph elements in the current document:jsd3.selectAll("p")
    .attr("class", "graf")
    .style("color", "red");Selection methods typically return the current selection, or a new selection, allowing the concise application of multiple operations on a given selection via method chaining. The above is equivalent to:jsconst p = d3.selectAll("p");
p.attr("class", "graf");
p.style("color", "red");Selections are immutable. All selection methods that affect which elements are selected (or their order) return a new selection rather than modifying the current selection. However, note that elements are necessarily mutable, as selections drive transformations of the document!selection.attr(name, value) ​Source · If a value is specified, sets the attribute with the specified name to the specified value on the selected elements and returns this selection.jsselection.attr("color", "red")If the value is a constant, all elements are given the same attribute value; otherwise, if the value is a function, it is evaluated for each selected element, in order, being passed the current datum (d), the current index (i), and the current group (nodes), with this as the current DOM element (nodes[i]). The function’s return value is then used to set each element’s attribute. A null value will remove the specified attribute.jsselection.attr("color") // "red"If a value is not specified, returns the current value of the specified attribute for the first (non-null) element in the selection. This is generally useful only if you know that the selection contains exactly one element.The specified name may have a namespace prefix, such as xlink:href to specify the href attribute in the XLink namespace. See namespaces for the map of supported namespaces; additional namespaces can be registered by adding to the map.selection.classed(names, value) ​Source · If a value is specified, assigns or unassigns the specified CSS class names on the selected elements by setting the class attribute or modifying the classList property and returns this selection.jsselection.classed("foo", true)The specified names is a string of space-separated class names. For example, to assign the classes foo and bar to the selected elements:jsselection.classed("foo bar", true)If the value is truthy, then all elements are assigned the specified classes; otherwise, the classes are unassigned.jsselection.classed("foo", () => Math.random() > 0.5)If the value is a function, it is evaluated for each selected element, in order, being passed the current datum (d), the current index (i), and the current group (nodes), with this as the current DOM element (nodes[i]). The function’s return value is then used to assign or unassign classes on each element.jsselection.classed("foo") // true, perhapsIf a value is not specified, returns true if and only if the first (non-null) selected element has the specified classes. This is generally useful only if you know the selection contains exactly one element.selection.style(name, value, priority) ​Source · If a value is specified, sets the style property with the specified name to the specified value on the selected elements and returns this selection.jsselection.style("color", "red")If the value is a constant, then all elements are given the same style property value; otherwise, if the value is a function, it is evaluated for each selected element, in order, being passed the current datum (d), the current index (i), and the current group (nodes), with this as the current DOM element (nodes[i]). The function’s return value is then used to set each element’s style property. A null value will remove the style property. An optional priority may also be specified, either as null or the string important (without the exclamation point).jsselection.style("color") // "red"If a value is not specified, returns the current value of the specified style property for the first (non-null) element in the selection. The current value is defined as the element’s inline value, if present, and otherwise its computed value. Accessing the current style value is generally useful only if you know the selection contains exactly one element.CAUTIONUnlike many SVG attributes, CSS styles typically have associated units. For example, 3px is a valid stroke-width property value, while 3 is not. Some browsers implicitly assign the px (pixel) unit to numeric values, but not all browsers do: IE, for example, throws an “invalid arguments” error!selection.property(name, value) ​Source · Some HTML elements have special properties that are not addressable using attributes or styles, such as a form field’s text value and a checkbox’s checked boolean. Use this method to get or set these properties.jsselection.property("checked", true)If a value is specified, sets the property with the specified name to the specified value on selected elements. If the value is a constant, then all elements are given the same property value; otherwise, if the value is a function, it is evaluated for each selected element, in order, being passed the current datum (d), the current index (i), and the current group (nodes), with this as the current DOM element (nodes[i]). The function’s return value is then used to set each element’s property. A null value will delete the specified property.jsselection.property("checked") // true, perhapsIf a value is not specified, returns the value of the specified property for the first (non-null) element in the selection. This is generally useful only if you know the selection contains exactly one element.selection.text(value) ​Source · If a value is specified, sets the text content to the specified value on all selected elements, replacing any existing child elements.jsselection.text("Hello, world!")If the value is a constant, then all elements are given the same text content; otherwise, if the value is a function, it is evaluated for each selected element, in order, being passed the current datum (d), the current index (i), and the current group (nodes), with this as the current DOM element (nodes[i]). The function’s return value is then used to set each element’s text content. A null value will clear the content.jsselection.text() // "Hello, world!"If a value is not specified, returns the text content for the first (non-null) element in the selection. This is generally useful only if you know the selection contains exactly one element.selection.html(value) ​Source · If a value is specified, sets the inner HTML to the specified value on all selected elements, replacing any existing child elements.jsselection.html("Hello, <i>world</i>!")If the value is a constant, then all elements are given the same inner HTML; otherwise, if the value is a function, it is evaluated for each selected element, in order, being passed the current datum (d), the current index (i), and the current group (nodes), with this as the current DOM element (nodes[i]). The function’s return value is then used to set each element’s inner HTML. A null value will clear the content.jsselection.html() // "Hello, <i>world</i>!"If a value is not specified, returns the inner HTML for the first (non-null) element in the selection. This is generally useful only if you know the selection contains exactly one element.Use selection.append or selection.insert instead to create data-driven content; this method is intended for when you want a little bit of HTML, say for rich formatting. Also, selection.html is only supported on HTML elements. SVG elements and other non-HTML elements do not support the innerHTML property, and thus are incompatible with selection.html. Consider using XMLSerializer to convert a DOM subtree to text. See also the innersvg polyfill, which provides a shim to support the innerHTML property on SVG elements.selection.append(type) ​Source · If the specified type is a string, appends a new element of this type (tag name) as the last child of each selected element, or before the next following sibling in the update selection if this is an enter selection. The latter behavior for enter selections allows you to insert elements into the DOM in an order consistent with the new bound data; however, note that selection.order may still be required if updating elements change order (i.e., if the order of new data is inconsistent with old data).If the specified type is a function, it is evaluated for each selected element, in order, being passed the current datum (d), the current index (i), and the current group (nodes), with this as the current DOM element (nodes[i]). This function should return an element to be appended. (The function typically creates a new element, but it may instead return an existing element.) For example, to append a paragraph to each DIV element:jsd3.selectAll("div").append("p");This is equivalent to:jsd3.selectAll("div").append(() => document.createElement("p"));Which is equivalent to:jsd3.selectAll("div").select(function() {
  return this.appendChild(document.createElement("p"));
});In both cases, this method returns a new selection containing the appended elements. Each new element inherits the data of the current elements, if any, in the same manner as selection.select.The specified name may have a namespace prefix, such as svg:text to specify a text attribute in the SVG namespace. See namespaces for the map of supported namespaces; additional namespaces can be registered by adding to the map. If no namespace is specified, the namespace will be inherited from the parent element; or, if the name is one of the known prefixes, the corresponding namespace will be used (for example, svg implies svg:svg).selection.insert(type, before) ​Source · If the specified type is a string, inserts a new element of this type (tag name) before the first element matching the specified before selector for each selected element. For example, a before selector :first-child will prepend nodes before the first child. If before is not specified, it defaults to null. (To append elements in an order consistent with bound data, use selection.append.)Both type and before may instead be specified as functions which are evaluated for each selected element, in order, being passed the current datum (d), the current index (i), and the current group (nodes), with this as the current DOM element (nodes[i]). The type function should return an element to be inserted; the before function should return the child element before which the element should be inserted. For example, to append a paragraph to each DIV element:jsd3.selectAll("div").insert("p");This is equivalent to:jsd3.selectAll("div").insert(() => document.createElement("p"));Which is equivalent to:jsd3.selectAll("div").select(function() {
  return this.insertBefore(document.createElement("p"), null);
});In both cases, this method returns a new selection containing the appended elements. Each new element inherits the data of the current elements, if any, in the same manner as selection.select.The specified name may have a namespace prefix, such as svg:text to specify a text attribute in the SVG namespace. See namespaces for the map of supported namespaces; additional namespaces can be registered by adding to the map. If no namespace is specified, the namespace will be inherited from the parent element; or, if the name is one of the known prefixes, the corresponding namespace will be used (for example, svg implies svg:svg).selection.remove() ​Source · Removes the selected elements from the document. Returns this selection (the removed elements) which are now detached from the DOM. There is not currently a dedicated API to add removed elements back to the document; however, you can pass a function to selection.append or selection.insert to re-add elements.selection.clone(deep) ​Source · Inserts clones of the selected elements immediately following the selected elements and returns a selection of the newly added clones. If deep is truthy, the descendant nodes of the selected elements will be cloned as well. Otherwise, only the elements themselves will be cloned. Equivalent to:jsselection.select(function() {
  return this.parentNode.insertBefore(this.cloneNode(deep), this.nextSibling);
});selection.sort(compare) ​Source · Returns a new selection that contains a copy of each group in this selection sorted according to the compare function. After sorting, re-inserts elements to match the resulting order (per selection.order).The compare function, which defaults to ascending, is passed two elements’ data a and b to compare. It should return either a negative, positive, or zero value. If negative, then a should be before b; if positive, then a should be after b; otherwise, a and b are considered equal and the order is arbitrary.selection.order() ​Source · Re-inserts elements into the document such that the document order of each group matches the selection order. This is equivalent to calling selection.sort if the data is already sorted, but much faster.selection.raise() ​Source · Re-inserts each selected element, in order, as the last child of its parent. Equivalent to:jsselection.each(function() {
  this.parentNode.appendChild(this);
});selection.lower() ​Source · Re-inserts each selected element, in order, as the first child of its parent. Equivalent to:jsselection.each(function() {
  this.parentNode.insertBefore(this, this.parentNode.firstChild);
});create(name) ​Source · Given the specified element name, returns a single-element selection containing a detached element of the given name in the current document. This method assumes the HTML namespace, so you must specify a namespace explicitly when creating SVG or other non-HTML elements; see namespace for details on supported namespace prefixes.jsd3.create("svg") // equivalent to svg:svgjsd3.create("svg:svg") // more explicitlyjsd3.create("svg:g") // an SVG G elementjsd3.create("g") // an HTML G (unknown) elementcreator(name) ​Source · Given the specified element name, returns a function which creates an element of the given name, assuming that this is the parent element. This method is used internally by selection.append and selection.insert to create new elements. For example, this:jsselection.append("div");Is equivalent to:jsselection.append(d3.creator("div"));See namespace for details on supported namespace prefixes, such as for SVG elements.PagerPrevious pageSelecting elementsNext pageJoining data\n\nModifying elements ​After selecting elements, use the selection to modify the elements. For example, to set the class and color style of all paragraph elements in the current document:jsd3.selectAll("p")
    .attr("class", "graf")
    .style("color", "red");Selection methods typically return the current selection, or a new selection, allowing the concise application of multiple operations on a given selection via method chaining. The above is equivalent to:jsconst p = d3.selectAll("p");
p.attr("class", "graf");
p.style("color", "red");Selections are immutable. All selection methods that affect which elements are selected (or their order) return a new selection rather than modifying the current selection. However, note that elements are necessarily mutable, as selections drive transformations of the document!selection.attr(name, value) ​Source · If a value is specified, sets the attribute with the specified name to the specified value on the selected elements and returns this selection.jsselection.attr("color", "red")If the value is a constant, all elements are given the same attribute value; otherwise, if the value is a function, it is evaluated for each selected element, in order, being passed the current datum (d), the current index (i), and the current group (nodes), with this as the current DOM element (nodes[i]). The function’s return value is then used to set each element’s attribute. A null value will remove the specified attribute.jsselection.attr("color") // "red"If a value is not specified, returns the current value of the specified attribute for the first (non-null) element in the selection. This is generally useful only if you know that the selection contains exactly one element.The specified name may have a namespace prefix, such as xlink:href to specify the href attribute in the XLink namespace. See namespaces for the map of supported namespaces; additional namespaces can be registered by adding to the map.selection.classed(names, value) ​Source · If a value is specified, assigns or unassigns the specified CSS class names on the selected elements by setting the class attribute or modifying the classList property and returns this selection.jsselection.classed("foo", true)The specified names is a string of space-separated class names. For example, to assign the classes foo and bar to the selected elements:jsselection.classed("foo bar", true)If the value is truthy, then all elements are assigned the specified classes; otherwise, the classes are unassigned.jsselection.classed("foo", () => Math.random() > 0.5)If the value is a function, it is evaluated for each selected element, in order, being passed the current datum (d), the current index (i), and the current group (nodes), with this as the current DOM element (nodes[i]). The function’s return value is then used to assign or unassign classes on each element.jsselection.classed("foo") // true, perhapsIf a value is not specified, returns true if and only if the first (non-null) selected element has the specified classes. This is generally useful only if you know the selection contains exactly one element.selection.style(name, value, priority) ​Source · If a value is specified, sets the style property with the specified name to the specified value on the selected elements and returns this selection.jsselection.style("color", "red")If the value is a constant, then all elements are given the same style property value; otherwise, if the value is a function, it is evaluated for each selected element, in order, being passed the current datum (d), the current index (i), and the current group (nodes), with this as the current DOM element (nodes[i]). The function’s return value is then used to set each element’s style property. A null value will remove the style property. An optional priority may also be specified, either as null or the string important (without the exclamation point).jsselection.style("color") // "red"If a value is not specified, returns the current value of the specified style property for the first (non-null) element in the selection. The current value is defined as the element’s inline value, if present, and otherwise its computed value. Accessing the current style value is generally useful only if you know the selection contains exactly one element.CAUTIONUnlike many SVG attributes, CSS styles typically have associated units. For example, 3px is a valid stroke-width property value, while 3 is not. Some browsers implicitly assign the px (pixel) unit to numeric values, but not all browsers do: IE, for example, throws an “invalid arguments” error!selection.property(name, value) ​Source · Some HTML elements have special properties that are not addressable using attributes or styles, such as a form field’s text value and a checkbox’s checked boolean. Use this method to get or set these properties.jsselection.property("checked", true)If a value is specified, sets the property with the specified name to the specified value on selected elements. If the value is a constant, then all elements are given the same property value; otherwise, if the value is a function, it is evaluated for each selected element, in order, being passed the current datum (d), the current index (i), and the current group (nodes), with this as the current DOM element (nodes[i]). The function’s return value is then used to set each element’s property. A null value will delete the specified property.jsselection.property("checked") // true, perhapsIf a value is not specified, returns the value of the specified property for the first (non-null) element in the selection. This is generally useful only if you know the selection contains exactly one element.selection.text(value) ​Source · If a value is specified, sets the text content to the specified value on all selected elements, replacing any existing child elements.jsselection.text("Hello, world!")If the value is a constant, then all elements are given the same text content; otherwise, if the value is a function, it is evaluated for each selected element, in order, being passed the current datum (d), the current index (i), and the current group (nodes), with this as the current DOM element (nodes[i]). The function’s return value is then used to set each element’s text content. A null value will clear the content.jsselection.text() // "Hello, world!"If a value is not specified, returns the text content for the first (non-null) element in the selection. This is generally useful only if you know the selection contains exactly one element.selection.html(value) ​Source · If a value is specified, sets the inner HTML to the specified value on all selected elements, replacing any existing child elements.jsselection.html("Hello, <i>world</i>!")If the value is a constant, then all elements are given the same inner HTML; otherwise, if the value is a function, it is evaluated for each selected element, in order, being passed the current datum (d), the current index (i), and the current group (nodes), with this as the current DOM element (nodes[i]). The function’s return value is then used to set each element’s inner HTML. A null value will clear the content.jsselection.html() // "Hello, <i>world</i>!"If a value is not specified, returns the inner HTML for the first (non-null) element in the selection. This is generally useful only if you know the selection contains exactly one element.Use selection.append or selection.insert instead to create data-driven content; this method is intended for when you want a little bit of HTML, say for rich formatting. Also, selection.html is only supported on HTML elements. SVG elements and other non-HTML elements do not support the innerHTML property, and thus are incompatible with selection.html. Consider using XMLSerializer to convert a DOM subtree to text. See also the innersvg polyfill, which provides a shim to support the innerHTML property on SVG elements.selection.append(type) ​Source · If the specified type is a string, appends a new element of this type (tag name) as the last child of each selected element, or before the next following sibling in the update selection if this is an enter selection. The latter behavior for enter selections allows you to insert elements into the DOM in an order consistent with the new bound data; however, note that selection.order may still be required if updating elements change order (i.e., if the order of new data is inconsistent with old data).If the specified type is a function, it is evaluated for each selected element, in order, being passed the current datum (d), the current index (i), and the current group (nodes), with this as the current DOM element (nodes[i]). This function should return an element to be appended. (The function typically creates a new element, but it may instead return an existing element.) For example, to append a paragraph to each DIV element:jsd3.selectAll("div").append("p");This is equivalent to:jsd3.selectAll("div").append(() => document.createElement("p"));Which is equivalent to:jsd3.selectAll("div").select(function() {
  return this.appendChild(document.createElement("p"));
});In both cases, this method returns a new selection containing the appended elements. Each new element inherits the data of the current elements, if any, in the same manner as selection.select.The specified name may have a namespace prefix, such as svg:text to specify a text attribute in the SVG namespace. See namespaces for the map of supported namespaces; additional namespaces can be registered by adding to the map. If no namespace is specified, the namespace will be inherited from the parent element; or, if the name is one of the known prefixes, the corresponding namespace will be used (for example, svg implies svg:svg).selection.insert(type, before) ​Source · If the specified type is a string, inserts a new element of this type (tag name) before the first element matching the specified before selector for each selected element. For example, a before selector :first-child will prepend nodes before the first child. If before is not specified, it defaults to null. (To append elements in an order consistent with bound data, use selection.append.)Both type and before may instead be specified as functions which are evaluated for each selected element, in order, being passed the current datum (d), the current index (i), and the current group (nodes), with this as the current DOM element (nodes[i]). The type function should return an element to be inserted; the before function should return the child element before which the element should be inserted. For example, to append a paragraph to each DIV element:jsd3.selectAll("div").insert("p");This is equivalent to:jsd3.selectAll("div").insert(() => document.createElement("p"));Which is equivalent to:jsd3.selectAll("div").select(function() {
  return this.insertBefore(document.createElement("p"), null);
});In both cases, this method returns a new selection containing the appended elements. Each new element inherits the data of the current elements, if any, in the same manner as selection.select.The specified name may have a namespace prefix, such as svg:text to specify a text attribute in the SVG namespace. See namespaces for the map of supported namespaces; additional namespaces can be registered by adding to the map. If no namespace is specified, the namespace will be inherited from the parent element; or, if the name is one of the known prefixes, the corresponding namespace will be used (for example, svg implies svg:svg).selection.remove() ​Source · Removes the selected elements from the document. Returns this selection (the removed elements) which are now detached from the DOM. There is not currently a dedicated API to add removed elements back to the document; however, you can pass a function to selection.append or selection.insert to re-add elements.selection.clone(deep) ​Source · Inserts clones of the selected elements immediately following the selected elements and returns a selection of the newly added clones. If deep is truthy, the descendant nodes of the selected elements will be cloned as well. Otherwise, only the elements themselves will be cloned. Equivalent to:jsselection.select(function() {
  return this.parentNode.insertBefore(this.cloneNode(deep), this.nextSibling);
});selection.sort(compare) ​Source · Returns a new selection that contains a copy of each group in this selection sorted according to the compare function. After sorting, re-inserts elements to match the resulting order (per selection.order).The compare function, which defaults to ascending, is passed two elements’ data a and b to compare. It should return either a negative, positive, or zero value. If negative, then a should be before b; if positive, then a should be after b; otherwise, a and b are considered equal and the order is arbitrary.selection.order() ​Source · Re-inserts elements into the document such that the document order of each group matches the selection order. This is equivalent to calling selection.sort if the data is already sorted, but much faster.selection.raise() ​Source · Re-inserts each selected element, in order, as the last child of its parent. Equivalent to:jsselection.each(function() {
  this.parentNode.appendChild(this);
});selection.lower() ​Source · Re-inserts each selected element, in order, as the first child of its parent. Equivalent to:jsselection.each(function() {
  this.parentNode.insertBefore(this, this.parentNode.firstChild);
});create(name) ​Source · Given the specified element name, returns a single-element selection containing a detached element of the given name in the current document. This method assumes the HTML namespace, so you must specify a namespace explicitly when creating SVG or other non-HTML elements; see namespace for details on supported namespace prefixes.jsd3.create("svg") // equivalent to svg:svgjsd3.create("svg:svg") // more explicitlyjsd3.create("svg:g") // an SVG G elementjsd3.create("g") // an HTML G (unknown) elementcreator(name) ​Source · Given the specified element name, returns a function which creates an element of the given name, assuming that this is the parent element. This method is used internally by selection.append and selection.insert to create new elements. For example, this:jsselection.append("div");Is equivalent to:jsselection.append(d3.creator("div"));See namespace for details on supported namespace prefixes, such as for SVG elements.\n\n\n\nWhat is D3? ​D3 (or D3.js) is a free, open-source JavaScript library for visualizing data. Its low-level approach built on web standards offers unparalleled flexibility in authoring dynamic, data-driven graphics. For more than a decade D3 has powered groundbreaking and award-winning visualizations, become a foundational building block of higher-level chart libraries, and fostered a vibrant community of data practitioners around the world.D3 “slingshotted the field into growth, diversification and creativity that has been unprecedented” and “changed how millions of data visualizations are created across newsrooms, websites, and personal portfolios,” remarked the Information is Beautiful 2022 Test of Time Award. The IEEE VIS 2021 Test of Time Award noted, “By creating a framework that was compelling and easy for web developers to use to author interactive visualizations, the authors have undeniably helped to bring data visualization to the mainstream. [D3] is a cornerstone contribution to this conference specifically and more generally to the success of our field as a whole.”D3 was created by Mike Bostock in 2011. Mike co-authored the D3 paper with Jeff Heer and Vadim Ogievetsky at Stanford. Jason Davies made major contributions to D3 from 2011 to 2013, most notably to D3’s geographic projection system. Philippe Rivière has been a major contributor to D3 and its documentation since 2016. Over the years, countless kind individuals have contributed to D3 by sharing code and ideas, by teaching and answering questions, and by bringing people together to further the practice of visualization. Mike and Philippe now maintain D3 and Observable Plot at Observable.D3 is a low-level toolbox ​D3 is not a charting library in the traditional sense. It has no concept of “charts”. When you visualize data with D3, you compose a variety of primitives.To make a stacked area chart, you might usea CSV parser to load data,a time scale for horizontal position (x),a linear scale for vertical position (y),an ordinal scale and categorical scheme for color,a stack layout for arranging values,an area shape with a linear curve for generating SVG path data,axes for documenting the position encodings, andselections for creating SVG elements.That’s a lot to take in, right? But take a deep breath — you don’t have to learn everything at once. Each piece can be used independently, so you can learn them individually before you fit them together. D3 is not a single monolith but rather a suite of 30 discrete libraries (or “modules”). We bundle these modules together for convenience rather than necessity so your tools are within reach as you iterate on your design.What all’s in the D3 toolbox? We recommend exploring the documentation and examples to get a sense of what’s relevant to you.TIPUnless you need D3’s low-level control, we recommend our high-level sister library: Observable Plot. Whereas a histogram in D3 might require 50 lines of code, Plot can do it in one! Plot’s concise yet expressive API lets you focus more on analyzing and visualizing data instead of web development. You can even combine Plot and D3 for the best of both.D3 is flexible ​Because D3 has no overarching “chart” abstraction, even a basic chart may require a few dozen lines of code. On the upside, all the pieces are laid out in front of you and you have complete control over what happens. You can tailor the visualization to achieve exactly what you want. D3 has no default presentation of your data — there’s just the code you write yourself. (Or copy from an example.)Consider D3 an alternative to “doing everything yourself”, not an alternative to a high-level charting library. If you aren’t satisfied with other tools and you’re thinking of rolling your own charts using SVG or Canvas (or even WebGL), you might as well peruse D3’s toolbox! There’s almost certainly something here that will help you build the chart of your dreams without imposing on your creativity.D3 works with the web ​D3 doesn’t introduce a new graphical representation; instead, you use D3 directly with web standards such as SVG and Canvas.The name “D3” is short for data-driven documents, where documents refers to the Document Object Model (DOM) standard that represents the contents of a webpage. While some of D3’s modules (such as selections and transitions) touch the DOM, others (including scales and shapes) only operate on data. D3 can also be paired with web frameworks such as React, Vue, and Svelte; see the getting started guide for recommendations.D3’s embrace of web standards brings many benefits. For example, you can use external stylesheets to alter the appearance of charts (even in response to media queries, say for responsive charts or dark mode); you can use the debugger and element inspector to review what your code is doing; and D3’s synchronous, imperative evaluation model — calling selection.attr immediately mutates the DOM — can make it easier to debug than frameworks with complex asynchronous runtimes.D3 is for bespoke visualization ​D3 makes things possible, not necessarily easy; even simple things that should be easy are often not. To paraphrase Amanda Cox: “Use D3 if you think it’s perfectly normal to write a hundred lines of code for a bar chart.”If you need maximal expressiveness for your bespoke visualization, you should consider D3. D3 makes sense for media organizations such as The New York Times or The Pudding, where a single graphic may be seen by a million readers, and where a team of editors can work together to advance the state of the art in visual communication.On the other hand, D3 is overkill for throwing together a private dashboard or a one-off analysis. Don’t get seduced by whizbang examples: many of them took an immense effort to implement! If you’re constrained by time (and who isn’t?), you’d likely produce a better visualization or analysis with Observable Plot.D3 is for dynamic visualization ​D3’s most novel concept is its data join: given a set of data and a set of DOM elements, the data join allows you to apply separate operations for entering, updating, and exiting elements. If you’re only creating static charts (charts that don’t animate or respond to user input), you may find this concept unintuitive or even bizarre because it’s not needed.The data join exists so that you can control exactly what happens when your data changes and update the display in response. This direct control allows extremely performant updates — you only touch the elements and attributes that need changing, without diffing the DOM — and smooth animated transitions between states. D3 shines for dynamic, interactive visualizations. (Try option-clicking the state toggles in “512 Paths to the White House” from 2012. Really.)\n\nSearchK7.9.0GitHub️ 110.0kOn this pageWhat is D3? ​D3 (or D3.js) is a free, open-source JavaScript library for visualizing data. Its low-level approach built on web standards offers unparalleled flexibility in authoring dynamic, data-driven graphics. For more than a decade D3 has powered groundbreaking and award-winning visualizations, become a foundational building block of higher-level chart libraries, and fostered a vibrant community of data practitioners around the world.D3 “slingshotted the field into growth, diversification and creativity that has been unprecedented” and “changed how millions of data visualizations are created across newsrooms, websites, and personal portfolios,” remarked the Information is Beautiful 2022 Test of Time Award. The IEEE VIS 2021 Test of Time Award noted, “By creating a framework that was compelling and easy for web developers to use to author interactive visualizations, the authors have undeniably helped to bring data visualization to the mainstream. [D3] is a cornerstone contribution to this conference specifically and more generally to the success of our field as a whole.”D3 was created by Mike Bostock in 2011. Mike co-authored the D3 paper with Jeff Heer and Vadim Ogievetsky at Stanford. Jason Davies made major contributions to D3 from 2011 to 2013, most notably to D3’s geographic projection system. Philippe Rivière has been a major contributor to D3 and its documentation since 2016. Over the years, countless kind individuals have contributed to D3 by sharing code and ideas, by teaching and answering questions, and by bringing people together to further the practice of visualization. Mike and Philippe now maintain D3 and Observable Plot at Observable.D3 is a low-level toolbox ​D3 is not a charting library in the traditional sense. It has no concept of “charts”. When you visualize data with D3, you compose a variety of primitives.To make a stacked area chart, you might usea CSV parser to load data,a time scale for horizontal position (x),a linear scale for vertical position (y),an ordinal scale and categorical scheme for color,a stack layout for arranging values,an area shape with a linear curve for generating SVG path data,axes for documenting the position encodings, andselections for creating SVG elements.That’s a lot to take in, right? But take a deep breath — you don’t have to learn everything at once. Each piece can be used independently, so you can learn them individually before you fit them together. D3 is not a single monolith but rather a suite of 30 discrete libraries (or “modules”). We bundle these modules together for convenience rather than necessity so your tools are within reach as you iterate on your design.What all’s in the D3 toolbox? We recommend exploring the documentation and examples to get a sense of what’s relevant to you.TIPUnless you need D3’s low-level control, we recommend our high-level sister library: Observable Plot. Whereas a histogram in D3 might require 50 lines of code, Plot can do it in one! Plot’s concise yet expressive API lets you focus more on analyzing and visualizing data instead of web development. You can even combine Plot and D3 for the best of both.D3 is flexible ​Because D3 has no overarching “chart” abstraction, even a basic chart may require a few dozen lines of code. On the upside, all the pieces are laid out in front of you and you have complete control over what happens. You can tailor the visualization to achieve exactly what you want. D3 has no default presentation of your data — there’s just the code you write yourself. (Or copy from an example.)Consider D3 an alternative to “doing everything yourself”, not an alternative to a high-level charting library. If you aren’t satisfied with other tools and you’re thinking of rolling your own charts using SVG or Canvas (or even WebGL), you might as well peruse D3’s toolbox! There’s almost certainly something here that will help you build the chart of your dreams without imposing on your creativity.D3 works with the web ​D3 doesn’t introduce a new graphical representation; instead, you use D3 directly with web standards such as SVG and Canvas.The name “D3” is short for data-driven documents, where documents refers to the Document Object Model (DOM) standard that represents the contents of a webpage. While some of D3’s modules (such as selections and transitions) touch the DOM, others (including scales and shapes) only operate on data. D3 can also be paired with web frameworks such as React, Vue, and Svelte; see the getting started guide for recommendations.D3’s embrace of web standards brings many benefits. For example, you can use external stylesheets to alter the appearance of charts (even in response to media queries, say for responsive charts or dark mode); you can use the debugger and element inspector to review what your code is doing; and D3’s synchronous, imperative evaluation model — calling selection.attr immediately mutates the DOM — can make it easier to debug than frameworks with complex asynchronous runtimes.D3 is for bespoke visualization ​D3 makes things possible, not necessarily easy; even simple things that should be easy are often not. To paraphrase Amanda Cox: “Use D3 if you think it’s perfectly normal to write a hundred lines of code for a bar chart.”If you need maximal expressiveness for your bespoke visualization, you should consider D3. D3 makes sense for media organizations such as The New York Times or The Pudding, where a single graphic may be seen by a million readers, and where a team of editors can work together to advance the state of the art in visual communication.On the other hand, D3 is overkill for throwing together a private dashboard or a one-off analysis. Don’t get seduced by whizbang examples: many of them took an immense effort to implement! If you’re constrained by time (and who isn’t?), you’d likely produce a better visualization or analysis with Observable Plot.D3 is for dynamic visualization ​D3’s most novel concept is its data join: given a set of data and a set of DOM elements, the data join allows you to apply separate operations for entering, updating, and exiting elements. If you’re only creating static charts (charts that don’t animate or respond to user input), you may find this concept unintuitive or even bizarre because it’s not needed.The data join exists so that you can control exactly what happens when your data changes and update the display in response. This direct control allows extremely performant updates — you only touch the elements and attributes that need changing, without diffing the DOM — and smooth animated transitions between states. D3 shines for dynamic, interactive visualizations. (Try option-clicking the state toggles in “512 Paths to the White House” from 2012. Really.)PagerNext pageGetting started\n\nWhat is D3? ​D3 (or D3.js) is a free, open-source JavaScript library for visualizing data. Its low-level approach built on web standards offers unparalleled flexibility in authoring dynamic, data-driven graphics. For more than a decade D3 has powered groundbreaking and award-winning visualizations, become a foundational building block of higher-level chart libraries, and fostered a vibrant community of data practitioners around the world.D3 “slingshotted the field into growth, diversification and creativity that has been unprecedented” and “changed how millions of data visualizations are created across newsrooms, websites, and personal portfolios,” remarked the Information is Beautiful 2022 Test of Time Award. The IEEE VIS 2021 Test of Time Award noted, “By creating a framework that was compelling and easy for web developers to use to author interactive visualizations, the authors have undeniably helped to bring data visualization to the mainstream. [D3] is a cornerstone contribution to this conference specifically and more generally to the success of our field as a whole.”D3 was created by Mike Bostock in 2011. Mike co-authored the D3 paper with Jeff Heer and Vadim Ogievetsky at Stanford. Jason Davies made major contributions to D3 from 2011 to 2013, most notably to D3’s geographic projection system. Philippe Rivière has been a major contributor to D3 and its documentation since 2016. Over the years, countless kind individuals have contributed to D3 by sharing code and ideas, by teaching and answering questions, and by bringing people together to further the practice of visualization. Mike and Philippe now maintain D3 and Observable Plot at Observable.D3 is a low-level toolbox ​D3 is not a charting library in the traditional sense. It has no concept of “charts”. When you visualize data with D3, you compose a variety of primitives.To make a stacked area chart, you might usea CSV parser to load data,a time scale for horizontal position (x),a linear scale for vertical position (y),an ordinal scale and categorical scheme for color,a stack layout for arranging values,an area shape with a linear curve for generating SVG path data,axes for documenting the position encodings, andselections for creating SVG elements.That’s a lot to take in, right? But take a deep breath — you don’t have to learn everything at once. Each piece can be used independently, so you can learn them individually before you fit them together. D3 is not a single monolith but rather a suite of 30 discrete libraries (or “modules”). We bundle these modules together for convenience rather than necessity so your tools are within reach as you iterate on your design.What all’s in the D3 toolbox? We recommend exploring the documentation and examples to get a sense of what’s relevant to you.TIPUnless you need D3’s low-level control, we recommend our high-level sister library: Observable Plot. Whereas a histogram in D3 might require 50 lines of code, Plot can do it in one! Plot’s concise yet expressive API lets you focus more on analyzing and visualizing data instead of web development. You can even combine Plot and D3 for the best of both.D3 is flexible ​Because D3 has no overarching “chart” abstraction, even a basic chart may require a few dozen lines of code. On the upside, all the pieces are laid out in front of you and you have complete control over what happens. You can tailor the visualization to achieve exactly what you want. D3 has no default presentation of your data — there’s just the code you write yourself. (Or copy from an example.)Consider D3 an alternative to “doing everything yourself”, not an alternative to a high-level charting library. If you aren’t satisfied with other tools and you’re thinking of rolling your own charts using SVG or Canvas (or even WebGL), you might as well peruse D3’s toolbox! There’s almost certainly something here that will help you build the chart of your dreams without imposing on your creativity.D3 works with the web ​D3 doesn’t introduce a new graphical representation; instead, you use D3 directly with web standards such as SVG and Canvas.The name “D3” is short for data-driven documents, where documents refers to the Document Object Model (DOM) standard that represents the contents of a webpage. While some of D3’s modules (such as selections and transitions) touch the DOM, others (including scales and shapes) only operate on data. D3 can also be paired with web frameworks such as React, Vue, and Svelte; see the getting started guide for recommendations.D3’s embrace of web standards brings many benefits. For example, you can use external stylesheets to alter the appearance of charts (even in response to media queries, say for responsive charts or dark mode); you can use the debugger and element inspector to review what your code is doing; and D3’s synchronous, imperative evaluation model — calling selection.attr immediately mutates the DOM — can make it easier to debug than frameworks with complex asynchronous runtimes.D3 is for bespoke visualization ​D3 makes things possible, not necessarily easy; even simple things that should be easy are often not. To paraphrase Amanda Cox: “Use D3 if you think it’s perfectly normal to write a hundred lines of code for a bar chart.”If you need maximal expressiveness for your bespoke visualization, you should consider D3. D3 makes sense for media organizations such as The New York Times or The Pudding, where a single graphic may be seen by a million readers, and where a team of editors can work together to advance the state of the art in visual communication.On the other hand, D3 is overkill for throwing together a private dashboard or a one-off analysis. Don’t get seduced by whizbang examples: many of them took an immense effort to implement! If you’re constrained by time (and who isn’t?), you’d likely produce a better visualization or analysis with Observable Plot.D3 is for dynamic visualization ​D3’s most novel concept is its data join: given a set of data and a set of DOM elements, the data join allows you to apply separate operations for entering, updating, and exiting elements. If you’re only creating static charts (charts that don’t animate or respond to user input), you may find this concept unintuitive or even bizarre because it’s not needed.The data join exists so that you can control exactly what happens when your data changes and update the display in response. This direct control allows extremely performant updates — you only touch the elements and attributes that need changing, without diffing the DOM — and smooth animated transitions between states. D3 shines for dynamic, interactive visualizations. (Try option-clicking the state toggles in “512 Paths to the White House” from 2012. Really.)\n\n\n\nWhat is D3? ​D3 (or D3.js) is a free, open-source JavaScript library for visualizing data. Its low-level approach built on web standards offers unparalleled flexibility in authoring dynamic, data-driven graphics. For more than a decade D3 has powered groundbreaking and award-winning visualizations, become a foundational building block of higher-level chart libraries, and fostered a vibrant community of data practitioners around the world.D3 “slingshotted the field into growth, diversification and creativity that has been unprecedented” and “changed how millions of data visualizations are created across newsrooms, websites, and personal portfolios,” remarked the Information is Beautiful 2022 Test of Time Award. The IEEE VIS 2021 Test of Time Award noted, “By creating a framework that was compelling and easy for web developers to use to author interactive visualizations, the authors have undeniably helped to bring data visualization to the mainstream. [D3] is a cornerstone contribution to this conference specifically and more generally to the success of our field as a whole.”D3 was created by Mike Bostock in 2011. Mike co-authored the D3 paper with Jeff Heer and Vadim Ogievetsky at Stanford. Jason Davies made major contributions to D3 from 2011 to 2013, most notably to D3’s geographic projection system. Philippe Rivière has been a major contributor to D3 and its documentation since 2016. Over the years, countless kind individuals have contributed to D3 by sharing code and ideas, by teaching and answering questions, and by bringing people together to further the practice of visualization. Mike and Philippe now maintain D3 and Observable Plot at Observable.D3 is a low-level toolbox ​D3 is not a charting library in the traditional sense. It has no concept of “charts”. When you visualize data with D3, you compose a variety of primitives.To make a stacked area chart, you might usea CSV parser to load data,a time scale for horizontal position (x),a linear scale for vertical position (y),an ordinal scale and categorical scheme for color,a stack layout for arranging values,an area shape with a linear curve for generating SVG path data,axes for documenting the position encodings, andselections for creating SVG elements.That’s a lot to take in, right? But take a deep breath — you don’t have to learn everything at once. Each piece can be used independently, so you can learn them individually before you fit them together. D3 is not a single monolith but rather a suite of 30 discrete libraries (or “modules”). We bundle these modules together for convenience rather than necessity so your tools are within reach as you iterate on your design.What all’s in the D3 toolbox? We recommend exploring the documentation and examples to get a sense of what’s relevant to you.TIPUnless you need D3’s low-level control, we recommend our high-level sister library: Observable Plot. Whereas a histogram in D3 might require 50 lines of code, Plot can do it in one! Plot’s concise yet expressive API lets you focus more on analyzing and visualizing data instead of web development. You can even combine Plot and D3 for the best of both.D3 is flexible ​Because D3 has no overarching “chart” abstraction, even a basic chart may require a few dozen lines of code. On the upside, all the pieces are laid out in front of you and you have complete control over what happens. You can tailor the visualization to achieve exactly what you want. D3 has no default presentation of your data — there’s just the code you write yourself. (Or copy from an example.)Consider D3 an alternative to “doing everything yourself”, not an alternative to a high-level charting library. If you aren’t satisfied with other tools and you’re thinking of rolling your own charts using SVG or Canvas (or even WebGL), you might as well peruse D3’s toolbox! There’s almost certainly something here that will help you build the chart of your dreams without imposing on your creativity.D3 works with the web ​D3 doesn’t introduce a new graphical representation; instead, you use D3 directly with web standards such as SVG and Canvas.The name “D3” is short for data-driven documents, where documents refers to the Document Object Model (DOM) standard that represents the contents of a webpage. While some of D3’s modules (such as selections and transitions) touch the DOM, others (including scales and shapes) only operate on data. D3 can also be paired with web frameworks such as React, Vue, and Svelte; see the getting started guide for recommendations.D3’s embrace of web standards brings many benefits. For example, you can use external stylesheets to alter the appearance of charts (even in response to media queries, say for responsive charts or dark mode); you can use the debugger and element inspector to review what your code is doing; and D3’s synchronous, imperative evaluation model — calling selection.attr immediately mutates the DOM — can make it easier to debug than frameworks with complex asynchronous runtimes.D3 is for bespoke visualization ​D3 makes things possible, not necessarily easy; even simple things that should be easy are often not. To paraphrase Amanda Cox: “Use D3 if you think it’s perfectly normal to write a hundred lines of code for a bar chart.”If you need maximal expressiveness for your bespoke visualization, you should consider D3. D3 makes sense for media organizations such as The New York Times or The Pudding, where a single graphic may be seen by a million readers, and where a team of editors can work together to advance the state of the art in visual communication.On the other hand, D3 is overkill for throwing together a private dashboard or a one-off analysis. Don’t get seduced by whizbang examples: many of them took an immense effort to implement! If you’re constrained by time (and who isn’t?), you’d likely produce a better visualization or analysis with Observable Plot.D3 is for dynamic visualization ​D3’s most novel concept is its data join: given a set of data and a set of DOM elements, the data join allows you to apply separate operations for entering, updating, and exiting elements. If you’re only creating static charts (charts that don’t animate or respond to user input), you may find this concept unintuitive or even bizarre because it’s not needed.The data join exists so that you can control exactly what happens when your data changes and update the display in response. This direct control allows extremely performant updates — you only touch the elements and attributes that need changing, without diffing the DOM — and smooth animated transitions between states. D3 shines for dynamic, interactive visualizations. (Try option-clicking the state toggles in “512 Paths to the White House” from 2012. Really.)\n\nSearchK7.9.0GitHub️ 110.0kOn this pageWhat is D3? ​D3 (or D3.js) is a free, open-source JavaScript library for visualizing data. Its low-level approach built on web standards offers unparalleled flexibility in authoring dynamic, data-driven graphics. For more than a decade D3 has powered groundbreaking and award-winning visualizations, become a foundational building block of higher-level chart libraries, and fostered a vibrant community of data practitioners around the world.D3 “slingshotted the field into growth, diversification and creativity that has been unprecedented” and “changed how millions of data visualizations are created across newsrooms, websites, and personal portfolios,” remarked the Information is Beautiful 2022 Test of Time Award. The IEEE VIS 2021 Test of Time Award noted, “By creating a framework that was compelling and easy for web developers to use to author interactive visualizations, the authors have undeniably helped to bring data visualization to the mainstream. [D3] is a cornerstone contribution to this conference specifically and more generally to the success of our field as a whole.”D3 was created by Mike Bostock in 2011. Mike co-authored the D3 paper with Jeff Heer and Vadim Ogievetsky at Stanford. Jason Davies made major contributions to D3 from 2011 to 2013, most notably to D3’s geographic projection system. Philippe Rivière has been a major contributor to D3 and its documentation since 2016. Over the years, countless kind individuals have contributed to D3 by sharing code and ideas, by teaching and answering questions, and by bringing people together to further the practice of visualization. Mike and Philippe now maintain D3 and Observable Plot at Observable.D3 is a low-level toolbox ​D3 is not a charting library in the traditional sense. It has no concept of “charts”. When you visualize data with D3, you compose a variety of primitives.To make a stacked area chart, you might usea CSV parser to load data,a time scale for horizontal position (x),a linear scale for vertical position (y),an ordinal scale and categorical scheme for color,a stack layout for arranging values,an area shape with a linear curve for generating SVG path data,axes for documenting the position encodings, andselections for creating SVG elements.That’s a lot to take in, right? But take a deep breath — you don’t have to learn everything at once. Each piece can be used independently, so you can learn them individually before you fit them together. D3 is not a single monolith but rather a suite of 30 discrete libraries (or “modules”). We bundle these modules together for convenience rather than necessity so your tools are within reach as you iterate on your design.What all’s in the D3 toolbox? We recommend exploring the documentation and examples to get a sense of what’s relevant to you.TIPUnless you need D3’s low-level control, we recommend our high-level sister library: Observable Plot. Whereas a histogram in D3 might require 50 lines of code, Plot can do it in one! Plot’s concise yet expressive API lets you focus more on analyzing and visualizing data instead of web development. You can even combine Plot and D3 for the best of both.D3 is flexible ​Because D3 has no overarching “chart” abstraction, even a basic chart may require a few dozen lines of code. On the upside, all the pieces are laid out in front of you and you have complete control over what happens. You can tailor the visualization to achieve exactly what you want. D3 has no default presentation of your data — there’s just the code you write yourself. (Or copy from an example.)Consider D3 an alternative to “doing everything yourself”, not an alternative to a high-level charting library. If you aren’t satisfied with other tools and you’re thinking of rolling your own charts using SVG or Canvas (or even WebGL), you might as well peruse D3’s toolbox! There’s almost certainly something here that will help you build the chart of your dreams without imposing on your creativity.D3 works with the web ​D3 doesn’t introduce a new graphical representation; instead, you use D3 directly with web standards such as SVG and Canvas.The name “D3” is short for data-driven documents, where documents refers to the Document Object Model (DOM) standard that represents the contents of a webpage. While some of D3’s modules (such as selections and transitions) touch the DOM, others (including scales and shapes) only operate on data. D3 can also be paired with web frameworks such as React, Vue, and Svelte; see the getting started guide for recommendations.D3’s embrace of web standards brings many benefits. For example, you can use external stylesheets to alter the appearance of charts (even in response to media queries, say for responsive charts or dark mode); you can use the debugger and element inspector to review what your code is doing; and D3’s synchronous, imperative evaluation model — calling selection.attr immediately mutates the DOM — can make it easier to debug than frameworks with complex asynchronous runtimes.D3 is for bespoke visualization ​D3 makes things possible, not necessarily easy; even simple things that should be easy are often not. To paraphrase Amanda Cox: “Use D3 if you think it’s perfectly normal to write a hundred lines of code for a bar chart.”If you need maximal expressiveness for your bespoke visualization, you should consider D3. D3 makes sense for media organizations such as The New York Times or The Pudding, where a single graphic may be seen by a million readers, and where a team of editors can work together to advance the state of the art in visual communication.On the other hand, D3 is overkill for throwing together a private dashboard or a one-off analysis. Don’t get seduced by whizbang examples: many of them took an immense effort to implement! If you’re constrained by time (and who isn’t?), you’d likely produce a better visualization or analysis with Observable Plot.D3 is for dynamic visualization ​D3’s most novel concept is its data join: given a set of data and a set of DOM elements, the data join allows you to apply separate operations for entering, updating, and exiting elements. If you’re only creating static charts (charts that don’t animate or respond to user input), you may find this concept unintuitive or even bizarre because it’s not needed.The data join exists so that you can control exactly what happens when your data changes and update the display in response. This direct control allows extremely performant updates — you only touch the elements and attributes that need changing, without diffing the DOM — and smooth animated transitions between states. D3 shines for dynamic, interactive visualizations. (Try option-clicking the state toggles in “512 Paths to the White House” from 2012. Really.)PagerNext pageGetting started\n\nWhat is D3? ​D3 (or D3.js) is a free, open-source JavaScript library for visualizing data. Its low-level approach built on web standards offers unparalleled flexibility in authoring dynamic, data-driven graphics. For more than a decade D3 has powered groundbreaking and award-winning visualizations, become a foundational building block of higher-level chart libraries, and fostered a vibrant community of data practitioners around the world.D3 “slingshotted the field into growth, diversification and creativity that has been unprecedented” and “changed how millions of data visualizations are created across newsrooms, websites, and personal portfolios,” remarked the Information is Beautiful 2022 Test of Time Award. The IEEE VIS 2021 Test of Time Award noted, “By creating a framework that was compelling and easy for web developers to use to author interactive visualizations, the authors have undeniably helped to bring data visualization to the mainstream. [D3] is a cornerstone contribution to this conference specifically and more generally to the success of our field as a whole.”D3 was created by Mike Bostock in 2011. Mike co-authored the D3 paper with Jeff Heer and Vadim Ogievetsky at Stanford. Jason Davies made major contributions to D3 from 2011 to 2013, most notably to D3’s geographic projection system. Philippe Rivière has been a major contributor to D3 and its documentation since 2016. Over the years, countless kind individuals have contributed to D3 by sharing code and ideas, by teaching and answering questions, and by bringing people together to further the practice of visualization. Mike and Philippe now maintain D3 and Observable Plot at Observable.D3 is a low-level toolbox ​D3 is not a charting library in the traditional sense. It has no concept of “charts”. When you visualize data with D3, you compose a variety of primitives.To make a stacked area chart, you might usea CSV parser to load data,a time scale for horizontal position (x),a linear scale for vertical position (y),an ordinal scale and categorical scheme for color,a stack layout for arranging values,an area shape with a linear curve for generating SVG path data,axes for documenting the position encodings, andselections for creating SVG elements.That’s a lot to take in, right? But take a deep breath — you don’t have to learn everything at once. Each piece can be used independently, so you can learn them individually before you fit them together. D3 is not a single monolith but rather a suite of 30 discrete libraries (or “modules”). We bundle these modules together for convenience rather than necessity so your tools are within reach as you iterate on your design.What all’s in the D3 toolbox? We recommend exploring the documentation and examples to get a sense of what’s relevant to you.TIPUnless you need D3’s low-level control, we recommend our high-level sister library: Observable Plot. Whereas a histogram in D3 might require 50 lines of code, Plot can do it in one! Plot’s concise yet expressive API lets you focus more on analyzing and visualizing data instead of web development. You can even combine Plot and D3 for the best of both.D3 is flexible ​Because D3 has no overarching “chart” abstraction, even a basic chart may require a few dozen lines of code. On the upside, all the pieces are laid out in front of you and you have complete control over what happens. You can tailor the visualization to achieve exactly what you want. D3 has no default presentation of your data — there’s just the code you write yourself. (Or copy from an example.)Consider D3 an alternative to “doing everything yourself”, not an alternative to a high-level charting library. If you aren’t satisfied with other tools and you’re thinking of rolling your own charts using SVG or Canvas (or even WebGL), you might as well peruse D3’s toolbox! There’s almost certainly something here that will help you build the chart of your dreams without imposing on your creativity.D3 works with the web ​D3 doesn’t introduce a new graphical representation; instead, you use D3 directly with web standards such as SVG and Canvas.The name “D3” is short for data-driven documents, where documents refers to the Document Object Model (DOM) standard that represents the contents of a webpage. While some of D3’s modules (such as selections and transitions) touch the DOM, others (including scales and shapes) only operate on data. D3 can also be paired with web frameworks such as React, Vue, and Svelte; see the getting started guide for recommendations.D3’s embrace of web standards brings many benefits. For example, you can use external stylesheets to alter the appearance of charts (even in response to media queries, say for responsive charts or dark mode); you can use the debugger and element inspector to review what your code is doing; and D3’s synchronous, imperative evaluation model — calling selection.attr immediately mutates the DOM — can make it easier to debug than frameworks with complex asynchronous runtimes.D3 is for bespoke visualization ​D3 makes things possible, not necessarily easy; even simple things that should be easy are often not. To paraphrase Amanda Cox: “Use D3 if you think it’s perfectly normal to write a hundred lines of code for a bar chart.”If you need maximal expressiveness for your bespoke visualization, you should consider D3. D3 makes sense for media organizations such as The New York Times or The Pudding, where a single graphic may be seen by a million readers, and where a team of editors can work together to advance the state of the art in visual communication.On the other hand, D3 is overkill for throwing together a private dashboard or a one-off analysis. Don’t get seduced by whizbang examples: many of them took an immense effort to implement! If you’re constrained by time (and who isn’t?), you’d likely produce a better visualization or analysis with Observable Plot.D3 is for dynamic visualization ​D3’s most novel concept is its data join: given a set of data and a set of DOM elements, the data join allows you to apply separate operations for entering, updating, and exiting elements. If you’re only creating static charts (charts that don’t animate or respond to user input), you may find this concept unintuitive or even bizarre because it’s not needed.The data join exists so that you can control exactly what happens when your data changes and update the display in response. This direct control allows extremely performant updates — you only touch the elements and attributes that need changing, without diffing the DOM — and smooth animated transitions between states. D3 shines for dynamic, interactive visualizations. (Try option-clicking the state toggles in “512 Paths to the White House” from 2012. Really.)\n\n\n\n