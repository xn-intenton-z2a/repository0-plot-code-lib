src/lib/main.js
# src/lib/main.js
#!/usr/bin/env node
// src/lib/main.js

import { fileURLToPath } from "url";
import { create, all } from "mathjs";
import fs from "fs";
import sharp from "sharp";

function parseArgs(args) {
  const opts = {};
  for (let i = 0; i < args.length; i++) {
    switch (args[i]) {
      case "--expression":
        opts.expression = args[++i];
        break;
      case "--range":
        opts.range = args[++i];
        break;
      case "--points":
        opts.points = args[++i];
        break;
      case "--format":
        opts.format = args[++i];
        break;
      case "--output":
        opts.output = args[++i];
        break;
      case "--help":
      case "-h":
        opts.help = true;
        break;
      default:
        // ignore unknown flags
        break;
    }
  }
  return opts;
}

export function renderPlot(data, options = { width: 800, height: 600, margin: 40 }) {
  const { width, height, margin } = options;
  const xs = data.map(p => p.x);
  const ys = data.map(p => p.y);
  const xMin = Math.min(...xs);
  const xMax = Math.max(...xs);
  const yMin = Math.min(...ys);
  const yMax = Math.max(...ys);
  const scaleX = x => ((x - xMin) / (xMax - xMin)) * (width - 2 * margin) + margin;
  const scaleY = y => height - (((y - yMin) / (yMax - yMin)) * (height - 2 * margin) + margin);
  const pathData = data
    .map((p, i) => {
      const x = scaleX(p.x);
      const y = scaleY(p.y);
      return `${i === 0 ? 'M' : 'L'}${x.toFixed(2)},${y.toFixed(2)}`;
    })
    .join(' ');
  return `<svg width="${width}" height="${height}" viewBox="0 0 ${width} ${height}" xmlns="http://www.w3.org/2000/svg"><path d="${pathData}" fill="none" stroke="black"/></svg>`;
}

export async function main(args = process.argv.slice(2)) {
  // Detect if called with explicit arguments vs default invocation
  const explicitInvocation = arguments.length > 0;
  const opts = parseArgs(args);
  const { expression, range, points, format, output, help } = opts;

  const helpText = `
Usage:
  node src/lib/main.js --expression <expr> --range <start:end> [--points <n>] [--format <svg|png>] [--output <file>]

Options:
  --expression   A mathematical expression in terms of x (e.g., y=sin(x)). Required for data generation.
  --range        A numeric range as start:end, with start < end. Required for data generation.
  --points       Number of samples to generate (integer 6gt;= 2). Defaults to 100.
  --format       Output format: svg or png. Defaults to svg.
  --output       Output file path. If omitted, writes to stdout.
  --help, -h     Display this help message.
`;

  if (help) {
    console.log(helpText.trim());
    return [];
  }
  // Missing required flags
  if (!expression || !range) {
    if (!explicitInvocation) {
      console.log(helpText.trim());
      return [];
    }
    console.error('Error: --expression and --range parameters are required.');
    process.exit(1);
  }

  const [startStr, endStr] = range.split(":");
  const start = parseFloat(startStr);
  const end = parseFloat(endStr);
  if (isNaN(start) || isNaN(end) || start >= end) {
    console.error('Error: --range must be in form start:end with start < end.');
    process.exit(1);
  }

  const numPoints = points ? parseInt(points, 10) : 100;
  if (isNaN(numPoints) || numPoints < 2) {
    console.error('Error: --points must be an integer â‰¥ 2.');
    process.exit(1);
  }

  const math = create(all);
  let exprStr = expression.startsWith("y=") ? expression.slice(2) : expression;
  const exprNode = math.parse(exprStr);
  const compiled = exprNode.compile();
  const step = (end - start) / (numPoints - 1);
  const data = [];
  for (let i = 0; i < numPoints; i++) {
    const x = start + i * step;
    let y;
    try {
      y = compiled.evaluate({ x });
    } catch (err) {
      console.error(`Error evaluating expression at x=${x}: ${err.message}`);
      process.exit(1);
    }
    data.push({ x, y });
  }

  // Data-only mode
  if (!format && !output) {
    console.log(JSON.stringify(data, null, 2));
    return data;
  }

  // Plot rendering mode
  const fmt = format || 'svg';
  const svg = renderPlot(data);
  if (fmt === 'svg') {
    if (output) {
      fs.writeFileSync(output, svg);
    } else {
      process.stdout.write(svg);
    }
    process.exit(0);
  }
  if (fmt === 'png') {
    try {
      const buffer = await sharp(Buffer.from(svg)).png().toBuffer();
      if (output) {
        fs.writeFileSync(output, buffer);
      } else {
        process.stdout.write(buffer);
      }
      process.exit(0);
    } catch (err) {
      console.error(`Error generating PNG: ${err.message}`);
      process.exit(1);
    }
  }
  console.error(`Error: Unsupported format: ${fmt}`);
  process.exit(1);
}

if (process.argv[1] === fileURLToPath(import.meta.url)) {
  main();
}