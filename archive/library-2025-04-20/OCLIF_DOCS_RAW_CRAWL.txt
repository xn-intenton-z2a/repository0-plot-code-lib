Getting StartedIntroductionOn this pageIntroductionoclif is a framework for building command-line interfaces (CLIs) using Node.js. You can use it like a simple flag parser, but it's capable of much more. It's designed to be extensible so that you can easily add plugins, such as the update warning plugin, or build your own for users to install at runtime.
The oclif generator creates a CLI project in TypeScript to get you started quickly. The generated CLI requires very few runtime dependencies and has minimal overhead.
Everything is customizable in oclif. Even the flag parser and help generation is optional and can be replaced. It's a platform to build upon that provides smart defaults without locking you in to any specific tools or behavior.
Requirements​
Only LTS Node versions are supported. If you want to ensure that users are on a specifc Node.js version, you can add the node package to your CLI.
To install the oclif CLI itself, run this command:
$ npm install --global oclif
Create an oclif Project from Scratch​
To create a new oclif project from scratch, run the oclif generate command.
$ oclif generate mynewcliGenerating mynewcli in /Users/me/oclif/mynewcli? Select a module type ESM? NPM package name mynewcli? Command bin name the CLI will export mynewcli<more prompts...>$ cd mynewcli$ ./bin/dev.js hello worldhello world! (./src/commands/hello/world.ts)
The command creates a new project based on our templates. To learn more about what's included in these templates, read the documentation here.
After oclif generate completes, run your CLI using the included bin scripts.


Use bin/dev.js to run your CLI in development mode:
$ ./bin/dev.js hello worldhello world! (./src/commands/hello/world.ts)


Use bin/run.js to run your CLI in production mode:
$ ./bin/run.js hello worldhello world! (./src/commands/hello/world.ts)


Initialize oclif in an Existing Project​
If you want to start using oclif inside an existing project, then use the oclif init command to add the necessary files, dependencies, and configuration.
$ oclif init? Command bin name the CLI will export (my-pkg): my-pkg? Select topic separator: spaces? Select a module type: CommonJS? Select a package manager: npmCreated CLI in my-pkg
oclif init adds the following:

bin scripts: bin/run.js, bin/run.cmd, bin/dev.js, and bin/dev.cmd. See bin scripts for more information.
oclif section to package.json with the bin, dirname, commands, and topicSeparator properties set. See Configuring Your CLI for more information.
@oclif/core to the dependencies property in your package.json (if it's not already there).
ts-node to the devDependencies property in your package.json (if it's not already there).

Next Steps​
Add Commands​
After you've generated an oclif project or initialized it in your existing project, start adding new commands. This example creates a new command with the TypeScript source file src/commands/foo/bar.ts that you can customize to do whatever you want:
$ oclif generate command foo:bar
See the documentation for flags and args which shows how to add flags and arguments to your command; the documentation for commands shows the other options you can set on your command.
Add Hooks​
You can also add hooks to your CLI that allow you to further customize the behavior of your CLI:
$ oclif generate hook my-hook --event init
Further customizations​

Configure Your CLI
Custom Help
Use a Base Command Class
Enhance the User Experience

Other Tutorials​
Our friend, @joshcanhelp, wrote a fantastic tutorial on his blog that we encourage you to read as well.Edit this pageLast updated on Dec 20, 2024 by Mike Donnalley\n\nGetting StartedIntroductionOn this pageIntroductionoclif is a framework for building command-line interfaces (CLIs) using Node.js. You can use it like a simple flag parser, but it's capable of much more. It's designed to be extensible so that you can easily add plugins, such as the update warning plugin, or build your own for users to install at runtime.
The oclif generator creates a CLI project in TypeScript to get you started quickly. The generated CLI requires very few runtime dependencies and has minimal overhead.
Everything is customizable in oclif. Even the flag parser and help generation is optional and can be replaced. It's a platform to build upon that provides smart defaults without locking you in to any specific tools or behavior.
Requirements​
Only LTS Node versions are supported. If you want to ensure that users are on a specifc Node.js version, you can add the node package to your CLI.
To install the oclif CLI itself, run this command:
$ npm install --global oclif
Create an oclif Project from Scratch​
To create a new oclif project from scratch, run the oclif generate command.
$ oclif generate mynewcliGenerating mynewcli in /Users/me/oclif/mynewcli? Select a module type ESM? NPM package name mynewcli? Command bin name the CLI will export mynewcli<more prompts...>$ cd mynewcli$ ./bin/dev.js hello worldhello world! (./src/commands/hello/world.ts)
The command creates a new project based on our templates. To learn more about what's included in these templates, read the documentation here.
After oclif generate completes, run your CLI using the included bin scripts.


Use bin/dev.js to run your CLI in development mode:
$ ./bin/dev.js hello worldhello world! (./src/commands/hello/world.ts)


Use bin/run.js to run your CLI in production mode:
$ ./bin/run.js hello worldhello world! (./src/commands/hello/world.ts)


Initialize oclif in an Existing Project​
If you want to start using oclif inside an existing project, then use the oclif init command to add the necessary files, dependencies, and configuration.
$ oclif init? Command bin name the CLI will export (my-pkg): my-pkg? Select topic separator: spaces? Select a module type: CommonJS? Select a package manager: npmCreated CLI in my-pkg
oclif init adds the following:

bin scripts: bin/run.js, bin/run.cmd, bin/dev.js, and bin/dev.cmd. See bin scripts for more information.
oclif section to package.json with the bin, dirname, commands, and topicSeparator properties set. See Configuring Your CLI for more information.
@oclif/core to the dependencies property in your package.json (if it's not already there).
ts-node to the devDependencies property in your package.json (if it's not already there).

Next Steps​
Add Commands​
After you've generated an oclif project or initialized it in your existing project, start adding new commands. This example creates a new command with the TypeScript source file src/commands/foo/bar.ts that you can customize to do whatever you want:
$ oclif generate command foo:bar
See the documentation for flags and args which shows how to add flags and arguments to your command; the documentation for commands shows the other options you can set on your command.
Add Hooks​
You can also add hooks to your CLI that allow you to further customize the behavior of your CLI:
$ oclif generate hook my-hook --event init
Further customizations​

Configure Your CLI
Custom Help
Use a Base Command Class
Enhance the User Experience

Other Tutorials​
Our friend, @joshcanhelp, wrote a fantastic tutorial on his blog that we encourage you to read as well.Edit this pageLast updated on Dec 20, 2024 by Mike DonnalleyNextFeaturesRequirementsCreate an oclif Project from ScratchInitialize oclif in an Existing ProjectNext StepsAdd CommandsAdd HooksFurther customizationsOther Tutorials\n\n\n\nGetting StartedIntroductionOn this pageIntroductionoclif is a framework for building command-line interfaces (CLIs) using Node.js. You can use it like a simple flag parser, but it's capable of much more. It's designed to be extensible so that you can easily add plugins, such as the update warning plugin, or build your own for users to install at runtime.
The oclif generator creates a CLI project in TypeScript to get you started quickly. The generated CLI requires very few runtime dependencies and has minimal overhead.
Everything is customizable in oclif. Even the flag parser and help generation is optional and can be replaced. It's a platform to build upon that provides smart defaults without locking you in to any specific tools or behavior.
Requirements​
Only LTS Node versions are supported. If you want to ensure that users are on a specifc Node.js version, you can add the node package to your CLI.
To install the oclif CLI itself, run this command:
$ npm install --global oclif
Create an oclif Project from Scratch​
To create a new oclif project from scratch, run the oclif generate command.
$ oclif generate mynewcliGenerating mynewcli in /Users/me/oclif/mynewcli? Select a module type ESM? NPM package name mynewcli? Command bin name the CLI will export mynewcli<more prompts...>$ cd mynewcli$ ./bin/dev.js hello worldhello world! (./src/commands/hello/world.ts)
The command creates a new project based on our templates. To learn more about what's included in these templates, read the documentation here.
After oclif generate completes, run your CLI using the included bin scripts.


Use bin/dev.js to run your CLI in development mode:
$ ./bin/dev.js hello worldhello world! (./src/commands/hello/world.ts)


Use bin/run.js to run your CLI in production mode:
$ ./bin/run.js hello worldhello world! (./src/commands/hello/world.ts)


Initialize oclif in an Existing Project​
If you want to start using oclif inside an existing project, then use the oclif init command to add the necessary files, dependencies, and configuration.
$ oclif init? Command bin name the CLI will export (my-pkg): my-pkg? Select topic separator: spaces? Select a module type: CommonJS? Select a package manager: npmCreated CLI in my-pkg
oclif init adds the following:

bin scripts: bin/run.js, bin/run.cmd, bin/dev.js, and bin/dev.cmd. See bin scripts for more information.
oclif section to package.json with the bin, dirname, commands, and topicSeparator properties set. See Configuring Your CLI for more information.
@oclif/core to the dependencies property in your package.json (if it's not already there).
ts-node to the devDependencies property in your package.json (if it's not already there).

Next Steps​
Add Commands​
After you've generated an oclif project or initialized it in your existing project, start adding new commands. This example creates a new command with the TypeScript source file src/commands/foo/bar.ts that you can customize to do whatever you want:
$ oclif generate command foo:bar
See the documentation for flags and args which shows how to add flags and arguments to your command; the documentation for commands shows the other options you can set on your command.
Add Hooks​
You can also add hooks to your CLI that allow you to further customize the behavior of your CLI:
$ oclif generate hook my-hook --event init
Further customizations​

Configure Your CLI
Custom Help
Use a Base Command Class
Enhance the User Experience

Other Tutorials​
Our friend, @joshcanhelp, wrote a fantastic tutorial on his blog that we encourage you to read as well.Edit this pageLast updated on Dec 20, 2024 by Mike Donnalley\n\nGetting StartedIntroductionOn this pageIntroductionoclif is a framework for building command-line interfaces (CLIs) using Node.js. You can use it like a simple flag parser, but it's capable of much more. It's designed to be extensible so that you can easily add plugins, such as the update warning plugin, or build your own for users to install at runtime.
The oclif generator creates a CLI project in TypeScript to get you started quickly. The generated CLI requires very few runtime dependencies and has minimal overhead.
Everything is customizable in oclif. Even the flag parser and help generation is optional and can be replaced. It's a platform to build upon that provides smart defaults without locking you in to any specific tools or behavior.
Requirements​
Only LTS Node versions are supported. If you want to ensure that users are on a specifc Node.js version, you can add the node package to your CLI.
To install the oclif CLI itself, run this command:
$ npm install --global oclif
Create an oclif Project from Scratch​
To create a new oclif project from scratch, run the oclif generate command.
$ oclif generate mynewcliGenerating mynewcli in /Users/me/oclif/mynewcli? Select a module type ESM? NPM package name mynewcli? Command bin name the CLI will export mynewcli<more prompts...>$ cd mynewcli$ ./bin/dev.js hello worldhello world! (./src/commands/hello/world.ts)
The command creates a new project based on our templates. To learn more about what's included in these templates, read the documentation here.
After oclif generate completes, run your CLI using the included bin scripts.


Use bin/dev.js to run your CLI in development mode:
$ ./bin/dev.js hello worldhello world! (./src/commands/hello/world.ts)


Use bin/run.js to run your CLI in production mode:
$ ./bin/run.js hello worldhello world! (./src/commands/hello/world.ts)


Initialize oclif in an Existing Project​
If you want to start using oclif inside an existing project, then use the oclif init command to add the necessary files, dependencies, and configuration.
$ oclif init? Command bin name the CLI will export (my-pkg): my-pkg? Select topic separator: spaces? Select a module type: CommonJS? Select a package manager: npmCreated CLI in my-pkg
oclif init adds the following:

bin scripts: bin/run.js, bin/run.cmd, bin/dev.js, and bin/dev.cmd. See bin scripts for more information.
oclif section to package.json with the bin, dirname, commands, and topicSeparator properties set. See Configuring Your CLI for more information.
@oclif/core to the dependencies property in your package.json (if it's not already there).
ts-node to the devDependencies property in your package.json (if it's not already there).

Next Steps​
Add Commands​
After you've generated an oclif project or initialized it in your existing project, start adding new commands. This example creates a new command with the TypeScript source file src/commands/foo/bar.ts that you can customize to do whatever you want:
$ oclif generate command foo:bar
See the documentation for flags and args which shows how to add flags and arguments to your command; the documentation for commands shows the other options you can set on your command.
Add Hooks​
You can also add hooks to your CLI that allow you to further customize the behavior of your CLI:
$ oclif generate hook my-hook --event init
Further customizations​

Configure Your CLI
Custom Help
Use a Base Command Class
Enhance the User Experience

Other Tutorials​
Our friend, @joshcanhelp, wrote a fantastic tutorial on his blog that we encourage you to read as well.Edit this pageLast updated on Dec 20, 2024 by Mike DonnalleyNextFeaturesRequirementsCreate an oclif Project from ScratchInitialize oclif in an Existing ProjectNext StepsAdd CommandsAdd HooksFurther customizationsOther Tutorials\n\n\n\nThe Open CLI FrameworkCreate command line tools your users loveoclif is an open source framework for building a command line interface (CLI) in Node.js and Typescript. Create CLIs with a few flags or advanced CLIs that have subcommands. oclif makes it easy for you to build CLIs for your company, service, or your own development needs.$ npx oclif generate mynewcli? npm package name (mynewcli): mynewcli$ cd mynewcli$ ./bin/run.js hello worldhello world! (./src/commands/hello/world.ts)Get Started →⚡Ready to goScaffold a fully functional CLI to get started quickly. oclif packages our years of experience into out-of-the-box functionality for argument parsing, command testing, and auto-documentation of CLI features.👐Open sourceoclif is open source and free to use or modify. We think you’ll love it too and you can also help make it better.✅ExtendableYou or your users can easily extend your CLI functionality to meet custom needs using plugins. Plugins are modular and shareable, encouraging reuse.🔒Trustedoclif is actively used to build the Heroku and Salesforce CLIs, powering millions of interactions for developers every day.CLIs built using With oclif you can build command line tools for your business, open source project, or your own development workflow. Check out what others have built.\n\n\n\n📄️ CommandsA basic command looks like the following in TypeScript:📄️ Command ArgumentsArguments are positional arguments passed to the command. For example, if this command was run with mycli arg1 arg2 it would be declared like this:📄️ Command FlagsFlag options are non-positional arguments passed to the command. Flags can either be option flags which take an argument, or boolean flags which do not. An option flag must have an argument.📄️ ConfigInside a command, this.config provides access to the Config class, which contains useful properties and methods you can use in your command. Here are a list of its methods and properties:📄️ Command Discovery StrategiesWhen oclif loads a plugin is must find all the commands within that plugin that can be executed. There a three strategies for discovering these commands:📄️ TopicsAs CLIs grow it can be useful to nest commands within topics. This is supported simply by placing command files in subdirectories. For example, with the Salesforce CLI we have a topic sf config with commands like sf config set and sf config get. The directory structure looks like this:📄️ Topic SeparatorsBy default, topics will be separated with colons, e.g. mycommand. However, you have the option to use spaces if you prefer, e.g. my awesome command.📄️ Hooksoclif exposes lifecycle event hooks such as init and commandnotfound. See below for a list of all the lifecycle events. In addition to these built-in events, you can create your own events and allow commands/plugins to watch for these custom events. It's a great way to allow multiple plugins to interact with each other.📄️ PluginsPlugins are a great way to offer experimental functionality, allow users to extend your CLI, break up a CLI into modular components, or share functionality between CLIs.📄️ Help ClassesOut of the box oclif provides a great help experience for CLIs. Users can invoke help with the --help flag.📄️ Performanceoclif supports performance tracking out of the box - both for oclif and you own code. You can enable it in one of two ways depending on how you've implemented your bin scripts.📄️ CommandsA basic command looks like the following in TypeScript:📄️ Command ArgumentsArguments are positional arguments passed to the command. For example, if this command was run with mycli arg1 arg2 it would be declared like this:📄️ Command FlagsFlag options are non-positional arguments passed to the command. Flags can either be option flags which take an argument, or boolean flags which do not. An option flag must have an argument.📄️ ConfigInside a command, this.config provides access to the Config class, which contains useful properties and methods you can use in your command. Here are a list of its methods and properties:📄️ Command Discovery StrategiesWhen oclif loads a plugin is must find all the commands within that plugin that can be executed. There a three strategies for discovering these commands:📄️ TopicsAs CLIs grow it can be useful to nest commands within topics. This is supported simply by placing command files in subdirectories. For example, with the Salesforce CLI we have a topic sf config with commands like sf config set and sf config get. The directory structure looks like this:📄️ Topic SeparatorsBy default, topics will be separated with colons, e.g. mycommand. However, you have the option to use spaces if you prefer, e.g. my awesome command.📄️ Hooksoclif exposes lifecycle event hooks such as init and commandnotfound. See below for a list of all the lifecycle events. In addition to these built-in events, you can create your own events and allow commands/plugins to watch for these custom events. It's a great way to allow multiple plugins to interact with each other.📄️ PluginsPlugins are a great way to offer experimental functionality, allow users to extend your CLI, break up a CLI into modular components, or share functionality between CLIs.📄️ Help ClassesOut of the box oclif provides a great help experience for CLIs. Users can invoke help with the --help flag.📄️ Performanceoclif supports performance tracking out of the box - both for oclif and you own code. You can enable it in one of two ways depending on how you've implemented your bin scripts.\n\nAPI ReferenceAPI Reference📄️ CommandsA basic command looks like the following in TypeScript:📄️ Command ArgumentsArguments are positional arguments passed to the command. For example, if this command was run with mycli arg1 arg2 it would be declared like this:📄️ Command FlagsFlag options are non-positional arguments passed to the command. Flags can either be option flags which take an argument, or boolean flags which do not. An option flag must have an argument.📄️ ConfigInside a command, this.config provides access to the Config class, which contains useful properties and methods you can use in your command. Here are a list of its methods and properties:📄️ Command Discovery StrategiesWhen oclif loads a plugin is must find all the commands within that plugin that can be executed. There a three strategies for discovering these commands:📄️ TopicsAs CLIs grow it can be useful to nest commands within topics. This is supported simply by placing command files in subdirectories. For example, with the Salesforce CLI we have a topic sf config with commands like sf config set and sf config get. The directory structure looks like this:📄️ Topic SeparatorsBy default, topics will be separated with colons, e.g. mycommand. However, you have the option to use spaces if you prefer, e.g. my awesome command.📄️ Hooksoclif exposes lifecycle event hooks such as init and commandnotfound. See below for a list of all the lifecycle events. In addition to these built-in events, you can create your own events and allow commands/plugins to watch for these custom events. It's a great way to allow multiple plugins to interact with each other.📄️ PluginsPlugins are a great way to offer experimental functionality, allow users to extend your CLI, break up a CLI into modular components, or share functionality between CLIs.📄️ Help ClassesOut of the box oclif provides a great help experience for CLIs. Users can invoke help with the --help flag.📄️ Performanceoclif supports performance tracking out of the box - both for oclif and you own code. You can enable it in one of two ways depending on how you've implemented your bin scripts.PreviousUser ExperienceNextCommands\n\n\n\nIntroducing `oclif init` commandApril 10, 2024 · 2 min readThanks to the contribution of @joshcanhelp we released a new command for the oclif CLI called oclif init in version 4.8.0
The oclif init command allows you to initialize oclif in an existing project directory by adding the bare minimum requirements: a few pieces of configuration, bin scripts, and a couple of dependencies (@oclif/core and ts-node). This is slightly different from oclif generate, which will create an entirely new oclif project based on our templates.
oclif init will add the following:

bin scripts: bin/run.js, bin/run.cmd, bin/dev.js, and bin/dev.cmd
oclif section to package.json with bin, dirname, commands, and topicSeparator set (See Configuring Your CLI for more)
@oclif/core to dependencies in your package.json (if it's not already there)
ts-node to devDependencies in your package.json (if it's not already there)

Once you've initialized oclif, you can use the bin scripts to execute your CLI. You can also use the other oclif commands like oclif generate command and oclif generate hook to start adding new functionality.

❯ oclif init --helpInitialize a new oclif CLIUSAGE  $ oclif init [--bin <value>] [--module-type ESM|CommonJS] [--package-manager npm|yarn|pnpm] [--topic-separator    colons|spaces] [-d <value>] [-y]FLAGS  -d, --output-dir=<value>        Directory to initialize the CLI in.  -y, --yes                       Use defaults for all prompts. Individual flags will override defaults.      --bin=<value>               Supply answer for prompt: Command bin name the CLI will export      --module-type=<option>      Supply answer for prompt: Select a module type                                  <options: ESM|CommonJS>      --package-manager=<option>  Supply answer for prompt: Select a package manager                                  <options: npm|yarn|pnpm>      --topic-separator=<option>  Supply answer for prompt: Select a topic separator                                  <options: colons|spaces>DESCRIPTION  Initialize a new oclif CLI  This will add the necessary oclif bin files, add oclif config to package.json, and install @oclif/core and ts-node.EXAMPLES  Initialize a new CLI in the current directory    $ oclif init  Initialize a new CLI in a different directory    $ oclif init --output-dir "/path/to/existing/project"  Supply answers for specific prompts    $ oclif init --topic-separator colons --bin mycli
Hope you enjoy the new command! If you come across any issues or have any new ideas for this command, head over to the oclif/oclif repo and open a new issue.
All our best,
The oclif teamoclif Spring 2024 UpdateMarch 29, 2024 · 4 min readHello oclif developers! It's been a while since we last uploaded a blog - and a lot has happened.
We've been focusing on these high-level areas over the past couple of years:

Improving @oclif/core
ESM Support
Improving and revitalizing oclif.io
Re-engaging the oclif community

Improving @oclif/core​
Since we announced @oclif/core over three years ago, we've released two new major versions, each packed with lots of features that we're really excited about.
Here are some of these changes:

Full support for ESM and interoperability with CommonJS (more on this topic below).
Configurable command discovery strategies that give you more control over how commands are loaded at runtime. Check out the docs.
A new preparse hook that allows you to manipulate the provided arguments before they're parsed. Salesforce used this hook to implement a neat --flags-dir feature that translates local files into flags.
A new Performance class that you can use to track performance inside of @oclif/core and your own CLI or plugin. Check out the docs.
A new flag type, Flags.option, that lets you define a flag with a preset list of options. Typescript then uses the options to infer the flag's type.
Flags now have a relationship property that allows you to define more complex relationships between flags. Check out the flags docs for more information.
Flags now have a defaultHelp property that allows you to set the human readable default value in the command help. This property is useful when your flag's parse method returns a complex type, such as an object or a class. Check out the flags docs for more.
Commands now have a hiddenAliases property that allows you to define aliases that you want to hide from the user. The property is super helpful when you're trying to wean users off a deprecated command.
You can now use bun or tsx as dev runtimes (as opposed to node or ts-node).
A command's usage, args, and flags are now shown whenever a user forgets to provide a required arg or flag, or when they provided a non-existent flag.

If you need help migrating to the latest version, head over to core's README which has links to the migration guides. Feel free to open a new discussion if you need more hands-on help from us or the community.
ESM Support​
Version 3 of @oclif/core introduced full support for developing ESM plugins and CLIs. It also offered full support for interoperability between CommonJS and ESM plugins.
Put more simply, you can now migrate your CLI to ESM while keeping individual plugins in CommonJS (or vice versa). The upgrade path is now much simpler for you. You also don't need to worry about any community plugins that have migrated to ESM before you did (such as all the @oclif plugins) or are staunchly sticking with CommonJS for the foreseeable future.
Read more about this topic here.
Improving and Revitalizing oclif.io​
Another area of focus for us has been improving our documentation site, oclif.io.
While improving the quality and accuracy of the documentation was our priority, we also took the time to upgrade to the latest version of docusaurus. This new version gave our site a much-needed facelift, as well as cool new features such as dark mode and announcements.
If you have any feedback or are running into issues, we want to hear about it. Just create an issue in the oclif.io repo.
Re-engaging the oclif Community​
Lastly, our biggest priority at the moment is to re-engage the oclif community. We understand how frustrating it has been over the years to see your issues and pull requests go unacknowledged. We apologize for not prioritizing the community, and are earnestly trying to make sure that every issue and pull request gets the attention it deserves going forward.
We also opened up GitHub discussions for @oclif/core and the oclif CLI, where you can now post your questions or ideas. We hope you take advantage of them, we love hearing from you!
One last thing: we intend to publicly post our roadmap so you have more visibility into what we're working on. Stay tuned!
All our best,
The oclif teamAnnouncing oclif v2!January 12, 2022 · 5 min readHello and happy new year! It's our great pleasure to announce that we have released oclif v2, which uses the new @oclif/core library! 🎉
oclif v2 includes many changes that improve the experience of both creating and using an oclif CLI.
Going forward, we don't plan to make any updates to oclif v1 and its corresponding libraries, except for critical security fixes. See the compatibility matrix for a list of these libraries. In order to give developers time to migrate from v1 to v2, we're not completely dropping support yet. But at some point in the future we'll archive the v1 repositories and deprecate their versions on npm.
What’s changing?​
Repository Changes​
All repositories under the oclif org now use main as their primary branch and oclif-v1 as the legacy branch. The main  branch corresponds to oclif v2 and the oclif-v1 branch to oclif v1. If you find any repos that don’t have a main branch, you can safely assume that they're not used in oclif v2 and will be deprecated in the future.
Consolidating Tools & Libraries​
The oclif-dev CLI has now been incorporated into oclif. You now no longer need to install a separate package to manage your entire CLI’s lifecycle.
The following libraries have been consolidated under @oclif/core and will be deprecated at some point in the future. Read the migration guide to learn how to update your CLI or plugin to use the new core library.

@oclif/command
@oclif/config
@oclif/error
@oclif/help
@oclif/parser

No more single vs multi command CLIs​
There's only one "type" of oclif v2 CLI, but it can have as few or as many commands as a developer wants. As a result, there’s only one command to generate CLIs, oclif generate, as opposed to the old oclif single and oclif multi commands.
Node > 12​
To ensure oclif CLIs are as secure as possible, all v2 libraries and plugins support only Node 12 or higher as of now. Going forward, they'll support only Node Maintenance or higher, as defined by Node's release schedule here: https://nodejs.org/en/about/releases/.
What’s new?​
New example CLI​
oclif-hello-world is our new example repo. This is also the repo that's used as a template when running oclif generate to create a new CLI. This repo will always be able to be referenced as an example of what an oclif v2 CLI should look like.
Spaced commands​
oclif CLIs can now use spaces, instead of colons, to separate topics and subcommands. To enable this feature, simply add “topicSeparator": " " to the oclif config in your package.json. See an example in our example repo.
// Old commands that use :$ mycli do:something
// New spaced commands$ mycli do something

Note: Spaced commands are backwards compatible. So if you enable spaced commands for your CLI, users will still be able to use : as a separator. This ensures that any existing scripts don't break.

New Help Output​
We’ve revamped the way command help is outputted to the terminal, making it both easier to implement and easier to read. See the difference between the old help output on the left and the new help output on the right in the screenshots below.
oclif v1oclif v2
Notice that there are new sections for flags and global flags, examples are displayed with better spacing, and there is a section at the bottom called Configuration Variables. This Configuration Variables section is not part of the new help by default. But we've added support for custom help sections, which is what the sf CLI uses to create the new section.
Async Command Parsing​
We’ve also improved the performance of new CLIs by rewriting how commands are parsed on initialization. The new parser is asynchronous, which makes CLIs with a lot of commands or installed  plugins much faster.
What’s coming next?​
Part of our charter for the release of oclif v2 includes improving our engagement with the oclif community. We know that over the past couple of years we’ve reduced our involvement, and a lot of issues and PRs have languished in limbo. Hopefully you’ve already seen increased activity and responses from oclif maintainers recently, but if you haven’t, please don’t hesitate to ping us by tagging @admins in oclif repos.
We also want to start interviewing members of the oclif community to acquire feedback and prioritize the features and fixes you deem most important!
Best,
The oclif team

Reference material​
Migration Guide​
This guide explains how to upgrade a CLI or plugin from the old oclif v1 libraries to the new @oclif/core library that oclif v2 uses.
https://github.com/oclif/core/blob/main/MIGRATION.md
Compatibility Matrix​
The following matrix shows how the v1 libraries and plugins relate to the new v2 ones. Use this matrix as a guide to know what to drop and which versions to switch when upgrading your plugins and CLIs to v2.
oclif "v1"oclif "v2"Utility CLIsoclif@<2@oclif/dev-cli@<2oclif@>=2Main packages@oclif/command@oclif/config@oclif/errors@oclif/parser@oclif/plugin-help@oclif/core@>=1Node LTSNode v8-14Node v12+ (at time of writing)TypeScripttypescript@<4typescript@>=4Main plugins@oclif/plugin-autocomplete@<1@oclif/plugin-commands@<2@oclif/plugin-help@<4@oclif/plugin-not-found@<2@oclif/plugin-plugins@<2@oclif/plugin-update@<2plugin-warn-if-update-available@<2plugin-which@<2@oclif/plugin-autocomplete@>=1@oclif/plugin-commands@>=2@oclif/plugin-help@>=4@oclif/plugin-not-found@>=2@oclif/plugin-plugins@>=2@oclif/plugin-update@>=2@oclif/plugin-warn-if-update-available@>=2@oclif/plugin-which@>=2Introducing @oclif/coreMarch 1, 2021 · 3 min readGreetings!
We hope this blog post finds you well.
Introducing...​
We are excited to announce the next iteration of the oclif project today: @oclif/core.
We have learned a lot in the last three years of developing oclif, developing on oclif and supporting millions of command runs a day via Heroku and Salesforce CLIs.
@oclif/core ("Core") simplifies the oclif development experience and introduces highly requested new features.
Core combines the essential oclif packages into one "core" package, aptly named @oclif/core.
Core also introduces:

A default command option
Colon or space command syntax
Async command parsing
Command piping to arguments

With the introduction of default command functionality, Core simplifies the oclif project and removes the notion of single or multi command CLIs. Core CLIs can have 1 or many commands.
Along with Core, we moved the oclif-dev CLI into the oclif CLI creating a single "utility" CLI. This CLI also introduces a new AWS S3 compatible publishing scheme.
What to expect in the near future​
Core is in pre-release beta and being actively developed for new internal Salesforce CLIs.
Much documentation needs to be written in the coming months including migration paths. Migration onto Core should be as painless as possible with many exports remaining entirely unchanged. Look for forthcoming blog posts and documentation on oclif.io.
Early this summer, tentively June 1, we will release Core v1. Core's release will coincide with major bumps to many other oclif plugin packages. See the compatibility matrix below.
At Core's v1 release, the current "main" oclif packages (namely: command, config, errors & parser) will go into maintenance mode until Jan 2022. They will receive only bug and security fixes and they remain compatible with current versions of the oclif and oclif-dev CLIs. Afterwhich, they will be archived.
Companioning Core, the next major release of the oclif CLI (literally oclif@2) will generate Core CLIs.
Going forward​
We are excited to release Core! We invite you to poke around the Core repo. It may appear to be a big change but Core keeps what you already enjoy about oclif while reducing development complexity, project dependencies, package coupling and bundle size and introduces many requested features previously too prickly to weave into the current oclif architecture.
Best,
The oclif team
Reference: Compatibility matrix​
oclif "v1"oclif "Core"Utility CLIsoclif@<2@oclif/dev-cli@<2oclif@>=2Main packages@oclif/core@<2@oclif/config@<2@oclif/errors@<2@oclif/parser@<4@oclif/plugin-help@<4@oclif/core@>=1Node LTSNode v8-14Node v12+TypeScripttypescript@<4typescript@>=4Main plugins@oclif/plugin-autocomplete@<1@oclif/plugin-commands@<2@oclif/plugin-help@<4@oclif/plugin-not-found@<2@oclif/plugin-plugins@<2@oclif/plugin-update@<2plugin-warn-if-update-available@<2plugin-which@<2@oclif/plugin-autocomplete@>=2@oclif/plugin-commands@>=2@oclif/plugin-help@>=4@oclif/plugin-not-found@>=2@oclif/plugin-plugins@>=2@oclif/plugin-update@>=2@oclif/plugin-warn-if-update-available@>=2@oclif/plugin-which@>=2oclif Summer 2020 UpdateAugust 26, 2020 · 2 min readHello oclif developers! We hope you are all doing well.
Earlier this year, we started our planning for oclifconf v2 and, like all conference, had to change course. We opted not to hold a virtual conference, however, we wanted to take some time to highlight a few oclif features shipped this year.
Feature: Help templating​
One of the most requested features, help templating enables oclif developers to customize the help output for their CLI.
Read the announcement.
Feature: Custom error delegation​
This feature both improved how oclif throws and handles errors and allows oclif developers to overwrite or interject in oclif’s error handling.
Read the announcement.
Feature: postrun hooks​
We have added a new lifecycle event postrun. Your CLI can now run a hook after a command has ran.
See our hook documentation.
Feature: Root index command​
Previously, oclif would display CLI help if only the binary name with no command ID was invoked, oclif now supports a "root index" command. If present, a command defined at src/commands/index.ts will be run if no command ID is found.
1 million weekly downloads​
While exact oclif usage metrics are hard to pin down, we use npm download statistics of oclif packages as a rough approximation. Earlier this year, oclif's command package hit 1 million weekly downloads for the first time!
This year has been presented its challenges on everyone. We want to thank you, oclif developers, whom have taken the time to use and improve the oclif project. We look forward to seeing you all - in person - in the future!
All our best,
The oclif teamPretty Printable ErrorsJuly 1, 2020 · One min readOften CLIs are used as handy tools and when things go wrong it’s useful to have additional context. In oclif we have added a couple of additional properties that can show extra context to the users when an error is displayed. The code, ref and suggestions will now be displayed if they are included. This will work with an existing oclif CLI by adding the latest @oclif/errors and @oclif/core to the CLI's package.json dependencies.
For example, using this.error with the additional properties:
class TestError extends Command {  async run() {    this.error("An error has occurred!", {      code: "OCLIF_ERR",      ref: "https://oclif.io/docs/commands#thiserrormessage-string--error-options-code-string-exit-number",      suggestions: ["Use these extra properties to provide additional context"],    })  }}
would result with the following output:
›   Error: An error has occurred!›   Code: OCLIF_ERR›   Try this: Use these extra properties to provide additional context›   Reference: https://oclif.io/docs/commands#thiserrormessage-string--error-options-code-string-exit-number
If these properties are not provided then nothing changes and the CLI will continue to display the single error message output as it did before. Additionally, as part of this exercise we’ve added documentation around Error Handling in oclif which should come in handy if the need arises to extend oclif’s default handling of errors.Customizing Help in oclifMay 5, 2020 · 2 min readOut of the box oclif provides a great help experience for CLIs.
But what if, as an oclif developer, you want to customize some or all of the output?
You can now customize your CLI's help output by implementing the HelpBase abstract class.
Getting started with custom help​
If you have not done so yet, update @oclif/core.
$ yarn add --latest @oclif/core
To get started, first define the filepath to your help class in oclif's config in package.json. This is a relative path to the help class, without a file extension.
For this example, the help class will be created in a file at "[project root]/src/help.ts".
{  // ...  "oclif": {    "helpClass": "./lib/help"    // ...  }  // ...}
From here there are two paths, implement the HelpBase abstract class yourself or overwrite the parts of the default Help class you want to customize (ex: how command usage is displayed). We recommend the latter approach but cover both in the new Help Classes docs.
Separating TOPICS & COMMANDS in the new default Help class​
Previously, topics and child commands were listed in help output under a single list heading called "COMMANDS". But we found this can be slightly confusing. Some topics are commands also (a.k.a. topic-commands) while others are simply organizational namespacing (and when ran just show their help).
The new default Help class splits the list of children into distinct lists of "TOPICS" and "COMMANDS", with the possibility of an item appearing in both if it a topic-command. This makes it clearer what is expected to be ran - "COMMANDS" - and what is providing structure - "TOPICS" - when looking at the help output.
VERSION  plugin-help-example/0.0.0 darwin-x64 node-v12.12.0USAGE  $ plugin-help-example [COMMAND]TOPICS  topic  this is a topic and has child topics or commandsCOMMANDS  hello  describe the command here  help   display help for plugin-help-example
We look forward to seeing what custom help features you implement in your oclif CLIs with this new feature!oclif TSLint to ESLint MigrationDecember 5, 2019 · 3 min readBack in February of this year, plans were announced to deprecate TSLint in favor of ESLint. TSLint's goal has become to work toward a “unified developer experience” by supporting ESLint development going forward.
What has changed in oclif​
To keep inline with the community, oclif has transitioned to ESLint for all our core libraries as well as all our official plugins.
Starting in v1.15.x, oclif will now optionally generate projects with ESLint for both TypeScript and JavaScript CLI’s.
ESLint does require Node to be on stable LTS version, at the time of writing, Node 8.10.x, Node 10.13.x & Node 12.x.x.
How does this affect you​
Existing CLI’s are unchanged, but any newly generated CLI's will only give the option of using ESLint. If you are running tslint in your CLI, we recommend you switch to ESLint as well.
In migrating our projects we took the following steps (for an example of these changes see this pull request).


Install eslint
$ yarn add eslint eslint-config-oclif eslint-config-oclif-typescript --dev


Add eslint related files


$ echo '{  "extends": [    "oclif",    "oclif-typescript"  ],  "rules": {  }}' > .eslintrc


Remove tslint and related packages
$ yarn remove @oclif/tslint tslint


Remove tslint related configuration files
$ rm tslint.json


Change lint script in our package.json from something like:
"lint": "tsc -p test --noEmit && tslint -p test -t stylish"
to
"lint": "eslint . --ext .ts --config .eslintrc"


To preserve the test compile (tsc -p test --noEmit) we also made the following updates to our scripts:
"pretest": "tsc -p test --noEmit"
In some cases we had our posttest duplicating the same steps as our lint script so it’s cleaner to have it reference the lint job directly with:
"posttest": "yarn lint"

Run yarn lint --fix. This attempts to auto-fix any linting violations automatically. In the case an auto-fix isn’t available it should be fixed manually or ignored (see the eslint configuration doc for more information)
Do a search in the codebase for tslint and remove any unnecessary tslint disabling comments, like:

/* tslint:disable:object-literal-sort-keys */
If you are on a version of Node that is not supported by ESLint, you will also need to update your Node engine. ESLint supports Node 8, 10, and 12 so you should upgrade to the most recent Node version compatible with your CLI and also supported by ESLint (see ESLint's Installation and Usage instructions).
When will this take effect​
These changes have taken effect in oclif v1.15.1. When you generate a new CLI or plugin it will now contain configuration for ESLint instead of TSLint.oclif's Current Node SupportOctober 31, 2019 · 3 min readTo maintain a healthy project trajectory, oclif follows and supports Node Active LTS release, currently Node 10 & Node 12. This means ensuring that oclif continues to play nice with coming Active LTS Node versions and other packages in the ecosystem. Moving forward also means leaving older versions behind. Starting in 2020, Node will stop maintaining Node 8 and it is our intent at that time to also follow suit. Let’s take a look at a few ways we will be supporting these changes.
CI Environments​
CLIs created with the oclif cli going forward will be generated with a CircleCI configuration with Node 10 & 12 and an Appveyor configuration using Node 10. We have also added Node latest to CircleCi to be an early warning detection against coming Node changes (Node latest is managed by CircleCI).
We have already updated every oclif repo's CI configs to reflect this.
If your existing CLI uses either Appveyor or CircleCI you can update your config files also, like so:
.circleci/config.yml​
Your CircleCI config should contain a node-latest job, aliased as test. From this, there should be two extensions of this job for the Active LTS Node versions, Node 10 and Node 12.
  node-10:    <<: *node-latest    docker:      - image: node:10  node-12:    <<: *node-latest    docker:      - image: node:12
Notice that these declarations only change the Docker Node images used to run that job.
Additionally, the jobs listed within workflows must also be updated to reflect our changes in configuration:
    jobs:      - node-latest      - node-10      - node-12
appveyor.yml​
For appveyor we are currently only testing the oldest Active LTS Node version, Node 10. Update the nodejs_version proppert in your appveyor.yml file to reflect this.
environment:  nodejs_version: "10"
Deprecating Node 8 & Updating packge.json engines​
In Jan 2020, Node will end its Node 8 maintenance. We will follow suit by setting the package.json engine property in oclif packages to >=10 and bumping the package's major versions.
Depending on how you ship your CLI you may wish to also bump the engines version in your CLI's package.json. You can read more about the implications of the engines property configuration in the npm documentation.
Also consider distributing your CLI with its own Node version.
Packaged Node Version​
When using dev-cli to pack your CLI it will use the Node version as specified in your package.json under the oclif.update.node.version property. This value should reflect an Active LTS Node version (dev-cli does not currently enforce versions).
Supporting the future​
As a community we may discover bumps along the way as we upgrade. If you notice something related to oclif please feel free to open an issue or submit a pull request under the relevant oclif package within the org.
We look forward to using the latest from Node and the community and keeping oclif healthy along the way.oclifconf 2019: A RecapSeptember 16, 2019 · 4 min readIn May, Heroku and Salesforce Open Source organized oclifconf, a conference for developers & product managers building CLI tools on top of the open source oclif framework. The speakers came from various tech companies, such as Adobe, Netlify, and Apollo, who have already built amazing CLI experiences. The topics covered everything from the incredible capabilities oclif has unlocked, to the community-built plugins extending its functionality, and even what the behavior of an adaptive CLI tool might look like.
Below is a listing of all of the talks from the event, along with a short summary. Enjoy!
The future of oclif by Jeff Dickey​

In its relatively short lifetime, oclif has already inspired many developers and companies to adopt its framework as a means for implementing their own command-line tooling. In this talk, Jeff Dickey, an oclif founding team member, recaps the project's history and inspiration. He also looks towards the future and outlines some features and improvements that the tool could adapt. This isn't so much a definitive roadmap of where oclif is headed, but rather, a call to inspiration for developers eager to contribute! And if you are interested in contributing, check out the open issues in the oclif GitHub repo and come say "Hello!" on Spectrum Chat.
Open Source Citizenship by Josh Simmons​

When it comes to open source, it's more than just individuals now. More and more frequently, large corporations are contributing to projects by donating to contributors, sponsoring events, or upstreaming contributions. But keeping open source projects and communities healthy requires more than just money and brainpower. Josh Simmons surveyed multiple open source communities and relays his findings as to what help maintainers and contributors actually need in this talk.
Building an enterprise-grade CLI with oclif by Thomas Dvornik​

Security and performance are all about trust. While oclif is an extremely extensible framework for building CLI tooling, there are additional requirements to fulfill for enterprise businesses to adopt it that might not be necessary for individual developers. Thomas Dvornik outlines what he and his colleagues at Salesforce have implemented as plugins to oclif to satisfy these needs, including encrypted OAuth, plugin signing, lazy loading dependencies, synchronizing weekly releases and deprecations across dozens of repositories, and establishing cross-team coding and documentation standards.
How Adobe I/O built an extensible CLI with oclif by Jesse MacFadyen​

Perhaps oclif's most appealing feature is its support for plugins. In Cordova's case, they've created a sophisticated telemetry system that helps Adobe developers see which commands users are using--and reports on which ones are erroring out. By embedding a feedback system into the tool, users are even able to quickly send their suggestions to a form, without ever leaving the terminal. Jesse MacFadyen demonstrates how oclif's plugin system can work beyond simply executing commands.
Integrating oclif with GraphQL and Apollo by Evans Hauser​

For Evans Hauser and the team at Apollo, oclif is best thought of as "React for the CLI." As a client paired with a strongly-typed API contract to a server, it can deliver structured and consistent commands to retrieve external data. What better mechanism to use for this transfer than GraphQL, a framework which empowers the client to ask precisely for the data it needs, and nothing more?
Adaptive Intent-based CLI State Machines by Shawn Wang​

In designing oclif, Jeff Dickey wrote out 12 CLI factors to keep in mind. In this talk, Shawn Wang outlines a 13th: state. State is hard, because it depends on context, and context depends on understanding what a user intends to do, not what they are asking. Shawn is working towards enabling oclif to better understand the commands a user has entered, so that it can predict and interpret future commands that might be entered next. This would enable CLI tools to not just interpret a users' commands, but to also interpret their intent.\n\nIntroducing `oclif init` commandApril 10, 2024 · 2 min readThanks to the contribution of @joshcanhelp we released a new command for the oclif CLI called oclif init in version 4.8.0
The oclif init command allows you to initialize oclif in an existing project directory by adding the bare minimum requirements: a few pieces of configuration, bin scripts, and a couple of dependencies (@oclif/core and ts-node). This is slightly different from oclif generate, which will create an entirely new oclif project based on our templates.
oclif init will add the following:

bin scripts: bin/run.js, bin/run.cmd, bin/dev.js, and bin/dev.cmd
oclif section to package.json with bin, dirname, commands, and topicSeparator set (See Configuring Your CLI for more)
@oclif/core to dependencies in your package.json (if it's not already there)
ts-node to devDependencies in your package.json (if it's not already there)

Once you've initialized oclif, you can use the bin scripts to execute your CLI. You can also use the other oclif commands like oclif generate command and oclif generate hook to start adding new functionality.

❯ oclif init --helpInitialize a new oclif CLIUSAGE  $ oclif init [--bin <value>] [--module-type ESM|CommonJS] [--package-manager npm|yarn|pnpm] [--topic-separator    colons|spaces] [-d <value>] [-y]FLAGS  -d, --output-dir=<value>        Directory to initialize the CLI in.  -y, --yes                       Use defaults for all prompts. Individual flags will override defaults.      --bin=<value>               Supply answer for prompt: Command bin name the CLI will export      --module-type=<option>      Supply answer for prompt: Select a module type                                  <options: ESM|CommonJS>      --package-manager=<option>  Supply answer for prompt: Select a package manager                                  <options: npm|yarn|pnpm>      --topic-separator=<option>  Supply answer for prompt: Select a topic separator                                  <options: colons|spaces>DESCRIPTION  Initialize a new oclif CLI  This will add the necessary oclif bin files, add oclif config to package.json, and install @oclif/core and ts-node.EXAMPLES  Initialize a new CLI in the current directory    $ oclif init  Initialize a new CLI in a different directory    $ oclif init --output-dir "/path/to/existing/project"  Supply answers for specific prompts    $ oclif init --topic-separator colons --bin mycli
Hope you enjoy the new command! If you come across any issues or have any new ideas for this command, head over to the oclif/oclif repo and open a new issue.
All our best,
The oclif teamoclif Spring 2024 UpdateMarch 29, 2024 · 4 min readHello oclif developers! It's been a while since we last uploaded a blog - and a lot has happened.
We've been focusing on these high-level areas over the past couple of years:

Improving @oclif/core
ESM Support
Improving and revitalizing oclif.io
Re-engaging the oclif community

Improving @oclif/core​
Since we announced @oclif/core over three years ago, we've released two new major versions, each packed with lots of features that we're really excited about.
Here are some of these changes:

Full support for ESM and interoperability with CommonJS (more on this topic below).
Configurable command discovery strategies that give you more control over how commands are loaded at runtime. Check out the docs.
A new preparse hook that allows you to manipulate the provided arguments before they're parsed. Salesforce used this hook to implement a neat --flags-dir feature that translates local files into flags.
A new Performance class that you can use to track performance inside of @oclif/core and your own CLI or plugin. Check out the docs.
A new flag type, Flags.option, that lets you define a flag with a preset list of options. Typescript then uses the options to infer the flag's type.
Flags now have a relationship property that allows you to define more complex relationships between flags. Check out the flags docs for more information.
Flags now have a defaultHelp property that allows you to set the human readable default value in the command help. This property is useful when your flag's parse method returns a complex type, such as an object or a class. Check out the flags docs for more.
Commands now have a hiddenAliases property that allows you to define aliases that you want to hide from the user. The property is super helpful when you're trying to wean users off a deprecated command.
You can now use bun or tsx as dev runtimes (as opposed to node or ts-node).
A command's usage, args, and flags are now shown whenever a user forgets to provide a required arg or flag, or when they provided a non-existent flag.

If you need help migrating to the latest version, head over to core's README which has links to the migration guides. Feel free to open a new discussion if you need more hands-on help from us or the community.
ESM Support​
Version 3 of @oclif/core introduced full support for developing ESM plugins and CLIs. It also offered full support for interoperability between CommonJS and ESM plugins.
Put more simply, you can now migrate your CLI to ESM while keeping individual plugins in CommonJS (or vice versa). The upgrade path is now much simpler for you. You also don't need to worry about any community plugins that have migrated to ESM before you did (such as all the @oclif plugins) or are staunchly sticking with CommonJS for the foreseeable future.
Read more about this topic here.
Improving and Revitalizing oclif.io​
Another area of focus for us has been improving our documentation site, oclif.io.
While improving the quality and accuracy of the documentation was our priority, we also took the time to upgrade to the latest version of docusaurus. This new version gave our site a much-needed facelift, as well as cool new features such as dark mode and announcements.
If you have any feedback or are running into issues, we want to hear about it. Just create an issue in the oclif.io repo.
Re-engaging the oclif Community​
Lastly, our biggest priority at the moment is to re-engage the oclif community. We understand how frustrating it has been over the years to see your issues and pull requests go unacknowledged. We apologize for not prioritizing the community, and are earnestly trying to make sure that every issue and pull request gets the attention it deserves going forward.
We also opened up GitHub discussions for @oclif/core and the oclif CLI, where you can now post your questions or ideas. We hope you take advantage of them, we love hearing from you!
One last thing: we intend to publicly post our roadmap so you have more visibility into what we're working on. Stay tuned!
All our best,
The oclif teamAnnouncing oclif v2!January 12, 2022 · 5 min readHello and happy new year! It's our great pleasure to announce that we have released oclif v2, which uses the new @oclif/core library! 🎉
oclif v2 includes many changes that improve the experience of both creating and using an oclif CLI.
Going forward, we don't plan to make any updates to oclif v1 and its corresponding libraries, except for critical security fixes. See the compatibility matrix for a list of these libraries. In order to give developers time to migrate from v1 to v2, we're not completely dropping support yet. But at some point in the future we'll archive the v1 repositories and deprecate their versions on npm.
What’s changing?​
Repository Changes​
All repositories under the oclif org now use main as their primary branch and oclif-v1 as the legacy branch. The main  branch corresponds to oclif v2 and the oclif-v1 branch to oclif v1. If you find any repos that don’t have a main branch, you can safely assume that they're not used in oclif v2 and will be deprecated in the future.
Consolidating Tools & Libraries​
The oclif-dev CLI has now been incorporated into oclif. You now no longer need to install a separate package to manage your entire CLI’s lifecycle.
The following libraries have been consolidated under @oclif/core and will be deprecated at some point in the future. Read the migration guide to learn how to update your CLI or plugin to use the new core library.

@oclif/command
@oclif/config
@oclif/error
@oclif/help
@oclif/parser

No more single vs multi command CLIs​
There's only one "type" of oclif v2 CLI, but it can have as few or as many commands as a developer wants. As a result, there’s only one command to generate CLIs, oclif generate, as opposed to the old oclif single and oclif multi commands.
Node > 12​
To ensure oclif CLIs are as secure as possible, all v2 libraries and plugins support only Node 12 or higher as of now. Going forward, they'll support only Node Maintenance or higher, as defined by Node's release schedule here: https://nodejs.org/en/about/releases/.
What’s new?​
New example CLI​
oclif-hello-world is our new example repo. This is also the repo that's used as a template when running oclif generate to create a new CLI. This repo will always be able to be referenced as an example of what an oclif v2 CLI should look like.
Spaced commands​
oclif CLIs can now use spaces, instead of colons, to separate topics and subcommands. To enable this feature, simply add “topicSeparator": " " to the oclif config in your package.json. See an example in our example repo.
// Old commands that use :$ mycli do:something
// New spaced commands$ mycli do something

Note: Spaced commands are backwards compatible. So if you enable spaced commands for your CLI, users will still be able to use : as a separator. This ensures that any existing scripts don't break.

New Help Output​
We’ve revamped the way command help is outputted to the terminal, making it both easier to implement and easier to read. See the difference between the old help output on the left and the new help output on the right in the screenshots below.
oclif v1oclif v2
Notice that there are new sections for flags and global flags, examples are displayed with better spacing, and there is a section at the bottom called Configuration Variables. This Configuration Variables section is not part of the new help by default. But we've added support for custom help sections, which is what the sf CLI uses to create the new section.
Async Command Parsing​
We’ve also improved the performance of new CLIs by rewriting how commands are parsed on initialization. The new parser is asynchronous, which makes CLIs with a lot of commands or installed  plugins much faster.
What’s coming next?​
Part of our charter for the release of oclif v2 includes improving our engagement with the oclif community. We know that over the past couple of years we’ve reduced our involvement, and a lot of issues and PRs have languished in limbo. Hopefully you’ve already seen increased activity and responses from oclif maintainers recently, but if you haven’t, please don’t hesitate to ping us by tagging @admins in oclif repos.
We also want to start interviewing members of the oclif community to acquire feedback and prioritize the features and fixes you deem most important!
Best,
The oclif team

Reference material​
Migration Guide​
This guide explains how to upgrade a CLI or plugin from the old oclif v1 libraries to the new @oclif/core library that oclif v2 uses.
https://github.com/oclif/core/blob/main/MIGRATION.md
Compatibility Matrix​
The following matrix shows how the v1 libraries and plugins relate to the new v2 ones. Use this matrix as a guide to know what to drop and which versions to switch when upgrading your plugins and CLIs to v2.
oclif "v1"oclif "v2"Utility CLIsoclif@<2@oclif/dev-cli@<2oclif@>=2Main packages@oclif/command@oclif/config@oclif/errors@oclif/parser@oclif/plugin-help@oclif/core@>=1Node LTSNode v8-14Node v12+ (at time of writing)TypeScripttypescript@<4typescript@>=4Main plugins@oclif/plugin-autocomplete@<1@oclif/plugin-commands@<2@oclif/plugin-help@<4@oclif/plugin-not-found@<2@oclif/plugin-plugins@<2@oclif/plugin-update@<2plugin-warn-if-update-available@<2plugin-which@<2@oclif/plugin-autocomplete@>=1@oclif/plugin-commands@>=2@oclif/plugin-help@>=4@oclif/plugin-not-found@>=2@oclif/plugin-plugins@>=2@oclif/plugin-update@>=2@oclif/plugin-warn-if-update-available@>=2@oclif/plugin-which@>=2Introducing @oclif/coreMarch 1, 2021 · 3 min readGreetings!
We hope this blog post finds you well.
Introducing...​
We are excited to announce the next iteration of the oclif project today: @oclif/core.
We have learned a lot in the last three years of developing oclif, developing on oclif and supporting millions of command runs a day via Heroku and Salesforce CLIs.
@oclif/core ("Core") simplifies the oclif development experience and introduces highly requested new features.
Core combines the essential oclif packages into one "core" package, aptly named @oclif/core.
Core also introduces:

A default command option
Colon or space command syntax
Async command parsing
Command piping to arguments

With the introduction of default command functionality, Core simplifies the oclif project and removes the notion of single or multi command CLIs. Core CLIs can have 1 or many commands.
Along with Core, we moved the oclif-dev CLI into the oclif CLI creating a single "utility" CLI. This CLI also introduces a new AWS S3 compatible publishing scheme.
What to expect in the near future​
Core is in pre-release beta and being actively developed for new internal Salesforce CLIs.
Much documentation needs to be written in the coming months including migration paths. Migration onto Core should be as painless as possible with many exports remaining entirely unchanged. Look for forthcoming blog posts and documentation on oclif.io.
Early this summer, tentively June 1, we will release Core v1. Core's release will coincide with major bumps to many other oclif plugin packages. See the compatibility matrix below.
At Core's v1 release, the current "main" oclif packages (namely: command, config, errors & parser) will go into maintenance mode until Jan 2022. They will receive only bug and security fixes and they remain compatible with current versions of the oclif and oclif-dev CLIs. Afterwhich, they will be archived.
Companioning Core, the next major release of the oclif CLI (literally oclif@2) will generate Core CLIs.
Going forward​
We are excited to release Core! We invite you to poke around the Core repo. It may appear to be a big change but Core keeps what you already enjoy about oclif while reducing development complexity, project dependencies, package coupling and bundle size and introduces many requested features previously too prickly to weave into the current oclif architecture.
Best,
The oclif team
Reference: Compatibility matrix​
oclif "v1"oclif "Core"Utility CLIsoclif@<2@oclif/dev-cli@<2oclif@>=2Main packages@oclif/core@<2@oclif/config@<2@oclif/errors@<2@oclif/parser@<4@oclif/plugin-help@<4@oclif/core@>=1Node LTSNode v8-14Node v12+TypeScripttypescript@<4typescript@>=4Main plugins@oclif/plugin-autocomplete@<1@oclif/plugin-commands@<2@oclif/plugin-help@<4@oclif/plugin-not-found@<2@oclif/plugin-plugins@<2@oclif/plugin-update@<2plugin-warn-if-update-available@<2plugin-which@<2@oclif/plugin-autocomplete@>=2@oclif/plugin-commands@>=2@oclif/plugin-help@>=4@oclif/plugin-not-found@>=2@oclif/plugin-plugins@>=2@oclif/plugin-update@>=2@oclif/plugin-warn-if-update-available@>=2@oclif/plugin-which@>=2oclif Summer 2020 UpdateAugust 26, 2020 · 2 min readHello oclif developers! We hope you are all doing well.
Earlier this year, we started our planning for oclifconf v2 and, like all conference, had to change course. We opted not to hold a virtual conference, however, we wanted to take some time to highlight a few oclif features shipped this year.
Feature: Help templating​
One of the most requested features, help templating enables oclif developers to customize the help output for their CLI.
Read the announcement.
Feature: Custom error delegation​
This feature both improved how oclif throws and handles errors and allows oclif developers to overwrite or interject in oclif’s error handling.
Read the announcement.
Feature: postrun hooks​
We have added a new lifecycle event postrun. Your CLI can now run a hook after a command has ran.
See our hook documentation.
Feature: Root index command​
Previously, oclif would display CLI help if only the binary name with no command ID was invoked, oclif now supports a "root index" command. If present, a command defined at src/commands/index.ts will be run if no command ID is found.
1 million weekly downloads​
While exact oclif usage metrics are hard to pin down, we use npm download statistics of oclif packages as a rough approximation. Earlier this year, oclif's command package hit 1 million weekly downloads for the first time!
This year has been presented its challenges on everyone. We want to thank you, oclif developers, whom have taken the time to use and improve the oclif project. We look forward to seeing you all - in person - in the future!
All our best,
The oclif teamPretty Printable ErrorsJuly 1, 2020 · One min readOften CLIs are used as handy tools and when things go wrong it’s useful to have additional context. In oclif we have added a couple of additional properties that can show extra context to the users when an error is displayed. The code, ref and suggestions will now be displayed if they are included. This will work with an existing oclif CLI by adding the latest @oclif/errors and @oclif/core to the CLI's package.json dependencies.
For example, using this.error with the additional properties:
class TestError extends Command {  async run() {    this.error("An error has occurred!", {      code: "OCLIF_ERR",      ref: "https://oclif.io/docs/commands#thiserrormessage-string--error-options-code-string-exit-number",      suggestions: ["Use these extra properties to provide additional context"],    })  }}
would result with the following output:
›   Error: An error has occurred!›   Code: OCLIF_ERR›   Try this: Use these extra properties to provide additional context›   Reference: https://oclif.io/docs/commands#thiserrormessage-string--error-options-code-string-exit-number
If these properties are not provided then nothing changes and the CLI will continue to display the single error message output as it did before. Additionally, as part of this exercise we’ve added documentation around Error Handling in oclif which should come in handy if the need arises to extend oclif’s default handling of errors.Customizing Help in oclifMay 5, 2020 · 2 min readOut of the box oclif provides a great help experience for CLIs.
But what if, as an oclif developer, you want to customize some or all of the output?
You can now customize your CLI's help output by implementing the HelpBase abstract class.
Getting started with custom help​
If you have not done so yet, update @oclif/core.
$ yarn add --latest @oclif/core
To get started, first define the filepath to your help class in oclif's config in package.json. This is a relative path to the help class, without a file extension.
For this example, the help class will be created in a file at "[project root]/src/help.ts".
{  // ...  "oclif": {    "helpClass": "./lib/help"    // ...  }  // ...}
From here there are two paths, implement the HelpBase abstract class yourself or overwrite the parts of the default Help class you want to customize (ex: how command usage is displayed). We recommend the latter approach but cover both in the new Help Classes docs.
Separating TOPICS & COMMANDS in the new default Help class​
Previously, topics and child commands were listed in help output under a single list heading called "COMMANDS". But we found this can be slightly confusing. Some topics are commands also (a.k.a. topic-commands) while others are simply organizational namespacing (and when ran just show their help).
The new default Help class splits the list of children into distinct lists of "TOPICS" and "COMMANDS", with the possibility of an item appearing in both if it a topic-command. This makes it clearer what is expected to be ran - "COMMANDS" - and what is providing structure - "TOPICS" - when looking at the help output.
VERSION  plugin-help-example/0.0.0 darwin-x64 node-v12.12.0USAGE  $ plugin-help-example [COMMAND]TOPICS  topic  this is a topic and has child topics or commandsCOMMANDS  hello  describe the command here  help   display help for plugin-help-example
We look forward to seeing what custom help features you implement in your oclif CLIs with this new feature!oclif TSLint to ESLint MigrationDecember 5, 2019 · 3 min readBack in February of this year, plans were announced to deprecate TSLint in favor of ESLint. TSLint's goal has become to work toward a “unified developer experience” by supporting ESLint development going forward.
What has changed in oclif​
To keep inline with the community, oclif has transitioned to ESLint for all our core libraries as well as all our official plugins.
Starting in v1.15.x, oclif will now optionally generate projects with ESLint for both TypeScript and JavaScript CLI’s.
ESLint does require Node to be on stable LTS version, at the time of writing, Node 8.10.x, Node 10.13.x & Node 12.x.x.
How does this affect you​
Existing CLI’s are unchanged, but any newly generated CLI's will only give the option of using ESLint. If you are running tslint in your CLI, we recommend you switch to ESLint as well.
In migrating our projects we took the following steps (for an example of these changes see this pull request).


Install eslint
$ yarn add eslint eslint-config-oclif eslint-config-oclif-typescript --dev


Add eslint related files


$ echo '{  "extends": [    "oclif",    "oclif-typescript"  ],  "rules": {  }}' > .eslintrc


Remove tslint and related packages
$ yarn remove @oclif/tslint tslint


Remove tslint related configuration files
$ rm tslint.json


Change lint script in our package.json from something like:
"lint": "tsc -p test --noEmit && tslint -p test -t stylish"
to
"lint": "eslint . --ext .ts --config .eslintrc"


To preserve the test compile (tsc -p test --noEmit) we also made the following updates to our scripts:
"pretest": "tsc -p test --noEmit"
In some cases we had our posttest duplicating the same steps as our lint script so it’s cleaner to have it reference the lint job directly with:
"posttest": "yarn lint"

Run yarn lint --fix. This attempts to auto-fix any linting violations automatically. In the case an auto-fix isn’t available it should be fixed manually or ignored (see the eslint configuration doc for more information)
Do a search in the codebase for tslint and remove any unnecessary tslint disabling comments, like:

/* tslint:disable:object-literal-sort-keys */
If you are on a version of Node that is not supported by ESLint, you will also need to update your Node engine. ESLint supports Node 8, 10, and 12 so you should upgrade to the most recent Node version compatible with your CLI and also supported by ESLint (see ESLint's Installation and Usage instructions).
When will this take effect​
These changes have taken effect in oclif v1.15.1. When you generate a new CLI or plugin it will now contain configuration for ESLint instead of TSLint.oclif's Current Node SupportOctober 31, 2019 · 3 min readTo maintain a healthy project trajectory, oclif follows and supports Node Active LTS release, currently Node 10 & Node 12. This means ensuring that oclif continues to play nice with coming Active LTS Node versions and other packages in the ecosystem. Moving forward also means leaving older versions behind. Starting in 2020, Node will stop maintaining Node 8 and it is our intent at that time to also follow suit. Let’s take a look at a few ways we will be supporting these changes.
CI Environments​
CLIs created with the oclif cli going forward will be generated with a CircleCI configuration with Node 10 & 12 and an Appveyor configuration using Node 10. We have also added Node latest to CircleCi to be an early warning detection against coming Node changes (Node latest is managed by CircleCI).
We have already updated every oclif repo's CI configs to reflect this.
If your existing CLI uses either Appveyor or CircleCI you can update your config files also, like so:
.circleci/config.yml​
Your CircleCI config should contain a node-latest job, aliased as test. From this, there should be two extensions of this job for the Active LTS Node versions, Node 10 and Node 12.
  node-10:    <<: *node-latest    docker:      - image: node:10  node-12:    <<: *node-latest    docker:      - image: node:12
Notice that these declarations only change the Docker Node images used to run that job.
Additionally, the jobs listed within workflows must also be updated to reflect our changes in configuration:
    jobs:      - node-latest      - node-10      - node-12
appveyor.yml​
For appveyor we are currently only testing the oldest Active LTS Node version, Node 10. Update the nodejs_version proppert in your appveyor.yml file to reflect this.
environment:  nodejs_version: "10"
Deprecating Node 8 & Updating packge.json engines​
In Jan 2020, Node will end its Node 8 maintenance. We will follow suit by setting the package.json engine property in oclif packages to >=10 and bumping the package's major versions.
Depending on how you ship your CLI you may wish to also bump the engines version in your CLI's package.json. You can read more about the implications of the engines property configuration in the npm documentation.
Also consider distributing your CLI with its own Node version.
Packaged Node Version​
When using dev-cli to pack your CLI it will use the Node version as specified in your package.json under the oclif.update.node.version property. This value should reflect an Active LTS Node version (dev-cli does not currently enforce versions).
Supporting the future​
As a community we may discover bumps along the way as we upgrade. If you notice something related to oclif please feel free to open an issue or submit a pull request under the relevant oclif package within the org.
We look forward to using the latest from Node and the community and keeping oclif healthy along the way.oclifconf 2019: A RecapSeptember 16, 2019 · 4 min readIn May, Heroku and Salesforce Open Source organized oclifconf, a conference for developers & product managers building CLI tools on top of the open source oclif framework. The speakers came from various tech companies, such as Adobe, Netlify, and Apollo, who have already built amazing CLI experiences. The topics covered everything from the incredible capabilities oclif has unlocked, to the community-built plugins extending its functionality, and even what the behavior of an adaptive CLI tool might look like.
Below is a listing of all of the talks from the event, along with a short summary. Enjoy!
The future of oclif by Jeff Dickey​

In its relatively short lifetime, oclif has already inspired many developers and companies to adopt its framework as a means for implementing their own command-line tooling. In this talk, Jeff Dickey, an oclif founding team member, recaps the project's history and inspiration. He also looks towards the future and outlines some features and improvements that the tool could adapt. This isn't so much a definitive roadmap of where oclif is headed, but rather, a call to inspiration for developers eager to contribute! And if you are interested in contributing, check out the open issues in the oclif GitHub repo and come say "Hello!" on Spectrum Chat.
Open Source Citizenship by Josh Simmons​

When it comes to open source, it's more than just individuals now. More and more frequently, large corporations are contributing to projects by donating to contributors, sponsoring events, or upstreaming contributions. But keeping open source projects and communities healthy requires more than just money and brainpower. Josh Simmons surveyed multiple open source communities and relays his findings as to what help maintainers and contributors actually need in this talk.
Building an enterprise-grade CLI with oclif by Thomas Dvornik​

Security and performance are all about trust. While oclif is an extremely extensible framework for building CLI tooling, there are additional requirements to fulfill for enterprise businesses to adopt it that might not be necessary for individual developers. Thomas Dvornik outlines what he and his colleagues at Salesforce have implemented as plugins to oclif to satisfy these needs, including encrypted OAuth, plugin signing, lazy loading dependencies, synchronizing weekly releases and deprecations across dozens of repositories, and establishing cross-team coding and documentation standards.
How Adobe I/O built an extensible CLI with oclif by Jesse MacFadyen​

Perhaps oclif's most appealing feature is its support for plugins. In Cordova's case, they've created a sophisticated telemetry system that helps Adobe developers see which commands users are using--and reports on which ones are erroring out. By embedding a feedback system into the tool, users are even able to quickly send their suggestions to a form, without ever leaving the terminal. Jesse MacFadyen demonstrates how oclif's plugin system can work beyond simply executing commands.
Integrating oclif with GraphQL and Apollo by Evans Hauser​

For Evans Hauser and the team at Apollo, oclif is best thought of as "React for the CLI." As a client paired with a strongly-typed API contract to a server, it can deliver structured and consistent commands to retrieve external data. What better mechanism to use for this transfer than GraphQL, a framework which empowers the client to ask precisely for the data it needs, and nothing more?
Adaptive Intent-based CLI State Machines by Shawn Wang​

In designing oclif, Jeff Dickey wrote out 12 CLI factors to keep in mind. In this talk, Shawn Wang outlines a 13th: state. State is hard, because it depends on context, and context depends on understanding what a user intends to do, not what they are asking. Shawn is working towards enabling oclif to better understand the commands a user has entered, so that it can predict and interpret future commands that might be entered next. This would enable CLI tools to not just interpret a users' commands, but to also interpret their intent.Older Entries\n\n\n\nGetting StartedFeaturesOn this pageFeaturesHere are some key features that set oclif apart from other CLI frameworks.
Flag and Argument Parsing​
No CLI framework is complete without a flag parser. We've built a custom flag parser from years of experimentation that we feel is flexible enough to make an easy, predictable user experience but without compromising type safety for the developer.
Configurable Topic Separators​
By default, topics are separated with colons, such as my:awesome:command. However, you can use spaces if you prefer, such as my awesome command.
Super Speed​
The overhead for running an oclif CLI command is almost nothing. The command requires few dependencies; for example, only 17 dependencies are required for a minimal setup. Also, only the command to be executed requires Node.js. Which means that a large CLI with many commands loads as fast as a small CLI with just a single command.
CLI Generator​
You can get started from scratch quickly; all you need is a single command to scaffold out a fully functional CLI. See Generator Commands.
Testing Helpers​
We've worked hard to make commands easily testable and easy to mock out stdout and stderr. The CLI generator automatically creates scaffolded tests.
Auto-documentation​
By default, you pass --help to a CLI command to get help, such as the flag options and argument information. This information is also automatically added to the README whenever the CLI's npm package is published. See the plugin-plugins as an example.
Plugins​
Using plugins, you can extend a CLI with new functionality, split it into modular components, and share its functionality among multiple CLIs. See Building your own plugin.
Hooks​
Use lifecycle hooks to run functionality anytime a CLI starts, or on custom triggers. Use hooks whenever you want to share custom functionality between various components of the CLI. See Hooks.
JSON Output​
Your CLI can opt in to using the --json flag, which causes commands to automatically suppress console logs and display their final results as valid JSON output. The --json flag is useful if you want to use your CLI for scripting in CI/CD environments. See JSON.
Flexible Taxonomy​
You can opt in to what we call flexible taxonomy. When enabled, this feature allows users to execute commands without adhering to your defined command taxonomy.
This feature makes your CLI more user-friendly, especially if you have long command names which users find difficult to remember. For example, users can find it hard to remember if a command is called project deploy metadata start or project start deploy metadata - with flexible taxonomy, it doesn't matter because both are valid!
TypeScript (or not)​
Everything in the core of oclif is written in TypeScript, and the CLI generator can build both fully configured TypeScript or plain JavaScript CLIs. Because of TypeScript static properties, the syntax is a bit cleaner in TypeScript — but everything works, no matter which language you choose. If you use plugins support, the CLI automatically uses ts-node to run the plugins, which makes it easy and fast to use TypeScript with minimal-to-no boilerplate needed for any oclif CLI.
Auto-Updating Installers​
oclif can package your CLI into different installers that don't require the user to already have Node.js installed on their computer. You can make these installers auto-updatable by using plugin-update.
Autocomplete​
Include terminal autocompletion for your CLI with the plugin-autocomplete. After the autocomplete feature is configured, users can complete command names and flag names by pressing the tab key.
$ my-cli p<tab><tab> # lists all commands starting with 'p' for completionEdit this pageLast updated on Dec 20, 2024 by Mike Donnalley\n\nGetting StartedFeaturesOn this pageFeaturesHere are some key features that set oclif apart from other CLI frameworks.
Flag and Argument Parsing​
No CLI framework is complete without a flag parser. We've built a custom flag parser from years of experimentation that we feel is flexible enough to make an easy, predictable user experience but without compromising type safety for the developer.
Configurable Topic Separators​
By default, topics are separated with colons, such as my:awesome:command. However, you can use spaces if you prefer, such as my awesome command.
Super Speed​
The overhead for running an oclif CLI command is almost nothing. The command requires few dependencies; for example, only 17 dependencies are required for a minimal setup. Also, only the command to be executed requires Node.js. Which means that a large CLI with many commands loads as fast as a small CLI with just a single command.
CLI Generator​
You can get started from scratch quickly; all you need is a single command to scaffold out a fully functional CLI. See Generator Commands.
Testing Helpers​
We've worked hard to make commands easily testable and easy to mock out stdout and stderr. The CLI generator automatically creates scaffolded tests.
Auto-documentation​
By default, you pass --help to a CLI command to get help, such as the flag options and argument information. This information is also automatically added to the README whenever the CLI's npm package is published. See the plugin-plugins as an example.
Plugins​
Using plugins, you can extend a CLI with new functionality, split it into modular components, and share its functionality among multiple CLIs. See Building your own plugin.
Hooks​
Use lifecycle hooks to run functionality anytime a CLI starts, or on custom triggers. Use hooks whenever you want to share custom functionality between various components of the CLI. See Hooks.
JSON Output​
Your CLI can opt in to using the --json flag, which causes commands to automatically suppress console logs and display their final results as valid JSON output. The --json flag is useful if you want to use your CLI for scripting in CI/CD environments. See JSON.
Flexible Taxonomy​
You can opt in to what we call flexible taxonomy. When enabled, this feature allows users to execute commands without adhering to your defined command taxonomy.
This feature makes your CLI more user-friendly, especially if you have long command names which users find difficult to remember. For example, users can find it hard to remember if a command is called project deploy metadata start or project start deploy metadata - with flexible taxonomy, it doesn't matter because both are valid!
TypeScript (or not)​
Everything in the core of oclif is written in TypeScript, and the CLI generator can build both fully configured TypeScript or plain JavaScript CLIs. Because of TypeScript static properties, the syntax is a bit cleaner in TypeScript — but everything works, no matter which language you choose. If you use plugins support, the CLI automatically uses ts-node to run the plugins, which makes it easy and fast to use TypeScript with minimal-to-no boilerplate needed for any oclif CLI.
Auto-Updating Installers​
oclif can package your CLI into different installers that don't require the user to already have Node.js installed on their computer. You can make these installers auto-updatable by using plugin-update.
Autocomplete​
Include terminal autocompletion for your CLI with the plugin-autocomplete. After the autocomplete feature is configured, users can complete command names and flag names by pressing the tab key.
$ my-cli p<tab><tab> # lists all commands starting with 'p' for completionEdit this pageLast updated on Dec 20, 2024 by Mike DonnalleyPreviousIntroductionNextFAQsFlag and Argument ParsingConfigurable Topic SeparatorsSuper SpeedCLI GeneratorTesting HelpersAuto-documentationPluginsHooksJSON OutputFlexible TaxonomyTypeScript (or not)Auto-Updating InstallersAutocomplete\n\n\n\nGetting StartedFAQsOn this pageFAQsWhy Node?​
There are a number of reasons why Node is the best choice for writing CLI code. At Salesforce, we've released the Heroku CLI in Ruby, Go, as well as Node. Read this article for details on that history. But in the end, we found that Node offers the best of everything.
First, JavaScript is the biggest language in the world. More people write in JavaScript than in any other programming language, and it has the biggest open-source community, by far. Because everyone can write it, you can find many useful libraries to help build your CLI.
We've also found that Node has the best cross-platform support of any language we've used. In general, if you write code on macOS, you rarely find issues making it also run on Windows.
Node has the best support for our plugins model. Plugins are a way to share code between CLIs, to modularize a CLI's codebase, and to allow users to add functionality to an existing CLI. With Node, we can have separate dependency versions sitting alongside one another. As a result, if you want to release an update to a dependency in one plugin, it doesn't affect how another plugin works. oclif takes this to an extreme so that even flag parsing is done at the individual plugin level. For example, if we ever want to make a breaking change to flag parsing (don't worry, we don't intend to!), you can update just one plugin and keep the old behavior in other plugins. This feature is very helpful for large CLI codebases where you want to migrate to new code slowly.
How can I create a single binary CLI, like with Go?​
Use pkg. Make sure you add the commands and other source files by setting pkg.scripts: "./lib/**/*.js" in package.json.
In Salesforce CLI, however, we prefer to ship a tarball and various installers that have Node baked in. Use oclif pack to create a set of tarballs for different platforms with Node built in. You probably must use @oclif/plugin-update in your CLI, otherwise the users won't have a way to update the CLI from the tarball without reinstalling it.
Should I use TypeScript or JavaScript?​
We suggest you use TypeScript, because we find the typing helpful when refactoring code and updating dependencies. It's nicer to get compilation errors rather than finding errors in production.
We've put a lot of care into making it easy to create a TypeScript CLI, even if you've never written TypeScript before. We generate CLIs and plugins that use ts-node, which makes it fast to run the TypeScript code without a compilation step. And you don't have to mess around with build configuration using oclif.
Still, the two languages are very similar today. The code you write in JavaScript will be nearly identical to what you would have in TypeScript, but with no type definitions of course.
What editor is best for oclif?​
If you already have a favorite editor, go ahead and keep using it. However, we typically recommend Visual Studio Code, or VS Code for short.
Microsoft has done a great job with this editor and it works particularly well for TypeScript projects. You get nice type checking, linting, and autocomplete, right out of the box.
Should I use npm or yarn?​
It doesn't make that much of a difference. If you're just getting started, keep it simple and use npm, which comes with Node. We like to use yarn internally, as it's a bit faster and we find the lockfiles friendlier.
How can I make the oclif generator run faster?​
If you're using npx, first install oclif by running npm install -g oclif. But to stay current with the latest updates, you must manually run npm update -g oclif to get new versions of the generator.
Why isn't Node X supported?​
The oclif project follows and supports Node's LTS support schedule, which allows oclif to stay current with Node's development.
How do I pronounce "oclif"?​
We say "oh-cliff".Edit this pageLast updated on Dec 20, 2024 by Mike Donnalley\n\nGetting StartedFAQsOn this pageFAQsWhy Node?​
There are a number of reasons why Node is the best choice for writing CLI code. At Salesforce, we've released the Heroku CLI in Ruby, Go, as well as Node. Read this article for details on that history. But in the end, we found that Node offers the best of everything.
First, JavaScript is the biggest language in the world. More people write in JavaScript than in any other programming language, and it has the biggest open-source community, by far. Because everyone can write it, you can find many useful libraries to help build your CLI.
We've also found that Node has the best cross-platform support of any language we've used. In general, if you write code on macOS, you rarely find issues making it also run on Windows.
Node has the best support for our plugins model. Plugins are a way to share code between CLIs, to modularize a CLI's codebase, and to allow users to add functionality to an existing CLI. With Node, we can have separate dependency versions sitting alongside one another. As a result, if you want to release an update to a dependency in one plugin, it doesn't affect how another plugin works. oclif takes this to an extreme so that even flag parsing is done at the individual plugin level. For example, if we ever want to make a breaking change to flag parsing (don't worry, we don't intend to!), you can update just one plugin and keep the old behavior in other plugins. This feature is very helpful for large CLI codebases where you want to migrate to new code slowly.
How can I create a single binary CLI, like with Go?​
Use pkg. Make sure you add the commands and other source files by setting pkg.scripts: "./lib/**/*.js" in package.json.
In Salesforce CLI, however, we prefer to ship a tarball and various installers that have Node baked in. Use oclif pack to create a set of tarballs for different platforms with Node built in. You probably must use @oclif/plugin-update in your CLI, otherwise the users won't have a way to update the CLI from the tarball without reinstalling it.
Should I use TypeScript or JavaScript?​
We suggest you use TypeScript, because we find the typing helpful when refactoring code and updating dependencies. It's nicer to get compilation errors rather than finding errors in production.
We've put a lot of care into making it easy to create a TypeScript CLI, even if you've never written TypeScript before. We generate CLIs and plugins that use ts-node, which makes it fast to run the TypeScript code without a compilation step. And you don't have to mess around with build configuration using oclif.
Still, the two languages are very similar today. The code you write in JavaScript will be nearly identical to what you would have in TypeScript, but with no type definitions of course.
What editor is best for oclif?​
If you already have a favorite editor, go ahead and keep using it. However, we typically recommend Visual Studio Code, or VS Code for short.
Microsoft has done a great job with this editor and it works particularly well for TypeScript projects. You get nice type checking, linting, and autocomplete, right out of the box.
Should I use npm or yarn?​
It doesn't make that much of a difference. If you're just getting started, keep it simple and use npm, which comes with Node. We like to use yarn internally, as it's a bit faster and we find the lockfiles friendlier.
How can I make the oclif generator run faster?​
If you're using npx, first install oclif by running npm install -g oclif. But to stay current with the latest updates, you must manually run npm update -g oclif to get new versions of the generator.
Why isn't Node X supported?​
The oclif project follows and supports Node's LTS support schedule, which allows oclif to stay current with Node's development.
How do I pronounce "oclif"?​
We say "oh-cliff".Edit this pageLast updated on Dec 20, 2024 by Mike DonnalleyPreviousFeaturesNextGenerator CommandsWhy Node?How can I create a single binary CLI, like with Go?Should I use TypeScript or JavaScript?What editor is best for oclif?Should I use npm or yarn?How can I make the oclif generator run faster?Why isn't Node X supported?How do I pronounce "oclif"?\n\n\n\nGetting StartedGenerator CommandsOn this pageGenerator CommandsUse these commands to generate the scaffoling for a new CLI, a command, or a hook. The scaffolding includes CLI configuration files, scripts, and sample TypeScript files for a simple  hello world command.
Run each command with the --help flag, but without its argument, to see the same information documented below; for example, oclif generate --help.

oclif generate NAME
oclif generate command NAME
oclif generate hook NAME

oclif generate NAME​
Generate a new CLI.
USAGE  $ oclif generate NAME [--author <value>] [--bin <value>] [--description <value>] [--license <value>]    [--module-type CommonJS|ESM] [--name <value>] [--owner <value>] [--package-manager npm|yarn|pnpm] [--repository    <value>] [-d <value>] [-y]ARGUMENTS  NAME  Directory name of new project.FLAGS  -d, --output-dir=<value>        Directory to build the CLI in.  -y, --yes                       Use defaults for all prompts. Individual flags will override defaults.      --author=<value>            Supply answer for prompt: Author      --bin=<value>               Supply answer for prompt: Command bin name the CLI will export      --description=<value>       Supply answer for prompt: Description      --license=<value>           Supply answer for prompt: License      --module-type=<option>      Supply answer for prompt: Select a module type                                  <options: CommonJS|ESM>      --name=<value>              Supply answer for prompt: NPM package name      --owner=<value>             Supply answer for prompt: Who is the GitHub owner of repository                                  (https://github.com/OWNER/repo)      --package-manager=<option>  Supply answer for prompt: Select a package manager                                  <options: npm|yarn|pnpm>      --repository=<value>        Supply answer for prompt: What is the GitHub name of repository                                  (https://github.com/owner/REPO)DESCRIPTION  Generate a new CLI  This will generate a fully functional oclif CLI that you can build on. It will prompt you for all the necessary  information to get started. If you want to skip the prompts, you can pass the --yes flag to accept the defaults for  all prompts. You can also pass individual flags to set specific values for prompts.  Head to oclif.io/docs/introduction to learn more about building CLIs with oclif.EXAMPLES  Generate a new CLI with prompts for all properties    $ oclif generate my-cli  Automatically accept default values for all prompts    $ oclif generate my-cli --yes  Supply answers for specific prompts    $ oclif generate my-cli --module-type CommonJS --author "John Doe"  Supply answers for specific prompts and accept default values for the rest    $ oclif generate my-cli --module-type CommonJS --author "John Doe" --yes
See code: src/commands/generate.ts
oclif generate command NAME​
Add a command to an existing CLI or plugin.
USAGE  $ oclif generate command NAME [--commands-dir <value>] [--force]ARGUMENTS  NAME  name of commandFLAGS  --commands-dir=<value>  [default: src/commands] The directory to create the command in.  --force                 Overwrite existing files.DESCRIPTION  Add a command to an existing CLI or plugin.
See code: src/commands/generate/command.ts
oclif generate hook NAME​
Add a hook to an existing CLI or plugin.
USAGE  $ oclif generate hook NAME [--event <value>] [--force]ARGUMENTS  NAME  Name of hook (snake_case).FLAGS  --event=<value>  [default: init] Event to run hook on.  --force          Overwrite existing files.DESCRIPTION  Add a hook to an existing CLI or plugin.
See code: src/commands/generate/hook.tsEdit this pageLast updated on Dec 20, 2024 by Mike Donnalley\n\nGetting StartedGenerator CommandsOn this pageGenerator CommandsUse these commands to generate the scaffoling for a new CLI, a command, or a hook. The scaffolding includes CLI configuration files, scripts, and sample TypeScript files for a simple  hello world command.
Run each command with the --help flag, but without its argument, to see the same information documented below; for example, oclif generate --help.

oclif generate NAME
oclif generate command NAME
oclif generate hook NAME

oclif generate NAME​
Generate a new CLI.
USAGE  $ oclif generate NAME [--author <value>] [--bin <value>] [--description <value>] [--license <value>]    [--module-type CommonJS|ESM] [--name <value>] [--owner <value>] [--package-manager npm|yarn|pnpm] [--repository    <value>] [-d <value>] [-y]ARGUMENTS  NAME  Directory name of new project.FLAGS  -d, --output-dir=<value>        Directory to build the CLI in.  -y, --yes                       Use defaults for all prompts. Individual flags will override defaults.      --author=<value>            Supply answer for prompt: Author      --bin=<value>               Supply answer for prompt: Command bin name the CLI will export      --description=<value>       Supply answer for prompt: Description      --license=<value>           Supply answer for prompt: License      --module-type=<option>      Supply answer for prompt: Select a module type                                  <options: CommonJS|ESM>      --name=<value>              Supply answer for prompt: NPM package name      --owner=<value>             Supply answer for prompt: Who is the GitHub owner of repository                                  (https://github.com/OWNER/repo)      --package-manager=<option>  Supply answer for prompt: Select a package manager                                  <options: npm|yarn|pnpm>      --repository=<value>        Supply answer for prompt: What is the GitHub name of repository                                  (https://github.com/owner/REPO)DESCRIPTION  Generate a new CLI  This will generate a fully functional oclif CLI that you can build on. It will prompt you for all the necessary  information to get started. If you want to skip the prompts, you can pass the --yes flag to accept the defaults for  all prompts. You can also pass individual flags to set specific values for prompts.  Head to oclif.io/docs/introduction to learn more about building CLIs with oclif.EXAMPLES  Generate a new CLI with prompts for all properties    $ oclif generate my-cli  Automatically accept default values for all prompts    $ oclif generate my-cli --yes  Supply answers for specific prompts    $ oclif generate my-cli --module-type CommonJS --author "John Doe"  Supply answers for specific prompts and accept default values for the rest    $ oclif generate my-cli --module-type CommonJS --author "John Doe" --yes
See code: src/commands/generate.ts
oclif generate command NAME​
Add a command to an existing CLI or plugin.
USAGE  $ oclif generate command NAME [--commands-dir <value>] [--force]ARGUMENTS  NAME  name of commandFLAGS  --commands-dir=<value>  [default: src/commands] The directory to create the command in.  --force                 Overwrite existing files.DESCRIPTION  Add a command to an existing CLI or plugin.
See code: src/commands/generate/command.ts
oclif generate hook NAME​
Add a hook to an existing CLI or plugin.
USAGE  $ oclif generate hook NAME [--event <value>] [--force]ARGUMENTS  NAME  Name of hook (snake_case).FLAGS  --event=<value>  [default: init] Event to run hook on.  --force          Overwrite existing files.DESCRIPTION  Add a hook to an existing CLI or plugin.
See code: src/commands/generate/hook.tsEdit this pageLast updated on Dec 20, 2024 by Mike DonnalleyPreviousFAQsNextTemplatesoclif generate NAMEoclif generate command NAMEoclif generate hook NAME\n\n\n\nGetting StartedTemplatesOn this pageTemplatesWhen you run oclif generate, you're prompted whether you want to use either CommonJS or ESM for your CLI. CommonJS modules were the original way to package JavaScript and TypeScript packages for reuse in Node.js; ESM modules are now the official standard format. Both options produce the same CLI, with the same tsconfig file, bin scripts, sample commands, and so on.
Here's a brief rundown of everything that's included in your newly generated CLI.
Bin Scripts​
The generated CLI project contains 4 bin scripts that you can use for either production or development.

bin/run.js - Run the CLI in production (macOS and Linux)
bin/dev.js - Run the CLI in development (macOS and Linux)
bin/run.cmd - Run the CLI in production (Windows)
bin/dev.cmd - Run the CLI in development (Windows)

The bin entry in your package.json points to the bin/run.js file, which in turn tells npm to use that file when installing the CLI. If you create operating system-specific installers using oclif pack, then the appropriate run script is added to the final installer based on the target operating system.
We encourage you to use the dev scripts for your local development. Doing so causes oclif to auto-transpile your TypeScript at runtime so you don't have to worry about compiling your code before every command execution. The dev scripts also produce more verbose warnings and errors, which makes it easier to figure out what went wrong.
The dev.js script uses ts-node as the Node.js runtime. However, you can use any of the following if you prefer:

TypeScript Execute (tsx)
Bun
node - If you use node and ESM, make sure you're using a loader that allows it to use ESM modules, such as --loader ts-node/esm. See ESM for more information.

For all of these Node.js runtimes, you can point the hashbang (#!) in the dev.js and run.js files to a global installation of the runtime (such as ts-node) or to a locally installed one (node_modules/.bin/ts-node).
Configuration​
The generated CLI also comes with several configuration files that you can easily modify, or even remove, to suit your needs.

.eslintrc.json - Our recommended plugins and settings for eslint.
.eslintignore - Our recommended .eslintignore to go with our recommend eslint configuration.
.mocharc.json - Our recommended settings for mocha.
.prettierrc.json - Our recommended prettier settings - uses @oclif/prettier-config as the base.
tsconfig.json - Our recommended compiler options for TypeScript projects.
package.json - Our recommended scripts, dependencies, and oclif settings.

Example Commands​
The generated CLI project comes with two sample commands that you can use as a base to build your own.

hello - src/commands/hello/index.ts
hello world - src/commands/hello/world.ts

Example Tests​
Test files for each of the sample commands are generated under the tests folder.
These tests use @oclif/test and mocha. However, feel free to set up your tests with any testing utilities that better suit your needs.Edit this pageLast updated on Dec 20, 2024 by Mike Donnalley\n\nGetting StartedTemplatesOn this pageTemplatesWhen you run oclif generate, you're prompted whether you want to use either CommonJS or ESM for your CLI. CommonJS modules were the original way to package JavaScript and TypeScript packages for reuse in Node.js; ESM modules are now the official standard format. Both options produce the same CLI, with the same tsconfig file, bin scripts, sample commands, and so on.
Here's a brief rundown of everything that's included in your newly generated CLI.
Bin Scripts​
The generated CLI project contains 4 bin scripts that you can use for either production or development.

bin/run.js - Run the CLI in production (macOS and Linux)
bin/dev.js - Run the CLI in development (macOS and Linux)
bin/run.cmd - Run the CLI in production (Windows)
bin/dev.cmd - Run the CLI in development (Windows)

The bin entry in your package.json points to the bin/run.js file, which in turn tells npm to use that file when installing the CLI. If you create operating system-specific installers using oclif pack, then the appropriate run script is added to the final installer based on the target operating system.
We encourage you to use the dev scripts for your local development. Doing so causes oclif to auto-transpile your TypeScript at runtime so you don't have to worry about compiling your code before every command execution. The dev scripts also produce more verbose warnings and errors, which makes it easier to figure out what went wrong.
The dev.js script uses ts-node as the Node.js runtime. However, you can use any of the following if you prefer:

TypeScript Execute (tsx)
Bun
node - If you use node and ESM, make sure you're using a loader that allows it to use ESM modules, such as --loader ts-node/esm. See ESM for more information.

For all of these Node.js runtimes, you can point the hashbang (#!) in the dev.js and run.js files to a global installation of the runtime (such as ts-node) or to a locally installed one (node_modules/.bin/ts-node).
Configuration​
The generated CLI also comes with several configuration files that you can easily modify, or even remove, to suit your needs.

.eslintrc.json - Our recommended plugins and settings for eslint.
.eslintignore - Our recommended .eslintignore to go with our recommend eslint configuration.
.mocharc.json - Our recommended settings for mocha.
.prettierrc.json - Our recommended prettier settings - uses @oclif/prettier-config as the base.
tsconfig.json - Our recommended compiler options for TypeScript projects.
package.json - Our recommended scripts, dependencies, and oclif settings.

Example Commands​
The generated CLI project comes with two sample commands that you can use as a base to build your own.

hello - src/commands/hello/index.ts
hello world - src/commands/hello/world.ts

Example Tests​
Test files for each of the sample commands are generated under the tests folder.
These tests use @oclif/test and mocha. However, feel free to set up your tests with any testing utilities that better suit your needs.Edit this pageLast updated on Dec 20, 2024 by Mike DonnalleyPreviousGenerator CommandsNextGuidesBin ScriptsConfigurationExample CommandsExample Tests\n\n\n\n📄️ AliasesDefine aliases for commands, flags, and bins📄️ Custom Base ClassCreate an extendable Command class📄️ Configuring Your CLIAll about configuring oclif📄️ DebuggingHow to access debug logs📄️ Error HandlingCustomize error handling📄️ ESMUsing ESM in oclif📄️ Flag InheritanceHow to share flags📄️ Flexible TaxonomyUnlock new levels of user-friendliness📄️ Just-in-Time Plugin InstallationSupport for just-in-time plugin installation📄️ JSONNative support for `--json` flag📄️ Loggingoclif-generated logging and custom loggers📄️ NSIS Installer CustomizationCustom nsis installer script📄️ ReleaseHow to release your CLI📄️ Running Commands ProgrammaticallyIf you need to run a command from another, or programmatically run a command in another codebase, there are a couple options.📄️ Single Command CLIConfigure CLI to be a single command📄️ TestingHow to test your CLI📄️ ThemesMake help output pretty📄️ User ExperienceProvided user-experience utilities📄️ AliasesDefine aliases for commands, flags, and bins📄️ Custom Base ClassCreate an extendable Command class📄️ Configuring Your CLIAll about configuring oclif📄️ DebuggingHow to access debug logs📄️ Error HandlingCustomize error handling📄️ ESMUsing ESM in oclif📄️ Flag InheritanceHow to share flags📄️ Flexible TaxonomyUnlock new levels of user-friendliness📄️ Just-in-Time Plugin InstallationSupport for just-in-time plugin installation📄️ JSONNative support for `--json` flag📄️ Loggingoclif-generated logging and custom loggers📄️ NSIS Installer CustomizationCustom nsis installer script📄️ ReleaseHow to release your CLI📄️ Running Commands ProgrammaticallyIf you need to run a command from another, or programmatically run a command in another codebase, there are a couple options.📄️ Single Command CLIConfigure CLI to be a single command📄️ TestingHow to test your CLI📄️ ThemesMake help output pretty📄️ User ExperienceProvided user-experience utilities\n\nGuidesGuides📄️ AliasesDefine aliases for commands, flags, and bins📄️ Custom Base ClassCreate an extendable Command class📄️ Configuring Your CLIAll about configuring oclif📄️ DebuggingHow to access debug logs📄️ Error HandlingCustomize error handling📄️ ESMUsing ESM in oclif📄️ Flag InheritanceHow to share flags📄️ Flexible TaxonomyUnlock new levels of user-friendliness📄️ Just-in-Time Plugin InstallationSupport for just-in-time plugin installation📄️ JSONNative support for `--json` flag📄️ Loggingoclif-generated logging and custom loggers📄️ NSIS Installer CustomizationCustom nsis installer script📄️ ReleaseHow to release your CLI📄️ Running Commands ProgrammaticallyIf you need to run a command from another, or programmatically run a command in another codebase, there are a couple options.📄️ Single Command CLIConfigure CLI to be a single command📄️ TestingHow to test your CLI📄️ ThemesMake help output pretty📄️ User ExperienceProvided user-experience utilitiesPreviousTemplatesNextAliases\n\n\n\nArchitectureCommand ExecutionCommand ExecutionBelow is a diagram that outlines at a high level the process that occurs every time a user executes an oclif command.
Edit this pageLast updated on Dec 20, 2024 by Mike Donnalley\n\nArchitectureCommand ExecutionCommand ExecutionBelow is a diagram that outlines at a high level the process that occurs every time a user executes an oclif command.
Edit this pageLast updated on Dec 20, 2024 by Mike DonnalleyPreviousPerformanceNextPlugin Loading\n\n\n\nAlso SeeExamplesExamplesHere are some examples to get an idea of how to use oclif in various setups.

CommonJS plugin
ESM plugin
Using esbuild
Hook-only plugin
Edit this pageLast updated on Dec 20, 2024 by Mike Donnalley\n\nAlso SeeExamplesExamplesHere are some examples to get an idea of how to use oclif in various setups.

CommonJS plugin
ESM plugin
Using esbuild
Hook-only plugin
Edit this pageLast updated on Dec 20, 2024 by Mike DonnalleyPreviousPlugin LoadingNextExternal Links\n\n\n\nGetting StartedIntroductionOn this pageIntroductionoclif is a framework for building command-line interfaces (CLIs) using Node.js. You can use it like a simple flag parser, but it's capable of much more. It's designed to be extensible so that you can easily add plugins, such as the update warning plugin, or build your own for users to install at runtime.
The oclif generator creates a CLI project in TypeScript to get you started quickly. The generated CLI requires very few runtime dependencies and has minimal overhead.
Everything is customizable in oclif. Even the flag parser and help generation is optional and can be replaced. It's a platform to build upon that provides smart defaults without locking you in to any specific tools or behavior.
Requirements​
Only LTS Node versions are supported. If you want to ensure that users are on a specifc Node.js version, you can add the node package to your CLI.
To install the oclif CLI itself, run this command:
$ npm install --global oclif
Create an oclif Project from Scratch​
To create a new oclif project from scratch, run the oclif generate command.
$ oclif generate mynewcliGenerating mynewcli in /Users/me/oclif/mynewcli? Select a module type ESM? NPM package name mynewcli? Command bin name the CLI will export mynewcli<more prompts...>$ cd mynewcli$ ./bin/dev.js hello worldhello world! (./src/commands/hello/world.ts)
The command creates a new project based on our templates. To learn more about what's included in these templates, read the documentation here.
After oclif generate completes, run your CLI using the included bin scripts.


Use bin/dev.js to run your CLI in development mode:
$ ./bin/dev.js hello worldhello world! (./src/commands/hello/world.ts)


Use bin/run.js to run your CLI in production mode:
$ ./bin/run.js hello worldhello world! (./src/commands/hello/world.ts)


Initialize oclif in an Existing Project​
If you want to start using oclif inside an existing project, then use the oclif init command to add the necessary files, dependencies, and configuration.
$ oclif init? Command bin name the CLI will export (my-pkg): my-pkg? Select topic separator: spaces? Select a module type: CommonJS? Select a package manager: npmCreated CLI in my-pkg
oclif init adds the following:

bin scripts: bin/run.js, bin/run.cmd, bin/dev.js, and bin/dev.cmd. See bin scripts for more information.
oclif section to package.json with the bin, dirname, commands, and topicSeparator properties set. See Configuring Your CLI for more information.
@oclif/core to the dependencies property in your package.json (if it's not already there).
ts-node to the devDependencies property in your package.json (if it's not already there).

Next Steps​
Add Commands​
After you've generated an oclif project or initialized it in your existing project, start adding new commands. This example creates a new command with the TypeScript source file src/commands/foo/bar.ts that you can customize to do whatever you want:
$ oclif generate command foo:bar
See the documentation for flags and args which shows how to add flags and arguments to your command; the documentation for commands shows the other options you can set on your command.
Add Hooks​
You can also add hooks to your CLI that allow you to further customize the behavior of your CLI:
$ oclif generate hook my-hook --event init
Further customizations​

Configure Your CLI
Custom Help
Use a Base Command Class
Enhance the User Experience

Other Tutorials​
Our friend, @joshcanhelp, wrote a fantastic tutorial on his blog that we encourage you to read as well.Edit this pageLast updated on Dec 20, 2024 by Mike Donnalley\n\nGetting StartedIntroductionOn this pageIntroductionoclif is a framework for building command-line interfaces (CLIs) using Node.js. You can use it like a simple flag parser, but it's capable of much more. It's designed to be extensible so that you can easily add plugins, such as the update warning plugin, or build your own for users to install at runtime.
The oclif generator creates a CLI project in TypeScript to get you started quickly. The generated CLI requires very few runtime dependencies and has minimal overhead.
Everything is customizable in oclif. Even the flag parser and help generation is optional and can be replaced. It's a platform to build upon that provides smart defaults without locking you in to any specific tools or behavior.
Requirements​
Only LTS Node versions are supported. If you want to ensure that users are on a specifc Node.js version, you can add the node package to your CLI.
To install the oclif CLI itself, run this command:
$ npm install --global oclif
Create an oclif Project from Scratch​
To create a new oclif project from scratch, run the oclif generate command.
$ oclif generate mynewcliGenerating mynewcli in /Users/me/oclif/mynewcli? Select a module type ESM? NPM package name mynewcli? Command bin name the CLI will export mynewcli<more prompts...>$ cd mynewcli$ ./bin/dev.js hello worldhello world! (./src/commands/hello/world.ts)
The command creates a new project based on our templates. To learn more about what's included in these templates, read the documentation here.
After oclif generate completes, run your CLI using the included bin scripts.


Use bin/dev.js to run your CLI in development mode:
$ ./bin/dev.js hello worldhello world! (./src/commands/hello/world.ts)


Use bin/run.js to run your CLI in production mode:
$ ./bin/run.js hello worldhello world! (./src/commands/hello/world.ts)


Initialize oclif in an Existing Project​
If you want to start using oclif inside an existing project, then use the oclif init command to add the necessary files, dependencies, and configuration.
$ oclif init? Command bin name the CLI will export (my-pkg): my-pkg? Select topic separator: spaces? Select a module type: CommonJS? Select a package manager: npmCreated CLI in my-pkg
oclif init adds the following:

bin scripts: bin/run.js, bin/run.cmd, bin/dev.js, and bin/dev.cmd. See bin scripts for more information.
oclif section to package.json with the bin, dirname, commands, and topicSeparator properties set. See Configuring Your CLI for more information.
@oclif/core to the dependencies property in your package.json (if it's not already there).
ts-node to the devDependencies property in your package.json (if it's not already there).

Next Steps​
Add Commands​
After you've generated an oclif project or initialized it in your existing project, start adding new commands. This example creates a new command with the TypeScript source file src/commands/foo/bar.ts that you can customize to do whatever you want:
$ oclif generate command foo:bar
See the documentation for flags and args which shows how to add flags and arguments to your command; the documentation for commands shows the other options you can set on your command.
Add Hooks​
You can also add hooks to your CLI that allow you to further customize the behavior of your CLI:
$ oclif generate hook my-hook --event init
Further customizations​

Configure Your CLI
Custom Help
Use a Base Command Class
Enhance the User Experience

Other Tutorials​
Our friend, @joshcanhelp, wrote a fantastic tutorial on his blog that we encourage you to read as well.Edit this pageLast updated on Dec 20, 2024 by Mike DonnalleyNextFeaturesRequirementsCreate an oclif Project from ScratchInitialize oclif in an Existing ProjectNext StepsAdd CommandsAdd HooksFurther customizationsOther Tutorials\n\n\n\nGetting StartedIntroductionOn this pageIntroductionoclif is a framework for building command-line interfaces (CLIs) using Node.js. You can use it like a simple flag parser, but it's capable of much more. It's designed to be extensible so that you can easily add plugins, such as the update warning plugin, or build your own for users to install at runtime.
The oclif generator creates a CLI project in TypeScript to get you started quickly. The generated CLI requires very few runtime dependencies and has minimal overhead.
Everything is customizable in oclif. Even the flag parser and help generation is optional and can be replaced. It's a platform to build upon that provides smart defaults without locking you in to any specific tools or behavior.
Requirements​
Only LTS Node versions are supported. If you want to ensure that users are on a specifc Node.js version, you can add the node package to your CLI.
To install the oclif CLI itself, run this command:
$ npm install --global oclif
Create an oclif Project from Scratch​
To create a new oclif project from scratch, run the oclif generate command.
$ oclif generate mynewcliGenerating mynewcli in /Users/me/oclif/mynewcli? Select a module type ESM? NPM package name mynewcli? Command bin name the CLI will export mynewcli<more prompts...>$ cd mynewcli$ ./bin/dev.js hello worldhello world! (./src/commands/hello/world.ts)
The command creates a new project based on our templates. To learn more about what's included in these templates, read the documentation here.
After oclif generate completes, run your CLI using the included bin scripts.


Use bin/dev.js to run your CLI in development mode:
$ ./bin/dev.js hello worldhello world! (./src/commands/hello/world.ts)


Use bin/run.js to run your CLI in production mode:
$ ./bin/run.js hello worldhello world! (./src/commands/hello/world.ts)


Initialize oclif in an Existing Project​
If you want to start using oclif inside an existing project, then use the oclif init command to add the necessary files, dependencies, and configuration.
$ oclif init? Command bin name the CLI will export (my-pkg): my-pkg? Select topic separator: spaces? Select a module type: CommonJS? Select a package manager: npmCreated CLI in my-pkg
oclif init adds the following:

bin scripts: bin/run.js, bin/run.cmd, bin/dev.js, and bin/dev.cmd. See bin scripts for more information.
oclif section to package.json with the bin, dirname, commands, and topicSeparator properties set. See Configuring Your CLI for more information.
@oclif/core to the dependencies property in your package.json (if it's not already there).
ts-node to the devDependencies property in your package.json (if it's not already there).

Next Steps​
Add Commands​
After you've generated an oclif project or initialized it in your existing project, start adding new commands. This example creates a new command with the TypeScript source file src/commands/foo/bar.ts that you can customize to do whatever you want:
$ oclif generate command foo:bar
See the documentation for flags and args which shows how to add flags and arguments to your command; the documentation for commands shows the other options you can set on your command.
Add Hooks​
You can also add hooks to your CLI that allow you to further customize the behavior of your CLI:
$ oclif generate hook my-hook --event init
Further customizations​

Configure Your CLI
Custom Help
Use a Base Command Class
Enhance the User Experience

Other Tutorials​
Our friend, @joshcanhelp, wrote a fantastic tutorial on his blog that we encourage you to read as well.Edit this pageLast updated on Dec 20, 2024 by Mike Donnalley\n\nGetting StartedIntroductionOn this pageIntroductionoclif is a framework for building command-line interfaces (CLIs) using Node.js. You can use it like a simple flag parser, but it's capable of much more. It's designed to be extensible so that you can easily add plugins, such as the update warning plugin, or build your own for users to install at runtime.
The oclif generator creates a CLI project in TypeScript to get you started quickly. The generated CLI requires very few runtime dependencies and has minimal overhead.
Everything is customizable in oclif. Even the flag parser and help generation is optional and can be replaced. It's a platform to build upon that provides smart defaults without locking you in to any specific tools or behavior.
Requirements​
Only LTS Node versions are supported. If you want to ensure that users are on a specifc Node.js version, you can add the node package to your CLI.
To install the oclif CLI itself, run this command:
$ npm install --global oclif
Create an oclif Project from Scratch​
To create a new oclif project from scratch, run the oclif generate command.
$ oclif generate mynewcliGenerating mynewcli in /Users/me/oclif/mynewcli? Select a module type ESM? NPM package name mynewcli? Command bin name the CLI will export mynewcli<more prompts...>$ cd mynewcli$ ./bin/dev.js hello worldhello world! (./src/commands/hello/world.ts)
The command creates a new project based on our templates. To learn more about what's included in these templates, read the documentation here.
After oclif generate completes, run your CLI using the included bin scripts.


Use bin/dev.js to run your CLI in development mode:
$ ./bin/dev.js hello worldhello world! (./src/commands/hello/world.ts)


Use bin/run.js to run your CLI in production mode:
$ ./bin/run.js hello worldhello world! (./src/commands/hello/world.ts)


Initialize oclif in an Existing Project​
If you want to start using oclif inside an existing project, then use the oclif init command to add the necessary files, dependencies, and configuration.
$ oclif init? Command bin name the CLI will export (my-pkg): my-pkg? Select topic separator: spaces? Select a module type: CommonJS? Select a package manager: npmCreated CLI in my-pkg
oclif init adds the following:

bin scripts: bin/run.js, bin/run.cmd, bin/dev.js, and bin/dev.cmd. See bin scripts for more information.
oclif section to package.json with the bin, dirname, commands, and topicSeparator properties set. See Configuring Your CLI for more information.
@oclif/core to the dependencies property in your package.json (if it's not already there).
ts-node to the devDependencies property in your package.json (if it's not already there).

Next Steps​
Add Commands​
After you've generated an oclif project or initialized it in your existing project, start adding new commands. This example creates a new command with the TypeScript source file src/commands/foo/bar.ts that you can customize to do whatever you want:
$ oclif generate command foo:bar
See the documentation for flags and args which shows how to add flags and arguments to your command; the documentation for commands shows the other options you can set on your command.
Add Hooks​
You can also add hooks to your CLI that allow you to further customize the behavior of your CLI:
$ oclif generate hook my-hook --event init
Further customizations​

Configure Your CLI
Custom Help
Use a Base Command Class
Enhance the User Experience

Other Tutorials​
Our friend, @joshcanhelp, wrote a fantastic tutorial on his blog that we encourage you to read as well.Edit this pageLast updated on Dec 20, 2024 by Mike DonnalleyNextFeaturesRequirementsCreate an oclif Project from ScratchInitialize oclif in an Existing ProjectNext StepsAdd CommandsAdd HooksFurther customizationsOther Tutorials\n\n\n\nGetting StartedTemplatesOn this pageTemplatesWhen you run oclif generate, you're prompted whether you want to use either CommonJS or ESM for your CLI. CommonJS modules were the original way to package JavaScript and TypeScript packages for reuse in Node.js; ESM modules are now the official standard format. Both options produce the same CLI, with the same tsconfig file, bin scripts, sample commands, and so on.
Here's a brief rundown of everything that's included in your newly generated CLI.
Bin Scripts​
The generated CLI project contains 4 bin scripts that you can use for either production or development.

bin/run.js - Run the CLI in production (macOS and Linux)
bin/dev.js - Run the CLI in development (macOS and Linux)
bin/run.cmd - Run the CLI in production (Windows)
bin/dev.cmd - Run the CLI in development (Windows)

The bin entry in your package.json points to the bin/run.js file, which in turn tells npm to use that file when installing the CLI. If you create operating system-specific installers using oclif pack, then the appropriate run script is added to the final installer based on the target operating system.
We encourage you to use the dev scripts for your local development. Doing so causes oclif to auto-transpile your TypeScript at runtime so you don't have to worry about compiling your code before every command execution. The dev scripts also produce more verbose warnings and errors, which makes it easier to figure out what went wrong.
The dev.js script uses ts-node as the Node.js runtime. However, you can use any of the following if you prefer:

TypeScript Execute (tsx)
Bun
node - If you use node and ESM, make sure you're using a loader that allows it to use ESM modules, such as --loader ts-node/esm. See ESM for more information.

For all of these Node.js runtimes, you can point the hashbang (#!) in the dev.js and run.js files to a global installation of the runtime (such as ts-node) or to a locally installed one (node_modules/.bin/ts-node).
Configuration​
The generated CLI also comes with several configuration files that you can easily modify, or even remove, to suit your needs.

.eslintrc.json - Our recommended plugins and settings for eslint.
.eslintignore - Our recommended .eslintignore to go with our recommend eslint configuration.
.mocharc.json - Our recommended settings for mocha.
.prettierrc.json - Our recommended prettier settings - uses @oclif/prettier-config as the base.
tsconfig.json - Our recommended compiler options for TypeScript projects.
package.json - Our recommended scripts, dependencies, and oclif settings.

Example Commands​
The generated CLI project comes with two sample commands that you can use as a base to build your own.

hello - src/commands/hello/index.ts
hello world - src/commands/hello/world.ts

Example Tests​
Test files for each of the sample commands are generated under the tests folder.
These tests use @oclif/test and mocha. However, feel free to set up your tests with any testing utilities that better suit your needs.Edit this pageLast updated on Dec 20, 2024 by Mike Donnalley\n\nGetting StartedTemplatesOn this pageTemplatesWhen you run oclif generate, you're prompted whether you want to use either CommonJS or ESM for your CLI. CommonJS modules were the original way to package JavaScript and TypeScript packages for reuse in Node.js; ESM modules are now the official standard format. Both options produce the same CLI, with the same tsconfig file, bin scripts, sample commands, and so on.
Here's a brief rundown of everything that's included in your newly generated CLI.
Bin Scripts​
The generated CLI project contains 4 bin scripts that you can use for either production or development.

bin/run.js - Run the CLI in production (macOS and Linux)
bin/dev.js - Run the CLI in development (macOS and Linux)
bin/run.cmd - Run the CLI in production (Windows)
bin/dev.cmd - Run the CLI in development (Windows)

The bin entry in your package.json points to the bin/run.js file, which in turn tells npm to use that file when installing the CLI. If you create operating system-specific installers using oclif pack, then the appropriate run script is added to the final installer based on the target operating system.
We encourage you to use the dev scripts for your local development. Doing so causes oclif to auto-transpile your TypeScript at runtime so you don't have to worry about compiling your code before every command execution. The dev scripts also produce more verbose warnings and errors, which makes it easier to figure out what went wrong.
The dev.js script uses ts-node as the Node.js runtime. However, you can use any of the following if you prefer:

TypeScript Execute (tsx)
Bun
node - If you use node and ESM, make sure you're using a loader that allows it to use ESM modules, such as --loader ts-node/esm. See ESM for more information.

For all of these Node.js runtimes, you can point the hashbang (#!) in the dev.js and run.js files to a global installation of the runtime (such as ts-node) or to a locally installed one (node_modules/.bin/ts-node).
Configuration​
The generated CLI also comes with several configuration files that you can easily modify, or even remove, to suit your needs.

.eslintrc.json - Our recommended plugins and settings for eslint.
.eslintignore - Our recommended .eslintignore to go with our recommend eslint configuration.
.mocharc.json - Our recommended settings for mocha.
.prettierrc.json - Our recommended prettier settings - uses @oclif/prettier-config as the base.
tsconfig.json - Our recommended compiler options for TypeScript projects.
package.json - Our recommended scripts, dependencies, and oclif settings.

Example Commands​
The generated CLI project comes with two sample commands that you can use as a base to build your own.

hello - src/commands/hello/index.ts
hello world - src/commands/hello/world.ts

Example Tests​
Test files for each of the sample commands are generated under the tests folder.
These tests use @oclif/test and mocha. However, feel free to set up your tests with any testing utilities that better suit your needs.Edit this pageLast updated on Dec 20, 2024 by Mike DonnalleyPreviousGenerator CommandsNextGuidesBin ScriptsConfigurationExample CommandsExample Tests\n\n\n\nGetting StartedIntroductionOn this pageIntroductionoclif is a framework for building command-line interfaces (CLIs) using Node.js. You can use it like a simple flag parser, but it's capable of much more. It's designed to be extensible so that you can easily add plugins, such as the update warning plugin, or build your own for users to install at runtime.
The oclif generator creates a CLI project in TypeScript to get you started quickly. The generated CLI requires very few runtime dependencies and has minimal overhead.
Everything is customizable in oclif. Even the flag parser and help generation is optional and can be replaced. It's a platform to build upon that provides smart defaults without locking you in to any specific tools or behavior.
Requirements​
Only LTS Node versions are supported. If you want to ensure that users are on a specifc Node.js version, you can add the node package to your CLI.
To install the oclif CLI itself, run this command:
$ npm install --global oclif
Create an oclif Project from Scratch​
To create a new oclif project from scratch, run the oclif generate command.
$ oclif generate mynewcliGenerating mynewcli in /Users/me/oclif/mynewcli? Select a module type ESM? NPM package name mynewcli? Command bin name the CLI will export mynewcli<more prompts...>$ cd mynewcli$ ./bin/dev.js hello worldhello world! (./src/commands/hello/world.ts)
The command creates a new project based on our templates. To learn more about what's included in these templates, read the documentation here.
After oclif generate completes, run your CLI using the included bin scripts.


Use bin/dev.js to run your CLI in development mode:
$ ./bin/dev.js hello worldhello world! (./src/commands/hello/world.ts)


Use bin/run.js to run your CLI in production mode:
$ ./bin/run.js hello worldhello world! (./src/commands/hello/world.ts)


Initialize oclif in an Existing Project​
If you want to start using oclif inside an existing project, then use the oclif init command to add the necessary files, dependencies, and configuration.
$ oclif init? Command bin name the CLI will export (my-pkg): my-pkg? Select topic separator: spaces? Select a module type: CommonJS? Select a package manager: npmCreated CLI in my-pkg
oclif init adds the following:

bin scripts: bin/run.js, bin/run.cmd, bin/dev.js, and bin/dev.cmd. See bin scripts for more information.
oclif section to package.json with the bin, dirname, commands, and topicSeparator properties set. See Configuring Your CLI for more information.
@oclif/core to the dependencies property in your package.json (if it's not already there).
ts-node to the devDependencies property in your package.json (if it's not already there).

Next Steps​
Add Commands​
After you've generated an oclif project or initialized it in your existing project, start adding new commands. This example creates a new command with the TypeScript source file src/commands/foo/bar.ts that you can customize to do whatever you want:
$ oclif generate command foo:bar
See the documentation for flags and args which shows how to add flags and arguments to your command; the documentation for commands shows the other options you can set on your command.
Add Hooks​
You can also add hooks to your CLI that allow you to further customize the behavior of your CLI:
$ oclif generate hook my-hook --event init
Further customizations​

Configure Your CLI
Custom Help
Use a Base Command Class
Enhance the User Experience

Other Tutorials​
Our friend, @joshcanhelp, wrote a fantastic tutorial on his blog that we encourage you to read as well.Edit this pageLast updated on Dec 20, 2024 by Mike Donnalley\n\nGetting StartedIntroductionOn this pageIntroductionoclif is a framework for building command-line interfaces (CLIs) using Node.js. You can use it like a simple flag parser, but it's capable of much more. It's designed to be extensible so that you can easily add plugins, such as the update warning plugin, or build your own for users to install at runtime.
The oclif generator creates a CLI project in TypeScript to get you started quickly. The generated CLI requires very few runtime dependencies and has minimal overhead.
Everything is customizable in oclif. Even the flag parser and help generation is optional and can be replaced. It's a platform to build upon that provides smart defaults without locking you in to any specific tools or behavior.
Requirements​
Only LTS Node versions are supported. If you want to ensure that users are on a specifc Node.js version, you can add the node package to your CLI.
To install the oclif CLI itself, run this command:
$ npm install --global oclif
Create an oclif Project from Scratch​
To create a new oclif project from scratch, run the oclif generate command.
$ oclif generate mynewcliGenerating mynewcli in /Users/me/oclif/mynewcli? Select a module type ESM? NPM package name mynewcli? Command bin name the CLI will export mynewcli<more prompts...>$ cd mynewcli$ ./bin/dev.js hello worldhello world! (./src/commands/hello/world.ts)
The command creates a new project based on our templates. To learn more about what's included in these templates, read the documentation here.
After oclif generate completes, run your CLI using the included bin scripts.


Use bin/dev.js to run your CLI in development mode:
$ ./bin/dev.js hello worldhello world! (./src/commands/hello/world.ts)


Use bin/run.js to run your CLI in production mode:
$ ./bin/run.js hello worldhello world! (./src/commands/hello/world.ts)


Initialize oclif in an Existing Project​
If you want to start using oclif inside an existing project, then use the oclif init command to add the necessary files, dependencies, and configuration.
$ oclif init? Command bin name the CLI will export (my-pkg): my-pkg? Select topic separator: spaces? Select a module type: CommonJS? Select a package manager: npmCreated CLI in my-pkg
oclif init adds the following:

bin scripts: bin/run.js, bin/run.cmd, bin/dev.js, and bin/dev.cmd. See bin scripts for more information.
oclif section to package.json with the bin, dirname, commands, and topicSeparator properties set. See Configuring Your CLI for more information.
@oclif/core to the dependencies property in your package.json (if it's not already there).
ts-node to the devDependencies property in your package.json (if it's not already there).

Next Steps​
Add Commands​
After you've generated an oclif project or initialized it in your existing project, start adding new commands. This example creates a new command with the TypeScript source file src/commands/foo/bar.ts that you can customize to do whatever you want:
$ oclif generate command foo:bar
See the documentation for flags and args which shows how to add flags and arguments to your command; the documentation for commands shows the other options you can set on your command.
Add Hooks​
You can also add hooks to your CLI that allow you to further customize the behavior of your CLI:
$ oclif generate hook my-hook --event init
Further customizations​

Configure Your CLI
Custom Help
Use a Base Command Class
Enhance the User Experience

Other Tutorials​
Our friend, @joshcanhelp, wrote a fantastic tutorial on his blog that we encourage you to read as well.Edit this pageLast updated on Dec 20, 2024 by Mike DonnalleyNextFeaturesRequirementsCreate an oclif Project from ScratchInitialize oclif in an Existing ProjectNext StepsAdd CommandsAdd HooksFurther customizationsOther Tutorials\n\n\n\nGuidesConfiguring Your CLIOn this pageConfiguring Your CLIYou can configure the behavior of oclif inside your CLI or plugin's package.json or using an rc file.
If you use the package.json, all of the configuration options should be placed under the oclif section. For example:
{  "name": "my-cli",  "version": "1.2.3",  "dependencies": {    "@oclif/core": "^3"  },  "oclif": {    "bin": "mycli",    "dirname": "mycli",    "commands": "./dist/commands",    "topicSeparator": " "  }}
If you'd like to use an rc file, then you do not need to put the configuration under oclif. For instance:
//.oclifrc.jsmodule.exports = {  bin: "mycli",  dirname: "mycli",  commands: "./dist/commands",  topicSeparator: " "}
The following rc files are supported:
.oclifrc.oclifrc.json.oclifrc.js.oclifrc.mjs.oclifrc.cjsoclif.config.jsoclif.config.mjsoclif.config.cjs
Here's a list of all the options that you can configure.
PropertyDescriptionadditionalHelpFlagsArray of flags that should trigger help output in addition to --helpadditionalVersionFlagsArray of flags that should trigger version output in addition to --versionaliasesAliases for the plugin. This is used to support legacy plugins that have been renamedbinCLI bin name (e.g. sf, heroku, git, etc...)binAliasesAn array of strings that will all execute the CLI's bin. See Aliases for moredirnameDirectory name to use when determining CLI's config, cache, and data directories.commandsWhere oclif can find command classes. See Command Discovery Strategies for moredescriptionDescription of your plugin or CLI to show in helpdevPluginsList of plugins that will only be loaded in development. See Plugins for moreexitCodesConfigured exit codes. See Exit Codes section belowflexibleTaxonomySet to true to enable flexible taxonomyhelpClassLocation of compiled custom help classhelpOptionsSettings for configuring behavior of help output. See Help Options section belowhooksRegister your plugin or CLI's hooks. See hooks for morejitPluginsRegister plugins that can be installed just in time. See Just-in-Time Plugin Installation for moremacosSettings for building macos installer. See Releasing for morensisCustomizationA path to a .nsis file that's used to customize the installer for Windows. See nsis-custom for morepluginsList of plugins that should be loaded. See Plugins for morestateSet the state of your CLI or plugin to be shown in help (e.g. beta will show This CLI is in beta)themePath to theme file to include with your CLI. See Themes for moretopicSeparatorThe separator to use between topics - only colons (":") and spaces (" ") are supportedtopicsDefine your CLI's topics. See Topics for morewindowsSettings for building windows installer. See Releasing for more
Exit Codes​
You can configure the desired exit codes for the following errors:

default - default exit code for any error.
failedFlagParsing - exit code when oclif fails to parse a flag's value.
failedFlagValidation - exit code when a flag fails it's own validation.
invalidArgsSpec - exit code when a command defines an invalid args configuration.
nonExistentFlag - exit code when user provides a non-existent flag.
requiredArgs - exit code when user fails to provide a required arg.
unexpectedArgs - exit code when user provides unexpected args to a command.

Help Options​
You can configure the behavior of the help output with the following:

docopts - Use docopts as the usage. Defaults to true.
flagSortOrder - Order in which to sort flags in help output. Can be alphabetical (default) or none (flags will appear in the order they were defined).
hideAliasesFromRoot - If true, hide command aliases from the root help output. Defaults to false.
hideCommandSummaryInDescription - By default, the command summary is show at the top of the help and as the first line in the command description. Repeating the summary in the command description improves readability especially for long command help output. If there is no command.summary, the first line of the description is treated as the summary. Some CLIs, especially with very simple commands, may not want the duplication.
maxWidth - Maximum column width of the help output.
sections - Only show the help for the specified sections. Defaults to all sections.
sendToStderr - By default, the help output is sent to stdout. If this is true, it will be sent to stderr.
showFlagNameInTitle - By default, titles show flag values as <value>. Some CLI developers may prefer titles to show the flag name as the value. i.e. --myflag=myflag instead of --myflag=<value>. An individual flag can set this using flag.helpValue=flag.name.
showFlagOptionsInTitle - By default, option values on flags are shown in the flag's description. This is because long options list ruin the formatting of help. If a CLI knows all commands will not do this, it can be turned off at a help level using this property. An individual flag can set this using flag.helpValue=options.join('|').
stripAnsi - Strip ansi characters from help out to remove all formatting.
usageHeader - Override the header for the USAGE section.

If you want to further customize help, you can implement a Custom Help Class.Edit this pageLast updated on Dec 20, 2024 by Mike Donnalley\n\nGuidesConfiguring Your CLIOn this pageConfiguring Your CLIYou can configure the behavior of oclif inside your CLI or plugin's package.json or using an rc file.
If you use the package.json, all of the configuration options should be placed under the oclif section. For example:
{  "name": "my-cli",  "version": "1.2.3",  "dependencies": {    "@oclif/core": "^3"  },  "oclif": {    "bin": "mycli",    "dirname": "mycli",    "commands": "./dist/commands",    "topicSeparator": " "  }}
If you'd like to use an rc file, then you do not need to put the configuration under oclif. For instance:
//.oclifrc.jsmodule.exports = {  bin: "mycli",  dirname: "mycli",  commands: "./dist/commands",  topicSeparator: " "}
The following rc files are supported:
.oclifrc.oclifrc.json.oclifrc.js.oclifrc.mjs.oclifrc.cjsoclif.config.jsoclif.config.mjsoclif.config.cjs
Here's a list of all the options that you can configure.
PropertyDescriptionadditionalHelpFlagsArray of flags that should trigger help output in addition to --helpadditionalVersionFlagsArray of flags that should trigger version output in addition to --versionaliasesAliases for the plugin. This is used to support legacy plugins that have been renamedbinCLI bin name (e.g. sf, heroku, git, etc...)binAliasesAn array of strings that will all execute the CLI's bin. See Aliases for moredirnameDirectory name to use when determining CLI's config, cache, and data directories.commandsWhere oclif can find command classes. See Command Discovery Strategies for moredescriptionDescription of your plugin or CLI to show in helpdevPluginsList of plugins that will only be loaded in development. See Plugins for moreexitCodesConfigured exit codes. See Exit Codes section belowflexibleTaxonomySet to true to enable flexible taxonomyhelpClassLocation of compiled custom help classhelpOptionsSettings for configuring behavior of help output. See Help Options section belowhooksRegister your plugin or CLI's hooks. See hooks for morejitPluginsRegister plugins that can be installed just in time. See Just-in-Time Plugin Installation for moremacosSettings for building macos installer. See Releasing for morensisCustomizationA path to a .nsis file that's used to customize the installer for Windows. See nsis-custom for morepluginsList of plugins that should be loaded. See Plugins for morestateSet the state of your CLI or plugin to be shown in help (e.g. beta will show This CLI is in beta)themePath to theme file to include with your CLI. See Themes for moretopicSeparatorThe separator to use between topics - only colons (":") and spaces (" ") are supportedtopicsDefine your CLI's topics. See Topics for morewindowsSettings for building windows installer. See Releasing for more
Exit Codes​
You can configure the desired exit codes for the following errors:

default - default exit code for any error.
failedFlagParsing - exit code when oclif fails to parse a flag's value.
failedFlagValidation - exit code when a flag fails it's own validation.
invalidArgsSpec - exit code when a command defines an invalid args configuration.
nonExistentFlag - exit code when user provides a non-existent flag.
requiredArgs - exit code when user fails to provide a required arg.
unexpectedArgs - exit code when user provides unexpected args to a command.

Help Options​
You can configure the behavior of the help output with the following:

docopts - Use docopts as the usage. Defaults to true.
flagSortOrder - Order in which to sort flags in help output. Can be alphabetical (default) or none (flags will appear in the order they were defined).
hideAliasesFromRoot - If true, hide command aliases from the root help output. Defaults to false.
hideCommandSummaryInDescription - By default, the command summary is show at the top of the help and as the first line in the command description. Repeating the summary in the command description improves readability especially for long command help output. If there is no command.summary, the first line of the description is treated as the summary. Some CLIs, especially with very simple commands, may not want the duplication.
maxWidth - Maximum column width of the help output.
sections - Only show the help for the specified sections. Defaults to all sections.
sendToStderr - By default, the help output is sent to stdout. If this is true, it will be sent to stderr.
showFlagNameInTitle - By default, titles show flag values as <value>. Some CLI developers may prefer titles to show the flag name as the value. i.e. --myflag=myflag instead of --myflag=<value>. An individual flag can set this using flag.helpValue=flag.name.
showFlagOptionsInTitle - By default, option values on flags are shown in the flag's description. This is because long options list ruin the formatting of help. If a CLI knows all commands will not do this, it can be turned off at a help level using this property. An individual flag can set this using flag.helpValue=options.join('|').
stripAnsi - Strip ansi characters from help out to remove all formatting.
usageHeader - Override the header for the USAGE section.

If you want to further customize help, you can implement a Custom Help Class.Edit this pageLast updated on Dec 20, 2024 by Mike DonnalleyPreviousCustom Base ClassNextDebuggingExit CodesHelp Options\n\n\n\nGetting StartedIntroductionOn this pageIntroductionoclif is a framework for building command-line interfaces (CLIs) using Node.js. You can use it like a simple flag parser, but it's capable of much more. It's designed to be extensible so that you can easily add plugins, such as the update warning plugin, or build your own for users to install at runtime.
The oclif generator creates a CLI project in TypeScript to get you started quickly. The generated CLI requires very few runtime dependencies and has minimal overhead.
Everything is customizable in oclif. Even the flag parser and help generation is optional and can be replaced. It's a platform to build upon that provides smart defaults without locking you in to any specific tools or behavior.
Requirements​
Only LTS Node versions are supported. If you want to ensure that users are on a specifc Node.js version, you can add the node package to your CLI.
To install the oclif CLI itself, run this command:
$ npm install --global oclif
Create an oclif Project from Scratch​
To create a new oclif project from scratch, run the oclif generate command.
$ oclif generate mynewcliGenerating mynewcli in /Users/me/oclif/mynewcli? Select a module type ESM? NPM package name mynewcli? Command bin name the CLI will export mynewcli<more prompts...>$ cd mynewcli$ ./bin/dev.js hello worldhello world! (./src/commands/hello/world.ts)
The command creates a new project based on our templates. To learn more about what's included in these templates, read the documentation here.
After oclif generate completes, run your CLI using the included bin scripts.


Use bin/dev.js to run your CLI in development mode:
$ ./bin/dev.js hello worldhello world! (./src/commands/hello/world.ts)


Use bin/run.js to run your CLI in production mode:
$ ./bin/run.js hello worldhello world! (./src/commands/hello/world.ts)


Initialize oclif in an Existing Project​
If you want to start using oclif inside an existing project, then use the oclif init command to add the necessary files, dependencies, and configuration.
$ oclif init? Command bin name the CLI will export (my-pkg): my-pkg? Select topic separator: spaces? Select a module type: CommonJS? Select a package manager: npmCreated CLI in my-pkg
oclif init adds the following:

bin scripts: bin/run.js, bin/run.cmd, bin/dev.js, and bin/dev.cmd. See bin scripts for more information.
oclif section to package.json with the bin, dirname, commands, and topicSeparator properties set. See Configuring Your CLI for more information.
@oclif/core to the dependencies property in your package.json (if it's not already there).
ts-node to the devDependencies property in your package.json (if it's not already there).

Next Steps​
Add Commands​
After you've generated an oclif project or initialized it in your existing project, start adding new commands. This example creates a new command with the TypeScript source file src/commands/foo/bar.ts that you can customize to do whatever you want:
$ oclif generate command foo:bar
See the documentation for flags and args which shows how to add flags and arguments to your command; the documentation for commands shows the other options you can set on your command.
Add Hooks​
You can also add hooks to your CLI that allow you to further customize the behavior of your CLI:
$ oclif generate hook my-hook --event init
Further customizations​

Configure Your CLI
Custom Help
Use a Base Command Class
Enhance the User Experience

Other Tutorials​
Our friend, @joshcanhelp, wrote a fantastic tutorial on his blog that we encourage you to read as well.Edit this pageLast updated on Dec 20, 2024 by Mike Donnalley\n\nGetting StartedIntroductionOn this pageIntroductionoclif is a framework for building command-line interfaces (CLIs) using Node.js. You can use it like a simple flag parser, but it's capable of much more. It's designed to be extensible so that you can easily add plugins, such as the update warning plugin, or build your own for users to install at runtime.
The oclif generator creates a CLI project in TypeScript to get you started quickly. The generated CLI requires very few runtime dependencies and has minimal overhead.
Everything is customizable in oclif. Even the flag parser and help generation is optional and can be replaced. It's a platform to build upon that provides smart defaults without locking you in to any specific tools or behavior.
Requirements​
Only LTS Node versions are supported. If you want to ensure that users are on a specifc Node.js version, you can add the node package to your CLI.
To install the oclif CLI itself, run this command:
$ npm install --global oclif
Create an oclif Project from Scratch​
To create a new oclif project from scratch, run the oclif generate command.
$ oclif generate mynewcliGenerating mynewcli in /Users/me/oclif/mynewcli? Select a module type ESM? NPM package name mynewcli? Command bin name the CLI will export mynewcli<more prompts...>$ cd mynewcli$ ./bin/dev.js hello worldhello world! (./src/commands/hello/world.ts)
The command creates a new project based on our templates. To learn more about what's included in these templates, read the documentation here.
After oclif generate completes, run your CLI using the included bin scripts.


Use bin/dev.js to run your CLI in development mode:
$ ./bin/dev.js hello worldhello world! (./src/commands/hello/world.ts)


Use bin/run.js to run your CLI in production mode:
$ ./bin/run.js hello worldhello world! (./src/commands/hello/world.ts)


Initialize oclif in an Existing Project​
If you want to start using oclif inside an existing project, then use the oclif init command to add the necessary files, dependencies, and configuration.
$ oclif init? Command bin name the CLI will export (my-pkg): my-pkg? Select topic separator: spaces? Select a module type: CommonJS? Select a package manager: npmCreated CLI in my-pkg
oclif init adds the following:

bin scripts: bin/run.js, bin/run.cmd, bin/dev.js, and bin/dev.cmd. See bin scripts for more information.
oclif section to package.json with the bin, dirname, commands, and topicSeparator properties set. See Configuring Your CLI for more information.
@oclif/core to the dependencies property in your package.json (if it's not already there).
ts-node to the devDependencies property in your package.json (if it's not already there).

Next Steps​
Add Commands​
After you've generated an oclif project or initialized it in your existing project, start adding new commands. This example creates a new command with the TypeScript source file src/commands/foo/bar.ts that you can customize to do whatever you want:
$ oclif generate command foo:bar
See the documentation for flags and args which shows how to add flags and arguments to your command; the documentation for commands shows the other options you can set on your command.
Add Hooks​
You can also add hooks to your CLI that allow you to further customize the behavior of your CLI:
$ oclif generate hook my-hook --event init
Further customizations​

Configure Your CLI
Custom Help
Use a Base Command Class
Enhance the User Experience

Other Tutorials​
Our friend, @joshcanhelp, wrote a fantastic tutorial on his blog that we encourage you to read as well.Edit this pageLast updated on Dec 20, 2024 by Mike DonnalleyNextFeaturesRequirementsCreate an oclif Project from ScratchInitialize oclif in an Existing ProjectNext StepsAdd CommandsAdd HooksFurther customizationsOther Tutorials\n\n\n\nGetting StartedIntroductionOn this pageIntroductionoclif is a framework for building command-line interfaces (CLIs) using Node.js. You can use it like a simple flag parser, but it's capable of much more. It's designed to be extensible so that you can easily add plugins, such as the update warning plugin, or build your own for users to install at runtime.
The oclif generator creates a CLI project in TypeScript to get you started quickly. The generated CLI requires very few runtime dependencies and has minimal overhead.
Everything is customizable in oclif. Even the flag parser and help generation is optional and can be replaced. It's a platform to build upon that provides smart defaults without locking you in to any specific tools or behavior.
Requirements​
Only LTS Node versions are supported. If you want to ensure that users are on a specifc Node.js version, you can add the node package to your CLI.
To install the oclif CLI itself, run this command:
$ npm install --global oclif
Create an oclif Project from Scratch​
To create a new oclif project from scratch, run the oclif generate command.
$ oclif generate mynewcliGenerating mynewcli in /Users/me/oclif/mynewcli? Select a module type ESM? NPM package name mynewcli? Command bin name the CLI will export mynewcli<more prompts...>$ cd mynewcli$ ./bin/dev.js hello worldhello world! (./src/commands/hello/world.ts)
The command creates a new project based on our templates. To learn more about what's included in these templates, read the documentation here.
After oclif generate completes, run your CLI using the included bin scripts.


Use bin/dev.js to run your CLI in development mode:
$ ./bin/dev.js hello worldhello world! (./src/commands/hello/world.ts)


Use bin/run.js to run your CLI in production mode:
$ ./bin/run.js hello worldhello world! (./src/commands/hello/world.ts)


Initialize oclif in an Existing Project​
If you want to start using oclif inside an existing project, then use the oclif init command to add the necessary files, dependencies, and configuration.
$ oclif init? Command bin name the CLI will export (my-pkg): my-pkg? Select topic separator: spaces? Select a module type: CommonJS? Select a package manager: npmCreated CLI in my-pkg
oclif init adds the following:

bin scripts: bin/run.js, bin/run.cmd, bin/dev.js, and bin/dev.cmd. See bin scripts for more information.
oclif section to package.json with the bin, dirname, commands, and topicSeparator properties set. See Configuring Your CLI for more information.
@oclif/core to the dependencies property in your package.json (if it's not already there).
ts-node to the devDependencies property in your package.json (if it's not already there).

Next Steps​
Add Commands​
After you've generated an oclif project or initialized it in your existing project, start adding new commands. This example creates a new command with the TypeScript source file src/commands/foo/bar.ts that you can customize to do whatever you want:
$ oclif generate command foo:bar
See the documentation for flags and args which shows how to add flags and arguments to your command; the documentation for commands shows the other options you can set on your command.
Add Hooks​
You can also add hooks to your CLI that allow you to further customize the behavior of your CLI:
$ oclif generate hook my-hook --event init
Further customizations​

Configure Your CLI
Custom Help
Use a Base Command Class
Enhance the User Experience

Other Tutorials​
Our friend, @joshcanhelp, wrote a fantastic tutorial on his blog that we encourage you to read as well.Edit this pageLast updated on Dec 20, 2024 by Mike Donnalley\n\nGetting StartedIntroductionOn this pageIntroductionoclif is a framework for building command-line interfaces (CLIs) using Node.js. You can use it like a simple flag parser, but it's capable of much more. It's designed to be extensible so that you can easily add plugins, such as the update warning plugin, or build your own for users to install at runtime.
The oclif generator creates a CLI project in TypeScript to get you started quickly. The generated CLI requires very few runtime dependencies and has minimal overhead.
Everything is customizable in oclif. Even the flag parser and help generation is optional and can be replaced. It's a platform to build upon that provides smart defaults without locking you in to any specific tools or behavior.
Requirements​
Only LTS Node versions are supported. If you want to ensure that users are on a specifc Node.js version, you can add the node package to your CLI.
To install the oclif CLI itself, run this command:
$ npm install --global oclif
Create an oclif Project from Scratch​
To create a new oclif project from scratch, run the oclif generate command.
$ oclif generate mynewcliGenerating mynewcli in /Users/me/oclif/mynewcli? Select a module type ESM? NPM package name mynewcli? Command bin name the CLI will export mynewcli<more prompts...>$ cd mynewcli$ ./bin/dev.js hello worldhello world! (./src/commands/hello/world.ts)
The command creates a new project based on our templates. To learn more about what's included in these templates, read the documentation here.
After oclif generate completes, run your CLI using the included bin scripts.


Use bin/dev.js to run your CLI in development mode:
$ ./bin/dev.js hello worldhello world! (./src/commands/hello/world.ts)


Use bin/run.js to run your CLI in production mode:
$ ./bin/run.js hello worldhello world! (./src/commands/hello/world.ts)


Initialize oclif in an Existing Project​
If you want to start using oclif inside an existing project, then use the oclif init command to add the necessary files, dependencies, and configuration.
$ oclif init? Command bin name the CLI will export (my-pkg): my-pkg? Select topic separator: spaces? Select a module type: CommonJS? Select a package manager: npmCreated CLI in my-pkg
oclif init adds the following:

bin scripts: bin/run.js, bin/run.cmd, bin/dev.js, and bin/dev.cmd. See bin scripts for more information.
oclif section to package.json with the bin, dirname, commands, and topicSeparator properties set. See Configuring Your CLI for more information.
@oclif/core to the dependencies property in your package.json (if it's not already there).
ts-node to the devDependencies property in your package.json (if it's not already there).

Next Steps​
Add Commands​
After you've generated an oclif project or initialized it in your existing project, start adding new commands. This example creates a new command with the TypeScript source file src/commands/foo/bar.ts that you can customize to do whatever you want:
$ oclif generate command foo:bar
See the documentation for flags and args which shows how to add flags and arguments to your command; the documentation for commands shows the other options you can set on your command.
Add Hooks​
You can also add hooks to your CLI that allow you to further customize the behavior of your CLI:
$ oclif generate hook my-hook --event init
Further customizations​

Configure Your CLI
Custom Help
Use a Base Command Class
Enhance the User Experience

Other Tutorials​
Our friend, @joshcanhelp, wrote a fantastic tutorial on his blog that we encourage you to read as well.Edit this pageLast updated on Dec 20, 2024 by Mike DonnalleyNextFeaturesRequirementsCreate an oclif Project from ScratchInitialize oclif in an Existing ProjectNext StepsAdd CommandsAdd HooksFurther customizationsOther Tutorials\n\n\n\nAPI ReferenceCommandsOn this pageCommandsA basic command looks like the following in TypeScript:
import {Command} from '@oclif/core'export class MyCommand extends Command {  static description = 'description of this example command'  async run(): Promise<void> {    console.log('running my command')  }}
The only part that is required is the run function. Accept user input with arguments and flags.
In JavaScript:
const {Command} = require('@oclif/core')class MyCommand extends Command {  async run() {    console.log('running my command')  }}MyCommand.description = 'description of this example command'module.exports = MyCommand
Note that the following examples will be in TypeScript. As JavaScript does not yet have static class properties, you will have to add them to the class after it is declared like we did with the description above.
Avoiding Timeouts​
In order to avoid command executions running indefinitely, oclif will terminate the node process 10 seconds after Command.run resolves. This means that all command logic inside the run method should either run synchronously or should return a Promise. This will allow the entire command to run before the 10 second timeout starts.
In other words, if you execute a promise in Command.run without a awaiting it, then the command will likely timeout before it's completed.
Other Command Options​
See the base class to get an idea of what methods can be called on a command.
import {Command, Flags} from '@oclif/core'export class MyCommand extends Command {  static summary = 'A brief overview of your command.'  static description = `An in-depth description of the command.It can be multiline.`  // hide the command from help  static hidden = false  // custom usage string for help  // this overrides the default usage  static usage = 'mycommand --myflag'  // examples to add to help  // <%= config.bin %> resolves to the executable name  // <%= command.id %> resolves to the command name  static examples = [    // Examples can be simple strings    '<%= config.bin %> <%= command.id %> --help',    // Or objects that provide a description of the example command    {      description: 'Force the command to execute',      command: '<%= config.bin %> <%= command.id %> --force',    }  ]  // this makes the parser not fail when it receives invalid arguments  // defaults to true  // set it to false if you need to accept a variable number of arguments  static strict = false  // define aliases that can execute this command.  static aliases = ['alternate:name:for:this:command']  // Set to true if you want to add the --json flag to your command.  // oclif will automatically suppress logs (if you use this.log, this.warn, or this.error) and  // display the JSON returned by the command's run method.  static enableJsonFlag = true  async run() {    // show a warning    this.warn('uh oh!')    // exit with an error message    this.error('uh oh!!!')    // exit with status code    this.exit(1)  }}
Command Methods​

Command Methods

this.log(message: string)
this.warn(message: string | Error)
this.error(message: string | Error, options?: {code?: string, exit?: number, ref?: string; suggestions?: string[];})
this.exit(code: number = 0)
this.logToStderr(message: string)
this.jsonEnabled()
this.toSuccessJson(result: unknown)
this.toErrorJson(result: unknown)



The following assumes you are in the run() method of an oclif command.
this.log(message: string)​
Output message to stdout (non-blocking). console.log() works fine too, but that is a blocking call and won't be automatically suppressed when the --json flag is present. This uses util.format() which behaves the same as console.log().
this.log('hello, world!')
this.warn(message: string | Error)​
Display an error or message as a warning
this.warn('uh oh!')this.warn(new Error('uh oh!'))
this.error(message: string | Error, options?: {code?: string, exit?: number, ref?: string; suggestions?: string[];})​
Display error and exit. Also add a code to error object or exit status.
this.error('uh oh!', {exit: 2})this.error(new Error('uh oh!'))
The options object has the following options:

exit — exit code to use
code — a unique error code for the type of error
suggestions —  an array of suggestions for a user to try next that may be useful or provide additional context
ref — a url to documentation related to this error or fixing it

The message, code, suggestions, ref properties will be displayed when an error is shown. Reusable Error classes can be created that display the optional outputs above by implementing the PrettyPrintableError interface from the Errors namespace from @oclif/core and this.error will handle them appropriately.
These errors are friendly and won't show a traceback unless debugging is enabled with DEBUG=*.
import {CLIError} from '@oclif/errors'throw new CLIError('my friendly error')
Any error caught by the command of this CLIError type will be shown without traceback.
this.exit(code: number = 0)​
Exit process. Defaults to status 0.
this.exit()this.exit(1)
this.logToStderr(message: string)​
Log a message to the terminal's stderr.
this.jsonEnabled()​
Returns to true if the --json flag is present and enableJsonFlag is set to true
this.toSuccessJson(result: unknown)​
Modify the command's success JSON output before it's displayed to the user.
this.toErrorJson(result: unknown)​
Modify the command's error JSON output before it's displayed to the user.Edit this pageLast updated on Dec 20, 2024 by Mike Donnalley\n\nAPI ReferenceCommandsOn this pageCommandsA basic command looks like the following in TypeScript:
import {Command} from '@oclif/core'export class MyCommand extends Command {  static description = 'description of this example command'  async run(): Promise<void> {    console.log('running my command')  }}
The only part that is required is the run function. Accept user input with arguments and flags.
In JavaScript:
const {Command} = require('@oclif/core')class MyCommand extends Command {  async run() {    console.log('running my command')  }}MyCommand.description = 'description of this example command'module.exports = MyCommand
Note that the following examples will be in TypeScript. As JavaScript does not yet have static class properties, you will have to add them to the class after it is declared like we did with the description above.
Avoiding Timeouts​
In order to avoid command executions running indefinitely, oclif will terminate the node process 10 seconds after Command.run resolves. This means that all command logic inside the run method should either run synchronously or should return a Promise. This will allow the entire command to run before the 10 second timeout starts.
In other words, if you execute a promise in Command.run without a awaiting it, then the command will likely timeout before it's completed.
Other Command Options​
See the base class to get an idea of what methods can be called on a command.
import {Command, Flags} from '@oclif/core'export class MyCommand extends Command {  static summary = 'A brief overview of your command.'  static description = `An in-depth description of the command.It can be multiline.`  // hide the command from help  static hidden = false  // custom usage string for help  // this overrides the default usage  static usage = 'mycommand --myflag'  // examples to add to help  // <%= config.bin %> resolves to the executable name  // <%= command.id %> resolves to the command name  static examples = [    // Examples can be simple strings    '<%= config.bin %> <%= command.id %> --help',    // Or objects that provide a description of the example command    {      description: 'Force the command to execute',      command: '<%= config.bin %> <%= command.id %> --force',    }  ]  // this makes the parser not fail when it receives invalid arguments  // defaults to true  // set it to false if you need to accept a variable number of arguments  static strict = false  // define aliases that can execute this command.  static aliases = ['alternate:name:for:this:command']  // Set to true if you want to add the --json flag to your command.  // oclif will automatically suppress logs (if you use this.log, this.warn, or this.error) and  // display the JSON returned by the command's run method.  static enableJsonFlag = true  async run() {    // show a warning    this.warn('uh oh!')    // exit with an error message    this.error('uh oh!!!')    // exit with status code    this.exit(1)  }}
Command Methods​

Command Methods

this.log(message: string)
this.warn(message: string | Error)
this.error(message: string | Error, options?: {code?: string, exit?: number, ref?: string; suggestions?: string[];})
this.exit(code: number = 0)
this.logToStderr(message: string)
this.jsonEnabled()
this.toSuccessJson(result: unknown)
this.toErrorJson(result: unknown)



The following assumes you are in the run() method of an oclif command.
this.log(message: string)​
Output message to stdout (non-blocking). console.log() works fine too, but that is a blocking call and won't be automatically suppressed when the --json flag is present. This uses util.format() which behaves the same as console.log().
this.log('hello, world!')
this.warn(message: string | Error)​
Display an error or message as a warning
this.warn('uh oh!')this.warn(new Error('uh oh!'))
this.error(message: string | Error, options?: {code?: string, exit?: number, ref?: string; suggestions?: string[];})​
Display error and exit. Also add a code to error object or exit status.
this.error('uh oh!', {exit: 2})this.error(new Error('uh oh!'))
The options object has the following options:

exit — exit code to use
code — a unique error code for the type of error
suggestions —  an array of suggestions for a user to try next that may be useful or provide additional context
ref — a url to documentation related to this error or fixing it

The message, code, suggestions, ref properties will be displayed when an error is shown. Reusable Error classes can be created that display the optional outputs above by implementing the PrettyPrintableError interface from the Errors namespace from @oclif/core and this.error will handle them appropriately.
These errors are friendly and won't show a traceback unless debugging is enabled with DEBUG=*.
import {CLIError} from '@oclif/errors'throw new CLIError('my friendly error')
Any error caught by the command of this CLIError type will be shown without traceback.
this.exit(code: number = 0)​
Exit process. Defaults to status 0.
this.exit()this.exit(1)
this.logToStderr(message: string)​
Log a message to the terminal's stderr.
this.jsonEnabled()​
Returns to true if the --json flag is present and enableJsonFlag is set to true
this.toSuccessJson(result: unknown)​
Modify the command's success JSON output before it's displayed to the user.
this.toErrorJson(result: unknown)​
Modify the command's error JSON output before it's displayed to the user.Edit this pageLast updated on Dec 20, 2024 by Mike DonnalleyPreviousAPI ReferenceNextCommand ArgumentsAvoiding TimeoutsOther Command OptionsCommand Methodsthis.log(message: string)this.warn(message: string | Error)this.error(message: string | Error, options?: {code?: string, exit?: number, ref?: string; suggestions?: string[];})this.exit(code: number = 0)this.logToStderr(message: string)this.jsonEnabled()this.toSuccessJson(result: unknown)this.toErrorJson(result: unknown)\n\n\n\nAPI ReferenceCommand FlagsOn this pageCommand FlagsFlag options are non-positional arguments passed to the command. Flags can either be option flags which take an argument, or boolean flags which do not. An option flag must have an argument.
For example, if this command was run like this:
$ mycli --force --file=./myfile
It would be declared like this:
import {Command, Flags} from '@oclif/core'export class MyCLI extends Command {  static flags = {    // can pass either --force or -f    force: Flags.boolean({char: 'f'}),    file: Flags.string(),  }  async run() {    const {flags} = await this.parse(MyCLI)    if (flags.force) console.log('--force is set')    if (flags.file) console.log(`--file is: ${flags.file}`)  }}
oclif supports a wide range of alternative flag inputs.
Here are the options flags can have:
static flags = {  name: Flags.string({    // The following can be set on both boolean and option flag (e.g. string, integer, url, custom, etc) types.    char: 'n',                                   // shorter flag version    summary: 'brief summary',                    // help summary for flag    helpLabel: '--my-flags',                     // The flag label to show in help. Defaults to "[-<char>] --<name>" where -<char> is only displayed if the char is defined.    helpGroup: 'THE BEST FLAGS',                 // Put flag into THE BEST FLAGS group in help    description: 'in-depth overview',            // help description for flag    hidden: false,                               // hide from help    multiple: false,                             // allow setting this flag multiple times    env: 'MY_NAME',                              // default to value of environment variable    options: ['a', 'b'],                         // only allow the value to be from a discrete set    parse: async input => 'output',              // instead of the user input, return a different value    default: 'world',                            // default value if flag not passed (can be an async function that returns a string or undefined)    defaultHelp: 'a dynamic value'               // dynamic default value to show in help output (e.g. current working directory). Can be an async function that returns a string or undefined    required: false,                             // make flag required    aliases: ['username', 'u'],                  // aliases for the flag - can be short char or long flags    charAliases: ['u', 'n'],                     // single character aliases for the flag    deprecated: false,                           // mark the flag as deprecated.    deprecateAliases: false,                     // emit deprecation warning anytime a flag alias is provided    noCacheDefault: false,                       // if true, the value returned by defaultHelp will not be cached in the oclif.manifest.json.    dependsOn: ['extra-flag'],                   // this flag requires another flag    exclusive: ['extra-flag'],                   // this flag cannot be specified alongside this other flag    exactlyOne: ['extra-flag', 'another-flag'],  // exactly one of these flags must be provided    relationships: [                             // define complex relationships between flags      // Make this flag dependent on all of these flags      {type: 'all', flags: ['flag-one', 'flag-two']}      // Make this flag dependent on at least one of these flags      {type: 'some', flags: ['flag-three', 'flag-four']}      // Make this flag exclusive of all these flags      {type: 'none', flags: ['flag-five', 'flag-six']}      // Make this flag dependent on all of these flags      {type: 'all', flags: [        'flag-one',        'flag-two',        // Include flag-seven but only when flag-eight is equal to FooBar        {name: 'flag-seven', when: async (flags) => flags['flag-eight'] === 'FooBar'}      ]}    ],    // The following properties cannot be set on boolean flags    helpValue: '<name>',                         // The flag value to show in help. Defaults to "<value>",    multipleNonGreedy: false,                    // Parse one value per flag to allow `-m val1 -m val2` but disallow `-m val1 val2`. Only respected if multiple is set to true    delimiter: ','                               // Delimiter to separate the values for a multiple value flag. Only respected if multiple is set to true. Default behavior is to separate on spaces.    allowStdin: false,                           // Allow input value to be read from stdin if the provided value is `-`. Can also be set to `only` to allow flag to always read from stdin even if no value is provided.  }),  // flag with no value (-f, --force)  force: Flags.boolean({    // Boolean flags take all the same properties described in the previous example    // in addition to:    allowNo: true // Support reversible boolean flag with `--no-` prefix (e.g. `--no-force`). This is disabled by default.  }),}
Custom Flags​
For larger CLIs, it can be useful to declare a custom flag that can be shared amongst multiple commands. Here is an example of a custom flag:
// src/flags.tsimport {Flags} from '@oclif/core'class Team {  public name: string;  // etc...}function getTeam(): Promise<Team> {  // imagine this reads a configuration file or something to find the team  return new Team()}export const team = Flags.custom<Team>({  char: 't',  description: 'team to use',  default: async () => getTeam(),})// src/commands/mycommand.tsimport {team} from '../flags'import {Command} from '@oclif/core'export class MyCLI extends Command {  static flags = {    team: team({      required: true,    }),  }  async run() {    const {flags} = await this.parse(MyCLI)    if (flags.team) console.log(`--team is ${flags.team.name}`)  }}
In the Salesforce CLI we make heavy use of custom flags. For example,

A salesforceId flag that ensures the provided string is a valid Salesforce Id.
A duration flag that converts a provided integer into a Duration instance that we use for working with time based values.

These and more are located here if you want to see more examples. You can also read the API docs.
Alternative Flag Inputs​
Here are some other ways the user can use input flags. This is assuming the command has flags like -f, --file=file and -v, --verbose (string and boolean flag):
$ mycli --verbose$ mycli -v$ mycli --file=foo$ mycli --file foo$ mycli -f foo$ mycli -f=foo$ mycli -ffoo$ mycli -vffoo
The last one seems a little odd at first glance, but it's relatively standard in unix and makes commands like tar -xvzfmytarball.tar.gz possible.
See our blog post CLI Flags Explained for a deeper dive into CLI flags.Edit this pageLast updated on Dec 20, 2024 by Mike Donnalley\n\nAPI ReferenceCommand FlagsOn this pageCommand FlagsFlag options are non-positional arguments passed to the command. Flags can either be option flags which take an argument, or boolean flags which do not. An option flag must have an argument.
For example, if this command was run like this:
$ mycli --force --file=./myfile
It would be declared like this:
import {Command, Flags} from '@oclif/core'export class MyCLI extends Command {  static flags = {    // can pass either --force or -f    force: Flags.boolean({char: 'f'}),    file: Flags.string(),  }  async run() {    const {flags} = await this.parse(MyCLI)    if (flags.force) console.log('--force is set')    if (flags.file) console.log(`--file is: ${flags.file}`)  }}
oclif supports a wide range of alternative flag inputs.
Here are the options flags can have:
static flags = {  name: Flags.string({    // The following can be set on both boolean and option flag (e.g. string, integer, url, custom, etc) types.    char: 'n',                                   // shorter flag version    summary: 'brief summary',                    // help summary for flag    helpLabel: '--my-flags',                     // The flag label to show in help. Defaults to "[-<char>] --<name>" where -<char> is only displayed if the char is defined.    helpGroup: 'THE BEST FLAGS',                 // Put flag into THE BEST FLAGS group in help    description: 'in-depth overview',            // help description for flag    hidden: false,                               // hide from help    multiple: false,                             // allow setting this flag multiple times    env: 'MY_NAME',                              // default to value of environment variable    options: ['a', 'b'],                         // only allow the value to be from a discrete set    parse: async input => 'output',              // instead of the user input, return a different value    default: 'world',                            // default value if flag not passed (can be an async function that returns a string or undefined)    defaultHelp: 'a dynamic value'               // dynamic default value to show in help output (e.g. current working directory). Can be an async function that returns a string or undefined    required: false,                             // make flag required    aliases: ['username', 'u'],                  // aliases for the flag - can be short char or long flags    charAliases: ['u', 'n'],                     // single character aliases for the flag    deprecated: false,                           // mark the flag as deprecated.    deprecateAliases: false,                     // emit deprecation warning anytime a flag alias is provided    noCacheDefault: false,                       // if true, the value returned by defaultHelp will not be cached in the oclif.manifest.json.    dependsOn: ['extra-flag'],                   // this flag requires another flag    exclusive: ['extra-flag'],                   // this flag cannot be specified alongside this other flag    exactlyOne: ['extra-flag', 'another-flag'],  // exactly one of these flags must be provided    relationships: [                             // define complex relationships between flags      // Make this flag dependent on all of these flags      {type: 'all', flags: ['flag-one', 'flag-two']}      // Make this flag dependent on at least one of these flags      {type: 'some', flags: ['flag-three', 'flag-four']}      // Make this flag exclusive of all these flags      {type: 'none', flags: ['flag-five', 'flag-six']}      // Make this flag dependent on all of these flags      {type: 'all', flags: [        'flag-one',        'flag-two',        // Include flag-seven but only when flag-eight is equal to FooBar        {name: 'flag-seven', when: async (flags) => flags['flag-eight'] === 'FooBar'}      ]}    ],    // The following properties cannot be set on boolean flags    helpValue: '<name>',                         // The flag value to show in help. Defaults to "<value>",    multipleNonGreedy: false,                    // Parse one value per flag to allow `-m val1 -m val2` but disallow `-m val1 val2`. Only respected if multiple is set to true    delimiter: ','                               // Delimiter to separate the values for a multiple value flag. Only respected if multiple is set to true. Default behavior is to separate on spaces.    allowStdin: false,                           // Allow input value to be read from stdin if the provided value is `-`. Can also be set to `only` to allow flag to always read from stdin even if no value is provided.  }),  // flag with no value (-f, --force)  force: Flags.boolean({    // Boolean flags take all the same properties described in the previous example    // in addition to:    allowNo: true // Support reversible boolean flag with `--no-` prefix (e.g. `--no-force`). This is disabled by default.  }),}
Custom Flags​
For larger CLIs, it can be useful to declare a custom flag that can be shared amongst multiple commands. Here is an example of a custom flag:
// src/flags.tsimport {Flags} from '@oclif/core'class Team {  public name: string;  // etc...}function getTeam(): Promise<Team> {  // imagine this reads a configuration file or something to find the team  return new Team()}export const team = Flags.custom<Team>({  char: 't',  description: 'team to use',  default: async () => getTeam(),})// src/commands/mycommand.tsimport {team} from '../flags'import {Command} from '@oclif/core'export class MyCLI extends Command {  static flags = {    team: team({      required: true,    }),  }  async run() {    const {flags} = await this.parse(MyCLI)    if (flags.team) console.log(`--team is ${flags.team.name}`)  }}
In the Salesforce CLI we make heavy use of custom flags. For example,

A salesforceId flag that ensures the provided string is a valid Salesforce Id.
A duration flag that converts a provided integer into a Duration instance that we use for working with time based values.

These and more are located here if you want to see more examples. You can also read the API docs.
Alternative Flag Inputs​
Here are some other ways the user can use input flags. This is assuming the command has flags like -f, --file=file and -v, --verbose (string and boolean flag):
$ mycli --verbose$ mycli -v$ mycli --file=foo$ mycli --file foo$ mycli -f foo$ mycli -f=foo$ mycli -ffoo$ mycli -vffoo
The last one seems a little odd at first glance, but it's relatively standard in unix and makes commands like tar -xvzfmytarball.tar.gz possible.
See our blog post CLI Flags Explained for a deeper dive into CLI flags.Edit this pageLast updated on Dec 20, 2024 by Mike DonnalleyPreviousCommand ArgumentsNextConfigCustom FlagsAlternative Flag Inputs\n\n\n\nAPI ReferenceCommand ArgumentsCommand ArgumentsArguments are positional arguments passed to the command. For example, if this command was run with mycli arg1 arg2 it would be declared like this:
import {Args, Command} from '@oclif/core'export class MyCLI extends Command {  static args = {    firstArg: Args.string(),    secondArg: Args.string(),  }  async run() {    // can get args as an object    const {args} = await this.parse(MyCLI)    this.log(`running my command with args: ${args.firstArg}, ${args.secondArg}`)    // can also get the args as an array    const {argv} = await this.parse(MyCLI)    this.log(`running my command with args: ${argv[0]}, ${argv[1]}`)  }}
Here are the options arguments can have:
static args = {  firstArg: Args.string(    {      name: 'file',                     // name of arg to show in help and reference with args[name]      required: false,                  // make the arg required with `required: true`      description: 'output file',       // help description      hidden: true,                     // hide this arg from help      parse: async input => 'output',   // instead of the user input, return a different value      default: 'world',                 // default value if no arg input. Can also be an async function.      defaultHelp: 'a dynamic value'    // dynamic default value to show in help output (e.g. current working directory). Can be an async function that returns a string or undefined      options: ['a', 'b'],              // only allow input to be from a discrete set      ignoreStdin: false,               // set to true to ignore any value provided by stdin      noCacheDefault: false             // if true, the value returned by defaultHelp will not be cached in the oclif.manifest.json.    }  ),}
Here are the types of args that Args exports:

string
integer
boolean
url
file
directory
custom

For variable length arguments, disable argument validation with static strict = false on the command.
import {Args, Command} from '@oclif/core'export class MyCLI extends Command {  static args = {    things: Args.string(),  }  static strict = false  async run() {    // If you're using strict=false you should use argv to access the provided args.    const {argv} = await this.parse(MyCLI)    this.log(`running my command with args: ${argv[0]}, ${argv[1]}`)  }}
Arguments can also be piped via stdin. This is particularly useful when creating scripts with your CLI commands. For example:
$ echo arg1 | myclirunning my command with args: arg1
This can behavior can be disabled on an argument by setting the ignoreStdin property to true on the argument's definition.Edit this pageLast updated on Dec 20, 2024 by Mike Donnalley\n\nAPI ReferenceCommand ArgumentsCommand ArgumentsArguments are positional arguments passed to the command. For example, if this command was run with mycli arg1 arg2 it would be declared like this:
import {Args, Command} from '@oclif/core'export class MyCLI extends Command {  static args = {    firstArg: Args.string(),    secondArg: Args.string(),  }  async run() {    // can get args as an object    const {args} = await this.parse(MyCLI)    this.log(`running my command with args: ${args.firstArg}, ${args.secondArg}`)    // can also get the args as an array    const {argv} = await this.parse(MyCLI)    this.log(`running my command with args: ${argv[0]}, ${argv[1]}`)  }}
Here are the options arguments can have:
static args = {  firstArg: Args.string(    {      name: 'file',                     // name of arg to show in help and reference with args[name]      required: false,                  // make the arg required with `required: true`      description: 'output file',       // help description      hidden: true,                     // hide this arg from help      parse: async input => 'output',   // instead of the user input, return a different value      default: 'world',                 // default value if no arg input. Can also be an async function.      defaultHelp: 'a dynamic value'    // dynamic default value to show in help output (e.g. current working directory). Can be an async function that returns a string or undefined      options: ['a', 'b'],              // only allow input to be from a discrete set      ignoreStdin: false,               // set to true to ignore any value provided by stdin      noCacheDefault: false             // if true, the value returned by defaultHelp will not be cached in the oclif.manifest.json.    }  ),}
Here are the types of args that Args exports:

string
integer
boolean
url
file
directory
custom

For variable length arguments, disable argument validation with static strict = false on the command.
import {Args, Command} from '@oclif/core'export class MyCLI extends Command {  static args = {    things: Args.string(),  }  static strict = false  async run() {    // If you're using strict=false you should use argv to access the provided args.    const {argv} = await this.parse(MyCLI)    this.log(`running my command with args: ${argv[0]}, ${argv[1]}`)  }}
Arguments can also be piped via stdin. This is particularly useful when creating scripts with your CLI commands. For example:
$ echo arg1 | myclirunning my command with args: arg1
This can behavior can be disabled on an argument by setting the ignoreStdin property to true on the argument's definition.Edit this pageLast updated on Dec 20, 2024 by Mike DonnalleyPreviousCommandsNextCommand Flags\n\n\n\nGetting StartedIntroductionOn this pageIntroductionoclif is a framework for building command-line interfaces (CLIs) using Node.js. You can use it like a simple flag parser, but it's capable of much more. It's designed to be extensible so that you can easily add plugins, such as the update warning plugin, or build your own for users to install at runtime.
The oclif generator creates a CLI project in TypeScript to get you started quickly. The generated CLI requires very few runtime dependencies and has minimal overhead.
Everything is customizable in oclif. Even the flag parser and help generation is optional and can be replaced. It's a platform to build upon that provides smart defaults without locking you in to any specific tools or behavior.
Requirements​
Only LTS Node versions are supported. If you want to ensure that users are on a specifc Node.js version, you can add the node package to your CLI.
To install the oclif CLI itself, run this command:
$ npm install --global oclif
Create an oclif Project from Scratch​
To create a new oclif project from scratch, run the oclif generate command.
$ oclif generate mynewcliGenerating mynewcli in /Users/me/oclif/mynewcli? Select a module type ESM? NPM package name mynewcli? Command bin name the CLI will export mynewcli<more prompts...>$ cd mynewcli$ ./bin/dev.js hello worldhello world! (./src/commands/hello/world.ts)
The command creates a new project based on our templates. To learn more about what's included in these templates, read the documentation here.
After oclif generate completes, run your CLI using the included bin scripts.


Use bin/dev.js to run your CLI in development mode:
$ ./bin/dev.js hello worldhello world! (./src/commands/hello/world.ts)


Use bin/run.js to run your CLI in production mode:
$ ./bin/run.js hello worldhello world! (./src/commands/hello/world.ts)


Initialize oclif in an Existing Project​
If you want to start using oclif inside an existing project, then use the oclif init command to add the necessary files, dependencies, and configuration.
$ oclif init? Command bin name the CLI will export (my-pkg): my-pkg? Select topic separator: spaces? Select a module type: CommonJS? Select a package manager: npmCreated CLI in my-pkg
oclif init adds the following:

bin scripts: bin/run.js, bin/run.cmd, bin/dev.js, and bin/dev.cmd. See bin scripts for more information.
oclif section to package.json with the bin, dirname, commands, and topicSeparator properties set. See Configuring Your CLI for more information.
@oclif/core to the dependencies property in your package.json (if it's not already there).
ts-node to the devDependencies property in your package.json (if it's not already there).

Next Steps​
Add Commands​
After you've generated an oclif project or initialized it in your existing project, start adding new commands. This example creates a new command with the TypeScript source file src/commands/foo/bar.ts that you can customize to do whatever you want:
$ oclif generate command foo:bar
See the documentation for flags and args which shows how to add flags and arguments to your command; the documentation for commands shows the other options you can set on your command.
Add Hooks​
You can also add hooks to your CLI that allow you to further customize the behavior of your CLI:
$ oclif generate hook my-hook --event init
Further customizations​

Configure Your CLI
Custom Help
Use a Base Command Class
Enhance the User Experience

Other Tutorials​
Our friend, @joshcanhelp, wrote a fantastic tutorial on his blog that we encourage you to read as well.Edit this pageLast updated on Dec 20, 2024 by Mike Donnalley\n\nGetting StartedIntroductionOn this pageIntroductionoclif is a framework for building command-line interfaces (CLIs) using Node.js. You can use it like a simple flag parser, but it's capable of much more. It's designed to be extensible so that you can easily add plugins, such as the update warning plugin, or build your own for users to install at runtime.
The oclif generator creates a CLI project in TypeScript to get you started quickly. The generated CLI requires very few runtime dependencies and has minimal overhead.
Everything is customizable in oclif. Even the flag parser and help generation is optional and can be replaced. It's a platform to build upon that provides smart defaults without locking you in to any specific tools or behavior.
Requirements​
Only LTS Node versions are supported. If you want to ensure that users are on a specifc Node.js version, you can add the node package to your CLI.
To install the oclif CLI itself, run this command:
$ npm install --global oclif
Create an oclif Project from Scratch​
To create a new oclif project from scratch, run the oclif generate command.
$ oclif generate mynewcliGenerating mynewcli in /Users/me/oclif/mynewcli? Select a module type ESM? NPM package name mynewcli? Command bin name the CLI will export mynewcli<more prompts...>$ cd mynewcli$ ./bin/dev.js hello worldhello world! (./src/commands/hello/world.ts)
The command creates a new project based on our templates. To learn more about what's included in these templates, read the documentation here.
After oclif generate completes, run your CLI using the included bin scripts.


Use bin/dev.js to run your CLI in development mode:
$ ./bin/dev.js hello worldhello world! (./src/commands/hello/world.ts)


Use bin/run.js to run your CLI in production mode:
$ ./bin/run.js hello worldhello world! (./src/commands/hello/world.ts)


Initialize oclif in an Existing Project​
If you want to start using oclif inside an existing project, then use the oclif init command to add the necessary files, dependencies, and configuration.
$ oclif init? Command bin name the CLI will export (my-pkg): my-pkg? Select topic separator: spaces? Select a module type: CommonJS? Select a package manager: npmCreated CLI in my-pkg
oclif init adds the following:

bin scripts: bin/run.js, bin/run.cmd, bin/dev.js, and bin/dev.cmd. See bin scripts for more information.
oclif section to package.json with the bin, dirname, commands, and topicSeparator properties set. See Configuring Your CLI for more information.
@oclif/core to the dependencies property in your package.json (if it's not already there).
ts-node to the devDependencies property in your package.json (if it's not already there).

Next Steps​
Add Commands​
After you've generated an oclif project or initialized it in your existing project, start adding new commands. This example creates a new command with the TypeScript source file src/commands/foo/bar.ts that you can customize to do whatever you want:
$ oclif generate command foo:bar
See the documentation for flags and args which shows how to add flags and arguments to your command; the documentation for commands shows the other options you can set on your command.
Add Hooks​
You can also add hooks to your CLI that allow you to further customize the behavior of your CLI:
$ oclif generate hook my-hook --event init
Further customizations​

Configure Your CLI
Custom Help
Use a Base Command Class
Enhance the User Experience

Other Tutorials​
Our friend, @joshcanhelp, wrote a fantastic tutorial on his blog that we encourage you to read as well.Edit this pageLast updated on Dec 20, 2024 by Mike DonnalleyNextFeaturesRequirementsCreate an oclif Project from ScratchInitialize oclif in an Existing ProjectNext StepsAdd CommandsAdd HooksFurther customizationsOther Tutorials\n\n\n\nAPI ReferenceHooksOn this pageHooksoclif exposes lifecycle event hooks such as init and command_not_found. See below for a list of all the lifecycle events. In addition to these built-in events, you can create your own events and allow commands/plugins to watch for these custom events. It's a great way to allow multiple plugins to interact with each other.
Multiple hooks are run in parallel. This behavior may change in a future release.
A basic hook looks like the following in TypeScript:
import {Hook} from '@oclif/core'const hook: Hook.Init = async function (options) {  console.log(`example init hook running before ${options.id}`)}export default hook
The hook must also be declared with the event's name and hook's file path under oclif's settings in package.json:
"oclif": {  "commands": "./lib/commands",  "hooks": {    "init": "./lib/hooks/init/example"  }}
Multiple hooks of the same event type can be declared with an array.
"oclif": {  "commands": "./lib/commands",  "hooks": {    "init": [      "./lib/hooks/init/example",      "./lib/hooks/init/another_hook"    ]  }}
You can create hooks with oclif generate hook myhook --event=init.
Lifecycle Events​

init - runs when the CLI is initialized before a command is found to run
prerun - runs after init and after the command is found, but just before running the command itself
command_not_found - runs if a command is not found before the error is displayed
command_incomplete - runs if a command is not found but it is a partial of an existing command. Only works if flexible taxonomy is enabled. Useful for instances where you'd like to present a prompt with all the matching commands. See Salesforce CLI's implementation.
jit_plugin_not_installed - runs if a command from a JIT plugin is executed but the plugin isn't installed yet. See Salesforce CLI's implementation.
preparse - runs before flags and args are parsed and validated. Useful if you need to manipulate the input. See Salesforce CLI's implementation. This can only be implemented by the root CLI.
postrun - runs after the command only if the command finishes with no error
finally - runs after the command finishes, regardless of the command's exit status

Custom Events​
Custom events are just like lifecycle events, but you need to call this.config.runHook() to fire the event.
For example, you could define an analytics post function that you will run in your command after submitting analytics telemetry. First define:
src/hooks/analytics/post.ts
const hook = async function (options: {id: string}) {  // code to post options.id to analytics server}export default hook
package.json
  "oclif": {    "commands": "./lib/commands",    "hooks": {      "analytics": "./lib/hooks/analytics/post"    },  },
Then in any command you want to trigger the event:
export class extends Command {  async run() {    // emit analytics    await this.config.runHook('analytics', {id: 'my_command'})  }}
If you need to exit during a hook, use options.context.error() or options.context.exit(). Throwing an Error will not cause the CLI to exit - this is to prevent an issues such a single plugin's init hook causing a CLI to immediately fail on every command execution.Edit this pageLast updated on Dec 20, 2024 by Mike Donnalley\n\nAPI ReferenceHooksOn this pageHooksoclif exposes lifecycle event hooks such as init and command_not_found. See below for a list of all the lifecycle events. In addition to these built-in events, you can create your own events and allow commands/plugins to watch for these custom events. It's a great way to allow multiple plugins to interact with each other.
Multiple hooks are run in parallel. This behavior may change in a future release.
A basic hook looks like the following in TypeScript:
import {Hook} from '@oclif/core'const hook: Hook.Init = async function (options) {  console.log(`example init hook running before ${options.id}`)}export default hook
The hook must also be declared with the event's name and hook's file path under oclif's settings in package.json:
"oclif": {  "commands": "./lib/commands",  "hooks": {    "init": "./lib/hooks/init/example"  }}
Multiple hooks of the same event type can be declared with an array.
"oclif": {  "commands": "./lib/commands",  "hooks": {    "init": [      "./lib/hooks/init/example",      "./lib/hooks/init/another_hook"    ]  }}
You can create hooks with oclif generate hook myhook --event=init.
Lifecycle Events​

init - runs when the CLI is initialized before a command is found to run
prerun - runs after init and after the command is found, but just before running the command itself
command_not_found - runs if a command is not found before the error is displayed
command_incomplete - runs if a command is not found but it is a partial of an existing command. Only works if flexible taxonomy is enabled. Useful for instances where you'd like to present a prompt with all the matching commands. See Salesforce CLI's implementation.
jit_plugin_not_installed - runs if a command from a JIT plugin is executed but the plugin isn't installed yet. See Salesforce CLI's implementation.
preparse - runs before flags and args are parsed and validated. Useful if you need to manipulate the input. See Salesforce CLI's implementation. This can only be implemented by the root CLI.
postrun - runs after the command only if the command finishes with no error
finally - runs after the command finishes, regardless of the command's exit status

Custom Events​
Custom events are just like lifecycle events, but you need to call this.config.runHook() to fire the event.
For example, you could define an analytics post function that you will run in your command after submitting analytics telemetry. First define:
src/hooks/analytics/post.ts
const hook = async function (options: {id: string}) {  // code to post options.id to analytics server}export default hook
package.json
  "oclif": {    "commands": "./lib/commands",    "hooks": {      "analytics": "./lib/hooks/analytics/post"    },  },
Then in any command you want to trigger the event:
export class extends Command {  async run() {    // emit analytics    await this.config.runHook('analytics', {id: 'my_command'})  }}
If you need to exit during a hook, use options.context.error() or options.context.exit(). Throwing an Error will not cause the CLI to exit - this is to prevent an issues such a single plugin's init hook causing a CLI to immediately fail on every command execution.Edit this pageLast updated on Dec 20, 2024 by Mike DonnalleyPreviousTopic SeparatorsNextPluginsLifecycle EventsCustom Events\n\n\n\nGetting StartedIntroductionOn this pageIntroductionoclif is a framework for building command-line interfaces (CLIs) using Node.js. You can use it like a simple flag parser, but it's capable of much more. It's designed to be extensible so that you can easily add plugins, such as the update warning plugin, or build your own for users to install at runtime.
The oclif generator creates a CLI project in TypeScript to get you started quickly. The generated CLI requires very few runtime dependencies and has minimal overhead.
Everything is customizable in oclif. Even the flag parser and help generation is optional and can be replaced. It's a platform to build upon that provides smart defaults without locking you in to any specific tools or behavior.
Requirements​
Only LTS Node versions are supported. If you want to ensure that users are on a specifc Node.js version, you can add the node package to your CLI.
To install the oclif CLI itself, run this command:
$ npm install --global oclif
Create an oclif Project from Scratch​
To create a new oclif project from scratch, run the oclif generate command.
$ oclif generate mynewcliGenerating mynewcli in /Users/me/oclif/mynewcli? Select a module type ESM? NPM package name mynewcli? Command bin name the CLI will export mynewcli<more prompts...>$ cd mynewcli$ ./bin/dev.js hello worldhello world! (./src/commands/hello/world.ts)
The command creates a new project based on our templates. To learn more about what's included in these templates, read the documentation here.
After oclif generate completes, run your CLI using the included bin scripts.


Use bin/dev.js to run your CLI in development mode:
$ ./bin/dev.js hello worldhello world! (./src/commands/hello/world.ts)


Use bin/run.js to run your CLI in production mode:
$ ./bin/run.js hello worldhello world! (./src/commands/hello/world.ts)


Initialize oclif in an Existing Project​
If you want to start using oclif inside an existing project, then use the oclif init command to add the necessary files, dependencies, and configuration.
$ oclif init? Command bin name the CLI will export (my-pkg): my-pkg? Select topic separator: spaces? Select a module type: CommonJS? Select a package manager: npmCreated CLI in my-pkg
oclif init adds the following:

bin scripts: bin/run.js, bin/run.cmd, bin/dev.js, and bin/dev.cmd. See bin scripts for more information.
oclif section to package.json with the bin, dirname, commands, and topicSeparator properties set. See Configuring Your CLI for more information.
@oclif/core to the dependencies property in your package.json (if it's not already there).
ts-node to the devDependencies property in your package.json (if it's not already there).

Next Steps​
Add Commands​
After you've generated an oclif project or initialized it in your existing project, start adding new commands. This example creates a new command with the TypeScript source file src/commands/foo/bar.ts that you can customize to do whatever you want:
$ oclif generate command foo:bar
See the documentation for flags and args which shows how to add flags and arguments to your command; the documentation for commands shows the other options you can set on your command.
Add Hooks​
You can also add hooks to your CLI that allow you to further customize the behavior of your CLI:
$ oclif generate hook my-hook --event init
Further customizations​

Configure Your CLI
Custom Help
Use a Base Command Class
Enhance the User Experience

Other Tutorials​
Our friend, @joshcanhelp, wrote a fantastic tutorial on his blog that we encourage you to read as well.Edit this pageLast updated on Dec 20, 2024 by Mike Donnalley\n\nGetting StartedIntroductionOn this pageIntroductionoclif is a framework for building command-line interfaces (CLIs) using Node.js. You can use it like a simple flag parser, but it's capable of much more. It's designed to be extensible so that you can easily add plugins, such as the update warning plugin, or build your own for users to install at runtime.
The oclif generator creates a CLI project in TypeScript to get you started quickly. The generated CLI requires very few runtime dependencies and has minimal overhead.
Everything is customizable in oclif. Even the flag parser and help generation is optional and can be replaced. It's a platform to build upon that provides smart defaults without locking you in to any specific tools or behavior.
Requirements​
Only LTS Node versions are supported. If you want to ensure that users are on a specifc Node.js version, you can add the node package to your CLI.
To install the oclif CLI itself, run this command:
$ npm install --global oclif
Create an oclif Project from Scratch​
To create a new oclif project from scratch, run the oclif generate command.
$ oclif generate mynewcliGenerating mynewcli in /Users/me/oclif/mynewcli? Select a module type ESM? NPM package name mynewcli? Command bin name the CLI will export mynewcli<more prompts...>$ cd mynewcli$ ./bin/dev.js hello worldhello world! (./src/commands/hello/world.ts)
The command creates a new project based on our templates. To learn more about what's included in these templates, read the documentation here.
After oclif generate completes, run your CLI using the included bin scripts.


Use bin/dev.js to run your CLI in development mode:
$ ./bin/dev.js hello worldhello world! (./src/commands/hello/world.ts)


Use bin/run.js to run your CLI in production mode:
$ ./bin/run.js hello worldhello world! (./src/commands/hello/world.ts)


Initialize oclif in an Existing Project​
If you want to start using oclif inside an existing project, then use the oclif init command to add the necessary files, dependencies, and configuration.
$ oclif init? Command bin name the CLI will export (my-pkg): my-pkg? Select topic separator: spaces? Select a module type: CommonJS? Select a package manager: npmCreated CLI in my-pkg
oclif init adds the following:

bin scripts: bin/run.js, bin/run.cmd, bin/dev.js, and bin/dev.cmd. See bin scripts for more information.
oclif section to package.json with the bin, dirname, commands, and topicSeparator properties set. See Configuring Your CLI for more information.
@oclif/core to the dependencies property in your package.json (if it's not already there).
ts-node to the devDependencies property in your package.json (if it's not already there).

Next Steps​
Add Commands​
After you've generated an oclif project or initialized it in your existing project, start adding new commands. This example creates a new command with the TypeScript source file src/commands/foo/bar.ts that you can customize to do whatever you want:
$ oclif generate command foo:bar
See the documentation for flags and args which shows how to add flags and arguments to your command; the documentation for commands shows the other options you can set on your command.
Add Hooks​
You can also add hooks to your CLI that allow you to further customize the behavior of your CLI:
$ oclif generate hook my-hook --event init
Further customizations​

Configure Your CLI
Custom Help
Use a Base Command Class
Enhance the User Experience

Other Tutorials​
Our friend, @joshcanhelp, wrote a fantastic tutorial on his blog that we encourage you to read as well.Edit this pageLast updated on Dec 20, 2024 by Mike DonnalleyNextFeaturesRequirementsCreate an oclif Project from ScratchInitialize oclif in an Existing ProjectNext StepsAdd CommandsAdd HooksFurther customizationsOther Tutorials\n\n\n\nAPI ReferenceHelp ClassesOn this pageHelp ClassesOut of the box oclif provides a great help experience for CLIs. Users can invoke help with the --help flag.
$ my-cli login --help
If you want your CLI to have an explicit help command, add @oclif/plugin-help as an oclif plugin in your config.
$ my-cli help
Custom Help​
To get started, first define the filepath to your help class in oclif's config in package.json. This is a relative path to the help class, without a file extension.
For this example, the help class will be created in a file at "[project root]/src/help.ts".
{  "oclif": {    "helpClass": "./dist/help"  }}
From here there are two paths, implement the HelpBase abstract class yourself or overwrite the parts of the default Help class you want to customize (ex: how command usage is displayed). We recommend the latter approach but cover both below.
Extending the HelpBase class​
The HelpBase abstract class provides a starting point requiring the minimum needed methods implemented to be compatible with oclif.
import {Command, HelpBase} from '@oclif/core';export default class CustomHelp extends HelpBase {  showHelp(args: string[]) {    console.log('This will be displayed in multi-command CLIs')  }  showCommandHelp(command: Command.Loadable) {    console.log('This will be displayed in single-command CLIs')  }}
The showHelp method is called by oclif to display help in multi-command CLIs, while showCommandHelp is called directly for single-command CLIs.
The class is instantiated with a config property that provides helpful context for constructing your custom output.
To see an example of what is possible take a look at the source code for the default Help class exported from @oclif/core.
Extending the default Help class​
The default Help class provides many method “hooks” that make it easy to override the particular parts of help's output you want to customize.
import {Command, Help, Interfaces} from '@oclif/core'export default class MyHelpClass extends Help {  // acts as a "router"  // and based on the args it receives  // calls one of showRootHelp, showTopicHelp,  // the formatting for an individual command  formatCommand(command: Command.Loadable): string {}  // the formatting for a list of commands  formatCommands(commands: Command.Loadable[]): string {}  // displayed for the root help  formatRoot(): string {}  // the formatting for an individual topic  formatTopic(topic: Interfaces.Topic): string {}  // the default implementations of showRootHelp  // showTopicHelp and showCommandHelp  // will call various format methods that  // provide the formatting for their corresponding  // help sections;  // these can be overwritten as well  // the formatting responsible for the header  // the formatting for a list of topics  protected formatTopics(topics: Interfaces.Topic[]): string {}  // display help for a command  showCommandHelp(command: Command.Loadable): void {}  // or showCommandHelp  showHelp(args: string[]): void {}  // display the root help of a CLI  showRootHelp(): void {}  // display help for a topic  showTopicHelp(topic: Interfaces.Topic): void {}}
To see the default implementation of these methods take a look at the default Help class exported from @oclif/core.
To start experimenting, define showCommandHelp in your custom help class and change the output.
import {Command, Help} from '@oclif/core';export default class MyHelpClass extends Help {  public showCommandHelp(command: Command.Loadable) {    console.log('Display my custom command help!')  }}
Then run help for any command.
$ my-cli login --helpDisplay my custom command help!Edit this pageLast updated on Dec 20, 2024 by Mike Donnalley\n\nAPI ReferenceHelp ClassesOn this pageHelp ClassesOut of the box oclif provides a great help experience for CLIs. Users can invoke help with the --help flag.
$ my-cli login --help
If you want your CLI to have an explicit help command, add @oclif/plugin-help as an oclif plugin in your config.
$ my-cli help
Custom Help​
To get started, first define the filepath to your help class in oclif's config in package.json. This is a relative path to the help class, without a file extension.
For this example, the help class will be created in a file at "[project root]/src/help.ts".
{  "oclif": {    "helpClass": "./dist/help"  }}
From here there are two paths, implement the HelpBase abstract class yourself or overwrite the parts of the default Help class you want to customize (ex: how command usage is displayed). We recommend the latter approach but cover both below.
Extending the HelpBase class​
The HelpBase abstract class provides a starting point requiring the minimum needed methods implemented to be compatible with oclif.
import {Command, HelpBase} from '@oclif/core';export default class CustomHelp extends HelpBase {  showHelp(args: string[]) {    console.log('This will be displayed in multi-command CLIs')  }  showCommandHelp(command: Command.Loadable) {    console.log('This will be displayed in single-command CLIs')  }}
The showHelp method is called by oclif to display help in multi-command CLIs, while showCommandHelp is called directly for single-command CLIs.
The class is instantiated with a config property that provides helpful context for constructing your custom output.
To see an example of what is possible take a look at the source code for the default Help class exported from @oclif/core.
Extending the default Help class​
The default Help class provides many method “hooks” that make it easy to override the particular parts of help's output you want to customize.
import {Command, Help, Interfaces} from '@oclif/core'export default class MyHelpClass extends Help {  // acts as a "router"  // and based on the args it receives  // calls one of showRootHelp, showTopicHelp,  // the formatting for an individual command  formatCommand(command: Command.Loadable): string {}  // the formatting for a list of commands  formatCommands(commands: Command.Loadable[]): string {}  // displayed for the root help  formatRoot(): string {}  // the formatting for an individual topic  formatTopic(topic: Interfaces.Topic): string {}  // the default implementations of showRootHelp  // showTopicHelp and showCommandHelp  // will call various format methods that  // provide the formatting for their corresponding  // help sections;  // these can be overwritten as well  // the formatting responsible for the header  // the formatting for a list of topics  protected formatTopics(topics: Interfaces.Topic[]): string {}  // display help for a command  showCommandHelp(command: Command.Loadable): void {}  // or showCommandHelp  showHelp(args: string[]): void {}  // display the root help of a CLI  showRootHelp(): void {}  // display help for a topic  showTopicHelp(topic: Interfaces.Topic): void {}}
To see the default implementation of these methods take a look at the default Help class exported from @oclif/core.
To start experimenting, define showCommandHelp in your custom help class and change the output.
import {Command, Help} from '@oclif/core';export default class MyHelpClass extends Help {  public showCommandHelp(command: Command.Loadable) {    console.log('Display my custom command help!')  }}
Then run help for any command.
$ my-cli login --helpDisplay my custom command help!Edit this pageLast updated on Dec 20, 2024 by Mike DonnalleyPreviousPluginsNextPerformanceCustom HelpExtending the HelpBase classExtending the default Help class\n\n\n\nGuidesCustom Base ClassCustom Base ClassUse inheritance to share functionality between common commands. Here is an example of a command base class that has some common shared flags.
For large CLIs with multiple plugins, it's useful to put this base class into its own npm package to be shared.
// src/baseCommand.tsimport {Command, Flags, Interfaces} from '@oclif/core'export type Flags<T extends typeof Command> = Interfaces.InferredFlags<typeof BaseCommand['baseFlags'] & T['flags']>export type Args<T extends typeof Command> = Interfaces.InferredArgs<T['args']>export abstract class BaseCommand<T extends typeof Command> extends Command {  // add the --json flag  static enableJsonFlag = true  // define flags that can be inherited by any command that extends BaseCommand  static baseFlags = {    'log-level': Flags.option({      default: 'info',      helpGroup: 'GLOBAL',      options: ['debug', 'warn', 'error', 'info', 'trace'] as const,      summary: 'Specify level for logging.',    })(),  }  protected flags!: Flags<T>  protected args!: Args<T>  public async init(): Promise<void> {    await super.init()    const {args, flags} = await this.parse({      flags: this.ctor.flags,      baseFlags: (super.ctor as typeof BaseCommand).baseFlags,      enableJsonFlag: this.ctor.enableJsonFlag,      args: this.ctor.args,      strict: this.ctor.strict,    })    this.flags = flags as Flags<T>    this.args = args as Args<T>  }  protected async catch(err: Error & {exitCode?: number}): Promise<any> {    // add any custom logic to handle errors from the command    // or simply return the parent class error handling    return super.catch(err)  }  protected async finally(_: Error | undefined): Promise<any> {    // called after run and catch regardless of whether or not the command errored    return super.finally(_)  }}// src/commands/my-command.tsexport default class MyCommand extends BaseCommand<typeof MyCommand> {  static summary = 'child class that extends BaseCommand'  static examples = [    '<%= config.bin %> <%= command.id %>',    '<%= config.bin %> <%= command.id %> --json',    '<%= config.bin %> <%= command.id %> --log-level debug',  ]  static flags = {    name: Flags.string({      char: 'n',      summary: 'Name to print.',      required: true,    }),  }  public async run(): Promise<Flags<typeof MyCommand>> {    for (const [flag, value] of Object.entries(this.flags)) {      this.log(`${flag}: ${value}`)    }    return this.flags  }}
For a more complex example, here's how we do this for the Salesforce CLI.Edit this pageLast updated on Dec 20, 2024 by Mike Donnalley\n\nGuidesCustom Base ClassCustom Base ClassUse inheritance to share functionality between common commands. Here is an example of a command base class that has some common shared flags.
For large CLIs with multiple plugins, it's useful to put this base class into its own npm package to be shared.
// src/baseCommand.tsimport {Command, Flags, Interfaces} from '@oclif/core'export type Flags<T extends typeof Command> = Interfaces.InferredFlags<typeof BaseCommand['baseFlags'] & T['flags']>export type Args<T extends typeof Command> = Interfaces.InferredArgs<T['args']>export abstract class BaseCommand<T extends typeof Command> extends Command {  // add the --json flag  static enableJsonFlag = true  // define flags that can be inherited by any command that extends BaseCommand  static baseFlags = {    'log-level': Flags.option({      default: 'info',      helpGroup: 'GLOBAL',      options: ['debug', 'warn', 'error', 'info', 'trace'] as const,      summary: 'Specify level for logging.',    })(),  }  protected flags!: Flags<T>  protected args!: Args<T>  public async init(): Promise<void> {    await super.init()    const {args, flags} = await this.parse({      flags: this.ctor.flags,      baseFlags: (super.ctor as typeof BaseCommand).baseFlags,      enableJsonFlag: this.ctor.enableJsonFlag,      args: this.ctor.args,      strict: this.ctor.strict,    })    this.flags = flags as Flags<T>    this.args = args as Args<T>  }  protected async catch(err: Error & {exitCode?: number}): Promise<any> {    // add any custom logic to handle errors from the command    // or simply return the parent class error handling    return super.catch(err)  }  protected async finally(_: Error | undefined): Promise<any> {    // called after run and catch regardless of whether or not the command errored    return super.finally(_)  }}// src/commands/my-command.tsexport default class MyCommand extends BaseCommand<typeof MyCommand> {  static summary = 'child class that extends BaseCommand'  static examples = [    '<%= config.bin %> <%= command.id %>',    '<%= config.bin %> <%= command.id %> --json',    '<%= config.bin %> <%= command.id %> --log-level debug',  ]  static flags = {    name: Flags.string({      char: 'n',      summary: 'Name to print.',      required: true,    }),  }  public async run(): Promise<Flags<typeof MyCommand>> {    for (const [flag, value] of Object.entries(this.flags)) {      this.log(`${flag}: ${value}`)    }    return this.flags  }}
For a more complex example, here's how we do this for the Salesforce CLI.Edit this pageLast updated on Dec 20, 2024 by Mike DonnalleyPreviousAliasesNextConfiguring Your CLI\n\n\n\nGuidesUser ExperienceUser Experienceoclif's philosophy is that developers should be free to design any user experience they want for their users. In other words, we try really hard to not make any UX decisions for you.
So many times we utilize hooks whenever a user experience is required (e.g. the provided command isn't found). That way, you can design the exact experience you want your users to have. In the case of error handling, you're able to override oclif's default behavior.
But to make it easy for you, @oclif/core exports a ux module that offers a small number of tools to implement your desired user experience.
If you need more complex user experiences, we suggest the following libraries:

For prompts: inquirer
For spinners: ora
For progress bars: cli-progress
For tables: tty-table, cliui
For trees: object-treeify
For colored JSON: color-json
For notifications: node-notifier
For links: terminal-link
For rendering react components: ink
Edit this pageLast updated on Dec 20, 2024 by Mike Donnalley\n\nGuidesUser ExperienceUser Experienceoclif's philosophy is that developers should be free to design any user experience they want for their users. In other words, we try really hard to not make any UX decisions for you.
So many times we utilize hooks whenever a user experience is required (e.g. the provided command isn't found). That way, you can design the exact experience you want your users to have. In the case of error handling, you're able to override oclif's default behavior.
But to make it easy for you, @oclif/core exports a ux module that offers a small number of tools to implement your desired user experience.
If you need more complex user experiences, we suggest the following libraries:

For prompts: inquirer
For spinners: ora
For progress bars: cli-progress
For tables: tty-table, cliui
For trees: object-treeify
For colored JSON: color-json
For notifications: node-notifier
For links: terminal-link
For rendering react components: ink
Edit this pageLast updated on Dec 20, 2024 by Mike DonnalleyPreviousThemesNextAPI Reference\n\n\n\nGetting StartedIntroductionOn this pageIntroductionoclif is a framework for building command-line interfaces (CLIs) using Node.js. You can use it like a simple flag parser, but it's capable of much more. It's designed to be extensible so that you can easily add plugins, such as the update warning plugin, or build your own for users to install at runtime.
The oclif generator creates a CLI project in TypeScript to get you started quickly. The generated CLI requires very few runtime dependencies and has minimal overhead.
Everything is customizable in oclif. Even the flag parser and help generation is optional and can be replaced. It's a platform to build upon that provides smart defaults without locking you in to any specific tools or behavior.
Requirements​
Only LTS Node versions are supported. If you want to ensure that users are on a specifc Node.js version, you can add the node package to your CLI.
To install the oclif CLI itself, run this command:
$ npm install --global oclif
Create an oclif Project from Scratch​
To create a new oclif project from scratch, run the oclif generate command.
$ oclif generate mynewcliGenerating mynewcli in /Users/me/oclif/mynewcli? Select a module type ESM? NPM package name mynewcli? Command bin name the CLI will export mynewcli<more prompts...>$ cd mynewcli$ ./bin/dev.js hello worldhello world! (./src/commands/hello/world.ts)
The command creates a new project based on our templates. To learn more about what's included in these templates, read the documentation here.
After oclif generate completes, run your CLI using the included bin scripts.


Use bin/dev.js to run your CLI in development mode:
$ ./bin/dev.js hello worldhello world! (./src/commands/hello/world.ts)


Use bin/run.js to run your CLI in production mode:
$ ./bin/run.js hello worldhello world! (./src/commands/hello/world.ts)


Initialize oclif in an Existing Project​
If you want to start using oclif inside an existing project, then use the oclif init command to add the necessary files, dependencies, and configuration.
$ oclif init? Command bin name the CLI will export (my-pkg): my-pkg? Select topic separator: spaces? Select a module type: CommonJS? Select a package manager: npmCreated CLI in my-pkg
oclif init adds the following:

bin scripts: bin/run.js, bin/run.cmd, bin/dev.js, and bin/dev.cmd. See bin scripts for more information.
oclif section to package.json with the bin, dirname, commands, and topicSeparator properties set. See Configuring Your CLI for more information.
@oclif/core to the dependencies property in your package.json (if it's not already there).
ts-node to the devDependencies property in your package.json (if it's not already there).

Next Steps​
Add Commands​
After you've generated an oclif project or initialized it in your existing project, start adding new commands. This example creates a new command with the TypeScript source file src/commands/foo/bar.ts that you can customize to do whatever you want:
$ oclif generate command foo:bar
See the documentation for flags and args which shows how to add flags and arguments to your command; the documentation for commands shows the other options you can set on your command.
Add Hooks​
You can also add hooks to your CLI that allow you to further customize the behavior of your CLI:
$ oclif generate hook my-hook --event init
Further customizations​

Configure Your CLI
Custom Help
Use a Base Command Class
Enhance the User Experience

Other Tutorials​
Our friend, @joshcanhelp, wrote a fantastic tutorial on his blog that we encourage you to read as well.Edit this pageLast updated on Dec 20, 2024 by Mike Donnalley\n\nGetting StartedIntroductionOn this pageIntroductionoclif is a framework for building command-line interfaces (CLIs) using Node.js. You can use it like a simple flag parser, but it's capable of much more. It's designed to be extensible so that you can easily add plugins, such as the update warning plugin, or build your own for users to install at runtime.
The oclif generator creates a CLI project in TypeScript to get you started quickly. The generated CLI requires very few runtime dependencies and has minimal overhead.
Everything is customizable in oclif. Even the flag parser and help generation is optional and can be replaced. It's a platform to build upon that provides smart defaults without locking you in to any specific tools or behavior.
Requirements​
Only LTS Node versions are supported. If you want to ensure that users are on a specifc Node.js version, you can add the node package to your CLI.
To install the oclif CLI itself, run this command:
$ npm install --global oclif
Create an oclif Project from Scratch​
To create a new oclif project from scratch, run the oclif generate command.
$ oclif generate mynewcliGenerating mynewcli in /Users/me/oclif/mynewcli? Select a module type ESM? NPM package name mynewcli? Command bin name the CLI will export mynewcli<more prompts...>$ cd mynewcli$ ./bin/dev.js hello worldhello world! (./src/commands/hello/world.ts)
The command creates a new project based on our templates. To learn more about what's included in these templates, read the documentation here.
After oclif generate completes, run your CLI using the included bin scripts.


Use bin/dev.js to run your CLI in development mode:
$ ./bin/dev.js hello worldhello world! (./src/commands/hello/world.ts)


Use bin/run.js to run your CLI in production mode:
$ ./bin/run.js hello worldhello world! (./src/commands/hello/world.ts)


Initialize oclif in an Existing Project​
If you want to start using oclif inside an existing project, then use the oclif init command to add the necessary files, dependencies, and configuration.
$ oclif init? Command bin name the CLI will export (my-pkg): my-pkg? Select topic separator: spaces? Select a module type: CommonJS? Select a package manager: npmCreated CLI in my-pkg
oclif init adds the following:

bin scripts: bin/run.js, bin/run.cmd, bin/dev.js, and bin/dev.cmd. See bin scripts for more information.
oclif section to package.json with the bin, dirname, commands, and topicSeparator properties set. See Configuring Your CLI for more information.
@oclif/core to the dependencies property in your package.json (if it's not already there).
ts-node to the devDependencies property in your package.json (if it's not already there).

Next Steps​
Add Commands​
After you've generated an oclif project or initialized it in your existing project, start adding new commands. This example creates a new command with the TypeScript source file src/commands/foo/bar.ts that you can customize to do whatever you want:
$ oclif generate command foo:bar
See the documentation for flags and args which shows how to add flags and arguments to your command; the documentation for commands shows the other options you can set on your command.
Add Hooks​
You can also add hooks to your CLI that allow you to further customize the behavior of your CLI:
$ oclif generate hook my-hook --event init
Further customizations​

Configure Your CLI
Custom Help
Use a Base Command Class
Enhance the User Experience

Other Tutorials​
Our friend, @joshcanhelp, wrote a fantastic tutorial on his blog that we encourage you to read as well.Edit this pageLast updated on Dec 20, 2024 by Mike DonnalleyNextFeaturesRequirementsCreate an oclif Project from ScratchInitialize oclif in an Existing ProjectNext StepsAdd CommandsAdd HooksFurther customizationsOther Tutorials\n\n\n\nThe Open CLI FrameworkCreate command line tools your users loveoclif is an open source framework for building a command line interface (CLI) in Node.js and Typescript. Create CLIs with a few flags or advanced CLIs that have subcommands. oclif makes it easy for you to build CLIs for your company, service, or your own development needs.$ npx oclif generate mynewcli? npm package name (mynewcli): mynewcli$ cd mynewcli$ ./bin/run.js hello worldhello world! (./src/commands/hello/world.ts)Get Started →⚡Ready to goScaffold a fully functional CLI to get started quickly. oclif packages our years of experience into out-of-the-box functionality for argument parsing, command testing, and auto-documentation of CLI features.👐Open sourceoclif is open source and free to use or modify. We think you’ll love it too and you can also help make it better.✅ExtendableYou or your users can easily extend your CLI functionality to meet custom needs using plugins. Plugins are modular and shareable, encouraging reuse.🔒Trustedoclif is actively used to build the Heroku and Salesforce CLIs, powering millions of interactions for developers every day.CLIs built using With oclif you can build command line tools for your business, open source project, or your own development workflow. Check out what others have built.\n\n\n\n📄️ CommandsA basic command looks like the following in TypeScript:📄️ Command ArgumentsArguments are positional arguments passed to the command. For example, if this command was run with mycli arg1 arg2 it would be declared like this:📄️ Command FlagsFlag options are non-positional arguments passed to the command. Flags can either be option flags which take an argument, or boolean flags which do not. An option flag must have an argument.📄️ ConfigInside a command, this.config provides access to the Config class, which contains useful properties and methods you can use in your command. Here are a list of its methods and properties:📄️ Command Discovery StrategiesWhen oclif loads a plugin is must find all the commands within that plugin that can be executed. There a three strategies for discovering these commands:📄️ TopicsAs CLIs grow it can be useful to nest commands within topics. This is supported simply by placing command files in subdirectories. For example, with the Salesforce CLI we have a topic sf config with commands like sf config set and sf config get. The directory structure looks like this:📄️ Topic SeparatorsBy default, topics will be separated with colons, e.g. mycommand. However, you have the option to use spaces if you prefer, e.g. my awesome command.📄️ Hooksoclif exposes lifecycle event hooks such as init and commandnotfound. See below for a list of all the lifecycle events. In addition to these built-in events, you can create your own events and allow commands/plugins to watch for these custom events. It's a great way to allow multiple plugins to interact with each other.📄️ PluginsPlugins are a great way to offer experimental functionality, allow users to extend your CLI, break up a CLI into modular components, or share functionality between CLIs.📄️ Help ClassesOut of the box oclif provides a great help experience for CLIs. Users can invoke help with the --help flag.📄️ Performanceoclif supports performance tracking out of the box - both for oclif and you own code. You can enable it in one of two ways depending on how you've implemented your bin scripts.📄️ CommandsA basic command looks like the following in TypeScript:📄️ Command ArgumentsArguments are positional arguments passed to the command. For example, if this command was run with mycli arg1 arg2 it would be declared like this:📄️ Command FlagsFlag options are non-positional arguments passed to the command. Flags can either be option flags which take an argument, or boolean flags which do not. An option flag must have an argument.📄️ ConfigInside a command, this.config provides access to the Config class, which contains useful properties and methods you can use in your command. Here are a list of its methods and properties:📄️ Command Discovery StrategiesWhen oclif loads a plugin is must find all the commands within that plugin that can be executed. There a three strategies for discovering these commands:📄️ TopicsAs CLIs grow it can be useful to nest commands within topics. This is supported simply by placing command files in subdirectories. For example, with the Salesforce CLI we have a topic sf config with commands like sf config set and sf config get. The directory structure looks like this:📄️ Topic SeparatorsBy default, topics will be separated with colons, e.g. mycommand. However, you have the option to use spaces if you prefer, e.g. my awesome command.📄️ Hooksoclif exposes lifecycle event hooks such as init and commandnotfound. See below for a list of all the lifecycle events. In addition to these built-in events, you can create your own events and allow commands/plugins to watch for these custom events. It's a great way to allow multiple plugins to interact with each other.📄️ PluginsPlugins are a great way to offer experimental functionality, allow users to extend your CLI, break up a CLI into modular components, or share functionality between CLIs.📄️ Help ClassesOut of the box oclif provides a great help experience for CLIs. Users can invoke help with the --help flag.📄️ Performanceoclif supports performance tracking out of the box - both for oclif and you own code. You can enable it in one of two ways depending on how you've implemented your bin scripts.\n\nAPI ReferenceAPI Reference📄️ CommandsA basic command looks like the following in TypeScript:📄️ Command ArgumentsArguments are positional arguments passed to the command. For example, if this command was run with mycli arg1 arg2 it would be declared like this:📄️ Command FlagsFlag options are non-positional arguments passed to the command. Flags can either be option flags which take an argument, or boolean flags which do not. An option flag must have an argument.📄️ ConfigInside a command, this.config provides access to the Config class, which contains useful properties and methods you can use in your command. Here are a list of its methods and properties:📄️ Command Discovery StrategiesWhen oclif loads a plugin is must find all the commands within that plugin that can be executed. There a three strategies for discovering these commands:📄️ TopicsAs CLIs grow it can be useful to nest commands within topics. This is supported simply by placing command files in subdirectories. For example, with the Salesforce CLI we have a topic sf config with commands like sf config set and sf config get. The directory structure looks like this:📄️ Topic SeparatorsBy default, topics will be separated with colons, e.g. mycommand. However, you have the option to use spaces if you prefer, e.g. my awesome command.📄️ Hooksoclif exposes lifecycle event hooks such as init and commandnotfound. See below for a list of all the lifecycle events. In addition to these built-in events, you can create your own events and allow commands/plugins to watch for these custom events. It's a great way to allow multiple plugins to interact with each other.📄️ PluginsPlugins are a great way to offer experimental functionality, allow users to extend your CLI, break up a CLI into modular components, or share functionality between CLIs.📄️ Help ClassesOut of the box oclif provides a great help experience for CLIs. Users can invoke help with the --help flag.📄️ Performanceoclif supports performance tracking out of the box - both for oclif and you own code. You can enable it in one of two ways depending on how you've implemented your bin scripts.PreviousUser ExperienceNextCommands\n\n\n\nAPI ReferenceConfigOn this pageConfigInside a command, this.config provides access to the Config class, which contains useful properties and methods you can use in your command. Here are a list of its methods and properties:

name - name of CLI
version - Version of the CLI.
pjson - Parsed CLI package.json.
bin - CLI bin name
cacheDir - CLI cache directory

macOS: ~/Library/Caches/mycli
Unix: ~/.cache/mycli
Windows: %LOCALAPPDATA%\mycli
Can be overridden with XDG_CACHE_HOME


configDir - CLI config directory

Unix: ~/.config/mycli
Windows: %LOCALAPPDATA%\mycli
Can be overridden with XDG_CONFIG_HOME


dataDir - CLI data directory

Unix: ~/.data/mycli
Windows: %LOCALAPPDATA%\mycli
Can be overridden with XDG_DATA_HOME


dirname - dirname used with cacheDir|configDir|dataDir. Can be overridden in package.json.
errlog - path to error log inside of cacheDir
home - user home directory
platform - operating system darwin|linux|win32
arch - process architecture x64|x86
shell - current shell in use
userAgent - user-agent intended for http calls. example: mycli/1.2.3 (darwin-x64) node-9.0.0
windows - boolean
npmRegistry - current npm registry to use with the plugins plugin
plugins - loaded plugins
commands - all commands in CLI
default - default cli command
topics - all topics in CLI
commandIDs - string IDs of all commands
async runHook(event, opts) - trigger a hook
async runCommand(id, opts) - Run a command
scopedEnvVar(key) - Return the value of a scoped env var (e.g. \<CLI>_NPM_REGISTRY)
scopedEnvVarKey(key) - Return the name of a scoped env var (e.g. \<CLI>_NPM_REGISTRY)
scopedEnvVarTrue(key) - Return true/false value of scoped env var (e.g. \<CLI>_NPM_REGISTRY)

Custom User Configuration​
Often it's useful to have a custom configuration for your users. One way to implement this is to read a config.json file from the CLI's config directory:
import { Command } from "@oclif/core";import * as fs from "fs-extra";import * as path from "path";export class extends Command {  async run() {    const userConfig = await fs.readJSON(      path.join(this.config.configDir, "config.json")    );    this.log("User config:");    console.dir(userConfig);  }}
To share this logic between different commands, use a base class.Edit this pageLast updated on Dec 20, 2024 by Mike Donnalley\n\nAPI ReferenceConfigOn this pageConfigInside a command, this.config provides access to the Config class, which contains useful properties and methods you can use in your command. Here are a list of its methods and properties:

name - name of CLI
version - Version of the CLI.
pjson - Parsed CLI package.json.
bin - CLI bin name
cacheDir - CLI cache directory

macOS: ~/Library/Caches/mycli
Unix: ~/.cache/mycli
Windows: %LOCALAPPDATA%\mycli
Can be overridden with XDG_CACHE_HOME


configDir - CLI config directory

Unix: ~/.config/mycli
Windows: %LOCALAPPDATA%\mycli
Can be overridden with XDG_CONFIG_HOME


dataDir - CLI data directory

Unix: ~/.data/mycli
Windows: %LOCALAPPDATA%\mycli
Can be overridden with XDG_DATA_HOME


dirname - dirname used with cacheDir|configDir|dataDir. Can be overridden in package.json.
errlog - path to error log inside of cacheDir
home - user home directory
platform - operating system darwin|linux|win32
arch - process architecture x64|x86
shell - current shell in use
userAgent - user-agent intended for http calls. example: mycli/1.2.3 (darwin-x64) node-9.0.0
windows - boolean
npmRegistry - current npm registry to use with the plugins plugin
plugins - loaded plugins
commands - all commands in CLI
default - default cli command
topics - all topics in CLI
commandIDs - string IDs of all commands
async runHook(event, opts) - trigger a hook
async runCommand(id, opts) - Run a command
scopedEnvVar(key) - Return the value of a scoped env var (e.g. \<CLI>_NPM_REGISTRY)
scopedEnvVarKey(key) - Return the name of a scoped env var (e.g. \<CLI>_NPM_REGISTRY)
scopedEnvVarTrue(key) - Return true/false value of scoped env var (e.g. \<CLI>_NPM_REGISTRY)

Custom User Configuration​
Often it's useful to have a custom configuration for your users. One way to implement this is to read a config.json file from the CLI's config directory:
import { Command } from "@oclif/core";import * as fs from "fs-extra";import * as path from "path";export class extends Command {  async run() {    const userConfig = await fs.readJSON(      path.join(this.config.configDir, "config.json")    );    this.log("User config:");    console.dir(userConfig);  }}
To share this logic between different commands, use a base class.Edit this pageLast updated on Dec 20, 2024 by Mike DonnalleyPreviousCommand FlagsNextCommand Discovery StrategiesCustom User Configuration\n\n\n\nAPI ReferenceCommand Discovery StrategiesOn this pageCommand Discovery StrategiesWhen oclif loads a plugin is must find all the commands within that plugin that can be executed. There a three strategies for discovering these commands:

pattern - this is the default behavior that finds commands based on glob patterns.
explicit - find commands that are exported from a specified file.
single - CLI contains a single command executed by top-level bin.

pattern Strategy​
The pattern strategy tells oclif to use a predefined set of globs to find command files in a specified directory. This is the default behavior of oclif unless otherwise stated.
Plugins can point the commands property to a directory
{  "oclif": {    "commands": "./dist/commands",  }}
This will tell oclif to look for commands in that directory (this is skipped if an oclif.manifest.json is present)
Alternatively, you can set this configuration which will do the exact same thing:
{  "oclif": {    "commands": {      "strategy": "pattern",      "target": "./dist/commands"    }  }}
You also have the ability to set globPatterns, which override the glob patterns that oclif uses when searching for command files:
{  "oclif": {    "commands": {      "strategy": "pattern",      "target": "./dist/commands",      "globPatterns": [         "**/*.+(js|cjs|mjs|ts|tsx|mts|cts)",        "!**/*.+(d.*|test.*|spec.*|helpers.*)?(x)"      ]    }  }}
This is useful if you like to put test or helper files in the same directory as your command files.
explicit Strategy​
The explicit strategy tells oclif to import commands from a single file. In this case the target is the file that exports the commands and identifier is the name of the export (defaults to default).
To use this you would add a new file (e.g. src/commands.ts) and then add this configuration to the package.json
{  "oclif": {    "commands": {      "strategy": "explicit",      "target": "./dist/index.js",      "identifier": "COMMANDS",    }  }}
src/index.ts would then need to have an export with the same name as the identifier (if not set, it defaults to default) that's an object of command names to command classes, e.g.
import Hello from './commands/hello'import HelloWorld from './commands/hello/world'export const COMMANDS = {  hello: Hello,  'hello:world': HelloWorld,  howdy: Hello, // alias the `hello` command to `howdy`}
The explicit strategy is useful to those who can't rely on file paths because they've bundled their code (see Bundling) but it can also be used if you simply prefer to be more explicit about your commands instead of relying on oclif "magically" finding commands from the file system.
It can also be leveraged to create or modify commands at runtime (e.g. internationalize messages at runtime or add flags to a command based on an API spec - see dynamic commands section below).
Hooks​
Hooks can also be defined using the explicit strategy:
"oclif": {    "hooks": {      "init": {        "target": "./dist/index.js",        "identifier": "INIT_HOOK"      }    }}
// src/index.tsimport Hello from './commands/hello'import HelloWorld from './commands/hello/world'export {default as INIT_HOOK} from './hooks/init/init.js'export const COMMANDS = {  hello: Hello,  'hello:world': HelloWorld,  howdy: Hello, // alias the `hello` command to `howdy`}
That configuration is essentially telling oclif to look for an INIT_HOOK export inside of ./dist/index.js
Bundling​
We do not support bundling given the endless number of tools + configurations that could be used. But if you choose to use a bundler, like esbuild, there are a couple hard requirements - you must have a package.json in your root directory and a bin/run or bin/run.js bin script. This means that you will not be able to successfully bundle your entire CLI (src code, package.json, node_modules, etc) into a single file.
If you still want to use a bundler, you can reference this example repo.
Dynamic Commands​
You can also use the explicit strategy if you want to manipulate or create commands at runtime. Please note that such usage of the explicit strategy cannot be used with an oclif.manifest.json, which will have significant performance implications for your CLI in production.
Example:
// src/index.tsimport {Command, Flags} from '@oclif/core'import Hello from './commands/hello'import HelloWorld from './commands/hello/world'const dynamicCommands: Record<string, Command.Class> = {}if (process.env.DYNAMIC_COMMAND) {  dynamicCommands[process.env.DYNAMIC_COMMAND] = class extends Command {    static flags = {      flag1: Flags.boolean({description: 'flag1 description'}),    }    async run(): Promise<void> {      const {flags} = await this.parse(this.constructor as Command.Class)      this.log('hello from', this.id, flags)    }  }}export const COMMANDS = {  hello: Hello,  'hello:world': HelloWorld,  ...dynamicCommands,}
❯ DYNAMIC_COMMAND=foo:bar:baz bin/run.js foo bar baz --flag1hello from foo:bar:baz { flag1: true }
single Strategy​
The single strategy tells oclif that this CLI contains a single command that can be executed by the bin/run.js (e.g. ls or cat).
{  "oclif": {    "commands": {      "strategy": "single",      "target": "./dist/index.js"    }  }}
In this example, ./dist/index.js exports the command class.
Note about oclif.manifest.json​
For all strategies, the oclif.manifest.json will be used to load the commands instead of the default behavior of the strategy.Edit this pageLast updated on Dec 20, 2024 by Mike Donnalley\n\nAPI ReferenceCommand Discovery StrategiesOn this pageCommand Discovery StrategiesWhen oclif loads a plugin is must find all the commands within that plugin that can be executed. There a three strategies for discovering these commands:

pattern - this is the default behavior that finds commands based on glob patterns.
explicit - find commands that are exported from a specified file.
single - CLI contains a single command executed by top-level bin.

pattern Strategy​
The pattern strategy tells oclif to use a predefined set of globs to find command files in a specified directory. This is the default behavior of oclif unless otherwise stated.
Plugins can point the commands property to a directory
{  "oclif": {    "commands": "./dist/commands",  }}
This will tell oclif to look for commands in that directory (this is skipped if an oclif.manifest.json is present)
Alternatively, you can set this configuration which will do the exact same thing:
{  "oclif": {    "commands": {      "strategy": "pattern",      "target": "./dist/commands"    }  }}
You also have the ability to set globPatterns, which override the glob patterns that oclif uses when searching for command files:
{  "oclif": {    "commands": {      "strategy": "pattern",      "target": "./dist/commands",      "globPatterns": [         "**/*.+(js|cjs|mjs|ts|tsx|mts|cts)",        "!**/*.+(d.*|test.*|spec.*|helpers.*)?(x)"      ]    }  }}
This is useful if you like to put test or helper files in the same directory as your command files.
explicit Strategy​
The explicit strategy tells oclif to import commands from a single file. In this case the target is the file that exports the commands and identifier is the name of the export (defaults to default).
To use this you would add a new file (e.g. src/commands.ts) and then add this configuration to the package.json
{  "oclif": {    "commands": {      "strategy": "explicit",      "target": "./dist/index.js",      "identifier": "COMMANDS",    }  }}
src/index.ts would then need to have an export with the same name as the identifier (if not set, it defaults to default) that's an object of command names to command classes, e.g.
import Hello from './commands/hello'import HelloWorld from './commands/hello/world'export const COMMANDS = {  hello: Hello,  'hello:world': HelloWorld,  howdy: Hello, // alias the `hello` command to `howdy`}
The explicit strategy is useful to those who can't rely on file paths because they've bundled their code (see Bundling) but it can also be used if you simply prefer to be more explicit about your commands instead of relying on oclif "magically" finding commands from the file system.
It can also be leveraged to create or modify commands at runtime (e.g. internationalize messages at runtime or add flags to a command based on an API spec - see dynamic commands section below).
Hooks​
Hooks can also be defined using the explicit strategy:
"oclif": {    "hooks": {      "init": {        "target": "./dist/index.js",        "identifier": "INIT_HOOK"      }    }}
// src/index.tsimport Hello from './commands/hello'import HelloWorld from './commands/hello/world'export {default as INIT_HOOK} from './hooks/init/init.js'export const COMMANDS = {  hello: Hello,  'hello:world': HelloWorld,  howdy: Hello, // alias the `hello` command to `howdy`}
That configuration is essentially telling oclif to look for an INIT_HOOK export inside of ./dist/index.js
Bundling​
We do not support bundling given the endless number of tools + configurations that could be used. But if you choose to use a bundler, like esbuild, there are a couple hard requirements - you must have a package.json in your root directory and a bin/run or bin/run.js bin script. This means that you will not be able to successfully bundle your entire CLI (src code, package.json, node_modules, etc) into a single file.
If you still want to use a bundler, you can reference this example repo.
Dynamic Commands​
You can also use the explicit strategy if you want to manipulate or create commands at runtime. Please note that such usage of the explicit strategy cannot be used with an oclif.manifest.json, which will have significant performance implications for your CLI in production.
Example:
// src/index.tsimport {Command, Flags} from '@oclif/core'import Hello from './commands/hello'import HelloWorld from './commands/hello/world'const dynamicCommands: Record<string, Command.Class> = {}if (process.env.DYNAMIC_COMMAND) {  dynamicCommands[process.env.DYNAMIC_COMMAND] = class extends Command {    static flags = {      flag1: Flags.boolean({description: 'flag1 description'}),    }    async run(): Promise<void> {      const {flags} = await this.parse(this.constructor as Command.Class)      this.log('hello from', this.id, flags)    }  }}export const COMMANDS = {  hello: Hello,  'hello:world': HelloWorld,  ...dynamicCommands,}
❯ DYNAMIC_COMMAND=foo:bar:baz bin/run.js foo bar baz --flag1hello from foo:bar:baz { flag1: true }
single Strategy​
The single strategy tells oclif that this CLI contains a single command that can be executed by the bin/run.js (e.g. ls or cat).
{  "oclif": {    "commands": {      "strategy": "single",      "target": "./dist/index.js"    }  }}
In this example, ./dist/index.js exports the command class.
Note about oclif.manifest.json​
For all strategies, the oclif.manifest.json will be used to load the commands instead of the default behavior of the strategy.Edit this pageLast updated on Dec 20, 2024 by Mike DonnalleyPreviousConfigNextTopicspattern Strategyexplicit Strategysingle StrategyNote about oclif.manifest.json\n\n\n\nAPI ReferenceTopicsTopicsAs CLIs grow it can be useful to nest commands within topics. This is supported simply by placing command files in subdirectories. For example, with the Salesforce CLI we have a topic sf config with commands like sf config set and sf config get. The directory structure looks like this:
package.jsonsrc/└── commands/    └── config/        ├── index.ts        ├── set.ts        └── get.ts
The help descriptions will be the description of the first command within a directory. If you'd like to customize the help description, add it to the package.json like so:
{  "oclif": {    "topics": {      "apps:favorites": { "description": "manage favorite apps" },      "config": { "description": "manage heroku config variables" },    }  }}
Subtopics can be created by making subdirectories within topic directories, but for UX reasons we generally discourage going more than 1 or 2 levels deep even for the largest CLIs.Edit this pageLast updated on Dec 20, 2024 by Mike Donnalley\n\nAPI ReferenceTopicsTopicsAs CLIs grow it can be useful to nest commands within topics. This is supported simply by placing command files in subdirectories. For example, with the Salesforce CLI we have a topic sf config with commands like sf config set and sf config get. The directory structure looks like this:
package.jsonsrc/└── commands/    └── config/        ├── index.ts        ├── set.ts        └── get.ts
The help descriptions will be the description of the first command within a directory. If you'd like to customize the help description, add it to the package.json like so:
{  "oclif": {    "topics": {      "apps:favorites": { "description": "manage favorite apps" },      "config": { "description": "manage heroku config variables" },    }  }}
Subtopics can be created by making subdirectories within topic directories, but for UX reasons we generally discourage going more than 1 or 2 levels deep even for the largest CLIs.Edit this pageLast updated on Dec 20, 2024 by Mike DonnalleyPreviousCommand Discovery StrategiesNextTopic Separators\n\n\n\nAPI ReferenceTopic SeparatorsTopic SeparatorsBy default, topics will be separated with colons, e.g. my:awesome:command. However, you have the option to use spaces if you prefer, e.g. my awesome command.
To do this, simply set the topicSeparator property in the oclif section of your package.json
{  "oclif": {    "topicSeparator": " "  }}
Currently colons (":") and spaces (" ") are the only supported topic separators.Edit this pageLast updated on Dec 20, 2024 by Mike Donnalley\n\nAPI ReferenceTopic SeparatorsTopic SeparatorsBy default, topics will be separated with colons, e.g. my:awesome:command. However, you have the option to use spaces if you prefer, e.g. my awesome command.
To do this, simply set the topicSeparator property in the oclif section of your package.json
{  "oclif": {    "topicSeparator": " "  }}
Currently colons (":") and spaces (" ") are the only supported topic separators.Edit this pageLast updated on Dec 20, 2024 by Mike DonnalleyPreviousTopicsNextHooks\n\n\n\nAPI ReferencePluginsOn this pagePluginsPlugins are a great way to offer experimental functionality, allow users to extend your CLI, break up a CLI into modular components, or share functionality between CLIs.
Plugins can have commands or hooks just like a CLI. To add a plugin such as the not-found plugin plugin, first add it to your CLI with yarn add @oclif/plugin-not-found, then add the following to your package.json:
{  "name": "mycli",  "version": "0.0.0",  // ...  "dependencies": {    "@oclif/core": "^3",    "@oclif/plugin-help": "^6",    "@oclif/plugin-not-found": "^3",  }  "oclif": {    "plugins": [      "@oclif/plugin-help",      "@oclif/plugin-not-found"    ]  }}
Plugins can also be specified using minimatch patterns:
{  "name": "mycli",  "version": "0.0.0",  // ...  "dependencies": {    "@oclif/core": "^3",    "@oclif/plugin-help": "^6",    "@oclif/plugin-not-found": "^3",  }  "oclif": {    "plugins": [      "@oclif/plugin-*",    ]  }}
If you want users to be able to install their own plugins into your CLI, use the plugins plugin.
Useful Plugins​

@oclif/plugin-not-found - Display a friendly "did you mean" message if a command is not found.
@oclif/plugin-plugins - Allow users to add plugins to extend your CLI.
@oclif/plugin-update - Add autoupdate support to the CLI.
@oclif/plugin-help - Help plugin for oclif.
@oclif/plugin-warn-if-update-available - Show a warning message if user is running an out of date CLI.
@oclif/plugin-which - Show which plugin a command comes from.
@oclif/plugin-commands - Add a commands command to list all the commands.
@oclif/plugin-autocomplete - Add bash/zsh autocomplete.
@oclif/plugin-search - Add search command to your CLI.
@oclif/plugin-version - Add version command to your CLI.

Building your own plugin​
Writing code for plugins is essentially the same as writing within a CLI. They can export 3 different types: commands, hooks, and other plugins.
Run npx oclif generate mynewplugin to create a plugin in a new directory. This will come with a sample commands called hello and hello world.Edit this pageLast updated on Dec 20, 2024 by Mike Donnalley\n\nAPI ReferencePluginsOn this pagePluginsPlugins are a great way to offer experimental functionality, allow users to extend your CLI, break up a CLI into modular components, or share functionality between CLIs.
Plugins can have commands or hooks just like a CLI. To add a plugin such as the not-found plugin plugin, first add it to your CLI with yarn add @oclif/plugin-not-found, then add the following to your package.json:
{  "name": "mycli",  "version": "0.0.0",  // ...  "dependencies": {    "@oclif/core": "^3",    "@oclif/plugin-help": "^6",    "@oclif/plugin-not-found": "^3",  }  "oclif": {    "plugins": [      "@oclif/plugin-help",      "@oclif/plugin-not-found"    ]  }}
Plugins can also be specified using minimatch patterns:
{  "name": "mycli",  "version": "0.0.0",  // ...  "dependencies": {    "@oclif/core": "^3",    "@oclif/plugin-help": "^6",    "@oclif/plugin-not-found": "^3",  }  "oclif": {    "plugins": [      "@oclif/plugin-*",    ]  }}
If you want users to be able to install their own plugins into your CLI, use the plugins plugin.
Useful Plugins​

@oclif/plugin-not-found - Display a friendly "did you mean" message if a command is not found.
@oclif/plugin-plugins - Allow users to add plugins to extend your CLI.
@oclif/plugin-update - Add autoupdate support to the CLI.
@oclif/plugin-help - Help plugin for oclif.
@oclif/plugin-warn-if-update-available - Show a warning message if user is running an out of date CLI.
@oclif/plugin-which - Show which plugin a command comes from.
@oclif/plugin-commands - Add a commands command to list all the commands.
@oclif/plugin-autocomplete - Add bash/zsh autocomplete.
@oclif/plugin-search - Add search command to your CLI.
@oclif/plugin-version - Add version command to your CLI.

Building your own plugin​
Writing code for plugins is essentially the same as writing within a CLI. They can export 3 different types: commands, hooks, and other plugins.
Run npx oclif generate mynewplugin to create a plugin in a new directory. This will come with a sample commands called hello and hello world.Edit this pageLast updated on Dec 20, 2024 by Mike DonnalleyPreviousHooksNextHelp ClassesUseful PluginsBuilding your own plugin\n\n\n\nAPI ReferencePerformanceOn this pagePerformanceoclif supports performance tracking out of the box - both for oclif and you own code. You can enable it in one of two ways depending on how you've implemented your bin scripts.
If you're using the bin scripts that come from the generator, you can simply set performanceEnabled on the settings module:
How to Enable​
#!/usr/bin/env nodeimport {execute, settings} from '@oclif/core'settings.performanceEnabled = trueawait execute({dir: import.meta.url})
You can also enable it on the Config class directly if that works better for your CLI:
import {Config, run} from '@oclif/core'import {fileUrlToPath} from 'node:url'const config = await Config.load({  root: resolve(fileURLToPath(import.meta.url), '..');,  enablePerf: true})await run(config)
Accessing oclif-specific performance metrics​
Once performance is enabled, you can see the in the debug output under the oclif:perf scope.
❯ DEBUG=oclif:perf sf version@salesforce/cli/2.35.6 darwin-arm64 node-v20.11.0  oclif:perf Process Uptime: 747.6823ms +0ms  oclif:perf Oclif Time: 302.1286ms +0ms  oclif:perf Init Time: 37.7735ms +0ms  oclif:perf Config Load Time: 294.5321ms +0ms  oclif:perf   • Root Plugin Load Time: 11.2781ms +0ms  oclif:perf   • Plugins Load Time: 274.6006ms +0ms  oclif:perf   • Commands Load Time: 6.7736ms +0ms  oclif:perf Core Plugin Load Time: 20.9403ms +0ms  oclif:perf User Plugin Load Time: 0.0000ms +0ms  oclif:perf Linked Plugin Load Time: 2.3124ms +0ms  oclif:perf Plugin Load Times: +0ms  oclif:perf   oclif-hello-world: 239.1951ms (no manifest!) +0ms  oclif:perf   @oclif/plugin-update: 18.8549ms +0ms  oclif:perf   @oclif/plugin-autocomplete: 17.5277ms +0ms  oclif:perf   @oclif/plugin-commands: 16.4917ms +0ms  oclif:perf   @oclif/plugin-not-found: 16.3310ms +0ms  oclif:perf   @oclif/plugin-search: 15.8846ms +0ms  oclif:perf   @oclif/plugin-version: 14.8063ms +0ms  oclif:perf   @salesforce/plugin-org: 14.5657ms +0ms  oclif:perf   @salesforce/plugin-data: 14.3991ms +0ms  oclif:perf   @oclif/plugin-warn-if-update-available: 14.3733ms +0ms  oclif:perf   @oclif/plugin-which: 14.1629ms +0ms  oclif:perf   @salesforce/plugin-apex: 13.9885ms +0ms  oclif:perf   @salesforce/plugin-auth: 13.6895ms +0ms  oclif:perf   @salesforce/plugin-deploy-retrieve: 13.6353ms +0ms  oclif:perf   @salesforce/plugin-limits: 13.1123ms +0ms  oclif:perf   @salesforce/plugin-packaging: 12.9777ms +0ms  oclif:perf   @salesforce/plugin-info: 12.7787ms +0ms  oclif:perf   @salesforce/plugin-marketplace: 12.1542ms +0ms  oclif:perf   @salesforce/plugin-source: 11.9480ms +0ms  oclif:perf   @salesforce/plugin-schema: 11.7775ms +0ms  oclif:perf   @salesforce/plugin-settings: 11.4785ms +0ms  oclif:perf   @salesforce/plugin-templates: 11.4225ms +0ms  oclif:perf   @salesforce/plugin-sobject: 11.3670ms +0ms  oclif:perf   root: 11.2781ms +0ms  oclif:perf   @salesforce/plugin-user: 10.8521ms +0ms  oclif:perf   @salesforce/plugin-telemetry: 10.5724ms +1ms  oclif:perf   @salesforce/plugin-trust: 10.4463ms +0ms  oclif:perf   @oclif/plugin-plugins: 2.0135ms +0ms  oclif:perf   @oclif/plugin-help: 1.9039ms +0ms  oclif:perf Hook Run Times: +0ms  oclif:perf   init: +0ms  oclif:perf     total: 37.4624ms +0ms  oclif:perf     oclif-hello-world(./dist/hooks/init/init): 7.9818ms +0ms  oclif:perf     @oclif/plugin-warn-if-update-available(./lib/hooks/init/check-update): 37.1145ms +0ms  oclif:perf     @salesforce/plugin-settings(./lib/hooks/init/load_config_meta): 29.3073ms +0ms  oclif:perf     @oclif/plugin-update(./dist/hooks/init.js): 33.1767ms +0ms  oclif:perf   prerun: +0ms  oclif:perf     total: 260.5702ms +0ms  oclif:perf     @salesforce/cli(./dist/hooks/prerun): 2.3582ms +0ms  oclif:perf     @salesforce/plugin-telemetry(./lib/hooks/telemetryPrerun.js): 260.2634ms +0ms  oclif:perf   preparse: +0ms  oclif:perf     total: 0.5351ms +0ms  oclif:perf     @salesforce/cli(/dist/hooks/preparse): 0.5045ms +0ms  oclif:perf   postrun: +0ms  oclif:perf     total: 0.3507ms +0ms  oclif:perf Command Load Time: 0.7478ms +0ms  oclif:perf Command Run Time: 264.2587ms +0ms
You can also access these metrics programmatically like so:
const {Performance, flush, handle, run, settings} = await import('@oclif/core')settings.performanceEnabled = trueawait run(process.argv.slice(2))  .catch(async (error) => handle(error))  .finally(async () => {    console.log('Performance', Performance.oclifPerf)    await flush()  })
Using Performance for your code​
You can also use the Performance class to capture performance metrics on your own code base.
To capture performance metrics for a block of code, you need to create a new marker using Performance.mark. You then need to call the .stop method the marker to finish timing that block of code.
Here's a brief example:
import {Performance} from '@oclif/core'// Create a new marker.// First argument is the owner of the marker (This allows Performance to be able to distinguish the origin of each marker)// Second argument is the name of the maker. Naming convention that oclif uses internally is <module>.<method>#scope. You are free, however, to name these however you like.const marker = Performance.mark('my-plugin', 'hello.run')// do things that take a while.// Add details to the marker that you might want to access latermarker?.addDetails({from: flags.from, person: args.person})// Stop the marker. This will capture the amount of time between the creation of the marker and the stopping of the marker.marker?.stop()
And a more thorough example:
// ./src/commands/hello/index.tsimport {Args, Command, Flags, Performance} from '@oclif/core'export default class Hello extends Command {  static args = {    person: Args.string({description: 'Person to say hello to', required: true}),  }  static flags = {    from: Flags.string({char: 'f', description: 'Who is saying hello', required: true}),  }  async run(): Promise<void> {    const {args, flags} = await this.parse(Hello)    const marker = Performance.mark('my-plugin', 'hello.run')    await new Promise((resolve) => {      setTimeout(resolve, 1000)    })    marker?.addDetails({from: flags.from, person: args.person})    marker?.stop()    this.log(`hello ${args.person} from ${flags.from}! (./src/commands/hello/index.ts)`)  }}
All the markers you create will be accessible on the static results property on Performance:
// bin/run.jsconst {Performance, flush, handle, run, settings} = await import('@oclif/core')settings.performanceEnabled = trueawait run(process.argv.slice(2))  .catch(async (error) => handle(error))  .finally(async () => {    console.log('Results', Performance.results)    await flush()  })
❯ bin/run.js hello reader --from oclifhello reader from oclif! (./src/commands/hello/index.ts)Results Map(1) {  'my-plugin' => [    {      details: {        from: oclif,        person: reader      },      duration: 1003.4971249999999,      method: 'run',      module: 'hello',      name: 'hello.run',      scope: undefined    }  ]}Edit this pageLast updated on Dec 20, 2024 by Mike Donnalley\n\nAPI ReferencePerformanceOn this pagePerformanceoclif supports performance tracking out of the box - both for oclif and you own code. You can enable it in one of two ways depending on how you've implemented your bin scripts.
If you're using the bin scripts that come from the generator, you can simply set performanceEnabled on the settings module:
How to Enable​
#!/usr/bin/env nodeimport {execute, settings} from '@oclif/core'settings.performanceEnabled = trueawait execute({dir: import.meta.url})
You can also enable it on the Config class directly if that works better for your CLI:
import {Config, run} from '@oclif/core'import {fileUrlToPath} from 'node:url'const config = await Config.load({  root: resolve(fileURLToPath(import.meta.url), '..');,  enablePerf: true})await run(config)
Accessing oclif-specific performance metrics​
Once performance is enabled, you can see the in the debug output under the oclif:perf scope.
❯ DEBUG=oclif:perf sf version@salesforce/cli/2.35.6 darwin-arm64 node-v20.11.0  oclif:perf Process Uptime: 747.6823ms +0ms  oclif:perf Oclif Time: 302.1286ms +0ms  oclif:perf Init Time: 37.7735ms +0ms  oclif:perf Config Load Time: 294.5321ms +0ms  oclif:perf   • Root Plugin Load Time: 11.2781ms +0ms  oclif:perf   • Plugins Load Time: 274.6006ms +0ms  oclif:perf   • Commands Load Time: 6.7736ms +0ms  oclif:perf Core Plugin Load Time: 20.9403ms +0ms  oclif:perf User Plugin Load Time: 0.0000ms +0ms  oclif:perf Linked Plugin Load Time: 2.3124ms +0ms  oclif:perf Plugin Load Times: +0ms  oclif:perf   oclif-hello-world: 239.1951ms (no manifest!) +0ms  oclif:perf   @oclif/plugin-update: 18.8549ms +0ms  oclif:perf   @oclif/plugin-autocomplete: 17.5277ms +0ms  oclif:perf   @oclif/plugin-commands: 16.4917ms +0ms  oclif:perf   @oclif/plugin-not-found: 16.3310ms +0ms  oclif:perf   @oclif/plugin-search: 15.8846ms +0ms  oclif:perf   @oclif/plugin-version: 14.8063ms +0ms  oclif:perf   @salesforce/plugin-org: 14.5657ms +0ms  oclif:perf   @salesforce/plugin-data: 14.3991ms +0ms  oclif:perf   @oclif/plugin-warn-if-update-available: 14.3733ms +0ms  oclif:perf   @oclif/plugin-which: 14.1629ms +0ms  oclif:perf   @salesforce/plugin-apex: 13.9885ms +0ms  oclif:perf   @salesforce/plugin-auth: 13.6895ms +0ms  oclif:perf   @salesforce/plugin-deploy-retrieve: 13.6353ms +0ms  oclif:perf   @salesforce/plugin-limits: 13.1123ms +0ms  oclif:perf   @salesforce/plugin-packaging: 12.9777ms +0ms  oclif:perf   @salesforce/plugin-info: 12.7787ms +0ms  oclif:perf   @salesforce/plugin-marketplace: 12.1542ms +0ms  oclif:perf   @salesforce/plugin-source: 11.9480ms +0ms  oclif:perf   @salesforce/plugin-schema: 11.7775ms +0ms  oclif:perf   @salesforce/plugin-settings: 11.4785ms +0ms  oclif:perf   @salesforce/plugin-templates: 11.4225ms +0ms  oclif:perf   @salesforce/plugin-sobject: 11.3670ms +0ms  oclif:perf   root: 11.2781ms +0ms  oclif:perf   @salesforce/plugin-user: 10.8521ms +0ms  oclif:perf   @salesforce/plugin-telemetry: 10.5724ms +1ms  oclif:perf   @salesforce/plugin-trust: 10.4463ms +0ms  oclif:perf   @oclif/plugin-plugins: 2.0135ms +0ms  oclif:perf   @oclif/plugin-help: 1.9039ms +0ms  oclif:perf Hook Run Times: +0ms  oclif:perf   init: +0ms  oclif:perf     total: 37.4624ms +0ms  oclif:perf     oclif-hello-world(./dist/hooks/init/init): 7.9818ms +0ms  oclif:perf     @oclif/plugin-warn-if-update-available(./lib/hooks/init/check-update): 37.1145ms +0ms  oclif:perf     @salesforce/plugin-settings(./lib/hooks/init/load_config_meta): 29.3073ms +0ms  oclif:perf     @oclif/plugin-update(./dist/hooks/init.js): 33.1767ms +0ms  oclif:perf   prerun: +0ms  oclif:perf     total: 260.5702ms +0ms  oclif:perf     @salesforce/cli(./dist/hooks/prerun): 2.3582ms +0ms  oclif:perf     @salesforce/plugin-telemetry(./lib/hooks/telemetryPrerun.js): 260.2634ms +0ms  oclif:perf   preparse: +0ms  oclif:perf     total: 0.5351ms +0ms  oclif:perf     @salesforce/cli(/dist/hooks/preparse): 0.5045ms +0ms  oclif:perf   postrun: +0ms  oclif:perf     total: 0.3507ms +0ms  oclif:perf Command Load Time: 0.7478ms +0ms  oclif:perf Command Run Time: 264.2587ms +0ms
You can also access these metrics programmatically like so:
const {Performance, flush, handle, run, settings} = await import('@oclif/core')settings.performanceEnabled = trueawait run(process.argv.slice(2))  .catch(async (error) => handle(error))  .finally(async () => {    console.log('Performance', Performance.oclifPerf)    await flush()  })
Using Performance for your code​
You can also use the Performance class to capture performance metrics on your own code base.
To capture performance metrics for a block of code, you need to create a new marker using Performance.mark. You then need to call the .stop method the marker to finish timing that block of code.
Here's a brief example:
import {Performance} from '@oclif/core'// Create a new marker.// First argument is the owner of the marker (This allows Performance to be able to distinguish the origin of each marker)// Second argument is the name of the maker. Naming convention that oclif uses internally is <module>.<method>#scope. You are free, however, to name these however you like.const marker = Performance.mark('my-plugin', 'hello.run')// do things that take a while.// Add details to the marker that you might want to access latermarker?.addDetails({from: flags.from, person: args.person})// Stop the marker. This will capture the amount of time between the creation of the marker and the stopping of the marker.marker?.stop()
And a more thorough example:
// ./src/commands/hello/index.tsimport {Args, Command, Flags, Performance} from '@oclif/core'export default class Hello extends Command {  static args = {    person: Args.string({description: 'Person to say hello to', required: true}),  }  static flags = {    from: Flags.string({char: 'f', description: 'Who is saying hello', required: true}),  }  async run(): Promise<void> {    const {args, flags} = await this.parse(Hello)    const marker = Performance.mark('my-plugin', 'hello.run')    await new Promise((resolve) => {      setTimeout(resolve, 1000)    })    marker?.addDetails({from: flags.from, person: args.person})    marker?.stop()    this.log(`hello ${args.person} from ${flags.from}! (./src/commands/hello/index.ts)`)  }}
All the markers you create will be accessible on the static results property on Performance:
// bin/run.jsconst {Performance, flush, handle, run, settings} = await import('@oclif/core')settings.performanceEnabled = trueawait run(process.argv.slice(2))  .catch(async (error) => handle(error))  .finally(async () => {    console.log('Results', Performance.results)    await flush()  })
❯ bin/run.js hello reader --from oclifhello reader from oclif! (./src/commands/hello/index.ts)Results Map(1) {  'my-plugin' => [    {      details: {        from: oclif,        person: reader      },      duration: 1003.4971249999999,      method: 'run',      module: 'hello',      name: 'hello.run',      scope: undefined    }  ]}Edit this pageLast updated on Dec 20, 2024 by Mike DonnalleyPreviousHelp ClassesNextCommand ExecutionHow to EnableAccessing oclif-specific performance metricsUsing Performance for your code\n\n\n\nIntroducing `oclif init` commandApril 10, 2024 · 2 min readThanks to the contribution of @joshcanhelp we released a new command for the oclif CLI called oclif init in version 4.8.0
The oclif init command allows you to initialize oclif in an existing project directory by adding the bare minimum requirements: a few pieces of configuration, bin scripts, and a couple of dependencies (@oclif/core and ts-node). This is slightly different from oclif generate, which will create an entirely new oclif project based on our templates.
oclif init will add the following:

bin scripts: bin/run.js, bin/run.cmd, bin/dev.js, and bin/dev.cmd
oclif section to package.json with bin, dirname, commands, and topicSeparator set (See Configuring Your CLI for more)
@oclif/core to dependencies in your package.json (if it's not already there)
ts-node to devDependencies in your package.json (if it's not already there)

Once you've initialized oclif, you can use the bin scripts to execute your CLI. You can also use the other oclif commands like oclif generate command and oclif generate hook to start adding new functionality.

❯ oclif init --helpInitialize a new oclif CLIUSAGE  $ oclif init [--bin <value>] [--module-type ESM|CommonJS] [--package-manager npm|yarn|pnpm] [--topic-separator    colons|spaces] [-d <value>] [-y]FLAGS  -d, --output-dir=<value>        Directory to initialize the CLI in.  -y, --yes                       Use defaults for all prompts. Individual flags will override defaults.      --bin=<value>               Supply answer for prompt: Command bin name the CLI will export      --module-type=<option>      Supply answer for prompt: Select a module type                                  <options: ESM|CommonJS>      --package-manager=<option>  Supply answer for prompt: Select a package manager                                  <options: npm|yarn|pnpm>      --topic-separator=<option>  Supply answer for prompt: Select a topic separator                                  <options: colons|spaces>DESCRIPTION  Initialize a new oclif CLI  This will add the necessary oclif bin files, add oclif config to package.json, and install @oclif/core and ts-node.EXAMPLES  Initialize a new CLI in the current directory    $ oclif init  Initialize a new CLI in a different directory    $ oclif init --output-dir "/path/to/existing/project"  Supply answers for specific prompts    $ oclif init --topic-separator colons --bin mycli
Hope you enjoy the new command! If you come across any issues or have any new ideas for this command, head over to the oclif/oclif repo and open a new issue.
All our best,
The oclif teamoclif Spring 2024 UpdateMarch 29, 2024 · 4 min readHello oclif developers! It's been a while since we last uploaded a blog - and a lot has happened.
We've been focusing on these high-level areas over the past couple of years:

Improving @oclif/core
ESM Support
Improving and revitalizing oclif.io
Re-engaging the oclif community

Improving @oclif/core​
Since we announced @oclif/core over three years ago, we've released two new major versions, each packed with lots of features that we're really excited about.
Here are some of these changes:

Full support for ESM and interoperability with CommonJS (more on this topic below).
Configurable command discovery strategies that give you more control over how commands are loaded at runtime. Check out the docs.
A new preparse hook that allows you to manipulate the provided arguments before they're parsed. Salesforce used this hook to implement a neat --flags-dir feature that translates local files into flags.
A new Performance class that you can use to track performance inside of @oclif/core and your own CLI or plugin. Check out the docs.
A new flag type, Flags.option, that lets you define a flag with a preset list of options. Typescript then uses the options to infer the flag's type.
Flags now have a relationship property that allows you to define more complex relationships between flags. Check out the flags docs for more information.
Flags now have a defaultHelp property that allows you to set the human readable default value in the command help. This property is useful when your flag's parse method returns a complex type, such as an object or a class. Check out the flags docs for more.
Commands now have a hiddenAliases property that allows you to define aliases that you want to hide from the user. The property is super helpful when you're trying to wean users off a deprecated command.
You can now use bun or tsx as dev runtimes (as opposed to node or ts-node).
A command's usage, args, and flags are now shown whenever a user forgets to provide a required arg or flag, or when they provided a non-existent flag.

If you need help migrating to the latest version, head over to core's README which has links to the migration guides. Feel free to open a new discussion if you need more hands-on help from us or the community.
ESM Support​
Version 3 of @oclif/core introduced full support for developing ESM plugins and CLIs. It also offered full support for interoperability between CommonJS and ESM plugins.
Put more simply, you can now migrate your CLI to ESM while keeping individual plugins in CommonJS (or vice versa). The upgrade path is now much simpler for you. You also don't need to worry about any community plugins that have migrated to ESM before you did (such as all the @oclif plugins) or are staunchly sticking with CommonJS for the foreseeable future.
Read more about this topic here.
Improving and Revitalizing oclif.io​
Another area of focus for us has been improving our documentation site, oclif.io.
While improving the quality and accuracy of the documentation was our priority, we also took the time to upgrade to the latest version of docusaurus. This new version gave our site a much-needed facelift, as well as cool new features such as dark mode and announcements.
If you have any feedback or are running into issues, we want to hear about it. Just create an issue in the oclif.io repo.
Re-engaging the oclif Community​
Lastly, our biggest priority at the moment is to re-engage the oclif community. We understand how frustrating it has been over the years to see your issues and pull requests go unacknowledged. We apologize for not prioritizing the community, and are earnestly trying to make sure that every issue and pull request gets the attention it deserves going forward.
We also opened up GitHub discussions for @oclif/core and the oclif CLI, where you can now post your questions or ideas. We hope you take advantage of them, we love hearing from you!
One last thing: we intend to publicly post our roadmap so you have more visibility into what we're working on. Stay tuned!
All our best,
The oclif teamAnnouncing oclif v2!January 12, 2022 · 5 min readHello and happy new year! It's our great pleasure to announce that we have released oclif v2, which uses the new @oclif/core library! 🎉
oclif v2 includes many changes that improve the experience of both creating and using an oclif CLI.
Going forward, we don't plan to make any updates to oclif v1 and its corresponding libraries, except for critical security fixes. See the compatibility matrix for a list of these libraries. In order to give developers time to migrate from v1 to v2, we're not completely dropping support yet. But at some point in the future we'll archive the v1 repositories and deprecate their versions on npm.
What’s changing?​
Repository Changes​
All repositories under the oclif org now use main as their primary branch and oclif-v1 as the legacy branch. The main  branch corresponds to oclif v2 and the oclif-v1 branch to oclif v1. If you find any repos that don’t have a main branch, you can safely assume that they're not used in oclif v2 and will be deprecated in the future.
Consolidating Tools & Libraries​
The oclif-dev CLI has now been incorporated into oclif. You now no longer need to install a separate package to manage your entire CLI’s lifecycle.
The following libraries have been consolidated under @oclif/core and will be deprecated at some point in the future. Read the migration guide to learn how to update your CLI or plugin to use the new core library.

@oclif/command
@oclif/config
@oclif/error
@oclif/help
@oclif/parser

No more single vs multi command CLIs​
There's only one "type" of oclif v2 CLI, but it can have as few or as many commands as a developer wants. As a result, there’s only one command to generate CLIs, oclif generate, as opposed to the old oclif single and oclif multi commands.
Node > 12​
To ensure oclif CLIs are as secure as possible, all v2 libraries and plugins support only Node 12 or higher as of now. Going forward, they'll support only Node Maintenance or higher, as defined by Node's release schedule here: https://nodejs.org/en/about/releases/.
What’s new?​
New example CLI​
oclif-hello-world is our new example repo. This is also the repo that's used as a template when running oclif generate to create a new CLI. This repo will always be able to be referenced as an example of what an oclif v2 CLI should look like.
Spaced commands​
oclif CLIs can now use spaces, instead of colons, to separate topics and subcommands. To enable this feature, simply add “topicSeparator": " " to the oclif config in your package.json. See an example in our example repo.
// Old commands that use :$ mycli do:something
// New spaced commands$ mycli do something

Note: Spaced commands are backwards compatible. So if you enable spaced commands for your CLI, users will still be able to use : as a separator. This ensures that any existing scripts don't break.

New Help Output​
We’ve revamped the way command help is outputted to the terminal, making it both easier to implement and easier to read. See the difference between the old help output on the left and the new help output on the right in the screenshots below.
oclif v1oclif v2
Notice that there are new sections for flags and global flags, examples are displayed with better spacing, and there is a section at the bottom called Configuration Variables. This Configuration Variables section is not part of the new help by default. But we've added support for custom help sections, which is what the sf CLI uses to create the new section.
Async Command Parsing​
We’ve also improved the performance of new CLIs by rewriting how commands are parsed on initialization. The new parser is asynchronous, which makes CLIs with a lot of commands or installed  plugins much faster.
What’s coming next?​
Part of our charter for the release of oclif v2 includes improving our engagement with the oclif community. We know that over the past couple of years we’ve reduced our involvement, and a lot of issues and PRs have languished in limbo. Hopefully you’ve already seen increased activity and responses from oclif maintainers recently, but if you haven’t, please don’t hesitate to ping us by tagging @admins in oclif repos.
We also want to start interviewing members of the oclif community to acquire feedback and prioritize the features and fixes you deem most important!
Best,
The oclif team

Reference material​
Migration Guide​
This guide explains how to upgrade a CLI or plugin from the old oclif v1 libraries to the new @oclif/core library that oclif v2 uses.
https://github.com/oclif/core/blob/main/MIGRATION.md
Compatibility Matrix​
The following matrix shows how the v1 libraries and plugins relate to the new v2 ones. Use this matrix as a guide to know what to drop and which versions to switch when upgrading your plugins and CLIs to v2.
oclif "v1"oclif "v2"Utility CLIsoclif@<2@oclif/dev-cli@<2oclif@>=2Main packages@oclif/command@oclif/config@oclif/errors@oclif/parser@oclif/plugin-help@oclif/core@>=1Node LTSNode v8-14Node v12+ (at time of writing)TypeScripttypescript@<4typescript@>=4Main plugins@oclif/plugin-autocomplete@<1@oclif/plugin-commands@<2@oclif/plugin-help@<4@oclif/plugin-not-found@<2@oclif/plugin-plugins@<2@oclif/plugin-update@<2plugin-warn-if-update-available@<2plugin-which@<2@oclif/plugin-autocomplete@>=1@oclif/plugin-commands@>=2@oclif/plugin-help@>=4@oclif/plugin-not-found@>=2@oclif/plugin-plugins@>=2@oclif/plugin-update@>=2@oclif/plugin-warn-if-update-available@>=2@oclif/plugin-which@>=2Introducing @oclif/coreMarch 1, 2021 · 3 min readGreetings!
We hope this blog post finds you well.
Introducing...​
We are excited to announce the next iteration of the oclif project today: @oclif/core.
We have learned a lot in the last three years of developing oclif, developing on oclif and supporting millions of command runs a day via Heroku and Salesforce CLIs.
@oclif/core ("Core") simplifies the oclif development experience and introduces highly requested new features.
Core combines the essential oclif packages into one "core" package, aptly named @oclif/core.
Core also introduces:

A default command option
Colon or space command syntax
Async command parsing
Command piping to arguments

With the introduction of default command functionality, Core simplifies the oclif project and removes the notion of single or multi command CLIs. Core CLIs can have 1 or many commands.
Along with Core, we moved the oclif-dev CLI into the oclif CLI creating a single "utility" CLI. This CLI also introduces a new AWS S3 compatible publishing scheme.
What to expect in the near future​
Core is in pre-release beta and being actively developed for new internal Salesforce CLIs.
Much documentation needs to be written in the coming months including migration paths. Migration onto Core should be as painless as possible with many exports remaining entirely unchanged. Look for forthcoming blog posts and documentation on oclif.io.
Early this summer, tentively June 1, we will release Core v1. Core's release will coincide with major bumps to many other oclif plugin packages. See the compatibility matrix below.
At Core's v1 release, the current "main" oclif packages (namely: command, config, errors & parser) will go into maintenance mode until Jan 2022. They will receive only bug and security fixes and they remain compatible with current versions of the oclif and oclif-dev CLIs. Afterwhich, they will be archived.
Companioning Core, the next major release of the oclif CLI (literally oclif@2) will generate Core CLIs.
Going forward​
We are excited to release Core! We invite you to poke around the Core repo. It may appear to be a big change but Core keeps what you already enjoy about oclif while reducing development complexity, project dependencies, package coupling and bundle size and introduces many requested features previously too prickly to weave into the current oclif architecture.
Best,
The oclif team
Reference: Compatibility matrix​
oclif "v1"oclif "Core"Utility CLIsoclif@<2@oclif/dev-cli@<2oclif@>=2Main packages@oclif/core@<2@oclif/config@<2@oclif/errors@<2@oclif/parser@<4@oclif/plugin-help@<4@oclif/core@>=1Node LTSNode v8-14Node v12+TypeScripttypescript@<4typescript@>=4Main plugins@oclif/plugin-autocomplete@<1@oclif/plugin-commands@<2@oclif/plugin-help@<4@oclif/plugin-not-found@<2@oclif/plugin-plugins@<2@oclif/plugin-update@<2plugin-warn-if-update-available@<2plugin-which@<2@oclif/plugin-autocomplete@>=2@oclif/plugin-commands@>=2@oclif/plugin-help@>=4@oclif/plugin-not-found@>=2@oclif/plugin-plugins@>=2@oclif/plugin-update@>=2@oclif/plugin-warn-if-update-available@>=2@oclif/plugin-which@>=2oclif Summer 2020 UpdateAugust 26, 2020 · 2 min readHello oclif developers! We hope you are all doing well.
Earlier this year, we started our planning for oclifconf v2 and, like all conference, had to change course. We opted not to hold a virtual conference, however, we wanted to take some time to highlight a few oclif features shipped this year.
Feature: Help templating​
One of the most requested features, help templating enables oclif developers to customize the help output for their CLI.
Read the announcement.
Feature: Custom error delegation​
This feature both improved how oclif throws and handles errors and allows oclif developers to overwrite or interject in oclif’s error handling.
Read the announcement.
Feature: postrun hooks​
We have added a new lifecycle event postrun. Your CLI can now run a hook after a command has ran.
See our hook documentation.
Feature: Root index command​
Previously, oclif would display CLI help if only the binary name with no command ID was invoked, oclif now supports a "root index" command. If present, a command defined at src/commands/index.ts will be run if no command ID is found.
1 million weekly downloads​
While exact oclif usage metrics are hard to pin down, we use npm download statistics of oclif packages as a rough approximation. Earlier this year, oclif's command package hit 1 million weekly downloads for the first time!
This year has been presented its challenges on everyone. We want to thank you, oclif developers, whom have taken the time to use and improve the oclif project. We look forward to seeing you all - in person - in the future!
All our best,
The oclif teamPretty Printable ErrorsJuly 1, 2020 · One min readOften CLIs are used as handy tools and when things go wrong it’s useful to have additional context. In oclif we have added a couple of additional properties that can show extra context to the users when an error is displayed. The code, ref and suggestions will now be displayed if they are included. This will work with an existing oclif CLI by adding the latest @oclif/errors and @oclif/core to the CLI's package.json dependencies.
For example, using this.error with the additional properties:
class TestError extends Command {  async run() {    this.error("An error has occurred!", {      code: "OCLIF_ERR",      ref: "https://oclif.io/docs/commands#thiserrormessage-string--error-options-code-string-exit-number",      suggestions: ["Use these extra properties to provide additional context"],    })  }}
would result with the following output:
›   Error: An error has occurred!›   Code: OCLIF_ERR›   Try this: Use these extra properties to provide additional context›   Reference: https://oclif.io/docs/commands#thiserrormessage-string--error-options-code-string-exit-number
If these properties are not provided then nothing changes and the CLI will continue to display the single error message output as it did before. Additionally, as part of this exercise we’ve added documentation around Error Handling in oclif which should come in handy if the need arises to extend oclif’s default handling of errors.Customizing Help in oclifMay 5, 2020 · 2 min readOut of the box oclif provides a great help experience for CLIs.
But what if, as an oclif developer, you want to customize some or all of the output?
You can now customize your CLI's help output by implementing the HelpBase abstract class.
Getting started with custom help​
If you have not done so yet, update @oclif/core.
$ yarn add --latest @oclif/core
To get started, first define the filepath to your help class in oclif's config in package.json. This is a relative path to the help class, without a file extension.
For this example, the help class will be created in a file at "[project root]/src/help.ts".
{  // ...  "oclif": {    "helpClass": "./lib/help"    // ...  }  // ...}
From here there are two paths, implement the HelpBase abstract class yourself or overwrite the parts of the default Help class you want to customize (ex: how command usage is displayed). We recommend the latter approach but cover both in the new Help Classes docs.
Separating TOPICS & COMMANDS in the new default Help class​
Previously, topics and child commands were listed in help output under a single list heading called "COMMANDS". But we found this can be slightly confusing. Some topics are commands also (a.k.a. topic-commands) while others are simply organizational namespacing (and when ran just show their help).
The new default Help class splits the list of children into distinct lists of "TOPICS" and "COMMANDS", with the possibility of an item appearing in both if it a topic-command. This makes it clearer what is expected to be ran - "COMMANDS" - and what is providing structure - "TOPICS" - when looking at the help output.
VERSION  plugin-help-example/0.0.0 darwin-x64 node-v12.12.0USAGE  $ plugin-help-example [COMMAND]TOPICS  topic  this is a topic and has child topics or commandsCOMMANDS  hello  describe the command here  help   display help for plugin-help-example
We look forward to seeing what custom help features you implement in your oclif CLIs with this new feature!oclif TSLint to ESLint MigrationDecember 5, 2019 · 3 min readBack in February of this year, plans were announced to deprecate TSLint in favor of ESLint. TSLint's goal has become to work toward a “unified developer experience” by supporting ESLint development going forward.
What has changed in oclif​
To keep inline with the community, oclif has transitioned to ESLint for all our core libraries as well as all our official plugins.
Starting in v1.15.x, oclif will now optionally generate projects with ESLint for both TypeScript and JavaScript CLI’s.
ESLint does require Node to be on stable LTS version, at the time of writing, Node 8.10.x, Node 10.13.x & Node 12.x.x.
How does this affect you​
Existing CLI’s are unchanged, but any newly generated CLI's will only give the option of using ESLint. If you are running tslint in your CLI, we recommend you switch to ESLint as well.
In migrating our projects we took the following steps (for an example of these changes see this pull request).


Install eslint
$ yarn add eslint eslint-config-oclif eslint-config-oclif-typescript --dev


Add eslint related files


$ echo '{  "extends": [    "oclif",    "oclif-typescript"  ],  "rules": {  }}' > .eslintrc


Remove tslint and related packages
$ yarn remove @oclif/tslint tslint


Remove tslint related configuration files
$ rm tslint.json


Change lint script in our package.json from something like:
"lint": "tsc -p test --noEmit && tslint -p test -t stylish"
to
"lint": "eslint . --ext .ts --config .eslintrc"


To preserve the test compile (tsc -p test --noEmit) we also made the following updates to our scripts:
"pretest": "tsc -p test --noEmit"
In some cases we had our posttest duplicating the same steps as our lint script so it’s cleaner to have it reference the lint job directly with:
"posttest": "yarn lint"

Run yarn lint --fix. This attempts to auto-fix any linting violations automatically. In the case an auto-fix isn’t available it should be fixed manually or ignored (see the eslint configuration doc for more information)
Do a search in the codebase for tslint and remove any unnecessary tslint disabling comments, like:

/* tslint:disable:object-literal-sort-keys */
If you are on a version of Node that is not supported by ESLint, you will also need to update your Node engine. ESLint supports Node 8, 10, and 12 so you should upgrade to the most recent Node version compatible with your CLI and also supported by ESLint (see ESLint's Installation and Usage instructions).
When will this take effect​
These changes have taken effect in oclif v1.15.1. When you generate a new CLI or plugin it will now contain configuration for ESLint instead of TSLint.oclif's Current Node SupportOctober 31, 2019 · 3 min readTo maintain a healthy project trajectory, oclif follows and supports Node Active LTS release, currently Node 10 & Node 12. This means ensuring that oclif continues to play nice with coming Active LTS Node versions and other packages in the ecosystem. Moving forward also means leaving older versions behind. Starting in 2020, Node will stop maintaining Node 8 and it is our intent at that time to also follow suit. Let’s take a look at a few ways we will be supporting these changes.
CI Environments​
CLIs created with the oclif cli going forward will be generated with a CircleCI configuration with Node 10 & 12 and an Appveyor configuration using Node 10. We have also added Node latest to CircleCi to be an early warning detection against coming Node changes (Node latest is managed by CircleCI).
We have already updated every oclif repo's CI configs to reflect this.
If your existing CLI uses either Appveyor or CircleCI you can update your config files also, like so:
.circleci/config.yml​
Your CircleCI config should contain a node-latest job, aliased as test. From this, there should be two extensions of this job for the Active LTS Node versions, Node 10 and Node 12.
  node-10:    <<: *node-latest    docker:      - image: node:10  node-12:    <<: *node-latest    docker:      - image: node:12
Notice that these declarations only change the Docker Node images used to run that job.
Additionally, the jobs listed within workflows must also be updated to reflect our changes in configuration:
    jobs:      - node-latest      - node-10      - node-12
appveyor.yml​
For appveyor we are currently only testing the oldest Active LTS Node version, Node 10. Update the nodejs_version proppert in your appveyor.yml file to reflect this.
environment:  nodejs_version: "10"
Deprecating Node 8 & Updating packge.json engines​
In Jan 2020, Node will end its Node 8 maintenance. We will follow suit by setting the package.json engine property in oclif packages to >=10 and bumping the package's major versions.
Depending on how you ship your CLI you may wish to also bump the engines version in your CLI's package.json. You can read more about the implications of the engines property configuration in the npm documentation.
Also consider distributing your CLI with its own Node version.
Packaged Node Version​
When using dev-cli to pack your CLI it will use the Node version as specified in your package.json under the oclif.update.node.version property. This value should reflect an Active LTS Node version (dev-cli does not currently enforce versions).
Supporting the future​
As a community we may discover bumps along the way as we upgrade. If you notice something related to oclif please feel free to open an issue or submit a pull request under the relevant oclif package within the org.
We look forward to using the latest from Node and the community and keeping oclif healthy along the way.oclifconf 2019: A RecapSeptember 16, 2019 · 4 min readIn May, Heroku and Salesforce Open Source organized oclifconf, a conference for developers & product managers building CLI tools on top of the open source oclif framework. The speakers came from various tech companies, such as Adobe, Netlify, and Apollo, who have already built amazing CLI experiences. The topics covered everything from the incredible capabilities oclif has unlocked, to the community-built plugins extending its functionality, and even what the behavior of an adaptive CLI tool might look like.
Below is a listing of all of the talks from the event, along with a short summary. Enjoy!
The future of oclif by Jeff Dickey​

In its relatively short lifetime, oclif has already inspired many developers and companies to adopt its framework as a means for implementing their own command-line tooling. In this talk, Jeff Dickey, an oclif founding team member, recaps the project's history and inspiration. He also looks towards the future and outlines some features and improvements that the tool could adapt. This isn't so much a definitive roadmap of where oclif is headed, but rather, a call to inspiration for developers eager to contribute! And if you are interested in contributing, check out the open issues in the oclif GitHub repo and come say "Hello!" on Spectrum Chat.
Open Source Citizenship by Josh Simmons​

When it comes to open source, it's more than just individuals now. More and more frequently, large corporations are contributing to projects by donating to contributors, sponsoring events, or upstreaming contributions. But keeping open source projects and communities healthy requires more than just money and brainpower. Josh Simmons surveyed multiple open source communities and relays his findings as to what help maintainers and contributors actually need in this talk.
Building an enterprise-grade CLI with oclif by Thomas Dvornik​

Security and performance are all about trust. While oclif is an extremely extensible framework for building CLI tooling, there are additional requirements to fulfill for enterprise businesses to adopt it that might not be necessary for individual developers. Thomas Dvornik outlines what he and his colleagues at Salesforce have implemented as plugins to oclif to satisfy these needs, including encrypted OAuth, plugin signing, lazy loading dependencies, synchronizing weekly releases and deprecations across dozens of repositories, and establishing cross-team coding and documentation standards.
How Adobe I/O built an extensible CLI with oclif by Jesse MacFadyen​

Perhaps oclif's most appealing feature is its support for plugins. In Cordova's case, they've created a sophisticated telemetry system that helps Adobe developers see which commands users are using--and reports on which ones are erroring out. By embedding a feedback system into the tool, users are even able to quickly send their suggestions to a form, without ever leaving the terminal. Jesse MacFadyen demonstrates how oclif's plugin system can work beyond simply executing commands.
Integrating oclif with GraphQL and Apollo by Evans Hauser​

For Evans Hauser and the team at Apollo, oclif is best thought of as "React for the CLI." As a client paired with a strongly-typed API contract to a server, it can deliver structured and consistent commands to retrieve external data. What better mechanism to use for this transfer than GraphQL, a framework which empowers the client to ask precisely for the data it needs, and nothing more?
Adaptive Intent-based CLI State Machines by Shawn Wang​

In designing oclif, Jeff Dickey wrote out 12 CLI factors to keep in mind. In this talk, Shawn Wang outlines a 13th: state. State is hard, because it depends on context, and context depends on understanding what a user intends to do, not what they are asking. Shawn is working towards enabling oclif to better understand the commands a user has entered, so that it can predict and interpret future commands that might be entered next. This would enable CLI tools to not just interpret a users' commands, but to also interpret their intent.\n\nIntroducing `oclif init` commandApril 10, 2024 · 2 min readThanks to the contribution of @joshcanhelp we released a new command for the oclif CLI called oclif init in version 4.8.0
The oclif init command allows you to initialize oclif in an existing project directory by adding the bare minimum requirements: a few pieces of configuration, bin scripts, and a couple of dependencies (@oclif/core and ts-node). This is slightly different from oclif generate, which will create an entirely new oclif project based on our templates.
oclif init will add the following:

bin scripts: bin/run.js, bin/run.cmd, bin/dev.js, and bin/dev.cmd
oclif section to package.json with bin, dirname, commands, and topicSeparator set (See Configuring Your CLI for more)
@oclif/core to dependencies in your package.json (if it's not already there)
ts-node to devDependencies in your package.json (if it's not already there)

Once you've initialized oclif, you can use the bin scripts to execute your CLI. You can also use the other oclif commands like oclif generate command and oclif generate hook to start adding new functionality.

❯ oclif init --helpInitialize a new oclif CLIUSAGE  $ oclif init [--bin <value>] [--module-type ESM|CommonJS] [--package-manager npm|yarn|pnpm] [--topic-separator    colons|spaces] [-d <value>] [-y]FLAGS  -d, --output-dir=<value>        Directory to initialize the CLI in.  -y, --yes                       Use defaults for all prompts. Individual flags will override defaults.      --bin=<value>               Supply answer for prompt: Command bin name the CLI will export      --module-type=<option>      Supply answer for prompt: Select a module type                                  <options: ESM|CommonJS>      --package-manager=<option>  Supply answer for prompt: Select a package manager                                  <options: npm|yarn|pnpm>      --topic-separator=<option>  Supply answer for prompt: Select a topic separator                                  <options: colons|spaces>DESCRIPTION  Initialize a new oclif CLI  This will add the necessary oclif bin files, add oclif config to package.json, and install @oclif/core and ts-node.EXAMPLES  Initialize a new CLI in the current directory    $ oclif init  Initialize a new CLI in a different directory    $ oclif init --output-dir "/path/to/existing/project"  Supply answers for specific prompts    $ oclif init --topic-separator colons --bin mycli
Hope you enjoy the new command! If you come across any issues or have any new ideas for this command, head over to the oclif/oclif repo and open a new issue.
All our best,
The oclif teamoclif Spring 2024 UpdateMarch 29, 2024 · 4 min readHello oclif developers! It's been a while since we last uploaded a blog - and a lot has happened.
We've been focusing on these high-level areas over the past couple of years:

Improving @oclif/core
ESM Support
Improving and revitalizing oclif.io
Re-engaging the oclif community

Improving @oclif/core​
Since we announced @oclif/core over three years ago, we've released two new major versions, each packed with lots of features that we're really excited about.
Here are some of these changes:

Full support for ESM and interoperability with CommonJS (more on this topic below).
Configurable command discovery strategies that give you more control over how commands are loaded at runtime. Check out the docs.
A new preparse hook that allows you to manipulate the provided arguments before they're parsed. Salesforce used this hook to implement a neat --flags-dir feature that translates local files into flags.
A new Performance class that you can use to track performance inside of @oclif/core and your own CLI or plugin. Check out the docs.
A new flag type, Flags.option, that lets you define a flag with a preset list of options. Typescript then uses the options to infer the flag's type.
Flags now have a relationship property that allows you to define more complex relationships between flags. Check out the flags docs for more information.
Flags now have a defaultHelp property that allows you to set the human readable default value in the command help. This property is useful when your flag's parse method returns a complex type, such as an object or a class. Check out the flags docs for more.
Commands now have a hiddenAliases property that allows you to define aliases that you want to hide from the user. The property is super helpful when you're trying to wean users off a deprecated command.
You can now use bun or tsx as dev runtimes (as opposed to node or ts-node).
A command's usage, args, and flags are now shown whenever a user forgets to provide a required arg or flag, or when they provided a non-existent flag.

If you need help migrating to the latest version, head over to core's README which has links to the migration guides. Feel free to open a new discussion if you need more hands-on help from us or the community.
ESM Support​
Version 3 of @oclif/core introduced full support for developing ESM plugins and CLIs. It also offered full support for interoperability between CommonJS and ESM plugins.
Put more simply, you can now migrate your CLI to ESM while keeping individual plugins in CommonJS (or vice versa). The upgrade path is now much simpler for you. You also don't need to worry about any community plugins that have migrated to ESM before you did (such as all the @oclif plugins) or are staunchly sticking with CommonJS for the foreseeable future.
Read more about this topic here.
Improving and Revitalizing oclif.io​
Another area of focus for us has been improving our documentation site, oclif.io.
While improving the quality and accuracy of the documentation was our priority, we also took the time to upgrade to the latest version of docusaurus. This new version gave our site a much-needed facelift, as well as cool new features such as dark mode and announcements.
If you have any feedback or are running into issues, we want to hear about it. Just create an issue in the oclif.io repo.
Re-engaging the oclif Community​
Lastly, our biggest priority at the moment is to re-engage the oclif community. We understand how frustrating it has been over the years to see your issues and pull requests go unacknowledged. We apologize for not prioritizing the community, and are earnestly trying to make sure that every issue and pull request gets the attention it deserves going forward.
We also opened up GitHub discussions for @oclif/core and the oclif CLI, where you can now post your questions or ideas. We hope you take advantage of them, we love hearing from you!
One last thing: we intend to publicly post our roadmap so you have more visibility into what we're working on. Stay tuned!
All our best,
The oclif teamAnnouncing oclif v2!January 12, 2022 · 5 min readHello and happy new year! It's our great pleasure to announce that we have released oclif v2, which uses the new @oclif/core library! 🎉
oclif v2 includes many changes that improve the experience of both creating and using an oclif CLI.
Going forward, we don't plan to make any updates to oclif v1 and its corresponding libraries, except for critical security fixes. See the compatibility matrix for a list of these libraries. In order to give developers time to migrate from v1 to v2, we're not completely dropping support yet. But at some point in the future we'll archive the v1 repositories and deprecate their versions on npm.
What’s changing?​
Repository Changes​
All repositories under the oclif org now use main as their primary branch and oclif-v1 as the legacy branch. The main  branch corresponds to oclif v2 and the oclif-v1 branch to oclif v1. If you find any repos that don’t have a main branch, you can safely assume that they're not used in oclif v2 and will be deprecated in the future.
Consolidating Tools & Libraries​
The oclif-dev CLI has now been incorporated into oclif. You now no longer need to install a separate package to manage your entire CLI’s lifecycle.
The following libraries have been consolidated under @oclif/core and will be deprecated at some point in the future. Read the migration guide to learn how to update your CLI or plugin to use the new core library.

@oclif/command
@oclif/config
@oclif/error
@oclif/help
@oclif/parser

No more single vs multi command CLIs​
There's only one "type" of oclif v2 CLI, but it can have as few or as many commands as a developer wants. As a result, there’s only one command to generate CLIs, oclif generate, as opposed to the old oclif single and oclif multi commands.
Node > 12​
To ensure oclif CLIs are as secure as possible, all v2 libraries and plugins support only Node 12 or higher as of now. Going forward, they'll support only Node Maintenance or higher, as defined by Node's release schedule here: https://nodejs.org/en/about/releases/.
What’s new?​
New example CLI​
oclif-hello-world is our new example repo. This is also the repo that's used as a template when running oclif generate to create a new CLI. This repo will always be able to be referenced as an example of what an oclif v2 CLI should look like.
Spaced commands​
oclif CLIs can now use spaces, instead of colons, to separate topics and subcommands. To enable this feature, simply add “topicSeparator": " " to the oclif config in your package.json. See an example in our example repo.
// Old commands that use :$ mycli do:something
// New spaced commands$ mycli do something

Note: Spaced commands are backwards compatible. So if you enable spaced commands for your CLI, users will still be able to use : as a separator. This ensures that any existing scripts don't break.

New Help Output​
We’ve revamped the way command help is outputted to the terminal, making it both easier to implement and easier to read. See the difference between the old help output on the left and the new help output on the right in the screenshots below.
oclif v1oclif v2
Notice that there are new sections for flags and global flags, examples are displayed with better spacing, and there is a section at the bottom called Configuration Variables. This Configuration Variables section is not part of the new help by default. But we've added support for custom help sections, which is what the sf CLI uses to create the new section.
Async Command Parsing​
We’ve also improved the performance of new CLIs by rewriting how commands are parsed on initialization. The new parser is asynchronous, which makes CLIs with a lot of commands or installed  plugins much faster.
What’s coming next?​
Part of our charter for the release of oclif v2 includes improving our engagement with the oclif community. We know that over the past couple of years we’ve reduced our involvement, and a lot of issues and PRs have languished in limbo. Hopefully you’ve already seen increased activity and responses from oclif maintainers recently, but if you haven’t, please don’t hesitate to ping us by tagging @admins in oclif repos.
We also want to start interviewing members of the oclif community to acquire feedback and prioritize the features and fixes you deem most important!
Best,
The oclif team

Reference material​
Migration Guide​
This guide explains how to upgrade a CLI or plugin from the old oclif v1 libraries to the new @oclif/core library that oclif v2 uses.
https://github.com/oclif/core/blob/main/MIGRATION.md
Compatibility Matrix​
The following matrix shows how the v1 libraries and plugins relate to the new v2 ones. Use this matrix as a guide to know what to drop and which versions to switch when upgrading your plugins and CLIs to v2.
oclif "v1"oclif "v2"Utility CLIsoclif@<2@oclif/dev-cli@<2oclif@>=2Main packages@oclif/command@oclif/config@oclif/errors@oclif/parser@oclif/plugin-help@oclif/core@>=1Node LTSNode v8-14Node v12+ (at time of writing)TypeScripttypescript@<4typescript@>=4Main plugins@oclif/plugin-autocomplete@<1@oclif/plugin-commands@<2@oclif/plugin-help@<4@oclif/plugin-not-found@<2@oclif/plugin-plugins@<2@oclif/plugin-update@<2plugin-warn-if-update-available@<2plugin-which@<2@oclif/plugin-autocomplete@>=1@oclif/plugin-commands@>=2@oclif/plugin-help@>=4@oclif/plugin-not-found@>=2@oclif/plugin-plugins@>=2@oclif/plugin-update@>=2@oclif/plugin-warn-if-update-available@>=2@oclif/plugin-which@>=2Introducing @oclif/coreMarch 1, 2021 · 3 min readGreetings!
We hope this blog post finds you well.
Introducing...​
We are excited to announce the next iteration of the oclif project today: @oclif/core.
We have learned a lot in the last three years of developing oclif, developing on oclif and supporting millions of command runs a day via Heroku and Salesforce CLIs.
@oclif/core ("Core") simplifies the oclif development experience and introduces highly requested new features.
Core combines the essential oclif packages into one "core" package, aptly named @oclif/core.
Core also introduces:

A default command option
Colon or space command syntax
Async command parsing
Command piping to arguments

With the introduction of default command functionality, Core simplifies the oclif project and removes the notion of single or multi command CLIs. Core CLIs can have 1 or many commands.
Along with Core, we moved the oclif-dev CLI into the oclif CLI creating a single "utility" CLI. This CLI also introduces a new AWS S3 compatible publishing scheme.
What to expect in the near future​
Core is in pre-release beta and being actively developed for new internal Salesforce CLIs.
Much documentation needs to be written in the coming months including migration paths. Migration onto Core should be as painless as possible with many exports remaining entirely unchanged. Look for forthcoming blog posts and documentation on oclif.io.
Early this summer, tentively June 1, we will release Core v1. Core's release will coincide with major bumps to many other oclif plugin packages. See the compatibility matrix below.
At Core's v1 release, the current "main" oclif packages (namely: command, config, errors & parser) will go into maintenance mode until Jan 2022. They will receive only bug and security fixes and they remain compatible with current versions of the oclif and oclif-dev CLIs. Afterwhich, they will be archived.
Companioning Core, the next major release of the oclif CLI (literally oclif@2) will generate Core CLIs.
Going forward​
We are excited to release Core! We invite you to poke around the Core repo. It may appear to be a big change but Core keeps what you already enjoy about oclif while reducing development complexity, project dependencies, package coupling and bundle size and introduces many requested features previously too prickly to weave into the current oclif architecture.
Best,
The oclif team
Reference: Compatibility matrix​
oclif "v1"oclif "Core"Utility CLIsoclif@<2@oclif/dev-cli@<2oclif@>=2Main packages@oclif/core@<2@oclif/config@<2@oclif/errors@<2@oclif/parser@<4@oclif/plugin-help@<4@oclif/core@>=1Node LTSNode v8-14Node v12+TypeScripttypescript@<4typescript@>=4Main plugins@oclif/plugin-autocomplete@<1@oclif/plugin-commands@<2@oclif/plugin-help@<4@oclif/plugin-not-found@<2@oclif/plugin-plugins@<2@oclif/plugin-update@<2plugin-warn-if-update-available@<2plugin-which@<2@oclif/plugin-autocomplete@>=2@oclif/plugin-commands@>=2@oclif/plugin-help@>=4@oclif/plugin-not-found@>=2@oclif/plugin-plugins@>=2@oclif/plugin-update@>=2@oclif/plugin-warn-if-update-available@>=2@oclif/plugin-which@>=2oclif Summer 2020 UpdateAugust 26, 2020 · 2 min readHello oclif developers! We hope you are all doing well.
Earlier this year, we started our planning for oclifconf v2 and, like all conference, had to change course. We opted not to hold a virtual conference, however, we wanted to take some time to highlight a few oclif features shipped this year.
Feature: Help templating​
One of the most requested features, help templating enables oclif developers to customize the help output for their CLI.
Read the announcement.
Feature: Custom error delegation​
This feature both improved how oclif throws and handles errors and allows oclif developers to overwrite or interject in oclif’s error handling.
Read the announcement.
Feature: postrun hooks​
We have added a new lifecycle event postrun. Your CLI can now run a hook after a command has ran.
See our hook documentation.
Feature: Root index command​
Previously, oclif would display CLI help if only the binary name with no command ID was invoked, oclif now supports a "root index" command. If present, a command defined at src/commands/index.ts will be run if no command ID is found.
1 million weekly downloads​
While exact oclif usage metrics are hard to pin down, we use npm download statistics of oclif packages as a rough approximation. Earlier this year, oclif's command package hit 1 million weekly downloads for the first time!
This year has been presented its challenges on everyone. We want to thank you, oclif developers, whom have taken the time to use and improve the oclif project. We look forward to seeing you all - in person - in the future!
All our best,
The oclif teamPretty Printable ErrorsJuly 1, 2020 · One min readOften CLIs are used as handy tools and when things go wrong it’s useful to have additional context. In oclif we have added a couple of additional properties that can show extra context to the users when an error is displayed. The code, ref and suggestions will now be displayed if they are included. This will work with an existing oclif CLI by adding the latest @oclif/errors and @oclif/core to the CLI's package.json dependencies.
For example, using this.error with the additional properties:
class TestError extends Command {  async run() {    this.error("An error has occurred!", {      code: "OCLIF_ERR",      ref: "https://oclif.io/docs/commands#thiserrormessage-string--error-options-code-string-exit-number",      suggestions: ["Use these extra properties to provide additional context"],    })  }}
would result with the following output:
›   Error: An error has occurred!›   Code: OCLIF_ERR›   Try this: Use these extra properties to provide additional context›   Reference: https://oclif.io/docs/commands#thiserrormessage-string--error-options-code-string-exit-number
If these properties are not provided then nothing changes and the CLI will continue to display the single error message output as it did before. Additionally, as part of this exercise we’ve added documentation around Error Handling in oclif which should come in handy if the need arises to extend oclif’s default handling of errors.Customizing Help in oclifMay 5, 2020 · 2 min readOut of the box oclif provides a great help experience for CLIs.
But what if, as an oclif developer, you want to customize some or all of the output?
You can now customize your CLI's help output by implementing the HelpBase abstract class.
Getting started with custom help​
If you have not done so yet, update @oclif/core.
$ yarn add --latest @oclif/core
To get started, first define the filepath to your help class in oclif's config in package.json. This is a relative path to the help class, without a file extension.
For this example, the help class will be created in a file at "[project root]/src/help.ts".
{  // ...  "oclif": {    "helpClass": "./lib/help"    // ...  }  // ...}
From here there are two paths, implement the HelpBase abstract class yourself or overwrite the parts of the default Help class you want to customize (ex: how command usage is displayed). We recommend the latter approach but cover both in the new Help Classes docs.
Separating TOPICS & COMMANDS in the new default Help class​
Previously, topics and child commands were listed in help output under a single list heading called "COMMANDS". But we found this can be slightly confusing. Some topics are commands also (a.k.a. topic-commands) while others are simply organizational namespacing (and when ran just show their help).
The new default Help class splits the list of children into distinct lists of "TOPICS" and "COMMANDS", with the possibility of an item appearing in both if it a topic-command. This makes it clearer what is expected to be ran - "COMMANDS" - and what is providing structure - "TOPICS" - when looking at the help output.
VERSION  plugin-help-example/0.0.0 darwin-x64 node-v12.12.0USAGE  $ plugin-help-example [COMMAND]TOPICS  topic  this is a topic and has child topics or commandsCOMMANDS  hello  describe the command here  help   display help for plugin-help-example
We look forward to seeing what custom help features you implement in your oclif CLIs with this new feature!oclif TSLint to ESLint MigrationDecember 5, 2019 · 3 min readBack in February of this year, plans were announced to deprecate TSLint in favor of ESLint. TSLint's goal has become to work toward a “unified developer experience” by supporting ESLint development going forward.
What has changed in oclif​
To keep inline with the community, oclif has transitioned to ESLint for all our core libraries as well as all our official plugins.
Starting in v1.15.x, oclif will now optionally generate projects with ESLint for both TypeScript and JavaScript CLI’s.
ESLint does require Node to be on stable LTS version, at the time of writing, Node 8.10.x, Node 10.13.x & Node 12.x.x.
How does this affect you​
Existing CLI’s are unchanged, but any newly generated CLI's will only give the option of using ESLint. If you are running tslint in your CLI, we recommend you switch to ESLint as well.
In migrating our projects we took the following steps (for an example of these changes see this pull request).


Install eslint
$ yarn add eslint eslint-config-oclif eslint-config-oclif-typescript --dev


Add eslint related files


$ echo '{  "extends": [    "oclif",    "oclif-typescript"  ],  "rules": {  }}' > .eslintrc


Remove tslint and related packages
$ yarn remove @oclif/tslint tslint


Remove tslint related configuration files
$ rm tslint.json


Change lint script in our package.json from something like:
"lint": "tsc -p test --noEmit && tslint -p test -t stylish"
to
"lint": "eslint . --ext .ts --config .eslintrc"


To preserve the test compile (tsc -p test --noEmit) we also made the following updates to our scripts:
"pretest": "tsc -p test --noEmit"
In some cases we had our posttest duplicating the same steps as our lint script so it’s cleaner to have it reference the lint job directly with:
"posttest": "yarn lint"

Run yarn lint --fix. This attempts to auto-fix any linting violations automatically. In the case an auto-fix isn’t available it should be fixed manually or ignored (see the eslint configuration doc for more information)
Do a search in the codebase for tslint and remove any unnecessary tslint disabling comments, like:

/* tslint:disable:object-literal-sort-keys */
If you are on a version of Node that is not supported by ESLint, you will also need to update your Node engine. ESLint supports Node 8, 10, and 12 so you should upgrade to the most recent Node version compatible with your CLI and also supported by ESLint (see ESLint's Installation and Usage instructions).
When will this take effect​
These changes have taken effect in oclif v1.15.1. When you generate a new CLI or plugin it will now contain configuration for ESLint instead of TSLint.oclif's Current Node SupportOctober 31, 2019 · 3 min readTo maintain a healthy project trajectory, oclif follows and supports Node Active LTS release, currently Node 10 & Node 12. This means ensuring that oclif continues to play nice with coming Active LTS Node versions and other packages in the ecosystem. Moving forward also means leaving older versions behind. Starting in 2020, Node will stop maintaining Node 8 and it is our intent at that time to also follow suit. Let’s take a look at a few ways we will be supporting these changes.
CI Environments​
CLIs created with the oclif cli going forward will be generated with a CircleCI configuration with Node 10 & 12 and an Appveyor configuration using Node 10. We have also added Node latest to CircleCi to be an early warning detection against coming Node changes (Node latest is managed by CircleCI).
We have already updated every oclif repo's CI configs to reflect this.
If your existing CLI uses either Appveyor or CircleCI you can update your config files also, like so:
.circleci/config.yml​
Your CircleCI config should contain a node-latest job, aliased as test. From this, there should be two extensions of this job for the Active LTS Node versions, Node 10 and Node 12.
  node-10:    <<: *node-latest    docker:      - image: node:10  node-12:    <<: *node-latest    docker:      - image: node:12
Notice that these declarations only change the Docker Node images used to run that job.
Additionally, the jobs listed within workflows must also be updated to reflect our changes in configuration:
    jobs:      - node-latest      - node-10      - node-12
appveyor.yml​
For appveyor we are currently only testing the oldest Active LTS Node version, Node 10. Update the nodejs_version proppert in your appveyor.yml file to reflect this.
environment:  nodejs_version: "10"
Deprecating Node 8 & Updating packge.json engines​
In Jan 2020, Node will end its Node 8 maintenance. We will follow suit by setting the package.json engine property in oclif packages to >=10 and bumping the package's major versions.
Depending on how you ship your CLI you may wish to also bump the engines version in your CLI's package.json. You can read more about the implications of the engines property configuration in the npm documentation.
Also consider distributing your CLI with its own Node version.
Packaged Node Version​
When using dev-cli to pack your CLI it will use the Node version as specified in your package.json under the oclif.update.node.version property. This value should reflect an Active LTS Node version (dev-cli does not currently enforce versions).
Supporting the future​
As a community we may discover bumps along the way as we upgrade. If you notice something related to oclif please feel free to open an issue or submit a pull request under the relevant oclif package within the org.
We look forward to using the latest from Node and the community and keeping oclif healthy along the way.oclifconf 2019: A RecapSeptember 16, 2019 · 4 min readIn May, Heroku and Salesforce Open Source organized oclifconf, a conference for developers & product managers building CLI tools on top of the open source oclif framework. The speakers came from various tech companies, such as Adobe, Netlify, and Apollo, who have already built amazing CLI experiences. The topics covered everything from the incredible capabilities oclif has unlocked, to the community-built plugins extending its functionality, and even what the behavior of an adaptive CLI tool might look like.
Below is a listing of all of the talks from the event, along with a short summary. Enjoy!
The future of oclif by Jeff Dickey​

In its relatively short lifetime, oclif has already inspired many developers and companies to adopt its framework as a means for implementing their own command-line tooling. In this talk, Jeff Dickey, an oclif founding team member, recaps the project's history and inspiration. He also looks towards the future and outlines some features and improvements that the tool could adapt. This isn't so much a definitive roadmap of where oclif is headed, but rather, a call to inspiration for developers eager to contribute! And if you are interested in contributing, check out the open issues in the oclif GitHub repo and come say "Hello!" on Spectrum Chat.
Open Source Citizenship by Josh Simmons​

When it comes to open source, it's more than just individuals now. More and more frequently, large corporations are contributing to projects by donating to contributors, sponsoring events, or upstreaming contributions. But keeping open source projects and communities healthy requires more than just money and brainpower. Josh Simmons surveyed multiple open source communities and relays his findings as to what help maintainers and contributors actually need in this talk.
Building an enterprise-grade CLI with oclif by Thomas Dvornik​

Security and performance are all about trust. While oclif is an extremely extensible framework for building CLI tooling, there are additional requirements to fulfill for enterprise businesses to adopt it that might not be necessary for individual developers. Thomas Dvornik outlines what he and his colleagues at Salesforce have implemented as plugins to oclif to satisfy these needs, including encrypted OAuth, plugin signing, lazy loading dependencies, synchronizing weekly releases and deprecations across dozens of repositories, and establishing cross-team coding and documentation standards.
How Adobe I/O built an extensible CLI with oclif by Jesse MacFadyen​

Perhaps oclif's most appealing feature is its support for plugins. In Cordova's case, they've created a sophisticated telemetry system that helps Adobe developers see which commands users are using--and reports on which ones are erroring out. By embedding a feedback system into the tool, users are even able to quickly send their suggestions to a form, without ever leaving the terminal. Jesse MacFadyen demonstrates how oclif's plugin system can work beyond simply executing commands.
Integrating oclif with GraphQL and Apollo by Evans Hauser​

For Evans Hauser and the team at Apollo, oclif is best thought of as "React for the CLI." As a client paired with a strongly-typed API contract to a server, it can deliver structured and consistent commands to retrieve external data. What better mechanism to use for this transfer than GraphQL, a framework which empowers the client to ask precisely for the data it needs, and nothing more?
Adaptive Intent-based CLI State Machines by Shawn Wang​

In designing oclif, Jeff Dickey wrote out 12 CLI factors to keep in mind. In this talk, Shawn Wang outlines a 13th: state. State is hard, because it depends on context, and context depends on understanding what a user intends to do, not what they are asking. Shawn is working towards enabling oclif to better understand the commands a user has entered, so that it can predict and interpret future commands that might be entered next. This would enable CLI tools to not just interpret a users' commands, but to also interpret their intent.Older Entries\n\n\n\nIntroducing `oclif init` commandApril 10, 2024 · 2 min readThanks to the contribution of @joshcanhelp we released a new command for the oclif CLI called oclif init in version 4.8.0
The oclif init command allows you to initialize oclif in an existing project directory by adding the bare minimum requirements: a few pieces of configuration, bin scripts, and a couple of dependencies (@oclif/core and ts-node). This is slightly different from oclif generate, which will create an entirely new oclif project based on our templates.
oclif init will add the following:

bin scripts: bin/run.js, bin/run.cmd, bin/dev.js, and bin/dev.cmd
oclif section to package.json with bin, dirname, commands, and topicSeparator set (See Configuring Your CLI for more)
@oclif/core to dependencies in your package.json (if it's not already there)
ts-node to devDependencies in your package.json (if it's not already there)

Once you've initialized oclif, you can use the bin scripts to execute your CLI. You can also use the other oclif commands like oclif generate command and oclif generate hook to start adding new functionality.

❯ oclif init --helpInitialize a new oclif CLIUSAGE  $ oclif init [--bin <value>] [--module-type ESM|CommonJS] [--package-manager npm|yarn|pnpm] [--topic-separator    colons|spaces] [-d <value>] [-y]FLAGS  -d, --output-dir=<value>        Directory to initialize the CLI in.  -y, --yes                       Use defaults for all prompts. Individual flags will override defaults.      --bin=<value>               Supply answer for prompt: Command bin name the CLI will export      --module-type=<option>      Supply answer for prompt: Select a module type                                  <options: ESM|CommonJS>      --package-manager=<option>  Supply answer for prompt: Select a package manager                                  <options: npm|yarn|pnpm>      --topic-separator=<option>  Supply answer for prompt: Select a topic separator                                  <options: colons|spaces>DESCRIPTION  Initialize a new oclif CLI  This will add the necessary oclif bin files, add oclif config to package.json, and install @oclif/core and ts-node.EXAMPLES  Initialize a new CLI in the current directory    $ oclif init  Initialize a new CLI in a different directory    $ oclif init --output-dir "/path/to/existing/project"  Supply answers for specific prompts    $ oclif init --topic-separator colons --bin mycli
Hope you enjoy the new command! If you come across any issues or have any new ideas for this command, head over to the oclif/oclif repo and open a new issue.
All our best,
The oclif team\n\nIntroducing `oclif init` commandApril 10, 2024 · 2 min readThanks to the contribution of @joshcanhelp we released a new command for the oclif CLI called oclif init in version 4.8.0
The oclif init command allows you to initialize oclif in an existing project directory by adding the bare minimum requirements: a few pieces of configuration, bin scripts, and a couple of dependencies (@oclif/core and ts-node). This is slightly different from oclif generate, which will create an entirely new oclif project based on our templates.
oclif init will add the following:

bin scripts: bin/run.js, bin/run.cmd, bin/dev.js, and bin/dev.cmd
oclif section to package.json with bin, dirname, commands, and topicSeparator set (See Configuring Your CLI for more)
@oclif/core to dependencies in your package.json (if it's not already there)
ts-node to devDependencies in your package.json (if it's not already there)

Once you've initialized oclif, you can use the bin scripts to execute your CLI. You can also use the other oclif commands like oclif generate command and oclif generate hook to start adding new functionality.

❯ oclif init --helpInitialize a new oclif CLIUSAGE  $ oclif init [--bin <value>] [--module-type ESM|CommonJS] [--package-manager npm|yarn|pnpm] [--topic-separator    colons|spaces] [-d <value>] [-y]FLAGS  -d, --output-dir=<value>        Directory to initialize the CLI in.  -y, --yes                       Use defaults for all prompts. Individual flags will override defaults.      --bin=<value>               Supply answer for prompt: Command bin name the CLI will export      --module-type=<option>      Supply answer for prompt: Select a module type                                  <options: ESM|CommonJS>      --package-manager=<option>  Supply answer for prompt: Select a package manager                                  <options: npm|yarn|pnpm>      --topic-separator=<option>  Supply answer for prompt: Select a topic separator                                  <options: colons|spaces>DESCRIPTION  Initialize a new oclif CLI  This will add the necessary oclif bin files, add oclif config to package.json, and install @oclif/core and ts-node.EXAMPLES  Initialize a new CLI in the current directory    $ oclif init  Initialize a new CLI in a different directory    $ oclif init --output-dir "/path/to/existing/project"  Supply answers for specific prompts    $ oclif init --topic-separator colons --bin mycli
Hope you enjoy the new command! If you come across any issues or have any new ideas for this command, head over to the oclif/oclif repo and open a new issue.
All our best,
The oclif teamOlder Postoclif Spring 2024 Update\n\n\n\noclif Spring 2024 UpdateMarch 29, 2024 · 4 min readHello oclif developers! It's been a while since we last uploaded a blog - and a lot has happened.
We've been focusing on these high-level areas over the past couple of years:

Improving @oclif/core
ESM Support
Improving and revitalizing oclif.io
Re-engaging the oclif community

Improving @oclif/core​
Since we announced @oclif/core over three years ago, we've released two new major versions, each packed with lots of features that we're really excited about.
Here are some of these changes:

Full support for ESM and interoperability with CommonJS (more on this topic below).
Configurable command discovery strategies that give you more control over how commands are loaded at runtime. Check out the docs.
A new preparse hook that allows you to manipulate the provided arguments before they're parsed. Salesforce used this hook to implement a neat --flags-dir feature that translates local files into flags.
A new Performance class that you can use to track performance inside of @oclif/core and your own CLI or plugin. Check out the docs.
A new flag type, Flags.option, that lets you define a flag with a preset list of options. Typescript then uses the options to infer the flag's type.
Flags now have a relationship property that allows you to define more complex relationships between flags. Check out the flags docs for more information.
Flags now have a defaultHelp property that allows you to set the human readable default value in the command help. This property is useful when your flag's parse method returns a complex type, such as an object or a class. Check out the flags docs for more.
Commands now have a hiddenAliases property that allows you to define aliases that you want to hide from the user. The property is super helpful when you're trying to wean users off a deprecated command.
You can now use bun or tsx as dev runtimes (as opposed to node or ts-node).
A command's usage, args, and flags are now shown whenever a user forgets to provide a required arg or flag, or when they provided a non-existent flag.

If you need help migrating to the latest version, head over to core's README which has links to the migration guides. Feel free to open a new discussion if you need more hands-on help from us or the community.
ESM Support​
Version 3 of @oclif/core introduced full support for developing ESM plugins and CLIs. It also offered full support for interoperability between CommonJS and ESM plugins.
Put more simply, you can now migrate your CLI to ESM while keeping individual plugins in CommonJS (or vice versa). The upgrade path is now much simpler for you. You also don't need to worry about any community plugins that have migrated to ESM before you did (such as all the @oclif plugins) or are staunchly sticking with CommonJS for the foreseeable future.
Read more about this topic here.
Improving and Revitalizing oclif.io​
Another area of focus for us has been improving our documentation site, oclif.io.
While improving the quality and accuracy of the documentation was our priority, we also took the time to upgrade to the latest version of docusaurus. This new version gave our site a much-needed facelift, as well as cool new features such as dark mode and announcements.
If you have any feedback or are running into issues, we want to hear about it. Just create an issue in the oclif.io repo.
Re-engaging the oclif Community​
Lastly, our biggest priority at the moment is to re-engage the oclif community. We understand how frustrating it has been over the years to see your issues and pull requests go unacknowledged. We apologize for not prioritizing the community, and are earnestly trying to make sure that every issue and pull request gets the attention it deserves going forward.
We also opened up GitHub discussions for @oclif/core and the oclif CLI, where you can now post your questions or ideas. We hope you take advantage of them, we love hearing from you!
One last thing: we intend to publicly post our roadmap so you have more visibility into what we're working on. Stay tuned!
All our best,
The oclif team\n\noclif Spring 2024 UpdateMarch 29, 2024 · 4 min readHello oclif developers! It's been a while since we last uploaded a blog - and a lot has happened.
We've been focusing on these high-level areas over the past couple of years:

Improving @oclif/core
ESM Support
Improving and revitalizing oclif.io
Re-engaging the oclif community

Improving @oclif/core​
Since we announced @oclif/core over three years ago, we've released two new major versions, each packed with lots of features that we're really excited about.
Here are some of these changes:

Full support for ESM and interoperability with CommonJS (more on this topic below).
Configurable command discovery strategies that give you more control over how commands are loaded at runtime. Check out the docs.
A new preparse hook that allows you to manipulate the provided arguments before they're parsed. Salesforce used this hook to implement a neat --flags-dir feature that translates local files into flags.
A new Performance class that you can use to track performance inside of @oclif/core and your own CLI or plugin. Check out the docs.
A new flag type, Flags.option, that lets you define a flag with a preset list of options. Typescript then uses the options to infer the flag's type.
Flags now have a relationship property that allows you to define more complex relationships between flags. Check out the flags docs for more information.
Flags now have a defaultHelp property that allows you to set the human readable default value in the command help. This property is useful when your flag's parse method returns a complex type, such as an object or a class. Check out the flags docs for more.
Commands now have a hiddenAliases property that allows you to define aliases that you want to hide from the user. The property is super helpful when you're trying to wean users off a deprecated command.
You can now use bun or tsx as dev runtimes (as opposed to node or ts-node).
A command's usage, args, and flags are now shown whenever a user forgets to provide a required arg or flag, or when they provided a non-existent flag.

If you need help migrating to the latest version, head over to core's README which has links to the migration guides. Feel free to open a new discussion if you need more hands-on help from us or the community.
ESM Support​
Version 3 of @oclif/core introduced full support for developing ESM plugins and CLIs. It also offered full support for interoperability between CommonJS and ESM plugins.
Put more simply, you can now migrate your CLI to ESM while keeping individual plugins in CommonJS (or vice versa). The upgrade path is now much simpler for you. You also don't need to worry about any community plugins that have migrated to ESM before you did (such as all the @oclif plugins) or are staunchly sticking with CommonJS for the foreseeable future.
Read more about this topic here.
Improving and Revitalizing oclif.io​
Another area of focus for us has been improving our documentation site, oclif.io.
While improving the quality and accuracy of the documentation was our priority, we also took the time to upgrade to the latest version of docusaurus. This new version gave our site a much-needed facelift, as well as cool new features such as dark mode and announcements.
If you have any feedback or are running into issues, we want to hear about it. Just create an issue in the oclif.io repo.
Re-engaging the oclif Community​
Lastly, our biggest priority at the moment is to re-engage the oclif community. We understand how frustrating it has been over the years to see your issues and pull requests go unacknowledged. We apologize for not prioritizing the community, and are earnestly trying to make sure that every issue and pull request gets the attention it deserves going forward.
We also opened up GitHub discussions for @oclif/core and the oclif CLI, where you can now post your questions or ideas. We hope you take advantage of them, we love hearing from you!
One last thing: we intend to publicly post our roadmap so you have more visibility into what we're working on. Stay tuned!
All our best,
The oclif teamNewer PostIntroducing `oclif init` commandOlder PostAnnouncing oclif v2!\n\n\n\nAnnouncing oclif v2!January 12, 2022 · 5 min readHello and happy new year! It's our great pleasure to announce that we have released oclif v2, which uses the new @oclif/core library! 🎉
oclif v2 includes many changes that improve the experience of both creating and using an oclif CLI.
Going forward, we don't plan to make any updates to oclif v1 and its corresponding libraries, except for critical security fixes. See the compatibility matrix for a list of these libraries. In order to give developers time to migrate from v1 to v2, we're not completely dropping support yet. But at some point in the future we'll archive the v1 repositories and deprecate their versions on npm.
What’s changing?​
Repository Changes​
All repositories under the oclif org now use main as their primary branch and oclif-v1 as the legacy branch. The main  branch corresponds to oclif v2 and the oclif-v1 branch to oclif v1. If you find any repos that don’t have a main branch, you can safely assume that they're not used in oclif v2 and will be deprecated in the future.
Consolidating Tools & Libraries​
The oclif-dev CLI has now been incorporated into oclif. You now no longer need to install a separate package to manage your entire CLI’s lifecycle.
The following libraries have been consolidated under @oclif/core and will be deprecated at some point in the future. Read the migration guide to learn how to update your CLI or plugin to use the new core library.

@oclif/command
@oclif/config
@oclif/error
@oclif/help
@oclif/parser

No more single vs multi command CLIs​
There's only one "type" of oclif v2 CLI, but it can have as few or as many commands as a developer wants. As a result, there’s only one command to generate CLIs, oclif generate, as opposed to the old oclif single and oclif multi commands.
Node > 12​
To ensure oclif CLIs are as secure as possible, all v2 libraries and plugins support only Node 12 or higher as of now. Going forward, they'll support only Node Maintenance or higher, as defined by Node's release schedule here: https://nodejs.org/en/about/releases/.
What’s new?​
New example CLI​
oclif-hello-world is our new example repo. This is also the repo that's used as a template when running oclif generate to create a new CLI. This repo will always be able to be referenced as an example of what an oclif v2 CLI should look like.
Spaced commands​
oclif CLIs can now use spaces, instead of colons, to separate topics and subcommands. To enable this feature, simply add “topicSeparator": " " to the oclif config in your package.json. See an example in our example repo.
// Old commands that use :$ mycli do:something
// New spaced commands$ mycli do something

Note: Spaced commands are backwards compatible. So if you enable spaced commands for your CLI, users will still be able to use : as a separator. This ensures that any existing scripts don't break.

New Help Output​
We’ve revamped the way command help is outputted to the terminal, making it both easier to implement and easier to read. See the difference between the old help output on the left and the new help output on the right in the screenshots below.
oclif v1oclif v2
Notice that there are new sections for flags and global flags, examples are displayed with better spacing, and there is a section at the bottom called Configuration Variables. This Configuration Variables section is not part of the new help by default. But we've added support for custom help sections, which is what the sf CLI uses to create the new section.
Async Command Parsing​
We’ve also improved the performance of new CLIs by rewriting how commands are parsed on initialization. The new parser is asynchronous, which makes CLIs with a lot of commands or installed  plugins much faster.
What’s coming next?​
Part of our charter for the release of oclif v2 includes improving our engagement with the oclif community. We know that over the past couple of years we’ve reduced our involvement, and a lot of issues and PRs have languished in limbo. Hopefully you’ve already seen increased activity and responses from oclif maintainers recently, but if you haven’t, please don’t hesitate to ping us by tagging @admins in oclif repos.
We also want to start interviewing members of the oclif community to acquire feedback and prioritize the features and fixes you deem most important!
Best,
The oclif team

Reference material​
Migration Guide​
This guide explains how to upgrade a CLI or plugin from the old oclif v1 libraries to the new @oclif/core library that oclif v2 uses.
https://github.com/oclif/core/blob/main/MIGRATION.md
Compatibility Matrix​
The following matrix shows how the v1 libraries and plugins relate to the new v2 ones. Use this matrix as a guide to know what to drop and which versions to switch when upgrading your plugins and CLIs to v2.
oclif "v1"oclif "v2"Utility CLIsoclif@<2@oclif/dev-cli@<2oclif@>=2Main packages@oclif/command@oclif/config@oclif/errors@oclif/parser@oclif/plugin-help@oclif/core@>=1Node LTSNode v8-14Node v12+ (at time of writing)TypeScripttypescript@<4typescript@>=4Main plugins@oclif/plugin-autocomplete@<1@oclif/plugin-commands@<2@oclif/plugin-help@<4@oclif/plugin-not-found@<2@oclif/plugin-plugins@<2@oclif/plugin-update@<2plugin-warn-if-update-available@<2plugin-which@<2@oclif/plugin-autocomplete@>=1@oclif/plugin-commands@>=2@oclif/plugin-help@>=4@oclif/plugin-not-found@>=2@oclif/plugin-plugins@>=2@oclif/plugin-update@>=2@oclif/plugin-warn-if-update-available@>=2@oclif/plugin-which@>=2\n\nAnnouncing oclif v2!January 12, 2022 · 5 min readHello and happy new year! It's our great pleasure to announce that we have released oclif v2, which uses the new @oclif/core library! 🎉
oclif v2 includes many changes that improve the experience of both creating and using an oclif CLI.
Going forward, we don't plan to make any updates to oclif v1 and its corresponding libraries, except for critical security fixes. See the compatibility matrix for a list of these libraries. In order to give developers time to migrate from v1 to v2, we're not completely dropping support yet. But at some point in the future we'll archive the v1 repositories and deprecate their versions on npm.
What’s changing?​
Repository Changes​
All repositories under the oclif org now use main as their primary branch and oclif-v1 as the legacy branch. The main  branch corresponds to oclif v2 and the oclif-v1 branch to oclif v1. If you find any repos that don’t have a main branch, you can safely assume that they're not used in oclif v2 and will be deprecated in the future.
Consolidating Tools & Libraries​
The oclif-dev CLI has now been incorporated into oclif. You now no longer need to install a separate package to manage your entire CLI’s lifecycle.
The following libraries have been consolidated under @oclif/core and will be deprecated at some point in the future. Read the migration guide to learn how to update your CLI or plugin to use the new core library.

@oclif/command
@oclif/config
@oclif/error
@oclif/help
@oclif/parser

No more single vs multi command CLIs​
There's only one "type" of oclif v2 CLI, but it can have as few or as many commands as a developer wants. As a result, there’s only one command to generate CLIs, oclif generate, as opposed to the old oclif single and oclif multi commands.
Node > 12​
To ensure oclif CLIs are as secure as possible, all v2 libraries and plugins support only Node 12 or higher as of now. Going forward, they'll support only Node Maintenance or higher, as defined by Node's release schedule here: https://nodejs.org/en/about/releases/.
What’s new?​
New example CLI​
oclif-hello-world is our new example repo. This is also the repo that's used as a template when running oclif generate to create a new CLI. This repo will always be able to be referenced as an example of what an oclif v2 CLI should look like.
Spaced commands​
oclif CLIs can now use spaces, instead of colons, to separate topics and subcommands. To enable this feature, simply add “topicSeparator": " " to the oclif config in your package.json. See an example in our example repo.
// Old commands that use :$ mycli do:something
// New spaced commands$ mycli do something

Note: Spaced commands are backwards compatible. So if you enable spaced commands for your CLI, users will still be able to use : as a separator. This ensures that any existing scripts don't break.

New Help Output​
We’ve revamped the way command help is outputted to the terminal, making it both easier to implement and easier to read. See the difference between the old help output on the left and the new help output on the right in the screenshots below.
oclif v1oclif v2
Notice that there are new sections for flags and global flags, examples are displayed with better spacing, and there is a section at the bottom called Configuration Variables. This Configuration Variables section is not part of the new help by default. But we've added support for custom help sections, which is what the sf CLI uses to create the new section.
Async Command Parsing​
We’ve also improved the performance of new CLIs by rewriting how commands are parsed on initialization. The new parser is asynchronous, which makes CLIs with a lot of commands or installed  plugins much faster.
What’s coming next?​
Part of our charter for the release of oclif v2 includes improving our engagement with the oclif community. We know that over the past couple of years we’ve reduced our involvement, and a lot of issues and PRs have languished in limbo. Hopefully you’ve already seen increased activity and responses from oclif maintainers recently, but if you haven’t, please don’t hesitate to ping us by tagging @admins in oclif repos.
We also want to start interviewing members of the oclif community to acquire feedback and prioritize the features and fixes you deem most important!
Best,
The oclif team

Reference material​
Migration Guide​
This guide explains how to upgrade a CLI or plugin from the old oclif v1 libraries to the new @oclif/core library that oclif v2 uses.
https://github.com/oclif/core/blob/main/MIGRATION.md
Compatibility Matrix​
The following matrix shows how the v1 libraries and plugins relate to the new v2 ones. Use this matrix as a guide to know what to drop and which versions to switch when upgrading your plugins and CLIs to v2.
oclif "v1"oclif "v2"Utility CLIsoclif@<2@oclif/dev-cli@<2oclif@>=2Main packages@oclif/command@oclif/config@oclif/errors@oclif/parser@oclif/plugin-help@oclif/core@>=1Node LTSNode v8-14Node v12+ (at time of writing)TypeScripttypescript@<4typescript@>=4Main plugins@oclif/plugin-autocomplete@<1@oclif/plugin-commands@<2@oclif/plugin-help@<4@oclif/plugin-not-found@<2@oclif/plugin-plugins@<2@oclif/plugin-update@<2plugin-warn-if-update-available@<2plugin-which@<2@oclif/plugin-autocomplete@>=1@oclif/plugin-commands@>=2@oclif/plugin-help@>=4@oclif/plugin-not-found@>=2@oclif/plugin-plugins@>=2@oclif/plugin-update@>=2@oclif/plugin-warn-if-update-available@>=2@oclif/plugin-which@>=2Newer Postoclif Spring 2024 UpdateOlder PostIntroducing @oclif/core\n\n\n\nIntroducing @oclif/coreMarch 1, 2021 · 3 min readGreetings!
We hope this blog post finds you well.
Introducing...​
We are excited to announce the next iteration of the oclif project today: @oclif/core.
We have learned a lot in the last three years of developing oclif, developing on oclif and supporting millions of command runs a day via Heroku and Salesforce CLIs.
@oclif/core ("Core") simplifies the oclif development experience and introduces highly requested new features.
Core combines the essential oclif packages into one "core" package, aptly named @oclif/core.
Core also introduces:

A default command option
Colon or space command syntax
Async command parsing
Command piping to arguments

With the introduction of default command functionality, Core simplifies the oclif project and removes the notion of single or multi command CLIs. Core CLIs can have 1 or many commands.
Along with Core, we moved the oclif-dev CLI into the oclif CLI creating a single "utility" CLI. This CLI also introduces a new AWS S3 compatible publishing scheme.
What to expect in the near future​
Core is in pre-release beta and being actively developed for new internal Salesforce CLIs.
Much documentation needs to be written in the coming months including migration paths. Migration onto Core should be as painless as possible with many exports remaining entirely unchanged. Look for forthcoming blog posts and documentation on oclif.io.
Early this summer, tentively June 1, we will release Core v1. Core's release will coincide with major bumps to many other oclif plugin packages. See the compatibility matrix below.
At Core's v1 release, the current "main" oclif packages (namely: command, config, errors & parser) will go into maintenance mode until Jan 2022. They will receive only bug and security fixes and they remain compatible with current versions of the oclif and oclif-dev CLIs. Afterwhich, they will be archived.
Companioning Core, the next major release of the oclif CLI (literally oclif@2) will generate Core CLIs.
Going forward​
We are excited to release Core! We invite you to poke around the Core repo. It may appear to be a big change but Core keeps what you already enjoy about oclif while reducing development complexity, project dependencies, package coupling and bundle size and introduces many requested features previously too prickly to weave into the current oclif architecture.
Best,
The oclif team
Reference: Compatibility matrix​
oclif "v1"oclif "Core"Utility CLIsoclif@<2@oclif/dev-cli@<2oclif@>=2Main packages@oclif/core@<2@oclif/config@<2@oclif/errors@<2@oclif/parser@<4@oclif/plugin-help@<4@oclif/core@>=1Node LTSNode v8-14Node v12+TypeScripttypescript@<4typescript@>=4Main plugins@oclif/plugin-autocomplete@<1@oclif/plugin-commands@<2@oclif/plugin-help@<4@oclif/plugin-not-found@<2@oclif/plugin-plugins@<2@oclif/plugin-update@<2plugin-warn-if-update-available@<2plugin-which@<2@oclif/plugin-autocomplete@>=2@oclif/plugin-commands@>=2@oclif/plugin-help@>=4@oclif/plugin-not-found@>=2@oclif/plugin-plugins@>=2@oclif/plugin-update@>=2@oclif/plugin-warn-if-update-available@>=2@oclif/plugin-which@>=2\n\nIntroducing @oclif/coreMarch 1, 2021 · 3 min readGreetings!
We hope this blog post finds you well.
Introducing...​
We are excited to announce the next iteration of the oclif project today: @oclif/core.
We have learned a lot in the last three years of developing oclif, developing on oclif and supporting millions of command runs a day via Heroku and Salesforce CLIs.
@oclif/core ("Core") simplifies the oclif development experience and introduces highly requested new features.
Core combines the essential oclif packages into one "core" package, aptly named @oclif/core.
Core also introduces:

A default command option
Colon or space command syntax
Async command parsing
Command piping to arguments

With the introduction of default command functionality, Core simplifies the oclif project and removes the notion of single or multi command CLIs. Core CLIs can have 1 or many commands.
Along with Core, we moved the oclif-dev CLI into the oclif CLI creating a single "utility" CLI. This CLI also introduces a new AWS S3 compatible publishing scheme.
What to expect in the near future​
Core is in pre-release beta and being actively developed for new internal Salesforce CLIs.
Much documentation needs to be written in the coming months including migration paths. Migration onto Core should be as painless as possible with many exports remaining entirely unchanged. Look for forthcoming blog posts and documentation on oclif.io.
Early this summer, tentively June 1, we will release Core v1. Core's release will coincide with major bumps to many other oclif plugin packages. See the compatibility matrix below.
At Core's v1 release, the current "main" oclif packages (namely: command, config, errors & parser) will go into maintenance mode until Jan 2022. They will receive only bug and security fixes and they remain compatible with current versions of the oclif and oclif-dev CLIs. Afterwhich, they will be archived.
Companioning Core, the next major release of the oclif CLI (literally oclif@2) will generate Core CLIs.
Going forward​
We are excited to release Core! We invite you to poke around the Core repo. It may appear to be a big change but Core keeps what you already enjoy about oclif while reducing development complexity, project dependencies, package coupling and bundle size and introduces many requested features previously too prickly to weave into the current oclif architecture.
Best,
The oclif team
Reference: Compatibility matrix​
oclif "v1"oclif "Core"Utility CLIsoclif@<2@oclif/dev-cli@<2oclif@>=2Main packages@oclif/core@<2@oclif/config@<2@oclif/errors@<2@oclif/parser@<4@oclif/plugin-help@<4@oclif/core@>=1Node LTSNode v8-14Node v12+TypeScripttypescript@<4typescript@>=4Main plugins@oclif/plugin-autocomplete@<1@oclif/plugin-commands@<2@oclif/plugin-help@<4@oclif/plugin-not-found@<2@oclif/plugin-plugins@<2@oclif/plugin-update@<2plugin-warn-if-update-available@<2plugin-which@<2@oclif/plugin-autocomplete@>=2@oclif/plugin-commands@>=2@oclif/plugin-help@>=4@oclif/plugin-not-found@>=2@oclif/plugin-plugins@>=2@oclif/plugin-update@>=2@oclif/plugin-warn-if-update-available@>=2@oclif/plugin-which@>=2Newer PostAnnouncing oclif v2!Older Postoclif Summer 2020 Update\n\n\n\noclif Summer 2020 UpdateAugust 26, 2020 · 2 min readHello oclif developers! We hope you are all doing well.
Earlier this year, we started our planning for oclifconf v2 and, like all conference, had to change course. We opted not to hold a virtual conference, however, we wanted to take some time to highlight a few oclif features shipped this year.
Feature: Help templating​
One of the most requested features, help templating enables oclif developers to customize the help output for their CLI.
Read the announcement.
Feature: Custom error delegation​
This feature both improved how oclif throws and handles errors and allows oclif developers to overwrite or interject in oclif’s error handling.
Read the announcement.
Feature: postrun hooks​
We have added a new lifecycle event postrun. Your CLI can now run a hook after a command has ran.
See our hook documentation.
Feature: Root index command​
Previously, oclif would display CLI help if only the binary name with no command ID was invoked, oclif now supports a "root index" command. If present, a command defined at src/commands/index.ts will be run if no command ID is found.
1 million weekly downloads​
While exact oclif usage metrics are hard to pin down, we use npm download statistics of oclif packages as a rough approximation. Earlier this year, oclif's command package hit 1 million weekly downloads for the first time!
This year has been presented its challenges on everyone. We want to thank you, oclif developers, whom have taken the time to use and improve the oclif project. We look forward to seeing you all - in person - in the future!
All our best,
The oclif team\n\noclif Summer 2020 UpdateAugust 26, 2020 · 2 min readHello oclif developers! We hope you are all doing well.
Earlier this year, we started our planning for oclifconf v2 and, like all conference, had to change course. We opted not to hold a virtual conference, however, we wanted to take some time to highlight a few oclif features shipped this year.
Feature: Help templating​
One of the most requested features, help templating enables oclif developers to customize the help output for their CLI.
Read the announcement.
Feature: Custom error delegation​
This feature both improved how oclif throws and handles errors and allows oclif developers to overwrite or interject in oclif’s error handling.
Read the announcement.
Feature: postrun hooks​
We have added a new lifecycle event postrun. Your CLI can now run a hook after a command has ran.
See our hook documentation.
Feature: Root index command​
Previously, oclif would display CLI help if only the binary name with no command ID was invoked, oclif now supports a "root index" command. If present, a command defined at src/commands/index.ts will be run if no command ID is found.
1 million weekly downloads​
While exact oclif usage metrics are hard to pin down, we use npm download statistics of oclif packages as a rough approximation. Earlier this year, oclif's command package hit 1 million weekly downloads for the first time!
This year has been presented its challenges on everyone. We want to thank you, oclif developers, whom have taken the time to use and improve the oclif project. We look forward to seeing you all - in person - in the future!
All our best,
The oclif teamNewer PostIntroducing @oclif/coreOlder PostPretty Printable Errors\n\n\n\nPretty Printable ErrorsJuly 1, 2020 · One min readOften CLIs are used as handy tools and when things go wrong it’s useful to have additional context. In oclif we have added a couple of additional properties that can show extra context to the users when an error is displayed. The code, ref and suggestions will now be displayed if they are included. This will work with an existing oclif CLI by adding the latest @oclif/errors and @oclif/core to the CLI's package.json dependencies.
For example, using this.error with the additional properties:
class TestError extends Command {  async run() {    this.error("An error has occurred!", {      code: "OCLIF_ERR",      ref: "https://oclif.io/docs/commands#thiserrormessage-string--error-options-code-string-exit-number",      suggestions: ["Use these extra properties to provide additional context"],    })  }}
would result with the following output:
›   Error: An error has occurred!›   Code: OCLIF_ERR›   Try this: Use these extra properties to provide additional context›   Reference: https://oclif.io/docs/commands#thiserrormessage-string--error-options-code-string-exit-number
If these properties are not provided then nothing changes and the CLI will continue to display the single error message output as it did before. Additionally, as part of this exercise we’ve added documentation around Error Handling in oclif which should come in handy if the need arises to extend oclif’s default handling of errors.\n\nPretty Printable ErrorsJuly 1, 2020 · One min readOften CLIs are used as handy tools and when things go wrong it’s useful to have additional context. In oclif we have added a couple of additional properties that can show extra context to the users when an error is displayed. The code, ref and suggestions will now be displayed if they are included. This will work with an existing oclif CLI by adding the latest @oclif/errors and @oclif/core to the CLI's package.json dependencies.
For example, using this.error with the additional properties:
class TestError extends Command {  async run() {    this.error("An error has occurred!", {      code: "OCLIF_ERR",      ref: "https://oclif.io/docs/commands#thiserrormessage-string--error-options-code-string-exit-number",      suggestions: ["Use these extra properties to provide additional context"],    })  }}
would result with the following output:
›   Error: An error has occurred!›   Code: OCLIF_ERR›   Try this: Use these extra properties to provide additional context›   Reference: https://oclif.io/docs/commands#thiserrormessage-string--error-options-code-string-exit-number
If these properties are not provided then nothing changes and the CLI will continue to display the single error message output as it did before. Additionally, as part of this exercise we’ve added documentation around Error Handling in oclif which should come in handy if the need arises to extend oclif’s default handling of errors.Newer Postoclif Summer 2020 UpdateOlder PostCustomizing Help in oclif\n\n\n\nCustomizing Help in oclifMay 5, 2020 · 2 min readOut of the box oclif provides a great help experience for CLIs.
But what if, as an oclif developer, you want to customize some or all of the output?
You can now customize your CLI's help output by implementing the HelpBase abstract class.
Getting started with custom help​
If you have not done so yet, update @oclif/core.
$ yarn add --latest @oclif/core
To get started, first define the filepath to your help class in oclif's config in package.json. This is a relative path to the help class, without a file extension.
For this example, the help class will be created in a file at "[project root]/src/help.ts".
{  // ...  "oclif": {    "helpClass": "./lib/help"    // ...  }  // ...}
From here there are two paths, implement the HelpBase abstract class yourself or overwrite the parts of the default Help class you want to customize (ex: how command usage is displayed). We recommend the latter approach but cover both in the new Help Classes docs.
Separating TOPICS & COMMANDS in the new default Help class​
Previously, topics and child commands were listed in help output under a single list heading called "COMMANDS". But we found this can be slightly confusing. Some topics are commands also (a.k.a. topic-commands) while others are simply organizational namespacing (and when ran just show their help).
The new default Help class splits the list of children into distinct lists of "TOPICS" and "COMMANDS", with the possibility of an item appearing in both if it a topic-command. This makes it clearer what is expected to be ran - "COMMANDS" - and what is providing structure - "TOPICS" - when looking at the help output.
VERSION  plugin-help-example/0.0.0 darwin-x64 node-v12.12.0USAGE  $ plugin-help-example [COMMAND]TOPICS  topic  this is a topic and has child topics or commandsCOMMANDS  hello  describe the command here  help   display help for plugin-help-example
We look forward to seeing what custom help features you implement in your oclif CLIs with this new feature!\n\nCustomizing Help in oclifMay 5, 2020 · 2 min readOut of the box oclif provides a great help experience for CLIs.
But what if, as an oclif developer, you want to customize some or all of the output?
You can now customize your CLI's help output by implementing the HelpBase abstract class.
Getting started with custom help​
If you have not done so yet, update @oclif/core.
$ yarn add --latest @oclif/core
To get started, first define the filepath to your help class in oclif's config in package.json. This is a relative path to the help class, without a file extension.
For this example, the help class will be created in a file at "[project root]/src/help.ts".
{  // ...  "oclif": {    "helpClass": "./lib/help"    // ...  }  // ...}
From here there are two paths, implement the HelpBase abstract class yourself or overwrite the parts of the default Help class you want to customize (ex: how command usage is displayed). We recommend the latter approach but cover both in the new Help Classes docs.
Separating TOPICS & COMMANDS in the new default Help class​
Previously, topics and child commands were listed in help output under a single list heading called "COMMANDS". But we found this can be slightly confusing. Some topics are commands also (a.k.a. topic-commands) while others are simply organizational namespacing (and when ran just show their help).
The new default Help class splits the list of children into distinct lists of "TOPICS" and "COMMANDS", with the possibility of an item appearing in both if it a topic-command. This makes it clearer what is expected to be ran - "COMMANDS" - and what is providing structure - "TOPICS" - when looking at the help output.
VERSION  plugin-help-example/0.0.0 darwin-x64 node-v12.12.0USAGE  $ plugin-help-example [COMMAND]TOPICS  topic  this is a topic and has child topics or commandsCOMMANDS  hello  describe the command here  help   display help for plugin-help-example
We look forward to seeing what custom help features you implement in your oclif CLIs with this new feature!Newer PostPretty Printable ErrorsOlder Postoclif TSLint to ESLint Migration\n\n\n\noclif TSLint to ESLint MigrationDecember 5, 2019 · 3 min readBack in February of this year, plans were announced to deprecate TSLint in favor of ESLint. TSLint's goal has become to work toward a “unified developer experience” by supporting ESLint development going forward.
What has changed in oclif​
To keep inline with the community, oclif has transitioned to ESLint for all our core libraries as well as all our official plugins.
Starting in v1.15.x, oclif will now optionally generate projects with ESLint for both TypeScript and JavaScript CLI’s.
ESLint does require Node to be on stable LTS version, at the time of writing, Node 8.10.x, Node 10.13.x & Node 12.x.x.
How does this affect you​
Existing CLI’s are unchanged, but any newly generated CLI's will only give the option of using ESLint. If you are running tslint in your CLI, we recommend you switch to ESLint as well.
In migrating our projects we took the following steps (for an example of these changes see this pull request).


Install eslint
$ yarn add eslint eslint-config-oclif eslint-config-oclif-typescript --dev


Add eslint related files


$ echo '{  "extends": [    "oclif",    "oclif-typescript"  ],  "rules": {  }}' > .eslintrc


Remove tslint and related packages
$ yarn remove @oclif/tslint tslint


Remove tslint related configuration files
$ rm tslint.json


Change lint script in our package.json from something like:
"lint": "tsc -p test --noEmit && tslint -p test -t stylish"
to
"lint": "eslint . --ext .ts --config .eslintrc"


To preserve the test compile (tsc -p test --noEmit) we also made the following updates to our scripts:
"pretest": "tsc -p test --noEmit"
In some cases we had our posttest duplicating the same steps as our lint script so it’s cleaner to have it reference the lint job directly with:
"posttest": "yarn lint"

Run yarn lint --fix. This attempts to auto-fix any linting violations automatically. In the case an auto-fix isn’t available it should be fixed manually or ignored (see the eslint configuration doc for more information)
Do a search in the codebase for tslint and remove any unnecessary tslint disabling comments, like:

/* tslint:disable:object-literal-sort-keys */
If you are on a version of Node that is not supported by ESLint, you will also need to update your Node engine. ESLint supports Node 8, 10, and 12 so you should upgrade to the most recent Node version compatible with your CLI and also supported by ESLint (see ESLint's Installation and Usage instructions).
When will this take effect​
These changes have taken effect in oclif v1.15.1. When you generate a new CLI or plugin it will now contain configuration for ESLint instead of TSLint.\n\noclif TSLint to ESLint MigrationDecember 5, 2019 · 3 min readBack in February of this year, plans were announced to deprecate TSLint in favor of ESLint. TSLint's goal has become to work toward a “unified developer experience” by supporting ESLint development going forward.
What has changed in oclif​
To keep inline with the community, oclif has transitioned to ESLint for all our core libraries as well as all our official plugins.
Starting in v1.15.x, oclif will now optionally generate projects with ESLint for both TypeScript and JavaScript CLI’s.
ESLint does require Node to be on stable LTS version, at the time of writing, Node 8.10.x, Node 10.13.x & Node 12.x.x.
How does this affect you​
Existing CLI’s are unchanged, but any newly generated CLI's will only give the option of using ESLint. If you are running tslint in your CLI, we recommend you switch to ESLint as well.
In migrating our projects we took the following steps (for an example of these changes see this pull request).


Install eslint
$ yarn add eslint eslint-config-oclif eslint-config-oclif-typescript --dev


Add eslint related files


$ echo '{  "extends": [    "oclif",    "oclif-typescript"  ],  "rules": {  }}' > .eslintrc


Remove tslint and related packages
$ yarn remove @oclif/tslint tslint


Remove tslint related configuration files
$ rm tslint.json


Change lint script in our package.json from something like:
"lint": "tsc -p test --noEmit && tslint -p test -t stylish"
to
"lint": "eslint . --ext .ts --config .eslintrc"


To preserve the test compile (tsc -p test --noEmit) we also made the following updates to our scripts:
"pretest": "tsc -p test --noEmit"
In some cases we had our posttest duplicating the same steps as our lint script so it’s cleaner to have it reference the lint job directly with:
"posttest": "yarn lint"

Run yarn lint --fix. This attempts to auto-fix any linting violations automatically. In the case an auto-fix isn’t available it should be fixed manually or ignored (see the eslint configuration doc for more information)
Do a search in the codebase for tslint and remove any unnecessary tslint disabling comments, like:

/* tslint:disable:object-literal-sort-keys */
If you are on a version of Node that is not supported by ESLint, you will also need to update your Node engine. ESLint supports Node 8, 10, and 12 so you should upgrade to the most recent Node version compatible with your CLI and also supported by ESLint (see ESLint's Installation and Usage instructions).
When will this take effect​
These changes have taken effect in oclif v1.15.1. When you generate a new CLI or plugin it will now contain configuration for ESLint instead of TSLint.Newer PostCustomizing Help in oclifOlder Postoclif's Current Node Support\n\n\n\noclif's Current Node SupportOctober 31, 2019 · 3 min readTo maintain a healthy project trajectory, oclif follows and supports Node Active LTS release, currently Node 10 & Node 12. This means ensuring that oclif continues to play nice with coming Active LTS Node versions and other packages in the ecosystem. Moving forward also means leaving older versions behind. Starting in 2020, Node will stop maintaining Node 8 and it is our intent at that time to also follow suit. Let’s take a look at a few ways we will be supporting these changes.
CI Environments​
CLIs created with the oclif cli going forward will be generated with a CircleCI configuration with Node 10 & 12 and an Appveyor configuration using Node 10. We have also added Node latest to CircleCi to be an early warning detection against coming Node changes (Node latest is managed by CircleCI).
We have already updated every oclif repo's CI configs to reflect this.
If your existing CLI uses either Appveyor or CircleCI you can update your config files also, like so:
.circleci/config.yml​
Your CircleCI config should contain a node-latest job, aliased as test. From this, there should be two extensions of this job for the Active LTS Node versions, Node 10 and Node 12.
  node-10:    <<: *node-latest    docker:      - image: node:10  node-12:    <<: *node-latest    docker:      - image: node:12
Notice that these declarations only change the Docker Node images used to run that job.
Additionally, the jobs listed within workflows must also be updated to reflect our changes in configuration:
    jobs:      - node-latest      - node-10      - node-12
appveyor.yml​
For appveyor we are currently only testing the oldest Active LTS Node version, Node 10. Update the nodejs_version proppert in your appveyor.yml file to reflect this.
environment:  nodejs_version: "10"
Deprecating Node 8 & Updating packge.json engines​
In Jan 2020, Node will end its Node 8 maintenance. We will follow suit by setting the package.json engine property in oclif packages to >=10 and bumping the package's major versions.
Depending on how you ship your CLI you may wish to also bump the engines version in your CLI's package.json. You can read more about the implications of the engines property configuration in the npm documentation.
Also consider distributing your CLI with its own Node version.
Packaged Node Version​
When using dev-cli to pack your CLI it will use the Node version as specified in your package.json under the oclif.update.node.version property. This value should reflect an Active LTS Node version (dev-cli does not currently enforce versions).
Supporting the future​
As a community we may discover bumps along the way as we upgrade. If you notice something related to oclif please feel free to open an issue or submit a pull request under the relevant oclif package within the org.
We look forward to using the latest from Node and the community and keeping oclif healthy along the way.\n\noclif's Current Node SupportOctober 31, 2019 · 3 min readTo maintain a healthy project trajectory, oclif follows and supports Node Active LTS release, currently Node 10 & Node 12. This means ensuring that oclif continues to play nice with coming Active LTS Node versions and other packages in the ecosystem. Moving forward also means leaving older versions behind. Starting in 2020, Node will stop maintaining Node 8 and it is our intent at that time to also follow suit. Let’s take a look at a few ways we will be supporting these changes.
CI Environments​
CLIs created with the oclif cli going forward will be generated with a CircleCI configuration with Node 10 & 12 and an Appveyor configuration using Node 10. We have also added Node latest to CircleCi to be an early warning detection against coming Node changes (Node latest is managed by CircleCI).
We have already updated every oclif repo's CI configs to reflect this.
If your existing CLI uses either Appveyor or CircleCI you can update your config files also, like so:
.circleci/config.yml​
Your CircleCI config should contain a node-latest job, aliased as test. From this, there should be two extensions of this job for the Active LTS Node versions, Node 10 and Node 12.
  node-10:    <<: *node-latest    docker:      - image: node:10  node-12:    <<: *node-latest    docker:      - image: node:12
Notice that these declarations only change the Docker Node images used to run that job.
Additionally, the jobs listed within workflows must also be updated to reflect our changes in configuration:
    jobs:      - node-latest      - node-10      - node-12
appveyor.yml​
For appveyor we are currently only testing the oldest Active LTS Node version, Node 10. Update the nodejs_version proppert in your appveyor.yml file to reflect this.
environment:  nodejs_version: "10"
Deprecating Node 8 & Updating packge.json engines​
In Jan 2020, Node will end its Node 8 maintenance. We will follow suit by setting the package.json engine property in oclif packages to >=10 and bumping the package's major versions.
Depending on how you ship your CLI you may wish to also bump the engines version in your CLI's package.json. You can read more about the implications of the engines property configuration in the npm documentation.
Also consider distributing your CLI with its own Node version.
Packaged Node Version​
When using dev-cli to pack your CLI it will use the Node version as specified in your package.json under the oclif.update.node.version property. This value should reflect an Active LTS Node version (dev-cli does not currently enforce versions).
Supporting the future​
As a community we may discover bumps along the way as we upgrade. If you notice something related to oclif please feel free to open an issue or submit a pull request under the relevant oclif package within the org.
We look forward to using the latest from Node and the community and keeping oclif healthy along the way.Newer Postoclif TSLint to ESLint MigrationOlder Postoclifconf 2019: A Recap\n\n\n\noclifconf 2019: A RecapSeptember 16, 2019 · 4 min readIn May, Heroku and Salesforce Open Source organized oclifconf, a conference for developers & product managers building CLI tools on top of the open source oclif framework. The speakers came from various tech companies, such as Adobe, Netlify, and Apollo, who have already built amazing CLI experiences. The topics covered everything from the incredible capabilities oclif has unlocked, to the community-built plugins extending its functionality, and even what the behavior of an adaptive CLI tool might look like.
Below is a listing of all of the talks from the event, along with a short summary. Enjoy!
The future of oclif by Jeff Dickey​

In its relatively short lifetime, oclif has already inspired many developers and companies to adopt its framework as a means for implementing their own command-line tooling. In this talk, Jeff Dickey, an oclif founding team member, recaps the project's history and inspiration. He also looks towards the future and outlines some features and improvements that the tool could adapt. This isn't so much a definitive roadmap of where oclif is headed, but rather, a call to inspiration for developers eager to contribute! And if you are interested in contributing, check out the open issues in the oclif GitHub repo and come say "Hello!" on Spectrum Chat.
Open Source Citizenship by Josh Simmons​

When it comes to open source, it's more than just individuals now. More and more frequently, large corporations are contributing to projects by donating to contributors, sponsoring events, or upstreaming contributions. But keeping open source projects and communities healthy requires more than just money and brainpower. Josh Simmons surveyed multiple open source communities and relays his findings as to what help maintainers and contributors actually need in this talk.
Building an enterprise-grade CLI with oclif by Thomas Dvornik​

Security and performance are all about trust. While oclif is an extremely extensible framework for building CLI tooling, there are additional requirements to fulfill for enterprise businesses to adopt it that might not be necessary for individual developers. Thomas Dvornik outlines what he and his colleagues at Salesforce have implemented as plugins to oclif to satisfy these needs, including encrypted OAuth, plugin signing, lazy loading dependencies, synchronizing weekly releases and deprecations across dozens of repositories, and establishing cross-team coding and documentation standards.
How Adobe I/O built an extensible CLI with oclif by Jesse MacFadyen​

Perhaps oclif's most appealing feature is its support for plugins. In Cordova's case, they've created a sophisticated telemetry system that helps Adobe developers see which commands users are using--and reports on which ones are erroring out. By embedding a feedback system into the tool, users are even able to quickly send their suggestions to a form, without ever leaving the terminal. Jesse MacFadyen demonstrates how oclif's plugin system can work beyond simply executing commands.
Integrating oclif with GraphQL and Apollo by Evans Hauser​

For Evans Hauser and the team at Apollo, oclif is best thought of as "React for the CLI." As a client paired with a strongly-typed API contract to a server, it can deliver structured and consistent commands to retrieve external data. What better mechanism to use for this transfer than GraphQL, a framework which empowers the client to ask precisely for the data it needs, and nothing more?
Adaptive Intent-based CLI State Machines by Shawn Wang​

In designing oclif, Jeff Dickey wrote out 12 CLI factors to keep in mind. In this talk, Shawn Wang outlines a 13th: state. State is hard, because it depends on context, and context depends on understanding what a user intends to do, not what they are asking. Shawn is working towards enabling oclif to better understand the commands a user has entered, so that it can predict and interpret future commands that might be entered next. This would enable CLI tools to not just interpret a users' commands, but to also interpret their intent.\n\noclifconf 2019: A RecapSeptember 16, 2019 · 4 min readIn May, Heroku and Salesforce Open Source organized oclifconf, a conference for developers & product managers building CLI tools on top of the open source oclif framework. The speakers came from various tech companies, such as Adobe, Netlify, and Apollo, who have already built amazing CLI experiences. The topics covered everything from the incredible capabilities oclif has unlocked, to the community-built plugins extending its functionality, and even what the behavior of an adaptive CLI tool might look like.
Below is a listing of all of the talks from the event, along with a short summary. Enjoy!
The future of oclif by Jeff Dickey​

In its relatively short lifetime, oclif has already inspired many developers and companies to adopt its framework as a means for implementing their own command-line tooling. In this talk, Jeff Dickey, an oclif founding team member, recaps the project's history and inspiration. He also looks towards the future and outlines some features and improvements that the tool could adapt. This isn't so much a definitive roadmap of where oclif is headed, but rather, a call to inspiration for developers eager to contribute! And if you are interested in contributing, check out the open issues in the oclif GitHub repo and come say "Hello!" on Spectrum Chat.
Open Source Citizenship by Josh Simmons​

When it comes to open source, it's more than just individuals now. More and more frequently, large corporations are contributing to projects by donating to contributors, sponsoring events, or upstreaming contributions. But keeping open source projects and communities healthy requires more than just money and brainpower. Josh Simmons surveyed multiple open source communities and relays his findings as to what help maintainers and contributors actually need in this talk.
Building an enterprise-grade CLI with oclif by Thomas Dvornik​

Security and performance are all about trust. While oclif is an extremely extensible framework for building CLI tooling, there are additional requirements to fulfill for enterprise businesses to adopt it that might not be necessary for individual developers. Thomas Dvornik outlines what he and his colleagues at Salesforce have implemented as plugins to oclif to satisfy these needs, including encrypted OAuth, plugin signing, lazy loading dependencies, synchronizing weekly releases and deprecations across dozens of repositories, and establishing cross-team coding and documentation standards.
How Adobe I/O built an extensible CLI with oclif by Jesse MacFadyen​

Perhaps oclif's most appealing feature is its support for plugins. In Cordova's case, they've created a sophisticated telemetry system that helps Adobe developers see which commands users are using--and reports on which ones are erroring out. By embedding a feedback system into the tool, users are even able to quickly send their suggestions to a form, without ever leaving the terminal. Jesse MacFadyen demonstrates how oclif's plugin system can work beyond simply executing commands.
Integrating oclif with GraphQL and Apollo by Evans Hauser​

For Evans Hauser and the team at Apollo, oclif is best thought of as "React for the CLI." As a client paired with a strongly-typed API contract to a server, it can deliver structured and consistent commands to retrieve external data. What better mechanism to use for this transfer than GraphQL, a framework which empowers the client to ask precisely for the data it needs, and nothing more?
Adaptive Intent-based CLI State Machines by Shawn Wang​

In designing oclif, Jeff Dickey wrote out 12 CLI factors to keep in mind. In this talk, Shawn Wang outlines a 13th: state. State is hard, because it depends on context, and context depends on understanding what a user intends to do, not what they are asking. Shawn is working towards enabling oclif to better understand the commands a user has entered, so that it can predict and interpret future commands that might be entered next. This would enable CLI tools to not just interpret a users' commands, but to also interpret their intent.Newer Postoclif's Current Node SupportOlder PostCLI Flags Explained\n\n\n\nCLI Flags ExplainedFebruary 20, 2019 · 5 min readCasey Watts and Jeff Dickeyoclif makes it easy to create a command line interface (CLI) in node. Most commands have parameters — also known as "flags", "args", and sometimes "options". This blog post explains what these parameters are and when to use them. We also have a new feature that makes it easier for users to detect typos when using parameters.
Note the following describes GNU-style flags. Not all CLIs follow this convention, but it is the most commonly used.
Parts of Speech​
Any command line interface command has a few standard "parts of speech".  As a user of CLI tools, knowing these parts of speech can help you make fewer typos. It can also help you understand complex commands other people share with you more quickly. If you are designing a CLI tool it is even more important to understand these parts of speech, so you can come up with the most ergonomic interface for your users.
Of the many ways you can pass data to a CLI command, three of them are parameters that are always to the "right" of the command. The three types of parameters are argument, short flag, and long flag.
Example ls​
One of the  most common and simplest unix commands is ls which "lists" the contents of a directory.
command​
ls
This command ls works on its own, as a standalone command. Without any parameters this command will list the contents of the current folder, using an implied . directory.
argument​
ls .ls ~/code/some-repo-name
If you pass a command argument to this command, like the directory name . (current folder) or ~/code/some-repo-name, it will list the contents of that directory instead.
An argument is anything to the right of a command that is not a flag. An argument can come before or after flags.
Long flag​
To list additional files that are normally hidden (like ~/.bashrc), you can use a flag on the ls command. ls --all is the long flag form. A long flag always uses a double dash, and it is always represented by multiple characters.
ls --allls . --all
Short flag​
There is also a short flag form of this flag: ls -a. The a is short for all in this case. A short flag always uses a single dash, and it is always represented by a single letter.
ls -als . -a
Short flags can stack too, so you don't need a separate dash for each one. Order does not matter for these, unless passing a flag argument.
ls -la
Flag arguments​
Many flags accept an option, which is a "flag argument" (as opposed to a "command argument"). In general a command's parameters can be in any order, but flags that accept options must have the option directly after the flag.
For an example, here the -x flag does not accept an option but the -f flag does. archive.tar is the option being passed to -f.
tar -x -f archive.tartar -xf archive.tar
A flag and its option can be separated by a space   or an equals sign =. Interestingly, short flags (but not long flags) can even skip the space, although many people find it much easier to read with the space or equals sign.
These three are all valid and equivalent:
tar -f archive.tartar -f=archive.tartar -farchive.tar
Long flags must have a space or equals sign to separate the flag from its option.
git log --pretty=onelinegit log --pretty oneline
Other Ways of Passing Data​
We've covered parameters, which are arguments, short flags and long flags. There are two other ways to pass data to a command: environment variables ("env vars"), or standard input ("stdin"). These won't be covered in this blog post.
Designing a Command​
Scenario: we want to design an oclif command that echos an input like "Casey", and returns "hi, Casey!". There are many ways the user could pass this in, and here we show an example of each type of input.
argument​
greet-me Casey
short flag with argument​
greet-me -n Caseygreet-me -n=Caseygreet-me -nCasey
long flag with argument​
greet-me --name=Caseygreet-me --name Casey
environment variable​
NAME=Casey greet-me
standard input​
echo "Casey" | greet-me
Command ergonomics​
Short flag vs long flag​
Many CLI commands allow for both long flag and short flag forms. In the Heroku CLI every flag has at least a long flag form and roughly half of the flags also have a short flag form.
The long flag form is easier to read, but takes more characters to type. It is often most useful when you want someone to understand a particular command statement quickly and easily, such as in a README.
The short flag form is quicker to type, and is often better for frequently used commands. Short flags are especially useful when stacking short flags together.\n\nCLI Flags ExplainedFebruary 20, 2019 · 5 min readCasey Watts and Jeff Dickeyoclif makes it easy to create a command line interface (CLI) in node. Most commands have parameters — also known as "flags", "args", and sometimes "options". This blog post explains what these parameters are and when to use them. We also have a new feature that makes it easier for users to detect typos when using parameters.
Note the following describes GNU-style flags. Not all CLIs follow this convention, but it is the most commonly used.
Parts of Speech​
Any command line interface command has a few standard "parts of speech".  As a user of CLI tools, knowing these parts of speech can help you make fewer typos. It can also help you understand complex commands other people share with you more quickly. If you are designing a CLI tool it is even more important to understand these parts of speech, so you can come up with the most ergonomic interface for your users.
Of the many ways you can pass data to a CLI command, three of them are parameters that are always to the "right" of the command. The three types of parameters are argument, short flag, and long flag.
Example ls​
One of the  most common and simplest unix commands is ls which "lists" the contents of a directory.
command​
ls
This command ls works on its own, as a standalone command. Without any parameters this command will list the contents of the current folder, using an implied . directory.
argument​
ls .ls ~/code/some-repo-name
If you pass a command argument to this command, like the directory name . (current folder) or ~/code/some-repo-name, it will list the contents of that directory instead.
An argument is anything to the right of a command that is not a flag. An argument can come before or after flags.
Long flag​
To list additional files that are normally hidden (like ~/.bashrc), you can use a flag on the ls command. ls --all is the long flag form. A long flag always uses a double dash, and it is always represented by multiple characters.
ls --allls . --all
Short flag​
There is also a short flag form of this flag: ls -a. The a is short for all in this case. A short flag always uses a single dash, and it is always represented by a single letter.
ls -als . -a
Short flags can stack too, so you don't need a separate dash for each one. Order does not matter for these, unless passing a flag argument.
ls -la
Flag arguments​
Many flags accept an option, which is a "flag argument" (as opposed to a "command argument"). In general a command's parameters can be in any order, but flags that accept options must have the option directly after the flag.
For an example, here the -x flag does not accept an option but the -f flag does. archive.tar is the option being passed to -f.
tar -x -f archive.tartar -xf archive.tar
A flag and its option can be separated by a space   or an equals sign =. Interestingly, short flags (but not long flags) can even skip the space, although many people find it much easier to read with the space or equals sign.
These three are all valid and equivalent:
tar -f archive.tartar -f=archive.tartar -farchive.tar
Long flags must have a space or equals sign to separate the flag from its option.
git log --pretty=onelinegit log --pretty oneline
Other Ways of Passing Data​
We've covered parameters, which are arguments, short flags and long flags. There are two other ways to pass data to a command: environment variables ("env vars"), or standard input ("stdin"). These won't be covered in this blog post.
Designing a Command​
Scenario: we want to design an oclif command that echos an input like "Casey", and returns "hi, Casey!". There are many ways the user could pass this in, and here we show an example of each type of input.
argument​
greet-me Casey
short flag with argument​
greet-me -n Caseygreet-me -n=Caseygreet-me -nCasey
long flag with argument​
greet-me --name=Caseygreet-me --name Casey
environment variable​
NAME=Casey greet-me
standard input​
echo "Casey" | greet-me
Command ergonomics​
Short flag vs long flag​
Many CLI commands allow for both long flag and short flag forms. In the Heroku CLI every flag has at least a long flag form and roughly half of the flags also have a short flag form.
The long flag form is easier to read, but takes more characters to type. It is often most useful when you want someone to understand a particular command statement quickly and easily, such as in a README.
The short flag form is quicker to type, and is often better for frequently used commands. Short flags are especially useful when stacking short flags together.Newer Postoclifconf 2019: A RecapOlder PostIntroducing oclif\n\n\n\nIntroducing oclifMarch 20, 2018 · One min readJeff Dickey
Coding for the browser takes serious time. You need to deal with front-end JS, CSS, design, product, and a ton more. On the other hand, building for a CLI takes a fraction of the effort. This makes CLIs particularly great for prototyping out new functionality, offering admin/internal tools, or power-user functionality.
Read More\n\nIntroducing oclifMarch 20, 2018 · One min readJeff Dickey
Coding for the browser takes serious time. You need to deal with front-end JS, CSS, design, product, and a ton more. On the other hand, building for a CLI takes a fraction of the effort. This makes CLIs particularly great for prototyping out new functionality, offering admin/internal tools, or power-user functionality.
Read MoreNewer PostCLI Flags Explained\n\n\n\nIntroducing `oclif init` commandApril 10, 2024 · 2 min readThanks to the contribution of @joshcanhelp we released a new command for the oclif CLI called oclif init in version 4.8.0
The oclif init command allows you to initialize oclif in an existing project directory by adding the bare minimum requirements: a few pieces of configuration, bin scripts, and a couple of dependencies (@oclif/core and ts-node). This is slightly different from oclif generate, which will create an entirely new oclif project based on our templates.
oclif init will add the following:

bin scripts: bin/run.js, bin/run.cmd, bin/dev.js, and bin/dev.cmd
oclif section to package.json with bin, dirname, commands, and topicSeparator set (See Configuring Your CLI for more)
@oclif/core to dependencies in your package.json (if it's not already there)
ts-node to devDependencies in your package.json (if it's not already there)

Once you've initialized oclif, you can use the bin scripts to execute your CLI. You can also use the other oclif commands like oclif generate command and oclif generate hook to start adding new functionality.

❯ oclif init --helpInitialize a new oclif CLIUSAGE  $ oclif init [--bin <value>] [--module-type ESM|CommonJS] [--package-manager npm|yarn|pnpm] [--topic-separator    colons|spaces] [-d <value>] [-y]FLAGS  -d, --output-dir=<value>        Directory to initialize the CLI in.  -y, --yes                       Use defaults for all prompts. Individual flags will override defaults.      --bin=<value>               Supply answer for prompt: Command bin name the CLI will export      --module-type=<option>      Supply answer for prompt: Select a module type                                  <options: ESM|CommonJS>      --package-manager=<option>  Supply answer for prompt: Select a package manager                                  <options: npm|yarn|pnpm>      --topic-separator=<option>  Supply answer for prompt: Select a topic separator                                  <options: colons|spaces>DESCRIPTION  Initialize a new oclif CLI  This will add the necessary oclif bin files, add oclif config to package.json, and install @oclif/core and ts-node.EXAMPLES  Initialize a new CLI in the current directory    $ oclif init  Initialize a new CLI in a different directory    $ oclif init --output-dir "/path/to/existing/project"  Supply answers for specific prompts    $ oclif init --topic-separator colons --bin mycli
Hope you enjoy the new command! If you come across any issues or have any new ideas for this command, head over to the oclif/oclif repo and open a new issue.
All our best,
The oclif teamoclif Spring 2024 UpdateMarch 29, 2024 · 4 min readHello oclif developers! It's been a while since we last uploaded a blog - and a lot has happened.
We've been focusing on these high-level areas over the past couple of years:

Improving @oclif/core
ESM Support
Improving and revitalizing oclif.io
Re-engaging the oclif community

Improving @oclif/core​
Since we announced @oclif/core over three years ago, we've released two new major versions, each packed with lots of features that we're really excited about.
Here are some of these changes:

Full support for ESM and interoperability with CommonJS (more on this topic below).
Configurable command discovery strategies that give you more control over how commands are loaded at runtime. Check out the docs.
A new preparse hook that allows you to manipulate the provided arguments before they're parsed. Salesforce used this hook to implement a neat --flags-dir feature that translates local files into flags.
A new Performance class that you can use to track performance inside of @oclif/core and your own CLI or plugin. Check out the docs.
A new flag type, Flags.option, that lets you define a flag with a preset list of options. Typescript then uses the options to infer the flag's type.
Flags now have a relationship property that allows you to define more complex relationships between flags. Check out the flags docs for more information.
Flags now have a defaultHelp property that allows you to set the human readable default value in the command help. This property is useful when your flag's parse method returns a complex type, such as an object or a class. Check out the flags docs for more.
Commands now have a hiddenAliases property that allows you to define aliases that you want to hide from the user. The property is super helpful when you're trying to wean users off a deprecated command.
You can now use bun or tsx as dev runtimes (as opposed to node or ts-node).
A command's usage, args, and flags are now shown whenever a user forgets to provide a required arg or flag, or when they provided a non-existent flag.

If you need help migrating to the latest version, head over to core's README which has links to the migration guides. Feel free to open a new discussion if you need more hands-on help from us or the community.
ESM Support​
Version 3 of @oclif/core introduced full support for developing ESM plugins and CLIs. It also offered full support for interoperability between CommonJS and ESM plugins.
Put more simply, you can now migrate your CLI to ESM while keeping individual plugins in CommonJS (or vice versa). The upgrade path is now much simpler for you. You also don't need to worry about any community plugins that have migrated to ESM before you did (such as all the @oclif plugins) or are staunchly sticking with CommonJS for the foreseeable future.
Read more about this topic here.
Improving and Revitalizing oclif.io​
Another area of focus for us has been improving our documentation site, oclif.io.
While improving the quality and accuracy of the documentation was our priority, we also took the time to upgrade to the latest version of docusaurus. This new version gave our site a much-needed facelift, as well as cool new features such as dark mode and announcements.
If you have any feedback or are running into issues, we want to hear about it. Just create an issue in the oclif.io repo.
Re-engaging the oclif Community​
Lastly, our biggest priority at the moment is to re-engage the oclif community. We understand how frustrating it has been over the years to see your issues and pull requests go unacknowledged. We apologize for not prioritizing the community, and are earnestly trying to make sure that every issue and pull request gets the attention it deserves going forward.
We also opened up GitHub discussions for @oclif/core and the oclif CLI, where you can now post your questions or ideas. We hope you take advantage of them, we love hearing from you!
One last thing: we intend to publicly post our roadmap so you have more visibility into what we're working on. Stay tuned!
All our best,
The oclif teamAnnouncing oclif v2!January 12, 2022 · 5 min readHello and happy new year! It's our great pleasure to announce that we have released oclif v2, which uses the new @oclif/core library! 🎉
oclif v2 includes many changes that improve the experience of both creating and using an oclif CLI.
Going forward, we don't plan to make any updates to oclif v1 and its corresponding libraries, except for critical security fixes. See the compatibility matrix for a list of these libraries. In order to give developers time to migrate from v1 to v2, we're not completely dropping support yet. But at some point in the future we'll archive the v1 repositories and deprecate their versions on npm.
What’s changing?​
Repository Changes​
All repositories under the oclif org now use main as their primary branch and oclif-v1 as the legacy branch. The main  branch corresponds to oclif v2 and the oclif-v1 branch to oclif v1. If you find any repos that don’t have a main branch, you can safely assume that they're not used in oclif v2 and will be deprecated in the future.
Consolidating Tools & Libraries​
The oclif-dev CLI has now been incorporated into oclif. You now no longer need to install a separate package to manage your entire CLI’s lifecycle.
The following libraries have been consolidated under @oclif/core and will be deprecated at some point in the future. Read the migration guide to learn how to update your CLI or plugin to use the new core library.

@oclif/command
@oclif/config
@oclif/error
@oclif/help
@oclif/parser

No more single vs multi command CLIs​
There's only one "type" of oclif v2 CLI, but it can have as few or as many commands as a developer wants. As a result, there’s only one command to generate CLIs, oclif generate, as opposed to the old oclif single and oclif multi commands.
Node > 12​
To ensure oclif CLIs are as secure as possible, all v2 libraries and plugins support only Node 12 or higher as of now. Going forward, they'll support only Node Maintenance or higher, as defined by Node's release schedule here: https://nodejs.org/en/about/releases/.
What’s new?​
New example CLI​
oclif-hello-world is our new example repo. This is also the repo that's used as a template when running oclif generate to create a new CLI. This repo will always be able to be referenced as an example of what an oclif v2 CLI should look like.
Spaced commands​
oclif CLIs can now use spaces, instead of colons, to separate topics and subcommands. To enable this feature, simply add “topicSeparator": " " to the oclif config in your package.json. See an example in our example repo.
// Old commands that use :$ mycli do:something
// New spaced commands$ mycli do something

Note: Spaced commands are backwards compatible. So if you enable spaced commands for your CLI, users will still be able to use : as a separator. This ensures that any existing scripts don't break.

New Help Output​
We’ve revamped the way command help is outputted to the terminal, making it both easier to implement and easier to read. See the difference between the old help output on the left and the new help output on the right in the screenshots below.
oclif v1oclif v2
Notice that there are new sections for flags and global flags, examples are displayed with better spacing, and there is a section at the bottom called Configuration Variables. This Configuration Variables section is not part of the new help by default. But we've added support for custom help sections, which is what the sf CLI uses to create the new section.
Async Command Parsing​
We’ve also improved the performance of new CLIs by rewriting how commands are parsed on initialization. The new parser is asynchronous, which makes CLIs with a lot of commands or installed  plugins much faster.
What’s coming next?​
Part of our charter for the release of oclif v2 includes improving our engagement with the oclif community. We know that over the past couple of years we’ve reduced our involvement, and a lot of issues and PRs have languished in limbo. Hopefully you’ve already seen increased activity and responses from oclif maintainers recently, but if you haven’t, please don’t hesitate to ping us by tagging @admins in oclif repos.
We also want to start interviewing members of the oclif community to acquire feedback and prioritize the features and fixes you deem most important!
Best,
The oclif team

Reference material​
Migration Guide​
This guide explains how to upgrade a CLI or plugin from the old oclif v1 libraries to the new @oclif/core library that oclif v2 uses.
https://github.com/oclif/core/blob/main/MIGRATION.md
Compatibility Matrix​
The following matrix shows how the v1 libraries and plugins relate to the new v2 ones. Use this matrix as a guide to know what to drop and which versions to switch when upgrading your plugins and CLIs to v2.
oclif "v1"oclif "v2"Utility CLIsoclif@<2@oclif/dev-cli@<2oclif@>=2Main packages@oclif/command@oclif/config@oclif/errors@oclif/parser@oclif/plugin-help@oclif/core@>=1Node LTSNode v8-14Node v12+ (at time of writing)TypeScripttypescript@<4typescript@>=4Main plugins@oclif/plugin-autocomplete@<1@oclif/plugin-commands@<2@oclif/plugin-help@<4@oclif/plugin-not-found@<2@oclif/plugin-plugins@<2@oclif/plugin-update@<2plugin-warn-if-update-available@<2plugin-which@<2@oclif/plugin-autocomplete@>=1@oclif/plugin-commands@>=2@oclif/plugin-help@>=4@oclif/plugin-not-found@>=2@oclif/plugin-plugins@>=2@oclif/plugin-update@>=2@oclif/plugin-warn-if-update-available@>=2@oclif/plugin-which@>=2Introducing @oclif/coreMarch 1, 2021 · 3 min readGreetings!
We hope this blog post finds you well.
Introducing...​
We are excited to announce the next iteration of the oclif project today: @oclif/core.
We have learned a lot in the last three years of developing oclif, developing on oclif and supporting millions of command runs a day via Heroku and Salesforce CLIs.
@oclif/core ("Core") simplifies the oclif development experience and introduces highly requested new features.
Core combines the essential oclif packages into one "core" package, aptly named @oclif/core.
Core also introduces:

A default command option
Colon or space command syntax
Async command parsing
Command piping to arguments

With the introduction of default command functionality, Core simplifies the oclif project and removes the notion of single or multi command CLIs. Core CLIs can have 1 or many commands.
Along with Core, we moved the oclif-dev CLI into the oclif CLI creating a single "utility" CLI. This CLI also introduces a new AWS S3 compatible publishing scheme.
What to expect in the near future​
Core is in pre-release beta and being actively developed for new internal Salesforce CLIs.
Much documentation needs to be written in the coming months including migration paths. Migration onto Core should be as painless as possible with many exports remaining entirely unchanged. Look for forthcoming blog posts and documentation on oclif.io.
Early this summer, tentively June 1, we will release Core v1. Core's release will coincide with major bumps to many other oclif plugin packages. See the compatibility matrix below.
At Core's v1 release, the current "main" oclif packages (namely: command, config, errors & parser) will go into maintenance mode until Jan 2022. They will receive only bug and security fixes and they remain compatible with current versions of the oclif and oclif-dev CLIs. Afterwhich, they will be archived.
Companioning Core, the next major release of the oclif CLI (literally oclif@2) will generate Core CLIs.
Going forward​
We are excited to release Core! We invite you to poke around the Core repo. It may appear to be a big change but Core keeps what you already enjoy about oclif while reducing development complexity, project dependencies, package coupling and bundle size and introduces many requested features previously too prickly to weave into the current oclif architecture.
Best,
The oclif team
Reference: Compatibility matrix​
oclif "v1"oclif "Core"Utility CLIsoclif@<2@oclif/dev-cli@<2oclif@>=2Main packages@oclif/core@<2@oclif/config@<2@oclif/errors@<2@oclif/parser@<4@oclif/plugin-help@<4@oclif/core@>=1Node LTSNode v8-14Node v12+TypeScripttypescript@<4typescript@>=4Main plugins@oclif/plugin-autocomplete@<1@oclif/plugin-commands@<2@oclif/plugin-help@<4@oclif/plugin-not-found@<2@oclif/plugin-plugins@<2@oclif/plugin-update@<2plugin-warn-if-update-available@<2plugin-which@<2@oclif/plugin-autocomplete@>=2@oclif/plugin-commands@>=2@oclif/plugin-help@>=4@oclif/plugin-not-found@>=2@oclif/plugin-plugins@>=2@oclif/plugin-update@>=2@oclif/plugin-warn-if-update-available@>=2@oclif/plugin-which@>=2oclif Summer 2020 UpdateAugust 26, 2020 · 2 min readHello oclif developers! We hope you are all doing well.
Earlier this year, we started our planning for oclifconf v2 and, like all conference, had to change course. We opted not to hold a virtual conference, however, we wanted to take some time to highlight a few oclif features shipped this year.
Feature: Help templating​
One of the most requested features, help templating enables oclif developers to customize the help output for their CLI.
Read the announcement.
Feature: Custom error delegation​
This feature both improved how oclif throws and handles errors and allows oclif developers to overwrite or interject in oclif’s error handling.
Read the announcement.
Feature: postrun hooks​
We have added a new lifecycle event postrun. Your CLI can now run a hook after a command has ran.
See our hook documentation.
Feature: Root index command​
Previously, oclif would display CLI help if only the binary name with no command ID was invoked, oclif now supports a "root index" command. If present, a command defined at src/commands/index.ts will be run if no command ID is found.
1 million weekly downloads​
While exact oclif usage metrics are hard to pin down, we use npm download statistics of oclif packages as a rough approximation. Earlier this year, oclif's command package hit 1 million weekly downloads for the first time!
This year has been presented its challenges on everyone. We want to thank you, oclif developers, whom have taken the time to use and improve the oclif project. We look forward to seeing you all - in person - in the future!
All our best,
The oclif teamPretty Printable ErrorsJuly 1, 2020 · One min readOften CLIs are used as handy tools and when things go wrong it’s useful to have additional context. In oclif we have added a couple of additional properties that can show extra context to the users when an error is displayed. The code, ref and suggestions will now be displayed if they are included. This will work with an existing oclif CLI by adding the latest @oclif/errors and @oclif/core to the CLI's package.json dependencies.
For example, using this.error with the additional properties:
class TestError extends Command {  async run() {    this.error("An error has occurred!", {      code: "OCLIF_ERR",      ref: "https://oclif.io/docs/commands#thiserrormessage-string--error-options-code-string-exit-number",      suggestions: ["Use these extra properties to provide additional context"],    })  }}
would result with the following output:
›   Error: An error has occurred!›   Code: OCLIF_ERR›   Try this: Use these extra properties to provide additional context›   Reference: https://oclif.io/docs/commands#thiserrormessage-string--error-options-code-string-exit-number
If these properties are not provided then nothing changes and the CLI will continue to display the single error message output as it did before. Additionally, as part of this exercise we’ve added documentation around Error Handling in oclif which should come in handy if the need arises to extend oclif’s default handling of errors.Customizing Help in oclifMay 5, 2020 · 2 min readOut of the box oclif provides a great help experience for CLIs.
But what if, as an oclif developer, you want to customize some or all of the output?
You can now customize your CLI's help output by implementing the HelpBase abstract class.
Getting started with custom help​
If you have not done so yet, update @oclif/core.
$ yarn add --latest @oclif/core
To get started, first define the filepath to your help class in oclif's config in package.json. This is a relative path to the help class, without a file extension.
For this example, the help class will be created in a file at "[project root]/src/help.ts".
{  // ...  "oclif": {    "helpClass": "./lib/help"    // ...  }  // ...}
From here there are two paths, implement the HelpBase abstract class yourself or overwrite the parts of the default Help class you want to customize (ex: how command usage is displayed). We recommend the latter approach but cover both in the new Help Classes docs.
Separating TOPICS & COMMANDS in the new default Help class​
Previously, topics and child commands were listed in help output under a single list heading called "COMMANDS". But we found this can be slightly confusing. Some topics are commands also (a.k.a. topic-commands) while others are simply organizational namespacing (and when ran just show their help).
The new default Help class splits the list of children into distinct lists of "TOPICS" and "COMMANDS", with the possibility of an item appearing in both if it a topic-command. This makes it clearer what is expected to be ran - "COMMANDS" - and what is providing structure - "TOPICS" - when looking at the help output.
VERSION  plugin-help-example/0.0.0 darwin-x64 node-v12.12.0USAGE  $ plugin-help-example [COMMAND]TOPICS  topic  this is a topic and has child topics or commandsCOMMANDS  hello  describe the command here  help   display help for plugin-help-example
We look forward to seeing what custom help features you implement in your oclif CLIs with this new feature!oclif TSLint to ESLint MigrationDecember 5, 2019 · 3 min readBack in February of this year, plans were announced to deprecate TSLint in favor of ESLint. TSLint's goal has become to work toward a “unified developer experience” by supporting ESLint development going forward.
What has changed in oclif​
To keep inline with the community, oclif has transitioned to ESLint for all our core libraries as well as all our official plugins.
Starting in v1.15.x, oclif will now optionally generate projects with ESLint for both TypeScript and JavaScript CLI’s.
ESLint does require Node to be on stable LTS version, at the time of writing, Node 8.10.x, Node 10.13.x & Node 12.x.x.
How does this affect you​
Existing CLI’s are unchanged, but any newly generated CLI's will only give the option of using ESLint. If you are running tslint in your CLI, we recommend you switch to ESLint as well.
In migrating our projects we took the following steps (for an example of these changes see this pull request).


Install eslint
$ yarn add eslint eslint-config-oclif eslint-config-oclif-typescript --dev


Add eslint related files


$ echo '{  "extends": [    "oclif",    "oclif-typescript"  ],  "rules": {  }}' > .eslintrc


Remove tslint and related packages
$ yarn remove @oclif/tslint tslint


Remove tslint related configuration files
$ rm tslint.json


Change lint script in our package.json from something like:
"lint": "tsc -p test --noEmit && tslint -p test -t stylish"
to
"lint": "eslint . --ext .ts --config .eslintrc"


To preserve the test compile (tsc -p test --noEmit) we also made the following updates to our scripts:
"pretest": "tsc -p test --noEmit"
In some cases we had our posttest duplicating the same steps as our lint script so it’s cleaner to have it reference the lint job directly with:
"posttest": "yarn lint"

Run yarn lint --fix. This attempts to auto-fix any linting violations automatically. In the case an auto-fix isn’t available it should be fixed manually or ignored (see the eslint configuration doc for more information)
Do a search in the codebase for tslint and remove any unnecessary tslint disabling comments, like:

/* tslint:disable:object-literal-sort-keys */
If you are on a version of Node that is not supported by ESLint, you will also need to update your Node engine. ESLint supports Node 8, 10, and 12 so you should upgrade to the most recent Node version compatible with your CLI and also supported by ESLint (see ESLint's Installation and Usage instructions).
When will this take effect​
These changes have taken effect in oclif v1.15.1. When you generate a new CLI or plugin it will now contain configuration for ESLint instead of TSLint.oclif's Current Node SupportOctober 31, 2019 · 3 min readTo maintain a healthy project trajectory, oclif follows and supports Node Active LTS release, currently Node 10 & Node 12. This means ensuring that oclif continues to play nice with coming Active LTS Node versions and other packages in the ecosystem. Moving forward also means leaving older versions behind. Starting in 2020, Node will stop maintaining Node 8 and it is our intent at that time to also follow suit. Let’s take a look at a few ways we will be supporting these changes.
CI Environments​
CLIs created with the oclif cli going forward will be generated with a CircleCI configuration with Node 10 & 12 and an Appveyor configuration using Node 10. We have also added Node latest to CircleCi to be an early warning detection against coming Node changes (Node latest is managed by CircleCI).
We have already updated every oclif repo's CI configs to reflect this.
If your existing CLI uses either Appveyor or CircleCI you can update your config files also, like so:
.circleci/config.yml​
Your CircleCI config should contain a node-latest job, aliased as test. From this, there should be two extensions of this job for the Active LTS Node versions, Node 10 and Node 12.
  node-10:    <<: *node-latest    docker:      - image: node:10  node-12:    <<: *node-latest    docker:      - image: node:12
Notice that these declarations only change the Docker Node images used to run that job.
Additionally, the jobs listed within workflows must also be updated to reflect our changes in configuration:
    jobs:      - node-latest      - node-10      - node-12
appveyor.yml​
For appveyor we are currently only testing the oldest Active LTS Node version, Node 10. Update the nodejs_version proppert in your appveyor.yml file to reflect this.
environment:  nodejs_version: "10"
Deprecating Node 8 & Updating packge.json engines​
In Jan 2020, Node will end its Node 8 maintenance. We will follow suit by setting the package.json engine property in oclif packages to >=10 and bumping the package's major versions.
Depending on how you ship your CLI you may wish to also bump the engines version in your CLI's package.json. You can read more about the implications of the engines property configuration in the npm documentation.
Also consider distributing your CLI with its own Node version.
Packaged Node Version​
When using dev-cli to pack your CLI it will use the Node version as specified in your package.json under the oclif.update.node.version property. This value should reflect an Active LTS Node version (dev-cli does not currently enforce versions).
Supporting the future​
As a community we may discover bumps along the way as we upgrade. If you notice something related to oclif please feel free to open an issue or submit a pull request under the relevant oclif package within the org.
We look forward to using the latest from Node and the community and keeping oclif healthy along the way.oclifconf 2019: A RecapSeptember 16, 2019 · 4 min readIn May, Heroku and Salesforce Open Source organized oclifconf, a conference for developers & product managers building CLI tools on top of the open source oclif framework. The speakers came from various tech companies, such as Adobe, Netlify, and Apollo, who have already built amazing CLI experiences. The topics covered everything from the incredible capabilities oclif has unlocked, to the community-built plugins extending its functionality, and even what the behavior of an adaptive CLI tool might look like.
Below is a listing of all of the talks from the event, along with a short summary. Enjoy!
The future of oclif by Jeff Dickey​

In its relatively short lifetime, oclif has already inspired many developers and companies to adopt its framework as a means for implementing their own command-line tooling. In this talk, Jeff Dickey, an oclif founding team member, recaps the project's history and inspiration. He also looks towards the future and outlines some features and improvements that the tool could adapt. This isn't so much a definitive roadmap of where oclif is headed, but rather, a call to inspiration for developers eager to contribute! And if you are interested in contributing, check out the open issues in the oclif GitHub repo and come say "Hello!" on Spectrum Chat.
Open Source Citizenship by Josh Simmons​

When it comes to open source, it's more than just individuals now. More and more frequently, large corporations are contributing to projects by donating to contributors, sponsoring events, or upstreaming contributions. But keeping open source projects and communities healthy requires more than just money and brainpower. Josh Simmons surveyed multiple open source communities and relays his findings as to what help maintainers and contributors actually need in this talk.
Building an enterprise-grade CLI with oclif by Thomas Dvornik​

Security and performance are all about trust. While oclif is an extremely extensible framework for building CLI tooling, there are additional requirements to fulfill for enterprise businesses to adopt it that might not be necessary for individual developers. Thomas Dvornik outlines what he and his colleagues at Salesforce have implemented as plugins to oclif to satisfy these needs, including encrypted OAuth, plugin signing, lazy loading dependencies, synchronizing weekly releases and deprecations across dozens of repositories, and establishing cross-team coding and documentation standards.
How Adobe I/O built an extensible CLI with oclif by Jesse MacFadyen​

Perhaps oclif's most appealing feature is its support for plugins. In Cordova's case, they've created a sophisticated telemetry system that helps Adobe developers see which commands users are using--and reports on which ones are erroring out. By embedding a feedback system into the tool, users are even able to quickly send their suggestions to a form, without ever leaving the terminal. Jesse MacFadyen demonstrates how oclif's plugin system can work beyond simply executing commands.
Integrating oclif with GraphQL and Apollo by Evans Hauser​

For Evans Hauser and the team at Apollo, oclif is best thought of as "React for the CLI." As a client paired with a strongly-typed API contract to a server, it can deliver structured and consistent commands to retrieve external data. What better mechanism to use for this transfer than GraphQL, a framework which empowers the client to ask precisely for the data it needs, and nothing more?
Adaptive Intent-based CLI State Machines by Shawn Wang​

In designing oclif, Jeff Dickey wrote out 12 CLI factors to keep in mind. In this talk, Shawn Wang outlines a 13th: state. State is hard, because it depends on context, and context depends on understanding what a user intends to do, not what they are asking. Shawn is working towards enabling oclif to better understand the commands a user has entered, so that it can predict and interpret future commands that might be entered next. This would enable CLI tools to not just interpret a users' commands, but to also interpret their intent.\n\nIntroducing `oclif init` commandApril 10, 2024 · 2 min readThanks to the contribution of @joshcanhelp we released a new command for the oclif CLI called oclif init in version 4.8.0
The oclif init command allows you to initialize oclif in an existing project directory by adding the bare minimum requirements: a few pieces of configuration, bin scripts, and a couple of dependencies (@oclif/core and ts-node). This is slightly different from oclif generate, which will create an entirely new oclif project based on our templates.
oclif init will add the following:

bin scripts: bin/run.js, bin/run.cmd, bin/dev.js, and bin/dev.cmd
oclif section to package.json with bin, dirname, commands, and topicSeparator set (See Configuring Your CLI for more)
@oclif/core to dependencies in your package.json (if it's not already there)
ts-node to devDependencies in your package.json (if it's not already there)

Once you've initialized oclif, you can use the bin scripts to execute your CLI. You can also use the other oclif commands like oclif generate command and oclif generate hook to start adding new functionality.

❯ oclif init --helpInitialize a new oclif CLIUSAGE  $ oclif init [--bin <value>] [--module-type ESM|CommonJS] [--package-manager npm|yarn|pnpm] [--topic-separator    colons|spaces] [-d <value>] [-y]FLAGS  -d, --output-dir=<value>        Directory to initialize the CLI in.  -y, --yes                       Use defaults for all prompts. Individual flags will override defaults.      --bin=<value>               Supply answer for prompt: Command bin name the CLI will export      --module-type=<option>      Supply answer for prompt: Select a module type                                  <options: ESM|CommonJS>      --package-manager=<option>  Supply answer for prompt: Select a package manager                                  <options: npm|yarn|pnpm>      --topic-separator=<option>  Supply answer for prompt: Select a topic separator                                  <options: colons|spaces>DESCRIPTION  Initialize a new oclif CLI  This will add the necessary oclif bin files, add oclif config to package.json, and install @oclif/core and ts-node.EXAMPLES  Initialize a new CLI in the current directory    $ oclif init  Initialize a new CLI in a different directory    $ oclif init --output-dir "/path/to/existing/project"  Supply answers for specific prompts    $ oclif init --topic-separator colons --bin mycli
Hope you enjoy the new command! If you come across any issues or have any new ideas for this command, head over to the oclif/oclif repo and open a new issue.
All our best,
The oclif teamoclif Spring 2024 UpdateMarch 29, 2024 · 4 min readHello oclif developers! It's been a while since we last uploaded a blog - and a lot has happened.
We've been focusing on these high-level areas over the past couple of years:

Improving @oclif/core
ESM Support
Improving and revitalizing oclif.io
Re-engaging the oclif community

Improving @oclif/core​
Since we announced @oclif/core over three years ago, we've released two new major versions, each packed with lots of features that we're really excited about.
Here are some of these changes:

Full support for ESM and interoperability with CommonJS (more on this topic below).
Configurable command discovery strategies that give you more control over how commands are loaded at runtime. Check out the docs.
A new preparse hook that allows you to manipulate the provided arguments before they're parsed. Salesforce used this hook to implement a neat --flags-dir feature that translates local files into flags.
A new Performance class that you can use to track performance inside of @oclif/core and your own CLI or plugin. Check out the docs.
A new flag type, Flags.option, that lets you define a flag with a preset list of options. Typescript then uses the options to infer the flag's type.
Flags now have a relationship property that allows you to define more complex relationships between flags. Check out the flags docs for more information.
Flags now have a defaultHelp property that allows you to set the human readable default value in the command help. This property is useful when your flag's parse method returns a complex type, such as an object or a class. Check out the flags docs for more.
Commands now have a hiddenAliases property that allows you to define aliases that you want to hide from the user. The property is super helpful when you're trying to wean users off a deprecated command.
You can now use bun or tsx as dev runtimes (as opposed to node or ts-node).
A command's usage, args, and flags are now shown whenever a user forgets to provide a required arg or flag, or when they provided a non-existent flag.

If you need help migrating to the latest version, head over to core's README which has links to the migration guides. Feel free to open a new discussion if you need more hands-on help from us or the community.
ESM Support​
Version 3 of @oclif/core introduced full support for developing ESM plugins and CLIs. It also offered full support for interoperability between CommonJS and ESM plugins.
Put more simply, you can now migrate your CLI to ESM while keeping individual plugins in CommonJS (or vice versa). The upgrade path is now much simpler for you. You also don't need to worry about any community plugins that have migrated to ESM before you did (such as all the @oclif plugins) or are staunchly sticking with CommonJS for the foreseeable future.
Read more about this topic here.
Improving and Revitalizing oclif.io​
Another area of focus for us has been improving our documentation site, oclif.io.
While improving the quality and accuracy of the documentation was our priority, we also took the time to upgrade to the latest version of docusaurus. This new version gave our site a much-needed facelift, as well as cool new features such as dark mode and announcements.
If you have any feedback or are running into issues, we want to hear about it. Just create an issue in the oclif.io repo.
Re-engaging the oclif Community​
Lastly, our biggest priority at the moment is to re-engage the oclif community. We understand how frustrating it has been over the years to see your issues and pull requests go unacknowledged. We apologize for not prioritizing the community, and are earnestly trying to make sure that every issue and pull request gets the attention it deserves going forward.
We also opened up GitHub discussions for @oclif/core and the oclif CLI, where you can now post your questions or ideas. We hope you take advantage of them, we love hearing from you!
One last thing: we intend to publicly post our roadmap so you have more visibility into what we're working on. Stay tuned!
All our best,
The oclif teamAnnouncing oclif v2!January 12, 2022 · 5 min readHello and happy new year! It's our great pleasure to announce that we have released oclif v2, which uses the new @oclif/core library! 🎉
oclif v2 includes many changes that improve the experience of both creating and using an oclif CLI.
Going forward, we don't plan to make any updates to oclif v1 and its corresponding libraries, except for critical security fixes. See the compatibility matrix for a list of these libraries. In order to give developers time to migrate from v1 to v2, we're not completely dropping support yet. But at some point in the future we'll archive the v1 repositories and deprecate their versions on npm.
What’s changing?​
Repository Changes​
All repositories under the oclif org now use main as their primary branch and oclif-v1 as the legacy branch. The main  branch corresponds to oclif v2 and the oclif-v1 branch to oclif v1. If you find any repos that don’t have a main branch, you can safely assume that they're not used in oclif v2 and will be deprecated in the future.
Consolidating Tools & Libraries​
The oclif-dev CLI has now been incorporated into oclif. You now no longer need to install a separate package to manage your entire CLI’s lifecycle.
The following libraries have been consolidated under @oclif/core and will be deprecated at some point in the future. Read the migration guide to learn how to update your CLI or plugin to use the new core library.

@oclif/command
@oclif/config
@oclif/error
@oclif/help
@oclif/parser

No more single vs multi command CLIs​
There's only one "type" of oclif v2 CLI, but it can have as few or as many commands as a developer wants. As a result, there’s only one command to generate CLIs, oclif generate, as opposed to the old oclif single and oclif multi commands.
Node > 12​
To ensure oclif CLIs are as secure as possible, all v2 libraries and plugins support only Node 12 or higher as of now. Going forward, they'll support only Node Maintenance or higher, as defined by Node's release schedule here: https://nodejs.org/en/about/releases/.
What’s new?​
New example CLI​
oclif-hello-world is our new example repo. This is also the repo that's used as a template when running oclif generate to create a new CLI. This repo will always be able to be referenced as an example of what an oclif v2 CLI should look like.
Spaced commands​
oclif CLIs can now use spaces, instead of colons, to separate topics and subcommands. To enable this feature, simply add “topicSeparator": " " to the oclif config in your package.json. See an example in our example repo.
// Old commands that use :$ mycli do:something
// New spaced commands$ mycli do something

Note: Spaced commands are backwards compatible. So if you enable spaced commands for your CLI, users will still be able to use : as a separator. This ensures that any existing scripts don't break.

New Help Output​
We’ve revamped the way command help is outputted to the terminal, making it both easier to implement and easier to read. See the difference between the old help output on the left and the new help output on the right in the screenshots below.
oclif v1oclif v2
Notice that there are new sections for flags and global flags, examples are displayed with better spacing, and there is a section at the bottom called Configuration Variables. This Configuration Variables section is not part of the new help by default. But we've added support for custom help sections, which is what the sf CLI uses to create the new section.
Async Command Parsing​
We’ve also improved the performance of new CLIs by rewriting how commands are parsed on initialization. The new parser is asynchronous, which makes CLIs with a lot of commands or installed  plugins much faster.
What’s coming next?​
Part of our charter for the release of oclif v2 includes improving our engagement with the oclif community. We know that over the past couple of years we’ve reduced our involvement, and a lot of issues and PRs have languished in limbo. Hopefully you’ve already seen increased activity and responses from oclif maintainers recently, but if you haven’t, please don’t hesitate to ping us by tagging @admins in oclif repos.
We also want to start interviewing members of the oclif community to acquire feedback and prioritize the features and fixes you deem most important!
Best,
The oclif team

Reference material​
Migration Guide​
This guide explains how to upgrade a CLI or plugin from the old oclif v1 libraries to the new @oclif/core library that oclif v2 uses.
https://github.com/oclif/core/blob/main/MIGRATION.md
Compatibility Matrix​
The following matrix shows how the v1 libraries and plugins relate to the new v2 ones. Use this matrix as a guide to know what to drop and which versions to switch when upgrading your plugins and CLIs to v2.
oclif "v1"oclif "v2"Utility CLIsoclif@<2@oclif/dev-cli@<2oclif@>=2Main packages@oclif/command@oclif/config@oclif/errors@oclif/parser@oclif/plugin-help@oclif/core@>=1Node LTSNode v8-14Node v12+ (at time of writing)TypeScripttypescript@<4typescript@>=4Main plugins@oclif/plugin-autocomplete@<1@oclif/plugin-commands@<2@oclif/plugin-help@<4@oclif/plugin-not-found@<2@oclif/plugin-plugins@<2@oclif/plugin-update@<2plugin-warn-if-update-available@<2plugin-which@<2@oclif/plugin-autocomplete@>=1@oclif/plugin-commands@>=2@oclif/plugin-help@>=4@oclif/plugin-not-found@>=2@oclif/plugin-plugins@>=2@oclif/plugin-update@>=2@oclif/plugin-warn-if-update-available@>=2@oclif/plugin-which@>=2Introducing @oclif/coreMarch 1, 2021 · 3 min readGreetings!
We hope this blog post finds you well.
Introducing...​
We are excited to announce the next iteration of the oclif project today: @oclif/core.
We have learned a lot in the last three years of developing oclif, developing on oclif and supporting millions of command runs a day via Heroku and Salesforce CLIs.
@oclif/core ("Core") simplifies the oclif development experience and introduces highly requested new features.
Core combines the essential oclif packages into one "core" package, aptly named @oclif/core.
Core also introduces:

A default command option
Colon or space command syntax
Async command parsing
Command piping to arguments

With the introduction of default command functionality, Core simplifies the oclif project and removes the notion of single or multi command CLIs. Core CLIs can have 1 or many commands.
Along with Core, we moved the oclif-dev CLI into the oclif CLI creating a single "utility" CLI. This CLI also introduces a new AWS S3 compatible publishing scheme.
What to expect in the near future​
Core is in pre-release beta and being actively developed for new internal Salesforce CLIs.
Much documentation needs to be written in the coming months including migration paths. Migration onto Core should be as painless as possible with many exports remaining entirely unchanged. Look for forthcoming blog posts and documentation on oclif.io.
Early this summer, tentively June 1, we will release Core v1. Core's release will coincide with major bumps to many other oclif plugin packages. See the compatibility matrix below.
At Core's v1 release, the current "main" oclif packages (namely: command, config, errors & parser) will go into maintenance mode until Jan 2022. They will receive only bug and security fixes and they remain compatible with current versions of the oclif and oclif-dev CLIs. Afterwhich, they will be archived.
Companioning Core, the next major release of the oclif CLI (literally oclif@2) will generate Core CLIs.
Going forward​
We are excited to release Core! We invite you to poke around the Core repo. It may appear to be a big change but Core keeps what you already enjoy about oclif while reducing development complexity, project dependencies, package coupling and bundle size and introduces many requested features previously too prickly to weave into the current oclif architecture.
Best,
The oclif team
Reference: Compatibility matrix​
oclif "v1"oclif "Core"Utility CLIsoclif@<2@oclif/dev-cli@<2oclif@>=2Main packages@oclif/core@<2@oclif/config@<2@oclif/errors@<2@oclif/parser@<4@oclif/plugin-help@<4@oclif/core@>=1Node LTSNode v8-14Node v12+TypeScripttypescript@<4typescript@>=4Main plugins@oclif/plugin-autocomplete@<1@oclif/plugin-commands@<2@oclif/plugin-help@<4@oclif/plugin-not-found@<2@oclif/plugin-plugins@<2@oclif/plugin-update@<2plugin-warn-if-update-available@<2plugin-which@<2@oclif/plugin-autocomplete@>=2@oclif/plugin-commands@>=2@oclif/plugin-help@>=4@oclif/plugin-not-found@>=2@oclif/plugin-plugins@>=2@oclif/plugin-update@>=2@oclif/plugin-warn-if-update-available@>=2@oclif/plugin-which@>=2oclif Summer 2020 UpdateAugust 26, 2020 · 2 min readHello oclif developers! We hope you are all doing well.
Earlier this year, we started our planning for oclifconf v2 and, like all conference, had to change course. We opted not to hold a virtual conference, however, we wanted to take some time to highlight a few oclif features shipped this year.
Feature: Help templating​
One of the most requested features, help templating enables oclif developers to customize the help output for their CLI.
Read the announcement.
Feature: Custom error delegation​
This feature both improved how oclif throws and handles errors and allows oclif developers to overwrite or interject in oclif’s error handling.
Read the announcement.
Feature: postrun hooks​
We have added a new lifecycle event postrun. Your CLI can now run a hook after a command has ran.
See our hook documentation.
Feature: Root index command​
Previously, oclif would display CLI help if only the binary name with no command ID was invoked, oclif now supports a "root index" command. If present, a command defined at src/commands/index.ts will be run if no command ID is found.
1 million weekly downloads​
While exact oclif usage metrics are hard to pin down, we use npm download statistics of oclif packages as a rough approximation. Earlier this year, oclif's command package hit 1 million weekly downloads for the first time!
This year has been presented its challenges on everyone. We want to thank you, oclif developers, whom have taken the time to use and improve the oclif project. We look forward to seeing you all - in person - in the future!
All our best,
The oclif teamPretty Printable ErrorsJuly 1, 2020 · One min readOften CLIs are used as handy tools and when things go wrong it’s useful to have additional context. In oclif we have added a couple of additional properties that can show extra context to the users when an error is displayed. The code, ref and suggestions will now be displayed if they are included. This will work with an existing oclif CLI by adding the latest @oclif/errors and @oclif/core to the CLI's package.json dependencies.
For example, using this.error with the additional properties:
class TestError extends Command {  async run() {    this.error("An error has occurred!", {      code: "OCLIF_ERR",      ref: "https://oclif.io/docs/commands#thiserrormessage-string--error-options-code-string-exit-number",      suggestions: ["Use these extra properties to provide additional context"],    })  }}
would result with the following output:
›   Error: An error has occurred!›   Code: OCLIF_ERR›   Try this: Use these extra properties to provide additional context›   Reference: https://oclif.io/docs/commands#thiserrormessage-string--error-options-code-string-exit-number
If these properties are not provided then nothing changes and the CLI will continue to display the single error message output as it did before. Additionally, as part of this exercise we’ve added documentation around Error Handling in oclif which should come in handy if the need arises to extend oclif’s default handling of errors.Customizing Help in oclifMay 5, 2020 · 2 min readOut of the box oclif provides a great help experience for CLIs.
But what if, as an oclif developer, you want to customize some or all of the output?
You can now customize your CLI's help output by implementing the HelpBase abstract class.
Getting started with custom help​
If you have not done so yet, update @oclif/core.
$ yarn add --latest @oclif/core
To get started, first define the filepath to your help class in oclif's config in package.json. This is a relative path to the help class, without a file extension.
For this example, the help class will be created in a file at "[project root]/src/help.ts".
{  // ...  "oclif": {    "helpClass": "./lib/help"    // ...  }  // ...}
From here there are two paths, implement the HelpBase abstract class yourself or overwrite the parts of the default Help class you want to customize (ex: how command usage is displayed). We recommend the latter approach but cover both in the new Help Classes docs.
Separating TOPICS & COMMANDS in the new default Help class​
Previously, topics and child commands were listed in help output under a single list heading called "COMMANDS". But we found this can be slightly confusing. Some topics are commands also (a.k.a. topic-commands) while others are simply organizational namespacing (and when ran just show their help).
The new default Help class splits the list of children into distinct lists of "TOPICS" and "COMMANDS", with the possibility of an item appearing in both if it a topic-command. This makes it clearer what is expected to be ran - "COMMANDS" - and what is providing structure - "TOPICS" - when looking at the help output.
VERSION  plugin-help-example/0.0.0 darwin-x64 node-v12.12.0USAGE  $ plugin-help-example [COMMAND]TOPICS  topic  this is a topic and has child topics or commandsCOMMANDS  hello  describe the command here  help   display help for plugin-help-example
We look forward to seeing what custom help features you implement in your oclif CLIs with this new feature!oclif TSLint to ESLint MigrationDecember 5, 2019 · 3 min readBack in February of this year, plans were announced to deprecate TSLint in favor of ESLint. TSLint's goal has become to work toward a “unified developer experience” by supporting ESLint development going forward.
What has changed in oclif​
To keep inline with the community, oclif has transitioned to ESLint for all our core libraries as well as all our official plugins.
Starting in v1.15.x, oclif will now optionally generate projects with ESLint for both TypeScript and JavaScript CLI’s.
ESLint does require Node to be on stable LTS version, at the time of writing, Node 8.10.x, Node 10.13.x & Node 12.x.x.
How does this affect you​
Existing CLI’s are unchanged, but any newly generated CLI's will only give the option of using ESLint. If you are running tslint in your CLI, we recommend you switch to ESLint as well.
In migrating our projects we took the following steps (for an example of these changes see this pull request).


Install eslint
$ yarn add eslint eslint-config-oclif eslint-config-oclif-typescript --dev


Add eslint related files


$ echo '{  "extends": [    "oclif",    "oclif-typescript"  ],  "rules": {  }}' > .eslintrc


Remove tslint and related packages
$ yarn remove @oclif/tslint tslint


Remove tslint related configuration files
$ rm tslint.json


Change lint script in our package.json from something like:
"lint": "tsc -p test --noEmit && tslint -p test -t stylish"
to
"lint": "eslint . --ext .ts --config .eslintrc"


To preserve the test compile (tsc -p test --noEmit) we also made the following updates to our scripts:
"pretest": "tsc -p test --noEmit"
In some cases we had our posttest duplicating the same steps as our lint script so it’s cleaner to have it reference the lint job directly with:
"posttest": "yarn lint"

Run yarn lint --fix. This attempts to auto-fix any linting violations automatically. In the case an auto-fix isn’t available it should be fixed manually or ignored (see the eslint configuration doc for more information)
Do a search in the codebase for tslint and remove any unnecessary tslint disabling comments, like:

/* tslint:disable:object-literal-sort-keys */
If you are on a version of Node that is not supported by ESLint, you will also need to update your Node engine. ESLint supports Node 8, 10, and 12 so you should upgrade to the most recent Node version compatible with your CLI and also supported by ESLint (see ESLint's Installation and Usage instructions).
When will this take effect​
These changes have taken effect in oclif v1.15.1. When you generate a new CLI or plugin it will now contain configuration for ESLint instead of TSLint.oclif's Current Node SupportOctober 31, 2019 · 3 min readTo maintain a healthy project trajectory, oclif follows and supports Node Active LTS release, currently Node 10 & Node 12. This means ensuring that oclif continues to play nice with coming Active LTS Node versions and other packages in the ecosystem. Moving forward also means leaving older versions behind. Starting in 2020, Node will stop maintaining Node 8 and it is our intent at that time to also follow suit. Let’s take a look at a few ways we will be supporting these changes.
CI Environments​
CLIs created with the oclif cli going forward will be generated with a CircleCI configuration with Node 10 & 12 and an Appveyor configuration using Node 10. We have also added Node latest to CircleCi to be an early warning detection against coming Node changes (Node latest is managed by CircleCI).
We have already updated every oclif repo's CI configs to reflect this.
If your existing CLI uses either Appveyor or CircleCI you can update your config files also, like so:
.circleci/config.yml​
Your CircleCI config should contain a node-latest job, aliased as test. From this, there should be two extensions of this job for the Active LTS Node versions, Node 10 and Node 12.
  node-10:    <<: *node-latest    docker:      - image: node:10  node-12:    <<: *node-latest    docker:      - image: node:12
Notice that these declarations only change the Docker Node images used to run that job.
Additionally, the jobs listed within workflows must also be updated to reflect our changes in configuration:
    jobs:      - node-latest      - node-10      - node-12
appveyor.yml​
For appveyor we are currently only testing the oldest Active LTS Node version, Node 10. Update the nodejs_version proppert in your appveyor.yml file to reflect this.
environment:  nodejs_version: "10"
Deprecating Node 8 & Updating packge.json engines​
In Jan 2020, Node will end its Node 8 maintenance. We will follow suit by setting the package.json engine property in oclif packages to >=10 and bumping the package's major versions.
Depending on how you ship your CLI you may wish to also bump the engines version in your CLI's package.json. You can read more about the implications of the engines property configuration in the npm documentation.
Also consider distributing your CLI with its own Node version.
Packaged Node Version​
When using dev-cli to pack your CLI it will use the Node version as specified in your package.json under the oclif.update.node.version property. This value should reflect an Active LTS Node version (dev-cli does not currently enforce versions).
Supporting the future​
As a community we may discover bumps along the way as we upgrade. If you notice something related to oclif please feel free to open an issue or submit a pull request under the relevant oclif package within the org.
We look forward to using the latest from Node and the community and keeping oclif healthy along the way.oclifconf 2019: A RecapSeptember 16, 2019 · 4 min readIn May, Heroku and Salesforce Open Source organized oclifconf, a conference for developers & product managers building CLI tools on top of the open source oclif framework. The speakers came from various tech companies, such as Adobe, Netlify, and Apollo, who have already built amazing CLI experiences. The topics covered everything from the incredible capabilities oclif has unlocked, to the community-built plugins extending its functionality, and even what the behavior of an adaptive CLI tool might look like.
Below is a listing of all of the talks from the event, along with a short summary. Enjoy!
The future of oclif by Jeff Dickey​

In its relatively short lifetime, oclif has already inspired many developers and companies to adopt its framework as a means for implementing their own command-line tooling. In this talk, Jeff Dickey, an oclif founding team member, recaps the project's history and inspiration. He also looks towards the future and outlines some features and improvements that the tool could adapt. This isn't so much a definitive roadmap of where oclif is headed, but rather, a call to inspiration for developers eager to contribute! And if you are interested in contributing, check out the open issues in the oclif GitHub repo and come say "Hello!" on Spectrum Chat.
Open Source Citizenship by Josh Simmons​

When it comes to open source, it's more than just individuals now. More and more frequently, large corporations are contributing to projects by donating to contributors, sponsoring events, or upstreaming contributions. But keeping open source projects and communities healthy requires more than just money and brainpower. Josh Simmons surveyed multiple open source communities and relays his findings as to what help maintainers and contributors actually need in this talk.
Building an enterprise-grade CLI with oclif by Thomas Dvornik​

Security and performance are all about trust. While oclif is an extremely extensible framework for building CLI tooling, there are additional requirements to fulfill for enterprise businesses to adopt it that might not be necessary for individual developers. Thomas Dvornik outlines what he and his colleagues at Salesforce have implemented as plugins to oclif to satisfy these needs, including encrypted OAuth, plugin signing, lazy loading dependencies, synchronizing weekly releases and deprecations across dozens of repositories, and establishing cross-team coding and documentation standards.
How Adobe I/O built an extensible CLI with oclif by Jesse MacFadyen​

Perhaps oclif's most appealing feature is its support for plugins. In Cordova's case, they've created a sophisticated telemetry system that helps Adobe developers see which commands users are using--and reports on which ones are erroring out. By embedding a feedback system into the tool, users are even able to quickly send their suggestions to a form, without ever leaving the terminal. Jesse MacFadyen demonstrates how oclif's plugin system can work beyond simply executing commands.
Integrating oclif with GraphQL and Apollo by Evans Hauser​

For Evans Hauser and the team at Apollo, oclif is best thought of as "React for the CLI." As a client paired with a strongly-typed API contract to a server, it can deliver structured and consistent commands to retrieve external data. What better mechanism to use for this transfer than GraphQL, a framework which empowers the client to ask precisely for the data it needs, and nothing more?
Adaptive Intent-based CLI State Machines by Shawn Wang​

In designing oclif, Jeff Dickey wrote out 12 CLI factors to keep in mind. In this talk, Shawn Wang outlines a 13th: state. State is hard, because it depends on context, and context depends on understanding what a user intends to do, not what they are asking. Shawn is working towards enabling oclif to better understand the commands a user has entered, so that it can predict and interpret future commands that might be entered next. This would enable CLI tools to not just interpret a users' commands, but to also interpret their intent.Older Entries\n\n\n\nIntroducing `oclif init` commandApril 10, 2024 · 2 min readThanks to the contribution of @joshcanhelp we released a new command for the oclif CLI called oclif init in version 4.8.0
The oclif init command allows you to initialize oclif in an existing project directory by adding the bare minimum requirements: a few pieces of configuration, bin scripts, and a couple of dependencies (@oclif/core and ts-node). This is slightly different from oclif generate, which will create an entirely new oclif project based on our templates.
oclif init will add the following:

bin scripts: bin/run.js, bin/run.cmd, bin/dev.js, and bin/dev.cmd
oclif section to package.json with bin, dirname, commands, and topicSeparator set (See Configuring Your CLI for more)
@oclif/core to dependencies in your package.json (if it's not already there)
ts-node to devDependencies in your package.json (if it's not already there)

Once you've initialized oclif, you can use the bin scripts to execute your CLI. You can also use the other oclif commands like oclif generate command and oclif generate hook to start adding new functionality.

❯ oclif init --helpInitialize a new oclif CLIUSAGE  $ oclif init [--bin <value>] [--module-type ESM|CommonJS] [--package-manager npm|yarn|pnpm] [--topic-separator    colons|spaces] [-d <value>] [-y]FLAGS  -d, --output-dir=<value>        Directory to initialize the CLI in.  -y, --yes                       Use defaults for all prompts. Individual flags will override defaults.      --bin=<value>               Supply answer for prompt: Command bin name the CLI will export      --module-type=<option>      Supply answer for prompt: Select a module type                                  <options: ESM|CommonJS>      --package-manager=<option>  Supply answer for prompt: Select a package manager                                  <options: npm|yarn|pnpm>      --topic-separator=<option>  Supply answer for prompt: Select a topic separator                                  <options: colons|spaces>DESCRIPTION  Initialize a new oclif CLI  This will add the necessary oclif bin files, add oclif config to package.json, and install @oclif/core and ts-node.EXAMPLES  Initialize a new CLI in the current directory    $ oclif init  Initialize a new CLI in a different directory    $ oclif init --output-dir "/path/to/existing/project"  Supply answers for specific prompts    $ oclif init --topic-separator colons --bin mycli
Hope you enjoy the new command! If you come across any issues or have any new ideas for this command, head over to the oclif/oclif repo and open a new issue.
All our best,
The oclif teamoclif Spring 2024 UpdateMarch 29, 2024 · 4 min readHello oclif developers! It's been a while since we last uploaded a blog - and a lot has happened.
We've been focusing on these high-level areas over the past couple of years:

Improving @oclif/core
ESM Support
Improving and revitalizing oclif.io
Re-engaging the oclif community

Improving @oclif/core​
Since we announced @oclif/core over three years ago, we've released two new major versions, each packed with lots of features that we're really excited about.
Here are some of these changes:

Full support for ESM and interoperability with CommonJS (more on this topic below).
Configurable command discovery strategies that give you more control over how commands are loaded at runtime. Check out the docs.
A new preparse hook that allows you to manipulate the provided arguments before they're parsed. Salesforce used this hook to implement a neat --flags-dir feature that translates local files into flags.
A new Performance class that you can use to track performance inside of @oclif/core and your own CLI or plugin. Check out the docs.
A new flag type, Flags.option, that lets you define a flag with a preset list of options. Typescript then uses the options to infer the flag's type.
Flags now have a relationship property that allows you to define more complex relationships between flags. Check out the flags docs for more information.
Flags now have a defaultHelp property that allows you to set the human readable default value in the command help. This property is useful when your flag's parse method returns a complex type, such as an object or a class. Check out the flags docs for more.
Commands now have a hiddenAliases property that allows you to define aliases that you want to hide from the user. The property is super helpful when you're trying to wean users off a deprecated command.
You can now use bun or tsx as dev runtimes (as opposed to node or ts-node).
A command's usage, args, and flags are now shown whenever a user forgets to provide a required arg or flag, or when they provided a non-existent flag.

If you need help migrating to the latest version, head over to core's README which has links to the migration guides. Feel free to open a new discussion if you need more hands-on help from us or the community.
ESM Support​
Version 3 of @oclif/core introduced full support for developing ESM plugins and CLIs. It also offered full support for interoperability between CommonJS and ESM plugins.
Put more simply, you can now migrate your CLI to ESM while keeping individual plugins in CommonJS (or vice versa). The upgrade path is now much simpler for you. You also don't need to worry about any community plugins that have migrated to ESM before you did (such as all the @oclif plugins) or are staunchly sticking with CommonJS for the foreseeable future.
Read more about this topic here.
Improving and Revitalizing oclif.io​
Another area of focus for us has been improving our documentation site, oclif.io.
While improving the quality and accuracy of the documentation was our priority, we also took the time to upgrade to the latest version of docusaurus. This new version gave our site a much-needed facelift, as well as cool new features such as dark mode and announcements.
If you have any feedback or are running into issues, we want to hear about it. Just create an issue in the oclif.io repo.
Re-engaging the oclif Community​
Lastly, our biggest priority at the moment is to re-engage the oclif community. We understand how frustrating it has been over the years to see your issues and pull requests go unacknowledged. We apologize for not prioritizing the community, and are earnestly trying to make sure that every issue and pull request gets the attention it deserves going forward.
We also opened up GitHub discussions for @oclif/core and the oclif CLI, where you can now post your questions or ideas. We hope you take advantage of them, we love hearing from you!
One last thing: we intend to publicly post our roadmap so you have more visibility into what we're working on. Stay tuned!
All our best,
The oclif teamAnnouncing oclif v2!January 12, 2022 · 5 min readHello and happy new year! It's our great pleasure to announce that we have released oclif v2, which uses the new @oclif/core library! 🎉
oclif v2 includes many changes that improve the experience of both creating and using an oclif CLI.
Going forward, we don't plan to make any updates to oclif v1 and its corresponding libraries, except for critical security fixes. See the compatibility matrix for a list of these libraries. In order to give developers time to migrate from v1 to v2, we're not completely dropping support yet. But at some point in the future we'll archive the v1 repositories and deprecate their versions on npm.
What’s changing?​
Repository Changes​
All repositories under the oclif org now use main as their primary branch and oclif-v1 as the legacy branch. The main  branch corresponds to oclif v2 and the oclif-v1 branch to oclif v1. If you find any repos that don’t have a main branch, you can safely assume that they're not used in oclif v2 and will be deprecated in the future.
Consolidating Tools & Libraries​
The oclif-dev CLI has now been incorporated into oclif. You now no longer need to install a separate package to manage your entire CLI’s lifecycle.
The following libraries have been consolidated under @oclif/core and will be deprecated at some point in the future. Read the migration guide to learn how to update your CLI or plugin to use the new core library.

@oclif/command
@oclif/config
@oclif/error
@oclif/help
@oclif/parser

No more single vs multi command CLIs​
There's only one "type" of oclif v2 CLI, but it can have as few or as many commands as a developer wants. As a result, there’s only one command to generate CLIs, oclif generate, as opposed to the old oclif single and oclif multi commands.
Node > 12​
To ensure oclif CLIs are as secure as possible, all v2 libraries and plugins support only Node 12 or higher as of now. Going forward, they'll support only Node Maintenance or higher, as defined by Node's release schedule here: https://nodejs.org/en/about/releases/.
What’s new?​
New example CLI​
oclif-hello-world is our new example repo. This is also the repo that's used as a template when running oclif generate to create a new CLI. This repo will always be able to be referenced as an example of what an oclif v2 CLI should look like.
Spaced commands​
oclif CLIs can now use spaces, instead of colons, to separate topics and subcommands. To enable this feature, simply add “topicSeparator": " " to the oclif config in your package.json. See an example in our example repo.
// Old commands that use :$ mycli do:something
// New spaced commands$ mycli do something

Note: Spaced commands are backwards compatible. So if you enable spaced commands for your CLI, users will still be able to use : as a separator. This ensures that any existing scripts don't break.

New Help Output​
We’ve revamped the way command help is outputted to the terminal, making it both easier to implement and easier to read. See the difference between the old help output on the left and the new help output on the right in the screenshots below.
oclif v1oclif v2
Notice that there are new sections for flags and global flags, examples are displayed with better spacing, and there is a section at the bottom called Configuration Variables. This Configuration Variables section is not part of the new help by default. But we've added support for custom help sections, which is what the sf CLI uses to create the new section.
Async Command Parsing​
We’ve also improved the performance of new CLIs by rewriting how commands are parsed on initialization. The new parser is asynchronous, which makes CLIs with a lot of commands or installed  plugins much faster.
What’s coming next?​
Part of our charter for the release of oclif v2 includes improving our engagement with the oclif community. We know that over the past couple of years we’ve reduced our involvement, and a lot of issues and PRs have languished in limbo. Hopefully you’ve already seen increased activity and responses from oclif maintainers recently, but if you haven’t, please don’t hesitate to ping us by tagging @admins in oclif repos.
We also want to start interviewing members of the oclif community to acquire feedback and prioritize the features and fixes you deem most important!
Best,
The oclif team

Reference material​
Migration Guide​
This guide explains how to upgrade a CLI or plugin from the old oclif v1 libraries to the new @oclif/core library that oclif v2 uses.
https://github.com/oclif/core/blob/main/MIGRATION.md
Compatibility Matrix​
The following matrix shows how the v1 libraries and plugins relate to the new v2 ones. Use this matrix as a guide to know what to drop and which versions to switch when upgrading your plugins and CLIs to v2.
oclif "v1"oclif "v2"Utility CLIsoclif@<2@oclif/dev-cli@<2oclif@>=2Main packages@oclif/command@oclif/config@oclif/errors@oclif/parser@oclif/plugin-help@oclif/core@>=1Node LTSNode v8-14Node v12+ (at time of writing)TypeScripttypescript@<4typescript@>=4Main plugins@oclif/plugin-autocomplete@<1@oclif/plugin-commands@<2@oclif/plugin-help@<4@oclif/plugin-not-found@<2@oclif/plugin-plugins@<2@oclif/plugin-update@<2plugin-warn-if-update-available@<2plugin-which@<2@oclif/plugin-autocomplete@>=1@oclif/plugin-commands@>=2@oclif/plugin-help@>=4@oclif/plugin-not-found@>=2@oclif/plugin-plugins@>=2@oclif/plugin-update@>=2@oclif/plugin-warn-if-update-available@>=2@oclif/plugin-which@>=2Introducing @oclif/coreMarch 1, 2021 · 3 min readGreetings!
We hope this blog post finds you well.
Introducing...​
We are excited to announce the next iteration of the oclif project today: @oclif/core.
We have learned a lot in the last three years of developing oclif, developing on oclif and supporting millions of command runs a day via Heroku and Salesforce CLIs.
@oclif/core ("Core") simplifies the oclif development experience and introduces highly requested new features.
Core combines the essential oclif packages into one "core" package, aptly named @oclif/core.
Core also introduces:

A default command option
Colon or space command syntax
Async command parsing
Command piping to arguments

With the introduction of default command functionality, Core simplifies the oclif project and removes the notion of single or multi command CLIs. Core CLIs can have 1 or many commands.
Along with Core, we moved the oclif-dev CLI into the oclif CLI creating a single "utility" CLI. This CLI also introduces a new AWS S3 compatible publishing scheme.
What to expect in the near future​
Core is in pre-release beta and being actively developed for new internal Salesforce CLIs.
Much documentation needs to be written in the coming months including migration paths. Migration onto Core should be as painless as possible with many exports remaining entirely unchanged. Look for forthcoming blog posts and documentation on oclif.io.
Early this summer, tentively June 1, we will release Core v1. Core's release will coincide with major bumps to many other oclif plugin packages. See the compatibility matrix below.
At Core's v1 release, the current "main" oclif packages (namely: command, config, errors & parser) will go into maintenance mode until Jan 2022. They will receive only bug and security fixes and they remain compatible with current versions of the oclif and oclif-dev CLIs. Afterwhich, they will be archived.
Companioning Core, the next major release of the oclif CLI (literally oclif@2) will generate Core CLIs.
Going forward​
We are excited to release Core! We invite you to poke around the Core repo. It may appear to be a big change but Core keeps what you already enjoy about oclif while reducing development complexity, project dependencies, package coupling and bundle size and introduces many requested features previously too prickly to weave into the current oclif architecture.
Best,
The oclif team
Reference: Compatibility matrix​
oclif "v1"oclif "Core"Utility CLIsoclif@<2@oclif/dev-cli@<2oclif@>=2Main packages@oclif/core@<2@oclif/config@<2@oclif/errors@<2@oclif/parser@<4@oclif/plugin-help@<4@oclif/core@>=1Node LTSNode v8-14Node v12+TypeScripttypescript@<4typescript@>=4Main plugins@oclif/plugin-autocomplete@<1@oclif/plugin-commands@<2@oclif/plugin-help@<4@oclif/plugin-not-found@<2@oclif/plugin-plugins@<2@oclif/plugin-update@<2plugin-warn-if-update-available@<2plugin-which@<2@oclif/plugin-autocomplete@>=2@oclif/plugin-commands@>=2@oclif/plugin-help@>=4@oclif/plugin-not-found@>=2@oclif/plugin-plugins@>=2@oclif/plugin-update@>=2@oclif/plugin-warn-if-update-available@>=2@oclif/plugin-which@>=2oclif Summer 2020 UpdateAugust 26, 2020 · 2 min readHello oclif developers! We hope you are all doing well.
Earlier this year, we started our planning for oclifconf v2 and, like all conference, had to change course. We opted not to hold a virtual conference, however, we wanted to take some time to highlight a few oclif features shipped this year.
Feature: Help templating​
One of the most requested features, help templating enables oclif developers to customize the help output for their CLI.
Read the announcement.
Feature: Custom error delegation​
This feature both improved how oclif throws and handles errors and allows oclif developers to overwrite or interject in oclif’s error handling.
Read the announcement.
Feature: postrun hooks​
We have added a new lifecycle event postrun. Your CLI can now run a hook after a command has ran.
See our hook documentation.
Feature: Root index command​
Previously, oclif would display CLI help if only the binary name with no command ID was invoked, oclif now supports a "root index" command. If present, a command defined at src/commands/index.ts will be run if no command ID is found.
1 million weekly downloads​
While exact oclif usage metrics are hard to pin down, we use npm download statistics of oclif packages as a rough approximation. Earlier this year, oclif's command package hit 1 million weekly downloads for the first time!
This year has been presented its challenges on everyone. We want to thank you, oclif developers, whom have taken the time to use and improve the oclif project. We look forward to seeing you all - in person - in the future!
All our best,
The oclif teamPretty Printable ErrorsJuly 1, 2020 · One min readOften CLIs are used as handy tools and when things go wrong it’s useful to have additional context. In oclif we have added a couple of additional properties that can show extra context to the users when an error is displayed. The code, ref and suggestions will now be displayed if they are included. This will work with an existing oclif CLI by adding the latest @oclif/errors and @oclif/core to the CLI's package.json dependencies.
For example, using this.error with the additional properties:
class TestError extends Command {  async run() {    this.error("An error has occurred!", {      code: "OCLIF_ERR",      ref: "https://oclif.io/docs/commands#thiserrormessage-string--error-options-code-string-exit-number",      suggestions: ["Use these extra properties to provide additional context"],    })  }}
would result with the following output:
›   Error: An error has occurred!›   Code: OCLIF_ERR›   Try this: Use these extra properties to provide additional context›   Reference: https://oclif.io/docs/commands#thiserrormessage-string--error-options-code-string-exit-number
If these properties are not provided then nothing changes and the CLI will continue to display the single error message output as it did before. Additionally, as part of this exercise we’ve added documentation around Error Handling in oclif which should come in handy if the need arises to extend oclif’s default handling of errors.Customizing Help in oclifMay 5, 2020 · 2 min readOut of the box oclif provides a great help experience for CLIs.
But what if, as an oclif developer, you want to customize some or all of the output?
You can now customize your CLI's help output by implementing the HelpBase abstract class.
Getting started with custom help​
If you have not done so yet, update @oclif/core.
$ yarn add --latest @oclif/core
To get started, first define the filepath to your help class in oclif's config in package.json. This is a relative path to the help class, without a file extension.
For this example, the help class will be created in a file at "[project root]/src/help.ts".
{  // ...  "oclif": {    "helpClass": "./lib/help"    // ...  }  // ...}
From here there are two paths, implement the HelpBase abstract class yourself or overwrite the parts of the default Help class you want to customize (ex: how command usage is displayed). We recommend the latter approach but cover both in the new Help Classes docs.
Separating TOPICS & COMMANDS in the new default Help class​
Previously, topics and child commands were listed in help output under a single list heading called "COMMANDS". But we found this can be slightly confusing. Some topics are commands also (a.k.a. topic-commands) while others are simply organizational namespacing (and when ran just show their help).
The new default Help class splits the list of children into distinct lists of "TOPICS" and "COMMANDS", with the possibility of an item appearing in both if it a topic-command. This makes it clearer what is expected to be ran - "COMMANDS" - and what is providing structure - "TOPICS" - when looking at the help output.
VERSION  plugin-help-example/0.0.0 darwin-x64 node-v12.12.0USAGE  $ plugin-help-example [COMMAND]TOPICS  topic  this is a topic and has child topics or commandsCOMMANDS  hello  describe the command here  help   display help for plugin-help-example
We look forward to seeing what custom help features you implement in your oclif CLIs with this new feature!oclif TSLint to ESLint MigrationDecember 5, 2019 · 3 min readBack in February of this year, plans were announced to deprecate TSLint in favor of ESLint. TSLint's goal has become to work toward a “unified developer experience” by supporting ESLint development going forward.
What has changed in oclif​
To keep inline with the community, oclif has transitioned to ESLint for all our core libraries as well as all our official plugins.
Starting in v1.15.x, oclif will now optionally generate projects with ESLint for both TypeScript and JavaScript CLI’s.
ESLint does require Node to be on stable LTS version, at the time of writing, Node 8.10.x, Node 10.13.x & Node 12.x.x.
How does this affect you​
Existing CLI’s are unchanged, but any newly generated CLI's will only give the option of using ESLint. If you are running tslint in your CLI, we recommend you switch to ESLint as well.
In migrating our projects we took the following steps (for an example of these changes see this pull request).


Install eslint
$ yarn add eslint eslint-config-oclif eslint-config-oclif-typescript --dev


Add eslint related files


$ echo '{  "extends": [    "oclif",    "oclif-typescript"  ],  "rules": {  }}' > .eslintrc


Remove tslint and related packages
$ yarn remove @oclif/tslint tslint


Remove tslint related configuration files
$ rm tslint.json


Change lint script in our package.json from something like:
"lint": "tsc -p test --noEmit && tslint -p test -t stylish"
to
"lint": "eslint . --ext .ts --config .eslintrc"


To preserve the test compile (tsc -p test --noEmit) we also made the following updates to our scripts:
"pretest": "tsc -p test --noEmit"
In some cases we had our posttest duplicating the same steps as our lint script so it’s cleaner to have it reference the lint job directly with:
"posttest": "yarn lint"

Run yarn lint --fix. This attempts to auto-fix any linting violations automatically. In the case an auto-fix isn’t available it should be fixed manually or ignored (see the eslint configuration doc for more information)
Do a search in the codebase for tslint and remove any unnecessary tslint disabling comments, like:

/* tslint:disable:object-literal-sort-keys */
If you are on a version of Node that is not supported by ESLint, you will also need to update your Node engine. ESLint supports Node 8, 10, and 12 so you should upgrade to the most recent Node version compatible with your CLI and also supported by ESLint (see ESLint's Installation and Usage instructions).
When will this take effect​
These changes have taken effect in oclif v1.15.1. When you generate a new CLI or plugin it will now contain configuration for ESLint instead of TSLint.oclif's Current Node SupportOctober 31, 2019 · 3 min readTo maintain a healthy project trajectory, oclif follows and supports Node Active LTS release, currently Node 10 & Node 12. This means ensuring that oclif continues to play nice with coming Active LTS Node versions and other packages in the ecosystem. Moving forward also means leaving older versions behind. Starting in 2020, Node will stop maintaining Node 8 and it is our intent at that time to also follow suit. Let’s take a look at a few ways we will be supporting these changes.
CI Environments​
CLIs created with the oclif cli going forward will be generated with a CircleCI configuration with Node 10 & 12 and an Appveyor configuration using Node 10. We have also added Node latest to CircleCi to be an early warning detection against coming Node changes (Node latest is managed by CircleCI).
We have already updated every oclif repo's CI configs to reflect this.
If your existing CLI uses either Appveyor or CircleCI you can update your config files also, like so:
.circleci/config.yml​
Your CircleCI config should contain a node-latest job, aliased as test. From this, there should be two extensions of this job for the Active LTS Node versions, Node 10 and Node 12.
  node-10:    <<: *node-latest    docker:      - image: node:10  node-12:    <<: *node-latest    docker:      - image: node:12
Notice that these declarations only change the Docker Node images used to run that job.
Additionally, the jobs listed within workflows must also be updated to reflect our changes in configuration:
    jobs:      - node-latest      - node-10      - node-12
appveyor.yml​
For appveyor we are currently only testing the oldest Active LTS Node version, Node 10. Update the nodejs_version proppert in your appveyor.yml file to reflect this.
environment:  nodejs_version: "10"
Deprecating Node 8 & Updating packge.json engines​
In Jan 2020, Node will end its Node 8 maintenance. We will follow suit by setting the package.json engine property in oclif packages to >=10 and bumping the package's major versions.
Depending on how you ship your CLI you may wish to also bump the engines version in your CLI's package.json. You can read more about the implications of the engines property configuration in the npm documentation.
Also consider distributing your CLI with its own Node version.
Packaged Node Version​
When using dev-cli to pack your CLI it will use the Node version as specified in your package.json under the oclif.update.node.version property. This value should reflect an Active LTS Node version (dev-cli does not currently enforce versions).
Supporting the future​
As a community we may discover bumps along the way as we upgrade. If you notice something related to oclif please feel free to open an issue or submit a pull request under the relevant oclif package within the org.
We look forward to using the latest from Node and the community and keeping oclif healthy along the way.oclifconf 2019: A RecapSeptember 16, 2019 · 4 min readIn May, Heroku and Salesforce Open Source organized oclifconf, a conference for developers & product managers building CLI tools on top of the open source oclif framework. The speakers came from various tech companies, such as Adobe, Netlify, and Apollo, who have already built amazing CLI experiences. The topics covered everything from the incredible capabilities oclif has unlocked, to the community-built plugins extending its functionality, and even what the behavior of an adaptive CLI tool might look like.
Below is a listing of all of the talks from the event, along with a short summary. Enjoy!
The future of oclif by Jeff Dickey​

In its relatively short lifetime, oclif has already inspired many developers and companies to adopt its framework as a means for implementing their own command-line tooling. In this talk, Jeff Dickey, an oclif founding team member, recaps the project's history and inspiration. He also looks towards the future and outlines some features and improvements that the tool could adapt. This isn't so much a definitive roadmap of where oclif is headed, but rather, a call to inspiration for developers eager to contribute! And if you are interested in contributing, check out the open issues in the oclif GitHub repo and come say "Hello!" on Spectrum Chat.
Open Source Citizenship by Josh Simmons​

When it comes to open source, it's more than just individuals now. More and more frequently, large corporations are contributing to projects by donating to contributors, sponsoring events, or upstreaming contributions. But keeping open source projects and communities healthy requires more than just money and brainpower. Josh Simmons surveyed multiple open source communities and relays his findings as to what help maintainers and contributors actually need in this talk.
Building an enterprise-grade CLI with oclif by Thomas Dvornik​

Security and performance are all about trust. While oclif is an extremely extensible framework for building CLI tooling, there are additional requirements to fulfill for enterprise businesses to adopt it that might not be necessary for individual developers. Thomas Dvornik outlines what he and his colleagues at Salesforce have implemented as plugins to oclif to satisfy these needs, including encrypted OAuth, plugin signing, lazy loading dependencies, synchronizing weekly releases and deprecations across dozens of repositories, and establishing cross-team coding and documentation standards.
How Adobe I/O built an extensible CLI with oclif by Jesse MacFadyen​

Perhaps oclif's most appealing feature is its support for plugins. In Cordova's case, they've created a sophisticated telemetry system that helps Adobe developers see which commands users are using--and reports on which ones are erroring out. By embedding a feedback system into the tool, users are even able to quickly send their suggestions to a form, without ever leaving the terminal. Jesse MacFadyen demonstrates how oclif's plugin system can work beyond simply executing commands.
Integrating oclif with GraphQL and Apollo by Evans Hauser​

For Evans Hauser and the team at Apollo, oclif is best thought of as "React for the CLI." As a client paired with a strongly-typed API contract to a server, it can deliver structured and consistent commands to retrieve external data. What better mechanism to use for this transfer than GraphQL, a framework which empowers the client to ask precisely for the data it needs, and nothing more?
Adaptive Intent-based CLI State Machines by Shawn Wang​

In designing oclif, Jeff Dickey wrote out 12 CLI factors to keep in mind. In this talk, Shawn Wang outlines a 13th: state. State is hard, because it depends on context, and context depends on understanding what a user intends to do, not what they are asking. Shawn is working towards enabling oclif to better understand the commands a user has entered, so that it can predict and interpret future commands that might be entered next. This would enable CLI tools to not just interpret a users' commands, but to also interpret their intent.\n\nIntroducing `oclif init` commandApril 10, 2024 · 2 min readThanks to the contribution of @joshcanhelp we released a new command for the oclif CLI called oclif init in version 4.8.0
The oclif init command allows you to initialize oclif in an existing project directory by adding the bare minimum requirements: a few pieces of configuration, bin scripts, and a couple of dependencies (@oclif/core and ts-node). This is slightly different from oclif generate, which will create an entirely new oclif project based on our templates.
oclif init will add the following:

bin scripts: bin/run.js, bin/run.cmd, bin/dev.js, and bin/dev.cmd
oclif section to package.json with bin, dirname, commands, and topicSeparator set (See Configuring Your CLI for more)
@oclif/core to dependencies in your package.json (if it's not already there)
ts-node to devDependencies in your package.json (if it's not already there)

Once you've initialized oclif, you can use the bin scripts to execute your CLI. You can also use the other oclif commands like oclif generate command and oclif generate hook to start adding new functionality.

❯ oclif init --helpInitialize a new oclif CLIUSAGE  $ oclif init [--bin <value>] [--module-type ESM|CommonJS] [--package-manager npm|yarn|pnpm] [--topic-separator    colons|spaces] [-d <value>] [-y]FLAGS  -d, --output-dir=<value>        Directory to initialize the CLI in.  -y, --yes                       Use defaults for all prompts. Individual flags will override defaults.      --bin=<value>               Supply answer for prompt: Command bin name the CLI will export      --module-type=<option>      Supply answer for prompt: Select a module type                                  <options: ESM|CommonJS>      --package-manager=<option>  Supply answer for prompt: Select a package manager                                  <options: npm|yarn|pnpm>      --topic-separator=<option>  Supply answer for prompt: Select a topic separator                                  <options: colons|spaces>DESCRIPTION  Initialize a new oclif CLI  This will add the necessary oclif bin files, add oclif config to package.json, and install @oclif/core and ts-node.EXAMPLES  Initialize a new CLI in the current directory    $ oclif init  Initialize a new CLI in a different directory    $ oclif init --output-dir "/path/to/existing/project"  Supply answers for specific prompts    $ oclif init --topic-separator colons --bin mycli
Hope you enjoy the new command! If you come across any issues or have any new ideas for this command, head over to the oclif/oclif repo and open a new issue.
All our best,
The oclif teamoclif Spring 2024 UpdateMarch 29, 2024 · 4 min readHello oclif developers! It's been a while since we last uploaded a blog - and a lot has happened.
We've been focusing on these high-level areas over the past couple of years:

Improving @oclif/core
ESM Support
Improving and revitalizing oclif.io
Re-engaging the oclif community

Improving @oclif/core​
Since we announced @oclif/core over three years ago, we've released two new major versions, each packed with lots of features that we're really excited about.
Here are some of these changes:

Full support for ESM and interoperability with CommonJS (more on this topic below).
Configurable command discovery strategies that give you more control over how commands are loaded at runtime. Check out the docs.
A new preparse hook that allows you to manipulate the provided arguments before they're parsed. Salesforce used this hook to implement a neat --flags-dir feature that translates local files into flags.
A new Performance class that you can use to track performance inside of @oclif/core and your own CLI or plugin. Check out the docs.
A new flag type, Flags.option, that lets you define a flag with a preset list of options. Typescript then uses the options to infer the flag's type.
Flags now have a relationship property that allows you to define more complex relationships between flags. Check out the flags docs for more information.
Flags now have a defaultHelp property that allows you to set the human readable default value in the command help. This property is useful when your flag's parse method returns a complex type, such as an object or a class. Check out the flags docs for more.
Commands now have a hiddenAliases property that allows you to define aliases that you want to hide from the user. The property is super helpful when you're trying to wean users off a deprecated command.
You can now use bun or tsx as dev runtimes (as opposed to node or ts-node).
A command's usage, args, and flags are now shown whenever a user forgets to provide a required arg or flag, or when they provided a non-existent flag.

If you need help migrating to the latest version, head over to core's README which has links to the migration guides. Feel free to open a new discussion if you need more hands-on help from us or the community.
ESM Support​
Version 3 of @oclif/core introduced full support for developing ESM plugins and CLIs. It also offered full support for interoperability between CommonJS and ESM plugins.
Put more simply, you can now migrate your CLI to ESM while keeping individual plugins in CommonJS (or vice versa). The upgrade path is now much simpler for you. You also don't need to worry about any community plugins that have migrated to ESM before you did (such as all the @oclif plugins) or are staunchly sticking with CommonJS for the foreseeable future.
Read more about this topic here.
Improving and Revitalizing oclif.io​
Another area of focus for us has been improving our documentation site, oclif.io.
While improving the quality and accuracy of the documentation was our priority, we also took the time to upgrade to the latest version of docusaurus. This new version gave our site a much-needed facelift, as well as cool new features such as dark mode and announcements.
If you have any feedback or are running into issues, we want to hear about it. Just create an issue in the oclif.io repo.
Re-engaging the oclif Community​
Lastly, our biggest priority at the moment is to re-engage the oclif community. We understand how frustrating it has been over the years to see your issues and pull requests go unacknowledged. We apologize for not prioritizing the community, and are earnestly trying to make sure that every issue and pull request gets the attention it deserves going forward.
We also opened up GitHub discussions for @oclif/core and the oclif CLI, where you can now post your questions or ideas. We hope you take advantage of them, we love hearing from you!
One last thing: we intend to publicly post our roadmap so you have more visibility into what we're working on. Stay tuned!
All our best,
The oclif teamAnnouncing oclif v2!January 12, 2022 · 5 min readHello and happy new year! It's our great pleasure to announce that we have released oclif v2, which uses the new @oclif/core library! 🎉
oclif v2 includes many changes that improve the experience of both creating and using an oclif CLI.
Going forward, we don't plan to make any updates to oclif v1 and its corresponding libraries, except for critical security fixes. See the compatibility matrix for a list of these libraries. In order to give developers time to migrate from v1 to v2, we're not completely dropping support yet. But at some point in the future we'll archive the v1 repositories and deprecate their versions on npm.
What’s changing?​
Repository Changes​
All repositories under the oclif org now use main as their primary branch and oclif-v1 as the legacy branch. The main  branch corresponds to oclif v2 and the oclif-v1 branch to oclif v1. If you find any repos that don’t have a main branch, you can safely assume that they're not used in oclif v2 and will be deprecated in the future.
Consolidating Tools & Libraries​
The oclif-dev CLI has now been incorporated into oclif. You now no longer need to install a separate package to manage your entire CLI’s lifecycle.
The following libraries have been consolidated under @oclif/core and will be deprecated at some point in the future. Read the migration guide to learn how to update your CLI or plugin to use the new core library.

@oclif/command
@oclif/config
@oclif/error
@oclif/help
@oclif/parser

No more single vs multi command CLIs​
There's only one "type" of oclif v2 CLI, but it can have as few or as many commands as a developer wants. As a result, there’s only one command to generate CLIs, oclif generate, as opposed to the old oclif single and oclif multi commands.
Node > 12​
To ensure oclif CLIs are as secure as possible, all v2 libraries and plugins support only Node 12 or higher as of now. Going forward, they'll support only Node Maintenance or higher, as defined by Node's release schedule here: https://nodejs.org/en/about/releases/.
What’s new?​
New example CLI​
oclif-hello-world is our new example repo. This is also the repo that's used as a template when running oclif generate to create a new CLI. This repo will always be able to be referenced as an example of what an oclif v2 CLI should look like.
Spaced commands​
oclif CLIs can now use spaces, instead of colons, to separate topics and subcommands. To enable this feature, simply add “topicSeparator": " " to the oclif config in your package.json. See an example in our example repo.
// Old commands that use :$ mycli do:something
// New spaced commands$ mycli do something

Note: Spaced commands are backwards compatible. So if you enable spaced commands for your CLI, users will still be able to use : as a separator. This ensures that any existing scripts don't break.

New Help Output​
We’ve revamped the way command help is outputted to the terminal, making it both easier to implement and easier to read. See the difference between the old help output on the left and the new help output on the right in the screenshots below.
oclif v1oclif v2
Notice that there are new sections for flags and global flags, examples are displayed with better spacing, and there is a section at the bottom called Configuration Variables. This Configuration Variables section is not part of the new help by default. But we've added support for custom help sections, which is what the sf CLI uses to create the new section.
Async Command Parsing​
We’ve also improved the performance of new CLIs by rewriting how commands are parsed on initialization. The new parser is asynchronous, which makes CLIs with a lot of commands or installed  plugins much faster.
What’s coming next?​
Part of our charter for the release of oclif v2 includes improving our engagement with the oclif community. We know that over the past couple of years we’ve reduced our involvement, and a lot of issues and PRs have languished in limbo. Hopefully you’ve already seen increased activity and responses from oclif maintainers recently, but if you haven’t, please don’t hesitate to ping us by tagging @admins in oclif repos.
We also want to start interviewing members of the oclif community to acquire feedback and prioritize the features and fixes you deem most important!
Best,
The oclif team

Reference material​
Migration Guide​
This guide explains how to upgrade a CLI or plugin from the old oclif v1 libraries to the new @oclif/core library that oclif v2 uses.
https://github.com/oclif/core/blob/main/MIGRATION.md
Compatibility Matrix​
The following matrix shows how the v1 libraries and plugins relate to the new v2 ones. Use this matrix as a guide to know what to drop and which versions to switch when upgrading your plugins and CLIs to v2.
oclif "v1"oclif "v2"Utility CLIsoclif@<2@oclif/dev-cli@<2oclif@>=2Main packages@oclif/command@oclif/config@oclif/errors@oclif/parser@oclif/plugin-help@oclif/core@>=1Node LTSNode v8-14Node v12+ (at time of writing)TypeScripttypescript@<4typescript@>=4Main plugins@oclif/plugin-autocomplete@<1@oclif/plugin-commands@<2@oclif/plugin-help@<4@oclif/plugin-not-found@<2@oclif/plugin-plugins@<2@oclif/plugin-update@<2plugin-warn-if-update-available@<2plugin-which@<2@oclif/plugin-autocomplete@>=1@oclif/plugin-commands@>=2@oclif/plugin-help@>=4@oclif/plugin-not-found@>=2@oclif/plugin-plugins@>=2@oclif/plugin-update@>=2@oclif/plugin-warn-if-update-available@>=2@oclif/plugin-which@>=2Introducing @oclif/coreMarch 1, 2021 · 3 min readGreetings!
We hope this blog post finds you well.
Introducing...​
We are excited to announce the next iteration of the oclif project today: @oclif/core.
We have learned a lot in the last three years of developing oclif, developing on oclif and supporting millions of command runs a day via Heroku and Salesforce CLIs.
@oclif/core ("Core") simplifies the oclif development experience and introduces highly requested new features.
Core combines the essential oclif packages into one "core" package, aptly named @oclif/core.
Core also introduces:

A default command option
Colon or space command syntax
Async command parsing
Command piping to arguments

With the introduction of default command functionality, Core simplifies the oclif project and removes the notion of single or multi command CLIs. Core CLIs can have 1 or many commands.
Along with Core, we moved the oclif-dev CLI into the oclif CLI creating a single "utility" CLI. This CLI also introduces a new AWS S3 compatible publishing scheme.
What to expect in the near future​
Core is in pre-release beta and being actively developed for new internal Salesforce CLIs.
Much documentation needs to be written in the coming months including migration paths. Migration onto Core should be as painless as possible with many exports remaining entirely unchanged. Look for forthcoming blog posts and documentation on oclif.io.
Early this summer, tentively June 1, we will release Core v1. Core's release will coincide with major bumps to many other oclif plugin packages. See the compatibility matrix below.
At Core's v1 release, the current "main" oclif packages (namely: command, config, errors & parser) will go into maintenance mode until Jan 2022. They will receive only bug and security fixes and they remain compatible with current versions of the oclif and oclif-dev CLIs. Afterwhich, they will be archived.
Companioning Core, the next major release of the oclif CLI (literally oclif@2) will generate Core CLIs.
Going forward​
We are excited to release Core! We invite you to poke around the Core repo. It may appear to be a big change but Core keeps what you already enjoy about oclif while reducing development complexity, project dependencies, package coupling and bundle size and introduces many requested features previously too prickly to weave into the current oclif architecture.
Best,
The oclif team
Reference: Compatibility matrix​
oclif "v1"oclif "Core"Utility CLIsoclif@<2@oclif/dev-cli@<2oclif@>=2Main packages@oclif/core@<2@oclif/config@<2@oclif/errors@<2@oclif/parser@<4@oclif/plugin-help@<4@oclif/core@>=1Node LTSNode v8-14Node v12+TypeScripttypescript@<4typescript@>=4Main plugins@oclif/plugin-autocomplete@<1@oclif/plugin-commands@<2@oclif/plugin-help@<4@oclif/plugin-not-found@<2@oclif/plugin-plugins@<2@oclif/plugin-update@<2plugin-warn-if-update-available@<2plugin-which@<2@oclif/plugin-autocomplete@>=2@oclif/plugin-commands@>=2@oclif/plugin-help@>=4@oclif/plugin-not-found@>=2@oclif/plugin-plugins@>=2@oclif/plugin-update@>=2@oclif/plugin-warn-if-update-available@>=2@oclif/plugin-which@>=2oclif Summer 2020 UpdateAugust 26, 2020 · 2 min readHello oclif developers! We hope you are all doing well.
Earlier this year, we started our planning for oclifconf v2 and, like all conference, had to change course. We opted not to hold a virtual conference, however, we wanted to take some time to highlight a few oclif features shipped this year.
Feature: Help templating​
One of the most requested features, help templating enables oclif developers to customize the help output for their CLI.
Read the announcement.
Feature: Custom error delegation​
This feature both improved how oclif throws and handles errors and allows oclif developers to overwrite or interject in oclif’s error handling.
Read the announcement.
Feature: postrun hooks​
We have added a new lifecycle event postrun. Your CLI can now run a hook after a command has ran.
See our hook documentation.
Feature: Root index command​
Previously, oclif would display CLI help if only the binary name with no command ID was invoked, oclif now supports a "root index" command. If present, a command defined at src/commands/index.ts will be run if no command ID is found.
1 million weekly downloads​
While exact oclif usage metrics are hard to pin down, we use npm download statistics of oclif packages as a rough approximation. Earlier this year, oclif's command package hit 1 million weekly downloads for the first time!
This year has been presented its challenges on everyone. We want to thank you, oclif developers, whom have taken the time to use and improve the oclif project. We look forward to seeing you all - in person - in the future!
All our best,
The oclif teamPretty Printable ErrorsJuly 1, 2020 · One min readOften CLIs are used as handy tools and when things go wrong it’s useful to have additional context. In oclif we have added a couple of additional properties that can show extra context to the users when an error is displayed. The code, ref and suggestions will now be displayed if they are included. This will work with an existing oclif CLI by adding the latest @oclif/errors and @oclif/core to the CLI's package.json dependencies.
For example, using this.error with the additional properties:
class TestError extends Command {  async run() {    this.error("An error has occurred!", {      code: "OCLIF_ERR",      ref: "https://oclif.io/docs/commands#thiserrormessage-string--error-options-code-string-exit-number",      suggestions: ["Use these extra properties to provide additional context"],    })  }}
would result with the following output:
›   Error: An error has occurred!›   Code: OCLIF_ERR›   Try this: Use these extra properties to provide additional context›   Reference: https://oclif.io/docs/commands#thiserrormessage-string--error-options-code-string-exit-number
If these properties are not provided then nothing changes and the CLI will continue to display the single error message output as it did before. Additionally, as part of this exercise we’ve added documentation around Error Handling in oclif which should come in handy if the need arises to extend oclif’s default handling of errors.Customizing Help in oclifMay 5, 2020 · 2 min readOut of the box oclif provides a great help experience for CLIs.
But what if, as an oclif developer, you want to customize some or all of the output?
You can now customize your CLI's help output by implementing the HelpBase abstract class.
Getting started with custom help​
If you have not done so yet, update @oclif/core.
$ yarn add --latest @oclif/core
To get started, first define the filepath to your help class in oclif's config in package.json. This is a relative path to the help class, without a file extension.
For this example, the help class will be created in a file at "[project root]/src/help.ts".
{  // ...  "oclif": {    "helpClass": "./lib/help"    // ...  }  // ...}
From here there are two paths, implement the HelpBase abstract class yourself or overwrite the parts of the default Help class you want to customize (ex: how command usage is displayed). We recommend the latter approach but cover both in the new Help Classes docs.
Separating TOPICS & COMMANDS in the new default Help class​
Previously, topics and child commands were listed in help output under a single list heading called "COMMANDS". But we found this can be slightly confusing. Some topics are commands also (a.k.a. topic-commands) while others are simply organizational namespacing (and when ran just show their help).
The new default Help class splits the list of children into distinct lists of "TOPICS" and "COMMANDS", with the possibility of an item appearing in both if it a topic-command. This makes it clearer what is expected to be ran - "COMMANDS" - and what is providing structure - "TOPICS" - when looking at the help output.
VERSION  plugin-help-example/0.0.0 darwin-x64 node-v12.12.0USAGE  $ plugin-help-example [COMMAND]TOPICS  topic  this is a topic and has child topics or commandsCOMMANDS  hello  describe the command here  help   display help for plugin-help-example
We look forward to seeing what custom help features you implement in your oclif CLIs with this new feature!oclif TSLint to ESLint MigrationDecember 5, 2019 · 3 min readBack in February of this year, plans were announced to deprecate TSLint in favor of ESLint. TSLint's goal has become to work toward a “unified developer experience” by supporting ESLint development going forward.
What has changed in oclif​
To keep inline with the community, oclif has transitioned to ESLint for all our core libraries as well as all our official plugins.
Starting in v1.15.x, oclif will now optionally generate projects with ESLint for both TypeScript and JavaScript CLI’s.
ESLint does require Node to be on stable LTS version, at the time of writing, Node 8.10.x, Node 10.13.x & Node 12.x.x.
How does this affect you​
Existing CLI’s are unchanged, but any newly generated CLI's will only give the option of using ESLint. If you are running tslint in your CLI, we recommend you switch to ESLint as well.
In migrating our projects we took the following steps (for an example of these changes see this pull request).


Install eslint
$ yarn add eslint eslint-config-oclif eslint-config-oclif-typescript --dev


Add eslint related files


$ echo '{  "extends": [    "oclif",    "oclif-typescript"  ],  "rules": {  }}' > .eslintrc


Remove tslint and related packages
$ yarn remove @oclif/tslint tslint


Remove tslint related configuration files
$ rm tslint.json


Change lint script in our package.json from something like:
"lint": "tsc -p test --noEmit && tslint -p test -t stylish"
to
"lint": "eslint . --ext .ts --config .eslintrc"


To preserve the test compile (tsc -p test --noEmit) we also made the following updates to our scripts:
"pretest": "tsc -p test --noEmit"
In some cases we had our posttest duplicating the same steps as our lint script so it’s cleaner to have it reference the lint job directly with:
"posttest": "yarn lint"

Run yarn lint --fix. This attempts to auto-fix any linting violations automatically. In the case an auto-fix isn’t available it should be fixed manually or ignored (see the eslint configuration doc for more information)
Do a search in the codebase for tslint and remove any unnecessary tslint disabling comments, like:

/* tslint:disable:object-literal-sort-keys */
If you are on a version of Node that is not supported by ESLint, you will also need to update your Node engine. ESLint supports Node 8, 10, and 12 so you should upgrade to the most recent Node version compatible with your CLI and also supported by ESLint (see ESLint's Installation and Usage instructions).
When will this take effect​
These changes have taken effect in oclif v1.15.1. When you generate a new CLI or plugin it will now contain configuration for ESLint instead of TSLint.oclif's Current Node SupportOctober 31, 2019 · 3 min readTo maintain a healthy project trajectory, oclif follows and supports Node Active LTS release, currently Node 10 & Node 12. This means ensuring that oclif continues to play nice with coming Active LTS Node versions and other packages in the ecosystem. Moving forward also means leaving older versions behind. Starting in 2020, Node will stop maintaining Node 8 and it is our intent at that time to also follow suit. Let’s take a look at a few ways we will be supporting these changes.
CI Environments​
CLIs created with the oclif cli going forward will be generated with a CircleCI configuration with Node 10 & 12 and an Appveyor configuration using Node 10. We have also added Node latest to CircleCi to be an early warning detection against coming Node changes (Node latest is managed by CircleCI).
We have already updated every oclif repo's CI configs to reflect this.
If your existing CLI uses either Appveyor or CircleCI you can update your config files also, like so:
.circleci/config.yml​
Your CircleCI config should contain a node-latest job, aliased as test. From this, there should be two extensions of this job for the Active LTS Node versions, Node 10 and Node 12.
  node-10:    <<: *node-latest    docker:      - image: node:10  node-12:    <<: *node-latest    docker:      - image: node:12
Notice that these declarations only change the Docker Node images used to run that job.
Additionally, the jobs listed within workflows must also be updated to reflect our changes in configuration:
    jobs:      - node-latest      - node-10      - node-12
appveyor.yml​
For appveyor we are currently only testing the oldest Active LTS Node version, Node 10. Update the nodejs_version proppert in your appveyor.yml file to reflect this.
environment:  nodejs_version: "10"
Deprecating Node 8 & Updating packge.json engines​
In Jan 2020, Node will end its Node 8 maintenance. We will follow suit by setting the package.json engine property in oclif packages to >=10 and bumping the package's major versions.
Depending on how you ship your CLI you may wish to also bump the engines version in your CLI's package.json. You can read more about the implications of the engines property configuration in the npm documentation.
Also consider distributing your CLI with its own Node version.
Packaged Node Version​
When using dev-cli to pack your CLI it will use the Node version as specified in your package.json under the oclif.update.node.version property. This value should reflect an Active LTS Node version (dev-cli does not currently enforce versions).
Supporting the future​
As a community we may discover bumps along the way as we upgrade. If you notice something related to oclif please feel free to open an issue or submit a pull request under the relevant oclif package within the org.
We look forward to using the latest from Node and the community and keeping oclif healthy along the way.oclifconf 2019: A RecapSeptember 16, 2019 · 4 min readIn May, Heroku and Salesforce Open Source organized oclifconf, a conference for developers & product managers building CLI tools on top of the open source oclif framework. The speakers came from various tech companies, such as Adobe, Netlify, and Apollo, who have already built amazing CLI experiences. The topics covered everything from the incredible capabilities oclif has unlocked, to the community-built plugins extending its functionality, and even what the behavior of an adaptive CLI tool might look like.
Below is a listing of all of the talks from the event, along with a short summary. Enjoy!
The future of oclif by Jeff Dickey​

In its relatively short lifetime, oclif has already inspired many developers and companies to adopt its framework as a means for implementing their own command-line tooling. In this talk, Jeff Dickey, an oclif founding team member, recaps the project's history and inspiration. He also looks towards the future and outlines some features and improvements that the tool could adapt. This isn't so much a definitive roadmap of where oclif is headed, but rather, a call to inspiration for developers eager to contribute! And if you are interested in contributing, check out the open issues in the oclif GitHub repo and come say "Hello!" on Spectrum Chat.
Open Source Citizenship by Josh Simmons​

When it comes to open source, it's more than just individuals now. More and more frequently, large corporations are contributing to projects by donating to contributors, sponsoring events, or upstreaming contributions. But keeping open source projects and communities healthy requires more than just money and brainpower. Josh Simmons surveyed multiple open source communities and relays his findings as to what help maintainers and contributors actually need in this talk.
Building an enterprise-grade CLI with oclif by Thomas Dvornik​

Security and performance are all about trust. While oclif is an extremely extensible framework for building CLI tooling, there are additional requirements to fulfill for enterprise businesses to adopt it that might not be necessary for individual developers. Thomas Dvornik outlines what he and his colleagues at Salesforce have implemented as plugins to oclif to satisfy these needs, including encrypted OAuth, plugin signing, lazy loading dependencies, synchronizing weekly releases and deprecations across dozens of repositories, and establishing cross-team coding and documentation standards.
How Adobe I/O built an extensible CLI with oclif by Jesse MacFadyen​

Perhaps oclif's most appealing feature is its support for plugins. In Cordova's case, they've created a sophisticated telemetry system that helps Adobe developers see which commands users are using--and reports on which ones are erroring out. By embedding a feedback system into the tool, users are even able to quickly send their suggestions to a form, without ever leaving the terminal. Jesse MacFadyen demonstrates how oclif's plugin system can work beyond simply executing commands.
Integrating oclif with GraphQL and Apollo by Evans Hauser​

For Evans Hauser and the team at Apollo, oclif is best thought of as "React for the CLI." As a client paired with a strongly-typed API contract to a server, it can deliver structured and consistent commands to retrieve external data. What better mechanism to use for this transfer than GraphQL, a framework which empowers the client to ask precisely for the data it needs, and nothing more?
Adaptive Intent-based CLI State Machines by Shawn Wang​

In designing oclif, Jeff Dickey wrote out 12 CLI factors to keep in mind. In this talk, Shawn Wang outlines a 13th: state. State is hard, because it depends on context, and context depends on understanding what a user intends to do, not what they are asking. Shawn is working towards enabling oclif to better understand the commands a user has entered, so that it can predict and interpret future commands that might be entered next. This would enable CLI tools to not just interpret a users' commands, but to also interpret their intent.Older Entries\n\n\n\nGuidesESMOn this pageESMVersion 3.0.0 of @oclif/core officially supports ESM plugin development and CJS/ESM interoperability, meaning that you can have a root plugin written with CJS and your plugins written in ESM or vice versa.
Interoperability Overview​
Here's a high level overview of ESM/CJS interoperability:
ESM Root plugin​
✅ Install CJS plugins
✅ Install ESM plugins
✅ Link CJS plugins
⚠️ Link ESM plugins

Auto-compilation will not work with linked ESM plugins that have ts-node as a dev dependency. Instead, oclif will use the plugin's compiled source - this means that you must compile the plugin yourself before executing any of the commands. We plan to support this again once the node ecosystem offers more comprehensive native support for ESM.
You can, however, replace ts-node with tsx in your dev dependencies if you'd like to have runtime auto-compilation for linked ESM plugins.

CJS Root plugin​
✅ Install CJS plugins
✅ Install ESM plugins
✅ Link CJS plugins
⚠️ Link ESM plugins

Auto-compilation will not work with linked ESM plugins that have ts-node as a dev dependency. Instead, oclif will use the plugin's compiled source - this means that you must compile the plugin yourself before executing any of the commands. We plan to support this again once the node ecosystem offers more comprehensive native support for ESM.
You can, however, replace ts-node with tsx in your dev dependencies if you'd like to have runtime auto-compilation for linked ESM plugins.

Creating an ESM plugin​
To generate a new ESM plugin, run the oclif generate command and select ESM when it prompts you to select a module type:
$ npx oclif generate my-esm-plugin? Select a module type  CommonJS❯ ESM
Migrating a CJS plugin to ESM​
Update bin scripts​
First you will need to update the bin scripts under the bin directory.
bin/dev → bin/dev.js​
Rename bin/dev to bin/dev.js and replace the existing code with the following:
#!/usr/bin/env -S node --loader ts-node/esm --no-warnings=ExperimentalWarningimport {execute} from '@oclif/core'await execute({development: true, dir: import.meta.url})
This leverages oclif's execute function which handles all the development setup for you. You no longer need set the NODE_ENV env var or register the project with ts-node. You can still adjust oclif settings before executing the CLI. For example,
#!/usr/bin/env -S node --loader ts-node/esm --no-warnings=ExperimentalWarningimport {execute, settings} from '@oclif/core'settings.performanceEnabled = trueawait execute({development: true, dir: import.meta.url})
bin/run → bin/run.js​
Rename bin/run to bin/run.js and replace the existing code with the following:
#!/usr/bin/env nodeimport {execute} from '@oclif/core'await execute({dir: import.meta.url})
Update tsconfig.json​
After updating the bin scripts you now need to update the tsconfig.json to include the following options:
{  "compilerOptions": {    "module": "ES2020",    "moduleResolution": "node16",  },  "ts-node": {    "esm": true  }}
Update package.json to "module" type​
Add "type": "module" to your package.json so that your files will be loaded as ESM modules
Update references to bin scripts​
You will need to update the references to your bin scripts to the bin scripts with the .js extension. In the package.json you will need to update the bin like so:
  "bin": {    "my-cli": "./bin/run"  },
to
  "bin": {    "my-cli": "./bin/run.js"  },
You may have references to the bin scripts in your .vscode/launch.json or in the scripts of your package.json. You'll need to update these as well.
Update mocharc settings​
In order for your mocha tests to run, you'll need to make a couple of changes:

Add the following to the .mocharc.json

{  "node-option": [    "loader=ts-node/esm"  ]}

Update test/helpers/init.js

If your plugin was generated oclif generate then you likely have a test/helpers/init.js file that needs to be updated. You can either update the file extension to .cjs or update the require at the top of the file to an import,
import path from 'node:path'
Alternatively, you can safely delete this file since it's no longer necessary.Edit this pageLast updated on Dec 20, 2024 by Mike Donnalley\n\nGuidesESMOn this pageESMVersion 3.0.0 of @oclif/core officially supports ESM plugin development and CJS/ESM interoperability, meaning that you can have a root plugin written with CJS and your plugins written in ESM or vice versa.
Interoperability Overview​
Here's a high level overview of ESM/CJS interoperability:
ESM Root plugin​
✅ Install CJS plugins
✅ Install ESM plugins
✅ Link CJS plugins
⚠️ Link ESM plugins

Auto-compilation will not work with linked ESM plugins that have ts-node as a dev dependency. Instead, oclif will use the plugin's compiled source - this means that you must compile the plugin yourself before executing any of the commands. We plan to support this again once the node ecosystem offers more comprehensive native support for ESM.
You can, however, replace ts-node with tsx in your dev dependencies if you'd like to have runtime auto-compilation for linked ESM plugins.

CJS Root plugin​
✅ Install CJS plugins
✅ Install ESM plugins
✅ Link CJS plugins
⚠️ Link ESM plugins

Auto-compilation will not work with linked ESM plugins that have ts-node as a dev dependency. Instead, oclif will use the plugin's compiled source - this means that you must compile the plugin yourself before executing any of the commands. We plan to support this again once the node ecosystem offers more comprehensive native support for ESM.
You can, however, replace ts-node with tsx in your dev dependencies if you'd like to have runtime auto-compilation for linked ESM plugins.

Creating an ESM plugin​
To generate a new ESM plugin, run the oclif generate command and select ESM when it prompts you to select a module type:
$ npx oclif generate my-esm-plugin? Select a module type  CommonJS❯ ESM
Migrating a CJS plugin to ESM​
Update bin scripts​
First you will need to update the bin scripts under the bin directory.
bin/dev → bin/dev.js​
Rename bin/dev to bin/dev.js and replace the existing code with the following:
#!/usr/bin/env -S node --loader ts-node/esm --no-warnings=ExperimentalWarningimport {execute} from '@oclif/core'await execute({development: true, dir: import.meta.url})
This leverages oclif's execute function which handles all the development setup for you. You no longer need set the NODE_ENV env var or register the project with ts-node. You can still adjust oclif settings before executing the CLI. For example,
#!/usr/bin/env -S node --loader ts-node/esm --no-warnings=ExperimentalWarningimport {execute, settings} from '@oclif/core'settings.performanceEnabled = trueawait execute({development: true, dir: import.meta.url})
bin/run → bin/run.js​
Rename bin/run to bin/run.js and replace the existing code with the following:
#!/usr/bin/env nodeimport {execute} from '@oclif/core'await execute({dir: import.meta.url})
Update tsconfig.json​
After updating the bin scripts you now need to update the tsconfig.json to include the following options:
{  "compilerOptions": {    "module": "ES2020",    "moduleResolution": "node16",  },  "ts-node": {    "esm": true  }}
Update package.json to "module" type​
Add "type": "module" to your package.json so that your files will be loaded as ESM modules
Update references to bin scripts​
You will need to update the references to your bin scripts to the bin scripts with the .js extension. In the package.json you will need to update the bin like so:
  "bin": {    "my-cli": "./bin/run"  },
to
  "bin": {    "my-cli": "./bin/run.js"  },
You may have references to the bin scripts in your .vscode/launch.json or in the scripts of your package.json. You'll need to update these as well.
Update mocharc settings​
In order for your mocha tests to run, you'll need to make a couple of changes:

Add the following to the .mocharc.json

{  "node-option": [    "loader=ts-node/esm"  ]}

Update test/helpers/init.js

If your plugin was generated oclif generate then you likely have a test/helpers/init.js file that needs to be updated. You can either update the file extension to .cjs or update the require at the top of the file to an import,
import path from 'node:path'
Alternatively, you can safely delete this file since it's no longer necessary.Edit this pageLast updated on Dec 20, 2024 by Mike DonnalleyPreviousError HandlingNextFlag InheritanceInteroperability OverviewESM Root pluginCJS Root pluginCreating an ESM pluginMigrating a CJS plugin to ESMUpdate bin scriptsUpdate tsconfig.jsonUpdate package.json to "module" typeUpdate references to bin scriptsUpdate mocharc settings\n\n\n\nIntroducing `oclif init` commandApril 10, 2024 · 2 min readThanks to the contribution of @joshcanhelp we released a new command for the oclif CLI called oclif init in version 4.8.0
The oclif init command allows you to initialize oclif in an existing project directory by adding the bare minimum requirements: a few pieces of configuration, bin scripts, and a couple of dependencies (@oclif/core and ts-node). This is slightly different from oclif generate, which will create an entirely new oclif project based on our templates.
oclif init will add the following:

bin scripts: bin/run.js, bin/run.cmd, bin/dev.js, and bin/dev.cmd
oclif section to package.json with bin, dirname, commands, and topicSeparator set (See Configuring Your CLI for more)
@oclif/core to dependencies in your package.json (if it's not already there)
ts-node to devDependencies in your package.json (if it's not already there)

Once you've initialized oclif, you can use the bin scripts to execute your CLI. You can also use the other oclif commands like oclif generate command and oclif generate hook to start adding new functionality.

❯ oclif init --helpInitialize a new oclif CLIUSAGE  $ oclif init [--bin <value>] [--module-type ESM|CommonJS] [--package-manager npm|yarn|pnpm] [--topic-separator    colons|spaces] [-d <value>] [-y]FLAGS  -d, --output-dir=<value>        Directory to initialize the CLI in.  -y, --yes                       Use defaults for all prompts. Individual flags will override defaults.      --bin=<value>               Supply answer for prompt: Command bin name the CLI will export      --module-type=<option>      Supply answer for prompt: Select a module type                                  <options: ESM|CommonJS>      --package-manager=<option>  Supply answer for prompt: Select a package manager                                  <options: npm|yarn|pnpm>      --topic-separator=<option>  Supply answer for prompt: Select a topic separator                                  <options: colons|spaces>DESCRIPTION  Initialize a new oclif CLI  This will add the necessary oclif bin files, add oclif config to package.json, and install @oclif/core and ts-node.EXAMPLES  Initialize a new CLI in the current directory    $ oclif init  Initialize a new CLI in a different directory    $ oclif init --output-dir "/path/to/existing/project"  Supply answers for specific prompts    $ oclif init --topic-separator colons --bin mycli
Hope you enjoy the new command! If you come across any issues or have any new ideas for this command, head over to the oclif/oclif repo and open a new issue.
All our best,
The oclif teamoclif Spring 2024 UpdateMarch 29, 2024 · 4 min readHello oclif developers! It's been a while since we last uploaded a blog - and a lot has happened.
We've been focusing on these high-level areas over the past couple of years:

Improving @oclif/core
ESM Support
Improving and revitalizing oclif.io
Re-engaging the oclif community

Improving @oclif/core​
Since we announced @oclif/core over three years ago, we've released two new major versions, each packed with lots of features that we're really excited about.
Here are some of these changes:

Full support for ESM and interoperability with CommonJS (more on this topic below).
Configurable command discovery strategies that give you more control over how commands are loaded at runtime. Check out the docs.
A new preparse hook that allows you to manipulate the provided arguments before they're parsed. Salesforce used this hook to implement a neat --flags-dir feature that translates local files into flags.
A new Performance class that you can use to track performance inside of @oclif/core and your own CLI or plugin. Check out the docs.
A new flag type, Flags.option, that lets you define a flag with a preset list of options. Typescript then uses the options to infer the flag's type.
Flags now have a relationship property that allows you to define more complex relationships between flags. Check out the flags docs for more information.
Flags now have a defaultHelp property that allows you to set the human readable default value in the command help. This property is useful when your flag's parse method returns a complex type, such as an object or a class. Check out the flags docs for more.
Commands now have a hiddenAliases property that allows you to define aliases that you want to hide from the user. The property is super helpful when you're trying to wean users off a deprecated command.
You can now use bun or tsx as dev runtimes (as opposed to node or ts-node).
A command's usage, args, and flags are now shown whenever a user forgets to provide a required arg or flag, or when they provided a non-existent flag.

If you need help migrating to the latest version, head over to core's README which has links to the migration guides. Feel free to open a new discussion if you need more hands-on help from us or the community.
ESM Support​
Version 3 of @oclif/core introduced full support for developing ESM plugins and CLIs. It also offered full support for interoperability between CommonJS and ESM plugins.
Put more simply, you can now migrate your CLI to ESM while keeping individual plugins in CommonJS (or vice versa). The upgrade path is now much simpler for you. You also don't need to worry about any community plugins that have migrated to ESM before you did (such as all the @oclif plugins) or are staunchly sticking with CommonJS for the foreseeable future.
Read more about this topic here.
Improving and Revitalizing oclif.io​
Another area of focus for us has been improving our documentation site, oclif.io.
While improving the quality and accuracy of the documentation was our priority, we also took the time to upgrade to the latest version of docusaurus. This new version gave our site a much-needed facelift, as well as cool new features such as dark mode and announcements.
If you have any feedback or are running into issues, we want to hear about it. Just create an issue in the oclif.io repo.
Re-engaging the oclif Community​
Lastly, our biggest priority at the moment is to re-engage the oclif community. We understand how frustrating it has been over the years to see your issues and pull requests go unacknowledged. We apologize for not prioritizing the community, and are earnestly trying to make sure that every issue and pull request gets the attention it deserves going forward.
We also opened up GitHub discussions for @oclif/core and the oclif CLI, where you can now post your questions or ideas. We hope you take advantage of them, we love hearing from you!
One last thing: we intend to publicly post our roadmap so you have more visibility into what we're working on. Stay tuned!
All our best,
The oclif teamAnnouncing oclif v2!January 12, 2022 · 5 min readHello and happy new year! It's our great pleasure to announce that we have released oclif v2, which uses the new @oclif/core library! 🎉
oclif v2 includes many changes that improve the experience of both creating and using an oclif CLI.
Going forward, we don't plan to make any updates to oclif v1 and its corresponding libraries, except for critical security fixes. See the compatibility matrix for a list of these libraries. In order to give developers time to migrate from v1 to v2, we're not completely dropping support yet. But at some point in the future we'll archive the v1 repositories and deprecate their versions on npm.
What’s changing?​
Repository Changes​
All repositories under the oclif org now use main as their primary branch and oclif-v1 as the legacy branch. The main  branch corresponds to oclif v2 and the oclif-v1 branch to oclif v1. If you find any repos that don’t have a main branch, you can safely assume that they're not used in oclif v2 and will be deprecated in the future.
Consolidating Tools & Libraries​
The oclif-dev CLI has now been incorporated into oclif. You now no longer need to install a separate package to manage your entire CLI’s lifecycle.
The following libraries have been consolidated under @oclif/core and will be deprecated at some point in the future. Read the migration guide to learn how to update your CLI or plugin to use the new core library.

@oclif/command
@oclif/config
@oclif/error
@oclif/help
@oclif/parser

No more single vs multi command CLIs​
There's only one "type" of oclif v2 CLI, but it can have as few or as many commands as a developer wants. As a result, there’s only one command to generate CLIs, oclif generate, as opposed to the old oclif single and oclif multi commands.
Node > 12​
To ensure oclif CLIs are as secure as possible, all v2 libraries and plugins support only Node 12 or higher as of now. Going forward, they'll support only Node Maintenance or higher, as defined by Node's release schedule here: https://nodejs.org/en/about/releases/.
What’s new?​
New example CLI​
oclif-hello-world is our new example repo. This is also the repo that's used as a template when running oclif generate to create a new CLI. This repo will always be able to be referenced as an example of what an oclif v2 CLI should look like.
Spaced commands​
oclif CLIs can now use spaces, instead of colons, to separate topics and subcommands. To enable this feature, simply add “topicSeparator": " " to the oclif config in your package.json. See an example in our example repo.
// Old commands that use :$ mycli do:something
// New spaced commands$ mycli do something

Note: Spaced commands are backwards compatible. So if you enable spaced commands for your CLI, users will still be able to use : as a separator. This ensures that any existing scripts don't break.

New Help Output​
We’ve revamped the way command help is outputted to the terminal, making it both easier to implement and easier to read. See the difference between the old help output on the left and the new help output on the right in the screenshots below.
oclif v1oclif v2
Notice that there are new sections for flags and global flags, examples are displayed with better spacing, and there is a section at the bottom called Configuration Variables. This Configuration Variables section is not part of the new help by default. But we've added support for custom help sections, which is what the sf CLI uses to create the new section.
Async Command Parsing​
We’ve also improved the performance of new CLIs by rewriting how commands are parsed on initialization. The new parser is asynchronous, which makes CLIs with a lot of commands or installed  plugins much faster.
What’s coming next?​
Part of our charter for the release of oclif v2 includes improving our engagement with the oclif community. We know that over the past couple of years we’ve reduced our involvement, and a lot of issues and PRs have languished in limbo. Hopefully you’ve already seen increased activity and responses from oclif maintainers recently, but if you haven’t, please don’t hesitate to ping us by tagging @admins in oclif repos.
We also want to start interviewing members of the oclif community to acquire feedback and prioritize the features and fixes you deem most important!
Best,
The oclif team

Reference material​
Migration Guide​
This guide explains how to upgrade a CLI or plugin from the old oclif v1 libraries to the new @oclif/core library that oclif v2 uses.
https://github.com/oclif/core/blob/main/MIGRATION.md
Compatibility Matrix​
The following matrix shows how the v1 libraries and plugins relate to the new v2 ones. Use this matrix as a guide to know what to drop and which versions to switch when upgrading your plugins and CLIs to v2.
oclif "v1"oclif "v2"Utility CLIsoclif@<2@oclif/dev-cli@<2oclif@>=2Main packages@oclif/command@oclif/config@oclif/errors@oclif/parser@oclif/plugin-help@oclif/core@>=1Node LTSNode v8-14Node v12+ (at time of writing)TypeScripttypescript@<4typescript@>=4Main plugins@oclif/plugin-autocomplete@<1@oclif/plugin-commands@<2@oclif/plugin-help@<4@oclif/plugin-not-found@<2@oclif/plugin-plugins@<2@oclif/plugin-update@<2plugin-warn-if-update-available@<2plugin-which@<2@oclif/plugin-autocomplete@>=1@oclif/plugin-commands@>=2@oclif/plugin-help@>=4@oclif/plugin-not-found@>=2@oclif/plugin-plugins@>=2@oclif/plugin-update@>=2@oclif/plugin-warn-if-update-available@>=2@oclif/plugin-which@>=2Introducing @oclif/coreMarch 1, 2021 · 3 min readGreetings!
We hope this blog post finds you well.
Introducing...​
We are excited to announce the next iteration of the oclif project today: @oclif/core.
We have learned a lot in the last three years of developing oclif, developing on oclif and supporting millions of command runs a day via Heroku and Salesforce CLIs.
@oclif/core ("Core") simplifies the oclif development experience and introduces highly requested new features.
Core combines the essential oclif packages into one "core" package, aptly named @oclif/core.
Core also introduces:

A default command option
Colon or space command syntax
Async command parsing
Command piping to arguments

With the introduction of default command functionality, Core simplifies the oclif project and removes the notion of single or multi command CLIs. Core CLIs can have 1 or many commands.
Along with Core, we moved the oclif-dev CLI into the oclif CLI creating a single "utility" CLI. This CLI also introduces a new AWS S3 compatible publishing scheme.
What to expect in the near future​
Core is in pre-release beta and being actively developed for new internal Salesforce CLIs.
Much documentation needs to be written in the coming months including migration paths. Migration onto Core should be as painless as possible with many exports remaining entirely unchanged. Look for forthcoming blog posts and documentation on oclif.io.
Early this summer, tentively June 1, we will release Core v1. Core's release will coincide with major bumps to many other oclif plugin packages. See the compatibility matrix below.
At Core's v1 release, the current "main" oclif packages (namely: command, config, errors & parser) will go into maintenance mode until Jan 2022. They will receive only bug and security fixes and they remain compatible with current versions of the oclif and oclif-dev CLIs. Afterwhich, they will be archived.
Companioning Core, the next major release of the oclif CLI (literally oclif@2) will generate Core CLIs.
Going forward​
We are excited to release Core! We invite you to poke around the Core repo. It may appear to be a big change but Core keeps what you already enjoy about oclif while reducing development complexity, project dependencies, package coupling and bundle size and introduces many requested features previously too prickly to weave into the current oclif architecture.
Best,
The oclif team
Reference: Compatibility matrix​
oclif "v1"oclif "Core"Utility CLIsoclif@<2@oclif/dev-cli@<2oclif@>=2Main packages@oclif/core@<2@oclif/config@<2@oclif/errors@<2@oclif/parser@<4@oclif/plugin-help@<4@oclif/core@>=1Node LTSNode v8-14Node v12+TypeScripttypescript@<4typescript@>=4Main plugins@oclif/plugin-autocomplete@<1@oclif/plugin-commands@<2@oclif/plugin-help@<4@oclif/plugin-not-found@<2@oclif/plugin-plugins@<2@oclif/plugin-update@<2plugin-warn-if-update-available@<2plugin-which@<2@oclif/plugin-autocomplete@>=2@oclif/plugin-commands@>=2@oclif/plugin-help@>=4@oclif/plugin-not-found@>=2@oclif/plugin-plugins@>=2@oclif/plugin-update@>=2@oclif/plugin-warn-if-update-available@>=2@oclif/plugin-which@>=2oclif Summer 2020 UpdateAugust 26, 2020 · 2 min readHello oclif developers! We hope you are all doing well.
Earlier this year, we started our planning for oclifconf v2 and, like all conference, had to change course. We opted not to hold a virtual conference, however, we wanted to take some time to highlight a few oclif features shipped this year.
Feature: Help templating​
One of the most requested features, help templating enables oclif developers to customize the help output for their CLI.
Read the announcement.
Feature: Custom error delegation​
This feature both improved how oclif throws and handles errors and allows oclif developers to overwrite or interject in oclif’s error handling.
Read the announcement.
Feature: postrun hooks​
We have added a new lifecycle event postrun. Your CLI can now run a hook after a command has ran.
See our hook documentation.
Feature: Root index command​
Previously, oclif would display CLI help if only the binary name with no command ID was invoked, oclif now supports a "root index" command. If present, a command defined at src/commands/index.ts will be run if no command ID is found.
1 million weekly downloads​
While exact oclif usage metrics are hard to pin down, we use npm download statistics of oclif packages as a rough approximation. Earlier this year, oclif's command package hit 1 million weekly downloads for the first time!
This year has been presented its challenges on everyone. We want to thank you, oclif developers, whom have taken the time to use and improve the oclif project. We look forward to seeing you all - in person - in the future!
All our best,
The oclif teamPretty Printable ErrorsJuly 1, 2020 · One min readOften CLIs are used as handy tools and when things go wrong it’s useful to have additional context. In oclif we have added a couple of additional properties that can show extra context to the users when an error is displayed. The code, ref and suggestions will now be displayed if they are included. This will work with an existing oclif CLI by adding the latest @oclif/errors and @oclif/core to the CLI's package.json dependencies.
For example, using this.error with the additional properties:
class TestError extends Command {  async run() {    this.error("An error has occurred!", {      code: "OCLIF_ERR",      ref: "https://oclif.io/docs/commands#thiserrormessage-string--error-options-code-string-exit-number",      suggestions: ["Use these extra properties to provide additional context"],    })  }}
would result with the following output:
›   Error: An error has occurred!›   Code: OCLIF_ERR›   Try this: Use these extra properties to provide additional context›   Reference: https://oclif.io/docs/commands#thiserrormessage-string--error-options-code-string-exit-number
If these properties are not provided then nothing changes and the CLI will continue to display the single error message output as it did before. Additionally, as part of this exercise we’ve added documentation around Error Handling in oclif which should come in handy if the need arises to extend oclif’s default handling of errors.Customizing Help in oclifMay 5, 2020 · 2 min readOut of the box oclif provides a great help experience for CLIs.
But what if, as an oclif developer, you want to customize some or all of the output?
You can now customize your CLI's help output by implementing the HelpBase abstract class.
Getting started with custom help​
If you have not done so yet, update @oclif/core.
$ yarn add --latest @oclif/core
To get started, first define the filepath to your help class in oclif's config in package.json. This is a relative path to the help class, without a file extension.
For this example, the help class will be created in a file at "[project root]/src/help.ts".
{  // ...  "oclif": {    "helpClass": "./lib/help"    // ...  }  // ...}
From here there are two paths, implement the HelpBase abstract class yourself or overwrite the parts of the default Help class you want to customize (ex: how command usage is displayed). We recommend the latter approach but cover both in the new Help Classes docs.
Separating TOPICS & COMMANDS in the new default Help class​
Previously, topics and child commands were listed in help output under a single list heading called "COMMANDS". But we found this can be slightly confusing. Some topics are commands also (a.k.a. topic-commands) while others are simply organizational namespacing (and when ran just show their help).
The new default Help class splits the list of children into distinct lists of "TOPICS" and "COMMANDS", with the possibility of an item appearing in both if it a topic-command. This makes it clearer what is expected to be ran - "COMMANDS" - and what is providing structure - "TOPICS" - when looking at the help output.
VERSION  plugin-help-example/0.0.0 darwin-x64 node-v12.12.0USAGE  $ plugin-help-example [COMMAND]TOPICS  topic  this is a topic and has child topics or commandsCOMMANDS  hello  describe the command here  help   display help for plugin-help-example
We look forward to seeing what custom help features you implement in your oclif CLIs with this new feature!oclif TSLint to ESLint MigrationDecember 5, 2019 · 3 min readBack in February of this year, plans were announced to deprecate TSLint in favor of ESLint. TSLint's goal has become to work toward a “unified developer experience” by supporting ESLint development going forward.
What has changed in oclif​
To keep inline with the community, oclif has transitioned to ESLint for all our core libraries as well as all our official plugins.
Starting in v1.15.x, oclif will now optionally generate projects with ESLint for both TypeScript and JavaScript CLI’s.
ESLint does require Node to be on stable LTS version, at the time of writing, Node 8.10.x, Node 10.13.x & Node 12.x.x.
How does this affect you​
Existing CLI’s are unchanged, but any newly generated CLI's will only give the option of using ESLint. If you are running tslint in your CLI, we recommend you switch to ESLint as well.
In migrating our projects we took the following steps (for an example of these changes see this pull request).


Install eslint
$ yarn add eslint eslint-config-oclif eslint-config-oclif-typescript --dev


Add eslint related files


$ echo '{  "extends": [    "oclif",    "oclif-typescript"  ],  "rules": {  }}' > .eslintrc


Remove tslint and related packages
$ yarn remove @oclif/tslint tslint


Remove tslint related configuration files
$ rm tslint.json


Change lint script in our package.json from something like:
"lint": "tsc -p test --noEmit && tslint -p test -t stylish"
to
"lint": "eslint . --ext .ts --config .eslintrc"


To preserve the test compile (tsc -p test --noEmit) we also made the following updates to our scripts:
"pretest": "tsc -p test --noEmit"
In some cases we had our posttest duplicating the same steps as our lint script so it’s cleaner to have it reference the lint job directly with:
"posttest": "yarn lint"

Run yarn lint --fix. This attempts to auto-fix any linting violations automatically. In the case an auto-fix isn’t available it should be fixed manually or ignored (see the eslint configuration doc for more information)
Do a search in the codebase for tslint and remove any unnecessary tslint disabling comments, like:

/* tslint:disable:object-literal-sort-keys */
If you are on a version of Node that is not supported by ESLint, you will also need to update your Node engine. ESLint supports Node 8, 10, and 12 so you should upgrade to the most recent Node version compatible with your CLI and also supported by ESLint (see ESLint's Installation and Usage instructions).
When will this take effect​
These changes have taken effect in oclif v1.15.1. When you generate a new CLI or plugin it will now contain configuration for ESLint instead of TSLint.oclif's Current Node SupportOctober 31, 2019 · 3 min readTo maintain a healthy project trajectory, oclif follows and supports Node Active LTS release, currently Node 10 & Node 12. This means ensuring that oclif continues to play nice with coming Active LTS Node versions and other packages in the ecosystem. Moving forward also means leaving older versions behind. Starting in 2020, Node will stop maintaining Node 8 and it is our intent at that time to also follow suit. Let’s take a look at a few ways we will be supporting these changes.
CI Environments​
CLIs created with the oclif cli going forward will be generated with a CircleCI configuration with Node 10 & 12 and an Appveyor configuration using Node 10. We have also added Node latest to CircleCi to be an early warning detection against coming Node changes (Node latest is managed by CircleCI).
We have already updated every oclif repo's CI configs to reflect this.
If your existing CLI uses either Appveyor or CircleCI you can update your config files also, like so:
.circleci/config.yml​
Your CircleCI config should contain a node-latest job, aliased as test. From this, there should be two extensions of this job for the Active LTS Node versions, Node 10 and Node 12.
  node-10:    <<: *node-latest    docker:      - image: node:10  node-12:    <<: *node-latest    docker:      - image: node:12
Notice that these declarations only change the Docker Node images used to run that job.
Additionally, the jobs listed within workflows must also be updated to reflect our changes in configuration:
    jobs:      - node-latest      - node-10      - node-12
appveyor.yml​
For appveyor we are currently only testing the oldest Active LTS Node version, Node 10. Update the nodejs_version proppert in your appveyor.yml file to reflect this.
environment:  nodejs_version: "10"
Deprecating Node 8 & Updating packge.json engines​
In Jan 2020, Node will end its Node 8 maintenance. We will follow suit by setting the package.json engine property in oclif packages to >=10 and bumping the package's major versions.
Depending on how you ship your CLI you may wish to also bump the engines version in your CLI's package.json. You can read more about the implications of the engines property configuration in the npm documentation.
Also consider distributing your CLI with its own Node version.
Packaged Node Version​
When using dev-cli to pack your CLI it will use the Node version as specified in your package.json under the oclif.update.node.version property. This value should reflect an Active LTS Node version (dev-cli does not currently enforce versions).
Supporting the future​
As a community we may discover bumps along the way as we upgrade. If you notice something related to oclif please feel free to open an issue or submit a pull request under the relevant oclif package within the org.
We look forward to using the latest from Node and the community and keeping oclif healthy along the way.oclifconf 2019: A RecapSeptember 16, 2019 · 4 min readIn May, Heroku and Salesforce Open Source organized oclifconf, a conference for developers & product managers building CLI tools on top of the open source oclif framework. The speakers came from various tech companies, such as Adobe, Netlify, and Apollo, who have already built amazing CLI experiences. The topics covered everything from the incredible capabilities oclif has unlocked, to the community-built plugins extending its functionality, and even what the behavior of an adaptive CLI tool might look like.
Below is a listing of all of the talks from the event, along with a short summary. Enjoy!
The future of oclif by Jeff Dickey​

In its relatively short lifetime, oclif has already inspired many developers and companies to adopt its framework as a means for implementing their own command-line tooling. In this talk, Jeff Dickey, an oclif founding team member, recaps the project's history and inspiration. He also looks towards the future and outlines some features and improvements that the tool could adapt. This isn't so much a definitive roadmap of where oclif is headed, but rather, a call to inspiration for developers eager to contribute! And if you are interested in contributing, check out the open issues in the oclif GitHub repo and come say "Hello!" on Spectrum Chat.
Open Source Citizenship by Josh Simmons​

When it comes to open source, it's more than just individuals now. More and more frequently, large corporations are contributing to projects by donating to contributors, sponsoring events, or upstreaming contributions. But keeping open source projects and communities healthy requires more than just money and brainpower. Josh Simmons surveyed multiple open source communities and relays his findings as to what help maintainers and contributors actually need in this talk.
Building an enterprise-grade CLI with oclif by Thomas Dvornik​

Security and performance are all about trust. While oclif is an extremely extensible framework for building CLI tooling, there are additional requirements to fulfill for enterprise businesses to adopt it that might not be necessary for individual developers. Thomas Dvornik outlines what he and his colleagues at Salesforce have implemented as plugins to oclif to satisfy these needs, including encrypted OAuth, plugin signing, lazy loading dependencies, synchronizing weekly releases and deprecations across dozens of repositories, and establishing cross-team coding and documentation standards.
How Adobe I/O built an extensible CLI with oclif by Jesse MacFadyen​

Perhaps oclif's most appealing feature is its support for plugins. In Cordova's case, they've created a sophisticated telemetry system that helps Adobe developers see which commands users are using--and reports on which ones are erroring out. By embedding a feedback system into the tool, users are even able to quickly send their suggestions to a form, without ever leaving the terminal. Jesse MacFadyen demonstrates how oclif's plugin system can work beyond simply executing commands.
Integrating oclif with GraphQL and Apollo by Evans Hauser​

For Evans Hauser and the team at Apollo, oclif is best thought of as "React for the CLI." As a client paired with a strongly-typed API contract to a server, it can deliver structured and consistent commands to retrieve external data. What better mechanism to use for this transfer than GraphQL, a framework which empowers the client to ask precisely for the data it needs, and nothing more?
Adaptive Intent-based CLI State Machines by Shawn Wang​

In designing oclif, Jeff Dickey wrote out 12 CLI factors to keep in mind. In this talk, Shawn Wang outlines a 13th: state. State is hard, because it depends on context, and context depends on understanding what a user intends to do, not what they are asking. Shawn is working towards enabling oclif to better understand the commands a user has entered, so that it can predict and interpret future commands that might be entered next. This would enable CLI tools to not just interpret a users' commands, but to also interpret their intent.\n\nIntroducing `oclif init` commandApril 10, 2024 · 2 min readThanks to the contribution of @joshcanhelp we released a new command for the oclif CLI called oclif init in version 4.8.0
The oclif init command allows you to initialize oclif in an existing project directory by adding the bare minimum requirements: a few pieces of configuration, bin scripts, and a couple of dependencies (@oclif/core and ts-node). This is slightly different from oclif generate, which will create an entirely new oclif project based on our templates.
oclif init will add the following:

bin scripts: bin/run.js, bin/run.cmd, bin/dev.js, and bin/dev.cmd
oclif section to package.json with bin, dirname, commands, and topicSeparator set (See Configuring Your CLI for more)
@oclif/core to dependencies in your package.json (if it's not already there)
ts-node to devDependencies in your package.json (if it's not already there)

Once you've initialized oclif, you can use the bin scripts to execute your CLI. You can also use the other oclif commands like oclif generate command and oclif generate hook to start adding new functionality.

❯ oclif init --helpInitialize a new oclif CLIUSAGE  $ oclif init [--bin <value>] [--module-type ESM|CommonJS] [--package-manager npm|yarn|pnpm] [--topic-separator    colons|spaces] [-d <value>] [-y]FLAGS  -d, --output-dir=<value>        Directory to initialize the CLI in.  -y, --yes                       Use defaults for all prompts. Individual flags will override defaults.      --bin=<value>               Supply answer for prompt: Command bin name the CLI will export      --module-type=<option>      Supply answer for prompt: Select a module type                                  <options: ESM|CommonJS>      --package-manager=<option>  Supply answer for prompt: Select a package manager                                  <options: npm|yarn|pnpm>      --topic-separator=<option>  Supply answer for prompt: Select a topic separator                                  <options: colons|spaces>DESCRIPTION  Initialize a new oclif CLI  This will add the necessary oclif bin files, add oclif config to package.json, and install @oclif/core and ts-node.EXAMPLES  Initialize a new CLI in the current directory    $ oclif init  Initialize a new CLI in a different directory    $ oclif init --output-dir "/path/to/existing/project"  Supply answers for specific prompts    $ oclif init --topic-separator colons --bin mycli
Hope you enjoy the new command! If you come across any issues or have any new ideas for this command, head over to the oclif/oclif repo and open a new issue.
All our best,
The oclif teamoclif Spring 2024 UpdateMarch 29, 2024 · 4 min readHello oclif developers! It's been a while since we last uploaded a blog - and a lot has happened.
We've been focusing on these high-level areas over the past couple of years:

Improving @oclif/core
ESM Support
Improving and revitalizing oclif.io
Re-engaging the oclif community

Improving @oclif/core​
Since we announced @oclif/core over three years ago, we've released two new major versions, each packed with lots of features that we're really excited about.
Here are some of these changes:

Full support for ESM and interoperability with CommonJS (more on this topic below).
Configurable command discovery strategies that give you more control over how commands are loaded at runtime. Check out the docs.
A new preparse hook that allows you to manipulate the provided arguments before they're parsed. Salesforce used this hook to implement a neat --flags-dir feature that translates local files into flags.
A new Performance class that you can use to track performance inside of @oclif/core and your own CLI or plugin. Check out the docs.
A new flag type, Flags.option, that lets you define a flag with a preset list of options. Typescript then uses the options to infer the flag's type.
Flags now have a relationship property that allows you to define more complex relationships between flags. Check out the flags docs for more information.
Flags now have a defaultHelp property that allows you to set the human readable default value in the command help. This property is useful when your flag's parse method returns a complex type, such as an object or a class. Check out the flags docs for more.
Commands now have a hiddenAliases property that allows you to define aliases that you want to hide from the user. The property is super helpful when you're trying to wean users off a deprecated command.
You can now use bun or tsx as dev runtimes (as opposed to node or ts-node).
A command's usage, args, and flags are now shown whenever a user forgets to provide a required arg or flag, or when they provided a non-existent flag.

If you need help migrating to the latest version, head over to core's README which has links to the migration guides. Feel free to open a new discussion if you need more hands-on help from us or the community.
ESM Support​
Version 3 of @oclif/core introduced full support for developing ESM plugins and CLIs. It also offered full support for interoperability between CommonJS and ESM plugins.
Put more simply, you can now migrate your CLI to ESM while keeping individual plugins in CommonJS (or vice versa). The upgrade path is now much simpler for you. You also don't need to worry about any community plugins that have migrated to ESM before you did (such as all the @oclif plugins) or are staunchly sticking with CommonJS for the foreseeable future.
Read more about this topic here.
Improving and Revitalizing oclif.io​
Another area of focus for us has been improving our documentation site, oclif.io.
While improving the quality and accuracy of the documentation was our priority, we also took the time to upgrade to the latest version of docusaurus. This new version gave our site a much-needed facelift, as well as cool new features such as dark mode and announcements.
If you have any feedback or are running into issues, we want to hear about it. Just create an issue in the oclif.io repo.
Re-engaging the oclif Community​
Lastly, our biggest priority at the moment is to re-engage the oclif community. We understand how frustrating it has been over the years to see your issues and pull requests go unacknowledged. We apologize for not prioritizing the community, and are earnestly trying to make sure that every issue and pull request gets the attention it deserves going forward.
We also opened up GitHub discussions for @oclif/core and the oclif CLI, where you can now post your questions or ideas. We hope you take advantage of them, we love hearing from you!
One last thing: we intend to publicly post our roadmap so you have more visibility into what we're working on. Stay tuned!
All our best,
The oclif teamAnnouncing oclif v2!January 12, 2022 · 5 min readHello and happy new year! It's our great pleasure to announce that we have released oclif v2, which uses the new @oclif/core library! 🎉
oclif v2 includes many changes that improve the experience of both creating and using an oclif CLI.
Going forward, we don't plan to make any updates to oclif v1 and its corresponding libraries, except for critical security fixes. See the compatibility matrix for a list of these libraries. In order to give developers time to migrate from v1 to v2, we're not completely dropping support yet. But at some point in the future we'll archive the v1 repositories and deprecate their versions on npm.
What’s changing?​
Repository Changes​
All repositories under the oclif org now use main as their primary branch and oclif-v1 as the legacy branch. The main  branch corresponds to oclif v2 and the oclif-v1 branch to oclif v1. If you find any repos that don’t have a main branch, you can safely assume that they're not used in oclif v2 and will be deprecated in the future.
Consolidating Tools & Libraries​
The oclif-dev CLI has now been incorporated into oclif. You now no longer need to install a separate package to manage your entire CLI’s lifecycle.
The following libraries have been consolidated under @oclif/core and will be deprecated at some point in the future. Read the migration guide to learn how to update your CLI or plugin to use the new core library.

@oclif/command
@oclif/config
@oclif/error
@oclif/help
@oclif/parser

No more single vs multi command CLIs​
There's only one "type" of oclif v2 CLI, but it can have as few or as many commands as a developer wants. As a result, there’s only one command to generate CLIs, oclif generate, as opposed to the old oclif single and oclif multi commands.
Node > 12​
To ensure oclif CLIs are as secure as possible, all v2 libraries and plugins support only Node 12 or higher as of now. Going forward, they'll support only Node Maintenance or higher, as defined by Node's release schedule here: https://nodejs.org/en/about/releases/.
What’s new?​
New example CLI​
oclif-hello-world is our new example repo. This is also the repo that's used as a template when running oclif generate to create a new CLI. This repo will always be able to be referenced as an example of what an oclif v2 CLI should look like.
Spaced commands​
oclif CLIs can now use spaces, instead of colons, to separate topics and subcommands. To enable this feature, simply add “topicSeparator": " " to the oclif config in your package.json. See an example in our example repo.
// Old commands that use :$ mycli do:something
// New spaced commands$ mycli do something

Note: Spaced commands are backwards compatible. So if you enable spaced commands for your CLI, users will still be able to use : as a separator. This ensures that any existing scripts don't break.

New Help Output​
We’ve revamped the way command help is outputted to the terminal, making it both easier to implement and easier to read. See the difference between the old help output on the left and the new help output on the right in the screenshots below.
oclif v1oclif v2
Notice that there are new sections for flags and global flags, examples are displayed with better spacing, and there is a section at the bottom called Configuration Variables. This Configuration Variables section is not part of the new help by default. But we've added support for custom help sections, which is what the sf CLI uses to create the new section.
Async Command Parsing​
We’ve also improved the performance of new CLIs by rewriting how commands are parsed on initialization. The new parser is asynchronous, which makes CLIs with a lot of commands or installed  plugins much faster.
What’s coming next?​
Part of our charter for the release of oclif v2 includes improving our engagement with the oclif community. We know that over the past couple of years we’ve reduced our involvement, and a lot of issues and PRs have languished in limbo. Hopefully you’ve already seen increased activity and responses from oclif maintainers recently, but if you haven’t, please don’t hesitate to ping us by tagging @admins in oclif repos.
We also want to start interviewing members of the oclif community to acquire feedback and prioritize the features and fixes you deem most important!
Best,
The oclif team

Reference material​
Migration Guide​
This guide explains how to upgrade a CLI or plugin from the old oclif v1 libraries to the new @oclif/core library that oclif v2 uses.
https://github.com/oclif/core/blob/main/MIGRATION.md
Compatibility Matrix​
The following matrix shows how the v1 libraries and plugins relate to the new v2 ones. Use this matrix as a guide to know what to drop and which versions to switch when upgrading your plugins and CLIs to v2.
oclif "v1"oclif "v2"Utility CLIsoclif@<2@oclif/dev-cli@<2oclif@>=2Main packages@oclif/command@oclif/config@oclif/errors@oclif/parser@oclif/plugin-help@oclif/core@>=1Node LTSNode v8-14Node v12+ (at time of writing)TypeScripttypescript@<4typescript@>=4Main plugins@oclif/plugin-autocomplete@<1@oclif/plugin-commands@<2@oclif/plugin-help@<4@oclif/plugin-not-found@<2@oclif/plugin-plugins@<2@oclif/plugin-update@<2plugin-warn-if-update-available@<2plugin-which@<2@oclif/plugin-autocomplete@>=1@oclif/plugin-commands@>=2@oclif/plugin-help@>=4@oclif/plugin-not-found@>=2@oclif/plugin-plugins@>=2@oclif/plugin-update@>=2@oclif/plugin-warn-if-update-available@>=2@oclif/plugin-which@>=2Introducing @oclif/coreMarch 1, 2021 · 3 min readGreetings!
We hope this blog post finds you well.
Introducing...​
We are excited to announce the next iteration of the oclif project today: @oclif/core.
We have learned a lot in the last three years of developing oclif, developing on oclif and supporting millions of command runs a day via Heroku and Salesforce CLIs.
@oclif/core ("Core") simplifies the oclif development experience and introduces highly requested new features.
Core combines the essential oclif packages into one "core" package, aptly named @oclif/core.
Core also introduces:

A default command option
Colon or space command syntax
Async command parsing
Command piping to arguments

With the introduction of default command functionality, Core simplifies the oclif project and removes the notion of single or multi command CLIs. Core CLIs can have 1 or many commands.
Along with Core, we moved the oclif-dev CLI into the oclif CLI creating a single "utility" CLI. This CLI also introduces a new AWS S3 compatible publishing scheme.
What to expect in the near future​
Core is in pre-release beta and being actively developed for new internal Salesforce CLIs.
Much documentation needs to be written in the coming months including migration paths. Migration onto Core should be as painless as possible with many exports remaining entirely unchanged. Look for forthcoming blog posts and documentation on oclif.io.
Early this summer, tentively June 1, we will release Core v1. Core's release will coincide with major bumps to many other oclif plugin packages. See the compatibility matrix below.
At Core's v1 release, the current "main" oclif packages (namely: command, config, errors & parser) will go into maintenance mode until Jan 2022. They will receive only bug and security fixes and they remain compatible with current versions of the oclif and oclif-dev CLIs. Afterwhich, they will be archived.
Companioning Core, the next major release of the oclif CLI (literally oclif@2) will generate Core CLIs.
Going forward​
We are excited to release Core! We invite you to poke around the Core repo. It may appear to be a big change but Core keeps what you already enjoy about oclif while reducing development complexity, project dependencies, package coupling and bundle size and introduces many requested features previously too prickly to weave into the current oclif architecture.
Best,
The oclif team
Reference: Compatibility matrix​
oclif "v1"oclif "Core"Utility CLIsoclif@<2@oclif/dev-cli@<2oclif@>=2Main packages@oclif/core@<2@oclif/config@<2@oclif/errors@<2@oclif/parser@<4@oclif/plugin-help@<4@oclif/core@>=1Node LTSNode v8-14Node v12+TypeScripttypescript@<4typescript@>=4Main plugins@oclif/plugin-autocomplete@<1@oclif/plugin-commands@<2@oclif/plugin-help@<4@oclif/plugin-not-found@<2@oclif/plugin-plugins@<2@oclif/plugin-update@<2plugin-warn-if-update-available@<2plugin-which@<2@oclif/plugin-autocomplete@>=2@oclif/plugin-commands@>=2@oclif/plugin-help@>=4@oclif/plugin-not-found@>=2@oclif/plugin-plugins@>=2@oclif/plugin-update@>=2@oclif/plugin-warn-if-update-available@>=2@oclif/plugin-which@>=2oclif Summer 2020 UpdateAugust 26, 2020 · 2 min readHello oclif developers! We hope you are all doing well.
Earlier this year, we started our planning for oclifconf v2 and, like all conference, had to change course. We opted not to hold a virtual conference, however, we wanted to take some time to highlight a few oclif features shipped this year.
Feature: Help templating​
One of the most requested features, help templating enables oclif developers to customize the help output for their CLI.
Read the announcement.
Feature: Custom error delegation​
This feature both improved how oclif throws and handles errors and allows oclif developers to overwrite or interject in oclif’s error handling.
Read the announcement.
Feature: postrun hooks​
We have added a new lifecycle event postrun. Your CLI can now run a hook after a command has ran.
See our hook documentation.
Feature: Root index command​
Previously, oclif would display CLI help if only the binary name with no command ID was invoked, oclif now supports a "root index" command. If present, a command defined at src/commands/index.ts will be run if no command ID is found.
1 million weekly downloads​
While exact oclif usage metrics are hard to pin down, we use npm download statistics of oclif packages as a rough approximation. Earlier this year, oclif's command package hit 1 million weekly downloads for the first time!
This year has been presented its challenges on everyone. We want to thank you, oclif developers, whom have taken the time to use and improve the oclif project. We look forward to seeing you all - in person - in the future!
All our best,
The oclif teamPretty Printable ErrorsJuly 1, 2020 · One min readOften CLIs are used as handy tools and when things go wrong it’s useful to have additional context. In oclif we have added a couple of additional properties that can show extra context to the users when an error is displayed. The code, ref and suggestions will now be displayed if they are included. This will work with an existing oclif CLI by adding the latest @oclif/errors and @oclif/core to the CLI's package.json dependencies.
For example, using this.error with the additional properties:
class TestError extends Command {  async run() {    this.error("An error has occurred!", {      code: "OCLIF_ERR",      ref: "https://oclif.io/docs/commands#thiserrormessage-string--error-options-code-string-exit-number",      suggestions: ["Use these extra properties to provide additional context"],    })  }}
would result with the following output:
›   Error: An error has occurred!›   Code: OCLIF_ERR›   Try this: Use these extra properties to provide additional context›   Reference: https://oclif.io/docs/commands#thiserrormessage-string--error-options-code-string-exit-number
If these properties are not provided then nothing changes and the CLI will continue to display the single error message output as it did before. Additionally, as part of this exercise we’ve added documentation around Error Handling in oclif which should come in handy if the need arises to extend oclif’s default handling of errors.Customizing Help in oclifMay 5, 2020 · 2 min readOut of the box oclif provides a great help experience for CLIs.
But what if, as an oclif developer, you want to customize some or all of the output?
You can now customize your CLI's help output by implementing the HelpBase abstract class.
Getting started with custom help​
If you have not done so yet, update @oclif/core.
$ yarn add --latest @oclif/core
To get started, first define the filepath to your help class in oclif's config in package.json. This is a relative path to the help class, without a file extension.
For this example, the help class will be created in a file at "[project root]/src/help.ts".
{  // ...  "oclif": {    "helpClass": "./lib/help"    // ...  }  // ...}
From here there are two paths, implement the HelpBase abstract class yourself or overwrite the parts of the default Help class you want to customize (ex: how command usage is displayed). We recommend the latter approach but cover both in the new Help Classes docs.
Separating TOPICS & COMMANDS in the new default Help class​
Previously, topics and child commands were listed in help output under a single list heading called "COMMANDS". But we found this can be slightly confusing. Some topics are commands also (a.k.a. topic-commands) while others are simply organizational namespacing (and when ran just show their help).
The new default Help class splits the list of children into distinct lists of "TOPICS" and "COMMANDS", with the possibility of an item appearing in both if it a topic-command. This makes it clearer what is expected to be ran - "COMMANDS" - and what is providing structure - "TOPICS" - when looking at the help output.
VERSION  plugin-help-example/0.0.0 darwin-x64 node-v12.12.0USAGE  $ plugin-help-example [COMMAND]TOPICS  topic  this is a topic and has child topics or commandsCOMMANDS  hello  describe the command here  help   display help for plugin-help-example
We look forward to seeing what custom help features you implement in your oclif CLIs with this new feature!oclif TSLint to ESLint MigrationDecember 5, 2019 · 3 min readBack in February of this year, plans were announced to deprecate TSLint in favor of ESLint. TSLint's goal has become to work toward a “unified developer experience” by supporting ESLint development going forward.
What has changed in oclif​
To keep inline with the community, oclif has transitioned to ESLint for all our core libraries as well as all our official plugins.
Starting in v1.15.x, oclif will now optionally generate projects with ESLint for both TypeScript and JavaScript CLI’s.
ESLint does require Node to be on stable LTS version, at the time of writing, Node 8.10.x, Node 10.13.x & Node 12.x.x.
How does this affect you​
Existing CLI’s are unchanged, but any newly generated CLI's will only give the option of using ESLint. If you are running tslint in your CLI, we recommend you switch to ESLint as well.
In migrating our projects we took the following steps (for an example of these changes see this pull request).


Install eslint
$ yarn add eslint eslint-config-oclif eslint-config-oclif-typescript --dev


Add eslint related files


$ echo '{  "extends": [    "oclif",    "oclif-typescript"  ],  "rules": {  }}' > .eslintrc


Remove tslint and related packages
$ yarn remove @oclif/tslint tslint


Remove tslint related configuration files
$ rm tslint.json


Change lint script in our package.json from something like:
"lint": "tsc -p test --noEmit && tslint -p test -t stylish"
to
"lint": "eslint . --ext .ts --config .eslintrc"


To preserve the test compile (tsc -p test --noEmit) we also made the following updates to our scripts:
"pretest": "tsc -p test --noEmit"
In some cases we had our posttest duplicating the same steps as our lint script so it’s cleaner to have it reference the lint job directly with:
"posttest": "yarn lint"

Run yarn lint --fix. This attempts to auto-fix any linting violations automatically. In the case an auto-fix isn’t available it should be fixed manually or ignored (see the eslint configuration doc for more information)
Do a search in the codebase for tslint and remove any unnecessary tslint disabling comments, like:

/* tslint:disable:object-literal-sort-keys */
If you are on a version of Node that is not supported by ESLint, you will also need to update your Node engine. ESLint supports Node 8, 10, and 12 so you should upgrade to the most recent Node version compatible with your CLI and also supported by ESLint (see ESLint's Installation and Usage instructions).
When will this take effect​
These changes have taken effect in oclif v1.15.1. When you generate a new CLI or plugin it will now contain configuration for ESLint instead of TSLint.oclif's Current Node SupportOctober 31, 2019 · 3 min readTo maintain a healthy project trajectory, oclif follows and supports Node Active LTS release, currently Node 10 & Node 12. This means ensuring that oclif continues to play nice with coming Active LTS Node versions and other packages in the ecosystem. Moving forward also means leaving older versions behind. Starting in 2020, Node will stop maintaining Node 8 and it is our intent at that time to also follow suit. Let’s take a look at a few ways we will be supporting these changes.
CI Environments​
CLIs created with the oclif cli going forward will be generated with a CircleCI configuration with Node 10 & 12 and an Appveyor configuration using Node 10. We have also added Node latest to CircleCi to be an early warning detection against coming Node changes (Node latest is managed by CircleCI).
We have already updated every oclif repo's CI configs to reflect this.
If your existing CLI uses either Appveyor or CircleCI you can update your config files also, like so:
.circleci/config.yml​
Your CircleCI config should contain a node-latest job, aliased as test. From this, there should be two extensions of this job for the Active LTS Node versions, Node 10 and Node 12.
  node-10:    <<: *node-latest    docker:      - image: node:10  node-12:    <<: *node-latest    docker:      - image: node:12
Notice that these declarations only change the Docker Node images used to run that job.
Additionally, the jobs listed within workflows must also be updated to reflect our changes in configuration:
    jobs:      - node-latest      - node-10      - node-12
appveyor.yml​
For appveyor we are currently only testing the oldest Active LTS Node version, Node 10. Update the nodejs_version proppert in your appveyor.yml file to reflect this.
environment:  nodejs_version: "10"
Deprecating Node 8 & Updating packge.json engines​
In Jan 2020, Node will end its Node 8 maintenance. We will follow suit by setting the package.json engine property in oclif packages to >=10 and bumping the package's major versions.
Depending on how you ship your CLI you may wish to also bump the engines version in your CLI's package.json. You can read more about the implications of the engines property configuration in the npm documentation.
Also consider distributing your CLI with its own Node version.
Packaged Node Version​
When using dev-cli to pack your CLI it will use the Node version as specified in your package.json under the oclif.update.node.version property. This value should reflect an Active LTS Node version (dev-cli does not currently enforce versions).
Supporting the future​
As a community we may discover bumps along the way as we upgrade. If you notice something related to oclif please feel free to open an issue or submit a pull request under the relevant oclif package within the org.
We look forward to using the latest from Node and the community and keeping oclif healthy along the way.oclifconf 2019: A RecapSeptember 16, 2019 · 4 min readIn May, Heroku and Salesforce Open Source organized oclifconf, a conference for developers & product managers building CLI tools on top of the open source oclif framework. The speakers came from various tech companies, such as Adobe, Netlify, and Apollo, who have already built amazing CLI experiences. The topics covered everything from the incredible capabilities oclif has unlocked, to the community-built plugins extending its functionality, and even what the behavior of an adaptive CLI tool might look like.
Below is a listing of all of the talks from the event, along with a short summary. Enjoy!
The future of oclif by Jeff Dickey​

In its relatively short lifetime, oclif has already inspired many developers and companies to adopt its framework as a means for implementing their own command-line tooling. In this talk, Jeff Dickey, an oclif founding team member, recaps the project's history and inspiration. He also looks towards the future and outlines some features and improvements that the tool could adapt. This isn't so much a definitive roadmap of where oclif is headed, but rather, a call to inspiration for developers eager to contribute! And if you are interested in contributing, check out the open issues in the oclif GitHub repo and come say "Hello!" on Spectrum Chat.
Open Source Citizenship by Josh Simmons​

When it comes to open source, it's more than just individuals now. More and more frequently, large corporations are contributing to projects by donating to contributors, sponsoring events, or upstreaming contributions. But keeping open source projects and communities healthy requires more than just money and brainpower. Josh Simmons surveyed multiple open source communities and relays his findings as to what help maintainers and contributors actually need in this talk.
Building an enterprise-grade CLI with oclif by Thomas Dvornik​

Security and performance are all about trust. While oclif is an extremely extensible framework for building CLI tooling, there are additional requirements to fulfill for enterprise businesses to adopt it that might not be necessary for individual developers. Thomas Dvornik outlines what he and his colleagues at Salesforce have implemented as plugins to oclif to satisfy these needs, including encrypted OAuth, plugin signing, lazy loading dependencies, synchronizing weekly releases and deprecations across dozens of repositories, and establishing cross-team coding and documentation standards.
How Adobe I/O built an extensible CLI with oclif by Jesse MacFadyen​

Perhaps oclif's most appealing feature is its support for plugins. In Cordova's case, they've created a sophisticated telemetry system that helps Adobe developers see which commands users are using--and reports on which ones are erroring out. By embedding a feedback system into the tool, users are even able to quickly send their suggestions to a form, without ever leaving the terminal. Jesse MacFadyen demonstrates how oclif's plugin system can work beyond simply executing commands.
Integrating oclif with GraphQL and Apollo by Evans Hauser​

For Evans Hauser and the team at Apollo, oclif is best thought of as "React for the CLI." As a client paired with a strongly-typed API contract to a server, it can deliver structured and consistent commands to retrieve external data. What better mechanism to use for this transfer than GraphQL, a framework which empowers the client to ask precisely for the data it needs, and nothing more?
Adaptive Intent-based CLI State Machines by Shawn Wang​

In designing oclif, Jeff Dickey wrote out 12 CLI factors to keep in mind. In this talk, Shawn Wang outlines a 13th: state. State is hard, because it depends on context, and context depends on understanding what a user intends to do, not what they are asking. Shawn is working towards enabling oclif to better understand the commands a user has entered, so that it can predict and interpret future commands that might be entered next. This would enable CLI tools to not just interpret a users' commands, but to also interpret their intent.Older Entries\n\n\n\nIntroducing `oclif init` commandApril 10, 2024 · 2 min readThanks to the contribution of @joshcanhelp we released a new command for the oclif CLI called oclif init in version 4.8.0
The oclif init command allows you to initialize oclif in an existing project directory by adding the bare minimum requirements: a few pieces of configuration, bin scripts, and a couple of dependencies (@oclif/core and ts-node). This is slightly different from oclif generate, which will create an entirely new oclif project based on our templates.
oclif init will add the following:

bin scripts: bin/run.js, bin/run.cmd, bin/dev.js, and bin/dev.cmd
oclif section to package.json with bin, dirname, commands, and topicSeparator set (See Configuring Your CLI for more)
@oclif/core to dependencies in your package.json (if it's not already there)
ts-node to devDependencies in your package.json (if it's not already there)

Once you've initialized oclif, you can use the bin scripts to execute your CLI. You can also use the other oclif commands like oclif generate command and oclif generate hook to start adding new functionality.

❯ oclif init --helpInitialize a new oclif CLIUSAGE  $ oclif init [--bin <value>] [--module-type ESM|CommonJS] [--package-manager npm|yarn|pnpm] [--topic-separator    colons|spaces] [-d <value>] [-y]FLAGS  -d, --output-dir=<value>        Directory to initialize the CLI in.  -y, --yes                       Use defaults for all prompts. Individual flags will override defaults.      --bin=<value>               Supply answer for prompt: Command bin name the CLI will export      --module-type=<option>      Supply answer for prompt: Select a module type                                  <options: ESM|CommonJS>      --package-manager=<option>  Supply answer for prompt: Select a package manager                                  <options: npm|yarn|pnpm>      --topic-separator=<option>  Supply answer for prompt: Select a topic separator                                  <options: colons|spaces>DESCRIPTION  Initialize a new oclif CLI  This will add the necessary oclif bin files, add oclif config to package.json, and install @oclif/core and ts-node.EXAMPLES  Initialize a new CLI in the current directory    $ oclif init  Initialize a new CLI in a different directory    $ oclif init --output-dir "/path/to/existing/project"  Supply answers for specific prompts    $ oclif init --topic-separator colons --bin mycli
Hope you enjoy the new command! If you come across any issues or have any new ideas for this command, head over to the oclif/oclif repo and open a new issue.
All our best,
The oclif teamoclif Spring 2024 UpdateMarch 29, 2024 · 4 min readHello oclif developers! It's been a while since we last uploaded a blog - and a lot has happened.
We've been focusing on these high-level areas over the past couple of years:

Improving @oclif/core
ESM Support
Improving and revitalizing oclif.io
Re-engaging the oclif community

Improving @oclif/core​
Since we announced @oclif/core over three years ago, we've released two new major versions, each packed with lots of features that we're really excited about.
Here are some of these changes:

Full support for ESM and interoperability with CommonJS (more on this topic below).
Configurable command discovery strategies that give you more control over how commands are loaded at runtime. Check out the docs.
A new preparse hook that allows you to manipulate the provided arguments before they're parsed. Salesforce used this hook to implement a neat --flags-dir feature that translates local files into flags.
A new Performance class that you can use to track performance inside of @oclif/core and your own CLI or plugin. Check out the docs.
A new flag type, Flags.option, that lets you define a flag with a preset list of options. Typescript then uses the options to infer the flag's type.
Flags now have a relationship property that allows you to define more complex relationships between flags. Check out the flags docs for more information.
Flags now have a defaultHelp property that allows you to set the human readable default value in the command help. This property is useful when your flag's parse method returns a complex type, such as an object or a class. Check out the flags docs for more.
Commands now have a hiddenAliases property that allows you to define aliases that you want to hide from the user. The property is super helpful when you're trying to wean users off a deprecated command.
You can now use bun or tsx as dev runtimes (as opposed to node or ts-node).
A command's usage, args, and flags are now shown whenever a user forgets to provide a required arg or flag, or when they provided a non-existent flag.

If you need help migrating to the latest version, head over to core's README which has links to the migration guides. Feel free to open a new discussion if you need more hands-on help from us or the community.
ESM Support​
Version 3 of @oclif/core introduced full support for developing ESM plugins and CLIs. It also offered full support for interoperability between CommonJS and ESM plugins.
Put more simply, you can now migrate your CLI to ESM while keeping individual plugins in CommonJS (or vice versa). The upgrade path is now much simpler for you. You also don't need to worry about any community plugins that have migrated to ESM before you did (such as all the @oclif plugins) or are staunchly sticking with CommonJS for the foreseeable future.
Read more about this topic here.
Improving and Revitalizing oclif.io​
Another area of focus for us has been improving our documentation site, oclif.io.
While improving the quality and accuracy of the documentation was our priority, we also took the time to upgrade to the latest version of docusaurus. This new version gave our site a much-needed facelift, as well as cool new features such as dark mode and announcements.
If you have any feedback or are running into issues, we want to hear about it. Just create an issue in the oclif.io repo.
Re-engaging the oclif Community​
Lastly, our biggest priority at the moment is to re-engage the oclif community. We understand how frustrating it has been over the years to see your issues and pull requests go unacknowledged. We apologize for not prioritizing the community, and are earnestly trying to make sure that every issue and pull request gets the attention it deserves going forward.
We also opened up GitHub discussions for @oclif/core and the oclif CLI, where you can now post your questions or ideas. We hope you take advantage of them, we love hearing from you!
One last thing: we intend to publicly post our roadmap so you have more visibility into what we're working on. Stay tuned!
All our best,
The oclif teamAnnouncing oclif v2!January 12, 2022 · 5 min readHello and happy new year! It's our great pleasure to announce that we have released oclif v2, which uses the new @oclif/core library! 🎉
oclif v2 includes many changes that improve the experience of both creating and using an oclif CLI.
Going forward, we don't plan to make any updates to oclif v1 and its corresponding libraries, except for critical security fixes. See the compatibility matrix for a list of these libraries. In order to give developers time to migrate from v1 to v2, we're not completely dropping support yet. But at some point in the future we'll archive the v1 repositories and deprecate their versions on npm.
What’s changing?​
Repository Changes​
All repositories under the oclif org now use main as their primary branch and oclif-v1 as the legacy branch. The main  branch corresponds to oclif v2 and the oclif-v1 branch to oclif v1. If you find any repos that don’t have a main branch, you can safely assume that they're not used in oclif v2 and will be deprecated in the future.
Consolidating Tools & Libraries​
The oclif-dev CLI has now been incorporated into oclif. You now no longer need to install a separate package to manage your entire CLI’s lifecycle.
The following libraries have been consolidated under @oclif/core and will be deprecated at some point in the future. Read the migration guide to learn how to update your CLI or plugin to use the new core library.

@oclif/command
@oclif/config
@oclif/error
@oclif/help
@oclif/parser

No more single vs multi command CLIs​
There's only one "type" of oclif v2 CLI, but it can have as few or as many commands as a developer wants. As a result, there’s only one command to generate CLIs, oclif generate, as opposed to the old oclif single and oclif multi commands.
Node > 12​
To ensure oclif CLIs are as secure as possible, all v2 libraries and plugins support only Node 12 or higher as of now. Going forward, they'll support only Node Maintenance or higher, as defined by Node's release schedule here: https://nodejs.org/en/about/releases/.
What’s new?​
New example CLI​
oclif-hello-world is our new example repo. This is also the repo that's used as a template when running oclif generate to create a new CLI. This repo will always be able to be referenced as an example of what an oclif v2 CLI should look like.
Spaced commands​
oclif CLIs can now use spaces, instead of colons, to separate topics and subcommands. To enable this feature, simply add “topicSeparator": " " to the oclif config in your package.json. See an example in our example repo.
// Old commands that use :$ mycli do:something
// New spaced commands$ mycli do something

Note: Spaced commands are backwards compatible. So if you enable spaced commands for your CLI, users will still be able to use : as a separator. This ensures that any existing scripts don't break.

New Help Output​
We’ve revamped the way command help is outputted to the terminal, making it both easier to implement and easier to read. See the difference between the old help output on the left and the new help output on the right in the screenshots below.
oclif v1oclif v2
Notice that there are new sections for flags and global flags, examples are displayed with better spacing, and there is a section at the bottom called Configuration Variables. This Configuration Variables section is not part of the new help by default. But we've added support for custom help sections, which is what the sf CLI uses to create the new section.
Async Command Parsing​
We’ve also improved the performance of new CLIs by rewriting how commands are parsed on initialization. The new parser is asynchronous, which makes CLIs with a lot of commands or installed  plugins much faster.
What’s coming next?​
Part of our charter for the release of oclif v2 includes improving our engagement with the oclif community. We know that over the past couple of years we’ve reduced our involvement, and a lot of issues and PRs have languished in limbo. Hopefully you’ve already seen increased activity and responses from oclif maintainers recently, but if you haven’t, please don’t hesitate to ping us by tagging @admins in oclif repos.
We also want to start interviewing members of the oclif community to acquire feedback and prioritize the features and fixes you deem most important!
Best,
The oclif team

Reference material​
Migration Guide​
This guide explains how to upgrade a CLI or plugin from the old oclif v1 libraries to the new @oclif/core library that oclif v2 uses.
https://github.com/oclif/core/blob/main/MIGRATION.md
Compatibility Matrix​
The following matrix shows how the v1 libraries and plugins relate to the new v2 ones. Use this matrix as a guide to know what to drop and which versions to switch when upgrading your plugins and CLIs to v2.
oclif "v1"oclif "v2"Utility CLIsoclif@<2@oclif/dev-cli@<2oclif@>=2Main packages@oclif/command@oclif/config@oclif/errors@oclif/parser@oclif/plugin-help@oclif/core@>=1Node LTSNode v8-14Node v12+ (at time of writing)TypeScripttypescript@<4typescript@>=4Main plugins@oclif/plugin-autocomplete@<1@oclif/plugin-commands@<2@oclif/plugin-help@<4@oclif/plugin-not-found@<2@oclif/plugin-plugins@<2@oclif/plugin-update@<2plugin-warn-if-update-available@<2plugin-which@<2@oclif/plugin-autocomplete@>=1@oclif/plugin-commands@>=2@oclif/plugin-help@>=4@oclif/plugin-not-found@>=2@oclif/plugin-plugins@>=2@oclif/plugin-update@>=2@oclif/plugin-warn-if-update-available@>=2@oclif/plugin-which@>=2Introducing @oclif/coreMarch 1, 2021 · 3 min readGreetings!
We hope this blog post finds you well.
Introducing...​
We are excited to announce the next iteration of the oclif project today: @oclif/core.
We have learned a lot in the last three years of developing oclif, developing on oclif and supporting millions of command runs a day via Heroku and Salesforce CLIs.
@oclif/core ("Core") simplifies the oclif development experience and introduces highly requested new features.
Core combines the essential oclif packages into one "core" package, aptly named @oclif/core.
Core also introduces:

A default command option
Colon or space command syntax
Async command parsing
Command piping to arguments

With the introduction of default command functionality, Core simplifies the oclif project and removes the notion of single or multi command CLIs. Core CLIs can have 1 or many commands.
Along with Core, we moved the oclif-dev CLI into the oclif CLI creating a single "utility" CLI. This CLI also introduces a new AWS S3 compatible publishing scheme.
What to expect in the near future​
Core is in pre-release beta and being actively developed for new internal Salesforce CLIs.
Much documentation needs to be written in the coming months including migration paths. Migration onto Core should be as painless as possible with many exports remaining entirely unchanged. Look for forthcoming blog posts and documentation on oclif.io.
Early this summer, tentively June 1, we will release Core v1. Core's release will coincide with major bumps to many other oclif plugin packages. See the compatibility matrix below.
At Core's v1 release, the current "main" oclif packages (namely: command, config, errors & parser) will go into maintenance mode until Jan 2022. They will receive only bug and security fixes and they remain compatible with current versions of the oclif and oclif-dev CLIs. Afterwhich, they will be archived.
Companioning Core, the next major release of the oclif CLI (literally oclif@2) will generate Core CLIs.
Going forward​
We are excited to release Core! We invite you to poke around the Core repo. It may appear to be a big change but Core keeps what you already enjoy about oclif while reducing development complexity, project dependencies, package coupling and bundle size and introduces many requested features previously too prickly to weave into the current oclif architecture.
Best,
The oclif team
Reference: Compatibility matrix​
oclif "v1"oclif "Core"Utility CLIsoclif@<2@oclif/dev-cli@<2oclif@>=2Main packages@oclif/core@<2@oclif/config@<2@oclif/errors@<2@oclif/parser@<4@oclif/plugin-help@<4@oclif/core@>=1Node LTSNode v8-14Node v12+TypeScripttypescript@<4typescript@>=4Main plugins@oclif/plugin-autocomplete@<1@oclif/plugin-commands@<2@oclif/plugin-help@<4@oclif/plugin-not-found@<2@oclif/plugin-plugins@<2@oclif/plugin-update@<2plugin-warn-if-update-available@<2plugin-which@<2@oclif/plugin-autocomplete@>=2@oclif/plugin-commands@>=2@oclif/plugin-help@>=4@oclif/plugin-not-found@>=2@oclif/plugin-plugins@>=2@oclif/plugin-update@>=2@oclif/plugin-warn-if-update-available@>=2@oclif/plugin-which@>=2oclif Summer 2020 UpdateAugust 26, 2020 · 2 min readHello oclif developers! We hope you are all doing well.
Earlier this year, we started our planning for oclifconf v2 and, like all conference, had to change course. We opted not to hold a virtual conference, however, we wanted to take some time to highlight a few oclif features shipped this year.
Feature: Help templating​
One of the most requested features, help templating enables oclif developers to customize the help output for their CLI.
Read the announcement.
Feature: Custom error delegation​
This feature both improved how oclif throws and handles errors and allows oclif developers to overwrite or interject in oclif’s error handling.
Read the announcement.
Feature: postrun hooks​
We have added a new lifecycle event postrun. Your CLI can now run a hook after a command has ran.
See our hook documentation.
Feature: Root index command​
Previously, oclif would display CLI help if only the binary name with no command ID was invoked, oclif now supports a "root index" command. If present, a command defined at src/commands/index.ts will be run if no command ID is found.
1 million weekly downloads​
While exact oclif usage metrics are hard to pin down, we use npm download statistics of oclif packages as a rough approximation. Earlier this year, oclif's command package hit 1 million weekly downloads for the first time!
This year has been presented its challenges on everyone. We want to thank you, oclif developers, whom have taken the time to use and improve the oclif project. We look forward to seeing you all - in person - in the future!
All our best,
The oclif teamPretty Printable ErrorsJuly 1, 2020 · One min readOften CLIs are used as handy tools and when things go wrong it’s useful to have additional context. In oclif we have added a couple of additional properties that can show extra context to the users when an error is displayed. The code, ref and suggestions will now be displayed if they are included. This will work with an existing oclif CLI by adding the latest @oclif/errors and @oclif/core to the CLI's package.json dependencies.
For example, using this.error with the additional properties:
class TestError extends Command {  async run() {    this.error("An error has occurred!", {      code: "OCLIF_ERR",      ref: "https://oclif.io/docs/commands#thiserrormessage-string--error-options-code-string-exit-number",      suggestions: ["Use these extra properties to provide additional context"],    })  }}
would result with the following output:
›   Error: An error has occurred!›   Code: OCLIF_ERR›   Try this: Use these extra properties to provide additional context›   Reference: https://oclif.io/docs/commands#thiserrormessage-string--error-options-code-string-exit-number
If these properties are not provided then nothing changes and the CLI will continue to display the single error message output as it did before. Additionally, as part of this exercise we’ve added documentation around Error Handling in oclif which should come in handy if the need arises to extend oclif’s default handling of errors.Customizing Help in oclifMay 5, 2020 · 2 min readOut of the box oclif provides a great help experience for CLIs.
But what if, as an oclif developer, you want to customize some or all of the output?
You can now customize your CLI's help output by implementing the HelpBase abstract class.
Getting started with custom help​
If you have not done so yet, update @oclif/core.
$ yarn add --latest @oclif/core
To get started, first define the filepath to your help class in oclif's config in package.json. This is a relative path to the help class, without a file extension.
For this example, the help class will be created in a file at "[project root]/src/help.ts".
{  // ...  "oclif": {    "helpClass": "./lib/help"    // ...  }  // ...}
From here there are two paths, implement the HelpBase abstract class yourself or overwrite the parts of the default Help class you want to customize (ex: how command usage is displayed). We recommend the latter approach but cover both in the new Help Classes docs.
Separating TOPICS & COMMANDS in the new default Help class​
Previously, topics and child commands were listed in help output under a single list heading called "COMMANDS". But we found this can be slightly confusing. Some topics are commands also (a.k.a. topic-commands) while others are simply organizational namespacing (and when ran just show their help).
The new default Help class splits the list of children into distinct lists of "TOPICS" and "COMMANDS", with the possibility of an item appearing in both if it a topic-command. This makes it clearer what is expected to be ran - "COMMANDS" - and what is providing structure - "TOPICS" - when looking at the help output.
VERSION  plugin-help-example/0.0.0 darwin-x64 node-v12.12.0USAGE  $ plugin-help-example [COMMAND]TOPICS  topic  this is a topic and has child topics or commandsCOMMANDS  hello  describe the command here  help   display help for plugin-help-example
We look forward to seeing what custom help features you implement in your oclif CLIs with this new feature!oclif TSLint to ESLint MigrationDecember 5, 2019 · 3 min readBack in February of this year, plans were announced to deprecate TSLint in favor of ESLint. TSLint's goal has become to work toward a “unified developer experience” by supporting ESLint development going forward.
What has changed in oclif​
To keep inline with the community, oclif has transitioned to ESLint for all our core libraries as well as all our official plugins.
Starting in v1.15.x, oclif will now optionally generate projects with ESLint for both TypeScript and JavaScript CLI’s.
ESLint does require Node to be on stable LTS version, at the time of writing, Node 8.10.x, Node 10.13.x & Node 12.x.x.
How does this affect you​
Existing CLI’s are unchanged, but any newly generated CLI's will only give the option of using ESLint. If you are running tslint in your CLI, we recommend you switch to ESLint as well.
In migrating our projects we took the following steps (for an example of these changes see this pull request).


Install eslint
$ yarn add eslint eslint-config-oclif eslint-config-oclif-typescript --dev


Add eslint related files


$ echo '{  "extends": [    "oclif",    "oclif-typescript"  ],  "rules": {  }}' > .eslintrc


Remove tslint and related packages
$ yarn remove @oclif/tslint tslint


Remove tslint related configuration files
$ rm tslint.json


Change lint script in our package.json from something like:
"lint": "tsc -p test --noEmit && tslint -p test -t stylish"
to
"lint": "eslint . --ext .ts --config .eslintrc"


To preserve the test compile (tsc -p test --noEmit) we also made the following updates to our scripts:
"pretest": "tsc -p test --noEmit"
In some cases we had our posttest duplicating the same steps as our lint script so it’s cleaner to have it reference the lint job directly with:
"posttest": "yarn lint"

Run yarn lint --fix. This attempts to auto-fix any linting violations automatically. In the case an auto-fix isn’t available it should be fixed manually or ignored (see the eslint configuration doc for more information)
Do a search in the codebase for tslint and remove any unnecessary tslint disabling comments, like:

/* tslint:disable:object-literal-sort-keys */
If you are on a version of Node that is not supported by ESLint, you will also need to update your Node engine. ESLint supports Node 8, 10, and 12 so you should upgrade to the most recent Node version compatible with your CLI and also supported by ESLint (see ESLint's Installation and Usage instructions).
When will this take effect​
These changes have taken effect in oclif v1.15.1. When you generate a new CLI or plugin it will now contain configuration for ESLint instead of TSLint.oclif's Current Node SupportOctober 31, 2019 · 3 min readTo maintain a healthy project trajectory, oclif follows and supports Node Active LTS release, currently Node 10 & Node 12. This means ensuring that oclif continues to play nice with coming Active LTS Node versions and other packages in the ecosystem. Moving forward also means leaving older versions behind. Starting in 2020, Node will stop maintaining Node 8 and it is our intent at that time to also follow suit. Let’s take a look at a few ways we will be supporting these changes.
CI Environments​
CLIs created with the oclif cli going forward will be generated with a CircleCI configuration with Node 10 & 12 and an Appveyor configuration using Node 10. We have also added Node latest to CircleCi to be an early warning detection against coming Node changes (Node latest is managed by CircleCI).
We have already updated every oclif repo's CI configs to reflect this.
If your existing CLI uses either Appveyor or CircleCI you can update your config files also, like so:
.circleci/config.yml​
Your CircleCI config should contain a node-latest job, aliased as test. From this, there should be two extensions of this job for the Active LTS Node versions, Node 10 and Node 12.
  node-10:    <<: *node-latest    docker:      - image: node:10  node-12:    <<: *node-latest    docker:      - image: node:12
Notice that these declarations only change the Docker Node images used to run that job.
Additionally, the jobs listed within workflows must also be updated to reflect our changes in configuration:
    jobs:      - node-latest      - node-10      - node-12
appveyor.yml​
For appveyor we are currently only testing the oldest Active LTS Node version, Node 10. Update the nodejs_version proppert in your appveyor.yml file to reflect this.
environment:  nodejs_version: "10"
Deprecating Node 8 & Updating packge.json engines​
In Jan 2020, Node will end its Node 8 maintenance. We will follow suit by setting the package.json engine property in oclif packages to >=10 and bumping the package's major versions.
Depending on how you ship your CLI you may wish to also bump the engines version in your CLI's package.json. You can read more about the implications of the engines property configuration in the npm documentation.
Also consider distributing your CLI with its own Node version.
Packaged Node Version​
When using dev-cli to pack your CLI it will use the Node version as specified in your package.json under the oclif.update.node.version property. This value should reflect an Active LTS Node version (dev-cli does not currently enforce versions).
Supporting the future​
As a community we may discover bumps along the way as we upgrade. If you notice something related to oclif please feel free to open an issue or submit a pull request under the relevant oclif package within the org.
We look forward to using the latest from Node and the community and keeping oclif healthy along the way.oclifconf 2019: A RecapSeptember 16, 2019 · 4 min readIn May, Heroku and Salesforce Open Source organized oclifconf, a conference for developers & product managers building CLI tools on top of the open source oclif framework. The speakers came from various tech companies, such as Adobe, Netlify, and Apollo, who have already built amazing CLI experiences. The topics covered everything from the incredible capabilities oclif has unlocked, to the community-built plugins extending its functionality, and even what the behavior of an adaptive CLI tool might look like.
Below is a listing of all of the talks from the event, along with a short summary. Enjoy!
The future of oclif by Jeff Dickey​

In its relatively short lifetime, oclif has already inspired many developers and companies to adopt its framework as a means for implementing their own command-line tooling. In this talk, Jeff Dickey, an oclif founding team member, recaps the project's history and inspiration. He also looks towards the future and outlines some features and improvements that the tool could adapt. This isn't so much a definitive roadmap of where oclif is headed, but rather, a call to inspiration for developers eager to contribute! And if you are interested in contributing, check out the open issues in the oclif GitHub repo and come say "Hello!" on Spectrum Chat.
Open Source Citizenship by Josh Simmons​

When it comes to open source, it's more than just individuals now. More and more frequently, large corporations are contributing to projects by donating to contributors, sponsoring events, or upstreaming contributions. But keeping open source projects and communities healthy requires more than just money and brainpower. Josh Simmons surveyed multiple open source communities and relays his findings as to what help maintainers and contributors actually need in this talk.
Building an enterprise-grade CLI with oclif by Thomas Dvornik​

Security and performance are all about trust. While oclif is an extremely extensible framework for building CLI tooling, there are additional requirements to fulfill for enterprise businesses to adopt it that might not be necessary for individual developers. Thomas Dvornik outlines what he and his colleagues at Salesforce have implemented as plugins to oclif to satisfy these needs, including encrypted OAuth, plugin signing, lazy loading dependencies, synchronizing weekly releases and deprecations across dozens of repositories, and establishing cross-team coding and documentation standards.
How Adobe I/O built an extensible CLI with oclif by Jesse MacFadyen​

Perhaps oclif's most appealing feature is its support for plugins. In Cordova's case, they've created a sophisticated telemetry system that helps Adobe developers see which commands users are using--and reports on which ones are erroring out. By embedding a feedback system into the tool, users are even able to quickly send their suggestions to a form, without ever leaving the terminal. Jesse MacFadyen demonstrates how oclif's plugin system can work beyond simply executing commands.
Integrating oclif with GraphQL and Apollo by Evans Hauser​

For Evans Hauser and the team at Apollo, oclif is best thought of as "React for the CLI." As a client paired with a strongly-typed API contract to a server, it can deliver structured and consistent commands to retrieve external data. What better mechanism to use for this transfer than GraphQL, a framework which empowers the client to ask precisely for the data it needs, and nothing more?
Adaptive Intent-based CLI State Machines by Shawn Wang​

In designing oclif, Jeff Dickey wrote out 12 CLI factors to keep in mind. In this talk, Shawn Wang outlines a 13th: state. State is hard, because it depends on context, and context depends on understanding what a user intends to do, not what they are asking. Shawn is working towards enabling oclif to better understand the commands a user has entered, so that it can predict and interpret future commands that might be entered next. This would enable CLI tools to not just interpret a users' commands, but to also interpret their intent.\n\nIntroducing `oclif init` commandApril 10, 2024 · 2 min readThanks to the contribution of @joshcanhelp we released a new command for the oclif CLI called oclif init in version 4.8.0
The oclif init command allows you to initialize oclif in an existing project directory by adding the bare minimum requirements: a few pieces of configuration, bin scripts, and a couple of dependencies (@oclif/core and ts-node). This is slightly different from oclif generate, which will create an entirely new oclif project based on our templates.
oclif init will add the following:

bin scripts: bin/run.js, bin/run.cmd, bin/dev.js, and bin/dev.cmd
oclif section to package.json with bin, dirname, commands, and topicSeparator set (See Configuring Your CLI for more)
@oclif/core to dependencies in your package.json (if it's not already there)
ts-node to devDependencies in your package.json (if it's not already there)

Once you've initialized oclif, you can use the bin scripts to execute your CLI. You can also use the other oclif commands like oclif generate command and oclif generate hook to start adding new functionality.

❯ oclif init --helpInitialize a new oclif CLIUSAGE  $ oclif init [--bin <value>] [--module-type ESM|CommonJS] [--package-manager npm|yarn|pnpm] [--topic-separator    colons|spaces] [-d <value>] [-y]FLAGS  -d, --output-dir=<value>        Directory to initialize the CLI in.  -y, --yes                       Use defaults for all prompts. Individual flags will override defaults.      --bin=<value>               Supply answer for prompt: Command bin name the CLI will export      --module-type=<option>      Supply answer for prompt: Select a module type                                  <options: ESM|CommonJS>      --package-manager=<option>  Supply answer for prompt: Select a package manager                                  <options: npm|yarn|pnpm>      --topic-separator=<option>  Supply answer for prompt: Select a topic separator                                  <options: colons|spaces>DESCRIPTION  Initialize a new oclif CLI  This will add the necessary oclif bin files, add oclif config to package.json, and install @oclif/core and ts-node.EXAMPLES  Initialize a new CLI in the current directory    $ oclif init  Initialize a new CLI in a different directory    $ oclif init --output-dir "/path/to/existing/project"  Supply answers for specific prompts    $ oclif init --topic-separator colons --bin mycli
Hope you enjoy the new command! If you come across any issues or have any new ideas for this command, head over to the oclif/oclif repo and open a new issue.
All our best,
The oclif teamoclif Spring 2024 UpdateMarch 29, 2024 · 4 min readHello oclif developers! It's been a while since we last uploaded a blog - and a lot has happened.
We've been focusing on these high-level areas over the past couple of years:

Improving @oclif/core
ESM Support
Improving and revitalizing oclif.io
Re-engaging the oclif community

Improving @oclif/core​
Since we announced @oclif/core over three years ago, we've released two new major versions, each packed with lots of features that we're really excited about.
Here are some of these changes:

Full support for ESM and interoperability with CommonJS (more on this topic below).
Configurable command discovery strategies that give you more control over how commands are loaded at runtime. Check out the docs.
A new preparse hook that allows you to manipulate the provided arguments before they're parsed. Salesforce used this hook to implement a neat --flags-dir feature that translates local files into flags.
A new Performance class that you can use to track performance inside of @oclif/core and your own CLI or plugin. Check out the docs.
A new flag type, Flags.option, that lets you define a flag with a preset list of options. Typescript then uses the options to infer the flag's type.
Flags now have a relationship property that allows you to define more complex relationships between flags. Check out the flags docs for more information.
Flags now have a defaultHelp property that allows you to set the human readable default value in the command help. This property is useful when your flag's parse method returns a complex type, such as an object or a class. Check out the flags docs for more.
Commands now have a hiddenAliases property that allows you to define aliases that you want to hide from the user. The property is super helpful when you're trying to wean users off a deprecated command.
You can now use bun or tsx as dev runtimes (as opposed to node or ts-node).
A command's usage, args, and flags are now shown whenever a user forgets to provide a required arg or flag, or when they provided a non-existent flag.

If you need help migrating to the latest version, head over to core's README which has links to the migration guides. Feel free to open a new discussion if you need more hands-on help from us or the community.
ESM Support​
Version 3 of @oclif/core introduced full support for developing ESM plugins and CLIs. It also offered full support for interoperability between CommonJS and ESM plugins.
Put more simply, you can now migrate your CLI to ESM while keeping individual plugins in CommonJS (or vice versa). The upgrade path is now much simpler for you. You also don't need to worry about any community plugins that have migrated to ESM before you did (such as all the @oclif plugins) or are staunchly sticking with CommonJS for the foreseeable future.
Read more about this topic here.
Improving and Revitalizing oclif.io​
Another area of focus for us has been improving our documentation site, oclif.io.
While improving the quality and accuracy of the documentation was our priority, we also took the time to upgrade to the latest version of docusaurus. This new version gave our site a much-needed facelift, as well as cool new features such as dark mode and announcements.
If you have any feedback or are running into issues, we want to hear about it. Just create an issue in the oclif.io repo.
Re-engaging the oclif Community​
Lastly, our biggest priority at the moment is to re-engage the oclif community. We understand how frustrating it has been over the years to see your issues and pull requests go unacknowledged. We apologize for not prioritizing the community, and are earnestly trying to make sure that every issue and pull request gets the attention it deserves going forward.
We also opened up GitHub discussions for @oclif/core and the oclif CLI, where you can now post your questions or ideas. We hope you take advantage of them, we love hearing from you!
One last thing: we intend to publicly post our roadmap so you have more visibility into what we're working on. Stay tuned!
All our best,
The oclif teamAnnouncing oclif v2!January 12, 2022 · 5 min readHello and happy new year! It's our great pleasure to announce that we have released oclif v2, which uses the new @oclif/core library! 🎉
oclif v2 includes many changes that improve the experience of both creating and using an oclif CLI.
Going forward, we don't plan to make any updates to oclif v1 and its corresponding libraries, except for critical security fixes. See the compatibility matrix for a list of these libraries. In order to give developers time to migrate from v1 to v2, we're not completely dropping support yet. But at some point in the future we'll archive the v1 repositories and deprecate their versions on npm.
What’s changing?​
Repository Changes​
All repositories under the oclif org now use main as their primary branch and oclif-v1 as the legacy branch. The main  branch corresponds to oclif v2 and the oclif-v1 branch to oclif v1. If you find any repos that don’t have a main branch, you can safely assume that they're not used in oclif v2 and will be deprecated in the future.
Consolidating Tools & Libraries​
The oclif-dev CLI has now been incorporated into oclif. You now no longer need to install a separate package to manage your entire CLI’s lifecycle.
The following libraries have been consolidated under @oclif/core and will be deprecated at some point in the future. Read the migration guide to learn how to update your CLI or plugin to use the new core library.

@oclif/command
@oclif/config
@oclif/error
@oclif/help
@oclif/parser

No more single vs multi command CLIs​
There's only one "type" of oclif v2 CLI, but it can have as few or as many commands as a developer wants. As a result, there’s only one command to generate CLIs, oclif generate, as opposed to the old oclif single and oclif multi commands.
Node > 12​
To ensure oclif CLIs are as secure as possible, all v2 libraries and plugins support only Node 12 or higher as of now. Going forward, they'll support only Node Maintenance or higher, as defined by Node's release schedule here: https://nodejs.org/en/about/releases/.
What’s new?​
New example CLI​
oclif-hello-world is our new example repo. This is also the repo that's used as a template when running oclif generate to create a new CLI. This repo will always be able to be referenced as an example of what an oclif v2 CLI should look like.
Spaced commands​
oclif CLIs can now use spaces, instead of colons, to separate topics and subcommands. To enable this feature, simply add “topicSeparator": " " to the oclif config in your package.json. See an example in our example repo.
// Old commands that use :$ mycli do:something
// New spaced commands$ mycli do something

Note: Spaced commands are backwards compatible. So if you enable spaced commands for your CLI, users will still be able to use : as a separator. This ensures that any existing scripts don't break.

New Help Output​
We’ve revamped the way command help is outputted to the terminal, making it both easier to implement and easier to read. See the difference between the old help output on the left and the new help output on the right in the screenshots below.
oclif v1oclif v2
Notice that there are new sections for flags and global flags, examples are displayed with better spacing, and there is a section at the bottom called Configuration Variables. This Configuration Variables section is not part of the new help by default. But we've added support for custom help sections, which is what the sf CLI uses to create the new section.
Async Command Parsing​
We’ve also improved the performance of new CLIs by rewriting how commands are parsed on initialization. The new parser is asynchronous, which makes CLIs with a lot of commands or installed  plugins much faster.
What’s coming next?​
Part of our charter for the release of oclif v2 includes improving our engagement with the oclif community. We know that over the past couple of years we’ve reduced our involvement, and a lot of issues and PRs have languished in limbo. Hopefully you’ve already seen increased activity and responses from oclif maintainers recently, but if you haven’t, please don’t hesitate to ping us by tagging @admins in oclif repos.
We also want to start interviewing members of the oclif community to acquire feedback and prioritize the features and fixes you deem most important!
Best,
The oclif team

Reference material​
Migration Guide​
This guide explains how to upgrade a CLI or plugin from the old oclif v1 libraries to the new @oclif/core library that oclif v2 uses.
https://github.com/oclif/core/blob/main/MIGRATION.md
Compatibility Matrix​
The following matrix shows how the v1 libraries and plugins relate to the new v2 ones. Use this matrix as a guide to know what to drop and which versions to switch when upgrading your plugins and CLIs to v2.
oclif "v1"oclif "v2"Utility CLIsoclif@<2@oclif/dev-cli@<2oclif@>=2Main packages@oclif/command@oclif/config@oclif/errors@oclif/parser@oclif/plugin-help@oclif/core@>=1Node LTSNode v8-14Node v12+ (at time of writing)TypeScripttypescript@<4typescript@>=4Main plugins@oclif/plugin-autocomplete@<1@oclif/plugin-commands@<2@oclif/plugin-help@<4@oclif/plugin-not-found@<2@oclif/plugin-plugins@<2@oclif/plugin-update@<2plugin-warn-if-update-available@<2plugin-which@<2@oclif/plugin-autocomplete@>=1@oclif/plugin-commands@>=2@oclif/plugin-help@>=4@oclif/plugin-not-found@>=2@oclif/plugin-plugins@>=2@oclif/plugin-update@>=2@oclif/plugin-warn-if-update-available@>=2@oclif/plugin-which@>=2Introducing @oclif/coreMarch 1, 2021 · 3 min readGreetings!
We hope this blog post finds you well.
Introducing...​
We are excited to announce the next iteration of the oclif project today: @oclif/core.
We have learned a lot in the last three years of developing oclif, developing on oclif and supporting millions of command runs a day via Heroku and Salesforce CLIs.
@oclif/core ("Core") simplifies the oclif development experience and introduces highly requested new features.
Core combines the essential oclif packages into one "core" package, aptly named @oclif/core.
Core also introduces:

A default command option
Colon or space command syntax
Async command parsing
Command piping to arguments

With the introduction of default command functionality, Core simplifies the oclif project and removes the notion of single or multi command CLIs. Core CLIs can have 1 or many commands.
Along with Core, we moved the oclif-dev CLI into the oclif CLI creating a single "utility" CLI. This CLI also introduces a new AWS S3 compatible publishing scheme.
What to expect in the near future​
Core is in pre-release beta and being actively developed for new internal Salesforce CLIs.
Much documentation needs to be written in the coming months including migration paths. Migration onto Core should be as painless as possible with many exports remaining entirely unchanged. Look for forthcoming blog posts and documentation on oclif.io.
Early this summer, tentively June 1, we will release Core v1. Core's release will coincide with major bumps to many other oclif plugin packages. See the compatibility matrix below.
At Core's v1 release, the current "main" oclif packages (namely: command, config, errors & parser) will go into maintenance mode until Jan 2022. They will receive only bug and security fixes and they remain compatible with current versions of the oclif and oclif-dev CLIs. Afterwhich, they will be archived.
Companioning Core, the next major release of the oclif CLI (literally oclif@2) will generate Core CLIs.
Going forward​
We are excited to release Core! We invite you to poke around the Core repo. It may appear to be a big change but Core keeps what you already enjoy about oclif while reducing development complexity, project dependencies, package coupling and bundle size and introduces many requested features previously too prickly to weave into the current oclif architecture.
Best,
The oclif team
Reference: Compatibility matrix​
oclif "v1"oclif "Core"Utility CLIsoclif@<2@oclif/dev-cli@<2oclif@>=2Main packages@oclif/core@<2@oclif/config@<2@oclif/errors@<2@oclif/parser@<4@oclif/plugin-help@<4@oclif/core@>=1Node LTSNode v8-14Node v12+TypeScripttypescript@<4typescript@>=4Main plugins@oclif/plugin-autocomplete@<1@oclif/plugin-commands@<2@oclif/plugin-help@<4@oclif/plugin-not-found@<2@oclif/plugin-plugins@<2@oclif/plugin-update@<2plugin-warn-if-update-available@<2plugin-which@<2@oclif/plugin-autocomplete@>=2@oclif/plugin-commands@>=2@oclif/plugin-help@>=4@oclif/plugin-not-found@>=2@oclif/plugin-plugins@>=2@oclif/plugin-update@>=2@oclif/plugin-warn-if-update-available@>=2@oclif/plugin-which@>=2oclif Summer 2020 UpdateAugust 26, 2020 · 2 min readHello oclif developers! We hope you are all doing well.
Earlier this year, we started our planning for oclifconf v2 and, like all conference, had to change course. We opted not to hold a virtual conference, however, we wanted to take some time to highlight a few oclif features shipped this year.
Feature: Help templating​
One of the most requested features, help templating enables oclif developers to customize the help output for their CLI.
Read the announcement.
Feature: Custom error delegation​
This feature both improved how oclif throws and handles errors and allows oclif developers to overwrite or interject in oclif’s error handling.
Read the announcement.
Feature: postrun hooks​
We have added a new lifecycle event postrun. Your CLI can now run a hook after a command has ran.
See our hook documentation.
Feature: Root index command​
Previously, oclif would display CLI help if only the binary name with no command ID was invoked, oclif now supports a "root index" command. If present, a command defined at src/commands/index.ts will be run if no command ID is found.
1 million weekly downloads​
While exact oclif usage metrics are hard to pin down, we use npm download statistics of oclif packages as a rough approximation. Earlier this year, oclif's command package hit 1 million weekly downloads for the first time!
This year has been presented its challenges on everyone. We want to thank you, oclif developers, whom have taken the time to use and improve the oclif project. We look forward to seeing you all - in person - in the future!
All our best,
The oclif teamPretty Printable ErrorsJuly 1, 2020 · One min readOften CLIs are used as handy tools and when things go wrong it’s useful to have additional context. In oclif we have added a couple of additional properties that can show extra context to the users when an error is displayed. The code, ref and suggestions will now be displayed if they are included. This will work with an existing oclif CLI by adding the latest @oclif/errors and @oclif/core to the CLI's package.json dependencies.
For example, using this.error with the additional properties:
class TestError extends Command {  async run() {    this.error("An error has occurred!", {      code: "OCLIF_ERR",      ref: "https://oclif.io/docs/commands#thiserrormessage-string--error-options-code-string-exit-number",      suggestions: ["Use these extra properties to provide additional context"],    })  }}
would result with the following output:
›   Error: An error has occurred!›   Code: OCLIF_ERR›   Try this: Use these extra properties to provide additional context›   Reference: https://oclif.io/docs/commands#thiserrormessage-string--error-options-code-string-exit-number
If these properties are not provided then nothing changes and the CLI will continue to display the single error message output as it did before. Additionally, as part of this exercise we’ve added documentation around Error Handling in oclif which should come in handy if the need arises to extend oclif’s default handling of errors.Customizing Help in oclifMay 5, 2020 · 2 min readOut of the box oclif provides a great help experience for CLIs.
But what if, as an oclif developer, you want to customize some or all of the output?
You can now customize your CLI's help output by implementing the HelpBase abstract class.
Getting started with custom help​
If you have not done so yet, update @oclif/core.
$ yarn add --latest @oclif/core
To get started, first define the filepath to your help class in oclif's config in package.json. This is a relative path to the help class, without a file extension.
For this example, the help class will be created in a file at "[project root]/src/help.ts".
{  // ...  "oclif": {    "helpClass": "./lib/help"    // ...  }  // ...}
From here there are two paths, implement the HelpBase abstract class yourself or overwrite the parts of the default Help class you want to customize (ex: how command usage is displayed). We recommend the latter approach but cover both in the new Help Classes docs.
Separating TOPICS & COMMANDS in the new default Help class​
Previously, topics and child commands were listed in help output under a single list heading called "COMMANDS". But we found this can be slightly confusing. Some topics are commands also (a.k.a. topic-commands) while others are simply organizational namespacing (and when ran just show their help).
The new default Help class splits the list of children into distinct lists of "TOPICS" and "COMMANDS", with the possibility of an item appearing in both if it a topic-command. This makes it clearer what is expected to be ran - "COMMANDS" - and what is providing structure - "TOPICS" - when looking at the help output.
VERSION  plugin-help-example/0.0.0 darwin-x64 node-v12.12.0USAGE  $ plugin-help-example [COMMAND]TOPICS  topic  this is a topic and has child topics or commandsCOMMANDS  hello  describe the command here  help   display help for plugin-help-example
We look forward to seeing what custom help features you implement in your oclif CLIs with this new feature!oclif TSLint to ESLint MigrationDecember 5, 2019 · 3 min readBack in February of this year, plans were announced to deprecate TSLint in favor of ESLint. TSLint's goal has become to work toward a “unified developer experience” by supporting ESLint development going forward.
What has changed in oclif​
To keep inline with the community, oclif has transitioned to ESLint for all our core libraries as well as all our official plugins.
Starting in v1.15.x, oclif will now optionally generate projects with ESLint for both TypeScript and JavaScript CLI’s.
ESLint does require Node to be on stable LTS version, at the time of writing, Node 8.10.x, Node 10.13.x & Node 12.x.x.
How does this affect you​
Existing CLI’s are unchanged, but any newly generated CLI's will only give the option of using ESLint. If you are running tslint in your CLI, we recommend you switch to ESLint as well.
In migrating our projects we took the following steps (for an example of these changes see this pull request).


Install eslint
$ yarn add eslint eslint-config-oclif eslint-config-oclif-typescript --dev


Add eslint related files


$ echo '{  "extends": [    "oclif",    "oclif-typescript"  ],  "rules": {  }}' > .eslintrc


Remove tslint and related packages
$ yarn remove @oclif/tslint tslint


Remove tslint related configuration files
$ rm tslint.json


Change lint script in our package.json from something like:
"lint": "tsc -p test --noEmit && tslint -p test -t stylish"
to
"lint": "eslint . --ext .ts --config .eslintrc"


To preserve the test compile (tsc -p test --noEmit) we also made the following updates to our scripts:
"pretest": "tsc -p test --noEmit"
In some cases we had our posttest duplicating the same steps as our lint script so it’s cleaner to have it reference the lint job directly with:
"posttest": "yarn lint"

Run yarn lint --fix. This attempts to auto-fix any linting violations automatically. In the case an auto-fix isn’t available it should be fixed manually or ignored (see the eslint configuration doc for more information)
Do a search in the codebase for tslint and remove any unnecessary tslint disabling comments, like:

/* tslint:disable:object-literal-sort-keys */
If you are on a version of Node that is not supported by ESLint, you will also need to update your Node engine. ESLint supports Node 8, 10, and 12 so you should upgrade to the most recent Node version compatible with your CLI and also supported by ESLint (see ESLint's Installation and Usage instructions).
When will this take effect​
These changes have taken effect in oclif v1.15.1. When you generate a new CLI or plugin it will now contain configuration for ESLint instead of TSLint.oclif's Current Node SupportOctober 31, 2019 · 3 min readTo maintain a healthy project trajectory, oclif follows and supports Node Active LTS release, currently Node 10 & Node 12. This means ensuring that oclif continues to play nice with coming Active LTS Node versions and other packages in the ecosystem. Moving forward also means leaving older versions behind. Starting in 2020, Node will stop maintaining Node 8 and it is our intent at that time to also follow suit. Let’s take a look at a few ways we will be supporting these changes.
CI Environments​
CLIs created with the oclif cli going forward will be generated with a CircleCI configuration with Node 10 & 12 and an Appveyor configuration using Node 10. We have also added Node latest to CircleCi to be an early warning detection against coming Node changes (Node latest is managed by CircleCI).
We have already updated every oclif repo's CI configs to reflect this.
If your existing CLI uses either Appveyor or CircleCI you can update your config files also, like so:
.circleci/config.yml​
Your CircleCI config should contain a node-latest job, aliased as test. From this, there should be two extensions of this job for the Active LTS Node versions, Node 10 and Node 12.
  node-10:    <<: *node-latest    docker:      - image: node:10  node-12:    <<: *node-latest    docker:      - image: node:12
Notice that these declarations only change the Docker Node images used to run that job.
Additionally, the jobs listed within workflows must also be updated to reflect our changes in configuration:
    jobs:      - node-latest      - node-10      - node-12
appveyor.yml​
For appveyor we are currently only testing the oldest Active LTS Node version, Node 10. Update the nodejs_version proppert in your appveyor.yml file to reflect this.
environment:  nodejs_version: "10"
Deprecating Node 8 & Updating packge.json engines​
In Jan 2020, Node will end its Node 8 maintenance. We will follow suit by setting the package.json engine property in oclif packages to >=10 and bumping the package's major versions.
Depending on how you ship your CLI you may wish to also bump the engines version in your CLI's package.json. You can read more about the implications of the engines property configuration in the npm documentation.
Also consider distributing your CLI with its own Node version.
Packaged Node Version​
When using dev-cli to pack your CLI it will use the Node version as specified in your package.json under the oclif.update.node.version property. This value should reflect an Active LTS Node version (dev-cli does not currently enforce versions).
Supporting the future​
As a community we may discover bumps along the way as we upgrade. If you notice something related to oclif please feel free to open an issue or submit a pull request under the relevant oclif package within the org.
We look forward to using the latest from Node and the community and keeping oclif healthy along the way.oclifconf 2019: A RecapSeptember 16, 2019 · 4 min readIn May, Heroku and Salesforce Open Source organized oclifconf, a conference for developers & product managers building CLI tools on top of the open source oclif framework. The speakers came from various tech companies, such as Adobe, Netlify, and Apollo, who have already built amazing CLI experiences. The topics covered everything from the incredible capabilities oclif has unlocked, to the community-built plugins extending its functionality, and even what the behavior of an adaptive CLI tool might look like.
Below is a listing of all of the talks from the event, along with a short summary. Enjoy!
The future of oclif by Jeff Dickey​

In its relatively short lifetime, oclif has already inspired many developers and companies to adopt its framework as a means for implementing their own command-line tooling. In this talk, Jeff Dickey, an oclif founding team member, recaps the project's history and inspiration. He also looks towards the future and outlines some features and improvements that the tool could adapt. This isn't so much a definitive roadmap of where oclif is headed, but rather, a call to inspiration for developers eager to contribute! And if you are interested in contributing, check out the open issues in the oclif GitHub repo and come say "Hello!" on Spectrum Chat.
Open Source Citizenship by Josh Simmons​

When it comes to open source, it's more than just individuals now. More and more frequently, large corporations are contributing to projects by donating to contributors, sponsoring events, or upstreaming contributions. But keeping open source projects and communities healthy requires more than just money and brainpower. Josh Simmons surveyed multiple open source communities and relays his findings as to what help maintainers and contributors actually need in this talk.
Building an enterprise-grade CLI with oclif by Thomas Dvornik​

Security and performance are all about trust. While oclif is an extremely extensible framework for building CLI tooling, there are additional requirements to fulfill for enterprise businesses to adopt it that might not be necessary for individual developers. Thomas Dvornik outlines what he and his colleagues at Salesforce have implemented as plugins to oclif to satisfy these needs, including encrypted OAuth, plugin signing, lazy loading dependencies, synchronizing weekly releases and deprecations across dozens of repositories, and establishing cross-team coding and documentation standards.
How Adobe I/O built an extensible CLI with oclif by Jesse MacFadyen​

Perhaps oclif's most appealing feature is its support for plugins. In Cordova's case, they've created a sophisticated telemetry system that helps Adobe developers see which commands users are using--and reports on which ones are erroring out. By embedding a feedback system into the tool, users are even able to quickly send their suggestions to a form, without ever leaving the terminal. Jesse MacFadyen demonstrates how oclif's plugin system can work beyond simply executing commands.
Integrating oclif with GraphQL and Apollo by Evans Hauser​

For Evans Hauser and the team at Apollo, oclif is best thought of as "React for the CLI." As a client paired with a strongly-typed API contract to a server, it can deliver structured and consistent commands to retrieve external data. What better mechanism to use for this transfer than GraphQL, a framework which empowers the client to ask precisely for the data it needs, and nothing more?
Adaptive Intent-based CLI State Machines by Shawn Wang​

In designing oclif, Jeff Dickey wrote out 12 CLI factors to keep in mind. In this talk, Shawn Wang outlines a 13th: state. State is hard, because it depends on context, and context depends on understanding what a user intends to do, not what they are asking. Shawn is working towards enabling oclif to better understand the commands a user has entered, so that it can predict and interpret future commands that might be entered next. This would enable CLI tools to not just interpret a users' commands, but to also interpret their intent.Older Entries\n\n\n\nIntroducing `oclif init` commandApril 10, 2024 · 2 min readThanks to the contribution of @joshcanhelp we released a new command for the oclif CLI called oclif init in version 4.8.0
The oclif init command allows you to initialize oclif in an existing project directory by adding the bare minimum requirements: a few pieces of configuration, bin scripts, and a couple of dependencies (@oclif/core and ts-node). This is slightly different from oclif generate, which will create an entirely new oclif project based on our templates.
oclif init will add the following:

bin scripts: bin/run.js, bin/run.cmd, bin/dev.js, and bin/dev.cmd
oclif section to package.json with bin, dirname, commands, and topicSeparator set (See Configuring Your CLI for more)
@oclif/core to dependencies in your package.json (if it's not already there)
ts-node to devDependencies in your package.json (if it's not already there)

Once you've initialized oclif, you can use the bin scripts to execute your CLI. You can also use the other oclif commands like oclif generate command and oclif generate hook to start adding new functionality.

❯ oclif init --helpInitialize a new oclif CLIUSAGE  $ oclif init [--bin <value>] [--module-type ESM|CommonJS] [--package-manager npm|yarn|pnpm] [--topic-separator    colons|spaces] [-d <value>] [-y]FLAGS  -d, --output-dir=<value>        Directory to initialize the CLI in.  -y, --yes                       Use defaults for all prompts. Individual flags will override defaults.      --bin=<value>               Supply answer for prompt: Command bin name the CLI will export      --module-type=<option>      Supply answer for prompt: Select a module type                                  <options: ESM|CommonJS>      --package-manager=<option>  Supply answer for prompt: Select a package manager                                  <options: npm|yarn|pnpm>      --topic-separator=<option>  Supply answer for prompt: Select a topic separator                                  <options: colons|spaces>DESCRIPTION  Initialize a new oclif CLI  This will add the necessary oclif bin files, add oclif config to package.json, and install @oclif/core and ts-node.EXAMPLES  Initialize a new CLI in the current directory    $ oclif init  Initialize a new CLI in a different directory    $ oclif init --output-dir "/path/to/existing/project"  Supply answers for specific prompts    $ oclif init --topic-separator colons --bin mycli
Hope you enjoy the new command! If you come across any issues or have any new ideas for this command, head over to the oclif/oclif repo and open a new issue.
All our best,
The oclif teamoclif Spring 2024 UpdateMarch 29, 2024 · 4 min readHello oclif developers! It's been a while since we last uploaded a blog - and a lot has happened.
We've been focusing on these high-level areas over the past couple of years:

Improving @oclif/core
ESM Support
Improving and revitalizing oclif.io
Re-engaging the oclif community

Improving @oclif/core​
Since we announced @oclif/core over three years ago, we've released two new major versions, each packed with lots of features that we're really excited about.
Here are some of these changes:

Full support for ESM and interoperability with CommonJS (more on this topic below).
Configurable command discovery strategies that give you more control over how commands are loaded at runtime. Check out the docs.
A new preparse hook that allows you to manipulate the provided arguments before they're parsed. Salesforce used this hook to implement a neat --flags-dir feature that translates local files into flags.
A new Performance class that you can use to track performance inside of @oclif/core and your own CLI or plugin. Check out the docs.
A new flag type, Flags.option, that lets you define a flag with a preset list of options. Typescript then uses the options to infer the flag's type.
Flags now have a relationship property that allows you to define more complex relationships between flags. Check out the flags docs for more information.
Flags now have a defaultHelp property that allows you to set the human readable default value in the command help. This property is useful when your flag's parse method returns a complex type, such as an object or a class. Check out the flags docs for more.
Commands now have a hiddenAliases property that allows you to define aliases that you want to hide from the user. The property is super helpful when you're trying to wean users off a deprecated command.
You can now use bun or tsx as dev runtimes (as opposed to node or ts-node).
A command's usage, args, and flags are now shown whenever a user forgets to provide a required arg or flag, or when they provided a non-existent flag.

If you need help migrating to the latest version, head over to core's README which has links to the migration guides. Feel free to open a new discussion if you need more hands-on help from us or the community.
ESM Support​
Version 3 of @oclif/core introduced full support for developing ESM plugins and CLIs. It also offered full support for interoperability between CommonJS and ESM plugins.
Put more simply, you can now migrate your CLI to ESM while keeping individual plugins in CommonJS (or vice versa). The upgrade path is now much simpler for you. You also don't need to worry about any community plugins that have migrated to ESM before you did (such as all the @oclif plugins) or are staunchly sticking with CommonJS for the foreseeable future.
Read more about this topic here.
Improving and Revitalizing oclif.io​
Another area of focus for us has been improving our documentation site, oclif.io.
While improving the quality and accuracy of the documentation was our priority, we also took the time to upgrade to the latest version of docusaurus. This new version gave our site a much-needed facelift, as well as cool new features such as dark mode and announcements.
If you have any feedback or are running into issues, we want to hear about it. Just create an issue in the oclif.io repo.
Re-engaging the oclif Community​
Lastly, our biggest priority at the moment is to re-engage the oclif community. We understand how frustrating it has been over the years to see your issues and pull requests go unacknowledged. We apologize for not prioritizing the community, and are earnestly trying to make sure that every issue and pull request gets the attention it deserves going forward.
We also opened up GitHub discussions for @oclif/core and the oclif CLI, where you can now post your questions or ideas. We hope you take advantage of them, we love hearing from you!
One last thing: we intend to publicly post our roadmap so you have more visibility into what we're working on. Stay tuned!
All our best,
The oclif teamAnnouncing oclif v2!January 12, 2022 · 5 min readHello and happy new year! It's our great pleasure to announce that we have released oclif v2, which uses the new @oclif/core library! 🎉
oclif v2 includes many changes that improve the experience of both creating and using an oclif CLI.
Going forward, we don't plan to make any updates to oclif v1 and its corresponding libraries, except for critical security fixes. See the compatibility matrix for a list of these libraries. In order to give developers time to migrate from v1 to v2, we're not completely dropping support yet. But at some point in the future we'll archive the v1 repositories and deprecate their versions on npm.
What’s changing?​
Repository Changes​
All repositories under the oclif org now use main as their primary branch and oclif-v1 as the legacy branch. The main  branch corresponds to oclif v2 and the oclif-v1 branch to oclif v1. If you find any repos that don’t have a main branch, you can safely assume that they're not used in oclif v2 and will be deprecated in the future.
Consolidating Tools & Libraries​
The oclif-dev CLI has now been incorporated into oclif. You now no longer need to install a separate package to manage your entire CLI’s lifecycle.
The following libraries have been consolidated under @oclif/core and will be deprecated at some point in the future. Read the migration guide to learn how to update your CLI or plugin to use the new core library.

@oclif/command
@oclif/config
@oclif/error
@oclif/help
@oclif/parser

No more single vs multi command CLIs​
There's only one "type" of oclif v2 CLI, but it can have as few or as many commands as a developer wants. As a result, there’s only one command to generate CLIs, oclif generate, as opposed to the old oclif single and oclif multi commands.
Node > 12​
To ensure oclif CLIs are as secure as possible, all v2 libraries and plugins support only Node 12 or higher as of now. Going forward, they'll support only Node Maintenance or higher, as defined by Node's release schedule here: https://nodejs.org/en/about/releases/.
What’s new?​
New example CLI​
oclif-hello-world is our new example repo. This is also the repo that's used as a template when running oclif generate to create a new CLI. This repo will always be able to be referenced as an example of what an oclif v2 CLI should look like.
Spaced commands​
oclif CLIs can now use spaces, instead of colons, to separate topics and subcommands. To enable this feature, simply add “topicSeparator": " " to the oclif config in your package.json. See an example in our example repo.
// Old commands that use :$ mycli do:something
// New spaced commands$ mycli do something

Note: Spaced commands are backwards compatible. So if you enable spaced commands for your CLI, users will still be able to use : as a separator. This ensures that any existing scripts don't break.

New Help Output​
We’ve revamped the way command help is outputted to the terminal, making it both easier to implement and easier to read. See the difference between the old help output on the left and the new help output on the right in the screenshots below.
oclif v1oclif v2
Notice that there are new sections for flags and global flags, examples are displayed with better spacing, and there is a section at the bottom called Configuration Variables. This Configuration Variables section is not part of the new help by default. But we've added support for custom help sections, which is what the sf CLI uses to create the new section.
Async Command Parsing​
We’ve also improved the performance of new CLIs by rewriting how commands are parsed on initialization. The new parser is asynchronous, which makes CLIs with a lot of commands or installed  plugins much faster.
What’s coming next?​
Part of our charter for the release of oclif v2 includes improving our engagement with the oclif community. We know that over the past couple of years we’ve reduced our involvement, and a lot of issues and PRs have languished in limbo. Hopefully you’ve already seen increased activity and responses from oclif maintainers recently, but if you haven’t, please don’t hesitate to ping us by tagging @admins in oclif repos.
We also want to start interviewing members of the oclif community to acquire feedback and prioritize the features and fixes you deem most important!
Best,
The oclif team

Reference material​
Migration Guide​
This guide explains how to upgrade a CLI or plugin from the old oclif v1 libraries to the new @oclif/core library that oclif v2 uses.
https://github.com/oclif/core/blob/main/MIGRATION.md
Compatibility Matrix​
The following matrix shows how the v1 libraries and plugins relate to the new v2 ones. Use this matrix as a guide to know what to drop and which versions to switch when upgrading your plugins and CLIs to v2.
oclif "v1"oclif "v2"Utility CLIsoclif@<2@oclif/dev-cli@<2oclif@>=2Main packages@oclif/command@oclif/config@oclif/errors@oclif/parser@oclif/plugin-help@oclif/core@>=1Node LTSNode v8-14Node v12+ (at time of writing)TypeScripttypescript@<4typescript@>=4Main plugins@oclif/plugin-autocomplete@<1@oclif/plugin-commands@<2@oclif/plugin-help@<4@oclif/plugin-not-found@<2@oclif/plugin-plugins@<2@oclif/plugin-update@<2plugin-warn-if-update-available@<2plugin-which@<2@oclif/plugin-autocomplete@>=1@oclif/plugin-commands@>=2@oclif/plugin-help@>=4@oclif/plugin-not-found@>=2@oclif/plugin-plugins@>=2@oclif/plugin-update@>=2@oclif/plugin-warn-if-update-available@>=2@oclif/plugin-which@>=2Introducing @oclif/coreMarch 1, 2021 · 3 min readGreetings!
We hope this blog post finds you well.
Introducing...​
We are excited to announce the next iteration of the oclif project today: @oclif/core.
We have learned a lot in the last three years of developing oclif, developing on oclif and supporting millions of command runs a day via Heroku and Salesforce CLIs.
@oclif/core ("Core") simplifies the oclif development experience and introduces highly requested new features.
Core combines the essential oclif packages into one "core" package, aptly named @oclif/core.
Core also introduces:

A default command option
Colon or space command syntax
Async command parsing
Command piping to arguments

With the introduction of default command functionality, Core simplifies the oclif project and removes the notion of single or multi command CLIs. Core CLIs can have 1 or many commands.
Along with Core, we moved the oclif-dev CLI into the oclif CLI creating a single "utility" CLI. This CLI also introduces a new AWS S3 compatible publishing scheme.
What to expect in the near future​
Core is in pre-release beta and being actively developed for new internal Salesforce CLIs.
Much documentation needs to be written in the coming months including migration paths. Migration onto Core should be as painless as possible with many exports remaining entirely unchanged. Look for forthcoming blog posts and documentation on oclif.io.
Early this summer, tentively June 1, we will release Core v1. Core's release will coincide with major bumps to many other oclif plugin packages. See the compatibility matrix below.
At Core's v1 release, the current "main" oclif packages (namely: command, config, errors & parser) will go into maintenance mode until Jan 2022. They will receive only bug and security fixes and they remain compatible with current versions of the oclif and oclif-dev CLIs. Afterwhich, they will be archived.
Companioning Core, the next major release of the oclif CLI (literally oclif@2) will generate Core CLIs.
Going forward​
We are excited to release Core! We invite you to poke around the Core repo. It may appear to be a big change but Core keeps what you already enjoy about oclif while reducing development complexity, project dependencies, package coupling and bundle size and introduces many requested features previously too prickly to weave into the current oclif architecture.
Best,
The oclif team
Reference: Compatibility matrix​
oclif "v1"oclif "Core"Utility CLIsoclif@<2@oclif/dev-cli@<2oclif@>=2Main packages@oclif/core@<2@oclif/config@<2@oclif/errors@<2@oclif/parser@<4@oclif/plugin-help@<4@oclif/core@>=1Node LTSNode v8-14Node v12+TypeScripttypescript@<4typescript@>=4Main plugins@oclif/plugin-autocomplete@<1@oclif/plugin-commands@<2@oclif/plugin-help@<4@oclif/plugin-not-found@<2@oclif/plugin-plugins@<2@oclif/plugin-update@<2plugin-warn-if-update-available@<2plugin-which@<2@oclif/plugin-autocomplete@>=2@oclif/plugin-commands@>=2@oclif/plugin-help@>=4@oclif/plugin-not-found@>=2@oclif/plugin-plugins@>=2@oclif/plugin-update@>=2@oclif/plugin-warn-if-update-available@>=2@oclif/plugin-which@>=2oclif Summer 2020 UpdateAugust 26, 2020 · 2 min readHello oclif developers! We hope you are all doing well.
Earlier this year, we started our planning for oclifconf v2 and, like all conference, had to change course. We opted not to hold a virtual conference, however, we wanted to take some time to highlight a few oclif features shipped this year.
Feature: Help templating​
One of the most requested features, help templating enables oclif developers to customize the help output for their CLI.
Read the announcement.
Feature: Custom error delegation​
This feature both improved how oclif throws and handles errors and allows oclif developers to overwrite or interject in oclif’s error handling.
Read the announcement.
Feature: postrun hooks​
We have added a new lifecycle event postrun. Your CLI can now run a hook after a command has ran.
See our hook documentation.
Feature: Root index command​
Previously, oclif would display CLI help if only the binary name with no command ID was invoked, oclif now supports a "root index" command. If present, a command defined at src/commands/index.ts will be run if no command ID is found.
1 million weekly downloads​
While exact oclif usage metrics are hard to pin down, we use npm download statistics of oclif packages as a rough approximation. Earlier this year, oclif's command package hit 1 million weekly downloads for the first time!
This year has been presented its challenges on everyone. We want to thank you, oclif developers, whom have taken the time to use and improve the oclif project. We look forward to seeing you all - in person - in the future!
All our best,
The oclif teamPretty Printable ErrorsJuly 1, 2020 · One min readOften CLIs are used as handy tools and when things go wrong it’s useful to have additional context. In oclif we have added a couple of additional properties that can show extra context to the users when an error is displayed. The code, ref and suggestions will now be displayed if they are included. This will work with an existing oclif CLI by adding the latest @oclif/errors and @oclif/core to the CLI's package.json dependencies.
For example, using this.error with the additional properties:
class TestError extends Command {  async run() {    this.error("An error has occurred!", {      code: "OCLIF_ERR",      ref: "https://oclif.io/docs/commands#thiserrormessage-string--error-options-code-string-exit-number",      suggestions: ["Use these extra properties to provide additional context"],    })  }}
would result with the following output:
›   Error: An error has occurred!›   Code: OCLIF_ERR›   Try this: Use these extra properties to provide additional context›   Reference: https://oclif.io/docs/commands#thiserrormessage-string--error-options-code-string-exit-number
If these properties are not provided then nothing changes and the CLI will continue to display the single error message output as it did before. Additionally, as part of this exercise we’ve added documentation around Error Handling in oclif which should come in handy if the need arises to extend oclif’s default handling of errors.Customizing Help in oclifMay 5, 2020 · 2 min readOut of the box oclif provides a great help experience for CLIs.
But what if, as an oclif developer, you want to customize some or all of the output?
You can now customize your CLI's help output by implementing the HelpBase abstract class.
Getting started with custom help​
If you have not done so yet, update @oclif/core.
$ yarn add --latest @oclif/core
To get started, first define the filepath to your help class in oclif's config in package.json. This is a relative path to the help class, without a file extension.
For this example, the help class will be created in a file at "[project root]/src/help.ts".
{  // ...  "oclif": {    "helpClass": "./lib/help"    // ...  }  // ...}
From here there are two paths, implement the HelpBase abstract class yourself or overwrite the parts of the default Help class you want to customize (ex: how command usage is displayed). We recommend the latter approach but cover both in the new Help Classes docs.
Separating TOPICS & COMMANDS in the new default Help class​
Previously, topics and child commands were listed in help output under a single list heading called "COMMANDS". But we found this can be slightly confusing. Some topics are commands also (a.k.a. topic-commands) while others are simply organizational namespacing (and when ran just show their help).
The new default Help class splits the list of children into distinct lists of "TOPICS" and "COMMANDS", with the possibility of an item appearing in both if it a topic-command. This makes it clearer what is expected to be ran - "COMMANDS" - and what is providing structure - "TOPICS" - when looking at the help output.
VERSION  plugin-help-example/0.0.0 darwin-x64 node-v12.12.0USAGE  $ plugin-help-example [COMMAND]TOPICS  topic  this is a topic and has child topics or commandsCOMMANDS  hello  describe the command here  help   display help for plugin-help-example
We look forward to seeing what custom help features you implement in your oclif CLIs with this new feature!oclif TSLint to ESLint MigrationDecember 5, 2019 · 3 min readBack in February of this year, plans were announced to deprecate TSLint in favor of ESLint. TSLint's goal has become to work toward a “unified developer experience” by supporting ESLint development going forward.
What has changed in oclif​
To keep inline with the community, oclif has transitioned to ESLint for all our core libraries as well as all our official plugins.
Starting in v1.15.x, oclif will now optionally generate projects with ESLint for both TypeScript and JavaScript CLI’s.
ESLint does require Node to be on stable LTS version, at the time of writing, Node 8.10.x, Node 10.13.x & Node 12.x.x.
How does this affect you​
Existing CLI’s are unchanged, but any newly generated CLI's will only give the option of using ESLint. If you are running tslint in your CLI, we recommend you switch to ESLint as well.
In migrating our projects we took the following steps (for an example of these changes see this pull request).


Install eslint
$ yarn add eslint eslint-config-oclif eslint-config-oclif-typescript --dev


Add eslint related files


$ echo '{  "extends": [    "oclif",    "oclif-typescript"  ],  "rules": {  }}' > .eslintrc


Remove tslint and related packages
$ yarn remove @oclif/tslint tslint


Remove tslint related configuration files
$ rm tslint.json


Change lint script in our package.json from something like:
"lint": "tsc -p test --noEmit && tslint -p test -t stylish"
to
"lint": "eslint . --ext .ts --config .eslintrc"


To preserve the test compile (tsc -p test --noEmit) we also made the following updates to our scripts:
"pretest": "tsc -p test --noEmit"
In some cases we had our posttest duplicating the same steps as our lint script so it’s cleaner to have it reference the lint job directly with:
"posttest": "yarn lint"

Run yarn lint --fix. This attempts to auto-fix any linting violations automatically. In the case an auto-fix isn’t available it should be fixed manually or ignored (see the eslint configuration doc for more information)
Do a search in the codebase for tslint and remove any unnecessary tslint disabling comments, like:

/* tslint:disable:object-literal-sort-keys */
If you are on a version of Node that is not supported by ESLint, you will also need to update your Node engine. ESLint supports Node 8, 10, and 12 so you should upgrade to the most recent Node version compatible with your CLI and also supported by ESLint (see ESLint's Installation and Usage instructions).
When will this take effect​
These changes have taken effect in oclif v1.15.1. When you generate a new CLI or plugin it will now contain configuration for ESLint instead of TSLint.oclif's Current Node SupportOctober 31, 2019 · 3 min readTo maintain a healthy project trajectory, oclif follows and supports Node Active LTS release, currently Node 10 & Node 12. This means ensuring that oclif continues to play nice with coming Active LTS Node versions and other packages in the ecosystem. Moving forward also means leaving older versions behind. Starting in 2020, Node will stop maintaining Node 8 and it is our intent at that time to also follow suit. Let’s take a look at a few ways we will be supporting these changes.
CI Environments​
CLIs created with the oclif cli going forward will be generated with a CircleCI configuration with Node 10 & 12 and an Appveyor configuration using Node 10. We have also added Node latest to CircleCi to be an early warning detection against coming Node changes (Node latest is managed by CircleCI).
We have already updated every oclif repo's CI configs to reflect this.
If your existing CLI uses either Appveyor or CircleCI you can update your config files also, like so:
.circleci/config.yml​
Your CircleCI config should contain a node-latest job, aliased as test. From this, there should be two extensions of this job for the Active LTS Node versions, Node 10 and Node 12.
  node-10:    <<: *node-latest    docker:      - image: node:10  node-12:    <<: *node-latest    docker:      - image: node:12
Notice that these declarations only change the Docker Node images used to run that job.
Additionally, the jobs listed within workflows must also be updated to reflect our changes in configuration:
    jobs:      - node-latest      - node-10      - node-12
appveyor.yml​
For appveyor we are currently only testing the oldest Active LTS Node version, Node 10. Update the nodejs_version proppert in your appveyor.yml file to reflect this.
environment:  nodejs_version: "10"
Deprecating Node 8 & Updating packge.json engines​
In Jan 2020, Node will end its Node 8 maintenance. We will follow suit by setting the package.json engine property in oclif packages to >=10 and bumping the package's major versions.
Depending on how you ship your CLI you may wish to also bump the engines version in your CLI's package.json. You can read more about the implications of the engines property configuration in the npm documentation.
Also consider distributing your CLI with its own Node version.
Packaged Node Version​
When using dev-cli to pack your CLI it will use the Node version as specified in your package.json under the oclif.update.node.version property. This value should reflect an Active LTS Node version (dev-cli does not currently enforce versions).
Supporting the future​
As a community we may discover bumps along the way as we upgrade. If you notice something related to oclif please feel free to open an issue or submit a pull request under the relevant oclif package within the org.
We look forward to using the latest from Node and the community and keeping oclif healthy along the way.oclifconf 2019: A RecapSeptember 16, 2019 · 4 min readIn May, Heroku and Salesforce Open Source organized oclifconf, a conference for developers & product managers building CLI tools on top of the open source oclif framework. The speakers came from various tech companies, such as Adobe, Netlify, and Apollo, who have already built amazing CLI experiences. The topics covered everything from the incredible capabilities oclif has unlocked, to the community-built plugins extending its functionality, and even what the behavior of an adaptive CLI tool might look like.
Below is a listing of all of the talks from the event, along with a short summary. Enjoy!
The future of oclif by Jeff Dickey​

In its relatively short lifetime, oclif has already inspired many developers and companies to adopt its framework as a means for implementing their own command-line tooling. In this talk, Jeff Dickey, an oclif founding team member, recaps the project's history and inspiration. He also looks towards the future and outlines some features and improvements that the tool could adapt. This isn't so much a definitive roadmap of where oclif is headed, but rather, a call to inspiration for developers eager to contribute! And if you are interested in contributing, check out the open issues in the oclif GitHub repo and come say "Hello!" on Spectrum Chat.
Open Source Citizenship by Josh Simmons​

When it comes to open source, it's more than just individuals now. More and more frequently, large corporations are contributing to projects by donating to contributors, sponsoring events, or upstreaming contributions. But keeping open source projects and communities healthy requires more than just money and brainpower. Josh Simmons surveyed multiple open source communities and relays his findings as to what help maintainers and contributors actually need in this talk.
Building an enterprise-grade CLI with oclif by Thomas Dvornik​

Security and performance are all about trust. While oclif is an extremely extensible framework for building CLI tooling, there are additional requirements to fulfill for enterprise businesses to adopt it that might not be necessary for individual developers. Thomas Dvornik outlines what he and his colleagues at Salesforce have implemented as plugins to oclif to satisfy these needs, including encrypted OAuth, plugin signing, lazy loading dependencies, synchronizing weekly releases and deprecations across dozens of repositories, and establishing cross-team coding and documentation standards.
How Adobe I/O built an extensible CLI with oclif by Jesse MacFadyen​

Perhaps oclif's most appealing feature is its support for plugins. In Cordova's case, they've created a sophisticated telemetry system that helps Adobe developers see which commands users are using--and reports on which ones are erroring out. By embedding a feedback system into the tool, users are even able to quickly send their suggestions to a form, without ever leaving the terminal. Jesse MacFadyen demonstrates how oclif's plugin system can work beyond simply executing commands.
Integrating oclif with GraphQL and Apollo by Evans Hauser​

For Evans Hauser and the team at Apollo, oclif is best thought of as "React for the CLI." As a client paired with a strongly-typed API contract to a server, it can deliver structured and consistent commands to retrieve external data. What better mechanism to use for this transfer than GraphQL, a framework which empowers the client to ask precisely for the data it needs, and nothing more?
Adaptive Intent-based CLI State Machines by Shawn Wang​

In designing oclif, Jeff Dickey wrote out 12 CLI factors to keep in mind. In this talk, Shawn Wang outlines a 13th: state. State is hard, because it depends on context, and context depends on understanding what a user intends to do, not what they are asking. Shawn is working towards enabling oclif to better understand the commands a user has entered, so that it can predict and interpret future commands that might be entered next. This would enable CLI tools to not just interpret a users' commands, but to also interpret their intent.\n\nIntroducing `oclif init` commandApril 10, 2024 · 2 min readThanks to the contribution of @joshcanhelp we released a new command for the oclif CLI called oclif init in version 4.8.0
The oclif init command allows you to initialize oclif in an existing project directory by adding the bare minimum requirements: a few pieces of configuration, bin scripts, and a couple of dependencies (@oclif/core and ts-node). This is slightly different from oclif generate, which will create an entirely new oclif project based on our templates.
oclif init will add the following:

bin scripts: bin/run.js, bin/run.cmd, bin/dev.js, and bin/dev.cmd
oclif section to package.json with bin, dirname, commands, and topicSeparator set (See Configuring Your CLI for more)
@oclif/core to dependencies in your package.json (if it's not already there)
ts-node to devDependencies in your package.json (if it's not already there)

Once you've initialized oclif, you can use the bin scripts to execute your CLI. You can also use the other oclif commands like oclif generate command and oclif generate hook to start adding new functionality.

❯ oclif init --helpInitialize a new oclif CLIUSAGE  $ oclif init [--bin <value>] [--module-type ESM|CommonJS] [--package-manager npm|yarn|pnpm] [--topic-separator    colons|spaces] [-d <value>] [-y]FLAGS  -d, --output-dir=<value>        Directory to initialize the CLI in.  -y, --yes                       Use defaults for all prompts. Individual flags will override defaults.      --bin=<value>               Supply answer for prompt: Command bin name the CLI will export      --module-type=<option>      Supply answer for prompt: Select a module type                                  <options: ESM|CommonJS>      --package-manager=<option>  Supply answer for prompt: Select a package manager                                  <options: npm|yarn|pnpm>      --topic-separator=<option>  Supply answer for prompt: Select a topic separator                                  <options: colons|spaces>DESCRIPTION  Initialize a new oclif CLI  This will add the necessary oclif bin files, add oclif config to package.json, and install @oclif/core and ts-node.EXAMPLES  Initialize a new CLI in the current directory    $ oclif init  Initialize a new CLI in a different directory    $ oclif init --output-dir "/path/to/existing/project"  Supply answers for specific prompts    $ oclif init --topic-separator colons --bin mycli
Hope you enjoy the new command! If you come across any issues or have any new ideas for this command, head over to the oclif/oclif repo and open a new issue.
All our best,
The oclif teamoclif Spring 2024 UpdateMarch 29, 2024 · 4 min readHello oclif developers! It's been a while since we last uploaded a blog - and a lot has happened.
We've been focusing on these high-level areas over the past couple of years:

Improving @oclif/core
ESM Support
Improving and revitalizing oclif.io
Re-engaging the oclif community

Improving @oclif/core​
Since we announced @oclif/core over three years ago, we've released two new major versions, each packed with lots of features that we're really excited about.
Here are some of these changes:

Full support for ESM and interoperability with CommonJS (more on this topic below).
Configurable command discovery strategies that give you more control over how commands are loaded at runtime. Check out the docs.
A new preparse hook that allows you to manipulate the provided arguments before they're parsed. Salesforce used this hook to implement a neat --flags-dir feature that translates local files into flags.
A new Performance class that you can use to track performance inside of @oclif/core and your own CLI or plugin. Check out the docs.
A new flag type, Flags.option, that lets you define a flag with a preset list of options. Typescript then uses the options to infer the flag's type.
Flags now have a relationship property that allows you to define more complex relationships between flags. Check out the flags docs for more information.
Flags now have a defaultHelp property that allows you to set the human readable default value in the command help. This property is useful when your flag's parse method returns a complex type, such as an object or a class. Check out the flags docs for more.
Commands now have a hiddenAliases property that allows you to define aliases that you want to hide from the user. The property is super helpful when you're trying to wean users off a deprecated command.
You can now use bun or tsx as dev runtimes (as opposed to node or ts-node).
A command's usage, args, and flags are now shown whenever a user forgets to provide a required arg or flag, or when they provided a non-existent flag.

If you need help migrating to the latest version, head over to core's README which has links to the migration guides. Feel free to open a new discussion if you need more hands-on help from us or the community.
ESM Support​
Version 3 of @oclif/core introduced full support for developing ESM plugins and CLIs. It also offered full support for interoperability between CommonJS and ESM plugins.
Put more simply, you can now migrate your CLI to ESM while keeping individual plugins in CommonJS (or vice versa). The upgrade path is now much simpler for you. You also don't need to worry about any community plugins that have migrated to ESM before you did (such as all the @oclif plugins) or are staunchly sticking with CommonJS for the foreseeable future.
Read more about this topic here.
Improving and Revitalizing oclif.io​
Another area of focus for us has been improving our documentation site, oclif.io.
While improving the quality and accuracy of the documentation was our priority, we also took the time to upgrade to the latest version of docusaurus. This new version gave our site a much-needed facelift, as well as cool new features such as dark mode and announcements.
If you have any feedback or are running into issues, we want to hear about it. Just create an issue in the oclif.io repo.
Re-engaging the oclif Community​
Lastly, our biggest priority at the moment is to re-engage the oclif community. We understand how frustrating it has been over the years to see your issues and pull requests go unacknowledged. We apologize for not prioritizing the community, and are earnestly trying to make sure that every issue and pull request gets the attention it deserves going forward.
We also opened up GitHub discussions for @oclif/core and the oclif CLI, where you can now post your questions or ideas. We hope you take advantage of them, we love hearing from you!
One last thing: we intend to publicly post our roadmap so you have more visibility into what we're working on. Stay tuned!
All our best,
The oclif teamAnnouncing oclif v2!January 12, 2022 · 5 min readHello and happy new year! It's our great pleasure to announce that we have released oclif v2, which uses the new @oclif/core library! 🎉
oclif v2 includes many changes that improve the experience of both creating and using an oclif CLI.
Going forward, we don't plan to make any updates to oclif v1 and its corresponding libraries, except for critical security fixes. See the compatibility matrix for a list of these libraries. In order to give developers time to migrate from v1 to v2, we're not completely dropping support yet. But at some point in the future we'll archive the v1 repositories and deprecate their versions on npm.
What’s changing?​
Repository Changes​
All repositories under the oclif org now use main as their primary branch and oclif-v1 as the legacy branch. The main  branch corresponds to oclif v2 and the oclif-v1 branch to oclif v1. If you find any repos that don’t have a main branch, you can safely assume that they're not used in oclif v2 and will be deprecated in the future.
Consolidating Tools & Libraries​
The oclif-dev CLI has now been incorporated into oclif. You now no longer need to install a separate package to manage your entire CLI’s lifecycle.
The following libraries have been consolidated under @oclif/core and will be deprecated at some point in the future. Read the migration guide to learn how to update your CLI or plugin to use the new core library.

@oclif/command
@oclif/config
@oclif/error
@oclif/help
@oclif/parser

No more single vs multi command CLIs​
There's only one "type" of oclif v2 CLI, but it can have as few or as many commands as a developer wants. As a result, there’s only one command to generate CLIs, oclif generate, as opposed to the old oclif single and oclif multi commands.
Node > 12​
To ensure oclif CLIs are as secure as possible, all v2 libraries and plugins support only Node 12 or higher as of now. Going forward, they'll support only Node Maintenance or higher, as defined by Node's release schedule here: https://nodejs.org/en/about/releases/.
What’s new?​
New example CLI​
oclif-hello-world is our new example repo. This is also the repo that's used as a template when running oclif generate to create a new CLI. This repo will always be able to be referenced as an example of what an oclif v2 CLI should look like.
Spaced commands​
oclif CLIs can now use spaces, instead of colons, to separate topics and subcommands. To enable this feature, simply add “topicSeparator": " " to the oclif config in your package.json. See an example in our example repo.
// Old commands that use :$ mycli do:something
// New spaced commands$ mycli do something

Note: Spaced commands are backwards compatible. So if you enable spaced commands for your CLI, users will still be able to use : as a separator. This ensures that any existing scripts don't break.

New Help Output​
We’ve revamped the way command help is outputted to the terminal, making it both easier to implement and easier to read. See the difference between the old help output on the left and the new help output on the right in the screenshots below.
oclif v1oclif v2
Notice that there are new sections for flags and global flags, examples are displayed with better spacing, and there is a section at the bottom called Configuration Variables. This Configuration Variables section is not part of the new help by default. But we've added support for custom help sections, which is what the sf CLI uses to create the new section.
Async Command Parsing​
We’ve also improved the performance of new CLIs by rewriting how commands are parsed on initialization. The new parser is asynchronous, which makes CLIs with a lot of commands or installed  plugins much faster.
What’s coming next?​
Part of our charter for the release of oclif v2 includes improving our engagement with the oclif community. We know that over the past couple of years we’ve reduced our involvement, and a lot of issues and PRs have languished in limbo. Hopefully you’ve already seen increased activity and responses from oclif maintainers recently, but if you haven’t, please don’t hesitate to ping us by tagging @admins in oclif repos.
We also want to start interviewing members of the oclif community to acquire feedback and prioritize the features and fixes you deem most important!
Best,
The oclif team

Reference material​
Migration Guide​
This guide explains how to upgrade a CLI or plugin from the old oclif v1 libraries to the new @oclif/core library that oclif v2 uses.
https://github.com/oclif/core/blob/main/MIGRATION.md
Compatibility Matrix​
The following matrix shows how the v1 libraries and plugins relate to the new v2 ones. Use this matrix as a guide to know what to drop and which versions to switch when upgrading your plugins and CLIs to v2.
oclif "v1"oclif "v2"Utility CLIsoclif@<2@oclif/dev-cli@<2oclif@>=2Main packages@oclif/command@oclif/config@oclif/errors@oclif/parser@oclif/plugin-help@oclif/core@>=1Node LTSNode v8-14Node v12+ (at time of writing)TypeScripttypescript@<4typescript@>=4Main plugins@oclif/plugin-autocomplete@<1@oclif/plugin-commands@<2@oclif/plugin-help@<4@oclif/plugin-not-found@<2@oclif/plugin-plugins@<2@oclif/plugin-update@<2plugin-warn-if-update-available@<2plugin-which@<2@oclif/plugin-autocomplete@>=1@oclif/plugin-commands@>=2@oclif/plugin-help@>=4@oclif/plugin-not-found@>=2@oclif/plugin-plugins@>=2@oclif/plugin-update@>=2@oclif/plugin-warn-if-update-available@>=2@oclif/plugin-which@>=2Introducing @oclif/coreMarch 1, 2021 · 3 min readGreetings!
We hope this blog post finds you well.
Introducing...​
We are excited to announce the next iteration of the oclif project today: @oclif/core.
We have learned a lot in the last three years of developing oclif, developing on oclif and supporting millions of command runs a day via Heroku and Salesforce CLIs.
@oclif/core ("Core") simplifies the oclif development experience and introduces highly requested new features.
Core combines the essential oclif packages into one "core" package, aptly named @oclif/core.
Core also introduces:

A default command option
Colon or space command syntax
Async command parsing
Command piping to arguments

With the introduction of default command functionality, Core simplifies the oclif project and removes the notion of single or multi command CLIs. Core CLIs can have 1 or many commands.
Along with Core, we moved the oclif-dev CLI into the oclif CLI creating a single "utility" CLI. This CLI also introduces a new AWS S3 compatible publishing scheme.
What to expect in the near future​
Core is in pre-release beta and being actively developed for new internal Salesforce CLIs.
Much documentation needs to be written in the coming months including migration paths. Migration onto Core should be as painless as possible with many exports remaining entirely unchanged. Look for forthcoming blog posts and documentation on oclif.io.
Early this summer, tentively June 1, we will release Core v1. Core's release will coincide with major bumps to many other oclif plugin packages. See the compatibility matrix below.
At Core's v1 release, the current "main" oclif packages (namely: command, config, errors & parser) will go into maintenance mode until Jan 2022. They will receive only bug and security fixes and they remain compatible with current versions of the oclif and oclif-dev CLIs. Afterwhich, they will be archived.
Companioning Core, the next major release of the oclif CLI (literally oclif@2) will generate Core CLIs.
Going forward​
We are excited to release Core! We invite you to poke around the Core repo. It may appear to be a big change but Core keeps what you already enjoy about oclif while reducing development complexity, project dependencies, package coupling and bundle size and introduces many requested features previously too prickly to weave into the current oclif architecture.
Best,
The oclif team
Reference: Compatibility matrix​
oclif "v1"oclif "Core"Utility CLIsoclif@<2@oclif/dev-cli@<2oclif@>=2Main packages@oclif/core@<2@oclif/config@<2@oclif/errors@<2@oclif/parser@<4@oclif/plugin-help@<4@oclif/core@>=1Node LTSNode v8-14Node v12+TypeScripttypescript@<4typescript@>=4Main plugins@oclif/plugin-autocomplete@<1@oclif/plugin-commands@<2@oclif/plugin-help@<4@oclif/plugin-not-found@<2@oclif/plugin-plugins@<2@oclif/plugin-update@<2plugin-warn-if-update-available@<2plugin-which@<2@oclif/plugin-autocomplete@>=2@oclif/plugin-commands@>=2@oclif/plugin-help@>=4@oclif/plugin-not-found@>=2@oclif/plugin-plugins@>=2@oclif/plugin-update@>=2@oclif/plugin-warn-if-update-available@>=2@oclif/plugin-which@>=2oclif Summer 2020 UpdateAugust 26, 2020 · 2 min readHello oclif developers! We hope you are all doing well.
Earlier this year, we started our planning for oclifconf v2 and, like all conference, had to change course. We opted not to hold a virtual conference, however, we wanted to take some time to highlight a few oclif features shipped this year.
Feature: Help templating​
One of the most requested features, help templating enables oclif developers to customize the help output for their CLI.
Read the announcement.
Feature: Custom error delegation​
This feature both improved how oclif throws and handles errors and allows oclif developers to overwrite or interject in oclif’s error handling.
Read the announcement.
Feature: postrun hooks​
We have added a new lifecycle event postrun. Your CLI can now run a hook after a command has ran.
See our hook documentation.
Feature: Root index command​
Previously, oclif would display CLI help if only the binary name with no command ID was invoked, oclif now supports a "root index" command. If present, a command defined at src/commands/index.ts will be run if no command ID is found.
1 million weekly downloads​
While exact oclif usage metrics are hard to pin down, we use npm download statistics of oclif packages as a rough approximation. Earlier this year, oclif's command package hit 1 million weekly downloads for the first time!
This year has been presented its challenges on everyone. We want to thank you, oclif developers, whom have taken the time to use and improve the oclif project. We look forward to seeing you all - in person - in the future!
All our best,
The oclif teamPretty Printable ErrorsJuly 1, 2020 · One min readOften CLIs are used as handy tools and when things go wrong it’s useful to have additional context. In oclif we have added a couple of additional properties that can show extra context to the users when an error is displayed. The code, ref and suggestions will now be displayed if they are included. This will work with an existing oclif CLI by adding the latest @oclif/errors and @oclif/core to the CLI's package.json dependencies.
For example, using this.error with the additional properties:
class TestError extends Command {  async run() {    this.error("An error has occurred!", {      code: "OCLIF_ERR",      ref: "https://oclif.io/docs/commands#thiserrormessage-string--error-options-code-string-exit-number",      suggestions: ["Use these extra properties to provide additional context"],    })  }}
would result with the following output:
›   Error: An error has occurred!›   Code: OCLIF_ERR›   Try this: Use these extra properties to provide additional context›   Reference: https://oclif.io/docs/commands#thiserrormessage-string--error-options-code-string-exit-number
If these properties are not provided then nothing changes and the CLI will continue to display the single error message output as it did before. Additionally, as part of this exercise we’ve added documentation around Error Handling in oclif which should come in handy if the need arises to extend oclif’s default handling of errors.Customizing Help in oclifMay 5, 2020 · 2 min readOut of the box oclif provides a great help experience for CLIs.
But what if, as an oclif developer, you want to customize some or all of the output?
You can now customize your CLI's help output by implementing the HelpBase abstract class.
Getting started with custom help​
If you have not done so yet, update @oclif/core.
$ yarn add --latest @oclif/core
To get started, first define the filepath to your help class in oclif's config in package.json. This is a relative path to the help class, without a file extension.
For this example, the help class will be created in a file at "[project root]/src/help.ts".
{  // ...  "oclif": {    "helpClass": "./lib/help"    // ...  }  // ...}
From here there are two paths, implement the HelpBase abstract class yourself or overwrite the parts of the default Help class you want to customize (ex: how command usage is displayed). We recommend the latter approach but cover both in the new Help Classes docs.
Separating TOPICS & COMMANDS in the new default Help class​
Previously, topics and child commands were listed in help output under a single list heading called "COMMANDS". But we found this can be slightly confusing. Some topics are commands also (a.k.a. topic-commands) while others are simply organizational namespacing (and when ran just show their help).
The new default Help class splits the list of children into distinct lists of "TOPICS" and "COMMANDS", with the possibility of an item appearing in both if it a topic-command. This makes it clearer what is expected to be ran - "COMMANDS" - and what is providing structure - "TOPICS" - when looking at the help output.
VERSION  plugin-help-example/0.0.0 darwin-x64 node-v12.12.0USAGE  $ plugin-help-example [COMMAND]TOPICS  topic  this is a topic and has child topics or commandsCOMMANDS  hello  describe the command here  help   display help for plugin-help-example
We look forward to seeing what custom help features you implement in your oclif CLIs with this new feature!oclif TSLint to ESLint MigrationDecember 5, 2019 · 3 min readBack in February of this year, plans were announced to deprecate TSLint in favor of ESLint. TSLint's goal has become to work toward a “unified developer experience” by supporting ESLint development going forward.
What has changed in oclif​
To keep inline with the community, oclif has transitioned to ESLint for all our core libraries as well as all our official plugins.
Starting in v1.15.x, oclif will now optionally generate projects with ESLint for both TypeScript and JavaScript CLI’s.
ESLint does require Node to be on stable LTS version, at the time of writing, Node 8.10.x, Node 10.13.x & Node 12.x.x.
How does this affect you​
Existing CLI’s are unchanged, but any newly generated CLI's will only give the option of using ESLint. If you are running tslint in your CLI, we recommend you switch to ESLint as well.
In migrating our projects we took the following steps (for an example of these changes see this pull request).


Install eslint
$ yarn add eslint eslint-config-oclif eslint-config-oclif-typescript --dev


Add eslint related files


$ echo '{  "extends": [    "oclif",    "oclif-typescript"  ],  "rules": {  }}' > .eslintrc


Remove tslint and related packages
$ yarn remove @oclif/tslint tslint


Remove tslint related configuration files
$ rm tslint.json


Change lint script in our package.json from something like:
"lint": "tsc -p test --noEmit && tslint -p test -t stylish"
to
"lint": "eslint . --ext .ts --config .eslintrc"


To preserve the test compile (tsc -p test --noEmit) we also made the following updates to our scripts:
"pretest": "tsc -p test --noEmit"
In some cases we had our posttest duplicating the same steps as our lint script so it’s cleaner to have it reference the lint job directly with:
"posttest": "yarn lint"

Run yarn lint --fix. This attempts to auto-fix any linting violations automatically. In the case an auto-fix isn’t available it should be fixed manually or ignored (see the eslint configuration doc for more information)
Do a search in the codebase for tslint and remove any unnecessary tslint disabling comments, like:

/* tslint:disable:object-literal-sort-keys */
If you are on a version of Node that is not supported by ESLint, you will also need to update your Node engine. ESLint supports Node 8, 10, and 12 so you should upgrade to the most recent Node version compatible with your CLI and also supported by ESLint (see ESLint's Installation and Usage instructions).
When will this take effect​
These changes have taken effect in oclif v1.15.1. When you generate a new CLI or plugin it will now contain configuration for ESLint instead of TSLint.oclif's Current Node SupportOctober 31, 2019 · 3 min readTo maintain a healthy project trajectory, oclif follows and supports Node Active LTS release, currently Node 10 & Node 12. This means ensuring that oclif continues to play nice with coming Active LTS Node versions and other packages in the ecosystem. Moving forward also means leaving older versions behind. Starting in 2020, Node will stop maintaining Node 8 and it is our intent at that time to also follow suit. Let’s take a look at a few ways we will be supporting these changes.
CI Environments​
CLIs created with the oclif cli going forward will be generated with a CircleCI configuration with Node 10 & 12 and an Appveyor configuration using Node 10. We have also added Node latest to CircleCi to be an early warning detection against coming Node changes (Node latest is managed by CircleCI).
We have already updated every oclif repo's CI configs to reflect this.
If your existing CLI uses either Appveyor or CircleCI you can update your config files also, like so:
.circleci/config.yml​
Your CircleCI config should contain a node-latest job, aliased as test. From this, there should be two extensions of this job for the Active LTS Node versions, Node 10 and Node 12.
  node-10:    <<: *node-latest    docker:      - image: node:10  node-12:    <<: *node-latest    docker:      - image: node:12
Notice that these declarations only change the Docker Node images used to run that job.
Additionally, the jobs listed within workflows must also be updated to reflect our changes in configuration:
    jobs:      - node-latest      - node-10      - node-12
appveyor.yml​
For appveyor we are currently only testing the oldest Active LTS Node version, Node 10. Update the nodejs_version proppert in your appveyor.yml file to reflect this.
environment:  nodejs_version: "10"
Deprecating Node 8 & Updating packge.json engines​
In Jan 2020, Node will end its Node 8 maintenance. We will follow suit by setting the package.json engine property in oclif packages to >=10 and bumping the package's major versions.
Depending on how you ship your CLI you may wish to also bump the engines version in your CLI's package.json. You can read more about the implications of the engines property configuration in the npm documentation.
Also consider distributing your CLI with its own Node version.
Packaged Node Version​
When using dev-cli to pack your CLI it will use the Node version as specified in your package.json under the oclif.update.node.version property. This value should reflect an Active LTS Node version (dev-cli does not currently enforce versions).
Supporting the future​
As a community we may discover bumps along the way as we upgrade. If you notice something related to oclif please feel free to open an issue or submit a pull request under the relevant oclif package within the org.
We look forward to using the latest from Node and the community and keeping oclif healthy along the way.oclifconf 2019: A RecapSeptember 16, 2019 · 4 min readIn May, Heroku and Salesforce Open Source organized oclifconf, a conference for developers & product managers building CLI tools on top of the open source oclif framework. The speakers came from various tech companies, such as Adobe, Netlify, and Apollo, who have already built amazing CLI experiences. The topics covered everything from the incredible capabilities oclif has unlocked, to the community-built plugins extending its functionality, and even what the behavior of an adaptive CLI tool might look like.
Below is a listing of all of the talks from the event, along with a short summary. Enjoy!
The future of oclif by Jeff Dickey​

In its relatively short lifetime, oclif has already inspired many developers and companies to adopt its framework as a means for implementing their own command-line tooling. In this talk, Jeff Dickey, an oclif founding team member, recaps the project's history and inspiration. He also looks towards the future and outlines some features and improvements that the tool could adapt. This isn't so much a definitive roadmap of where oclif is headed, but rather, a call to inspiration for developers eager to contribute! And if you are interested in contributing, check out the open issues in the oclif GitHub repo and come say "Hello!" on Spectrum Chat.
Open Source Citizenship by Josh Simmons​

When it comes to open source, it's more than just individuals now. More and more frequently, large corporations are contributing to projects by donating to contributors, sponsoring events, or upstreaming contributions. But keeping open source projects and communities healthy requires more than just money and brainpower. Josh Simmons surveyed multiple open source communities and relays his findings as to what help maintainers and contributors actually need in this talk.
Building an enterprise-grade CLI with oclif by Thomas Dvornik​

Security and performance are all about trust. While oclif is an extremely extensible framework for building CLI tooling, there are additional requirements to fulfill for enterprise businesses to adopt it that might not be necessary for individual developers. Thomas Dvornik outlines what he and his colleagues at Salesforce have implemented as plugins to oclif to satisfy these needs, including encrypted OAuth, plugin signing, lazy loading dependencies, synchronizing weekly releases and deprecations across dozens of repositories, and establishing cross-team coding and documentation standards.
How Adobe I/O built an extensible CLI with oclif by Jesse MacFadyen​

Perhaps oclif's most appealing feature is its support for plugins. In Cordova's case, they've created a sophisticated telemetry system that helps Adobe developers see which commands users are using--and reports on which ones are erroring out. By embedding a feedback system into the tool, users are even able to quickly send their suggestions to a form, without ever leaving the terminal. Jesse MacFadyen demonstrates how oclif's plugin system can work beyond simply executing commands.
Integrating oclif with GraphQL and Apollo by Evans Hauser​

For Evans Hauser and the team at Apollo, oclif is best thought of as "React for the CLI." As a client paired with a strongly-typed API contract to a server, it can deliver structured and consistent commands to retrieve external data. What better mechanism to use for this transfer than GraphQL, a framework which empowers the client to ask precisely for the data it needs, and nothing more?
Adaptive Intent-based CLI State Machines by Shawn Wang​

In designing oclif, Jeff Dickey wrote out 12 CLI factors to keep in mind. In this talk, Shawn Wang outlines a 13th: state. State is hard, because it depends on context, and context depends on understanding what a user intends to do, not what they are asking. Shawn is working towards enabling oclif to better understand the commands a user has entered, so that it can predict and interpret future commands that might be entered next. This would enable CLI tools to not just interpret a users' commands, but to also interpret their intent.Older Entries\n\n\n\nIntroducing `oclif init` commandApril 10, 2024 · 2 min readThanks to the contribution of @joshcanhelp we released a new command for the oclif CLI called oclif init in version 4.8.0
The oclif init command allows you to initialize oclif in an existing project directory by adding the bare minimum requirements: a few pieces of configuration, bin scripts, and a couple of dependencies (@oclif/core and ts-node). This is slightly different from oclif generate, which will create an entirely new oclif project based on our templates.
oclif init will add the following:

bin scripts: bin/run.js, bin/run.cmd, bin/dev.js, and bin/dev.cmd
oclif section to package.json with bin, dirname, commands, and topicSeparator set (See Configuring Your CLI for more)
@oclif/core to dependencies in your package.json (if it's not already there)
ts-node to devDependencies in your package.json (if it's not already there)

Once you've initialized oclif, you can use the bin scripts to execute your CLI. You can also use the other oclif commands like oclif generate command and oclif generate hook to start adding new functionality.

❯ oclif init --helpInitialize a new oclif CLIUSAGE  $ oclif init [--bin <value>] [--module-type ESM|CommonJS] [--package-manager npm|yarn|pnpm] [--topic-separator    colons|spaces] [-d <value>] [-y]FLAGS  -d, --output-dir=<value>        Directory to initialize the CLI in.  -y, --yes                       Use defaults for all prompts. Individual flags will override defaults.      --bin=<value>               Supply answer for prompt: Command bin name the CLI will export      --module-type=<option>      Supply answer for prompt: Select a module type                                  <options: ESM|CommonJS>      --package-manager=<option>  Supply answer for prompt: Select a package manager                                  <options: npm|yarn|pnpm>      --topic-separator=<option>  Supply answer for prompt: Select a topic separator                                  <options: colons|spaces>DESCRIPTION  Initialize a new oclif CLI  This will add the necessary oclif bin files, add oclif config to package.json, and install @oclif/core and ts-node.EXAMPLES  Initialize a new CLI in the current directory    $ oclif init  Initialize a new CLI in a different directory    $ oclif init --output-dir "/path/to/existing/project"  Supply answers for specific prompts    $ oclif init --topic-separator colons --bin mycli
Hope you enjoy the new command! If you come across any issues or have any new ideas for this command, head over to the oclif/oclif repo and open a new issue.
All our best,
The oclif teamoclif Spring 2024 UpdateMarch 29, 2024 · 4 min readHello oclif developers! It's been a while since we last uploaded a blog - and a lot has happened.
We've been focusing on these high-level areas over the past couple of years:

Improving @oclif/core
ESM Support
Improving and revitalizing oclif.io
Re-engaging the oclif community

Improving @oclif/core​
Since we announced @oclif/core over three years ago, we've released two new major versions, each packed with lots of features that we're really excited about.
Here are some of these changes:

Full support for ESM and interoperability with CommonJS (more on this topic below).
Configurable command discovery strategies that give you more control over how commands are loaded at runtime. Check out the docs.
A new preparse hook that allows you to manipulate the provided arguments before they're parsed. Salesforce used this hook to implement a neat --flags-dir feature that translates local files into flags.
A new Performance class that you can use to track performance inside of @oclif/core and your own CLI or plugin. Check out the docs.
A new flag type, Flags.option, that lets you define a flag with a preset list of options. Typescript then uses the options to infer the flag's type.
Flags now have a relationship property that allows you to define more complex relationships between flags. Check out the flags docs for more information.
Flags now have a defaultHelp property that allows you to set the human readable default value in the command help. This property is useful when your flag's parse method returns a complex type, such as an object or a class. Check out the flags docs for more.
Commands now have a hiddenAliases property that allows you to define aliases that you want to hide from the user. The property is super helpful when you're trying to wean users off a deprecated command.
You can now use bun or tsx as dev runtimes (as opposed to node or ts-node).
A command's usage, args, and flags are now shown whenever a user forgets to provide a required arg or flag, or when they provided a non-existent flag.

If you need help migrating to the latest version, head over to core's README which has links to the migration guides. Feel free to open a new discussion if you need more hands-on help from us or the community.
ESM Support​
Version 3 of @oclif/core introduced full support for developing ESM plugins and CLIs. It also offered full support for interoperability between CommonJS and ESM plugins.
Put more simply, you can now migrate your CLI to ESM while keeping individual plugins in CommonJS (or vice versa). The upgrade path is now much simpler for you. You also don't need to worry about any community plugins that have migrated to ESM before you did (such as all the @oclif plugins) or are staunchly sticking with CommonJS for the foreseeable future.
Read more about this topic here.
Improving and Revitalizing oclif.io​
Another area of focus for us has been improving our documentation site, oclif.io.
While improving the quality and accuracy of the documentation was our priority, we also took the time to upgrade to the latest version of docusaurus. This new version gave our site a much-needed facelift, as well as cool new features such as dark mode and announcements.
If you have any feedback or are running into issues, we want to hear about it. Just create an issue in the oclif.io repo.
Re-engaging the oclif Community​
Lastly, our biggest priority at the moment is to re-engage the oclif community. We understand how frustrating it has been over the years to see your issues and pull requests go unacknowledged. We apologize for not prioritizing the community, and are earnestly trying to make sure that every issue and pull request gets the attention it deserves going forward.
We also opened up GitHub discussions for @oclif/core and the oclif CLI, where you can now post your questions or ideas. We hope you take advantage of them, we love hearing from you!
One last thing: we intend to publicly post our roadmap so you have more visibility into what we're working on. Stay tuned!
All our best,
The oclif teamAnnouncing oclif v2!January 12, 2022 · 5 min readHello and happy new year! It's our great pleasure to announce that we have released oclif v2, which uses the new @oclif/core library! 🎉
oclif v2 includes many changes that improve the experience of both creating and using an oclif CLI.
Going forward, we don't plan to make any updates to oclif v1 and its corresponding libraries, except for critical security fixes. See the compatibility matrix for a list of these libraries. In order to give developers time to migrate from v1 to v2, we're not completely dropping support yet. But at some point in the future we'll archive the v1 repositories and deprecate their versions on npm.
What’s changing?​
Repository Changes​
All repositories under the oclif org now use main as their primary branch and oclif-v1 as the legacy branch. The main  branch corresponds to oclif v2 and the oclif-v1 branch to oclif v1. If you find any repos that don’t have a main branch, you can safely assume that they're not used in oclif v2 and will be deprecated in the future.
Consolidating Tools & Libraries​
The oclif-dev CLI has now been incorporated into oclif. You now no longer need to install a separate package to manage your entire CLI’s lifecycle.
The following libraries have been consolidated under @oclif/core and will be deprecated at some point in the future. Read the migration guide to learn how to update your CLI or plugin to use the new core library.

@oclif/command
@oclif/config
@oclif/error
@oclif/help
@oclif/parser

No more single vs multi command CLIs​
There's only one "type" of oclif v2 CLI, but it can have as few or as many commands as a developer wants. As a result, there’s only one command to generate CLIs, oclif generate, as opposed to the old oclif single and oclif multi commands.
Node > 12​
To ensure oclif CLIs are as secure as possible, all v2 libraries and plugins support only Node 12 or higher as of now. Going forward, they'll support only Node Maintenance or higher, as defined by Node's release schedule here: https://nodejs.org/en/about/releases/.
What’s new?​
New example CLI​
oclif-hello-world is our new example repo. This is also the repo that's used as a template when running oclif generate to create a new CLI. This repo will always be able to be referenced as an example of what an oclif v2 CLI should look like.
Spaced commands​
oclif CLIs can now use spaces, instead of colons, to separate topics and subcommands. To enable this feature, simply add “topicSeparator": " " to the oclif config in your package.json. See an example in our example repo.
// Old commands that use :$ mycli do:something
// New spaced commands$ mycli do something

Note: Spaced commands are backwards compatible. So if you enable spaced commands for your CLI, users will still be able to use : as a separator. This ensures that any existing scripts don't break.

New Help Output​
We’ve revamped the way command help is outputted to the terminal, making it both easier to implement and easier to read. See the difference between the old help output on the left and the new help output on the right in the screenshots below.
oclif v1oclif v2
Notice that there are new sections for flags and global flags, examples are displayed with better spacing, and there is a section at the bottom called Configuration Variables. This Configuration Variables section is not part of the new help by default. But we've added support for custom help sections, which is what the sf CLI uses to create the new section.
Async Command Parsing​
We’ve also improved the performance of new CLIs by rewriting how commands are parsed on initialization. The new parser is asynchronous, which makes CLIs with a lot of commands or installed  plugins much faster.
What’s coming next?​
Part of our charter for the release of oclif v2 includes improving our engagement with the oclif community. We know that over the past couple of years we’ve reduced our involvement, and a lot of issues and PRs have languished in limbo. Hopefully you’ve already seen increased activity and responses from oclif maintainers recently, but if you haven’t, please don’t hesitate to ping us by tagging @admins in oclif repos.
We also want to start interviewing members of the oclif community to acquire feedback and prioritize the features and fixes you deem most important!
Best,
The oclif team

Reference material​
Migration Guide​
This guide explains how to upgrade a CLI or plugin from the old oclif v1 libraries to the new @oclif/core library that oclif v2 uses.
https://github.com/oclif/core/blob/main/MIGRATION.md
Compatibility Matrix​
The following matrix shows how the v1 libraries and plugins relate to the new v2 ones. Use this matrix as a guide to know what to drop and which versions to switch when upgrading your plugins and CLIs to v2.
oclif "v1"oclif "v2"Utility CLIsoclif@<2@oclif/dev-cli@<2oclif@>=2Main packages@oclif/command@oclif/config@oclif/errors@oclif/parser@oclif/plugin-help@oclif/core@>=1Node LTSNode v8-14Node v12+ (at time of writing)TypeScripttypescript@<4typescript@>=4Main plugins@oclif/plugin-autocomplete@<1@oclif/plugin-commands@<2@oclif/plugin-help@<4@oclif/plugin-not-found@<2@oclif/plugin-plugins@<2@oclif/plugin-update@<2plugin-warn-if-update-available@<2plugin-which@<2@oclif/plugin-autocomplete@>=1@oclif/plugin-commands@>=2@oclif/plugin-help@>=4@oclif/plugin-not-found@>=2@oclif/plugin-plugins@>=2@oclif/plugin-update@>=2@oclif/plugin-warn-if-update-available@>=2@oclif/plugin-which@>=2Introducing @oclif/coreMarch 1, 2021 · 3 min readGreetings!
We hope this blog post finds you well.
Introducing...​
We are excited to announce the next iteration of the oclif project today: @oclif/core.
We have learned a lot in the last three years of developing oclif, developing on oclif and supporting millions of command runs a day via Heroku and Salesforce CLIs.
@oclif/core ("Core") simplifies the oclif development experience and introduces highly requested new features.
Core combines the essential oclif packages into one "core" package, aptly named @oclif/core.
Core also introduces:

A default command option
Colon or space command syntax
Async command parsing
Command piping to arguments

With the introduction of default command functionality, Core simplifies the oclif project and removes the notion of single or multi command CLIs. Core CLIs can have 1 or many commands.
Along with Core, we moved the oclif-dev CLI into the oclif CLI creating a single "utility" CLI. This CLI also introduces a new AWS S3 compatible publishing scheme.
What to expect in the near future​
Core is in pre-release beta and being actively developed for new internal Salesforce CLIs.
Much documentation needs to be written in the coming months including migration paths. Migration onto Core should be as painless as possible with many exports remaining entirely unchanged. Look for forthcoming blog posts and documentation on oclif.io.
Early this summer, tentively June 1, we will release Core v1. Core's release will coincide with major bumps to many other oclif plugin packages. See the compatibility matrix below.
At Core's v1 release, the current "main" oclif packages (namely: command, config, errors & parser) will go into maintenance mode until Jan 2022. They will receive only bug and security fixes and they remain compatible with current versions of the oclif and oclif-dev CLIs. Afterwhich, they will be archived.
Companioning Core, the next major release of the oclif CLI (literally oclif@2) will generate Core CLIs.
Going forward​
We are excited to release Core! We invite you to poke around the Core repo. It may appear to be a big change but Core keeps what you already enjoy about oclif while reducing development complexity, project dependencies, package coupling and bundle size and introduces many requested features previously too prickly to weave into the current oclif architecture.
Best,
The oclif team
Reference: Compatibility matrix​
oclif "v1"oclif "Core"Utility CLIsoclif@<2@oclif/dev-cli@<2oclif@>=2Main packages@oclif/core@<2@oclif/config@<2@oclif/errors@<2@oclif/parser@<4@oclif/plugin-help@<4@oclif/core@>=1Node LTSNode v8-14Node v12+TypeScripttypescript@<4typescript@>=4Main plugins@oclif/plugin-autocomplete@<1@oclif/plugin-commands@<2@oclif/plugin-help@<4@oclif/plugin-not-found@<2@oclif/plugin-plugins@<2@oclif/plugin-update@<2plugin-warn-if-update-available@<2plugin-which@<2@oclif/plugin-autocomplete@>=2@oclif/plugin-commands@>=2@oclif/plugin-help@>=4@oclif/plugin-not-found@>=2@oclif/plugin-plugins@>=2@oclif/plugin-update@>=2@oclif/plugin-warn-if-update-available@>=2@oclif/plugin-which@>=2oclif Summer 2020 UpdateAugust 26, 2020 · 2 min readHello oclif developers! We hope you are all doing well.
Earlier this year, we started our planning for oclifconf v2 and, like all conference, had to change course. We opted not to hold a virtual conference, however, we wanted to take some time to highlight a few oclif features shipped this year.
Feature: Help templating​
One of the most requested features, help templating enables oclif developers to customize the help output for their CLI.
Read the announcement.
Feature: Custom error delegation​
This feature both improved how oclif throws and handles errors and allows oclif developers to overwrite or interject in oclif’s error handling.
Read the announcement.
Feature: postrun hooks​
We have added a new lifecycle event postrun. Your CLI can now run a hook after a command has ran.
See our hook documentation.
Feature: Root index command​
Previously, oclif would display CLI help if only the binary name with no command ID was invoked, oclif now supports a "root index" command. If present, a command defined at src/commands/index.ts will be run if no command ID is found.
1 million weekly downloads​
While exact oclif usage metrics are hard to pin down, we use npm download statistics of oclif packages as a rough approximation. Earlier this year, oclif's command package hit 1 million weekly downloads for the first time!
This year has been presented its challenges on everyone. We want to thank you, oclif developers, whom have taken the time to use and improve the oclif project. We look forward to seeing you all - in person - in the future!
All our best,
The oclif teamPretty Printable ErrorsJuly 1, 2020 · One min readOften CLIs are used as handy tools and when things go wrong it’s useful to have additional context. In oclif we have added a couple of additional properties that can show extra context to the users when an error is displayed. The code, ref and suggestions will now be displayed if they are included. This will work with an existing oclif CLI by adding the latest @oclif/errors and @oclif/core to the CLI's package.json dependencies.
For example, using this.error with the additional properties:
class TestError extends Command {  async run() {    this.error("An error has occurred!", {      code: "OCLIF_ERR",      ref: "https://oclif.io/docs/commands#thiserrormessage-string--error-options-code-string-exit-number",      suggestions: ["Use these extra properties to provide additional context"],    })  }}
would result with the following output:
›   Error: An error has occurred!›   Code: OCLIF_ERR›   Try this: Use these extra properties to provide additional context›   Reference: https://oclif.io/docs/commands#thiserrormessage-string--error-options-code-string-exit-number
If these properties are not provided then nothing changes and the CLI will continue to display the single error message output as it did before. Additionally, as part of this exercise we’ve added documentation around Error Handling in oclif which should come in handy if the need arises to extend oclif’s default handling of errors.Customizing Help in oclifMay 5, 2020 · 2 min readOut of the box oclif provides a great help experience for CLIs.
But what if, as an oclif developer, you want to customize some or all of the output?
You can now customize your CLI's help output by implementing the HelpBase abstract class.
Getting started with custom help​
If you have not done so yet, update @oclif/core.
$ yarn add --latest @oclif/core
To get started, first define the filepath to your help class in oclif's config in package.json. This is a relative path to the help class, without a file extension.
For this example, the help class will be created in a file at "[project root]/src/help.ts".
{  // ...  "oclif": {    "helpClass": "./lib/help"    // ...  }  // ...}
From here there are two paths, implement the HelpBase abstract class yourself or overwrite the parts of the default Help class you want to customize (ex: how command usage is displayed). We recommend the latter approach but cover both in the new Help Classes docs.
Separating TOPICS & COMMANDS in the new default Help class​
Previously, topics and child commands were listed in help output under a single list heading called "COMMANDS". But we found this can be slightly confusing. Some topics are commands also (a.k.a. topic-commands) while others are simply organizational namespacing (and when ran just show their help).
The new default Help class splits the list of children into distinct lists of "TOPICS" and "COMMANDS", with the possibility of an item appearing in both if it a topic-command. This makes it clearer what is expected to be ran - "COMMANDS" - and what is providing structure - "TOPICS" - when looking at the help output.
VERSION  plugin-help-example/0.0.0 darwin-x64 node-v12.12.0USAGE  $ plugin-help-example [COMMAND]TOPICS  topic  this is a topic and has child topics or commandsCOMMANDS  hello  describe the command here  help   display help for plugin-help-example
We look forward to seeing what custom help features you implement in your oclif CLIs with this new feature!oclif TSLint to ESLint MigrationDecember 5, 2019 · 3 min readBack in February of this year, plans were announced to deprecate TSLint in favor of ESLint. TSLint's goal has become to work toward a “unified developer experience” by supporting ESLint development going forward.
What has changed in oclif​
To keep inline with the community, oclif has transitioned to ESLint for all our core libraries as well as all our official plugins.
Starting in v1.15.x, oclif will now optionally generate projects with ESLint for both TypeScript and JavaScript CLI’s.
ESLint does require Node to be on stable LTS version, at the time of writing, Node 8.10.x, Node 10.13.x & Node 12.x.x.
How does this affect you​
Existing CLI’s are unchanged, but any newly generated CLI's will only give the option of using ESLint. If you are running tslint in your CLI, we recommend you switch to ESLint as well.
In migrating our projects we took the following steps (for an example of these changes see this pull request).


Install eslint
$ yarn add eslint eslint-config-oclif eslint-config-oclif-typescript --dev


Add eslint related files


$ echo '{  "extends": [    "oclif",    "oclif-typescript"  ],  "rules": {  }}' > .eslintrc


Remove tslint and related packages
$ yarn remove @oclif/tslint tslint


Remove tslint related configuration files
$ rm tslint.json


Change lint script in our package.json from something like:
"lint": "tsc -p test --noEmit && tslint -p test -t stylish"
to
"lint": "eslint . --ext .ts --config .eslintrc"


To preserve the test compile (tsc -p test --noEmit) we also made the following updates to our scripts:
"pretest": "tsc -p test --noEmit"
In some cases we had our posttest duplicating the same steps as our lint script so it’s cleaner to have it reference the lint job directly with:
"posttest": "yarn lint"

Run yarn lint --fix. This attempts to auto-fix any linting violations automatically. In the case an auto-fix isn’t available it should be fixed manually or ignored (see the eslint configuration doc for more information)
Do a search in the codebase for tslint and remove any unnecessary tslint disabling comments, like:

/* tslint:disable:object-literal-sort-keys */
If you are on a version of Node that is not supported by ESLint, you will also need to update your Node engine. ESLint supports Node 8, 10, and 12 so you should upgrade to the most recent Node version compatible with your CLI and also supported by ESLint (see ESLint's Installation and Usage instructions).
When will this take effect​
These changes have taken effect in oclif v1.15.1. When you generate a new CLI or plugin it will now contain configuration for ESLint instead of TSLint.oclif's Current Node SupportOctober 31, 2019 · 3 min readTo maintain a healthy project trajectory, oclif follows and supports Node Active LTS release, currently Node 10 & Node 12. This means ensuring that oclif continues to play nice with coming Active LTS Node versions and other packages in the ecosystem. Moving forward also means leaving older versions behind. Starting in 2020, Node will stop maintaining Node 8 and it is our intent at that time to also follow suit. Let’s take a look at a few ways we will be supporting these changes.
CI Environments​
CLIs created with the oclif cli going forward will be generated with a CircleCI configuration with Node 10 & 12 and an Appveyor configuration using Node 10. We have also added Node latest to CircleCi to be an early warning detection against coming Node changes (Node latest is managed by CircleCI).
We have already updated every oclif repo's CI configs to reflect this.
If your existing CLI uses either Appveyor or CircleCI you can update your config files also, like so:
.circleci/config.yml​
Your CircleCI config should contain a node-latest job, aliased as test. From this, there should be two extensions of this job for the Active LTS Node versions, Node 10 and Node 12.
  node-10:    <<: *node-latest    docker:      - image: node:10  node-12:    <<: *node-latest    docker:      - image: node:12
Notice that these declarations only change the Docker Node images used to run that job.
Additionally, the jobs listed within workflows must also be updated to reflect our changes in configuration:
    jobs:      - node-latest      - node-10      - node-12
appveyor.yml​
For appveyor we are currently only testing the oldest Active LTS Node version, Node 10. Update the nodejs_version proppert in your appveyor.yml file to reflect this.
environment:  nodejs_version: "10"
Deprecating Node 8 & Updating packge.json engines​
In Jan 2020, Node will end its Node 8 maintenance. We will follow suit by setting the package.json engine property in oclif packages to >=10 and bumping the package's major versions.
Depending on how you ship your CLI you may wish to also bump the engines version in your CLI's package.json. You can read more about the implications of the engines property configuration in the npm documentation.
Also consider distributing your CLI with its own Node version.
Packaged Node Version​
When using dev-cli to pack your CLI it will use the Node version as specified in your package.json under the oclif.update.node.version property. This value should reflect an Active LTS Node version (dev-cli does not currently enforce versions).
Supporting the future​
As a community we may discover bumps along the way as we upgrade. If you notice something related to oclif please feel free to open an issue or submit a pull request under the relevant oclif package within the org.
We look forward to using the latest from Node and the community and keeping oclif healthy along the way.oclifconf 2019: A RecapSeptember 16, 2019 · 4 min readIn May, Heroku and Salesforce Open Source organized oclifconf, a conference for developers & product managers building CLI tools on top of the open source oclif framework. The speakers came from various tech companies, such as Adobe, Netlify, and Apollo, who have already built amazing CLI experiences. The topics covered everything from the incredible capabilities oclif has unlocked, to the community-built plugins extending its functionality, and even what the behavior of an adaptive CLI tool might look like.
Below is a listing of all of the talks from the event, along with a short summary. Enjoy!
The future of oclif by Jeff Dickey​

In its relatively short lifetime, oclif has already inspired many developers and companies to adopt its framework as a means for implementing their own command-line tooling. In this talk, Jeff Dickey, an oclif founding team member, recaps the project's history and inspiration. He also looks towards the future and outlines some features and improvements that the tool could adapt. This isn't so much a definitive roadmap of where oclif is headed, but rather, a call to inspiration for developers eager to contribute! And if you are interested in contributing, check out the open issues in the oclif GitHub repo and come say "Hello!" on Spectrum Chat.
Open Source Citizenship by Josh Simmons​

When it comes to open source, it's more than just individuals now. More and more frequently, large corporations are contributing to projects by donating to contributors, sponsoring events, or upstreaming contributions. But keeping open source projects and communities healthy requires more than just money and brainpower. Josh Simmons surveyed multiple open source communities and relays his findings as to what help maintainers and contributors actually need in this talk.
Building an enterprise-grade CLI with oclif by Thomas Dvornik​

Security and performance are all about trust. While oclif is an extremely extensible framework for building CLI tooling, there are additional requirements to fulfill for enterprise businesses to adopt it that might not be necessary for individual developers. Thomas Dvornik outlines what he and his colleagues at Salesforce have implemented as plugins to oclif to satisfy these needs, including encrypted OAuth, plugin signing, lazy loading dependencies, synchronizing weekly releases and deprecations across dozens of repositories, and establishing cross-team coding and documentation standards.
How Adobe I/O built an extensible CLI with oclif by Jesse MacFadyen​

Perhaps oclif's most appealing feature is its support for plugins. In Cordova's case, they've created a sophisticated telemetry system that helps Adobe developers see which commands users are using--and reports on which ones are erroring out. By embedding a feedback system into the tool, users are even able to quickly send their suggestions to a form, without ever leaving the terminal. Jesse MacFadyen demonstrates how oclif's plugin system can work beyond simply executing commands.
Integrating oclif with GraphQL and Apollo by Evans Hauser​

For Evans Hauser and the team at Apollo, oclif is best thought of as "React for the CLI." As a client paired with a strongly-typed API contract to a server, it can deliver structured and consistent commands to retrieve external data. What better mechanism to use for this transfer than GraphQL, a framework which empowers the client to ask precisely for the data it needs, and nothing more?
Adaptive Intent-based CLI State Machines by Shawn Wang​

In designing oclif, Jeff Dickey wrote out 12 CLI factors to keep in mind. In this talk, Shawn Wang outlines a 13th: state. State is hard, because it depends on context, and context depends on understanding what a user intends to do, not what they are asking. Shawn is working towards enabling oclif to better understand the commands a user has entered, so that it can predict and interpret future commands that might be entered next. This would enable CLI tools to not just interpret a users' commands, but to also interpret their intent.\n\nIntroducing `oclif init` commandApril 10, 2024 · 2 min readThanks to the contribution of @joshcanhelp we released a new command for the oclif CLI called oclif init in version 4.8.0
The oclif init command allows you to initialize oclif in an existing project directory by adding the bare minimum requirements: a few pieces of configuration, bin scripts, and a couple of dependencies (@oclif/core and ts-node). This is slightly different from oclif generate, which will create an entirely new oclif project based on our templates.
oclif init will add the following:

bin scripts: bin/run.js, bin/run.cmd, bin/dev.js, and bin/dev.cmd
oclif section to package.json with bin, dirname, commands, and topicSeparator set (See Configuring Your CLI for more)
@oclif/core to dependencies in your package.json (if it's not already there)
ts-node to devDependencies in your package.json (if it's not already there)

Once you've initialized oclif, you can use the bin scripts to execute your CLI. You can also use the other oclif commands like oclif generate command and oclif generate hook to start adding new functionality.

❯ oclif init --helpInitialize a new oclif CLIUSAGE  $ oclif init [--bin <value>] [--module-type ESM|CommonJS] [--package-manager npm|yarn|pnpm] [--topic-separator    colons|spaces] [-d <value>] [-y]FLAGS  -d, --output-dir=<value>        Directory to initialize the CLI in.  -y, --yes                       Use defaults for all prompts. Individual flags will override defaults.      --bin=<value>               Supply answer for prompt: Command bin name the CLI will export      --module-type=<option>      Supply answer for prompt: Select a module type                                  <options: ESM|CommonJS>      --package-manager=<option>  Supply answer for prompt: Select a package manager                                  <options: npm|yarn|pnpm>      --topic-separator=<option>  Supply answer for prompt: Select a topic separator                                  <options: colons|spaces>DESCRIPTION  Initialize a new oclif CLI  This will add the necessary oclif bin files, add oclif config to package.json, and install @oclif/core and ts-node.EXAMPLES  Initialize a new CLI in the current directory    $ oclif init  Initialize a new CLI in a different directory    $ oclif init --output-dir "/path/to/existing/project"  Supply answers for specific prompts    $ oclif init --topic-separator colons --bin mycli
Hope you enjoy the new command! If you come across any issues or have any new ideas for this command, head over to the oclif/oclif repo and open a new issue.
All our best,
The oclif teamoclif Spring 2024 UpdateMarch 29, 2024 · 4 min readHello oclif developers! It's been a while since we last uploaded a blog - and a lot has happened.
We've been focusing on these high-level areas over the past couple of years:

Improving @oclif/core
ESM Support
Improving and revitalizing oclif.io
Re-engaging the oclif community

Improving @oclif/core​
Since we announced @oclif/core over three years ago, we've released two new major versions, each packed with lots of features that we're really excited about.
Here are some of these changes:

Full support for ESM and interoperability with CommonJS (more on this topic below).
Configurable command discovery strategies that give you more control over how commands are loaded at runtime. Check out the docs.
A new preparse hook that allows you to manipulate the provided arguments before they're parsed. Salesforce used this hook to implement a neat --flags-dir feature that translates local files into flags.
A new Performance class that you can use to track performance inside of @oclif/core and your own CLI or plugin. Check out the docs.
A new flag type, Flags.option, that lets you define a flag with a preset list of options. Typescript then uses the options to infer the flag's type.
Flags now have a relationship property that allows you to define more complex relationships between flags. Check out the flags docs for more information.
Flags now have a defaultHelp property that allows you to set the human readable default value in the command help. This property is useful when your flag's parse method returns a complex type, such as an object or a class. Check out the flags docs for more.
Commands now have a hiddenAliases property that allows you to define aliases that you want to hide from the user. The property is super helpful when you're trying to wean users off a deprecated command.
You can now use bun or tsx as dev runtimes (as opposed to node or ts-node).
A command's usage, args, and flags are now shown whenever a user forgets to provide a required arg or flag, or when they provided a non-existent flag.

If you need help migrating to the latest version, head over to core's README which has links to the migration guides. Feel free to open a new discussion if you need more hands-on help from us or the community.
ESM Support​
Version 3 of @oclif/core introduced full support for developing ESM plugins and CLIs. It also offered full support for interoperability between CommonJS and ESM plugins.
Put more simply, you can now migrate your CLI to ESM while keeping individual plugins in CommonJS (or vice versa). The upgrade path is now much simpler for you. You also don't need to worry about any community plugins that have migrated to ESM before you did (such as all the @oclif plugins) or are staunchly sticking with CommonJS for the foreseeable future.
Read more about this topic here.
Improving and Revitalizing oclif.io​
Another area of focus for us has been improving our documentation site, oclif.io.
While improving the quality and accuracy of the documentation was our priority, we also took the time to upgrade to the latest version of docusaurus. This new version gave our site a much-needed facelift, as well as cool new features such as dark mode and announcements.
If you have any feedback or are running into issues, we want to hear about it. Just create an issue in the oclif.io repo.
Re-engaging the oclif Community​
Lastly, our biggest priority at the moment is to re-engage the oclif community. We understand how frustrating it has been over the years to see your issues and pull requests go unacknowledged. We apologize for not prioritizing the community, and are earnestly trying to make sure that every issue and pull request gets the attention it deserves going forward.
We also opened up GitHub discussions for @oclif/core and the oclif CLI, where you can now post your questions or ideas. We hope you take advantage of them, we love hearing from you!
One last thing: we intend to publicly post our roadmap so you have more visibility into what we're working on. Stay tuned!
All our best,
The oclif teamAnnouncing oclif v2!January 12, 2022 · 5 min readHello and happy new year! It's our great pleasure to announce that we have released oclif v2, which uses the new @oclif/core library! 🎉
oclif v2 includes many changes that improve the experience of both creating and using an oclif CLI.
Going forward, we don't plan to make any updates to oclif v1 and its corresponding libraries, except for critical security fixes. See the compatibility matrix for a list of these libraries. In order to give developers time to migrate from v1 to v2, we're not completely dropping support yet. But at some point in the future we'll archive the v1 repositories and deprecate their versions on npm.
What’s changing?​
Repository Changes​
All repositories under the oclif org now use main as their primary branch and oclif-v1 as the legacy branch. The main  branch corresponds to oclif v2 and the oclif-v1 branch to oclif v1. If you find any repos that don’t have a main branch, you can safely assume that they're not used in oclif v2 and will be deprecated in the future.
Consolidating Tools & Libraries​
The oclif-dev CLI has now been incorporated into oclif. You now no longer need to install a separate package to manage your entire CLI’s lifecycle.
The following libraries have been consolidated under @oclif/core and will be deprecated at some point in the future. Read the migration guide to learn how to update your CLI or plugin to use the new core library.

@oclif/command
@oclif/config
@oclif/error
@oclif/help
@oclif/parser

No more single vs multi command CLIs​
There's only one "type" of oclif v2 CLI, but it can have as few or as many commands as a developer wants. As a result, there’s only one command to generate CLIs, oclif generate, as opposed to the old oclif single and oclif multi commands.
Node > 12​
To ensure oclif CLIs are as secure as possible, all v2 libraries and plugins support only Node 12 or higher as of now. Going forward, they'll support only Node Maintenance or higher, as defined by Node's release schedule here: https://nodejs.org/en/about/releases/.
What’s new?​
New example CLI​
oclif-hello-world is our new example repo. This is also the repo that's used as a template when running oclif generate to create a new CLI. This repo will always be able to be referenced as an example of what an oclif v2 CLI should look like.
Spaced commands​
oclif CLIs can now use spaces, instead of colons, to separate topics and subcommands. To enable this feature, simply add “topicSeparator": " " to the oclif config in your package.json. See an example in our example repo.
// Old commands that use :$ mycli do:something
// New spaced commands$ mycli do something

Note: Spaced commands are backwards compatible. So if you enable spaced commands for your CLI, users will still be able to use : as a separator. This ensures that any existing scripts don't break.

New Help Output​
We’ve revamped the way command help is outputted to the terminal, making it both easier to implement and easier to read. See the difference between the old help output on the left and the new help output on the right in the screenshots below.
oclif v1oclif v2
Notice that there are new sections for flags and global flags, examples are displayed with better spacing, and there is a section at the bottom called Configuration Variables. This Configuration Variables section is not part of the new help by default. But we've added support for custom help sections, which is what the sf CLI uses to create the new section.
Async Command Parsing​
We’ve also improved the performance of new CLIs by rewriting how commands are parsed on initialization. The new parser is asynchronous, which makes CLIs with a lot of commands or installed  plugins much faster.
What’s coming next?​
Part of our charter for the release of oclif v2 includes improving our engagement with the oclif community. We know that over the past couple of years we’ve reduced our involvement, and a lot of issues and PRs have languished in limbo. Hopefully you’ve already seen increased activity and responses from oclif maintainers recently, but if you haven’t, please don’t hesitate to ping us by tagging @admins in oclif repos.
We also want to start interviewing members of the oclif community to acquire feedback and prioritize the features and fixes you deem most important!
Best,
The oclif team

Reference material​
Migration Guide​
This guide explains how to upgrade a CLI or plugin from the old oclif v1 libraries to the new @oclif/core library that oclif v2 uses.
https://github.com/oclif/core/blob/main/MIGRATION.md
Compatibility Matrix​
The following matrix shows how the v1 libraries and plugins relate to the new v2 ones. Use this matrix as a guide to know what to drop and which versions to switch when upgrading your plugins and CLIs to v2.
oclif "v1"oclif "v2"Utility CLIsoclif@<2@oclif/dev-cli@<2oclif@>=2Main packages@oclif/command@oclif/config@oclif/errors@oclif/parser@oclif/plugin-help@oclif/core@>=1Node LTSNode v8-14Node v12+ (at time of writing)TypeScripttypescript@<4typescript@>=4Main plugins@oclif/plugin-autocomplete@<1@oclif/plugin-commands@<2@oclif/plugin-help@<4@oclif/plugin-not-found@<2@oclif/plugin-plugins@<2@oclif/plugin-update@<2plugin-warn-if-update-available@<2plugin-which@<2@oclif/plugin-autocomplete@>=1@oclif/plugin-commands@>=2@oclif/plugin-help@>=4@oclif/plugin-not-found@>=2@oclif/plugin-plugins@>=2@oclif/plugin-update@>=2@oclif/plugin-warn-if-update-available@>=2@oclif/plugin-which@>=2Introducing @oclif/coreMarch 1, 2021 · 3 min readGreetings!
We hope this blog post finds you well.
Introducing...​
We are excited to announce the next iteration of the oclif project today: @oclif/core.
We have learned a lot in the last three years of developing oclif, developing on oclif and supporting millions of command runs a day via Heroku and Salesforce CLIs.
@oclif/core ("Core") simplifies the oclif development experience and introduces highly requested new features.
Core combines the essential oclif packages into one "core" package, aptly named @oclif/core.
Core also introduces:

A default command option
Colon or space command syntax
Async command parsing
Command piping to arguments

With the introduction of default command functionality, Core simplifies the oclif project and removes the notion of single or multi command CLIs. Core CLIs can have 1 or many commands.
Along with Core, we moved the oclif-dev CLI into the oclif CLI creating a single "utility" CLI. This CLI also introduces a new AWS S3 compatible publishing scheme.
What to expect in the near future​
Core is in pre-release beta and being actively developed for new internal Salesforce CLIs.
Much documentation needs to be written in the coming months including migration paths. Migration onto Core should be as painless as possible with many exports remaining entirely unchanged. Look for forthcoming blog posts and documentation on oclif.io.
Early this summer, tentively June 1, we will release Core v1. Core's release will coincide with major bumps to many other oclif plugin packages. See the compatibility matrix below.
At Core's v1 release, the current "main" oclif packages (namely: command, config, errors & parser) will go into maintenance mode until Jan 2022. They will receive only bug and security fixes and they remain compatible with current versions of the oclif and oclif-dev CLIs. Afterwhich, they will be archived.
Companioning Core, the next major release of the oclif CLI (literally oclif@2) will generate Core CLIs.
Going forward​
We are excited to release Core! We invite you to poke around the Core repo. It may appear to be a big change but Core keeps what you already enjoy about oclif while reducing development complexity, project dependencies, package coupling and bundle size and introduces many requested features previously too prickly to weave into the current oclif architecture.
Best,
The oclif team
Reference: Compatibility matrix​
oclif "v1"oclif "Core"Utility CLIsoclif@<2@oclif/dev-cli@<2oclif@>=2Main packages@oclif/core@<2@oclif/config@<2@oclif/errors@<2@oclif/parser@<4@oclif/plugin-help@<4@oclif/core@>=1Node LTSNode v8-14Node v12+TypeScripttypescript@<4typescript@>=4Main plugins@oclif/plugin-autocomplete@<1@oclif/plugin-commands@<2@oclif/plugin-help@<4@oclif/plugin-not-found@<2@oclif/plugin-plugins@<2@oclif/plugin-update@<2plugin-warn-if-update-available@<2plugin-which@<2@oclif/plugin-autocomplete@>=2@oclif/plugin-commands@>=2@oclif/plugin-help@>=4@oclif/plugin-not-found@>=2@oclif/plugin-plugins@>=2@oclif/plugin-update@>=2@oclif/plugin-warn-if-update-available@>=2@oclif/plugin-which@>=2oclif Summer 2020 UpdateAugust 26, 2020 · 2 min readHello oclif developers! We hope you are all doing well.
Earlier this year, we started our planning for oclifconf v2 and, like all conference, had to change course. We opted not to hold a virtual conference, however, we wanted to take some time to highlight a few oclif features shipped this year.
Feature: Help templating​
One of the most requested features, help templating enables oclif developers to customize the help output for their CLI.
Read the announcement.
Feature: Custom error delegation​
This feature both improved how oclif throws and handles errors and allows oclif developers to overwrite or interject in oclif’s error handling.
Read the announcement.
Feature: postrun hooks​
We have added a new lifecycle event postrun. Your CLI can now run a hook after a command has ran.
See our hook documentation.
Feature: Root index command​
Previously, oclif would display CLI help if only the binary name with no command ID was invoked, oclif now supports a "root index" command. If present, a command defined at src/commands/index.ts will be run if no command ID is found.
1 million weekly downloads​
While exact oclif usage metrics are hard to pin down, we use npm download statistics of oclif packages as a rough approximation. Earlier this year, oclif's command package hit 1 million weekly downloads for the first time!
This year has been presented its challenges on everyone. We want to thank you, oclif developers, whom have taken the time to use and improve the oclif project. We look forward to seeing you all - in person - in the future!
All our best,
The oclif teamPretty Printable ErrorsJuly 1, 2020 · One min readOften CLIs are used as handy tools and when things go wrong it’s useful to have additional context. In oclif we have added a couple of additional properties that can show extra context to the users when an error is displayed. The code, ref and suggestions will now be displayed if they are included. This will work with an existing oclif CLI by adding the latest @oclif/errors and @oclif/core to the CLI's package.json dependencies.
For example, using this.error with the additional properties:
class TestError extends Command {  async run() {    this.error("An error has occurred!", {      code: "OCLIF_ERR",      ref: "https://oclif.io/docs/commands#thiserrormessage-string--error-options-code-string-exit-number",      suggestions: ["Use these extra properties to provide additional context"],    })  }}
would result with the following output:
›   Error: An error has occurred!›   Code: OCLIF_ERR›   Try this: Use these extra properties to provide additional context›   Reference: https://oclif.io/docs/commands#thiserrormessage-string--error-options-code-string-exit-number
If these properties are not provided then nothing changes and the CLI will continue to display the single error message output as it did before. Additionally, as part of this exercise we’ve added documentation around Error Handling in oclif which should come in handy if the need arises to extend oclif’s default handling of errors.Customizing Help in oclifMay 5, 2020 · 2 min readOut of the box oclif provides a great help experience for CLIs.
But what if, as an oclif developer, you want to customize some or all of the output?
You can now customize your CLI's help output by implementing the HelpBase abstract class.
Getting started with custom help​
If you have not done so yet, update @oclif/core.
$ yarn add --latest @oclif/core
To get started, first define the filepath to your help class in oclif's config in package.json. This is a relative path to the help class, without a file extension.
For this example, the help class will be created in a file at "[project root]/src/help.ts".
{  // ...  "oclif": {    "helpClass": "./lib/help"    // ...  }  // ...}
From here there are two paths, implement the HelpBase abstract class yourself or overwrite the parts of the default Help class you want to customize (ex: how command usage is displayed). We recommend the latter approach but cover both in the new Help Classes docs.
Separating TOPICS & COMMANDS in the new default Help class​
Previously, topics and child commands were listed in help output under a single list heading called "COMMANDS". But we found this can be slightly confusing. Some topics are commands also (a.k.a. topic-commands) while others are simply organizational namespacing (and when ran just show their help).
The new default Help class splits the list of children into distinct lists of "TOPICS" and "COMMANDS", with the possibility of an item appearing in both if it a topic-command. This makes it clearer what is expected to be ran - "COMMANDS" - and what is providing structure - "TOPICS" - when looking at the help output.
VERSION  plugin-help-example/0.0.0 darwin-x64 node-v12.12.0USAGE  $ plugin-help-example [COMMAND]TOPICS  topic  this is a topic and has child topics or commandsCOMMANDS  hello  describe the command here  help   display help for plugin-help-example
We look forward to seeing what custom help features you implement in your oclif CLIs with this new feature!oclif TSLint to ESLint MigrationDecember 5, 2019 · 3 min readBack in February of this year, plans were announced to deprecate TSLint in favor of ESLint. TSLint's goal has become to work toward a “unified developer experience” by supporting ESLint development going forward.
What has changed in oclif​
To keep inline with the community, oclif has transitioned to ESLint for all our core libraries as well as all our official plugins.
Starting in v1.15.x, oclif will now optionally generate projects with ESLint for both TypeScript and JavaScript CLI’s.
ESLint does require Node to be on stable LTS version, at the time of writing, Node 8.10.x, Node 10.13.x & Node 12.x.x.
How does this affect you​
Existing CLI’s are unchanged, but any newly generated CLI's will only give the option of using ESLint. If you are running tslint in your CLI, we recommend you switch to ESLint as well.
In migrating our projects we took the following steps (for an example of these changes see this pull request).


Install eslint
$ yarn add eslint eslint-config-oclif eslint-config-oclif-typescript --dev


Add eslint related files


$ echo '{  "extends": [    "oclif",    "oclif-typescript"  ],  "rules": {  }}' > .eslintrc


Remove tslint and related packages
$ yarn remove @oclif/tslint tslint


Remove tslint related configuration files
$ rm tslint.json


Change lint script in our package.json from something like:
"lint": "tsc -p test --noEmit && tslint -p test -t stylish"
to
"lint": "eslint . --ext .ts --config .eslintrc"


To preserve the test compile (tsc -p test --noEmit) we also made the following updates to our scripts:
"pretest": "tsc -p test --noEmit"
In some cases we had our posttest duplicating the same steps as our lint script so it’s cleaner to have it reference the lint job directly with:
"posttest": "yarn lint"

Run yarn lint --fix. This attempts to auto-fix any linting violations automatically. In the case an auto-fix isn’t available it should be fixed manually or ignored (see the eslint configuration doc for more information)
Do a search in the codebase for tslint and remove any unnecessary tslint disabling comments, like:

/* tslint:disable:object-literal-sort-keys */
If you are on a version of Node that is not supported by ESLint, you will also need to update your Node engine. ESLint supports Node 8, 10, and 12 so you should upgrade to the most recent Node version compatible with your CLI and also supported by ESLint (see ESLint's Installation and Usage instructions).
When will this take effect​
These changes have taken effect in oclif v1.15.1. When you generate a new CLI or plugin it will now contain configuration for ESLint instead of TSLint.oclif's Current Node SupportOctober 31, 2019 · 3 min readTo maintain a healthy project trajectory, oclif follows and supports Node Active LTS release, currently Node 10 & Node 12. This means ensuring that oclif continues to play nice with coming Active LTS Node versions and other packages in the ecosystem. Moving forward also means leaving older versions behind. Starting in 2020, Node will stop maintaining Node 8 and it is our intent at that time to also follow suit. Let’s take a look at a few ways we will be supporting these changes.
CI Environments​
CLIs created with the oclif cli going forward will be generated with a CircleCI configuration with Node 10 & 12 and an Appveyor configuration using Node 10. We have also added Node latest to CircleCi to be an early warning detection against coming Node changes (Node latest is managed by CircleCI).
We have already updated every oclif repo's CI configs to reflect this.
If your existing CLI uses either Appveyor or CircleCI you can update your config files also, like so:
.circleci/config.yml​
Your CircleCI config should contain a node-latest job, aliased as test. From this, there should be two extensions of this job for the Active LTS Node versions, Node 10 and Node 12.
  node-10:    <<: *node-latest    docker:      - image: node:10  node-12:    <<: *node-latest    docker:      - image: node:12
Notice that these declarations only change the Docker Node images used to run that job.
Additionally, the jobs listed within workflows must also be updated to reflect our changes in configuration:
    jobs:      - node-latest      - node-10      - node-12
appveyor.yml​
For appveyor we are currently only testing the oldest Active LTS Node version, Node 10. Update the nodejs_version proppert in your appveyor.yml file to reflect this.
environment:  nodejs_version: "10"
Deprecating Node 8 & Updating packge.json engines​
In Jan 2020, Node will end its Node 8 maintenance. We will follow suit by setting the package.json engine property in oclif packages to >=10 and bumping the package's major versions.
Depending on how you ship your CLI you may wish to also bump the engines version in your CLI's package.json. You can read more about the implications of the engines property configuration in the npm documentation.
Also consider distributing your CLI with its own Node version.
Packaged Node Version​
When using dev-cli to pack your CLI it will use the Node version as specified in your package.json under the oclif.update.node.version property. This value should reflect an Active LTS Node version (dev-cli does not currently enforce versions).
Supporting the future​
As a community we may discover bumps along the way as we upgrade. If you notice something related to oclif please feel free to open an issue or submit a pull request under the relevant oclif package within the org.
We look forward to using the latest from Node and the community and keeping oclif healthy along the way.oclifconf 2019: A RecapSeptember 16, 2019 · 4 min readIn May, Heroku and Salesforce Open Source organized oclifconf, a conference for developers & product managers building CLI tools on top of the open source oclif framework. The speakers came from various tech companies, such as Adobe, Netlify, and Apollo, who have already built amazing CLI experiences. The topics covered everything from the incredible capabilities oclif has unlocked, to the community-built plugins extending its functionality, and even what the behavior of an adaptive CLI tool might look like.
Below is a listing of all of the talks from the event, along with a short summary. Enjoy!
The future of oclif by Jeff Dickey​

In its relatively short lifetime, oclif has already inspired many developers and companies to adopt its framework as a means for implementing their own command-line tooling. In this talk, Jeff Dickey, an oclif founding team member, recaps the project's history and inspiration. He also looks towards the future and outlines some features and improvements that the tool could adapt. This isn't so much a definitive roadmap of where oclif is headed, but rather, a call to inspiration for developers eager to contribute! And if you are interested in contributing, check out the open issues in the oclif GitHub repo and come say "Hello!" on Spectrum Chat.
Open Source Citizenship by Josh Simmons​

When it comes to open source, it's more than just individuals now. More and more frequently, large corporations are contributing to projects by donating to contributors, sponsoring events, or upstreaming contributions. But keeping open source projects and communities healthy requires more than just money and brainpower. Josh Simmons surveyed multiple open source communities and relays his findings as to what help maintainers and contributors actually need in this talk.
Building an enterprise-grade CLI with oclif by Thomas Dvornik​

Security and performance are all about trust. While oclif is an extremely extensible framework for building CLI tooling, there are additional requirements to fulfill for enterprise businesses to adopt it that might not be necessary for individual developers. Thomas Dvornik outlines what he and his colleagues at Salesforce have implemented as plugins to oclif to satisfy these needs, including encrypted OAuth, plugin signing, lazy loading dependencies, synchronizing weekly releases and deprecations across dozens of repositories, and establishing cross-team coding and documentation standards.
How Adobe I/O built an extensible CLI with oclif by Jesse MacFadyen​

Perhaps oclif's most appealing feature is its support for plugins. In Cordova's case, they've created a sophisticated telemetry system that helps Adobe developers see which commands users are using--and reports on which ones are erroring out. By embedding a feedback system into the tool, users are even able to quickly send their suggestions to a form, without ever leaving the terminal. Jesse MacFadyen demonstrates how oclif's plugin system can work beyond simply executing commands.
Integrating oclif with GraphQL and Apollo by Evans Hauser​

For Evans Hauser and the team at Apollo, oclif is best thought of as "React for the CLI." As a client paired with a strongly-typed API contract to a server, it can deliver structured and consistent commands to retrieve external data. What better mechanism to use for this transfer than GraphQL, a framework which empowers the client to ask precisely for the data it needs, and nothing more?
Adaptive Intent-based CLI State Machines by Shawn Wang​

In designing oclif, Jeff Dickey wrote out 12 CLI factors to keep in mind. In this talk, Shawn Wang outlines a 13th: state. State is hard, because it depends on context, and context depends on understanding what a user intends to do, not what they are asking. Shawn is working towards enabling oclif to better understand the commands a user has entered, so that it can predict and interpret future commands that might be entered next. This would enable CLI tools to not just interpret a users' commands, but to also interpret their intent.Older Entries\n\n\n\nIntroducing `oclif init` commandApril 10, 2024 · 2 min readThanks to the contribution of @joshcanhelp we released a new command for the oclif CLI called oclif init in version 4.8.0
The oclif init command allows you to initialize oclif in an existing project directory by adding the bare minimum requirements: a few pieces of configuration, bin scripts, and a couple of dependencies (@oclif/core and ts-node). This is slightly different from oclif generate, which will create an entirely new oclif project based on our templates.
oclif init will add the following:

bin scripts: bin/run.js, bin/run.cmd, bin/dev.js, and bin/dev.cmd
oclif section to package.json with bin, dirname, commands, and topicSeparator set (See Configuring Your CLI for more)
@oclif/core to dependencies in your package.json (if it's not already there)
ts-node to devDependencies in your package.json (if it's not already there)

Once you've initialized oclif, you can use the bin scripts to execute your CLI. You can also use the other oclif commands like oclif generate command and oclif generate hook to start adding new functionality.

❯ oclif init --helpInitialize a new oclif CLIUSAGE  $ oclif init [--bin <value>] [--module-type ESM|CommonJS] [--package-manager npm|yarn|pnpm] [--topic-separator    colons|spaces] [-d <value>] [-y]FLAGS  -d, --output-dir=<value>        Directory to initialize the CLI in.  -y, --yes                       Use defaults for all prompts. Individual flags will override defaults.      --bin=<value>               Supply answer for prompt: Command bin name the CLI will export      --module-type=<option>      Supply answer for prompt: Select a module type                                  <options: ESM|CommonJS>      --package-manager=<option>  Supply answer for prompt: Select a package manager                                  <options: npm|yarn|pnpm>      --topic-separator=<option>  Supply answer for prompt: Select a topic separator                                  <options: colons|spaces>DESCRIPTION  Initialize a new oclif CLI  This will add the necessary oclif bin files, add oclif config to package.json, and install @oclif/core and ts-node.EXAMPLES  Initialize a new CLI in the current directory    $ oclif init  Initialize a new CLI in a different directory    $ oclif init --output-dir "/path/to/existing/project"  Supply answers for specific prompts    $ oclif init --topic-separator colons --bin mycli
Hope you enjoy the new command! If you come across any issues or have any new ideas for this command, head over to the oclif/oclif repo and open a new issue.
All our best,
The oclif teamoclif Spring 2024 UpdateMarch 29, 2024 · 4 min readHello oclif developers! It's been a while since we last uploaded a blog - and a lot has happened.
We've been focusing on these high-level areas over the past couple of years:

Improving @oclif/core
ESM Support
Improving and revitalizing oclif.io
Re-engaging the oclif community

Improving @oclif/core​
Since we announced @oclif/core over three years ago, we've released two new major versions, each packed with lots of features that we're really excited about.
Here are some of these changes:

Full support for ESM and interoperability with CommonJS (more on this topic below).
Configurable command discovery strategies that give you more control over how commands are loaded at runtime. Check out the docs.
A new preparse hook that allows you to manipulate the provided arguments before they're parsed. Salesforce used this hook to implement a neat --flags-dir feature that translates local files into flags.
A new Performance class that you can use to track performance inside of @oclif/core and your own CLI or plugin. Check out the docs.
A new flag type, Flags.option, that lets you define a flag with a preset list of options. Typescript then uses the options to infer the flag's type.
Flags now have a relationship property that allows you to define more complex relationships between flags. Check out the flags docs for more information.
Flags now have a defaultHelp property that allows you to set the human readable default value in the command help. This property is useful when your flag's parse method returns a complex type, such as an object or a class. Check out the flags docs for more.
Commands now have a hiddenAliases property that allows you to define aliases that you want to hide from the user. The property is super helpful when you're trying to wean users off a deprecated command.
You can now use bun or tsx as dev runtimes (as opposed to node or ts-node).
A command's usage, args, and flags are now shown whenever a user forgets to provide a required arg or flag, or when they provided a non-existent flag.

If you need help migrating to the latest version, head over to core's README which has links to the migration guides. Feel free to open a new discussion if you need more hands-on help from us or the community.
ESM Support​
Version 3 of @oclif/core introduced full support for developing ESM plugins and CLIs. It also offered full support for interoperability between CommonJS and ESM plugins.
Put more simply, you can now migrate your CLI to ESM while keeping individual plugins in CommonJS (or vice versa). The upgrade path is now much simpler for you. You also don't need to worry about any community plugins that have migrated to ESM before you did (such as all the @oclif plugins) or are staunchly sticking with CommonJS for the foreseeable future.
Read more about this topic here.
Improving and Revitalizing oclif.io​
Another area of focus for us has been improving our documentation site, oclif.io.
While improving the quality and accuracy of the documentation was our priority, we also took the time to upgrade to the latest version of docusaurus. This new version gave our site a much-needed facelift, as well as cool new features such as dark mode and announcements.
If you have any feedback or are running into issues, we want to hear about it. Just create an issue in the oclif.io repo.
Re-engaging the oclif Community​
Lastly, our biggest priority at the moment is to re-engage the oclif community. We understand how frustrating it has been over the years to see your issues and pull requests go unacknowledged. We apologize for not prioritizing the community, and are earnestly trying to make sure that every issue and pull request gets the attention it deserves going forward.
We also opened up GitHub discussions for @oclif/core and the oclif CLI, where you can now post your questions or ideas. We hope you take advantage of them, we love hearing from you!
One last thing: we intend to publicly post our roadmap so you have more visibility into what we're working on. Stay tuned!
All our best,
The oclif teamAnnouncing oclif v2!January 12, 2022 · 5 min readHello and happy new year! It's our great pleasure to announce that we have released oclif v2, which uses the new @oclif/core library! 🎉
oclif v2 includes many changes that improve the experience of both creating and using an oclif CLI.
Going forward, we don't plan to make any updates to oclif v1 and its corresponding libraries, except for critical security fixes. See the compatibility matrix for a list of these libraries. In order to give developers time to migrate from v1 to v2, we're not completely dropping support yet. But at some point in the future we'll archive the v1 repositories and deprecate their versions on npm.
What’s changing?​
Repository Changes​
All repositories under the oclif org now use main as their primary branch and oclif-v1 as the legacy branch. The main  branch corresponds to oclif v2 and the oclif-v1 branch to oclif v1. If you find any repos that don’t have a main branch, you can safely assume that they're not used in oclif v2 and will be deprecated in the future.
Consolidating Tools & Libraries​
The oclif-dev CLI has now been incorporated into oclif. You now no longer need to install a separate package to manage your entire CLI’s lifecycle.
The following libraries have been consolidated under @oclif/core and will be deprecated at some point in the future. Read the migration guide to learn how to update your CLI or plugin to use the new core library.

@oclif/command
@oclif/config
@oclif/error
@oclif/help
@oclif/parser

No more single vs multi command CLIs​
There's only one "type" of oclif v2 CLI, but it can have as few or as many commands as a developer wants. As a result, there’s only one command to generate CLIs, oclif generate, as opposed to the old oclif single and oclif multi commands.
Node > 12​
To ensure oclif CLIs are as secure as possible, all v2 libraries and plugins support only Node 12 or higher as of now. Going forward, they'll support only Node Maintenance or higher, as defined by Node's release schedule here: https://nodejs.org/en/about/releases/.
What’s new?​
New example CLI​
oclif-hello-world is our new example repo. This is also the repo that's used as a template when running oclif generate to create a new CLI. This repo will always be able to be referenced as an example of what an oclif v2 CLI should look like.
Spaced commands​
oclif CLIs can now use spaces, instead of colons, to separate topics and subcommands. To enable this feature, simply add “topicSeparator": " " to the oclif config in your package.json. See an example in our example repo.
// Old commands that use :$ mycli do:something
// New spaced commands$ mycli do something

Note: Spaced commands are backwards compatible. So if you enable spaced commands for your CLI, users will still be able to use : as a separator. This ensures that any existing scripts don't break.

New Help Output​
We’ve revamped the way command help is outputted to the terminal, making it both easier to implement and easier to read. See the difference between the old help output on the left and the new help output on the right in the screenshots below.
oclif v1oclif v2
Notice that there are new sections for flags and global flags, examples are displayed with better spacing, and there is a section at the bottom called Configuration Variables. This Configuration Variables section is not part of the new help by default. But we've added support for custom help sections, which is what the sf CLI uses to create the new section.
Async Command Parsing​
We’ve also improved the performance of new CLIs by rewriting how commands are parsed on initialization. The new parser is asynchronous, which makes CLIs with a lot of commands or installed  plugins much faster.
What’s coming next?​
Part of our charter for the release of oclif v2 includes improving our engagement with the oclif community. We know that over the past couple of years we’ve reduced our involvement, and a lot of issues and PRs have languished in limbo. Hopefully you’ve already seen increased activity and responses from oclif maintainers recently, but if you haven’t, please don’t hesitate to ping us by tagging @admins in oclif repos.
We also want to start interviewing members of the oclif community to acquire feedback and prioritize the features and fixes you deem most important!
Best,
The oclif team

Reference material​
Migration Guide​
This guide explains how to upgrade a CLI or plugin from the old oclif v1 libraries to the new @oclif/core library that oclif v2 uses.
https://github.com/oclif/core/blob/main/MIGRATION.md
Compatibility Matrix​
The following matrix shows how the v1 libraries and plugins relate to the new v2 ones. Use this matrix as a guide to know what to drop and which versions to switch when upgrading your plugins and CLIs to v2.
oclif "v1"oclif "v2"Utility CLIsoclif@<2@oclif/dev-cli@<2oclif@>=2Main packages@oclif/command@oclif/config@oclif/errors@oclif/parser@oclif/plugin-help@oclif/core@>=1Node LTSNode v8-14Node v12+ (at time of writing)TypeScripttypescript@<4typescript@>=4Main plugins@oclif/plugin-autocomplete@<1@oclif/plugin-commands@<2@oclif/plugin-help@<4@oclif/plugin-not-found@<2@oclif/plugin-plugins@<2@oclif/plugin-update@<2plugin-warn-if-update-available@<2plugin-which@<2@oclif/plugin-autocomplete@>=1@oclif/plugin-commands@>=2@oclif/plugin-help@>=4@oclif/plugin-not-found@>=2@oclif/plugin-plugins@>=2@oclif/plugin-update@>=2@oclif/plugin-warn-if-update-available@>=2@oclif/plugin-which@>=2Introducing @oclif/coreMarch 1, 2021 · 3 min readGreetings!
We hope this blog post finds you well.
Introducing...​
We are excited to announce the next iteration of the oclif project today: @oclif/core.
We have learned a lot in the last three years of developing oclif, developing on oclif and supporting millions of command runs a day via Heroku and Salesforce CLIs.
@oclif/core ("Core") simplifies the oclif development experience and introduces highly requested new features.
Core combines the essential oclif packages into one "core" package, aptly named @oclif/core.
Core also introduces:

A default command option
Colon or space command syntax
Async command parsing
Command piping to arguments

With the introduction of default command functionality, Core simplifies the oclif project and removes the notion of single or multi command CLIs. Core CLIs can have 1 or many commands.
Along with Core, we moved the oclif-dev CLI into the oclif CLI creating a single "utility" CLI. This CLI also introduces a new AWS S3 compatible publishing scheme.
What to expect in the near future​
Core is in pre-release beta and being actively developed for new internal Salesforce CLIs.
Much documentation needs to be written in the coming months including migration paths. Migration onto Core should be as painless as possible with many exports remaining entirely unchanged. Look for forthcoming blog posts and documentation on oclif.io.
Early this summer, tentively June 1, we will release Core v1. Core's release will coincide with major bumps to many other oclif plugin packages. See the compatibility matrix below.
At Core's v1 release, the current "main" oclif packages (namely: command, config, errors & parser) will go into maintenance mode until Jan 2022. They will receive only bug and security fixes and they remain compatible with current versions of the oclif and oclif-dev CLIs. Afterwhich, they will be archived.
Companioning Core, the next major release of the oclif CLI (literally oclif@2) will generate Core CLIs.
Going forward​
We are excited to release Core! We invite you to poke around the Core repo. It may appear to be a big change but Core keeps what you already enjoy about oclif while reducing development complexity, project dependencies, package coupling and bundle size and introduces many requested features previously too prickly to weave into the current oclif architecture.
Best,
The oclif team
Reference: Compatibility matrix​
oclif "v1"oclif "Core"Utility CLIsoclif@<2@oclif/dev-cli@<2oclif@>=2Main packages@oclif/core@<2@oclif/config@<2@oclif/errors@<2@oclif/parser@<4@oclif/plugin-help@<4@oclif/core@>=1Node LTSNode v8-14Node v12+TypeScripttypescript@<4typescript@>=4Main plugins@oclif/plugin-autocomplete@<1@oclif/plugin-commands@<2@oclif/plugin-help@<4@oclif/plugin-not-found@<2@oclif/plugin-plugins@<2@oclif/plugin-update@<2plugin-warn-if-update-available@<2plugin-which@<2@oclif/plugin-autocomplete@>=2@oclif/plugin-commands@>=2@oclif/plugin-help@>=4@oclif/plugin-not-found@>=2@oclif/plugin-plugins@>=2@oclif/plugin-update@>=2@oclif/plugin-warn-if-update-available@>=2@oclif/plugin-which@>=2oclif Summer 2020 UpdateAugust 26, 2020 · 2 min readHello oclif developers! We hope you are all doing well.
Earlier this year, we started our planning for oclifconf v2 and, like all conference, had to change course. We opted not to hold a virtual conference, however, we wanted to take some time to highlight a few oclif features shipped this year.
Feature: Help templating​
One of the most requested features, help templating enables oclif developers to customize the help output for their CLI.
Read the announcement.
Feature: Custom error delegation​
This feature both improved how oclif throws and handles errors and allows oclif developers to overwrite or interject in oclif’s error handling.
Read the announcement.
Feature: postrun hooks​
We have added a new lifecycle event postrun. Your CLI can now run a hook after a command has ran.
See our hook documentation.
Feature: Root index command​
Previously, oclif would display CLI help if only the binary name with no command ID was invoked, oclif now supports a "root index" command. If present, a command defined at src/commands/index.ts will be run if no command ID is found.
1 million weekly downloads​
While exact oclif usage metrics are hard to pin down, we use npm download statistics of oclif packages as a rough approximation. Earlier this year, oclif's command package hit 1 million weekly downloads for the first time!
This year has been presented its challenges on everyone. We want to thank you, oclif developers, whom have taken the time to use and improve the oclif project. We look forward to seeing you all - in person - in the future!
All our best,
The oclif teamPretty Printable ErrorsJuly 1, 2020 · One min readOften CLIs are used as handy tools and when things go wrong it’s useful to have additional context. In oclif we have added a couple of additional properties that can show extra context to the users when an error is displayed. The code, ref and suggestions will now be displayed if they are included. This will work with an existing oclif CLI by adding the latest @oclif/errors and @oclif/core to the CLI's package.json dependencies.
For example, using this.error with the additional properties:
class TestError extends Command {  async run() {    this.error("An error has occurred!", {      code: "OCLIF_ERR",      ref: "https://oclif.io/docs/commands#thiserrormessage-string--error-options-code-string-exit-number",      suggestions: ["Use these extra properties to provide additional context"],    })  }}
would result with the following output:
›   Error: An error has occurred!›   Code: OCLIF_ERR›   Try this: Use these extra properties to provide additional context›   Reference: https://oclif.io/docs/commands#thiserrormessage-string--error-options-code-string-exit-number
If these properties are not provided then nothing changes and the CLI will continue to display the single error message output as it did before. Additionally, as part of this exercise we’ve added documentation around Error Handling in oclif which should come in handy if the need arises to extend oclif’s default handling of errors.Customizing Help in oclifMay 5, 2020 · 2 min readOut of the box oclif provides a great help experience for CLIs.
But what if, as an oclif developer, you want to customize some or all of the output?
You can now customize your CLI's help output by implementing the HelpBase abstract class.
Getting started with custom help​
If you have not done so yet, update @oclif/core.
$ yarn add --latest @oclif/core
To get started, first define the filepath to your help class in oclif's config in package.json. This is a relative path to the help class, without a file extension.
For this example, the help class will be created in a file at "[project root]/src/help.ts".
{  // ...  "oclif": {    "helpClass": "./lib/help"    // ...  }  // ...}
From here there are two paths, implement the HelpBase abstract class yourself or overwrite the parts of the default Help class you want to customize (ex: how command usage is displayed). We recommend the latter approach but cover both in the new Help Classes docs.
Separating TOPICS & COMMANDS in the new default Help class​
Previously, topics and child commands were listed in help output under a single list heading called "COMMANDS". But we found this can be slightly confusing. Some topics are commands also (a.k.a. topic-commands) while others are simply organizational namespacing (and when ran just show their help).
The new default Help class splits the list of children into distinct lists of "TOPICS" and "COMMANDS", with the possibility of an item appearing in both if it a topic-command. This makes it clearer what is expected to be ran - "COMMANDS" - and what is providing structure - "TOPICS" - when looking at the help output.
VERSION  plugin-help-example/0.0.0 darwin-x64 node-v12.12.0USAGE  $ plugin-help-example [COMMAND]TOPICS  topic  this is a topic and has child topics or commandsCOMMANDS  hello  describe the command here  help   display help for plugin-help-example
We look forward to seeing what custom help features you implement in your oclif CLIs with this new feature!oclif TSLint to ESLint MigrationDecember 5, 2019 · 3 min readBack in February of this year, plans were announced to deprecate TSLint in favor of ESLint. TSLint's goal has become to work toward a “unified developer experience” by supporting ESLint development going forward.
What has changed in oclif​
To keep inline with the community, oclif has transitioned to ESLint for all our core libraries as well as all our official plugins.
Starting in v1.15.x, oclif will now optionally generate projects with ESLint for both TypeScript and JavaScript CLI’s.
ESLint does require Node to be on stable LTS version, at the time of writing, Node 8.10.x, Node 10.13.x & Node 12.x.x.
How does this affect you​
Existing CLI’s are unchanged, but any newly generated CLI's will only give the option of using ESLint. If you are running tslint in your CLI, we recommend you switch to ESLint as well.
In migrating our projects we took the following steps (for an example of these changes see this pull request).


Install eslint
$ yarn add eslint eslint-config-oclif eslint-config-oclif-typescript --dev


Add eslint related files


$ echo '{  "extends": [    "oclif",    "oclif-typescript"  ],  "rules": {  }}' > .eslintrc


Remove tslint and related packages
$ yarn remove @oclif/tslint tslint


Remove tslint related configuration files
$ rm tslint.json


Change lint script in our package.json from something like:
"lint": "tsc -p test --noEmit && tslint -p test -t stylish"
to
"lint": "eslint . --ext .ts --config .eslintrc"


To preserve the test compile (tsc -p test --noEmit) we also made the following updates to our scripts:
"pretest": "tsc -p test --noEmit"
In some cases we had our posttest duplicating the same steps as our lint script so it’s cleaner to have it reference the lint job directly with:
"posttest": "yarn lint"

Run yarn lint --fix. This attempts to auto-fix any linting violations automatically. In the case an auto-fix isn’t available it should be fixed manually or ignored (see the eslint configuration doc for more information)
Do a search in the codebase for tslint and remove any unnecessary tslint disabling comments, like:

/* tslint:disable:object-literal-sort-keys */
If you are on a version of Node that is not supported by ESLint, you will also need to update your Node engine. ESLint supports Node 8, 10, and 12 so you should upgrade to the most recent Node version compatible with your CLI and also supported by ESLint (see ESLint's Installation and Usage instructions).
When will this take effect​
These changes have taken effect in oclif v1.15.1. When you generate a new CLI or plugin it will now contain configuration for ESLint instead of TSLint.oclif's Current Node SupportOctober 31, 2019 · 3 min readTo maintain a healthy project trajectory, oclif follows and supports Node Active LTS release, currently Node 10 & Node 12. This means ensuring that oclif continues to play nice with coming Active LTS Node versions and other packages in the ecosystem. Moving forward also means leaving older versions behind. Starting in 2020, Node will stop maintaining Node 8 and it is our intent at that time to also follow suit. Let’s take a look at a few ways we will be supporting these changes.
CI Environments​
CLIs created with the oclif cli going forward will be generated with a CircleCI configuration with Node 10 & 12 and an Appveyor configuration using Node 10. We have also added Node latest to CircleCi to be an early warning detection against coming Node changes (Node latest is managed by CircleCI).
We have already updated every oclif repo's CI configs to reflect this.
If your existing CLI uses either Appveyor or CircleCI you can update your config files also, like so:
.circleci/config.yml​
Your CircleCI config should contain a node-latest job, aliased as test. From this, there should be two extensions of this job for the Active LTS Node versions, Node 10 and Node 12.
  node-10:    <<: *node-latest    docker:      - image: node:10  node-12:    <<: *node-latest    docker:      - image: node:12
Notice that these declarations only change the Docker Node images used to run that job.
Additionally, the jobs listed within workflows must also be updated to reflect our changes in configuration:
    jobs:      - node-latest      - node-10      - node-12
appveyor.yml​
For appveyor we are currently only testing the oldest Active LTS Node version, Node 10. Update the nodejs_version proppert in your appveyor.yml file to reflect this.
environment:  nodejs_version: "10"
Deprecating Node 8 & Updating packge.json engines​
In Jan 2020, Node will end its Node 8 maintenance. We will follow suit by setting the package.json engine property in oclif packages to >=10 and bumping the package's major versions.
Depending on how you ship your CLI you may wish to also bump the engines version in your CLI's package.json. You can read more about the implications of the engines property configuration in the npm documentation.
Also consider distributing your CLI with its own Node version.
Packaged Node Version​
When using dev-cli to pack your CLI it will use the Node version as specified in your package.json under the oclif.update.node.version property. This value should reflect an Active LTS Node version (dev-cli does not currently enforce versions).
Supporting the future​
As a community we may discover bumps along the way as we upgrade. If you notice something related to oclif please feel free to open an issue or submit a pull request under the relevant oclif package within the org.
We look forward to using the latest from Node and the community and keeping oclif healthy along the way.oclifconf 2019: A RecapSeptember 16, 2019 · 4 min readIn May, Heroku and Salesforce Open Source organized oclifconf, a conference for developers & product managers building CLI tools on top of the open source oclif framework. The speakers came from various tech companies, such as Adobe, Netlify, and Apollo, who have already built amazing CLI experiences. The topics covered everything from the incredible capabilities oclif has unlocked, to the community-built plugins extending its functionality, and even what the behavior of an adaptive CLI tool might look like.
Below is a listing of all of the talks from the event, along with a short summary. Enjoy!
The future of oclif by Jeff Dickey​

In its relatively short lifetime, oclif has already inspired many developers and companies to adopt its framework as a means for implementing their own command-line tooling. In this talk, Jeff Dickey, an oclif founding team member, recaps the project's history and inspiration. He also looks towards the future and outlines some features and improvements that the tool could adapt. This isn't so much a definitive roadmap of where oclif is headed, but rather, a call to inspiration for developers eager to contribute! And if you are interested in contributing, check out the open issues in the oclif GitHub repo and come say "Hello!" on Spectrum Chat.
Open Source Citizenship by Josh Simmons​

When it comes to open source, it's more than just individuals now. More and more frequently, large corporations are contributing to projects by donating to contributors, sponsoring events, or upstreaming contributions. But keeping open source projects and communities healthy requires more than just money and brainpower. Josh Simmons surveyed multiple open source communities and relays his findings as to what help maintainers and contributors actually need in this talk.
Building an enterprise-grade CLI with oclif by Thomas Dvornik​

Security and performance are all about trust. While oclif is an extremely extensible framework for building CLI tooling, there are additional requirements to fulfill for enterprise businesses to adopt it that might not be necessary for individual developers. Thomas Dvornik outlines what he and his colleagues at Salesforce have implemented as plugins to oclif to satisfy these needs, including encrypted OAuth, plugin signing, lazy loading dependencies, synchronizing weekly releases and deprecations across dozens of repositories, and establishing cross-team coding and documentation standards.
How Adobe I/O built an extensible CLI with oclif by Jesse MacFadyen​

Perhaps oclif's most appealing feature is its support for plugins. In Cordova's case, they've created a sophisticated telemetry system that helps Adobe developers see which commands users are using--and reports on which ones are erroring out. By embedding a feedback system into the tool, users are even able to quickly send their suggestions to a form, without ever leaving the terminal. Jesse MacFadyen demonstrates how oclif's plugin system can work beyond simply executing commands.
Integrating oclif with GraphQL and Apollo by Evans Hauser​

For Evans Hauser and the team at Apollo, oclif is best thought of as "React for the CLI." As a client paired with a strongly-typed API contract to a server, it can deliver structured and consistent commands to retrieve external data. What better mechanism to use for this transfer than GraphQL, a framework which empowers the client to ask precisely for the data it needs, and nothing more?
Adaptive Intent-based CLI State Machines by Shawn Wang​

In designing oclif, Jeff Dickey wrote out 12 CLI factors to keep in mind. In this talk, Shawn Wang outlines a 13th: state. State is hard, because it depends on context, and context depends on understanding what a user intends to do, not what they are asking. Shawn is working towards enabling oclif to better understand the commands a user has entered, so that it can predict and interpret future commands that might be entered next. This would enable CLI tools to not just interpret a users' commands, but to also interpret their intent.\n\nIntroducing `oclif init` commandApril 10, 2024 · 2 min readThanks to the contribution of @joshcanhelp we released a new command for the oclif CLI called oclif init in version 4.8.0
The oclif init command allows you to initialize oclif in an existing project directory by adding the bare minimum requirements: a few pieces of configuration, bin scripts, and a couple of dependencies (@oclif/core and ts-node). This is slightly different from oclif generate, which will create an entirely new oclif project based on our templates.
oclif init will add the following:

bin scripts: bin/run.js, bin/run.cmd, bin/dev.js, and bin/dev.cmd
oclif section to package.json with bin, dirname, commands, and topicSeparator set (See Configuring Your CLI for more)
@oclif/core to dependencies in your package.json (if it's not already there)
ts-node to devDependencies in your package.json (if it's not already there)

Once you've initialized oclif, you can use the bin scripts to execute your CLI. You can also use the other oclif commands like oclif generate command and oclif generate hook to start adding new functionality.

❯ oclif init --helpInitialize a new oclif CLIUSAGE  $ oclif init [--bin <value>] [--module-type ESM|CommonJS] [--package-manager npm|yarn|pnpm] [--topic-separator    colons|spaces] [-d <value>] [-y]FLAGS  -d, --output-dir=<value>        Directory to initialize the CLI in.  -y, --yes                       Use defaults for all prompts. Individual flags will override defaults.      --bin=<value>               Supply answer for prompt: Command bin name the CLI will export      --module-type=<option>      Supply answer for prompt: Select a module type                                  <options: ESM|CommonJS>      --package-manager=<option>  Supply answer for prompt: Select a package manager                                  <options: npm|yarn|pnpm>      --topic-separator=<option>  Supply answer for prompt: Select a topic separator                                  <options: colons|spaces>DESCRIPTION  Initialize a new oclif CLI  This will add the necessary oclif bin files, add oclif config to package.json, and install @oclif/core and ts-node.EXAMPLES  Initialize a new CLI in the current directory    $ oclif init  Initialize a new CLI in a different directory    $ oclif init --output-dir "/path/to/existing/project"  Supply answers for specific prompts    $ oclif init --topic-separator colons --bin mycli
Hope you enjoy the new command! If you come across any issues or have any new ideas for this command, head over to the oclif/oclif repo and open a new issue.
All our best,
The oclif teamoclif Spring 2024 UpdateMarch 29, 2024 · 4 min readHello oclif developers! It's been a while since we last uploaded a blog - and a lot has happened.
We've been focusing on these high-level areas over the past couple of years:

Improving @oclif/core
ESM Support
Improving and revitalizing oclif.io
Re-engaging the oclif community

Improving @oclif/core​
Since we announced @oclif/core over three years ago, we've released two new major versions, each packed with lots of features that we're really excited about.
Here are some of these changes:

Full support for ESM and interoperability with CommonJS (more on this topic below).
Configurable command discovery strategies that give you more control over how commands are loaded at runtime. Check out the docs.
A new preparse hook that allows you to manipulate the provided arguments before they're parsed. Salesforce used this hook to implement a neat --flags-dir feature that translates local files into flags.
A new Performance class that you can use to track performance inside of @oclif/core and your own CLI or plugin. Check out the docs.
A new flag type, Flags.option, that lets you define a flag with a preset list of options. Typescript then uses the options to infer the flag's type.
Flags now have a relationship property that allows you to define more complex relationships between flags. Check out the flags docs for more information.
Flags now have a defaultHelp property that allows you to set the human readable default value in the command help. This property is useful when your flag's parse method returns a complex type, such as an object or a class. Check out the flags docs for more.
Commands now have a hiddenAliases property that allows you to define aliases that you want to hide from the user. The property is super helpful when you're trying to wean users off a deprecated command.
You can now use bun or tsx as dev runtimes (as opposed to node or ts-node).
A command's usage, args, and flags are now shown whenever a user forgets to provide a required arg or flag, or when they provided a non-existent flag.

If you need help migrating to the latest version, head over to core's README which has links to the migration guides. Feel free to open a new discussion if you need more hands-on help from us or the community.
ESM Support​
Version 3 of @oclif/core introduced full support for developing ESM plugins and CLIs. It also offered full support for interoperability between CommonJS and ESM plugins.
Put more simply, you can now migrate your CLI to ESM while keeping individual plugins in CommonJS (or vice versa). The upgrade path is now much simpler for you. You also don't need to worry about any community plugins that have migrated to ESM before you did (such as all the @oclif plugins) or are staunchly sticking with CommonJS for the foreseeable future.
Read more about this topic here.
Improving and Revitalizing oclif.io​
Another area of focus for us has been improving our documentation site, oclif.io.
While improving the quality and accuracy of the documentation was our priority, we also took the time to upgrade to the latest version of docusaurus. This new version gave our site a much-needed facelift, as well as cool new features such as dark mode and announcements.
If you have any feedback or are running into issues, we want to hear about it. Just create an issue in the oclif.io repo.
Re-engaging the oclif Community​
Lastly, our biggest priority at the moment is to re-engage the oclif community. We understand how frustrating it has been over the years to see your issues and pull requests go unacknowledged. We apologize for not prioritizing the community, and are earnestly trying to make sure that every issue and pull request gets the attention it deserves going forward.
We also opened up GitHub discussions for @oclif/core and the oclif CLI, where you can now post your questions or ideas. We hope you take advantage of them, we love hearing from you!
One last thing: we intend to publicly post our roadmap so you have more visibility into what we're working on. Stay tuned!
All our best,
The oclif teamAnnouncing oclif v2!January 12, 2022 · 5 min readHello and happy new year! It's our great pleasure to announce that we have released oclif v2, which uses the new @oclif/core library! 🎉
oclif v2 includes many changes that improve the experience of both creating and using an oclif CLI.
Going forward, we don't plan to make any updates to oclif v1 and its corresponding libraries, except for critical security fixes. See the compatibility matrix for a list of these libraries. In order to give developers time to migrate from v1 to v2, we're not completely dropping support yet. But at some point in the future we'll archive the v1 repositories and deprecate their versions on npm.
What’s changing?​
Repository Changes​
All repositories under the oclif org now use main as their primary branch and oclif-v1 as the legacy branch. The main  branch corresponds to oclif v2 and the oclif-v1 branch to oclif v1. If you find any repos that don’t have a main branch, you can safely assume that they're not used in oclif v2 and will be deprecated in the future.
Consolidating Tools & Libraries​
The oclif-dev CLI has now been incorporated into oclif. You now no longer need to install a separate package to manage your entire CLI’s lifecycle.
The following libraries have been consolidated under @oclif/core and will be deprecated at some point in the future. Read the migration guide to learn how to update your CLI or plugin to use the new core library.

@oclif/command
@oclif/config
@oclif/error
@oclif/help
@oclif/parser

No more single vs multi command CLIs​
There's only one "type" of oclif v2 CLI, but it can have as few or as many commands as a developer wants. As a result, there’s only one command to generate CLIs, oclif generate, as opposed to the old oclif single and oclif multi commands.
Node > 12​
To ensure oclif CLIs are as secure as possible, all v2 libraries and plugins support only Node 12 or higher as of now. Going forward, they'll support only Node Maintenance or higher, as defined by Node's release schedule here: https://nodejs.org/en/about/releases/.
What’s new?​
New example CLI​
oclif-hello-world is our new example repo. This is also the repo that's used as a template when running oclif generate to create a new CLI. This repo will always be able to be referenced as an example of what an oclif v2 CLI should look like.
Spaced commands​
oclif CLIs can now use spaces, instead of colons, to separate topics and subcommands. To enable this feature, simply add “topicSeparator": " " to the oclif config in your package.json. See an example in our example repo.
// Old commands that use :$ mycli do:something
// New spaced commands$ mycli do something

Note: Spaced commands are backwards compatible. So if you enable spaced commands for your CLI, users will still be able to use : as a separator. This ensures that any existing scripts don't break.

New Help Output​
We’ve revamped the way command help is outputted to the terminal, making it both easier to implement and easier to read. See the difference between the old help output on the left and the new help output on the right in the screenshots below.
oclif v1oclif v2
Notice that there are new sections for flags and global flags, examples are displayed with better spacing, and there is a section at the bottom called Configuration Variables. This Configuration Variables section is not part of the new help by default. But we've added support for custom help sections, which is what the sf CLI uses to create the new section.
Async Command Parsing​
We’ve also improved the performance of new CLIs by rewriting how commands are parsed on initialization. The new parser is asynchronous, which makes CLIs with a lot of commands or installed  plugins much faster.
What’s coming next?​
Part of our charter for the release of oclif v2 includes improving our engagement with the oclif community. We know that over the past couple of years we’ve reduced our involvement, and a lot of issues and PRs have languished in limbo. Hopefully you’ve already seen increased activity and responses from oclif maintainers recently, but if you haven’t, please don’t hesitate to ping us by tagging @admins in oclif repos.
We also want to start interviewing members of the oclif community to acquire feedback and prioritize the features and fixes you deem most important!
Best,
The oclif team

Reference material​
Migration Guide​
This guide explains how to upgrade a CLI or plugin from the old oclif v1 libraries to the new @oclif/core library that oclif v2 uses.
https://github.com/oclif/core/blob/main/MIGRATION.md
Compatibility Matrix​
The following matrix shows how the v1 libraries and plugins relate to the new v2 ones. Use this matrix as a guide to know what to drop and which versions to switch when upgrading your plugins and CLIs to v2.
oclif "v1"oclif "v2"Utility CLIsoclif@<2@oclif/dev-cli@<2oclif@>=2Main packages@oclif/command@oclif/config@oclif/errors@oclif/parser@oclif/plugin-help@oclif/core@>=1Node LTSNode v8-14Node v12+ (at time of writing)TypeScripttypescript@<4typescript@>=4Main plugins@oclif/plugin-autocomplete@<1@oclif/plugin-commands@<2@oclif/plugin-help@<4@oclif/plugin-not-found@<2@oclif/plugin-plugins@<2@oclif/plugin-update@<2plugin-warn-if-update-available@<2plugin-which@<2@oclif/plugin-autocomplete@>=1@oclif/plugin-commands@>=2@oclif/plugin-help@>=4@oclif/plugin-not-found@>=2@oclif/plugin-plugins@>=2@oclif/plugin-update@>=2@oclif/plugin-warn-if-update-available@>=2@oclif/plugin-which@>=2Introducing @oclif/coreMarch 1, 2021 · 3 min readGreetings!
We hope this blog post finds you well.
Introducing...​
We are excited to announce the next iteration of the oclif project today: @oclif/core.
We have learned a lot in the last three years of developing oclif, developing on oclif and supporting millions of command runs a day via Heroku and Salesforce CLIs.
@oclif/core ("Core") simplifies the oclif development experience and introduces highly requested new features.
Core combines the essential oclif packages into one "core" package, aptly named @oclif/core.
Core also introduces:

A default command option
Colon or space command syntax
Async command parsing
Command piping to arguments

With the introduction of default command functionality, Core simplifies the oclif project and removes the notion of single or multi command CLIs. Core CLIs can have 1 or many commands.
Along with Core, we moved the oclif-dev CLI into the oclif CLI creating a single "utility" CLI. This CLI also introduces a new AWS S3 compatible publishing scheme.
What to expect in the near future​
Core is in pre-release beta and being actively developed for new internal Salesforce CLIs.
Much documentation needs to be written in the coming months including migration paths. Migration onto Core should be as painless as possible with many exports remaining entirely unchanged. Look for forthcoming blog posts and documentation on oclif.io.
Early this summer, tentively June 1, we will release Core v1. Core's release will coincide with major bumps to many other oclif plugin packages. See the compatibility matrix below.
At Core's v1 release, the current "main" oclif packages (namely: command, config, errors & parser) will go into maintenance mode until Jan 2022. They will receive only bug and security fixes and they remain compatible with current versions of the oclif and oclif-dev CLIs. Afterwhich, they will be archived.
Companioning Core, the next major release of the oclif CLI (literally oclif@2) will generate Core CLIs.
Going forward​
We are excited to release Core! We invite you to poke around the Core repo. It may appear to be a big change but Core keeps what you already enjoy about oclif while reducing development complexity, project dependencies, package coupling and bundle size and introduces many requested features previously too prickly to weave into the current oclif architecture.
Best,
The oclif team
Reference: Compatibility matrix​
oclif "v1"oclif "Core"Utility CLIsoclif@<2@oclif/dev-cli@<2oclif@>=2Main packages@oclif/core@<2@oclif/config@<2@oclif/errors@<2@oclif/parser@<4@oclif/plugin-help@<4@oclif/core@>=1Node LTSNode v8-14Node v12+TypeScripttypescript@<4typescript@>=4Main plugins@oclif/plugin-autocomplete@<1@oclif/plugin-commands@<2@oclif/plugin-help@<4@oclif/plugin-not-found@<2@oclif/plugin-plugins@<2@oclif/plugin-update@<2plugin-warn-if-update-available@<2plugin-which@<2@oclif/plugin-autocomplete@>=2@oclif/plugin-commands@>=2@oclif/plugin-help@>=4@oclif/plugin-not-found@>=2@oclif/plugin-plugins@>=2@oclif/plugin-update@>=2@oclif/plugin-warn-if-update-available@>=2@oclif/plugin-which@>=2oclif Summer 2020 UpdateAugust 26, 2020 · 2 min readHello oclif developers! We hope you are all doing well.
Earlier this year, we started our planning for oclifconf v2 and, like all conference, had to change course. We opted not to hold a virtual conference, however, we wanted to take some time to highlight a few oclif features shipped this year.
Feature: Help templating​
One of the most requested features, help templating enables oclif developers to customize the help output for their CLI.
Read the announcement.
Feature: Custom error delegation​
This feature both improved how oclif throws and handles errors and allows oclif developers to overwrite or interject in oclif’s error handling.
Read the announcement.
Feature: postrun hooks​
We have added a new lifecycle event postrun. Your CLI can now run a hook after a command has ran.
See our hook documentation.
Feature: Root index command​
Previously, oclif would display CLI help if only the binary name with no command ID was invoked, oclif now supports a "root index" command. If present, a command defined at src/commands/index.ts will be run if no command ID is found.
1 million weekly downloads​
While exact oclif usage metrics are hard to pin down, we use npm download statistics of oclif packages as a rough approximation. Earlier this year, oclif's command package hit 1 million weekly downloads for the first time!
This year has been presented its challenges on everyone. We want to thank you, oclif developers, whom have taken the time to use and improve the oclif project. We look forward to seeing you all - in person - in the future!
All our best,
The oclif teamPretty Printable ErrorsJuly 1, 2020 · One min readOften CLIs are used as handy tools and when things go wrong it’s useful to have additional context. In oclif we have added a couple of additional properties that can show extra context to the users when an error is displayed. The code, ref and suggestions will now be displayed if they are included. This will work with an existing oclif CLI by adding the latest @oclif/errors and @oclif/core to the CLI's package.json dependencies.
For example, using this.error with the additional properties:
class TestError extends Command {  async run() {    this.error("An error has occurred!", {      code: "OCLIF_ERR",      ref: "https://oclif.io/docs/commands#thiserrormessage-string--error-options-code-string-exit-number",      suggestions: ["Use these extra properties to provide additional context"],    })  }}
would result with the following output:
›   Error: An error has occurred!›   Code: OCLIF_ERR›   Try this: Use these extra properties to provide additional context›   Reference: https://oclif.io/docs/commands#thiserrormessage-string--error-options-code-string-exit-number
If these properties are not provided then nothing changes and the CLI will continue to display the single error message output as it did before. Additionally, as part of this exercise we’ve added documentation around Error Handling in oclif which should come in handy if the need arises to extend oclif’s default handling of errors.Customizing Help in oclifMay 5, 2020 · 2 min readOut of the box oclif provides a great help experience for CLIs.
But what if, as an oclif developer, you want to customize some or all of the output?
You can now customize your CLI's help output by implementing the HelpBase abstract class.
Getting started with custom help​
If you have not done so yet, update @oclif/core.
$ yarn add --latest @oclif/core
To get started, first define the filepath to your help class in oclif's config in package.json. This is a relative path to the help class, without a file extension.
For this example, the help class will be created in a file at "[project root]/src/help.ts".
{  // ...  "oclif": {    "helpClass": "./lib/help"    // ...  }  // ...}
From here there are two paths, implement the HelpBase abstract class yourself or overwrite the parts of the default Help class you want to customize (ex: how command usage is displayed). We recommend the latter approach but cover both in the new Help Classes docs.
Separating TOPICS & COMMANDS in the new default Help class​
Previously, topics and child commands were listed in help output under a single list heading called "COMMANDS". But we found this can be slightly confusing. Some topics are commands also (a.k.a. topic-commands) while others are simply organizational namespacing (and when ran just show their help).
The new default Help class splits the list of children into distinct lists of "TOPICS" and "COMMANDS", with the possibility of an item appearing in both if it a topic-command. This makes it clearer what is expected to be ran - "COMMANDS" - and what is providing structure - "TOPICS" - when looking at the help output.
VERSION  plugin-help-example/0.0.0 darwin-x64 node-v12.12.0USAGE  $ plugin-help-example [COMMAND]TOPICS  topic  this is a topic and has child topics or commandsCOMMANDS  hello  describe the command here  help   display help for plugin-help-example
We look forward to seeing what custom help features you implement in your oclif CLIs with this new feature!oclif TSLint to ESLint MigrationDecember 5, 2019 · 3 min readBack in February of this year, plans were announced to deprecate TSLint in favor of ESLint. TSLint's goal has become to work toward a “unified developer experience” by supporting ESLint development going forward.
What has changed in oclif​
To keep inline with the community, oclif has transitioned to ESLint for all our core libraries as well as all our official plugins.
Starting in v1.15.x, oclif will now optionally generate projects with ESLint for both TypeScript and JavaScript CLI’s.
ESLint does require Node to be on stable LTS version, at the time of writing, Node 8.10.x, Node 10.13.x & Node 12.x.x.
How does this affect you​
Existing CLI’s are unchanged, but any newly generated CLI's will only give the option of using ESLint. If you are running tslint in your CLI, we recommend you switch to ESLint as well.
In migrating our projects we took the following steps (for an example of these changes see this pull request).


Install eslint
$ yarn add eslint eslint-config-oclif eslint-config-oclif-typescript --dev


Add eslint related files


$ echo '{  "extends": [    "oclif",    "oclif-typescript"  ],  "rules": {  }}' > .eslintrc


Remove tslint and related packages
$ yarn remove @oclif/tslint tslint


Remove tslint related configuration files
$ rm tslint.json


Change lint script in our package.json from something like:
"lint": "tsc -p test --noEmit && tslint -p test -t stylish"
to
"lint": "eslint . --ext .ts --config .eslintrc"


To preserve the test compile (tsc -p test --noEmit) we also made the following updates to our scripts:
"pretest": "tsc -p test --noEmit"
In some cases we had our posttest duplicating the same steps as our lint script so it’s cleaner to have it reference the lint job directly with:
"posttest": "yarn lint"

Run yarn lint --fix. This attempts to auto-fix any linting violations automatically. In the case an auto-fix isn’t available it should be fixed manually or ignored (see the eslint configuration doc for more information)
Do a search in the codebase for tslint and remove any unnecessary tslint disabling comments, like:

/* tslint:disable:object-literal-sort-keys */
If you are on a version of Node that is not supported by ESLint, you will also need to update your Node engine. ESLint supports Node 8, 10, and 12 so you should upgrade to the most recent Node version compatible with your CLI and also supported by ESLint (see ESLint's Installation and Usage instructions).
When will this take effect​
These changes have taken effect in oclif v1.15.1. When you generate a new CLI or plugin it will now contain configuration for ESLint instead of TSLint.oclif's Current Node SupportOctober 31, 2019 · 3 min readTo maintain a healthy project trajectory, oclif follows and supports Node Active LTS release, currently Node 10 & Node 12. This means ensuring that oclif continues to play nice with coming Active LTS Node versions and other packages in the ecosystem. Moving forward also means leaving older versions behind. Starting in 2020, Node will stop maintaining Node 8 and it is our intent at that time to also follow suit. Let’s take a look at a few ways we will be supporting these changes.
CI Environments​
CLIs created with the oclif cli going forward will be generated with a CircleCI configuration with Node 10 & 12 and an Appveyor configuration using Node 10. We have also added Node latest to CircleCi to be an early warning detection against coming Node changes (Node latest is managed by CircleCI).
We have already updated every oclif repo's CI configs to reflect this.
If your existing CLI uses either Appveyor or CircleCI you can update your config files also, like so:
.circleci/config.yml​
Your CircleCI config should contain a node-latest job, aliased as test. From this, there should be two extensions of this job for the Active LTS Node versions, Node 10 and Node 12.
  node-10:    <<: *node-latest    docker:      - image: node:10  node-12:    <<: *node-latest    docker:      - image: node:12
Notice that these declarations only change the Docker Node images used to run that job.
Additionally, the jobs listed within workflows must also be updated to reflect our changes in configuration:
    jobs:      - node-latest      - node-10      - node-12
appveyor.yml​
For appveyor we are currently only testing the oldest Active LTS Node version, Node 10. Update the nodejs_version proppert in your appveyor.yml file to reflect this.
environment:  nodejs_version: "10"
Deprecating Node 8 & Updating packge.json engines​
In Jan 2020, Node will end its Node 8 maintenance. We will follow suit by setting the package.json engine property in oclif packages to >=10 and bumping the package's major versions.
Depending on how you ship your CLI you may wish to also bump the engines version in your CLI's package.json. You can read more about the implications of the engines property configuration in the npm documentation.
Also consider distributing your CLI with its own Node version.
Packaged Node Version​
When using dev-cli to pack your CLI it will use the Node version as specified in your package.json under the oclif.update.node.version property. This value should reflect an Active LTS Node version (dev-cli does not currently enforce versions).
Supporting the future​
As a community we may discover bumps along the way as we upgrade. If you notice something related to oclif please feel free to open an issue or submit a pull request under the relevant oclif package within the org.
We look forward to using the latest from Node and the community and keeping oclif healthy along the way.oclifconf 2019: A RecapSeptember 16, 2019 · 4 min readIn May, Heroku and Salesforce Open Source organized oclifconf, a conference for developers & product managers building CLI tools on top of the open source oclif framework. The speakers came from various tech companies, such as Adobe, Netlify, and Apollo, who have already built amazing CLI experiences. The topics covered everything from the incredible capabilities oclif has unlocked, to the community-built plugins extending its functionality, and even what the behavior of an adaptive CLI tool might look like.
Below is a listing of all of the talks from the event, along with a short summary. Enjoy!
The future of oclif by Jeff Dickey​

In its relatively short lifetime, oclif has already inspired many developers and companies to adopt its framework as a means for implementing their own command-line tooling. In this talk, Jeff Dickey, an oclif founding team member, recaps the project's history and inspiration. He also looks towards the future and outlines some features and improvements that the tool could adapt. This isn't so much a definitive roadmap of where oclif is headed, but rather, a call to inspiration for developers eager to contribute! And if you are interested in contributing, check out the open issues in the oclif GitHub repo and come say "Hello!" on Spectrum Chat.
Open Source Citizenship by Josh Simmons​

When it comes to open source, it's more than just individuals now. More and more frequently, large corporations are contributing to projects by donating to contributors, sponsoring events, or upstreaming contributions. But keeping open source projects and communities healthy requires more than just money and brainpower. Josh Simmons surveyed multiple open source communities and relays his findings as to what help maintainers and contributors actually need in this talk.
Building an enterprise-grade CLI with oclif by Thomas Dvornik​

Security and performance are all about trust. While oclif is an extremely extensible framework for building CLI tooling, there are additional requirements to fulfill for enterprise businesses to adopt it that might not be necessary for individual developers. Thomas Dvornik outlines what he and his colleagues at Salesforce have implemented as plugins to oclif to satisfy these needs, including encrypted OAuth, plugin signing, lazy loading dependencies, synchronizing weekly releases and deprecations across dozens of repositories, and establishing cross-team coding and documentation standards.
How Adobe I/O built an extensible CLI with oclif by Jesse MacFadyen​

Perhaps oclif's most appealing feature is its support for plugins. In Cordova's case, they've created a sophisticated telemetry system that helps Adobe developers see which commands users are using--and reports on which ones are erroring out. By embedding a feedback system into the tool, users are even able to quickly send their suggestions to a form, without ever leaving the terminal. Jesse MacFadyen demonstrates how oclif's plugin system can work beyond simply executing commands.
Integrating oclif with GraphQL and Apollo by Evans Hauser​

For Evans Hauser and the team at Apollo, oclif is best thought of as "React for the CLI." As a client paired with a strongly-typed API contract to a server, it can deliver structured and consistent commands to retrieve external data. What better mechanism to use for this transfer than GraphQL, a framework which empowers the client to ask precisely for the data it needs, and nothing more?
Adaptive Intent-based CLI State Machines by Shawn Wang​

In designing oclif, Jeff Dickey wrote out 12 CLI factors to keep in mind. In this talk, Shawn Wang outlines a 13th: state. State is hard, because it depends on context, and context depends on understanding what a user intends to do, not what they are asking. Shawn is working towards enabling oclif to better understand the commands a user has entered, so that it can predict and interpret future commands that might be entered next. This would enable CLI tools to not just interpret a users' commands, but to also interpret their intent.Older Entries\n\n\n\nIntroducing `oclif init` commandApril 10, 2024 · 2 min readThanks to the contribution of @joshcanhelp we released a new command for the oclif CLI called oclif init in version 4.8.0
The oclif init command allows you to initialize oclif in an existing project directory by adding the bare minimum requirements: a few pieces of configuration, bin scripts, and a couple of dependencies (@oclif/core and ts-node). This is slightly different from oclif generate, which will create an entirely new oclif project based on our templates.
oclif init will add the following:

bin scripts: bin/run.js, bin/run.cmd, bin/dev.js, and bin/dev.cmd
oclif section to package.json with bin, dirname, commands, and topicSeparator set (See Configuring Your CLI for more)
@oclif/core to dependencies in your package.json (if it's not already there)
ts-node to devDependencies in your package.json (if it's not already there)

Once you've initialized oclif, you can use the bin scripts to execute your CLI. You can also use the other oclif commands like oclif generate command and oclif generate hook to start adding new functionality.

❯ oclif init --helpInitialize a new oclif CLIUSAGE  $ oclif init [--bin <value>] [--module-type ESM|CommonJS] [--package-manager npm|yarn|pnpm] [--topic-separator    colons|spaces] [-d <value>] [-y]FLAGS  -d, --output-dir=<value>        Directory to initialize the CLI in.  -y, --yes                       Use defaults for all prompts. Individual flags will override defaults.      --bin=<value>               Supply answer for prompt: Command bin name the CLI will export      --module-type=<option>      Supply answer for prompt: Select a module type                                  <options: ESM|CommonJS>      --package-manager=<option>  Supply answer for prompt: Select a package manager                                  <options: npm|yarn|pnpm>      --topic-separator=<option>  Supply answer for prompt: Select a topic separator                                  <options: colons|spaces>DESCRIPTION  Initialize a new oclif CLI  This will add the necessary oclif bin files, add oclif config to package.json, and install @oclif/core and ts-node.EXAMPLES  Initialize a new CLI in the current directory    $ oclif init  Initialize a new CLI in a different directory    $ oclif init --output-dir "/path/to/existing/project"  Supply answers for specific prompts    $ oclif init --topic-separator colons --bin mycli
Hope you enjoy the new command! If you come across any issues or have any new ideas for this command, head over to the oclif/oclif repo and open a new issue.
All our best,
The oclif teamoclif Spring 2024 UpdateMarch 29, 2024 · 4 min readHello oclif developers! It's been a while since we last uploaded a blog - and a lot has happened.
We've been focusing on these high-level areas over the past couple of years:

Improving @oclif/core
ESM Support
Improving and revitalizing oclif.io
Re-engaging the oclif community

Improving @oclif/core​
Since we announced @oclif/core over three years ago, we've released two new major versions, each packed with lots of features that we're really excited about.
Here are some of these changes:

Full support for ESM and interoperability with CommonJS (more on this topic below).
Configurable command discovery strategies that give you more control over how commands are loaded at runtime. Check out the docs.
A new preparse hook that allows you to manipulate the provided arguments before they're parsed. Salesforce used this hook to implement a neat --flags-dir feature that translates local files into flags.
A new Performance class that you can use to track performance inside of @oclif/core and your own CLI or plugin. Check out the docs.
A new flag type, Flags.option, that lets you define a flag with a preset list of options. Typescript then uses the options to infer the flag's type.
Flags now have a relationship property that allows you to define more complex relationships between flags. Check out the flags docs for more information.
Flags now have a defaultHelp property that allows you to set the human readable default value in the command help. This property is useful when your flag's parse method returns a complex type, such as an object or a class. Check out the flags docs for more.
Commands now have a hiddenAliases property that allows you to define aliases that you want to hide from the user. The property is super helpful when you're trying to wean users off a deprecated command.
You can now use bun or tsx as dev runtimes (as opposed to node or ts-node).
A command's usage, args, and flags are now shown whenever a user forgets to provide a required arg or flag, or when they provided a non-existent flag.

If you need help migrating to the latest version, head over to core's README which has links to the migration guides. Feel free to open a new discussion if you need more hands-on help from us or the community.
ESM Support​
Version 3 of @oclif/core introduced full support for developing ESM plugins and CLIs. It also offered full support for interoperability between CommonJS and ESM plugins.
Put more simply, you can now migrate your CLI to ESM while keeping individual plugins in CommonJS (or vice versa). The upgrade path is now much simpler for you. You also don't need to worry about any community plugins that have migrated to ESM before you did (such as all the @oclif plugins) or are staunchly sticking with CommonJS for the foreseeable future.
Read more about this topic here.
Improving and Revitalizing oclif.io​
Another area of focus for us has been improving our documentation site, oclif.io.
While improving the quality and accuracy of the documentation was our priority, we also took the time to upgrade to the latest version of docusaurus. This new version gave our site a much-needed facelift, as well as cool new features such as dark mode and announcements.
If you have any feedback or are running into issues, we want to hear about it. Just create an issue in the oclif.io repo.
Re-engaging the oclif Community​
Lastly, our biggest priority at the moment is to re-engage the oclif community. We understand how frustrating it has been over the years to see your issues and pull requests go unacknowledged. We apologize for not prioritizing the community, and are earnestly trying to make sure that every issue and pull request gets the attention it deserves going forward.
We also opened up GitHub discussions for @oclif/core and the oclif CLI, where you can now post your questions or ideas. We hope you take advantage of them, we love hearing from you!
One last thing: we intend to publicly post our roadmap so you have more visibility into what we're working on. Stay tuned!
All our best,
The oclif teamAnnouncing oclif v2!January 12, 2022 · 5 min readHello and happy new year! It's our great pleasure to announce that we have released oclif v2, which uses the new @oclif/core library! 🎉
oclif v2 includes many changes that improve the experience of both creating and using an oclif CLI.
Going forward, we don't plan to make any updates to oclif v1 and its corresponding libraries, except for critical security fixes. See the compatibility matrix for a list of these libraries. In order to give developers time to migrate from v1 to v2, we're not completely dropping support yet. But at some point in the future we'll archive the v1 repositories and deprecate their versions on npm.
What’s changing?​
Repository Changes​
All repositories under the oclif org now use main as their primary branch and oclif-v1 as the legacy branch. The main  branch corresponds to oclif v2 and the oclif-v1 branch to oclif v1. If you find any repos that don’t have a main branch, you can safely assume that they're not used in oclif v2 and will be deprecated in the future.
Consolidating Tools & Libraries​
The oclif-dev CLI has now been incorporated into oclif. You now no longer need to install a separate package to manage your entire CLI’s lifecycle.
The following libraries have been consolidated under @oclif/core and will be deprecated at some point in the future. Read the migration guide to learn how to update your CLI or plugin to use the new core library.

@oclif/command
@oclif/config
@oclif/error
@oclif/help
@oclif/parser

No more single vs multi command CLIs​
There's only one "type" of oclif v2 CLI, but it can have as few or as many commands as a developer wants. As a result, there’s only one command to generate CLIs, oclif generate, as opposed to the old oclif single and oclif multi commands.
Node > 12​
To ensure oclif CLIs are as secure as possible, all v2 libraries and plugins support only Node 12 or higher as of now. Going forward, they'll support only Node Maintenance or higher, as defined by Node's release schedule here: https://nodejs.org/en/about/releases/.
What’s new?​
New example CLI​
oclif-hello-world is our new example repo. This is also the repo that's used as a template when running oclif generate to create a new CLI. This repo will always be able to be referenced as an example of what an oclif v2 CLI should look like.
Spaced commands​
oclif CLIs can now use spaces, instead of colons, to separate topics and subcommands. To enable this feature, simply add “topicSeparator": " " to the oclif config in your package.json. See an example in our example repo.
// Old commands that use :$ mycli do:something
// New spaced commands$ mycli do something

Note: Spaced commands are backwards compatible. So if you enable spaced commands for your CLI, users will still be able to use : as a separator. This ensures that any existing scripts don't break.

New Help Output​
We’ve revamped the way command help is outputted to the terminal, making it both easier to implement and easier to read. See the difference between the old help output on the left and the new help output on the right in the screenshots below.
oclif v1oclif v2
Notice that there are new sections for flags and global flags, examples are displayed with better spacing, and there is a section at the bottom called Configuration Variables. This Configuration Variables section is not part of the new help by default. But we've added support for custom help sections, which is what the sf CLI uses to create the new section.
Async Command Parsing​
We’ve also improved the performance of new CLIs by rewriting how commands are parsed on initialization. The new parser is asynchronous, which makes CLIs with a lot of commands or installed  plugins much faster.
What’s coming next?​
Part of our charter for the release of oclif v2 includes improving our engagement with the oclif community. We know that over the past couple of years we’ve reduced our involvement, and a lot of issues and PRs have languished in limbo. Hopefully you’ve already seen increased activity and responses from oclif maintainers recently, but if you haven’t, please don’t hesitate to ping us by tagging @admins in oclif repos.
We also want to start interviewing members of the oclif community to acquire feedback and prioritize the features and fixes you deem most important!
Best,
The oclif team

Reference material​
Migration Guide​
This guide explains how to upgrade a CLI or plugin from the old oclif v1 libraries to the new @oclif/core library that oclif v2 uses.
https://github.com/oclif/core/blob/main/MIGRATION.md
Compatibility Matrix​
The following matrix shows how the v1 libraries and plugins relate to the new v2 ones. Use this matrix as a guide to know what to drop and which versions to switch when upgrading your plugins and CLIs to v2.
oclif "v1"oclif "v2"Utility CLIsoclif@<2@oclif/dev-cli@<2oclif@>=2Main packages@oclif/command@oclif/config@oclif/errors@oclif/parser@oclif/plugin-help@oclif/core@>=1Node LTSNode v8-14Node v12+ (at time of writing)TypeScripttypescript@<4typescript@>=4Main plugins@oclif/plugin-autocomplete@<1@oclif/plugin-commands@<2@oclif/plugin-help@<4@oclif/plugin-not-found@<2@oclif/plugin-plugins@<2@oclif/plugin-update@<2plugin-warn-if-update-available@<2plugin-which@<2@oclif/plugin-autocomplete@>=1@oclif/plugin-commands@>=2@oclif/plugin-help@>=4@oclif/plugin-not-found@>=2@oclif/plugin-plugins@>=2@oclif/plugin-update@>=2@oclif/plugin-warn-if-update-available@>=2@oclif/plugin-which@>=2Introducing @oclif/coreMarch 1, 2021 · 3 min readGreetings!
We hope this blog post finds you well.
Introducing...​
We are excited to announce the next iteration of the oclif project today: @oclif/core.
We have learned a lot in the last three years of developing oclif, developing on oclif and supporting millions of command runs a day via Heroku and Salesforce CLIs.
@oclif/core ("Core") simplifies the oclif development experience and introduces highly requested new features.
Core combines the essential oclif packages into one "core" package, aptly named @oclif/core.
Core also introduces:

A default command option
Colon or space command syntax
Async command parsing
Command piping to arguments

With the introduction of default command functionality, Core simplifies the oclif project and removes the notion of single or multi command CLIs. Core CLIs can have 1 or many commands.
Along with Core, we moved the oclif-dev CLI into the oclif CLI creating a single "utility" CLI. This CLI also introduces a new AWS S3 compatible publishing scheme.
What to expect in the near future​
Core is in pre-release beta and being actively developed for new internal Salesforce CLIs.
Much documentation needs to be written in the coming months including migration paths. Migration onto Core should be as painless as possible with many exports remaining entirely unchanged. Look for forthcoming blog posts and documentation on oclif.io.
Early this summer, tentively June 1, we will release Core v1. Core's release will coincide with major bumps to many other oclif plugin packages. See the compatibility matrix below.
At Core's v1 release, the current "main" oclif packages (namely: command, config, errors & parser) will go into maintenance mode until Jan 2022. They will receive only bug and security fixes and they remain compatible with current versions of the oclif and oclif-dev CLIs. Afterwhich, they will be archived.
Companioning Core, the next major release of the oclif CLI (literally oclif@2) will generate Core CLIs.
Going forward​
We are excited to release Core! We invite you to poke around the Core repo. It may appear to be a big change but Core keeps what you already enjoy about oclif while reducing development complexity, project dependencies, package coupling and bundle size and introduces many requested features previously too prickly to weave into the current oclif architecture.
Best,
The oclif team
Reference: Compatibility matrix​
oclif "v1"oclif "Core"Utility CLIsoclif@<2@oclif/dev-cli@<2oclif@>=2Main packages@oclif/core@<2@oclif/config@<2@oclif/errors@<2@oclif/parser@<4@oclif/plugin-help@<4@oclif/core@>=1Node LTSNode v8-14Node v12+TypeScripttypescript@<4typescript@>=4Main plugins@oclif/plugin-autocomplete@<1@oclif/plugin-commands@<2@oclif/plugin-help@<4@oclif/plugin-not-found@<2@oclif/plugin-plugins@<2@oclif/plugin-update@<2plugin-warn-if-update-available@<2plugin-which@<2@oclif/plugin-autocomplete@>=2@oclif/plugin-commands@>=2@oclif/plugin-help@>=4@oclif/plugin-not-found@>=2@oclif/plugin-plugins@>=2@oclif/plugin-update@>=2@oclif/plugin-warn-if-update-available@>=2@oclif/plugin-which@>=2oclif Summer 2020 UpdateAugust 26, 2020 · 2 min readHello oclif developers! We hope you are all doing well.
Earlier this year, we started our planning for oclifconf v2 and, like all conference, had to change course. We opted not to hold a virtual conference, however, we wanted to take some time to highlight a few oclif features shipped this year.
Feature: Help templating​
One of the most requested features, help templating enables oclif developers to customize the help output for their CLI.
Read the announcement.
Feature: Custom error delegation​
This feature both improved how oclif throws and handles errors and allows oclif developers to overwrite or interject in oclif’s error handling.
Read the announcement.
Feature: postrun hooks​
We have added a new lifecycle event postrun. Your CLI can now run a hook after a command has ran.
See our hook documentation.
Feature: Root index command​
Previously, oclif would display CLI help if only the binary name with no command ID was invoked, oclif now supports a "root index" command. If present, a command defined at src/commands/index.ts will be run if no command ID is found.
1 million weekly downloads​
While exact oclif usage metrics are hard to pin down, we use npm download statistics of oclif packages as a rough approximation. Earlier this year, oclif's command package hit 1 million weekly downloads for the first time!
This year has been presented its challenges on everyone. We want to thank you, oclif developers, whom have taken the time to use and improve the oclif project. We look forward to seeing you all - in person - in the future!
All our best,
The oclif teamPretty Printable ErrorsJuly 1, 2020 · One min readOften CLIs are used as handy tools and when things go wrong it’s useful to have additional context. In oclif we have added a couple of additional properties that can show extra context to the users when an error is displayed. The code, ref and suggestions will now be displayed if they are included. This will work with an existing oclif CLI by adding the latest @oclif/errors and @oclif/core to the CLI's package.json dependencies.
For example, using this.error with the additional properties:
class TestError extends Command {  async run() {    this.error("An error has occurred!", {      code: "OCLIF_ERR",      ref: "https://oclif.io/docs/commands#thiserrormessage-string--error-options-code-string-exit-number",      suggestions: ["Use these extra properties to provide additional context"],    })  }}
would result with the following output:
›   Error: An error has occurred!›   Code: OCLIF_ERR›   Try this: Use these extra properties to provide additional context›   Reference: https://oclif.io/docs/commands#thiserrormessage-string--error-options-code-string-exit-number
If these properties are not provided then nothing changes and the CLI will continue to display the single error message output as it did before. Additionally, as part of this exercise we’ve added documentation around Error Handling in oclif which should come in handy if the need arises to extend oclif’s default handling of errors.Customizing Help in oclifMay 5, 2020 · 2 min readOut of the box oclif provides a great help experience for CLIs.
But what if, as an oclif developer, you want to customize some or all of the output?
You can now customize your CLI's help output by implementing the HelpBase abstract class.
Getting started with custom help​
If you have not done so yet, update @oclif/core.
$ yarn add --latest @oclif/core
To get started, first define the filepath to your help class in oclif's config in package.json. This is a relative path to the help class, without a file extension.
For this example, the help class will be created in a file at "[project root]/src/help.ts".
{  // ...  "oclif": {    "helpClass": "./lib/help"    // ...  }  // ...}
From here there are two paths, implement the HelpBase abstract class yourself or overwrite the parts of the default Help class you want to customize (ex: how command usage is displayed). We recommend the latter approach but cover both in the new Help Classes docs.
Separating TOPICS & COMMANDS in the new default Help class​
Previously, topics and child commands were listed in help output under a single list heading called "COMMANDS". But we found this can be slightly confusing. Some topics are commands also (a.k.a. topic-commands) while others are simply organizational namespacing (and when ran just show their help).
The new default Help class splits the list of children into distinct lists of "TOPICS" and "COMMANDS", with the possibility of an item appearing in both if it a topic-command. This makes it clearer what is expected to be ran - "COMMANDS" - and what is providing structure - "TOPICS" - when looking at the help output.
VERSION  plugin-help-example/0.0.0 darwin-x64 node-v12.12.0USAGE  $ plugin-help-example [COMMAND]TOPICS  topic  this is a topic and has child topics or commandsCOMMANDS  hello  describe the command here  help   display help for plugin-help-example
We look forward to seeing what custom help features you implement in your oclif CLIs with this new feature!oclif TSLint to ESLint MigrationDecember 5, 2019 · 3 min readBack in February of this year, plans were announced to deprecate TSLint in favor of ESLint. TSLint's goal has become to work toward a “unified developer experience” by supporting ESLint development going forward.
What has changed in oclif​
To keep inline with the community, oclif has transitioned to ESLint for all our core libraries as well as all our official plugins.
Starting in v1.15.x, oclif will now optionally generate projects with ESLint for both TypeScript and JavaScript CLI’s.
ESLint does require Node to be on stable LTS version, at the time of writing, Node 8.10.x, Node 10.13.x & Node 12.x.x.
How does this affect you​
Existing CLI’s are unchanged, but any newly generated CLI's will only give the option of using ESLint. If you are running tslint in your CLI, we recommend you switch to ESLint as well.
In migrating our projects we took the following steps (for an example of these changes see this pull request).


Install eslint
$ yarn add eslint eslint-config-oclif eslint-config-oclif-typescript --dev


Add eslint related files


$ echo '{  "extends": [    "oclif",    "oclif-typescript"  ],  "rules": {  }}' > .eslintrc


Remove tslint and related packages
$ yarn remove @oclif/tslint tslint


Remove tslint related configuration files
$ rm tslint.json


Change lint script in our package.json from something like:
"lint": "tsc -p test --noEmit && tslint -p test -t stylish"
to
"lint": "eslint . --ext .ts --config .eslintrc"


To preserve the test compile (tsc -p test --noEmit) we also made the following updates to our scripts:
"pretest": "tsc -p test --noEmit"
In some cases we had our posttest duplicating the same steps as our lint script so it’s cleaner to have it reference the lint job directly with:
"posttest": "yarn lint"

Run yarn lint --fix. This attempts to auto-fix any linting violations automatically. In the case an auto-fix isn’t available it should be fixed manually or ignored (see the eslint configuration doc for more information)
Do a search in the codebase for tslint and remove any unnecessary tslint disabling comments, like:

/* tslint:disable:object-literal-sort-keys */
If you are on a version of Node that is not supported by ESLint, you will also need to update your Node engine. ESLint supports Node 8, 10, and 12 so you should upgrade to the most recent Node version compatible with your CLI and also supported by ESLint (see ESLint's Installation and Usage instructions).
When will this take effect​
These changes have taken effect in oclif v1.15.1. When you generate a new CLI or plugin it will now contain configuration for ESLint instead of TSLint.oclif's Current Node SupportOctober 31, 2019 · 3 min readTo maintain a healthy project trajectory, oclif follows and supports Node Active LTS release, currently Node 10 & Node 12. This means ensuring that oclif continues to play nice with coming Active LTS Node versions and other packages in the ecosystem. Moving forward also means leaving older versions behind. Starting in 2020, Node will stop maintaining Node 8 and it is our intent at that time to also follow suit. Let’s take a look at a few ways we will be supporting these changes.
CI Environments​
CLIs created with the oclif cli going forward will be generated with a CircleCI configuration with Node 10 & 12 and an Appveyor configuration using Node 10. We have also added Node latest to CircleCi to be an early warning detection against coming Node changes (Node latest is managed by CircleCI).
We have already updated every oclif repo's CI configs to reflect this.
If your existing CLI uses either Appveyor or CircleCI you can update your config files also, like so:
.circleci/config.yml​
Your CircleCI config should contain a node-latest job, aliased as test. From this, there should be two extensions of this job for the Active LTS Node versions, Node 10 and Node 12.
  node-10:    <<: *node-latest    docker:      - image: node:10  node-12:    <<: *node-latest    docker:      - image: node:12
Notice that these declarations only change the Docker Node images used to run that job.
Additionally, the jobs listed within workflows must also be updated to reflect our changes in configuration:
    jobs:      - node-latest      - node-10      - node-12
appveyor.yml​
For appveyor we are currently only testing the oldest Active LTS Node version, Node 10. Update the nodejs_version proppert in your appveyor.yml file to reflect this.
environment:  nodejs_version: "10"
Deprecating Node 8 & Updating packge.json engines​
In Jan 2020, Node will end its Node 8 maintenance. We will follow suit by setting the package.json engine property in oclif packages to >=10 and bumping the package's major versions.
Depending on how you ship your CLI you may wish to also bump the engines version in your CLI's package.json. You can read more about the implications of the engines property configuration in the npm documentation.
Also consider distributing your CLI with its own Node version.
Packaged Node Version​
When using dev-cli to pack your CLI it will use the Node version as specified in your package.json under the oclif.update.node.version property. This value should reflect an Active LTS Node version (dev-cli does not currently enforce versions).
Supporting the future​
As a community we may discover bumps along the way as we upgrade. If you notice something related to oclif please feel free to open an issue or submit a pull request under the relevant oclif package within the org.
We look forward to using the latest from Node and the community and keeping oclif healthy along the way.oclifconf 2019: A RecapSeptember 16, 2019 · 4 min readIn May, Heroku and Salesforce Open Source organized oclifconf, a conference for developers & product managers building CLI tools on top of the open source oclif framework. The speakers came from various tech companies, such as Adobe, Netlify, and Apollo, who have already built amazing CLI experiences. The topics covered everything from the incredible capabilities oclif has unlocked, to the community-built plugins extending its functionality, and even what the behavior of an adaptive CLI tool might look like.
Below is a listing of all of the talks from the event, along with a short summary. Enjoy!
The future of oclif by Jeff Dickey​

In its relatively short lifetime, oclif has already inspired many developers and companies to adopt its framework as a means for implementing their own command-line tooling. In this talk, Jeff Dickey, an oclif founding team member, recaps the project's history and inspiration. He also looks towards the future and outlines some features and improvements that the tool could adapt. This isn't so much a definitive roadmap of where oclif is headed, but rather, a call to inspiration for developers eager to contribute! And if you are interested in contributing, check out the open issues in the oclif GitHub repo and come say "Hello!" on Spectrum Chat.
Open Source Citizenship by Josh Simmons​

When it comes to open source, it's more than just individuals now. More and more frequently, large corporations are contributing to projects by donating to contributors, sponsoring events, or upstreaming contributions. But keeping open source projects and communities healthy requires more than just money and brainpower. Josh Simmons surveyed multiple open source communities and relays his findings as to what help maintainers and contributors actually need in this talk.
Building an enterprise-grade CLI with oclif by Thomas Dvornik​

Security and performance are all about trust. While oclif is an extremely extensible framework for building CLI tooling, there are additional requirements to fulfill for enterprise businesses to adopt it that might not be necessary for individual developers. Thomas Dvornik outlines what he and his colleagues at Salesforce have implemented as plugins to oclif to satisfy these needs, including encrypted OAuth, plugin signing, lazy loading dependencies, synchronizing weekly releases and deprecations across dozens of repositories, and establishing cross-team coding and documentation standards.
How Adobe I/O built an extensible CLI with oclif by Jesse MacFadyen​

Perhaps oclif's most appealing feature is its support for plugins. In Cordova's case, they've created a sophisticated telemetry system that helps Adobe developers see which commands users are using--and reports on which ones are erroring out. By embedding a feedback system into the tool, users are even able to quickly send their suggestions to a form, without ever leaving the terminal. Jesse MacFadyen demonstrates how oclif's plugin system can work beyond simply executing commands.
Integrating oclif with GraphQL and Apollo by Evans Hauser​

For Evans Hauser and the team at Apollo, oclif is best thought of as "React for the CLI." As a client paired with a strongly-typed API contract to a server, it can deliver structured and consistent commands to retrieve external data. What better mechanism to use for this transfer than GraphQL, a framework which empowers the client to ask precisely for the data it needs, and nothing more?
Adaptive Intent-based CLI State Machines by Shawn Wang​

In designing oclif, Jeff Dickey wrote out 12 CLI factors to keep in mind. In this talk, Shawn Wang outlines a 13th: state. State is hard, because it depends on context, and context depends on understanding what a user intends to do, not what they are asking. Shawn is working towards enabling oclif to better understand the commands a user has entered, so that it can predict and interpret future commands that might be entered next. This would enable CLI tools to not just interpret a users' commands, but to also interpret their intent.\n\nIntroducing `oclif init` commandApril 10, 2024 · 2 min readThanks to the contribution of @joshcanhelp we released a new command for the oclif CLI called oclif init in version 4.8.0
The oclif init command allows you to initialize oclif in an existing project directory by adding the bare minimum requirements: a few pieces of configuration, bin scripts, and a couple of dependencies (@oclif/core and ts-node). This is slightly different from oclif generate, which will create an entirely new oclif project based on our templates.
oclif init will add the following:

bin scripts: bin/run.js, bin/run.cmd, bin/dev.js, and bin/dev.cmd
oclif section to package.json with bin, dirname, commands, and topicSeparator set (See Configuring Your CLI for more)
@oclif/core to dependencies in your package.json (if it's not already there)
ts-node to devDependencies in your package.json (if it's not already there)

Once you've initialized oclif, you can use the bin scripts to execute your CLI. You can also use the other oclif commands like oclif generate command and oclif generate hook to start adding new functionality.

❯ oclif init --helpInitialize a new oclif CLIUSAGE  $ oclif init [--bin <value>] [--module-type ESM|CommonJS] [--package-manager npm|yarn|pnpm] [--topic-separator    colons|spaces] [-d <value>] [-y]FLAGS  -d, --output-dir=<value>        Directory to initialize the CLI in.  -y, --yes                       Use defaults for all prompts. Individual flags will override defaults.      --bin=<value>               Supply answer for prompt: Command bin name the CLI will export      --module-type=<option>      Supply answer for prompt: Select a module type                                  <options: ESM|CommonJS>      --package-manager=<option>  Supply answer for prompt: Select a package manager                                  <options: npm|yarn|pnpm>      --topic-separator=<option>  Supply answer for prompt: Select a topic separator                                  <options: colons|spaces>DESCRIPTION  Initialize a new oclif CLI  This will add the necessary oclif bin files, add oclif config to package.json, and install @oclif/core and ts-node.EXAMPLES  Initialize a new CLI in the current directory    $ oclif init  Initialize a new CLI in a different directory    $ oclif init --output-dir "/path/to/existing/project"  Supply answers for specific prompts    $ oclif init --topic-separator colons --bin mycli
Hope you enjoy the new command! If you come across any issues or have any new ideas for this command, head over to the oclif/oclif repo and open a new issue.
All our best,
The oclif teamoclif Spring 2024 UpdateMarch 29, 2024 · 4 min readHello oclif developers! It's been a while since we last uploaded a blog - and a lot has happened.
We've been focusing on these high-level areas over the past couple of years:

Improving @oclif/core
ESM Support
Improving and revitalizing oclif.io
Re-engaging the oclif community

Improving @oclif/core​
Since we announced @oclif/core over three years ago, we've released two new major versions, each packed with lots of features that we're really excited about.
Here are some of these changes:

Full support for ESM and interoperability with CommonJS (more on this topic below).
Configurable command discovery strategies that give you more control over how commands are loaded at runtime. Check out the docs.
A new preparse hook that allows you to manipulate the provided arguments before they're parsed. Salesforce used this hook to implement a neat --flags-dir feature that translates local files into flags.
A new Performance class that you can use to track performance inside of @oclif/core and your own CLI or plugin. Check out the docs.
A new flag type, Flags.option, that lets you define a flag with a preset list of options. Typescript then uses the options to infer the flag's type.
Flags now have a relationship property that allows you to define more complex relationships between flags. Check out the flags docs for more information.
Flags now have a defaultHelp property that allows you to set the human readable default value in the command help. This property is useful when your flag's parse method returns a complex type, such as an object or a class. Check out the flags docs for more.
Commands now have a hiddenAliases property that allows you to define aliases that you want to hide from the user. The property is super helpful when you're trying to wean users off a deprecated command.
You can now use bun or tsx as dev runtimes (as opposed to node or ts-node).
A command's usage, args, and flags are now shown whenever a user forgets to provide a required arg or flag, or when they provided a non-existent flag.

If you need help migrating to the latest version, head over to core's README which has links to the migration guides. Feel free to open a new discussion if you need more hands-on help from us or the community.
ESM Support​
Version 3 of @oclif/core introduced full support for developing ESM plugins and CLIs. It also offered full support for interoperability between CommonJS and ESM plugins.
Put more simply, you can now migrate your CLI to ESM while keeping individual plugins in CommonJS (or vice versa). The upgrade path is now much simpler for you. You also don't need to worry about any community plugins that have migrated to ESM before you did (such as all the @oclif plugins) or are staunchly sticking with CommonJS for the foreseeable future.
Read more about this topic here.
Improving and Revitalizing oclif.io​
Another area of focus for us has been improving our documentation site, oclif.io.
While improving the quality and accuracy of the documentation was our priority, we also took the time to upgrade to the latest version of docusaurus. This new version gave our site a much-needed facelift, as well as cool new features such as dark mode and announcements.
If you have any feedback or are running into issues, we want to hear about it. Just create an issue in the oclif.io repo.
Re-engaging the oclif Community​
Lastly, our biggest priority at the moment is to re-engage the oclif community. We understand how frustrating it has been over the years to see your issues and pull requests go unacknowledged. We apologize for not prioritizing the community, and are earnestly trying to make sure that every issue and pull request gets the attention it deserves going forward.
We also opened up GitHub discussions for @oclif/core and the oclif CLI, where you can now post your questions or ideas. We hope you take advantage of them, we love hearing from you!
One last thing: we intend to publicly post our roadmap so you have more visibility into what we're working on. Stay tuned!
All our best,
The oclif teamAnnouncing oclif v2!January 12, 2022 · 5 min readHello and happy new year! It's our great pleasure to announce that we have released oclif v2, which uses the new @oclif/core library! 🎉
oclif v2 includes many changes that improve the experience of both creating and using an oclif CLI.
Going forward, we don't plan to make any updates to oclif v1 and its corresponding libraries, except for critical security fixes. See the compatibility matrix for a list of these libraries. In order to give developers time to migrate from v1 to v2, we're not completely dropping support yet. But at some point in the future we'll archive the v1 repositories and deprecate their versions on npm.
What’s changing?​
Repository Changes​
All repositories under the oclif org now use main as their primary branch and oclif-v1 as the legacy branch. The main  branch corresponds to oclif v2 and the oclif-v1 branch to oclif v1. If you find any repos that don’t have a main branch, you can safely assume that they're not used in oclif v2 and will be deprecated in the future.
Consolidating Tools & Libraries​
The oclif-dev CLI has now been incorporated into oclif. You now no longer need to install a separate package to manage your entire CLI’s lifecycle.
The following libraries have been consolidated under @oclif/core and will be deprecated at some point in the future. Read the migration guide to learn how to update your CLI or plugin to use the new core library.

@oclif/command
@oclif/config
@oclif/error
@oclif/help
@oclif/parser

No more single vs multi command CLIs​
There's only one "type" of oclif v2 CLI, but it can have as few or as many commands as a developer wants. As a result, there’s only one command to generate CLIs, oclif generate, as opposed to the old oclif single and oclif multi commands.
Node > 12​
To ensure oclif CLIs are as secure as possible, all v2 libraries and plugins support only Node 12 or higher as of now. Going forward, they'll support only Node Maintenance or higher, as defined by Node's release schedule here: https://nodejs.org/en/about/releases/.
What’s new?​
New example CLI​
oclif-hello-world is our new example repo. This is also the repo that's used as a template when running oclif generate to create a new CLI. This repo will always be able to be referenced as an example of what an oclif v2 CLI should look like.
Spaced commands​
oclif CLIs can now use spaces, instead of colons, to separate topics and subcommands. To enable this feature, simply add “topicSeparator": " " to the oclif config in your package.json. See an example in our example repo.
// Old commands that use :$ mycli do:something
// New spaced commands$ mycli do something

Note: Spaced commands are backwards compatible. So if you enable spaced commands for your CLI, users will still be able to use : as a separator. This ensures that any existing scripts don't break.

New Help Output​
We’ve revamped the way command help is outputted to the terminal, making it both easier to implement and easier to read. See the difference between the old help output on the left and the new help output on the right in the screenshots below.
oclif v1oclif v2
Notice that there are new sections for flags and global flags, examples are displayed with better spacing, and there is a section at the bottom called Configuration Variables. This Configuration Variables section is not part of the new help by default. But we've added support for custom help sections, which is what the sf CLI uses to create the new section.
Async Command Parsing​
We’ve also improved the performance of new CLIs by rewriting how commands are parsed on initialization. The new parser is asynchronous, which makes CLIs with a lot of commands or installed  plugins much faster.
What’s coming next?​
Part of our charter for the release of oclif v2 includes improving our engagement with the oclif community. We know that over the past couple of years we’ve reduced our involvement, and a lot of issues and PRs have languished in limbo. Hopefully you’ve already seen increased activity and responses from oclif maintainers recently, but if you haven’t, please don’t hesitate to ping us by tagging @admins in oclif repos.
We also want to start interviewing members of the oclif community to acquire feedback and prioritize the features and fixes you deem most important!
Best,
The oclif team

Reference material​
Migration Guide​
This guide explains how to upgrade a CLI or plugin from the old oclif v1 libraries to the new @oclif/core library that oclif v2 uses.
https://github.com/oclif/core/blob/main/MIGRATION.md
Compatibility Matrix​
The following matrix shows how the v1 libraries and plugins relate to the new v2 ones. Use this matrix as a guide to know what to drop and which versions to switch when upgrading your plugins and CLIs to v2.
oclif "v1"oclif "v2"Utility CLIsoclif@<2@oclif/dev-cli@<2oclif@>=2Main packages@oclif/command@oclif/config@oclif/errors@oclif/parser@oclif/plugin-help@oclif/core@>=1Node LTSNode v8-14Node v12+ (at time of writing)TypeScripttypescript@<4typescript@>=4Main plugins@oclif/plugin-autocomplete@<1@oclif/plugin-commands@<2@oclif/plugin-help@<4@oclif/plugin-not-found@<2@oclif/plugin-plugins@<2@oclif/plugin-update@<2plugin-warn-if-update-available@<2plugin-which@<2@oclif/plugin-autocomplete@>=1@oclif/plugin-commands@>=2@oclif/plugin-help@>=4@oclif/plugin-not-found@>=2@oclif/plugin-plugins@>=2@oclif/plugin-update@>=2@oclif/plugin-warn-if-update-available@>=2@oclif/plugin-which@>=2Introducing @oclif/coreMarch 1, 2021 · 3 min readGreetings!
We hope this blog post finds you well.
Introducing...​
We are excited to announce the next iteration of the oclif project today: @oclif/core.
We have learned a lot in the last three years of developing oclif, developing on oclif and supporting millions of command runs a day via Heroku and Salesforce CLIs.
@oclif/core ("Core") simplifies the oclif development experience and introduces highly requested new features.
Core combines the essential oclif packages into one "core" package, aptly named @oclif/core.
Core also introduces:

A default command option
Colon or space command syntax
Async command parsing
Command piping to arguments

With the introduction of default command functionality, Core simplifies the oclif project and removes the notion of single or multi command CLIs. Core CLIs can have 1 or many commands.
Along with Core, we moved the oclif-dev CLI into the oclif CLI creating a single "utility" CLI. This CLI also introduces a new AWS S3 compatible publishing scheme.
What to expect in the near future​
Core is in pre-release beta and being actively developed for new internal Salesforce CLIs.
Much documentation needs to be written in the coming months including migration paths. Migration onto Core should be as painless as possible with many exports remaining entirely unchanged. Look for forthcoming blog posts and documentation on oclif.io.
Early this summer, tentively June 1, we will release Core v1. Core's release will coincide with major bumps to many other oclif plugin packages. See the compatibility matrix below.
At Core's v1 release, the current "main" oclif packages (namely: command, config, errors & parser) will go into maintenance mode until Jan 2022. They will receive only bug and security fixes and they remain compatible with current versions of the oclif and oclif-dev CLIs. Afterwhich, they will be archived.
Companioning Core, the next major release of the oclif CLI (literally oclif@2) will generate Core CLIs.
Going forward​
We are excited to release Core! We invite you to poke around the Core repo. It may appear to be a big change but Core keeps what you already enjoy about oclif while reducing development complexity, project dependencies, package coupling and bundle size and introduces many requested features previously too prickly to weave into the current oclif architecture.
Best,
The oclif team
Reference: Compatibility matrix​
oclif "v1"oclif "Core"Utility CLIsoclif@<2@oclif/dev-cli@<2oclif@>=2Main packages@oclif/core@<2@oclif/config@<2@oclif/errors@<2@oclif/parser@<4@oclif/plugin-help@<4@oclif/core@>=1Node LTSNode v8-14Node v12+TypeScripttypescript@<4typescript@>=4Main plugins@oclif/plugin-autocomplete@<1@oclif/plugin-commands@<2@oclif/plugin-help@<4@oclif/plugin-not-found@<2@oclif/plugin-plugins@<2@oclif/plugin-update@<2plugin-warn-if-update-available@<2plugin-which@<2@oclif/plugin-autocomplete@>=2@oclif/plugin-commands@>=2@oclif/plugin-help@>=4@oclif/plugin-not-found@>=2@oclif/plugin-plugins@>=2@oclif/plugin-update@>=2@oclif/plugin-warn-if-update-available@>=2@oclif/plugin-which@>=2oclif Summer 2020 UpdateAugust 26, 2020 · 2 min readHello oclif developers! We hope you are all doing well.
Earlier this year, we started our planning for oclifconf v2 and, like all conference, had to change course. We opted not to hold a virtual conference, however, we wanted to take some time to highlight a few oclif features shipped this year.
Feature: Help templating​
One of the most requested features, help templating enables oclif developers to customize the help output for their CLI.
Read the announcement.
Feature: Custom error delegation​
This feature both improved how oclif throws and handles errors and allows oclif developers to overwrite or interject in oclif’s error handling.
Read the announcement.
Feature: postrun hooks​
We have added a new lifecycle event postrun. Your CLI can now run a hook after a command has ran.
See our hook documentation.
Feature: Root index command​
Previously, oclif would display CLI help if only the binary name with no command ID was invoked, oclif now supports a "root index" command. If present, a command defined at src/commands/index.ts will be run if no command ID is found.
1 million weekly downloads​
While exact oclif usage metrics are hard to pin down, we use npm download statistics of oclif packages as a rough approximation. Earlier this year, oclif's command package hit 1 million weekly downloads for the first time!
This year has been presented its challenges on everyone. We want to thank you, oclif developers, whom have taken the time to use and improve the oclif project. We look forward to seeing you all - in person - in the future!
All our best,
The oclif teamPretty Printable ErrorsJuly 1, 2020 · One min readOften CLIs are used as handy tools and when things go wrong it’s useful to have additional context. In oclif we have added a couple of additional properties that can show extra context to the users when an error is displayed. The code, ref and suggestions will now be displayed if they are included. This will work with an existing oclif CLI by adding the latest @oclif/errors and @oclif/core to the CLI's package.json dependencies.
For example, using this.error with the additional properties:
class TestError extends Command {  async run() {    this.error("An error has occurred!", {      code: "OCLIF_ERR",      ref: "https://oclif.io/docs/commands#thiserrormessage-string--error-options-code-string-exit-number",      suggestions: ["Use these extra properties to provide additional context"],    })  }}
would result with the following output:
›   Error: An error has occurred!›   Code: OCLIF_ERR›   Try this: Use these extra properties to provide additional context›   Reference: https://oclif.io/docs/commands#thiserrormessage-string--error-options-code-string-exit-number
If these properties are not provided then nothing changes and the CLI will continue to display the single error message output as it did before. Additionally, as part of this exercise we’ve added documentation around Error Handling in oclif which should come in handy if the need arises to extend oclif’s default handling of errors.Customizing Help in oclifMay 5, 2020 · 2 min readOut of the box oclif provides a great help experience for CLIs.
But what if, as an oclif developer, you want to customize some or all of the output?
You can now customize your CLI's help output by implementing the HelpBase abstract class.
Getting started with custom help​
If you have not done so yet, update @oclif/core.
$ yarn add --latest @oclif/core
To get started, first define the filepath to your help class in oclif's config in package.json. This is a relative path to the help class, without a file extension.
For this example, the help class will be created in a file at "[project root]/src/help.ts".
{  // ...  "oclif": {    "helpClass": "./lib/help"    // ...  }  // ...}
From here there are two paths, implement the HelpBase abstract class yourself or overwrite the parts of the default Help class you want to customize (ex: how command usage is displayed). We recommend the latter approach but cover both in the new Help Classes docs.
Separating TOPICS & COMMANDS in the new default Help class​
Previously, topics and child commands were listed in help output under a single list heading called "COMMANDS". But we found this can be slightly confusing. Some topics are commands also (a.k.a. topic-commands) while others are simply organizational namespacing (and when ran just show their help).
The new default Help class splits the list of children into distinct lists of "TOPICS" and "COMMANDS", with the possibility of an item appearing in both if it a topic-command. This makes it clearer what is expected to be ran - "COMMANDS" - and what is providing structure - "TOPICS" - when looking at the help output.
VERSION  plugin-help-example/0.0.0 darwin-x64 node-v12.12.0USAGE  $ plugin-help-example [COMMAND]TOPICS  topic  this is a topic and has child topics or commandsCOMMANDS  hello  describe the command here  help   display help for plugin-help-example
We look forward to seeing what custom help features you implement in your oclif CLIs with this new feature!oclif TSLint to ESLint MigrationDecember 5, 2019 · 3 min readBack in February of this year, plans were announced to deprecate TSLint in favor of ESLint. TSLint's goal has become to work toward a “unified developer experience” by supporting ESLint development going forward.
What has changed in oclif​
To keep inline with the community, oclif has transitioned to ESLint for all our core libraries as well as all our official plugins.
Starting in v1.15.x, oclif will now optionally generate projects with ESLint for both TypeScript and JavaScript CLI’s.
ESLint does require Node to be on stable LTS version, at the time of writing, Node 8.10.x, Node 10.13.x & Node 12.x.x.
How does this affect you​
Existing CLI’s are unchanged, but any newly generated CLI's will only give the option of using ESLint. If you are running tslint in your CLI, we recommend you switch to ESLint as well.
In migrating our projects we took the following steps (for an example of these changes see this pull request).


Install eslint
$ yarn add eslint eslint-config-oclif eslint-config-oclif-typescript --dev


Add eslint related files


$ echo '{  "extends": [    "oclif",    "oclif-typescript"  ],  "rules": {  }}' > .eslintrc


Remove tslint and related packages
$ yarn remove @oclif/tslint tslint


Remove tslint related configuration files
$ rm tslint.json


Change lint script in our package.json from something like:
"lint": "tsc -p test --noEmit && tslint -p test -t stylish"
to
"lint": "eslint . --ext .ts --config .eslintrc"


To preserve the test compile (tsc -p test --noEmit) we also made the following updates to our scripts:
"pretest": "tsc -p test --noEmit"
In some cases we had our posttest duplicating the same steps as our lint script so it’s cleaner to have it reference the lint job directly with:
"posttest": "yarn lint"

Run yarn lint --fix. This attempts to auto-fix any linting violations automatically. In the case an auto-fix isn’t available it should be fixed manually or ignored (see the eslint configuration doc for more information)
Do a search in the codebase for tslint and remove any unnecessary tslint disabling comments, like:

/* tslint:disable:object-literal-sort-keys */
If you are on a version of Node that is not supported by ESLint, you will also need to update your Node engine. ESLint supports Node 8, 10, and 12 so you should upgrade to the most recent Node version compatible with your CLI and also supported by ESLint (see ESLint's Installation and Usage instructions).
When will this take effect​
These changes have taken effect in oclif v1.15.1. When you generate a new CLI or plugin it will now contain configuration for ESLint instead of TSLint.oclif's Current Node SupportOctober 31, 2019 · 3 min readTo maintain a healthy project trajectory, oclif follows and supports Node Active LTS release, currently Node 10 & Node 12. This means ensuring that oclif continues to play nice with coming Active LTS Node versions and other packages in the ecosystem. Moving forward also means leaving older versions behind. Starting in 2020, Node will stop maintaining Node 8 and it is our intent at that time to also follow suit. Let’s take a look at a few ways we will be supporting these changes.
CI Environments​
CLIs created with the oclif cli going forward will be generated with a CircleCI configuration with Node 10 & 12 and an Appveyor configuration using Node 10. We have also added Node latest to CircleCi to be an early warning detection against coming Node changes (Node latest is managed by CircleCI).
We have already updated every oclif repo's CI configs to reflect this.
If your existing CLI uses either Appveyor or CircleCI you can update your config files also, like so:
.circleci/config.yml​
Your CircleCI config should contain a node-latest job, aliased as test. From this, there should be two extensions of this job for the Active LTS Node versions, Node 10 and Node 12.
  node-10:    <<: *node-latest    docker:      - image: node:10  node-12:    <<: *node-latest    docker:      - image: node:12
Notice that these declarations only change the Docker Node images used to run that job.
Additionally, the jobs listed within workflows must also be updated to reflect our changes in configuration:
    jobs:      - node-latest      - node-10      - node-12
appveyor.yml​
For appveyor we are currently only testing the oldest Active LTS Node version, Node 10. Update the nodejs_version proppert in your appveyor.yml file to reflect this.
environment:  nodejs_version: "10"
Deprecating Node 8 & Updating packge.json engines​
In Jan 2020, Node will end its Node 8 maintenance. We will follow suit by setting the package.json engine property in oclif packages to >=10 and bumping the package's major versions.
Depending on how you ship your CLI you may wish to also bump the engines version in your CLI's package.json. You can read more about the implications of the engines property configuration in the npm documentation.
Also consider distributing your CLI with its own Node version.
Packaged Node Version​
When using dev-cli to pack your CLI it will use the Node version as specified in your package.json under the oclif.update.node.version property. This value should reflect an Active LTS Node version (dev-cli does not currently enforce versions).
Supporting the future​
As a community we may discover bumps along the way as we upgrade. If you notice something related to oclif please feel free to open an issue or submit a pull request under the relevant oclif package within the org.
We look forward to using the latest from Node and the community and keeping oclif healthy along the way.oclifconf 2019: A RecapSeptember 16, 2019 · 4 min readIn May, Heroku and Salesforce Open Source organized oclifconf, a conference for developers & product managers building CLI tools on top of the open source oclif framework. The speakers came from various tech companies, such as Adobe, Netlify, and Apollo, who have already built amazing CLI experiences. The topics covered everything from the incredible capabilities oclif has unlocked, to the community-built plugins extending its functionality, and even what the behavior of an adaptive CLI tool might look like.
Below is a listing of all of the talks from the event, along with a short summary. Enjoy!
The future of oclif by Jeff Dickey​

In its relatively short lifetime, oclif has already inspired many developers and companies to adopt its framework as a means for implementing their own command-line tooling. In this talk, Jeff Dickey, an oclif founding team member, recaps the project's history and inspiration. He also looks towards the future and outlines some features and improvements that the tool could adapt. This isn't so much a definitive roadmap of where oclif is headed, but rather, a call to inspiration for developers eager to contribute! And if you are interested in contributing, check out the open issues in the oclif GitHub repo and come say "Hello!" on Spectrum Chat.
Open Source Citizenship by Josh Simmons​

When it comes to open source, it's more than just individuals now. More and more frequently, large corporations are contributing to projects by donating to contributors, sponsoring events, or upstreaming contributions. But keeping open source projects and communities healthy requires more than just money and brainpower. Josh Simmons surveyed multiple open source communities and relays his findings as to what help maintainers and contributors actually need in this talk.
Building an enterprise-grade CLI with oclif by Thomas Dvornik​

Security and performance are all about trust. While oclif is an extremely extensible framework for building CLI tooling, there are additional requirements to fulfill for enterprise businesses to adopt it that might not be necessary for individual developers. Thomas Dvornik outlines what he and his colleagues at Salesforce have implemented as plugins to oclif to satisfy these needs, including encrypted OAuth, plugin signing, lazy loading dependencies, synchronizing weekly releases and deprecations across dozens of repositories, and establishing cross-team coding and documentation standards.
How Adobe I/O built an extensible CLI with oclif by Jesse MacFadyen​

Perhaps oclif's most appealing feature is its support for plugins. In Cordova's case, they've created a sophisticated telemetry system that helps Adobe developers see which commands users are using--and reports on which ones are erroring out. By embedding a feedback system into the tool, users are even able to quickly send their suggestions to a form, without ever leaving the terminal. Jesse MacFadyen demonstrates how oclif's plugin system can work beyond simply executing commands.
Integrating oclif with GraphQL and Apollo by Evans Hauser​

For Evans Hauser and the team at Apollo, oclif is best thought of as "React for the CLI." As a client paired with a strongly-typed API contract to a server, it can deliver structured and consistent commands to retrieve external data. What better mechanism to use for this transfer than GraphQL, a framework which empowers the client to ask precisely for the data it needs, and nothing more?
Adaptive Intent-based CLI State Machines by Shawn Wang​

In designing oclif, Jeff Dickey wrote out 12 CLI factors to keep in mind. In this talk, Shawn Wang outlines a 13th: state. State is hard, because it depends on context, and context depends on understanding what a user intends to do, not what they are asking. Shawn is working towards enabling oclif to better understand the commands a user has entered, so that it can predict and interpret future commands that might be entered next. This would enable CLI tools to not just interpret a users' commands, but to also interpret their intent.Older Entries\n\n\n\nIntroducing `oclif init` commandApril 10, 2024 · 2 min readThanks to the contribution of @joshcanhelp we released a new command for the oclif CLI called oclif init in version 4.8.0
The oclif init command allows you to initialize oclif in an existing project directory by adding the bare minimum requirements: a few pieces of configuration, bin scripts, and a couple of dependencies (@oclif/core and ts-node). This is slightly different from oclif generate, which will create an entirely new oclif project based on our templates.
oclif init will add the following:

bin scripts: bin/run.js, bin/run.cmd, bin/dev.js, and bin/dev.cmd
oclif section to package.json with bin, dirname, commands, and topicSeparator set (See Configuring Your CLI for more)
@oclif/core to dependencies in your package.json (if it's not already there)
ts-node to devDependencies in your package.json (if it's not already there)

Once you've initialized oclif, you can use the bin scripts to execute your CLI. You can also use the other oclif commands like oclif generate command and oclif generate hook to start adding new functionality.

❯ oclif init --helpInitialize a new oclif CLIUSAGE  $ oclif init [--bin <value>] [--module-type ESM|CommonJS] [--package-manager npm|yarn|pnpm] [--topic-separator    colons|spaces] [-d <value>] [-y]FLAGS  -d, --output-dir=<value>        Directory to initialize the CLI in.  -y, --yes                       Use defaults for all prompts. Individual flags will override defaults.      --bin=<value>               Supply answer for prompt: Command bin name the CLI will export      --module-type=<option>      Supply answer for prompt: Select a module type                                  <options: ESM|CommonJS>      --package-manager=<option>  Supply answer for prompt: Select a package manager                                  <options: npm|yarn|pnpm>      --topic-separator=<option>  Supply answer for prompt: Select a topic separator                                  <options: colons|spaces>DESCRIPTION  Initialize a new oclif CLI  This will add the necessary oclif bin files, add oclif config to package.json, and install @oclif/core and ts-node.EXAMPLES  Initialize a new CLI in the current directory    $ oclif init  Initialize a new CLI in a different directory    $ oclif init --output-dir "/path/to/existing/project"  Supply answers for specific prompts    $ oclif init --topic-separator colons --bin mycli
Hope you enjoy the new command! If you come across any issues or have any new ideas for this command, head over to the oclif/oclif repo and open a new issue.
All our best,
The oclif teamoclif Spring 2024 UpdateMarch 29, 2024 · 4 min readHello oclif developers! It's been a while since we last uploaded a blog - and a lot has happened.
We've been focusing on these high-level areas over the past couple of years:

Improving @oclif/core
ESM Support
Improving and revitalizing oclif.io
Re-engaging the oclif community

Improving @oclif/core​
Since we announced @oclif/core over three years ago, we've released two new major versions, each packed with lots of features that we're really excited about.
Here are some of these changes:

Full support for ESM and interoperability with CommonJS (more on this topic below).
Configurable command discovery strategies that give you more control over how commands are loaded at runtime. Check out the docs.
A new preparse hook that allows you to manipulate the provided arguments before they're parsed. Salesforce used this hook to implement a neat --flags-dir feature that translates local files into flags.
A new Performance class that you can use to track performance inside of @oclif/core and your own CLI or plugin. Check out the docs.
A new flag type, Flags.option, that lets you define a flag with a preset list of options. Typescript then uses the options to infer the flag's type.
Flags now have a relationship property that allows you to define more complex relationships between flags. Check out the flags docs for more information.
Flags now have a defaultHelp property that allows you to set the human readable default value in the command help. This property is useful when your flag's parse method returns a complex type, such as an object or a class. Check out the flags docs for more.
Commands now have a hiddenAliases property that allows you to define aliases that you want to hide from the user. The property is super helpful when you're trying to wean users off a deprecated command.
You can now use bun or tsx as dev runtimes (as opposed to node or ts-node).
A command's usage, args, and flags are now shown whenever a user forgets to provide a required arg or flag, or when they provided a non-existent flag.

If you need help migrating to the latest version, head over to core's README which has links to the migration guides. Feel free to open a new discussion if you need more hands-on help from us or the community.
ESM Support​
Version 3 of @oclif/core introduced full support for developing ESM plugins and CLIs. It also offered full support for interoperability between CommonJS and ESM plugins.
Put more simply, you can now migrate your CLI to ESM while keeping individual plugins in CommonJS (or vice versa). The upgrade path is now much simpler for you. You also don't need to worry about any community plugins that have migrated to ESM before you did (such as all the @oclif plugins) or are staunchly sticking with CommonJS for the foreseeable future.
Read more about this topic here.
Improving and Revitalizing oclif.io​
Another area of focus for us has been improving our documentation site, oclif.io.
While improving the quality and accuracy of the documentation was our priority, we also took the time to upgrade to the latest version of docusaurus. This new version gave our site a much-needed facelift, as well as cool new features such as dark mode and announcements.
If you have any feedback or are running into issues, we want to hear about it. Just create an issue in the oclif.io repo.
Re-engaging the oclif Community​
Lastly, our biggest priority at the moment is to re-engage the oclif community. We understand how frustrating it has been over the years to see your issues and pull requests go unacknowledged. We apologize for not prioritizing the community, and are earnestly trying to make sure that every issue and pull request gets the attention it deserves going forward.
We also opened up GitHub discussions for @oclif/core and the oclif CLI, where you can now post your questions or ideas. We hope you take advantage of them, we love hearing from you!
One last thing: we intend to publicly post our roadmap so you have more visibility into what we're working on. Stay tuned!
All our best,
The oclif teamAnnouncing oclif v2!January 12, 2022 · 5 min readHello and happy new year! It's our great pleasure to announce that we have released oclif v2, which uses the new @oclif/core library! 🎉
oclif v2 includes many changes that improve the experience of both creating and using an oclif CLI.
Going forward, we don't plan to make any updates to oclif v1 and its corresponding libraries, except for critical security fixes. See the compatibility matrix for a list of these libraries. In order to give developers time to migrate from v1 to v2, we're not completely dropping support yet. But at some point in the future we'll archive the v1 repositories and deprecate their versions on npm.
What’s changing?​
Repository Changes​
All repositories under the oclif org now use main as their primary branch and oclif-v1 as the legacy branch. The main  branch corresponds to oclif v2 and the oclif-v1 branch to oclif v1. If you find any repos that don’t have a main branch, you can safely assume that they're not used in oclif v2 and will be deprecated in the future.
Consolidating Tools & Libraries​
The oclif-dev CLI has now been incorporated into oclif. You now no longer need to install a separate package to manage your entire CLI’s lifecycle.
The following libraries have been consolidated under @oclif/core and will be deprecated at some point in the future. Read the migration guide to learn how to update your CLI or plugin to use the new core library.

@oclif/command
@oclif/config
@oclif/error
@oclif/help
@oclif/parser

No more single vs multi command CLIs​
There's only one "type" of oclif v2 CLI, but it can have as few or as many commands as a developer wants. As a result, there’s only one command to generate CLIs, oclif generate, as opposed to the old oclif single and oclif multi commands.
Node > 12​
To ensure oclif CLIs are as secure as possible, all v2 libraries and plugins support only Node 12 or higher as of now. Going forward, they'll support only Node Maintenance or higher, as defined by Node's release schedule here: https://nodejs.org/en/about/releases/.
What’s new?​
New example CLI​
oclif-hello-world is our new example repo. This is also the repo that's used as a template when running oclif generate to create a new CLI. This repo will always be able to be referenced as an example of what an oclif v2 CLI should look like.
Spaced commands​
oclif CLIs can now use spaces, instead of colons, to separate topics and subcommands. To enable this feature, simply add “topicSeparator": " " to the oclif config in your package.json. See an example in our example repo.
// Old commands that use :$ mycli do:something
// New spaced commands$ mycli do something

Note: Spaced commands are backwards compatible. So if you enable spaced commands for your CLI, users will still be able to use : as a separator. This ensures that any existing scripts don't break.

New Help Output​
We’ve revamped the way command help is outputted to the terminal, making it both easier to implement and easier to read. See the difference between the old help output on the left and the new help output on the right in the screenshots below.
oclif v1oclif v2
Notice that there are new sections for flags and global flags, examples are displayed with better spacing, and there is a section at the bottom called Configuration Variables. This Configuration Variables section is not part of the new help by default. But we've added support for custom help sections, which is what the sf CLI uses to create the new section.
Async Command Parsing​
We’ve also improved the performance of new CLIs by rewriting how commands are parsed on initialization. The new parser is asynchronous, which makes CLIs with a lot of commands or installed  plugins much faster.
What’s coming next?​
Part of our charter for the release of oclif v2 includes improving our engagement with the oclif community. We know that over the past couple of years we’ve reduced our involvement, and a lot of issues and PRs have languished in limbo. Hopefully you’ve already seen increased activity and responses from oclif maintainers recently, but if you haven’t, please don’t hesitate to ping us by tagging @admins in oclif repos.
We also want to start interviewing members of the oclif community to acquire feedback and prioritize the features and fixes you deem most important!
Best,
The oclif team

Reference material​
Migration Guide​
This guide explains how to upgrade a CLI or plugin from the old oclif v1 libraries to the new @oclif/core library that oclif v2 uses.
https://github.com/oclif/core/blob/main/MIGRATION.md
Compatibility Matrix​
The following matrix shows how the v1 libraries and plugins relate to the new v2 ones. Use this matrix as a guide to know what to drop and which versions to switch when upgrading your plugins and CLIs to v2.
oclif "v1"oclif "v2"Utility CLIsoclif@<2@oclif/dev-cli@<2oclif@>=2Main packages@oclif/command@oclif/config@oclif/errors@oclif/parser@oclif/plugin-help@oclif/core@>=1Node LTSNode v8-14Node v12+ (at time of writing)TypeScripttypescript@<4typescript@>=4Main plugins@oclif/plugin-autocomplete@<1@oclif/plugin-commands@<2@oclif/plugin-help@<4@oclif/plugin-not-found@<2@oclif/plugin-plugins@<2@oclif/plugin-update@<2plugin-warn-if-update-available@<2plugin-which@<2@oclif/plugin-autocomplete@>=1@oclif/plugin-commands@>=2@oclif/plugin-help@>=4@oclif/plugin-not-found@>=2@oclif/plugin-plugins@>=2@oclif/plugin-update@>=2@oclif/plugin-warn-if-update-available@>=2@oclif/plugin-which@>=2Introducing @oclif/coreMarch 1, 2021 · 3 min readGreetings!
We hope this blog post finds you well.
Introducing...​
We are excited to announce the next iteration of the oclif project today: @oclif/core.
We have learned a lot in the last three years of developing oclif, developing on oclif and supporting millions of command runs a day via Heroku and Salesforce CLIs.
@oclif/core ("Core") simplifies the oclif development experience and introduces highly requested new features.
Core combines the essential oclif packages into one "core" package, aptly named @oclif/core.
Core also introduces:

A default command option
Colon or space command syntax
Async command parsing
Command piping to arguments

With the introduction of default command functionality, Core simplifies the oclif project and removes the notion of single or multi command CLIs. Core CLIs can have 1 or many commands.
Along with Core, we moved the oclif-dev CLI into the oclif CLI creating a single "utility" CLI. This CLI also introduces a new AWS S3 compatible publishing scheme.
What to expect in the near future​
Core is in pre-release beta and being actively developed for new internal Salesforce CLIs.
Much documentation needs to be written in the coming months including migration paths. Migration onto Core should be as painless as possible with many exports remaining entirely unchanged. Look for forthcoming blog posts and documentation on oclif.io.
Early this summer, tentively June 1, we will release Core v1. Core's release will coincide with major bumps to many other oclif plugin packages. See the compatibility matrix below.
At Core's v1 release, the current "main" oclif packages (namely: command, config, errors & parser) will go into maintenance mode until Jan 2022. They will receive only bug and security fixes and they remain compatible with current versions of the oclif and oclif-dev CLIs. Afterwhich, they will be archived.
Companioning Core, the next major release of the oclif CLI (literally oclif@2) will generate Core CLIs.
Going forward​
We are excited to release Core! We invite you to poke around the Core repo. It may appear to be a big change but Core keeps what you already enjoy about oclif while reducing development complexity, project dependencies, package coupling and bundle size and introduces many requested features previously too prickly to weave into the current oclif architecture.
Best,
The oclif team
Reference: Compatibility matrix​
oclif "v1"oclif "Core"Utility CLIsoclif@<2@oclif/dev-cli@<2oclif@>=2Main packages@oclif/core@<2@oclif/config@<2@oclif/errors@<2@oclif/parser@<4@oclif/plugin-help@<4@oclif/core@>=1Node LTSNode v8-14Node v12+TypeScripttypescript@<4typescript@>=4Main plugins@oclif/plugin-autocomplete@<1@oclif/plugin-commands@<2@oclif/plugin-help@<4@oclif/plugin-not-found@<2@oclif/plugin-plugins@<2@oclif/plugin-update@<2plugin-warn-if-update-available@<2plugin-which@<2@oclif/plugin-autocomplete@>=2@oclif/plugin-commands@>=2@oclif/plugin-help@>=4@oclif/plugin-not-found@>=2@oclif/plugin-plugins@>=2@oclif/plugin-update@>=2@oclif/plugin-warn-if-update-available@>=2@oclif/plugin-which@>=2oclif Summer 2020 UpdateAugust 26, 2020 · 2 min readHello oclif developers! We hope you are all doing well.
Earlier this year, we started our planning for oclifconf v2 and, like all conference, had to change course. We opted not to hold a virtual conference, however, we wanted to take some time to highlight a few oclif features shipped this year.
Feature: Help templating​
One of the most requested features, help templating enables oclif developers to customize the help output for their CLI.
Read the announcement.
Feature: Custom error delegation​
This feature both improved how oclif throws and handles errors and allows oclif developers to overwrite or interject in oclif’s error handling.
Read the announcement.
Feature: postrun hooks​
We have added a new lifecycle event postrun. Your CLI can now run a hook after a command has ran.
See our hook documentation.
Feature: Root index command​
Previously, oclif would display CLI help if only the binary name with no command ID was invoked, oclif now supports a "root index" command. If present, a command defined at src/commands/index.ts will be run if no command ID is found.
1 million weekly downloads​
While exact oclif usage metrics are hard to pin down, we use npm download statistics of oclif packages as a rough approximation. Earlier this year, oclif's command package hit 1 million weekly downloads for the first time!
This year has been presented its challenges on everyone. We want to thank you, oclif developers, whom have taken the time to use and improve the oclif project. We look forward to seeing you all - in person - in the future!
All our best,
The oclif teamPretty Printable ErrorsJuly 1, 2020 · One min readOften CLIs are used as handy tools and when things go wrong it’s useful to have additional context. In oclif we have added a couple of additional properties that can show extra context to the users when an error is displayed. The code, ref and suggestions will now be displayed if they are included. This will work with an existing oclif CLI by adding the latest @oclif/errors and @oclif/core to the CLI's package.json dependencies.
For example, using this.error with the additional properties:
class TestError extends Command {  async run() {    this.error("An error has occurred!", {      code: "OCLIF_ERR",      ref: "https://oclif.io/docs/commands#thiserrormessage-string--error-options-code-string-exit-number",      suggestions: ["Use these extra properties to provide additional context"],    })  }}
would result with the following output:
›   Error: An error has occurred!›   Code: OCLIF_ERR›   Try this: Use these extra properties to provide additional context›   Reference: https://oclif.io/docs/commands#thiserrormessage-string--error-options-code-string-exit-number
If these properties are not provided then nothing changes and the CLI will continue to display the single error message output as it did before. Additionally, as part of this exercise we’ve added documentation around Error Handling in oclif which should come in handy if the need arises to extend oclif’s default handling of errors.Customizing Help in oclifMay 5, 2020 · 2 min readOut of the box oclif provides a great help experience for CLIs.
But what if, as an oclif developer, you want to customize some or all of the output?
You can now customize your CLI's help output by implementing the HelpBase abstract class.
Getting started with custom help​
If you have not done so yet, update @oclif/core.
$ yarn add --latest @oclif/core
To get started, first define the filepath to your help class in oclif's config in package.json. This is a relative path to the help class, without a file extension.
For this example, the help class will be created in a file at "[project root]/src/help.ts".
{  // ...  "oclif": {    "helpClass": "./lib/help"    // ...  }  // ...}
From here there are two paths, implement the HelpBase abstract class yourself or overwrite the parts of the default Help class you want to customize (ex: how command usage is displayed). We recommend the latter approach but cover both in the new Help Classes docs.
Separating TOPICS & COMMANDS in the new default Help class​
Previously, topics and child commands were listed in help output under a single list heading called "COMMANDS". But we found this can be slightly confusing. Some topics are commands also (a.k.a. topic-commands) while others are simply organizational namespacing (and when ran just show their help).
The new default Help class splits the list of children into distinct lists of "TOPICS" and "COMMANDS", with the possibility of an item appearing in both if it a topic-command. This makes it clearer what is expected to be ran - "COMMANDS" - and what is providing structure - "TOPICS" - when looking at the help output.
VERSION  plugin-help-example/0.0.0 darwin-x64 node-v12.12.0USAGE  $ plugin-help-example [COMMAND]TOPICS  topic  this is a topic and has child topics or commandsCOMMANDS  hello  describe the command here  help   display help for plugin-help-example
We look forward to seeing what custom help features you implement in your oclif CLIs with this new feature!oclif TSLint to ESLint MigrationDecember 5, 2019 · 3 min readBack in February of this year, plans were announced to deprecate TSLint in favor of ESLint. TSLint's goal has become to work toward a “unified developer experience” by supporting ESLint development going forward.
What has changed in oclif​
To keep inline with the community, oclif has transitioned to ESLint for all our core libraries as well as all our official plugins.
Starting in v1.15.x, oclif will now optionally generate projects with ESLint for both TypeScript and JavaScript CLI’s.
ESLint does require Node to be on stable LTS version, at the time of writing, Node 8.10.x, Node 10.13.x & Node 12.x.x.
How does this affect you​
Existing CLI’s are unchanged, but any newly generated CLI's will only give the option of using ESLint. If you are running tslint in your CLI, we recommend you switch to ESLint as well.
In migrating our projects we took the following steps (for an example of these changes see this pull request).


Install eslint
$ yarn add eslint eslint-config-oclif eslint-config-oclif-typescript --dev


Add eslint related files


$ echo '{  "extends": [    "oclif",    "oclif-typescript"  ],  "rules": {  }}' > .eslintrc


Remove tslint and related packages
$ yarn remove @oclif/tslint tslint


Remove tslint related configuration files
$ rm tslint.json


Change lint script in our package.json from something like:
"lint": "tsc -p test --noEmit && tslint -p test -t stylish"
to
"lint": "eslint . --ext .ts --config .eslintrc"


To preserve the test compile (tsc -p test --noEmit) we also made the following updates to our scripts:
"pretest": "tsc -p test --noEmit"
In some cases we had our posttest duplicating the same steps as our lint script so it’s cleaner to have it reference the lint job directly with:
"posttest": "yarn lint"

Run yarn lint --fix. This attempts to auto-fix any linting violations automatically. In the case an auto-fix isn’t available it should be fixed manually or ignored (see the eslint configuration doc for more information)
Do a search in the codebase for tslint and remove any unnecessary tslint disabling comments, like:

/* tslint:disable:object-literal-sort-keys */
If you are on a version of Node that is not supported by ESLint, you will also need to update your Node engine. ESLint supports Node 8, 10, and 12 so you should upgrade to the most recent Node version compatible with your CLI and also supported by ESLint (see ESLint's Installation and Usage instructions).
When will this take effect​
These changes have taken effect in oclif v1.15.1. When you generate a new CLI or plugin it will now contain configuration for ESLint instead of TSLint.oclif's Current Node SupportOctober 31, 2019 · 3 min readTo maintain a healthy project trajectory, oclif follows and supports Node Active LTS release, currently Node 10 & Node 12. This means ensuring that oclif continues to play nice with coming Active LTS Node versions and other packages in the ecosystem. Moving forward also means leaving older versions behind. Starting in 2020, Node will stop maintaining Node 8 and it is our intent at that time to also follow suit. Let’s take a look at a few ways we will be supporting these changes.
CI Environments​
CLIs created with the oclif cli going forward will be generated with a CircleCI configuration with Node 10 & 12 and an Appveyor configuration using Node 10. We have also added Node latest to CircleCi to be an early warning detection against coming Node changes (Node latest is managed by CircleCI).
We have already updated every oclif repo's CI configs to reflect this.
If your existing CLI uses either Appveyor or CircleCI you can update your config files also, like so:
.circleci/config.yml​
Your CircleCI config should contain a node-latest job, aliased as test. From this, there should be two extensions of this job for the Active LTS Node versions, Node 10 and Node 12.
  node-10:    <<: *node-latest    docker:      - image: node:10  node-12:    <<: *node-latest    docker:      - image: node:12
Notice that these declarations only change the Docker Node images used to run that job.
Additionally, the jobs listed within workflows must also be updated to reflect our changes in configuration:
    jobs:      - node-latest      - node-10      - node-12
appveyor.yml​
For appveyor we are currently only testing the oldest Active LTS Node version, Node 10. Update the nodejs_version proppert in your appveyor.yml file to reflect this.
environment:  nodejs_version: "10"
Deprecating Node 8 & Updating packge.json engines​
In Jan 2020, Node will end its Node 8 maintenance. We will follow suit by setting the package.json engine property in oclif packages to >=10 and bumping the package's major versions.
Depending on how you ship your CLI you may wish to also bump the engines version in your CLI's package.json. You can read more about the implications of the engines property configuration in the npm documentation.
Also consider distributing your CLI with its own Node version.
Packaged Node Version​
When using dev-cli to pack your CLI it will use the Node version as specified in your package.json under the oclif.update.node.version property. This value should reflect an Active LTS Node version (dev-cli does not currently enforce versions).
Supporting the future​
As a community we may discover bumps along the way as we upgrade. If you notice something related to oclif please feel free to open an issue or submit a pull request under the relevant oclif package within the org.
We look forward to using the latest from Node and the community and keeping oclif healthy along the way.oclifconf 2019: A RecapSeptember 16, 2019 · 4 min readIn May, Heroku and Salesforce Open Source organized oclifconf, a conference for developers & product managers building CLI tools on top of the open source oclif framework. The speakers came from various tech companies, such as Adobe, Netlify, and Apollo, who have already built amazing CLI experiences. The topics covered everything from the incredible capabilities oclif has unlocked, to the community-built plugins extending its functionality, and even what the behavior of an adaptive CLI tool might look like.
Below is a listing of all of the talks from the event, along with a short summary. Enjoy!
The future of oclif by Jeff Dickey​

In its relatively short lifetime, oclif has already inspired many developers and companies to adopt its framework as a means for implementing their own command-line tooling. In this talk, Jeff Dickey, an oclif founding team member, recaps the project's history and inspiration. He also looks towards the future and outlines some features and improvements that the tool could adapt. This isn't so much a definitive roadmap of where oclif is headed, but rather, a call to inspiration for developers eager to contribute! And if you are interested in contributing, check out the open issues in the oclif GitHub repo and come say "Hello!" on Spectrum Chat.
Open Source Citizenship by Josh Simmons​

When it comes to open source, it's more than just individuals now. More and more frequently, large corporations are contributing to projects by donating to contributors, sponsoring events, or upstreaming contributions. But keeping open source projects and communities healthy requires more than just money and brainpower. Josh Simmons surveyed multiple open source communities and relays his findings as to what help maintainers and contributors actually need in this talk.
Building an enterprise-grade CLI with oclif by Thomas Dvornik​

Security and performance are all about trust. While oclif is an extremely extensible framework for building CLI tooling, there are additional requirements to fulfill for enterprise businesses to adopt it that might not be necessary for individual developers. Thomas Dvornik outlines what he and his colleagues at Salesforce have implemented as plugins to oclif to satisfy these needs, including encrypted OAuth, plugin signing, lazy loading dependencies, synchronizing weekly releases and deprecations across dozens of repositories, and establishing cross-team coding and documentation standards.
How Adobe I/O built an extensible CLI with oclif by Jesse MacFadyen​

Perhaps oclif's most appealing feature is its support for plugins. In Cordova's case, they've created a sophisticated telemetry system that helps Adobe developers see which commands users are using--and reports on which ones are erroring out. By embedding a feedback system into the tool, users are even able to quickly send their suggestions to a form, without ever leaving the terminal. Jesse MacFadyen demonstrates how oclif's plugin system can work beyond simply executing commands.
Integrating oclif with GraphQL and Apollo by Evans Hauser​

For Evans Hauser and the team at Apollo, oclif is best thought of as "React for the CLI." As a client paired with a strongly-typed API contract to a server, it can deliver structured and consistent commands to retrieve external data. What better mechanism to use for this transfer than GraphQL, a framework which empowers the client to ask precisely for the data it needs, and nothing more?
Adaptive Intent-based CLI State Machines by Shawn Wang​

In designing oclif, Jeff Dickey wrote out 12 CLI factors to keep in mind. In this talk, Shawn Wang outlines a 13th: state. State is hard, because it depends on context, and context depends on understanding what a user intends to do, not what they are asking. Shawn is working towards enabling oclif to better understand the commands a user has entered, so that it can predict and interpret future commands that might be entered next. This would enable CLI tools to not just interpret a users' commands, but to also interpret their intent.\n\nIntroducing `oclif init` commandApril 10, 2024 · 2 min readThanks to the contribution of @joshcanhelp we released a new command for the oclif CLI called oclif init in version 4.8.0
The oclif init command allows you to initialize oclif in an existing project directory by adding the bare minimum requirements: a few pieces of configuration, bin scripts, and a couple of dependencies (@oclif/core and ts-node). This is slightly different from oclif generate, which will create an entirely new oclif project based on our templates.
oclif init will add the following:

bin scripts: bin/run.js, bin/run.cmd, bin/dev.js, and bin/dev.cmd
oclif section to package.json with bin, dirname, commands, and topicSeparator set (See Configuring Your CLI for more)
@oclif/core to dependencies in your package.json (if it's not already there)
ts-node to devDependencies in your package.json (if it's not already there)

Once you've initialized oclif, you can use the bin scripts to execute your CLI. You can also use the other oclif commands like oclif generate command and oclif generate hook to start adding new functionality.

❯ oclif init --helpInitialize a new oclif CLIUSAGE  $ oclif init [--bin <value>] [--module-type ESM|CommonJS] [--package-manager npm|yarn|pnpm] [--topic-separator    colons|spaces] [-d <value>] [-y]FLAGS  -d, --output-dir=<value>        Directory to initialize the CLI in.  -y, --yes                       Use defaults for all prompts. Individual flags will override defaults.      --bin=<value>               Supply answer for prompt: Command bin name the CLI will export      --module-type=<option>      Supply answer for prompt: Select a module type                                  <options: ESM|CommonJS>      --package-manager=<option>  Supply answer for prompt: Select a package manager                                  <options: npm|yarn|pnpm>      --topic-separator=<option>  Supply answer for prompt: Select a topic separator                                  <options: colons|spaces>DESCRIPTION  Initialize a new oclif CLI  This will add the necessary oclif bin files, add oclif config to package.json, and install @oclif/core and ts-node.EXAMPLES  Initialize a new CLI in the current directory    $ oclif init  Initialize a new CLI in a different directory    $ oclif init --output-dir "/path/to/existing/project"  Supply answers for specific prompts    $ oclif init --topic-separator colons --bin mycli
Hope you enjoy the new command! If you come across any issues or have any new ideas for this command, head over to the oclif/oclif repo and open a new issue.
All our best,
The oclif teamoclif Spring 2024 UpdateMarch 29, 2024 · 4 min readHello oclif developers! It's been a while since we last uploaded a blog - and a lot has happened.
We've been focusing on these high-level areas over the past couple of years:

Improving @oclif/core
ESM Support
Improving and revitalizing oclif.io
Re-engaging the oclif community

Improving @oclif/core​
Since we announced @oclif/core over three years ago, we've released two new major versions, each packed with lots of features that we're really excited about.
Here are some of these changes:

Full support for ESM and interoperability with CommonJS (more on this topic below).
Configurable command discovery strategies that give you more control over how commands are loaded at runtime. Check out the docs.
A new preparse hook that allows you to manipulate the provided arguments before they're parsed. Salesforce used this hook to implement a neat --flags-dir feature that translates local files into flags.
A new Performance class that you can use to track performance inside of @oclif/core and your own CLI or plugin. Check out the docs.
A new flag type, Flags.option, that lets you define a flag with a preset list of options. Typescript then uses the options to infer the flag's type.
Flags now have a relationship property that allows you to define more complex relationships between flags. Check out the flags docs for more information.
Flags now have a defaultHelp property that allows you to set the human readable default value in the command help. This property is useful when your flag's parse method returns a complex type, such as an object or a class. Check out the flags docs for more.
Commands now have a hiddenAliases property that allows you to define aliases that you want to hide from the user. The property is super helpful when you're trying to wean users off a deprecated command.
You can now use bun or tsx as dev runtimes (as opposed to node or ts-node).
A command's usage, args, and flags are now shown whenever a user forgets to provide a required arg or flag, or when they provided a non-existent flag.

If you need help migrating to the latest version, head over to core's README which has links to the migration guides. Feel free to open a new discussion if you need more hands-on help from us or the community.
ESM Support​
Version 3 of @oclif/core introduced full support for developing ESM plugins and CLIs. It also offered full support for interoperability between CommonJS and ESM plugins.
Put more simply, you can now migrate your CLI to ESM while keeping individual plugins in CommonJS (or vice versa). The upgrade path is now much simpler for you. You also don't need to worry about any community plugins that have migrated to ESM before you did (such as all the @oclif plugins) or are staunchly sticking with CommonJS for the foreseeable future.
Read more about this topic here.
Improving and Revitalizing oclif.io​
Another area of focus for us has been improving our documentation site, oclif.io.
While improving the quality and accuracy of the documentation was our priority, we also took the time to upgrade to the latest version of docusaurus. This new version gave our site a much-needed facelift, as well as cool new features such as dark mode and announcements.
If you have any feedback or are running into issues, we want to hear about it. Just create an issue in the oclif.io repo.
Re-engaging the oclif Community​
Lastly, our biggest priority at the moment is to re-engage the oclif community. We understand how frustrating it has been over the years to see your issues and pull requests go unacknowledged. We apologize for not prioritizing the community, and are earnestly trying to make sure that every issue and pull request gets the attention it deserves going forward.
We also opened up GitHub discussions for @oclif/core and the oclif CLI, where you can now post your questions or ideas. We hope you take advantage of them, we love hearing from you!
One last thing: we intend to publicly post our roadmap so you have more visibility into what we're working on. Stay tuned!
All our best,
The oclif teamAnnouncing oclif v2!January 12, 2022 · 5 min readHello and happy new year! It's our great pleasure to announce that we have released oclif v2, which uses the new @oclif/core library! 🎉
oclif v2 includes many changes that improve the experience of both creating and using an oclif CLI.
Going forward, we don't plan to make any updates to oclif v1 and its corresponding libraries, except for critical security fixes. See the compatibility matrix for a list of these libraries. In order to give developers time to migrate from v1 to v2, we're not completely dropping support yet. But at some point in the future we'll archive the v1 repositories and deprecate their versions on npm.
What’s changing?​
Repository Changes​
All repositories under the oclif org now use main as their primary branch and oclif-v1 as the legacy branch. The main  branch corresponds to oclif v2 and the oclif-v1 branch to oclif v1. If you find any repos that don’t have a main branch, you can safely assume that they're not used in oclif v2 and will be deprecated in the future.
Consolidating Tools & Libraries​
The oclif-dev CLI has now been incorporated into oclif. You now no longer need to install a separate package to manage your entire CLI’s lifecycle.
The following libraries have been consolidated under @oclif/core and will be deprecated at some point in the future. Read the migration guide to learn how to update your CLI or plugin to use the new core library.

@oclif/command
@oclif/config
@oclif/error
@oclif/help
@oclif/parser

No more single vs multi command CLIs​
There's only one "type" of oclif v2 CLI, but it can have as few or as many commands as a developer wants. As a result, there’s only one command to generate CLIs, oclif generate, as opposed to the old oclif single and oclif multi commands.
Node > 12​
To ensure oclif CLIs are as secure as possible, all v2 libraries and plugins support only Node 12 or higher as of now. Going forward, they'll support only Node Maintenance or higher, as defined by Node's release schedule here: https://nodejs.org/en/about/releases/.
What’s new?​
New example CLI​
oclif-hello-world is our new example repo. This is also the repo that's used as a template when running oclif generate to create a new CLI. This repo will always be able to be referenced as an example of what an oclif v2 CLI should look like.
Spaced commands​
oclif CLIs can now use spaces, instead of colons, to separate topics and subcommands. To enable this feature, simply add “topicSeparator": " " to the oclif config in your package.json. See an example in our example repo.
// Old commands that use :$ mycli do:something
// New spaced commands$ mycli do something

Note: Spaced commands are backwards compatible. So if you enable spaced commands for your CLI, users will still be able to use : as a separator. This ensures that any existing scripts don't break.

New Help Output​
We’ve revamped the way command help is outputted to the terminal, making it both easier to implement and easier to read. See the difference between the old help output on the left and the new help output on the right in the screenshots below.
oclif v1oclif v2
Notice that there are new sections for flags and global flags, examples are displayed with better spacing, and there is a section at the bottom called Configuration Variables. This Configuration Variables section is not part of the new help by default. But we've added support for custom help sections, which is what the sf CLI uses to create the new section.
Async Command Parsing​
We’ve also improved the performance of new CLIs by rewriting how commands are parsed on initialization. The new parser is asynchronous, which makes CLIs with a lot of commands or installed  plugins much faster.
What’s coming next?​
Part of our charter for the release of oclif v2 includes improving our engagement with the oclif community. We know that over the past couple of years we’ve reduced our involvement, and a lot of issues and PRs have languished in limbo. Hopefully you’ve already seen increased activity and responses from oclif maintainers recently, but if you haven’t, please don’t hesitate to ping us by tagging @admins in oclif repos.
We also want to start interviewing members of the oclif community to acquire feedback and prioritize the features and fixes you deem most important!
Best,
The oclif team

Reference material​
Migration Guide​
This guide explains how to upgrade a CLI or plugin from the old oclif v1 libraries to the new @oclif/core library that oclif v2 uses.
https://github.com/oclif/core/blob/main/MIGRATION.md
Compatibility Matrix​
The following matrix shows how the v1 libraries and plugins relate to the new v2 ones. Use this matrix as a guide to know what to drop and which versions to switch when upgrading your plugins and CLIs to v2.
oclif "v1"oclif "v2"Utility CLIsoclif@<2@oclif/dev-cli@<2oclif@>=2Main packages@oclif/command@oclif/config@oclif/errors@oclif/parser@oclif/plugin-help@oclif/core@>=1Node LTSNode v8-14Node v12+ (at time of writing)TypeScripttypescript@<4typescript@>=4Main plugins@oclif/plugin-autocomplete@<1@oclif/plugin-commands@<2@oclif/plugin-help@<4@oclif/plugin-not-found@<2@oclif/plugin-plugins@<2@oclif/plugin-update@<2plugin-warn-if-update-available@<2plugin-which@<2@oclif/plugin-autocomplete@>=1@oclif/plugin-commands@>=2@oclif/plugin-help@>=4@oclif/plugin-not-found@>=2@oclif/plugin-plugins@>=2@oclif/plugin-update@>=2@oclif/plugin-warn-if-update-available@>=2@oclif/plugin-which@>=2Introducing @oclif/coreMarch 1, 2021 · 3 min readGreetings!
We hope this blog post finds you well.
Introducing...​
We are excited to announce the next iteration of the oclif project today: @oclif/core.
We have learned a lot in the last three years of developing oclif, developing on oclif and supporting millions of command runs a day via Heroku and Salesforce CLIs.
@oclif/core ("Core") simplifies the oclif development experience and introduces highly requested new features.
Core combines the essential oclif packages into one "core" package, aptly named @oclif/core.
Core also introduces:

A default command option
Colon or space command syntax
Async command parsing
Command piping to arguments

With the introduction of default command functionality, Core simplifies the oclif project and removes the notion of single or multi command CLIs. Core CLIs can have 1 or many commands.
Along with Core, we moved the oclif-dev CLI into the oclif CLI creating a single "utility" CLI. This CLI also introduces a new AWS S3 compatible publishing scheme.
What to expect in the near future​
Core is in pre-release beta and being actively developed for new internal Salesforce CLIs.
Much documentation needs to be written in the coming months including migration paths. Migration onto Core should be as painless as possible with many exports remaining entirely unchanged. Look for forthcoming blog posts and documentation on oclif.io.
Early this summer, tentively June 1, we will release Core v1. Core's release will coincide with major bumps to many other oclif plugin packages. See the compatibility matrix below.
At Core's v1 release, the current "main" oclif packages (namely: command, config, errors & parser) will go into maintenance mode until Jan 2022. They will receive only bug and security fixes and they remain compatible with current versions of the oclif and oclif-dev CLIs. Afterwhich, they will be archived.
Companioning Core, the next major release of the oclif CLI (literally oclif@2) will generate Core CLIs.
Going forward​
We are excited to release Core! We invite you to poke around the Core repo. It may appear to be a big change but Core keeps what you already enjoy about oclif while reducing development complexity, project dependencies, package coupling and bundle size and introduces many requested features previously too prickly to weave into the current oclif architecture.
Best,
The oclif team
Reference: Compatibility matrix​
oclif "v1"oclif "Core"Utility CLIsoclif@<2@oclif/dev-cli@<2oclif@>=2Main packages@oclif/core@<2@oclif/config@<2@oclif/errors@<2@oclif/parser@<4@oclif/plugin-help@<4@oclif/core@>=1Node LTSNode v8-14Node v12+TypeScripttypescript@<4typescript@>=4Main plugins@oclif/plugin-autocomplete@<1@oclif/plugin-commands@<2@oclif/plugin-help@<4@oclif/plugin-not-found@<2@oclif/plugin-plugins@<2@oclif/plugin-update@<2plugin-warn-if-update-available@<2plugin-which@<2@oclif/plugin-autocomplete@>=2@oclif/plugin-commands@>=2@oclif/plugin-help@>=4@oclif/plugin-not-found@>=2@oclif/plugin-plugins@>=2@oclif/plugin-update@>=2@oclif/plugin-warn-if-update-available@>=2@oclif/plugin-which@>=2oclif Summer 2020 UpdateAugust 26, 2020 · 2 min readHello oclif developers! We hope you are all doing well.
Earlier this year, we started our planning for oclifconf v2 and, like all conference, had to change course. We opted not to hold a virtual conference, however, we wanted to take some time to highlight a few oclif features shipped this year.
Feature: Help templating​
One of the most requested features, help templating enables oclif developers to customize the help output for their CLI.
Read the announcement.
Feature: Custom error delegation​
This feature both improved how oclif throws and handles errors and allows oclif developers to overwrite or interject in oclif’s error handling.
Read the announcement.
Feature: postrun hooks​
We have added a new lifecycle event postrun. Your CLI can now run a hook after a command has ran.
See our hook documentation.
Feature: Root index command​
Previously, oclif would display CLI help if only the binary name with no command ID was invoked, oclif now supports a "root index" command. If present, a command defined at src/commands/index.ts will be run if no command ID is found.
1 million weekly downloads​
While exact oclif usage metrics are hard to pin down, we use npm download statistics of oclif packages as a rough approximation. Earlier this year, oclif's command package hit 1 million weekly downloads for the first time!
This year has been presented its challenges on everyone. We want to thank you, oclif developers, whom have taken the time to use and improve the oclif project. We look forward to seeing you all - in person - in the future!
All our best,
The oclif teamPretty Printable ErrorsJuly 1, 2020 · One min readOften CLIs are used as handy tools and when things go wrong it’s useful to have additional context. In oclif we have added a couple of additional properties that can show extra context to the users when an error is displayed. The code, ref and suggestions will now be displayed if they are included. This will work with an existing oclif CLI by adding the latest @oclif/errors and @oclif/core to the CLI's package.json dependencies.
For example, using this.error with the additional properties:
class TestError extends Command {  async run() {    this.error("An error has occurred!", {      code: "OCLIF_ERR",      ref: "https://oclif.io/docs/commands#thiserrormessage-string--error-options-code-string-exit-number",      suggestions: ["Use these extra properties to provide additional context"],    })  }}
would result with the following output:
›   Error: An error has occurred!›   Code: OCLIF_ERR›   Try this: Use these extra properties to provide additional context›   Reference: https://oclif.io/docs/commands#thiserrormessage-string--error-options-code-string-exit-number
If these properties are not provided then nothing changes and the CLI will continue to display the single error message output as it did before. Additionally, as part of this exercise we’ve added documentation around Error Handling in oclif which should come in handy if the need arises to extend oclif’s default handling of errors.Customizing Help in oclifMay 5, 2020 · 2 min readOut of the box oclif provides a great help experience for CLIs.
But what if, as an oclif developer, you want to customize some or all of the output?
You can now customize your CLI's help output by implementing the HelpBase abstract class.
Getting started with custom help​
If you have not done so yet, update @oclif/core.
$ yarn add --latest @oclif/core
To get started, first define the filepath to your help class in oclif's config in package.json. This is a relative path to the help class, without a file extension.
For this example, the help class will be created in a file at "[project root]/src/help.ts".
{  // ...  "oclif": {    "helpClass": "./lib/help"    // ...  }  // ...}
From here there are two paths, implement the HelpBase abstract class yourself or overwrite the parts of the default Help class you want to customize (ex: how command usage is displayed). We recommend the latter approach but cover both in the new Help Classes docs.
Separating TOPICS & COMMANDS in the new default Help class​
Previously, topics and child commands were listed in help output under a single list heading called "COMMANDS". But we found this can be slightly confusing. Some topics are commands also (a.k.a. topic-commands) while others are simply organizational namespacing (and when ran just show their help).
The new default Help class splits the list of children into distinct lists of "TOPICS" and "COMMANDS", with the possibility of an item appearing in both if it a topic-command. This makes it clearer what is expected to be ran - "COMMANDS" - and what is providing structure - "TOPICS" - when looking at the help output.
VERSION  plugin-help-example/0.0.0 darwin-x64 node-v12.12.0USAGE  $ plugin-help-example [COMMAND]TOPICS  topic  this is a topic and has child topics or commandsCOMMANDS  hello  describe the command here  help   display help for plugin-help-example
We look forward to seeing what custom help features you implement in your oclif CLIs with this new feature!oclif TSLint to ESLint MigrationDecember 5, 2019 · 3 min readBack in February of this year, plans were announced to deprecate TSLint in favor of ESLint. TSLint's goal has become to work toward a “unified developer experience” by supporting ESLint development going forward.
What has changed in oclif​
To keep inline with the community, oclif has transitioned to ESLint for all our core libraries as well as all our official plugins.
Starting in v1.15.x, oclif will now optionally generate projects with ESLint for both TypeScript and JavaScript CLI’s.
ESLint does require Node to be on stable LTS version, at the time of writing, Node 8.10.x, Node 10.13.x & Node 12.x.x.
How does this affect you​
Existing CLI’s are unchanged, but any newly generated CLI's will only give the option of using ESLint. If you are running tslint in your CLI, we recommend you switch to ESLint as well.
In migrating our projects we took the following steps (for an example of these changes see this pull request).


Install eslint
$ yarn add eslint eslint-config-oclif eslint-config-oclif-typescript --dev


Add eslint related files


$ echo '{  "extends": [    "oclif",    "oclif-typescript"  ],  "rules": {  }}' > .eslintrc


Remove tslint and related packages
$ yarn remove @oclif/tslint tslint


Remove tslint related configuration files
$ rm tslint.json


Change lint script in our package.json from something like:
"lint": "tsc -p test --noEmit && tslint -p test -t stylish"
to
"lint": "eslint . --ext .ts --config .eslintrc"


To preserve the test compile (tsc -p test --noEmit) we also made the following updates to our scripts:
"pretest": "tsc -p test --noEmit"
In some cases we had our posttest duplicating the same steps as our lint script so it’s cleaner to have it reference the lint job directly with:
"posttest": "yarn lint"

Run yarn lint --fix. This attempts to auto-fix any linting violations automatically. In the case an auto-fix isn’t available it should be fixed manually or ignored (see the eslint configuration doc for more information)
Do a search in the codebase for tslint and remove any unnecessary tslint disabling comments, like:

/* tslint:disable:object-literal-sort-keys */
If you are on a version of Node that is not supported by ESLint, you will also need to update your Node engine. ESLint supports Node 8, 10, and 12 so you should upgrade to the most recent Node version compatible with your CLI and also supported by ESLint (see ESLint's Installation and Usage instructions).
When will this take effect​
These changes have taken effect in oclif v1.15.1. When you generate a new CLI or plugin it will now contain configuration for ESLint instead of TSLint.oclif's Current Node SupportOctober 31, 2019 · 3 min readTo maintain a healthy project trajectory, oclif follows and supports Node Active LTS release, currently Node 10 & Node 12. This means ensuring that oclif continues to play nice with coming Active LTS Node versions and other packages in the ecosystem. Moving forward also means leaving older versions behind. Starting in 2020, Node will stop maintaining Node 8 and it is our intent at that time to also follow suit. Let’s take a look at a few ways we will be supporting these changes.
CI Environments​
CLIs created with the oclif cli going forward will be generated with a CircleCI configuration with Node 10 & 12 and an Appveyor configuration using Node 10. We have also added Node latest to CircleCi to be an early warning detection against coming Node changes (Node latest is managed by CircleCI).
We have already updated every oclif repo's CI configs to reflect this.
If your existing CLI uses either Appveyor or CircleCI you can update your config files also, like so:
.circleci/config.yml​
Your CircleCI config should contain a node-latest job, aliased as test. From this, there should be two extensions of this job for the Active LTS Node versions, Node 10 and Node 12.
  node-10:    <<: *node-latest    docker:      - image: node:10  node-12:    <<: *node-latest    docker:      - image: node:12
Notice that these declarations only change the Docker Node images used to run that job.
Additionally, the jobs listed within workflows must also be updated to reflect our changes in configuration:
    jobs:      - node-latest      - node-10      - node-12
appveyor.yml​
For appveyor we are currently only testing the oldest Active LTS Node version, Node 10. Update the nodejs_version proppert in your appveyor.yml file to reflect this.
environment:  nodejs_version: "10"
Deprecating Node 8 & Updating packge.json engines​
In Jan 2020, Node will end its Node 8 maintenance. We will follow suit by setting the package.json engine property in oclif packages to >=10 and bumping the package's major versions.
Depending on how you ship your CLI you may wish to also bump the engines version in your CLI's package.json. You can read more about the implications of the engines property configuration in the npm documentation.
Also consider distributing your CLI with its own Node version.
Packaged Node Version​
When using dev-cli to pack your CLI it will use the Node version as specified in your package.json under the oclif.update.node.version property. This value should reflect an Active LTS Node version (dev-cli does not currently enforce versions).
Supporting the future​
As a community we may discover bumps along the way as we upgrade. If you notice something related to oclif please feel free to open an issue or submit a pull request under the relevant oclif package within the org.
We look forward to using the latest from Node and the community and keeping oclif healthy along the way.oclifconf 2019: A RecapSeptember 16, 2019 · 4 min readIn May, Heroku and Salesforce Open Source organized oclifconf, a conference for developers & product managers building CLI tools on top of the open source oclif framework. The speakers came from various tech companies, such as Adobe, Netlify, and Apollo, who have already built amazing CLI experiences. The topics covered everything from the incredible capabilities oclif has unlocked, to the community-built plugins extending its functionality, and even what the behavior of an adaptive CLI tool might look like.
Below is a listing of all of the talks from the event, along with a short summary. Enjoy!
The future of oclif by Jeff Dickey​

In its relatively short lifetime, oclif has already inspired many developers and companies to adopt its framework as a means for implementing their own command-line tooling. In this talk, Jeff Dickey, an oclif founding team member, recaps the project's history and inspiration. He also looks towards the future and outlines some features and improvements that the tool could adapt. This isn't so much a definitive roadmap of where oclif is headed, but rather, a call to inspiration for developers eager to contribute! And if you are interested in contributing, check out the open issues in the oclif GitHub repo and come say "Hello!" on Spectrum Chat.
Open Source Citizenship by Josh Simmons​

When it comes to open source, it's more than just individuals now. More and more frequently, large corporations are contributing to projects by donating to contributors, sponsoring events, or upstreaming contributions. But keeping open source projects and communities healthy requires more than just money and brainpower. Josh Simmons surveyed multiple open source communities and relays his findings as to what help maintainers and contributors actually need in this talk.
Building an enterprise-grade CLI with oclif by Thomas Dvornik​

Security and performance are all about trust. While oclif is an extremely extensible framework for building CLI tooling, there are additional requirements to fulfill for enterprise businesses to adopt it that might not be necessary for individual developers. Thomas Dvornik outlines what he and his colleagues at Salesforce have implemented as plugins to oclif to satisfy these needs, including encrypted OAuth, plugin signing, lazy loading dependencies, synchronizing weekly releases and deprecations across dozens of repositories, and establishing cross-team coding and documentation standards.
How Adobe I/O built an extensible CLI with oclif by Jesse MacFadyen​

Perhaps oclif's most appealing feature is its support for plugins. In Cordova's case, they've created a sophisticated telemetry system that helps Adobe developers see which commands users are using--and reports on which ones are erroring out. By embedding a feedback system into the tool, users are even able to quickly send their suggestions to a form, without ever leaving the terminal. Jesse MacFadyen demonstrates how oclif's plugin system can work beyond simply executing commands.
Integrating oclif with GraphQL and Apollo by Evans Hauser​

For Evans Hauser and the team at Apollo, oclif is best thought of as "React for the CLI." As a client paired with a strongly-typed API contract to a server, it can deliver structured and consistent commands to retrieve external data. What better mechanism to use for this transfer than GraphQL, a framework which empowers the client to ask precisely for the data it needs, and nothing more?
Adaptive Intent-based CLI State Machines by Shawn Wang​

In designing oclif, Jeff Dickey wrote out 12 CLI factors to keep in mind. In this talk, Shawn Wang outlines a 13th: state. State is hard, because it depends on context, and context depends on understanding what a user intends to do, not what they are asking. Shawn is working towards enabling oclif to better understand the commands a user has entered, so that it can predict and interpret future commands that might be entered next. This would enable CLI tools to not just interpret a users' commands, but to also interpret their intent.Older Entries\n\n\n\nIntroducing `oclif init` commandApril 10, 2024 · 2 min readThanks to the contribution of @joshcanhelp we released a new command for the oclif CLI called oclif init in version 4.8.0
The oclif init command allows you to initialize oclif in an existing project directory by adding the bare minimum requirements: a few pieces of configuration, bin scripts, and a couple of dependencies (@oclif/core and ts-node). This is slightly different from oclif generate, which will create an entirely new oclif project based on our templates.
oclif init will add the following:

bin scripts: bin/run.js, bin/run.cmd, bin/dev.js, and bin/dev.cmd
oclif section to package.json with bin, dirname, commands, and topicSeparator set (See Configuring Your CLI for more)
@oclif/core to dependencies in your package.json (if it's not already there)
ts-node to devDependencies in your package.json (if it's not already there)

Once you've initialized oclif, you can use the bin scripts to execute your CLI. You can also use the other oclif commands like oclif generate command and oclif generate hook to start adding new functionality.

❯ oclif init --helpInitialize a new oclif CLIUSAGE  $ oclif init [--bin <value>] [--module-type ESM|CommonJS] [--package-manager npm|yarn|pnpm] [--topic-separator    colons|spaces] [-d <value>] [-y]FLAGS  -d, --output-dir=<value>        Directory to initialize the CLI in.  -y, --yes                       Use defaults for all prompts. Individual flags will override defaults.      --bin=<value>               Supply answer for prompt: Command bin name the CLI will export      --module-type=<option>      Supply answer for prompt: Select a module type                                  <options: ESM|CommonJS>      --package-manager=<option>  Supply answer for prompt: Select a package manager                                  <options: npm|yarn|pnpm>      --topic-separator=<option>  Supply answer for prompt: Select a topic separator                                  <options: colons|spaces>DESCRIPTION  Initialize a new oclif CLI  This will add the necessary oclif bin files, add oclif config to package.json, and install @oclif/core and ts-node.EXAMPLES  Initialize a new CLI in the current directory    $ oclif init  Initialize a new CLI in a different directory    $ oclif init --output-dir "/path/to/existing/project"  Supply answers for specific prompts    $ oclif init --topic-separator colons --bin mycli
Hope you enjoy the new command! If you come across any issues or have any new ideas for this command, head over to the oclif/oclif repo and open a new issue.
All our best,
The oclif teamoclif Spring 2024 UpdateMarch 29, 2024 · 4 min readHello oclif developers! It's been a while since we last uploaded a blog - and a lot has happened.
We've been focusing on these high-level areas over the past couple of years:

Improving @oclif/core
ESM Support
Improving and revitalizing oclif.io
Re-engaging the oclif community

Improving @oclif/core​
Since we announced @oclif/core over three years ago, we've released two new major versions, each packed with lots of features that we're really excited about.
Here are some of these changes:

Full support for ESM and interoperability with CommonJS (more on this topic below).
Configurable command discovery strategies that give you more control over how commands are loaded at runtime. Check out the docs.
A new preparse hook that allows you to manipulate the provided arguments before they're parsed. Salesforce used this hook to implement a neat --flags-dir feature that translates local files into flags.
A new Performance class that you can use to track performance inside of @oclif/core and your own CLI or plugin. Check out the docs.
A new flag type, Flags.option, that lets you define a flag with a preset list of options. Typescript then uses the options to infer the flag's type.
Flags now have a relationship property that allows you to define more complex relationships between flags. Check out the flags docs for more information.
Flags now have a defaultHelp property that allows you to set the human readable default value in the command help. This property is useful when your flag's parse method returns a complex type, such as an object or a class. Check out the flags docs for more.
Commands now have a hiddenAliases property that allows you to define aliases that you want to hide from the user. The property is super helpful when you're trying to wean users off a deprecated command.
You can now use bun or tsx as dev runtimes (as opposed to node or ts-node).
A command's usage, args, and flags are now shown whenever a user forgets to provide a required arg or flag, or when they provided a non-existent flag.

If you need help migrating to the latest version, head over to core's README which has links to the migration guides. Feel free to open a new discussion if you need more hands-on help from us or the community.
ESM Support​
Version 3 of @oclif/core introduced full support for developing ESM plugins and CLIs. It also offered full support for interoperability between CommonJS and ESM plugins.
Put more simply, you can now migrate your CLI to ESM while keeping individual plugins in CommonJS (or vice versa). The upgrade path is now much simpler for you. You also don't need to worry about any community plugins that have migrated to ESM before you did (such as all the @oclif plugins) or are staunchly sticking with CommonJS for the foreseeable future.
Read more about this topic here.
Improving and Revitalizing oclif.io​
Another area of focus for us has been improving our documentation site, oclif.io.
While improving the quality and accuracy of the documentation was our priority, we also took the time to upgrade to the latest version of docusaurus. This new version gave our site a much-needed facelift, as well as cool new features such as dark mode and announcements.
If you have any feedback or are running into issues, we want to hear about it. Just create an issue in the oclif.io repo.
Re-engaging the oclif Community​
Lastly, our biggest priority at the moment is to re-engage the oclif community. We understand how frustrating it has been over the years to see your issues and pull requests go unacknowledged. We apologize for not prioritizing the community, and are earnestly trying to make sure that every issue and pull request gets the attention it deserves going forward.
We also opened up GitHub discussions for @oclif/core and the oclif CLI, where you can now post your questions or ideas. We hope you take advantage of them, we love hearing from you!
One last thing: we intend to publicly post our roadmap so you have more visibility into what we're working on. Stay tuned!
All our best,
The oclif teamAnnouncing oclif v2!January 12, 2022 · 5 min readHello and happy new year! It's our great pleasure to announce that we have released oclif v2, which uses the new @oclif/core library! 🎉
oclif v2 includes many changes that improve the experience of both creating and using an oclif CLI.
Going forward, we don't plan to make any updates to oclif v1 and its corresponding libraries, except for critical security fixes. See the compatibility matrix for a list of these libraries. In order to give developers time to migrate from v1 to v2, we're not completely dropping support yet. But at some point in the future we'll archive the v1 repositories and deprecate their versions on npm.
What’s changing?​
Repository Changes​
All repositories under the oclif org now use main as their primary branch and oclif-v1 as the legacy branch. The main  branch corresponds to oclif v2 and the oclif-v1 branch to oclif v1. If you find any repos that don’t have a main branch, you can safely assume that they're not used in oclif v2 and will be deprecated in the future.
Consolidating Tools & Libraries​
The oclif-dev CLI has now been incorporated into oclif. You now no longer need to install a separate package to manage your entire CLI’s lifecycle.
The following libraries have been consolidated under @oclif/core and will be deprecated at some point in the future. Read the migration guide to learn how to update your CLI or plugin to use the new core library.

@oclif/command
@oclif/config
@oclif/error
@oclif/help
@oclif/parser

No more single vs multi command CLIs​
There's only one "type" of oclif v2 CLI, but it can have as few or as many commands as a developer wants. As a result, there’s only one command to generate CLIs, oclif generate, as opposed to the old oclif single and oclif multi commands.
Node > 12​
To ensure oclif CLIs are as secure as possible, all v2 libraries and plugins support only Node 12 or higher as of now. Going forward, they'll support only Node Maintenance or higher, as defined by Node's release schedule here: https://nodejs.org/en/about/releases/.
What’s new?​
New example CLI​
oclif-hello-world is our new example repo. This is also the repo that's used as a template when running oclif generate to create a new CLI. This repo will always be able to be referenced as an example of what an oclif v2 CLI should look like.
Spaced commands​
oclif CLIs can now use spaces, instead of colons, to separate topics and subcommands. To enable this feature, simply add “topicSeparator": " " to the oclif config in your package.json. See an example in our example repo.
// Old commands that use :$ mycli do:something
// New spaced commands$ mycli do something

Note: Spaced commands are backwards compatible. So if you enable spaced commands for your CLI, users will still be able to use : as a separator. This ensures that any existing scripts don't break.

New Help Output​
We’ve revamped the way command help is outputted to the terminal, making it both easier to implement and easier to read. See the difference between the old help output on the left and the new help output on the right in the screenshots below.
oclif v1oclif v2
Notice that there are new sections for flags and global flags, examples are displayed with better spacing, and there is a section at the bottom called Configuration Variables. This Configuration Variables section is not part of the new help by default. But we've added support for custom help sections, which is what the sf CLI uses to create the new section.
Async Command Parsing​
We’ve also improved the performance of new CLIs by rewriting how commands are parsed on initialization. The new parser is asynchronous, which makes CLIs with a lot of commands or installed  plugins much faster.
What’s coming next?​
Part of our charter for the release of oclif v2 includes improving our engagement with the oclif community. We know that over the past couple of years we’ve reduced our involvement, and a lot of issues and PRs have languished in limbo. Hopefully you’ve already seen increased activity and responses from oclif maintainers recently, but if you haven’t, please don’t hesitate to ping us by tagging @admins in oclif repos.
We also want to start interviewing members of the oclif community to acquire feedback and prioritize the features and fixes you deem most important!
Best,
The oclif team

Reference material​
Migration Guide​
This guide explains how to upgrade a CLI or plugin from the old oclif v1 libraries to the new @oclif/core library that oclif v2 uses.
https://github.com/oclif/core/blob/main/MIGRATION.md
Compatibility Matrix​
The following matrix shows how the v1 libraries and plugins relate to the new v2 ones. Use this matrix as a guide to know what to drop and which versions to switch when upgrading your plugins and CLIs to v2.
oclif "v1"oclif "v2"Utility CLIsoclif@<2@oclif/dev-cli@<2oclif@>=2Main packages@oclif/command@oclif/config@oclif/errors@oclif/parser@oclif/plugin-help@oclif/core@>=1Node LTSNode v8-14Node v12+ (at time of writing)TypeScripttypescript@<4typescript@>=4Main plugins@oclif/plugin-autocomplete@<1@oclif/plugin-commands@<2@oclif/plugin-help@<4@oclif/plugin-not-found@<2@oclif/plugin-plugins@<2@oclif/plugin-update@<2plugin-warn-if-update-available@<2plugin-which@<2@oclif/plugin-autocomplete@>=1@oclif/plugin-commands@>=2@oclif/plugin-help@>=4@oclif/plugin-not-found@>=2@oclif/plugin-plugins@>=2@oclif/plugin-update@>=2@oclif/plugin-warn-if-update-available@>=2@oclif/plugin-which@>=2Introducing @oclif/coreMarch 1, 2021 · 3 min readGreetings!
We hope this blog post finds you well.
Introducing...​
We are excited to announce the next iteration of the oclif project today: @oclif/core.
We have learned a lot in the last three years of developing oclif, developing on oclif and supporting millions of command runs a day via Heroku and Salesforce CLIs.
@oclif/core ("Core") simplifies the oclif development experience and introduces highly requested new features.
Core combines the essential oclif packages into one "core" package, aptly named @oclif/core.
Core also introduces:

A default command option
Colon or space command syntax
Async command parsing
Command piping to arguments

With the introduction of default command functionality, Core simplifies the oclif project and removes the notion of single or multi command CLIs. Core CLIs can have 1 or many commands.
Along with Core, we moved the oclif-dev CLI into the oclif CLI creating a single "utility" CLI. This CLI also introduces a new AWS S3 compatible publishing scheme.
What to expect in the near future​
Core is in pre-release beta and being actively developed for new internal Salesforce CLIs.
Much documentation needs to be written in the coming months including migration paths. Migration onto Core should be as painless as possible with many exports remaining entirely unchanged. Look for forthcoming blog posts and documentation on oclif.io.
Early this summer, tentively June 1, we will release Core v1. Core's release will coincide with major bumps to many other oclif plugin packages. See the compatibility matrix below.
At Core's v1 release, the current "main" oclif packages (namely: command, config, errors & parser) will go into maintenance mode until Jan 2022. They will receive only bug and security fixes and they remain compatible with current versions of the oclif and oclif-dev CLIs. Afterwhich, they will be archived.
Companioning Core, the next major release of the oclif CLI (literally oclif@2) will generate Core CLIs.
Going forward​
We are excited to release Core! We invite you to poke around the Core repo. It may appear to be a big change but Core keeps what you already enjoy about oclif while reducing development complexity, project dependencies, package coupling and bundle size and introduces many requested features previously too prickly to weave into the current oclif architecture.
Best,
The oclif team
Reference: Compatibility matrix​
oclif "v1"oclif "Core"Utility CLIsoclif@<2@oclif/dev-cli@<2oclif@>=2Main packages@oclif/core@<2@oclif/config@<2@oclif/errors@<2@oclif/parser@<4@oclif/plugin-help@<4@oclif/core@>=1Node LTSNode v8-14Node v12+TypeScripttypescript@<4typescript@>=4Main plugins@oclif/plugin-autocomplete@<1@oclif/plugin-commands@<2@oclif/plugin-help@<4@oclif/plugin-not-found@<2@oclif/plugin-plugins@<2@oclif/plugin-update@<2plugin-warn-if-update-available@<2plugin-which@<2@oclif/plugin-autocomplete@>=2@oclif/plugin-commands@>=2@oclif/plugin-help@>=4@oclif/plugin-not-found@>=2@oclif/plugin-plugins@>=2@oclif/plugin-update@>=2@oclif/plugin-warn-if-update-available@>=2@oclif/plugin-which@>=2oclif Summer 2020 UpdateAugust 26, 2020 · 2 min readHello oclif developers! We hope you are all doing well.
Earlier this year, we started our planning for oclifconf v2 and, like all conference, had to change course. We opted not to hold a virtual conference, however, we wanted to take some time to highlight a few oclif features shipped this year.
Feature: Help templating​
One of the most requested features, help templating enables oclif developers to customize the help output for their CLI.
Read the announcement.
Feature: Custom error delegation​
This feature both improved how oclif throws and handles errors and allows oclif developers to overwrite or interject in oclif’s error handling.
Read the announcement.
Feature: postrun hooks​
We have added a new lifecycle event postrun. Your CLI can now run a hook after a command has ran.
See our hook documentation.
Feature: Root index command​
Previously, oclif would display CLI help if only the binary name with no command ID was invoked, oclif now supports a "root index" command. If present, a command defined at src/commands/index.ts will be run if no command ID is found.
1 million weekly downloads​
While exact oclif usage metrics are hard to pin down, we use npm download statistics of oclif packages as a rough approximation. Earlier this year, oclif's command package hit 1 million weekly downloads for the first time!
This year has been presented its challenges on everyone. We want to thank you, oclif developers, whom have taken the time to use and improve the oclif project. We look forward to seeing you all - in person - in the future!
All our best,
The oclif teamPretty Printable ErrorsJuly 1, 2020 · One min readOften CLIs are used as handy tools and when things go wrong it’s useful to have additional context. In oclif we have added a couple of additional properties that can show extra context to the users when an error is displayed. The code, ref and suggestions will now be displayed if they are included. This will work with an existing oclif CLI by adding the latest @oclif/errors and @oclif/core to the CLI's package.json dependencies.
For example, using this.error with the additional properties:
class TestError extends Command {  async run() {    this.error("An error has occurred!", {      code: "OCLIF_ERR",      ref: "https://oclif.io/docs/commands#thiserrormessage-string--error-options-code-string-exit-number",      suggestions: ["Use these extra properties to provide additional context"],    })  }}
would result with the following output:
›   Error: An error has occurred!›   Code: OCLIF_ERR›   Try this: Use these extra properties to provide additional context›   Reference: https://oclif.io/docs/commands#thiserrormessage-string--error-options-code-string-exit-number
If these properties are not provided then nothing changes and the CLI will continue to display the single error message output as it did before. Additionally, as part of this exercise we’ve added documentation around Error Handling in oclif which should come in handy if the need arises to extend oclif’s default handling of errors.Customizing Help in oclifMay 5, 2020 · 2 min readOut of the box oclif provides a great help experience for CLIs.
But what if, as an oclif developer, you want to customize some or all of the output?
You can now customize your CLI's help output by implementing the HelpBase abstract class.
Getting started with custom help​
If you have not done so yet, update @oclif/core.
$ yarn add --latest @oclif/core
To get started, first define the filepath to your help class in oclif's config in package.json. This is a relative path to the help class, without a file extension.
For this example, the help class will be created in a file at "[project root]/src/help.ts".
{  // ...  "oclif": {    "helpClass": "./lib/help"    // ...  }  // ...}
From here there are two paths, implement the HelpBase abstract class yourself or overwrite the parts of the default Help class you want to customize (ex: how command usage is displayed). We recommend the latter approach but cover both in the new Help Classes docs.
Separating TOPICS & COMMANDS in the new default Help class​
Previously, topics and child commands were listed in help output under a single list heading called "COMMANDS". But we found this can be slightly confusing. Some topics are commands also (a.k.a. topic-commands) while others are simply organizational namespacing (and when ran just show their help).
The new default Help class splits the list of children into distinct lists of "TOPICS" and "COMMANDS", with the possibility of an item appearing in both if it a topic-command. This makes it clearer what is expected to be ran - "COMMANDS" - and what is providing structure - "TOPICS" - when looking at the help output.
VERSION  plugin-help-example/0.0.0 darwin-x64 node-v12.12.0USAGE  $ plugin-help-example [COMMAND]TOPICS  topic  this is a topic and has child topics or commandsCOMMANDS  hello  describe the command here  help   display help for plugin-help-example
We look forward to seeing what custom help features you implement in your oclif CLIs with this new feature!oclif TSLint to ESLint MigrationDecember 5, 2019 · 3 min readBack in February of this year, plans were announced to deprecate TSLint in favor of ESLint. TSLint's goal has become to work toward a “unified developer experience” by supporting ESLint development going forward.
What has changed in oclif​
To keep inline with the community, oclif has transitioned to ESLint for all our core libraries as well as all our official plugins.
Starting in v1.15.x, oclif will now optionally generate projects with ESLint for both TypeScript and JavaScript CLI’s.
ESLint does require Node to be on stable LTS version, at the time of writing, Node 8.10.x, Node 10.13.x & Node 12.x.x.
How does this affect you​
Existing CLI’s are unchanged, but any newly generated CLI's will only give the option of using ESLint. If you are running tslint in your CLI, we recommend you switch to ESLint as well.
In migrating our projects we took the following steps (for an example of these changes see this pull request).


Install eslint
$ yarn add eslint eslint-config-oclif eslint-config-oclif-typescript --dev


Add eslint related files


$ echo '{  "extends": [    "oclif",    "oclif-typescript"  ],  "rules": {  }}' > .eslintrc


Remove tslint and related packages
$ yarn remove @oclif/tslint tslint


Remove tslint related configuration files
$ rm tslint.json


Change lint script in our package.json from something like:
"lint": "tsc -p test --noEmit && tslint -p test -t stylish"
to
"lint": "eslint . --ext .ts --config .eslintrc"


To preserve the test compile (tsc -p test --noEmit) we also made the following updates to our scripts:
"pretest": "tsc -p test --noEmit"
In some cases we had our posttest duplicating the same steps as our lint script so it’s cleaner to have it reference the lint job directly with:
"posttest": "yarn lint"

Run yarn lint --fix. This attempts to auto-fix any linting violations automatically. In the case an auto-fix isn’t available it should be fixed manually or ignored (see the eslint configuration doc for more information)
Do a search in the codebase for tslint and remove any unnecessary tslint disabling comments, like:

/* tslint:disable:object-literal-sort-keys */
If you are on a version of Node that is not supported by ESLint, you will also need to update your Node engine. ESLint supports Node 8, 10, and 12 so you should upgrade to the most recent Node version compatible with your CLI and also supported by ESLint (see ESLint's Installation and Usage instructions).
When will this take effect​
These changes have taken effect in oclif v1.15.1. When you generate a new CLI or plugin it will now contain configuration for ESLint instead of TSLint.oclif's Current Node SupportOctober 31, 2019 · 3 min readTo maintain a healthy project trajectory, oclif follows and supports Node Active LTS release, currently Node 10 & Node 12. This means ensuring that oclif continues to play nice with coming Active LTS Node versions and other packages in the ecosystem. Moving forward also means leaving older versions behind. Starting in 2020, Node will stop maintaining Node 8 and it is our intent at that time to also follow suit. Let’s take a look at a few ways we will be supporting these changes.
CI Environments​
CLIs created with the oclif cli going forward will be generated with a CircleCI configuration with Node 10 & 12 and an Appveyor configuration using Node 10. We have also added Node latest to CircleCi to be an early warning detection against coming Node changes (Node latest is managed by CircleCI).
We have already updated every oclif repo's CI configs to reflect this.
If your existing CLI uses either Appveyor or CircleCI you can update your config files also, like so:
.circleci/config.yml​
Your CircleCI config should contain a node-latest job, aliased as test. From this, there should be two extensions of this job for the Active LTS Node versions, Node 10 and Node 12.
  node-10:    <<: *node-latest    docker:      - image: node:10  node-12:    <<: *node-latest    docker:      - image: node:12
Notice that these declarations only change the Docker Node images used to run that job.
Additionally, the jobs listed within workflows must also be updated to reflect our changes in configuration:
    jobs:      - node-latest      - node-10      - node-12
appveyor.yml​
For appveyor we are currently only testing the oldest Active LTS Node version, Node 10. Update the nodejs_version proppert in your appveyor.yml file to reflect this.
environment:  nodejs_version: "10"
Deprecating Node 8 & Updating packge.json engines​
In Jan 2020, Node will end its Node 8 maintenance. We will follow suit by setting the package.json engine property in oclif packages to >=10 and bumping the package's major versions.
Depending on how you ship your CLI you may wish to also bump the engines version in your CLI's package.json. You can read more about the implications of the engines property configuration in the npm documentation.
Also consider distributing your CLI with its own Node version.
Packaged Node Version​
When using dev-cli to pack your CLI it will use the Node version as specified in your package.json under the oclif.update.node.version property. This value should reflect an Active LTS Node version (dev-cli does not currently enforce versions).
Supporting the future​
As a community we may discover bumps along the way as we upgrade. If you notice something related to oclif please feel free to open an issue or submit a pull request under the relevant oclif package within the org.
We look forward to using the latest from Node and the community and keeping oclif healthy along the way.oclifconf 2019: A RecapSeptember 16, 2019 · 4 min readIn May, Heroku and Salesforce Open Source organized oclifconf, a conference for developers & product managers building CLI tools on top of the open source oclif framework. The speakers came from various tech companies, such as Adobe, Netlify, and Apollo, who have already built amazing CLI experiences. The topics covered everything from the incredible capabilities oclif has unlocked, to the community-built plugins extending its functionality, and even what the behavior of an adaptive CLI tool might look like.
Below is a listing of all of the talks from the event, along with a short summary. Enjoy!
The future of oclif by Jeff Dickey​

In its relatively short lifetime, oclif has already inspired many developers and companies to adopt its framework as a means for implementing their own command-line tooling. In this talk, Jeff Dickey, an oclif founding team member, recaps the project's history and inspiration. He also looks towards the future and outlines some features and improvements that the tool could adapt. This isn't so much a definitive roadmap of where oclif is headed, but rather, a call to inspiration for developers eager to contribute! And if you are interested in contributing, check out the open issues in the oclif GitHub repo and come say "Hello!" on Spectrum Chat.
Open Source Citizenship by Josh Simmons​

When it comes to open source, it's more than just individuals now. More and more frequently, large corporations are contributing to projects by donating to contributors, sponsoring events, or upstreaming contributions. But keeping open source projects and communities healthy requires more than just money and brainpower. Josh Simmons surveyed multiple open source communities and relays his findings as to what help maintainers and contributors actually need in this talk.
Building an enterprise-grade CLI with oclif by Thomas Dvornik​

Security and performance are all about trust. While oclif is an extremely extensible framework for building CLI tooling, there are additional requirements to fulfill for enterprise businesses to adopt it that might not be necessary for individual developers. Thomas Dvornik outlines what he and his colleagues at Salesforce have implemented as plugins to oclif to satisfy these needs, including encrypted OAuth, plugin signing, lazy loading dependencies, synchronizing weekly releases and deprecations across dozens of repositories, and establishing cross-team coding and documentation standards.
How Adobe I/O built an extensible CLI with oclif by Jesse MacFadyen​

Perhaps oclif's most appealing feature is its support for plugins. In Cordova's case, they've created a sophisticated telemetry system that helps Adobe developers see which commands users are using--and reports on which ones are erroring out. By embedding a feedback system into the tool, users are even able to quickly send their suggestions to a form, without ever leaving the terminal. Jesse MacFadyen demonstrates how oclif's plugin system can work beyond simply executing commands.
Integrating oclif with GraphQL and Apollo by Evans Hauser​

For Evans Hauser and the team at Apollo, oclif is best thought of as "React for the CLI." As a client paired with a strongly-typed API contract to a server, it can deliver structured and consistent commands to retrieve external data. What better mechanism to use for this transfer than GraphQL, a framework which empowers the client to ask precisely for the data it needs, and nothing more?
Adaptive Intent-based CLI State Machines by Shawn Wang​

In designing oclif, Jeff Dickey wrote out 12 CLI factors to keep in mind. In this talk, Shawn Wang outlines a 13th: state. State is hard, because it depends on context, and context depends on understanding what a user intends to do, not what they are asking. Shawn is working towards enabling oclif to better understand the commands a user has entered, so that it can predict and interpret future commands that might be entered next. This would enable CLI tools to not just interpret a users' commands, but to also interpret their intent.\n\nIntroducing `oclif init` commandApril 10, 2024 · 2 min readThanks to the contribution of @joshcanhelp we released a new command for the oclif CLI called oclif init in version 4.8.0
The oclif init command allows you to initialize oclif in an existing project directory by adding the bare minimum requirements: a few pieces of configuration, bin scripts, and a couple of dependencies (@oclif/core and ts-node). This is slightly different from oclif generate, which will create an entirely new oclif project based on our templates.
oclif init will add the following:

bin scripts: bin/run.js, bin/run.cmd, bin/dev.js, and bin/dev.cmd
oclif section to package.json with bin, dirname, commands, and topicSeparator set (See Configuring Your CLI for more)
@oclif/core to dependencies in your package.json (if it's not already there)
ts-node to devDependencies in your package.json (if it's not already there)

Once you've initialized oclif, you can use the bin scripts to execute your CLI. You can also use the other oclif commands like oclif generate command and oclif generate hook to start adding new functionality.

❯ oclif init --helpInitialize a new oclif CLIUSAGE  $ oclif init [--bin <value>] [--module-type ESM|CommonJS] [--package-manager npm|yarn|pnpm] [--topic-separator    colons|spaces] [-d <value>] [-y]FLAGS  -d, --output-dir=<value>        Directory to initialize the CLI in.  -y, --yes                       Use defaults for all prompts. Individual flags will override defaults.      --bin=<value>               Supply answer for prompt: Command bin name the CLI will export      --module-type=<option>      Supply answer for prompt: Select a module type                                  <options: ESM|CommonJS>      --package-manager=<option>  Supply answer for prompt: Select a package manager                                  <options: npm|yarn|pnpm>      --topic-separator=<option>  Supply answer for prompt: Select a topic separator                                  <options: colons|spaces>DESCRIPTION  Initialize a new oclif CLI  This will add the necessary oclif bin files, add oclif config to package.json, and install @oclif/core and ts-node.EXAMPLES  Initialize a new CLI in the current directory    $ oclif init  Initialize a new CLI in a different directory    $ oclif init --output-dir "/path/to/existing/project"  Supply answers for specific prompts    $ oclif init --topic-separator colons --bin mycli
Hope you enjoy the new command! If you come across any issues or have any new ideas for this command, head over to the oclif/oclif repo and open a new issue.
All our best,
The oclif teamoclif Spring 2024 UpdateMarch 29, 2024 · 4 min readHello oclif developers! It's been a while since we last uploaded a blog - and a lot has happened.
We've been focusing on these high-level areas over the past couple of years:

Improving @oclif/core
ESM Support
Improving and revitalizing oclif.io
Re-engaging the oclif community

Improving @oclif/core​
Since we announced @oclif/core over three years ago, we've released two new major versions, each packed with lots of features that we're really excited about.
Here are some of these changes:

Full support for ESM and interoperability with CommonJS (more on this topic below).
Configurable command discovery strategies that give you more control over how commands are loaded at runtime. Check out the docs.
A new preparse hook that allows you to manipulate the provided arguments before they're parsed. Salesforce used this hook to implement a neat --flags-dir feature that translates local files into flags.
A new Performance class that you can use to track performance inside of @oclif/core and your own CLI or plugin. Check out the docs.
A new flag type, Flags.option, that lets you define a flag with a preset list of options. Typescript then uses the options to infer the flag's type.
Flags now have a relationship property that allows you to define more complex relationships between flags. Check out the flags docs for more information.
Flags now have a defaultHelp property that allows you to set the human readable default value in the command help. This property is useful when your flag's parse method returns a complex type, such as an object or a class. Check out the flags docs for more.
Commands now have a hiddenAliases property that allows you to define aliases that you want to hide from the user. The property is super helpful when you're trying to wean users off a deprecated command.
You can now use bun or tsx as dev runtimes (as opposed to node or ts-node).
A command's usage, args, and flags are now shown whenever a user forgets to provide a required arg or flag, or when they provided a non-existent flag.

If you need help migrating to the latest version, head over to core's README which has links to the migration guides. Feel free to open a new discussion if you need more hands-on help from us or the community.
ESM Support​
Version 3 of @oclif/core introduced full support for developing ESM plugins and CLIs. It also offered full support for interoperability between CommonJS and ESM plugins.
Put more simply, you can now migrate your CLI to ESM while keeping individual plugins in CommonJS (or vice versa). The upgrade path is now much simpler for you. You also don't need to worry about any community plugins that have migrated to ESM before you did (such as all the @oclif plugins) or are staunchly sticking with CommonJS for the foreseeable future.
Read more about this topic here.
Improving and Revitalizing oclif.io​
Another area of focus for us has been improving our documentation site, oclif.io.
While improving the quality and accuracy of the documentation was our priority, we also took the time to upgrade to the latest version of docusaurus. This new version gave our site a much-needed facelift, as well as cool new features such as dark mode and announcements.
If you have any feedback or are running into issues, we want to hear about it. Just create an issue in the oclif.io repo.
Re-engaging the oclif Community​
Lastly, our biggest priority at the moment is to re-engage the oclif community. We understand how frustrating it has been over the years to see your issues and pull requests go unacknowledged. We apologize for not prioritizing the community, and are earnestly trying to make sure that every issue and pull request gets the attention it deserves going forward.
We also opened up GitHub discussions for @oclif/core and the oclif CLI, where you can now post your questions or ideas. We hope you take advantage of them, we love hearing from you!
One last thing: we intend to publicly post our roadmap so you have more visibility into what we're working on. Stay tuned!
All our best,
The oclif teamAnnouncing oclif v2!January 12, 2022 · 5 min readHello and happy new year! It's our great pleasure to announce that we have released oclif v2, which uses the new @oclif/core library! 🎉
oclif v2 includes many changes that improve the experience of both creating and using an oclif CLI.
Going forward, we don't plan to make any updates to oclif v1 and its corresponding libraries, except for critical security fixes. See the compatibility matrix for a list of these libraries. In order to give developers time to migrate from v1 to v2, we're not completely dropping support yet. But at some point in the future we'll archive the v1 repositories and deprecate their versions on npm.
What’s changing?​
Repository Changes​
All repositories under the oclif org now use main as their primary branch and oclif-v1 as the legacy branch. The main  branch corresponds to oclif v2 and the oclif-v1 branch to oclif v1. If you find any repos that don’t have a main branch, you can safely assume that they're not used in oclif v2 and will be deprecated in the future.
Consolidating Tools & Libraries​
The oclif-dev CLI has now been incorporated into oclif. You now no longer need to install a separate package to manage your entire CLI’s lifecycle.
The following libraries have been consolidated under @oclif/core and will be deprecated at some point in the future. Read the migration guide to learn how to update your CLI or plugin to use the new core library.

@oclif/command
@oclif/config
@oclif/error
@oclif/help
@oclif/parser

No more single vs multi command CLIs​
There's only one "type" of oclif v2 CLI, but it can have as few or as many commands as a developer wants. As a result, there’s only one command to generate CLIs, oclif generate, as opposed to the old oclif single and oclif multi commands.
Node > 12​
To ensure oclif CLIs are as secure as possible, all v2 libraries and plugins support only Node 12 or higher as of now. Going forward, they'll support only Node Maintenance or higher, as defined by Node's release schedule here: https://nodejs.org/en/about/releases/.
What’s new?​
New example CLI​
oclif-hello-world is our new example repo. This is also the repo that's used as a template when running oclif generate to create a new CLI. This repo will always be able to be referenced as an example of what an oclif v2 CLI should look like.
Spaced commands​
oclif CLIs can now use spaces, instead of colons, to separate topics and subcommands. To enable this feature, simply add “topicSeparator": " " to the oclif config in your package.json. See an example in our example repo.
// Old commands that use :$ mycli do:something
// New spaced commands$ mycli do something

Note: Spaced commands are backwards compatible. So if you enable spaced commands for your CLI, users will still be able to use : as a separator. This ensures that any existing scripts don't break.

New Help Output​
We’ve revamped the way command help is outputted to the terminal, making it both easier to implement and easier to read. See the difference between the old help output on the left and the new help output on the right in the screenshots below.
oclif v1oclif v2
Notice that there are new sections for flags and global flags, examples are displayed with better spacing, and there is a section at the bottom called Configuration Variables. This Configuration Variables section is not part of the new help by default. But we've added support for custom help sections, which is what the sf CLI uses to create the new section.
Async Command Parsing​
We’ve also improved the performance of new CLIs by rewriting how commands are parsed on initialization. The new parser is asynchronous, which makes CLIs with a lot of commands or installed  plugins much faster.
What’s coming next?​
Part of our charter for the release of oclif v2 includes improving our engagement with the oclif community. We know that over the past couple of years we’ve reduced our involvement, and a lot of issues and PRs have languished in limbo. Hopefully you’ve already seen increased activity and responses from oclif maintainers recently, but if you haven’t, please don’t hesitate to ping us by tagging @admins in oclif repos.
We also want to start interviewing members of the oclif community to acquire feedback and prioritize the features and fixes you deem most important!
Best,
The oclif team

Reference material​
Migration Guide​
This guide explains how to upgrade a CLI or plugin from the old oclif v1 libraries to the new @oclif/core library that oclif v2 uses.
https://github.com/oclif/core/blob/main/MIGRATION.md
Compatibility Matrix​
The following matrix shows how the v1 libraries and plugins relate to the new v2 ones. Use this matrix as a guide to know what to drop and which versions to switch when upgrading your plugins and CLIs to v2.
oclif "v1"oclif "v2"Utility CLIsoclif@<2@oclif/dev-cli@<2oclif@>=2Main packages@oclif/command@oclif/config@oclif/errors@oclif/parser@oclif/plugin-help@oclif/core@>=1Node LTSNode v8-14Node v12+ (at time of writing)TypeScripttypescript@<4typescript@>=4Main plugins@oclif/plugin-autocomplete@<1@oclif/plugin-commands@<2@oclif/plugin-help@<4@oclif/plugin-not-found@<2@oclif/plugin-plugins@<2@oclif/plugin-update@<2plugin-warn-if-update-available@<2plugin-which@<2@oclif/plugin-autocomplete@>=1@oclif/plugin-commands@>=2@oclif/plugin-help@>=4@oclif/plugin-not-found@>=2@oclif/plugin-plugins@>=2@oclif/plugin-update@>=2@oclif/plugin-warn-if-update-available@>=2@oclif/plugin-which@>=2Introducing @oclif/coreMarch 1, 2021 · 3 min readGreetings!
We hope this blog post finds you well.
Introducing...​
We are excited to announce the next iteration of the oclif project today: @oclif/core.
We have learned a lot in the last three years of developing oclif, developing on oclif and supporting millions of command runs a day via Heroku and Salesforce CLIs.
@oclif/core ("Core") simplifies the oclif development experience and introduces highly requested new features.
Core combines the essential oclif packages into one "core" package, aptly named @oclif/core.
Core also introduces:

A default command option
Colon or space command syntax
Async command parsing
Command piping to arguments

With the introduction of default command functionality, Core simplifies the oclif project and removes the notion of single or multi command CLIs. Core CLIs can have 1 or many commands.
Along with Core, we moved the oclif-dev CLI into the oclif CLI creating a single "utility" CLI. This CLI also introduces a new AWS S3 compatible publishing scheme.
What to expect in the near future​
Core is in pre-release beta and being actively developed for new internal Salesforce CLIs.
Much documentation needs to be written in the coming months including migration paths. Migration onto Core should be as painless as possible with many exports remaining entirely unchanged. Look for forthcoming blog posts and documentation on oclif.io.
Early this summer, tentively June 1, we will release Core v1. Core's release will coincide with major bumps to many other oclif plugin packages. See the compatibility matrix below.
At Core's v1 release, the current "main" oclif packages (namely: command, config, errors & parser) will go into maintenance mode until Jan 2022. They will receive only bug and security fixes and they remain compatible with current versions of the oclif and oclif-dev CLIs. Afterwhich, they will be archived.
Companioning Core, the next major release of the oclif CLI (literally oclif@2) will generate Core CLIs.
Going forward​
We are excited to release Core! We invite you to poke around the Core repo. It may appear to be a big change but Core keeps what you already enjoy about oclif while reducing development complexity, project dependencies, package coupling and bundle size and introduces many requested features previously too prickly to weave into the current oclif architecture.
Best,
The oclif team
Reference: Compatibility matrix​
oclif "v1"oclif "Core"Utility CLIsoclif@<2@oclif/dev-cli@<2oclif@>=2Main packages@oclif/core@<2@oclif/config@<2@oclif/errors@<2@oclif/parser@<4@oclif/plugin-help@<4@oclif/core@>=1Node LTSNode v8-14Node v12+TypeScripttypescript@<4typescript@>=4Main plugins@oclif/plugin-autocomplete@<1@oclif/plugin-commands@<2@oclif/plugin-help@<4@oclif/plugin-not-found@<2@oclif/plugin-plugins@<2@oclif/plugin-update@<2plugin-warn-if-update-available@<2plugin-which@<2@oclif/plugin-autocomplete@>=2@oclif/plugin-commands@>=2@oclif/plugin-help@>=4@oclif/plugin-not-found@>=2@oclif/plugin-plugins@>=2@oclif/plugin-update@>=2@oclif/plugin-warn-if-update-available@>=2@oclif/plugin-which@>=2oclif Summer 2020 UpdateAugust 26, 2020 · 2 min readHello oclif developers! We hope you are all doing well.
Earlier this year, we started our planning for oclifconf v2 and, like all conference, had to change course. We opted not to hold a virtual conference, however, we wanted to take some time to highlight a few oclif features shipped this year.
Feature: Help templating​
One of the most requested features, help templating enables oclif developers to customize the help output for their CLI.
Read the announcement.
Feature: Custom error delegation​
This feature both improved how oclif throws and handles errors and allows oclif developers to overwrite or interject in oclif’s error handling.
Read the announcement.
Feature: postrun hooks​
We have added a new lifecycle event postrun. Your CLI can now run a hook after a command has ran.
See our hook documentation.
Feature: Root index command​
Previously, oclif would display CLI help if only the binary name with no command ID was invoked, oclif now supports a "root index" command. If present, a command defined at src/commands/index.ts will be run if no command ID is found.
1 million weekly downloads​
While exact oclif usage metrics are hard to pin down, we use npm download statistics of oclif packages as a rough approximation. Earlier this year, oclif's command package hit 1 million weekly downloads for the first time!
This year has been presented its challenges on everyone. We want to thank you, oclif developers, whom have taken the time to use and improve the oclif project. We look forward to seeing you all - in person - in the future!
All our best,
The oclif teamPretty Printable ErrorsJuly 1, 2020 · One min readOften CLIs are used as handy tools and when things go wrong it’s useful to have additional context. In oclif we have added a couple of additional properties that can show extra context to the users when an error is displayed. The code, ref and suggestions will now be displayed if they are included. This will work with an existing oclif CLI by adding the latest @oclif/errors and @oclif/core to the CLI's package.json dependencies.
For example, using this.error with the additional properties:
class TestError extends Command {  async run() {    this.error("An error has occurred!", {      code: "OCLIF_ERR",      ref: "https://oclif.io/docs/commands#thiserrormessage-string--error-options-code-string-exit-number",      suggestions: ["Use these extra properties to provide additional context"],    })  }}
would result with the following output:
›   Error: An error has occurred!›   Code: OCLIF_ERR›   Try this: Use these extra properties to provide additional context›   Reference: https://oclif.io/docs/commands#thiserrormessage-string--error-options-code-string-exit-number
If these properties are not provided then nothing changes and the CLI will continue to display the single error message output as it did before. Additionally, as part of this exercise we’ve added documentation around Error Handling in oclif which should come in handy if the need arises to extend oclif’s default handling of errors.Customizing Help in oclifMay 5, 2020 · 2 min readOut of the box oclif provides a great help experience for CLIs.
But what if, as an oclif developer, you want to customize some or all of the output?
You can now customize your CLI's help output by implementing the HelpBase abstract class.
Getting started with custom help​
If you have not done so yet, update @oclif/core.
$ yarn add --latest @oclif/core
To get started, first define the filepath to your help class in oclif's config in package.json. This is a relative path to the help class, without a file extension.
For this example, the help class will be created in a file at "[project root]/src/help.ts".
{  // ...  "oclif": {    "helpClass": "./lib/help"    // ...  }  // ...}
From here there are two paths, implement the HelpBase abstract class yourself or overwrite the parts of the default Help class you want to customize (ex: how command usage is displayed). We recommend the latter approach but cover both in the new Help Classes docs.
Separating TOPICS & COMMANDS in the new default Help class​
Previously, topics and child commands were listed in help output under a single list heading called "COMMANDS". But we found this can be slightly confusing. Some topics are commands also (a.k.a. topic-commands) while others are simply organizational namespacing (and when ran just show their help).
The new default Help class splits the list of children into distinct lists of "TOPICS" and "COMMANDS", with the possibility of an item appearing in both if it a topic-command. This makes it clearer what is expected to be ran - "COMMANDS" - and what is providing structure - "TOPICS" - when looking at the help output.
VERSION  plugin-help-example/0.0.0 darwin-x64 node-v12.12.0USAGE  $ plugin-help-example [COMMAND]TOPICS  topic  this is a topic and has child topics or commandsCOMMANDS  hello  describe the command here  help   display help for plugin-help-example
We look forward to seeing what custom help features you implement in your oclif CLIs with this new feature!oclif TSLint to ESLint MigrationDecember 5, 2019 · 3 min readBack in February of this year, plans were announced to deprecate TSLint in favor of ESLint. TSLint's goal has become to work toward a “unified developer experience” by supporting ESLint development going forward.
What has changed in oclif​
To keep inline with the community, oclif has transitioned to ESLint for all our core libraries as well as all our official plugins.
Starting in v1.15.x, oclif will now optionally generate projects with ESLint for both TypeScript and JavaScript CLI’s.
ESLint does require Node to be on stable LTS version, at the time of writing, Node 8.10.x, Node 10.13.x & Node 12.x.x.
How does this affect you​
Existing CLI’s are unchanged, but any newly generated CLI's will only give the option of using ESLint. If you are running tslint in your CLI, we recommend you switch to ESLint as well.
In migrating our projects we took the following steps (for an example of these changes see this pull request).


Install eslint
$ yarn add eslint eslint-config-oclif eslint-config-oclif-typescript --dev


Add eslint related files


$ echo '{  "extends": [    "oclif",    "oclif-typescript"  ],  "rules": {  }}' > .eslintrc


Remove tslint and related packages
$ yarn remove @oclif/tslint tslint


Remove tslint related configuration files
$ rm tslint.json


Change lint script in our package.json from something like:
"lint": "tsc -p test --noEmit && tslint -p test -t stylish"
to
"lint": "eslint . --ext .ts --config .eslintrc"


To preserve the test compile (tsc -p test --noEmit) we also made the following updates to our scripts:
"pretest": "tsc -p test --noEmit"
In some cases we had our posttest duplicating the same steps as our lint script so it’s cleaner to have it reference the lint job directly with:
"posttest": "yarn lint"

Run yarn lint --fix. This attempts to auto-fix any linting violations automatically. In the case an auto-fix isn’t available it should be fixed manually or ignored (see the eslint configuration doc for more information)
Do a search in the codebase for tslint and remove any unnecessary tslint disabling comments, like:

/* tslint:disable:object-literal-sort-keys */
If you are on a version of Node that is not supported by ESLint, you will also need to update your Node engine. ESLint supports Node 8, 10, and 12 so you should upgrade to the most recent Node version compatible with your CLI and also supported by ESLint (see ESLint's Installation and Usage instructions).
When will this take effect​
These changes have taken effect in oclif v1.15.1. When you generate a new CLI or plugin it will now contain configuration for ESLint instead of TSLint.oclif's Current Node SupportOctober 31, 2019 · 3 min readTo maintain a healthy project trajectory, oclif follows and supports Node Active LTS release, currently Node 10 & Node 12. This means ensuring that oclif continues to play nice with coming Active LTS Node versions and other packages in the ecosystem. Moving forward also means leaving older versions behind. Starting in 2020, Node will stop maintaining Node 8 and it is our intent at that time to also follow suit. Let’s take a look at a few ways we will be supporting these changes.
CI Environments​
CLIs created with the oclif cli going forward will be generated with a CircleCI configuration with Node 10 & 12 and an Appveyor configuration using Node 10. We have also added Node latest to CircleCi to be an early warning detection against coming Node changes (Node latest is managed by CircleCI).
We have already updated every oclif repo's CI configs to reflect this.
If your existing CLI uses either Appveyor or CircleCI you can update your config files also, like so:
.circleci/config.yml​
Your CircleCI config should contain a node-latest job, aliased as test. From this, there should be two extensions of this job for the Active LTS Node versions, Node 10 and Node 12.
  node-10:    <<: *node-latest    docker:      - image: node:10  node-12:    <<: *node-latest    docker:      - image: node:12
Notice that these declarations only change the Docker Node images used to run that job.
Additionally, the jobs listed within workflows must also be updated to reflect our changes in configuration:
    jobs:      - node-latest      - node-10      - node-12
appveyor.yml​
For appveyor we are currently only testing the oldest Active LTS Node version, Node 10. Update the nodejs_version proppert in your appveyor.yml file to reflect this.
environment:  nodejs_version: "10"
Deprecating Node 8 & Updating packge.json engines​
In Jan 2020, Node will end its Node 8 maintenance. We will follow suit by setting the package.json engine property in oclif packages to >=10 and bumping the package's major versions.
Depending on how you ship your CLI you may wish to also bump the engines version in your CLI's package.json. You can read more about the implications of the engines property configuration in the npm documentation.
Also consider distributing your CLI with its own Node version.
Packaged Node Version​
When using dev-cli to pack your CLI it will use the Node version as specified in your package.json under the oclif.update.node.version property. This value should reflect an Active LTS Node version (dev-cli does not currently enforce versions).
Supporting the future​
As a community we may discover bumps along the way as we upgrade. If you notice something related to oclif please feel free to open an issue or submit a pull request under the relevant oclif package within the org.
We look forward to using the latest from Node and the community and keeping oclif healthy along the way.oclifconf 2019: A RecapSeptember 16, 2019 · 4 min readIn May, Heroku and Salesforce Open Source organized oclifconf, a conference for developers & product managers building CLI tools on top of the open source oclif framework. The speakers came from various tech companies, such as Adobe, Netlify, and Apollo, who have already built amazing CLI experiences. The topics covered everything from the incredible capabilities oclif has unlocked, to the community-built plugins extending its functionality, and even what the behavior of an adaptive CLI tool might look like.
Below is a listing of all of the talks from the event, along with a short summary. Enjoy!
The future of oclif by Jeff Dickey​

In its relatively short lifetime, oclif has already inspired many developers and companies to adopt its framework as a means for implementing their own command-line tooling. In this talk, Jeff Dickey, an oclif founding team member, recaps the project's history and inspiration. He also looks towards the future and outlines some features and improvements that the tool could adapt. This isn't so much a definitive roadmap of where oclif is headed, but rather, a call to inspiration for developers eager to contribute! And if you are interested in contributing, check out the open issues in the oclif GitHub repo and come say "Hello!" on Spectrum Chat.
Open Source Citizenship by Josh Simmons​

When it comes to open source, it's more than just individuals now. More and more frequently, large corporations are contributing to projects by donating to contributors, sponsoring events, or upstreaming contributions. But keeping open source projects and communities healthy requires more than just money and brainpower. Josh Simmons surveyed multiple open source communities and relays his findings as to what help maintainers and contributors actually need in this talk.
Building an enterprise-grade CLI with oclif by Thomas Dvornik​

Security and performance are all about trust. While oclif is an extremely extensible framework for building CLI tooling, there are additional requirements to fulfill for enterprise businesses to adopt it that might not be necessary for individual developers. Thomas Dvornik outlines what he and his colleagues at Salesforce have implemented as plugins to oclif to satisfy these needs, including encrypted OAuth, plugin signing, lazy loading dependencies, synchronizing weekly releases and deprecations across dozens of repositories, and establishing cross-team coding and documentation standards.
How Adobe I/O built an extensible CLI with oclif by Jesse MacFadyen​

Perhaps oclif's most appealing feature is its support for plugins. In Cordova's case, they've created a sophisticated telemetry system that helps Adobe developers see which commands users are using--and reports on which ones are erroring out. By embedding a feedback system into the tool, users are even able to quickly send their suggestions to a form, without ever leaving the terminal. Jesse MacFadyen demonstrates how oclif's plugin system can work beyond simply executing commands.
Integrating oclif with GraphQL and Apollo by Evans Hauser​

For Evans Hauser and the team at Apollo, oclif is best thought of as "React for the CLI." As a client paired with a strongly-typed API contract to a server, it can deliver structured and consistent commands to retrieve external data. What better mechanism to use for this transfer than GraphQL, a framework which empowers the client to ask precisely for the data it needs, and nothing more?
Adaptive Intent-based CLI State Machines by Shawn Wang​

In designing oclif, Jeff Dickey wrote out 12 CLI factors to keep in mind. In this talk, Shawn Wang outlines a 13th: state. State is hard, because it depends on context, and context depends on understanding what a user intends to do, not what they are asking. Shawn is working towards enabling oclif to better understand the commands a user has entered, so that it can predict and interpret future commands that might be entered next. This would enable CLI tools to not just interpret a users' commands, but to also interpret their intent.Older Entries\n\n\n\nIntroducing `oclif init` commandApril 10, 2024 · 2 min readThanks to the contribution of @joshcanhelp we released a new command for the oclif CLI called oclif init in version 4.8.0
The oclif init command allows you to initialize oclif in an existing project directory by adding the bare minimum requirements: a few pieces of configuration, bin scripts, and a couple of dependencies (@oclif/core and ts-node). This is slightly different from oclif generate, which will create an entirely new oclif project based on our templates.
oclif init will add the following:

bin scripts: bin/run.js, bin/run.cmd, bin/dev.js, and bin/dev.cmd
oclif section to package.json with bin, dirname, commands, and topicSeparator set (See Configuring Your CLI for more)
@oclif/core to dependencies in your package.json (if it's not already there)
ts-node to devDependencies in your package.json (if it's not already there)

Once you've initialized oclif, you can use the bin scripts to execute your CLI. You can also use the other oclif commands like oclif generate command and oclif generate hook to start adding new functionality.

❯ oclif init --helpInitialize a new oclif CLIUSAGE  $ oclif init [--bin <value>] [--module-type ESM|CommonJS] [--package-manager npm|yarn|pnpm] [--topic-separator    colons|spaces] [-d <value>] [-y]FLAGS  -d, --output-dir=<value>        Directory to initialize the CLI in.  -y, --yes                       Use defaults for all prompts. Individual flags will override defaults.      --bin=<value>               Supply answer for prompt: Command bin name the CLI will export      --module-type=<option>      Supply answer for prompt: Select a module type                                  <options: ESM|CommonJS>      --package-manager=<option>  Supply answer for prompt: Select a package manager                                  <options: npm|yarn|pnpm>      --topic-separator=<option>  Supply answer for prompt: Select a topic separator                                  <options: colons|spaces>DESCRIPTION  Initialize a new oclif CLI  This will add the necessary oclif bin files, add oclif config to package.json, and install @oclif/core and ts-node.EXAMPLES  Initialize a new CLI in the current directory    $ oclif init  Initialize a new CLI in a different directory    $ oclif init --output-dir "/path/to/existing/project"  Supply answers for specific prompts    $ oclif init --topic-separator colons --bin mycli
Hope you enjoy the new command! If you come across any issues or have any new ideas for this command, head over to the oclif/oclif repo and open a new issue.
All our best,
The oclif teamoclif Spring 2024 UpdateMarch 29, 2024 · 4 min readHello oclif developers! It's been a while since we last uploaded a blog - and a lot has happened.
We've been focusing on these high-level areas over the past couple of years:

Improving @oclif/core
ESM Support
Improving and revitalizing oclif.io
Re-engaging the oclif community

Improving @oclif/core​
Since we announced @oclif/core over three years ago, we've released two new major versions, each packed with lots of features that we're really excited about.
Here are some of these changes:

Full support for ESM and interoperability with CommonJS (more on this topic below).
Configurable command discovery strategies that give you more control over how commands are loaded at runtime. Check out the docs.
A new preparse hook that allows you to manipulate the provided arguments before they're parsed. Salesforce used this hook to implement a neat --flags-dir feature that translates local files into flags.
A new Performance class that you can use to track performance inside of @oclif/core and your own CLI or plugin. Check out the docs.
A new flag type, Flags.option, that lets you define a flag with a preset list of options. Typescript then uses the options to infer the flag's type.
Flags now have a relationship property that allows you to define more complex relationships between flags. Check out the flags docs for more information.
Flags now have a defaultHelp property that allows you to set the human readable default value in the command help. This property is useful when your flag's parse method returns a complex type, such as an object or a class. Check out the flags docs for more.
Commands now have a hiddenAliases property that allows you to define aliases that you want to hide from the user. The property is super helpful when you're trying to wean users off a deprecated command.
You can now use bun or tsx as dev runtimes (as opposed to node or ts-node).
A command's usage, args, and flags are now shown whenever a user forgets to provide a required arg or flag, or when they provided a non-existent flag.

If you need help migrating to the latest version, head over to core's README which has links to the migration guides. Feel free to open a new discussion if you need more hands-on help from us or the community.
ESM Support​
Version 3 of @oclif/core introduced full support for developing ESM plugins and CLIs. It also offered full support for interoperability between CommonJS and ESM plugins.
Put more simply, you can now migrate your CLI to ESM while keeping individual plugins in CommonJS (or vice versa). The upgrade path is now much simpler for you. You also don't need to worry about any community plugins that have migrated to ESM before you did (such as all the @oclif plugins) or are staunchly sticking with CommonJS for the foreseeable future.
Read more about this topic here.
Improving and Revitalizing oclif.io​
Another area of focus for us has been improving our documentation site, oclif.io.
While improving the quality and accuracy of the documentation was our priority, we also took the time to upgrade to the latest version of docusaurus. This new version gave our site a much-needed facelift, as well as cool new features such as dark mode and announcements.
If you have any feedback or are running into issues, we want to hear about it. Just create an issue in the oclif.io repo.
Re-engaging the oclif Community​
Lastly, our biggest priority at the moment is to re-engage the oclif community. We understand how frustrating it has been over the years to see your issues and pull requests go unacknowledged. We apologize for not prioritizing the community, and are earnestly trying to make sure that every issue and pull request gets the attention it deserves going forward.
We also opened up GitHub discussions for @oclif/core and the oclif CLI, where you can now post your questions or ideas. We hope you take advantage of them, we love hearing from you!
One last thing: we intend to publicly post our roadmap so you have more visibility into what we're working on. Stay tuned!
All our best,
The oclif teamAnnouncing oclif v2!January 12, 2022 · 5 min readHello and happy new year! It's our great pleasure to announce that we have released oclif v2, which uses the new @oclif/core library! 🎉
oclif v2 includes many changes that improve the experience of both creating and using an oclif CLI.
Going forward, we don't plan to make any updates to oclif v1 and its corresponding libraries, except for critical security fixes. See the compatibility matrix for a list of these libraries. In order to give developers time to migrate from v1 to v2, we're not completely dropping support yet. But at some point in the future we'll archive the v1 repositories and deprecate their versions on npm.
What’s changing?​
Repository Changes​
All repositories under the oclif org now use main as their primary branch and oclif-v1 as the legacy branch. The main  branch corresponds to oclif v2 and the oclif-v1 branch to oclif v1. If you find any repos that don’t have a main branch, you can safely assume that they're not used in oclif v2 and will be deprecated in the future.
Consolidating Tools & Libraries​
The oclif-dev CLI has now been incorporated into oclif. You now no longer need to install a separate package to manage your entire CLI’s lifecycle.
The following libraries have been consolidated under @oclif/core and will be deprecated at some point in the future. Read the migration guide to learn how to update your CLI or plugin to use the new core library.

@oclif/command
@oclif/config
@oclif/error
@oclif/help
@oclif/parser

No more single vs multi command CLIs​
There's only one "type" of oclif v2 CLI, but it can have as few or as many commands as a developer wants. As a result, there’s only one command to generate CLIs, oclif generate, as opposed to the old oclif single and oclif multi commands.
Node > 12​
To ensure oclif CLIs are as secure as possible, all v2 libraries and plugins support only Node 12 or higher as of now. Going forward, they'll support only Node Maintenance or higher, as defined by Node's release schedule here: https://nodejs.org/en/about/releases/.
What’s new?​
New example CLI​
oclif-hello-world is our new example repo. This is also the repo that's used as a template when running oclif generate to create a new CLI. This repo will always be able to be referenced as an example of what an oclif v2 CLI should look like.
Spaced commands​
oclif CLIs can now use spaces, instead of colons, to separate topics and subcommands. To enable this feature, simply add “topicSeparator": " " to the oclif config in your package.json. See an example in our example repo.
// Old commands that use :$ mycli do:something
// New spaced commands$ mycli do something

Note: Spaced commands are backwards compatible. So if you enable spaced commands for your CLI, users will still be able to use : as a separator. This ensures that any existing scripts don't break.

New Help Output​
We’ve revamped the way command help is outputted to the terminal, making it both easier to implement and easier to read. See the difference between the old help output on the left and the new help output on the right in the screenshots below.
oclif v1oclif v2
Notice that there are new sections for flags and global flags, examples are displayed with better spacing, and there is a section at the bottom called Configuration Variables. This Configuration Variables section is not part of the new help by default. But we've added support for custom help sections, which is what the sf CLI uses to create the new section.
Async Command Parsing​
We’ve also improved the performance of new CLIs by rewriting how commands are parsed on initialization. The new parser is asynchronous, which makes CLIs with a lot of commands or installed  plugins much faster.
What’s coming next?​
Part of our charter for the release of oclif v2 includes improving our engagement with the oclif community. We know that over the past couple of years we’ve reduced our involvement, and a lot of issues and PRs have languished in limbo. Hopefully you’ve already seen increased activity and responses from oclif maintainers recently, but if you haven’t, please don’t hesitate to ping us by tagging @admins in oclif repos.
We also want to start interviewing members of the oclif community to acquire feedback and prioritize the features and fixes you deem most important!
Best,
The oclif team

Reference material​
Migration Guide​
This guide explains how to upgrade a CLI or plugin from the old oclif v1 libraries to the new @oclif/core library that oclif v2 uses.
https://github.com/oclif/core/blob/main/MIGRATION.md
Compatibility Matrix​
The following matrix shows how the v1 libraries and plugins relate to the new v2 ones. Use this matrix as a guide to know what to drop and which versions to switch when upgrading your plugins and CLIs to v2.
oclif "v1"oclif "v2"Utility CLIsoclif@<2@oclif/dev-cli@<2oclif@>=2Main packages@oclif/command@oclif/config@oclif/errors@oclif/parser@oclif/plugin-help@oclif/core@>=1Node LTSNode v8-14Node v12+ (at time of writing)TypeScripttypescript@<4typescript@>=4Main plugins@oclif/plugin-autocomplete@<1@oclif/plugin-commands@<2@oclif/plugin-help@<4@oclif/plugin-not-found@<2@oclif/plugin-plugins@<2@oclif/plugin-update@<2plugin-warn-if-update-available@<2plugin-which@<2@oclif/plugin-autocomplete@>=1@oclif/plugin-commands@>=2@oclif/plugin-help@>=4@oclif/plugin-not-found@>=2@oclif/plugin-plugins@>=2@oclif/plugin-update@>=2@oclif/plugin-warn-if-update-available@>=2@oclif/plugin-which@>=2Introducing @oclif/coreMarch 1, 2021 · 3 min readGreetings!
We hope this blog post finds you well.
Introducing...​
We are excited to announce the next iteration of the oclif project today: @oclif/core.
We have learned a lot in the last three years of developing oclif, developing on oclif and supporting millions of command runs a day via Heroku and Salesforce CLIs.
@oclif/core ("Core") simplifies the oclif development experience and introduces highly requested new features.
Core combines the essential oclif packages into one "core" package, aptly named @oclif/core.
Core also introduces:

A default command option
Colon or space command syntax
Async command parsing
Command piping to arguments

With the introduction of default command functionality, Core simplifies the oclif project and removes the notion of single or multi command CLIs. Core CLIs can have 1 or many commands.
Along with Core, we moved the oclif-dev CLI into the oclif CLI creating a single "utility" CLI. This CLI also introduces a new AWS S3 compatible publishing scheme.
What to expect in the near future​
Core is in pre-release beta and being actively developed for new internal Salesforce CLIs.
Much documentation needs to be written in the coming months including migration paths. Migration onto Core should be as painless as possible with many exports remaining entirely unchanged. Look for forthcoming blog posts and documentation on oclif.io.
Early this summer, tentively June 1, we will release Core v1. Core's release will coincide with major bumps to many other oclif plugin packages. See the compatibility matrix below.
At Core's v1 release, the current "main" oclif packages (namely: command, config, errors & parser) will go into maintenance mode until Jan 2022. They will receive only bug and security fixes and they remain compatible with current versions of the oclif and oclif-dev CLIs. Afterwhich, they will be archived.
Companioning Core, the next major release of the oclif CLI (literally oclif@2) will generate Core CLIs.
Going forward​
We are excited to release Core! We invite you to poke around the Core repo. It may appear to be a big change but Core keeps what you already enjoy about oclif while reducing development complexity, project dependencies, package coupling and bundle size and introduces many requested features previously too prickly to weave into the current oclif architecture.
Best,
The oclif team
Reference: Compatibility matrix​
oclif "v1"oclif "Core"Utility CLIsoclif@<2@oclif/dev-cli@<2oclif@>=2Main packages@oclif/core@<2@oclif/config@<2@oclif/errors@<2@oclif/parser@<4@oclif/plugin-help@<4@oclif/core@>=1Node LTSNode v8-14Node v12+TypeScripttypescript@<4typescript@>=4Main plugins@oclif/plugin-autocomplete@<1@oclif/plugin-commands@<2@oclif/plugin-help@<4@oclif/plugin-not-found@<2@oclif/plugin-plugins@<2@oclif/plugin-update@<2plugin-warn-if-update-available@<2plugin-which@<2@oclif/plugin-autocomplete@>=2@oclif/plugin-commands@>=2@oclif/plugin-help@>=4@oclif/plugin-not-found@>=2@oclif/plugin-plugins@>=2@oclif/plugin-update@>=2@oclif/plugin-warn-if-update-available@>=2@oclif/plugin-which@>=2oclif Summer 2020 UpdateAugust 26, 2020 · 2 min readHello oclif developers! We hope you are all doing well.
Earlier this year, we started our planning for oclifconf v2 and, like all conference, had to change course. We opted not to hold a virtual conference, however, we wanted to take some time to highlight a few oclif features shipped this year.
Feature: Help templating​
One of the most requested features, help templating enables oclif developers to customize the help output for their CLI.
Read the announcement.
Feature: Custom error delegation​
This feature both improved how oclif throws and handles errors and allows oclif developers to overwrite or interject in oclif’s error handling.
Read the announcement.
Feature: postrun hooks​
We have added a new lifecycle event postrun. Your CLI can now run a hook after a command has ran.
See our hook documentation.
Feature: Root index command​
Previously, oclif would display CLI help if only the binary name with no command ID was invoked, oclif now supports a "root index" command. If present, a command defined at src/commands/index.ts will be run if no command ID is found.
1 million weekly downloads​
While exact oclif usage metrics are hard to pin down, we use npm download statistics of oclif packages as a rough approximation. Earlier this year, oclif's command package hit 1 million weekly downloads for the first time!
This year has been presented its challenges on everyone. We want to thank you, oclif developers, whom have taken the time to use and improve the oclif project. We look forward to seeing you all - in person - in the future!
All our best,
The oclif teamPretty Printable ErrorsJuly 1, 2020 · One min readOften CLIs are used as handy tools and when things go wrong it’s useful to have additional context. In oclif we have added a couple of additional properties that can show extra context to the users when an error is displayed. The code, ref and suggestions will now be displayed if they are included. This will work with an existing oclif CLI by adding the latest @oclif/errors and @oclif/core to the CLI's package.json dependencies.
For example, using this.error with the additional properties:
class TestError extends Command {  async run() {    this.error("An error has occurred!", {      code: "OCLIF_ERR",      ref: "https://oclif.io/docs/commands#thiserrormessage-string--error-options-code-string-exit-number",      suggestions: ["Use these extra properties to provide additional context"],    })  }}
would result with the following output:
›   Error: An error has occurred!›   Code: OCLIF_ERR›   Try this: Use these extra properties to provide additional context›   Reference: https://oclif.io/docs/commands#thiserrormessage-string--error-options-code-string-exit-number
If these properties are not provided then nothing changes and the CLI will continue to display the single error message output as it did before. Additionally, as part of this exercise we’ve added documentation around Error Handling in oclif which should come in handy if the need arises to extend oclif’s default handling of errors.Customizing Help in oclifMay 5, 2020 · 2 min readOut of the box oclif provides a great help experience for CLIs.
But what if, as an oclif developer, you want to customize some or all of the output?
You can now customize your CLI's help output by implementing the HelpBase abstract class.
Getting started with custom help​
If you have not done so yet, update @oclif/core.
$ yarn add --latest @oclif/core
To get started, first define the filepath to your help class in oclif's config in package.json. This is a relative path to the help class, without a file extension.
For this example, the help class will be created in a file at "[project root]/src/help.ts".
{  // ...  "oclif": {    "helpClass": "./lib/help"    // ...  }  // ...}
From here there are two paths, implement the HelpBase abstract class yourself or overwrite the parts of the default Help class you want to customize (ex: how command usage is displayed). We recommend the latter approach but cover both in the new Help Classes docs.
Separating TOPICS & COMMANDS in the new default Help class​
Previously, topics and child commands were listed in help output under a single list heading called "COMMANDS". But we found this can be slightly confusing. Some topics are commands also (a.k.a. topic-commands) while others are simply organizational namespacing (and when ran just show their help).
The new default Help class splits the list of children into distinct lists of "TOPICS" and "COMMANDS", with the possibility of an item appearing in both if it a topic-command. This makes it clearer what is expected to be ran - "COMMANDS" - and what is providing structure - "TOPICS" - when looking at the help output.
VERSION  plugin-help-example/0.0.0 darwin-x64 node-v12.12.0USAGE  $ plugin-help-example [COMMAND]TOPICS  topic  this is a topic and has child topics or commandsCOMMANDS  hello  describe the command here  help   display help for plugin-help-example
We look forward to seeing what custom help features you implement in your oclif CLIs with this new feature!oclif TSLint to ESLint MigrationDecember 5, 2019 · 3 min readBack in February of this year, plans were announced to deprecate TSLint in favor of ESLint. TSLint's goal has become to work toward a “unified developer experience” by supporting ESLint development going forward.
What has changed in oclif​
To keep inline with the community, oclif has transitioned to ESLint for all our core libraries as well as all our official plugins.
Starting in v1.15.x, oclif will now optionally generate projects with ESLint for both TypeScript and JavaScript CLI’s.
ESLint does require Node to be on stable LTS version, at the time of writing, Node 8.10.x, Node 10.13.x & Node 12.x.x.
How does this affect you​
Existing CLI’s are unchanged, but any newly generated CLI's will only give the option of using ESLint. If you are running tslint in your CLI, we recommend you switch to ESLint as well.
In migrating our projects we took the following steps (for an example of these changes see this pull request).


Install eslint
$ yarn add eslint eslint-config-oclif eslint-config-oclif-typescript --dev


Add eslint related files


$ echo '{  "extends": [    "oclif",    "oclif-typescript"  ],  "rules": {  }}' > .eslintrc


Remove tslint and related packages
$ yarn remove @oclif/tslint tslint


Remove tslint related configuration files
$ rm tslint.json


Change lint script in our package.json from something like:
"lint": "tsc -p test --noEmit && tslint -p test -t stylish"
to
"lint": "eslint . --ext .ts --config .eslintrc"


To preserve the test compile (tsc -p test --noEmit) we also made the following updates to our scripts:
"pretest": "tsc -p test --noEmit"
In some cases we had our posttest duplicating the same steps as our lint script so it’s cleaner to have it reference the lint job directly with:
"posttest": "yarn lint"

Run yarn lint --fix. This attempts to auto-fix any linting violations automatically. In the case an auto-fix isn’t available it should be fixed manually or ignored (see the eslint configuration doc for more information)
Do a search in the codebase for tslint and remove any unnecessary tslint disabling comments, like:

/* tslint:disable:object-literal-sort-keys */
If you are on a version of Node that is not supported by ESLint, you will also need to update your Node engine. ESLint supports Node 8, 10, and 12 so you should upgrade to the most recent Node version compatible with your CLI and also supported by ESLint (see ESLint's Installation and Usage instructions).
When will this take effect​
These changes have taken effect in oclif v1.15.1. When you generate a new CLI or plugin it will now contain configuration for ESLint instead of TSLint.oclif's Current Node SupportOctober 31, 2019 · 3 min readTo maintain a healthy project trajectory, oclif follows and supports Node Active LTS release, currently Node 10 & Node 12. This means ensuring that oclif continues to play nice with coming Active LTS Node versions and other packages in the ecosystem. Moving forward also means leaving older versions behind. Starting in 2020, Node will stop maintaining Node 8 and it is our intent at that time to also follow suit. Let’s take a look at a few ways we will be supporting these changes.
CI Environments​
CLIs created with the oclif cli going forward will be generated with a CircleCI configuration with Node 10 & 12 and an Appveyor configuration using Node 10. We have also added Node latest to CircleCi to be an early warning detection against coming Node changes (Node latest is managed by CircleCI).
We have already updated every oclif repo's CI configs to reflect this.
If your existing CLI uses either Appveyor or CircleCI you can update your config files also, like so:
.circleci/config.yml​
Your CircleCI config should contain a node-latest job, aliased as test. From this, there should be two extensions of this job for the Active LTS Node versions, Node 10 and Node 12.
  node-10:    <<: *node-latest    docker:      - image: node:10  node-12:    <<: *node-latest    docker:      - image: node:12
Notice that these declarations only change the Docker Node images used to run that job.
Additionally, the jobs listed within workflows must also be updated to reflect our changes in configuration:
    jobs:      - node-latest      - node-10      - node-12
appveyor.yml​
For appveyor we are currently only testing the oldest Active LTS Node version, Node 10. Update the nodejs_version proppert in your appveyor.yml file to reflect this.
environment:  nodejs_version: "10"
Deprecating Node 8 & Updating packge.json engines​
In Jan 2020, Node will end its Node 8 maintenance. We will follow suit by setting the package.json engine property in oclif packages to >=10 and bumping the package's major versions.
Depending on how you ship your CLI you may wish to also bump the engines version in your CLI's package.json. You can read more about the implications of the engines property configuration in the npm documentation.
Also consider distributing your CLI with its own Node version.
Packaged Node Version​
When using dev-cli to pack your CLI it will use the Node version as specified in your package.json under the oclif.update.node.version property. This value should reflect an Active LTS Node version (dev-cli does not currently enforce versions).
Supporting the future​
As a community we may discover bumps along the way as we upgrade. If you notice something related to oclif please feel free to open an issue or submit a pull request under the relevant oclif package within the org.
We look forward to using the latest from Node and the community and keeping oclif healthy along the way.oclifconf 2019: A RecapSeptember 16, 2019 · 4 min readIn May, Heroku and Salesforce Open Source organized oclifconf, a conference for developers & product managers building CLI tools on top of the open source oclif framework. The speakers came from various tech companies, such as Adobe, Netlify, and Apollo, who have already built amazing CLI experiences. The topics covered everything from the incredible capabilities oclif has unlocked, to the community-built plugins extending its functionality, and even what the behavior of an adaptive CLI tool might look like.
Below is a listing of all of the talks from the event, along with a short summary. Enjoy!
The future of oclif by Jeff Dickey​

In its relatively short lifetime, oclif has already inspired many developers and companies to adopt its framework as a means for implementing their own command-line tooling. In this talk, Jeff Dickey, an oclif founding team member, recaps the project's history and inspiration. He also looks towards the future and outlines some features and improvements that the tool could adapt. This isn't so much a definitive roadmap of where oclif is headed, but rather, a call to inspiration for developers eager to contribute! And if you are interested in contributing, check out the open issues in the oclif GitHub repo and come say "Hello!" on Spectrum Chat.
Open Source Citizenship by Josh Simmons​

When it comes to open source, it's more than just individuals now. More and more frequently, large corporations are contributing to projects by donating to contributors, sponsoring events, or upstreaming contributions. But keeping open source projects and communities healthy requires more than just money and brainpower. Josh Simmons surveyed multiple open source communities and relays his findings as to what help maintainers and contributors actually need in this talk.
Building an enterprise-grade CLI with oclif by Thomas Dvornik​

Security and performance are all about trust. While oclif is an extremely extensible framework for building CLI tooling, there are additional requirements to fulfill for enterprise businesses to adopt it that might not be necessary for individual developers. Thomas Dvornik outlines what he and his colleagues at Salesforce have implemented as plugins to oclif to satisfy these needs, including encrypted OAuth, plugin signing, lazy loading dependencies, synchronizing weekly releases and deprecations across dozens of repositories, and establishing cross-team coding and documentation standards.
How Adobe I/O built an extensible CLI with oclif by Jesse MacFadyen​

Perhaps oclif's most appealing feature is its support for plugins. In Cordova's case, they've created a sophisticated telemetry system that helps Adobe developers see which commands users are using--and reports on which ones are erroring out. By embedding a feedback system into the tool, users are even able to quickly send their suggestions to a form, without ever leaving the terminal. Jesse MacFadyen demonstrates how oclif's plugin system can work beyond simply executing commands.
Integrating oclif with GraphQL and Apollo by Evans Hauser​

For Evans Hauser and the team at Apollo, oclif is best thought of as "React for the CLI." As a client paired with a strongly-typed API contract to a server, it can deliver structured and consistent commands to retrieve external data. What better mechanism to use for this transfer than GraphQL, a framework which empowers the client to ask precisely for the data it needs, and nothing more?
Adaptive Intent-based CLI State Machines by Shawn Wang​

In designing oclif, Jeff Dickey wrote out 12 CLI factors to keep in mind. In this talk, Shawn Wang outlines a 13th: state. State is hard, because it depends on context, and context depends on understanding what a user intends to do, not what they are asking. Shawn is working towards enabling oclif to better understand the commands a user has entered, so that it can predict and interpret future commands that might be entered next. This would enable CLI tools to not just interpret a users' commands, but to also interpret their intent.\n\nIntroducing `oclif init` commandApril 10, 2024 · 2 min readThanks to the contribution of @joshcanhelp we released a new command for the oclif CLI called oclif init in version 4.8.0
The oclif init command allows you to initialize oclif in an existing project directory by adding the bare minimum requirements: a few pieces of configuration, bin scripts, and a couple of dependencies (@oclif/core and ts-node). This is slightly different from oclif generate, which will create an entirely new oclif project based on our templates.
oclif init will add the following:

bin scripts: bin/run.js, bin/run.cmd, bin/dev.js, and bin/dev.cmd
oclif section to package.json with bin, dirname, commands, and topicSeparator set (See Configuring Your CLI for more)
@oclif/core to dependencies in your package.json (if it's not already there)
ts-node to devDependencies in your package.json (if it's not already there)

Once you've initialized oclif, you can use the bin scripts to execute your CLI. You can also use the other oclif commands like oclif generate command and oclif generate hook to start adding new functionality.

❯ oclif init --helpInitialize a new oclif CLIUSAGE  $ oclif init [--bin <value>] [--module-type ESM|CommonJS] [--package-manager npm|yarn|pnpm] [--topic-separator    colons|spaces] [-d <value>] [-y]FLAGS  -d, --output-dir=<value>        Directory to initialize the CLI in.  -y, --yes                       Use defaults for all prompts. Individual flags will override defaults.      --bin=<value>               Supply answer for prompt: Command bin name the CLI will export      --module-type=<option>      Supply answer for prompt: Select a module type                                  <options: ESM|CommonJS>      --package-manager=<option>  Supply answer for prompt: Select a package manager                                  <options: npm|yarn|pnpm>      --topic-separator=<option>  Supply answer for prompt: Select a topic separator                                  <options: colons|spaces>DESCRIPTION  Initialize a new oclif CLI  This will add the necessary oclif bin files, add oclif config to package.json, and install @oclif/core and ts-node.EXAMPLES  Initialize a new CLI in the current directory    $ oclif init  Initialize a new CLI in a different directory    $ oclif init --output-dir "/path/to/existing/project"  Supply answers for specific prompts    $ oclif init --topic-separator colons --bin mycli
Hope you enjoy the new command! If you come across any issues or have any new ideas for this command, head over to the oclif/oclif repo and open a new issue.
All our best,
The oclif teamoclif Spring 2024 UpdateMarch 29, 2024 · 4 min readHello oclif developers! It's been a while since we last uploaded a blog - and a lot has happened.
We've been focusing on these high-level areas over the past couple of years:

Improving @oclif/core
ESM Support
Improving and revitalizing oclif.io
Re-engaging the oclif community

Improving @oclif/core​
Since we announced @oclif/core over three years ago, we've released two new major versions, each packed with lots of features that we're really excited about.
Here are some of these changes:

Full support for ESM and interoperability with CommonJS (more on this topic below).
Configurable command discovery strategies that give you more control over how commands are loaded at runtime. Check out the docs.
A new preparse hook that allows you to manipulate the provided arguments before they're parsed. Salesforce used this hook to implement a neat --flags-dir feature that translates local files into flags.
A new Performance class that you can use to track performance inside of @oclif/core and your own CLI or plugin. Check out the docs.
A new flag type, Flags.option, that lets you define a flag with a preset list of options. Typescript then uses the options to infer the flag's type.
Flags now have a relationship property that allows you to define more complex relationships between flags. Check out the flags docs for more information.
Flags now have a defaultHelp property that allows you to set the human readable default value in the command help. This property is useful when your flag's parse method returns a complex type, such as an object or a class. Check out the flags docs for more.
Commands now have a hiddenAliases property that allows you to define aliases that you want to hide from the user. The property is super helpful when you're trying to wean users off a deprecated command.
You can now use bun or tsx as dev runtimes (as opposed to node or ts-node).
A command's usage, args, and flags are now shown whenever a user forgets to provide a required arg or flag, or when they provided a non-existent flag.

If you need help migrating to the latest version, head over to core's README which has links to the migration guides. Feel free to open a new discussion if you need more hands-on help from us or the community.
ESM Support​
Version 3 of @oclif/core introduced full support for developing ESM plugins and CLIs. It also offered full support for interoperability between CommonJS and ESM plugins.
Put more simply, you can now migrate your CLI to ESM while keeping individual plugins in CommonJS (or vice versa). The upgrade path is now much simpler for you. You also don't need to worry about any community plugins that have migrated to ESM before you did (such as all the @oclif plugins) or are staunchly sticking with CommonJS for the foreseeable future.
Read more about this topic here.
Improving and Revitalizing oclif.io​
Another area of focus for us has been improving our documentation site, oclif.io.
While improving the quality and accuracy of the documentation was our priority, we also took the time to upgrade to the latest version of docusaurus. This new version gave our site a much-needed facelift, as well as cool new features such as dark mode and announcements.
If you have any feedback or are running into issues, we want to hear about it. Just create an issue in the oclif.io repo.
Re-engaging the oclif Community​
Lastly, our biggest priority at the moment is to re-engage the oclif community. We understand how frustrating it has been over the years to see your issues and pull requests go unacknowledged. We apologize for not prioritizing the community, and are earnestly trying to make sure that every issue and pull request gets the attention it deserves going forward.
We also opened up GitHub discussions for @oclif/core and the oclif CLI, where you can now post your questions or ideas. We hope you take advantage of them, we love hearing from you!
One last thing: we intend to publicly post our roadmap so you have more visibility into what we're working on. Stay tuned!
All our best,
The oclif teamAnnouncing oclif v2!January 12, 2022 · 5 min readHello and happy new year! It's our great pleasure to announce that we have released oclif v2, which uses the new @oclif/core library! 🎉
oclif v2 includes many changes that improve the experience of both creating and using an oclif CLI.
Going forward, we don't plan to make any updates to oclif v1 and its corresponding libraries, except for critical security fixes. See the compatibility matrix for a list of these libraries. In order to give developers time to migrate from v1 to v2, we're not completely dropping support yet. But at some point in the future we'll archive the v1 repositories and deprecate their versions on npm.
What’s changing?​
Repository Changes​
All repositories under the oclif org now use main as their primary branch and oclif-v1 as the legacy branch. The main  branch corresponds to oclif v2 and the oclif-v1 branch to oclif v1. If you find any repos that don’t have a main branch, you can safely assume that they're not used in oclif v2 and will be deprecated in the future.
Consolidating Tools & Libraries​
The oclif-dev CLI has now been incorporated into oclif. You now no longer need to install a separate package to manage your entire CLI’s lifecycle.
The following libraries have been consolidated under @oclif/core and will be deprecated at some point in the future. Read the migration guide to learn how to update your CLI or plugin to use the new core library.

@oclif/command
@oclif/config
@oclif/error
@oclif/help
@oclif/parser

No more single vs multi command CLIs​
There's only one "type" of oclif v2 CLI, but it can have as few or as many commands as a developer wants. As a result, there’s only one command to generate CLIs, oclif generate, as opposed to the old oclif single and oclif multi commands.
Node > 12​
To ensure oclif CLIs are as secure as possible, all v2 libraries and plugins support only Node 12 or higher as of now. Going forward, they'll support only Node Maintenance or higher, as defined by Node's release schedule here: https://nodejs.org/en/about/releases/.
What’s new?​
New example CLI​
oclif-hello-world is our new example repo. This is also the repo that's used as a template when running oclif generate to create a new CLI. This repo will always be able to be referenced as an example of what an oclif v2 CLI should look like.
Spaced commands​
oclif CLIs can now use spaces, instead of colons, to separate topics and subcommands. To enable this feature, simply add “topicSeparator": " " to the oclif config in your package.json. See an example in our example repo.
// Old commands that use :$ mycli do:something
// New spaced commands$ mycli do something

Note: Spaced commands are backwards compatible. So if you enable spaced commands for your CLI, users will still be able to use : as a separator. This ensures that any existing scripts don't break.

New Help Output​
We’ve revamped the way command help is outputted to the terminal, making it both easier to implement and easier to read. See the difference between the old help output on the left and the new help output on the right in the screenshots below.
oclif v1oclif v2
Notice that there are new sections for flags and global flags, examples are displayed with better spacing, and there is a section at the bottom called Configuration Variables. This Configuration Variables section is not part of the new help by default. But we've added support for custom help sections, which is what the sf CLI uses to create the new section.
Async Command Parsing​
We’ve also improved the performance of new CLIs by rewriting how commands are parsed on initialization. The new parser is asynchronous, which makes CLIs with a lot of commands or installed  plugins much faster.
What’s coming next?​
Part of our charter for the release of oclif v2 includes improving our engagement with the oclif community. We know that over the past couple of years we’ve reduced our involvement, and a lot of issues and PRs have languished in limbo. Hopefully you’ve already seen increased activity and responses from oclif maintainers recently, but if you haven’t, please don’t hesitate to ping us by tagging @admins in oclif repos.
We also want to start interviewing members of the oclif community to acquire feedback and prioritize the features and fixes you deem most important!
Best,
The oclif team

Reference material​
Migration Guide​
This guide explains how to upgrade a CLI or plugin from the old oclif v1 libraries to the new @oclif/core library that oclif v2 uses.
https://github.com/oclif/core/blob/main/MIGRATION.md
Compatibility Matrix​
The following matrix shows how the v1 libraries and plugins relate to the new v2 ones. Use this matrix as a guide to know what to drop and which versions to switch when upgrading your plugins and CLIs to v2.
oclif "v1"oclif "v2"Utility CLIsoclif@<2@oclif/dev-cli@<2oclif@>=2Main packages@oclif/command@oclif/config@oclif/errors@oclif/parser@oclif/plugin-help@oclif/core@>=1Node LTSNode v8-14Node v12+ (at time of writing)TypeScripttypescript@<4typescript@>=4Main plugins@oclif/plugin-autocomplete@<1@oclif/plugin-commands@<2@oclif/plugin-help@<4@oclif/plugin-not-found@<2@oclif/plugin-plugins@<2@oclif/plugin-update@<2plugin-warn-if-update-available@<2plugin-which@<2@oclif/plugin-autocomplete@>=1@oclif/plugin-commands@>=2@oclif/plugin-help@>=4@oclif/plugin-not-found@>=2@oclif/plugin-plugins@>=2@oclif/plugin-update@>=2@oclif/plugin-warn-if-update-available@>=2@oclif/plugin-which@>=2Introducing @oclif/coreMarch 1, 2021 · 3 min readGreetings!
We hope this blog post finds you well.
Introducing...​
We are excited to announce the next iteration of the oclif project today: @oclif/core.
We have learned a lot in the last three years of developing oclif, developing on oclif and supporting millions of command runs a day via Heroku and Salesforce CLIs.
@oclif/core ("Core") simplifies the oclif development experience and introduces highly requested new features.
Core combines the essential oclif packages into one "core" package, aptly named @oclif/core.
Core also introduces:

A default command option
Colon or space command syntax
Async command parsing
Command piping to arguments

With the introduction of default command functionality, Core simplifies the oclif project and removes the notion of single or multi command CLIs. Core CLIs can have 1 or many commands.
Along with Core, we moved the oclif-dev CLI into the oclif CLI creating a single "utility" CLI. This CLI also introduces a new AWS S3 compatible publishing scheme.
What to expect in the near future​
Core is in pre-release beta and being actively developed for new internal Salesforce CLIs.
Much documentation needs to be written in the coming months including migration paths. Migration onto Core should be as painless as possible with many exports remaining entirely unchanged. Look for forthcoming blog posts and documentation on oclif.io.
Early this summer, tentively June 1, we will release Core v1. Core's release will coincide with major bumps to many other oclif plugin packages. See the compatibility matrix below.
At Core's v1 release, the current "main" oclif packages (namely: command, config, errors & parser) will go into maintenance mode until Jan 2022. They will receive only bug and security fixes and they remain compatible with current versions of the oclif and oclif-dev CLIs. Afterwhich, they will be archived.
Companioning Core, the next major release of the oclif CLI (literally oclif@2) will generate Core CLIs.
Going forward​
We are excited to release Core! We invite you to poke around the Core repo. It may appear to be a big change but Core keeps what you already enjoy about oclif while reducing development complexity, project dependencies, package coupling and bundle size and introduces many requested features previously too prickly to weave into the current oclif architecture.
Best,
The oclif team
Reference: Compatibility matrix​
oclif "v1"oclif "Core"Utility CLIsoclif@<2@oclif/dev-cli@<2oclif@>=2Main packages@oclif/core@<2@oclif/config@<2@oclif/errors@<2@oclif/parser@<4@oclif/plugin-help@<4@oclif/core@>=1Node LTSNode v8-14Node v12+TypeScripttypescript@<4typescript@>=4Main plugins@oclif/plugin-autocomplete@<1@oclif/plugin-commands@<2@oclif/plugin-help@<4@oclif/plugin-not-found@<2@oclif/plugin-plugins@<2@oclif/plugin-update@<2plugin-warn-if-update-available@<2plugin-which@<2@oclif/plugin-autocomplete@>=2@oclif/plugin-commands@>=2@oclif/plugin-help@>=4@oclif/plugin-not-found@>=2@oclif/plugin-plugins@>=2@oclif/plugin-update@>=2@oclif/plugin-warn-if-update-available@>=2@oclif/plugin-which@>=2oclif Summer 2020 UpdateAugust 26, 2020 · 2 min readHello oclif developers! We hope you are all doing well.
Earlier this year, we started our planning for oclifconf v2 and, like all conference, had to change course. We opted not to hold a virtual conference, however, we wanted to take some time to highlight a few oclif features shipped this year.
Feature: Help templating​
One of the most requested features, help templating enables oclif developers to customize the help output for their CLI.
Read the announcement.
Feature: Custom error delegation​
This feature both improved how oclif throws and handles errors and allows oclif developers to overwrite or interject in oclif’s error handling.
Read the announcement.
Feature: postrun hooks​
We have added a new lifecycle event postrun. Your CLI can now run a hook after a command has ran.
See our hook documentation.
Feature: Root index command​
Previously, oclif would display CLI help if only the binary name with no command ID was invoked, oclif now supports a "root index" command. If present, a command defined at src/commands/index.ts will be run if no command ID is found.
1 million weekly downloads​
While exact oclif usage metrics are hard to pin down, we use npm download statistics of oclif packages as a rough approximation. Earlier this year, oclif's command package hit 1 million weekly downloads for the first time!
This year has been presented its challenges on everyone. We want to thank you, oclif developers, whom have taken the time to use and improve the oclif project. We look forward to seeing you all - in person - in the future!
All our best,
The oclif teamPretty Printable ErrorsJuly 1, 2020 · One min readOften CLIs are used as handy tools and when things go wrong it’s useful to have additional context. In oclif we have added a couple of additional properties that can show extra context to the users when an error is displayed. The code, ref and suggestions will now be displayed if they are included. This will work with an existing oclif CLI by adding the latest @oclif/errors and @oclif/core to the CLI's package.json dependencies.
For example, using this.error with the additional properties:
class TestError extends Command {  async run() {    this.error("An error has occurred!", {      code: "OCLIF_ERR",      ref: "https://oclif.io/docs/commands#thiserrormessage-string--error-options-code-string-exit-number",      suggestions: ["Use these extra properties to provide additional context"],    })  }}
would result with the following output:
›   Error: An error has occurred!›   Code: OCLIF_ERR›   Try this: Use these extra properties to provide additional context›   Reference: https://oclif.io/docs/commands#thiserrormessage-string--error-options-code-string-exit-number
If these properties are not provided then nothing changes and the CLI will continue to display the single error message output as it did before. Additionally, as part of this exercise we’ve added documentation around Error Handling in oclif which should come in handy if the need arises to extend oclif’s default handling of errors.Customizing Help in oclifMay 5, 2020 · 2 min readOut of the box oclif provides a great help experience for CLIs.
But what if, as an oclif developer, you want to customize some or all of the output?
You can now customize your CLI's help output by implementing the HelpBase abstract class.
Getting started with custom help​
If you have not done so yet, update @oclif/core.
$ yarn add --latest @oclif/core
To get started, first define the filepath to your help class in oclif's config in package.json. This is a relative path to the help class, without a file extension.
For this example, the help class will be created in a file at "[project root]/src/help.ts".
{  // ...  "oclif": {    "helpClass": "./lib/help"    // ...  }  // ...}
From here there are two paths, implement the HelpBase abstract class yourself or overwrite the parts of the default Help class you want to customize (ex: how command usage is displayed). We recommend the latter approach but cover both in the new Help Classes docs.
Separating TOPICS & COMMANDS in the new default Help class​
Previously, topics and child commands were listed in help output under a single list heading called "COMMANDS". But we found this can be slightly confusing. Some topics are commands also (a.k.a. topic-commands) while others are simply organizational namespacing (and when ran just show their help).
The new default Help class splits the list of children into distinct lists of "TOPICS" and "COMMANDS", with the possibility of an item appearing in both if it a topic-command. This makes it clearer what is expected to be ran - "COMMANDS" - and what is providing structure - "TOPICS" - when looking at the help output.
VERSION  plugin-help-example/0.0.0 darwin-x64 node-v12.12.0USAGE  $ plugin-help-example [COMMAND]TOPICS  topic  this is a topic and has child topics or commandsCOMMANDS  hello  describe the command here  help   display help for plugin-help-example
We look forward to seeing what custom help features you implement in your oclif CLIs with this new feature!oclif TSLint to ESLint MigrationDecember 5, 2019 · 3 min readBack in February of this year, plans were announced to deprecate TSLint in favor of ESLint. TSLint's goal has become to work toward a “unified developer experience” by supporting ESLint development going forward.
What has changed in oclif​
To keep inline with the community, oclif has transitioned to ESLint for all our core libraries as well as all our official plugins.
Starting in v1.15.x, oclif will now optionally generate projects with ESLint for both TypeScript and JavaScript CLI’s.
ESLint does require Node to be on stable LTS version, at the time of writing, Node 8.10.x, Node 10.13.x & Node 12.x.x.
How does this affect you​
Existing CLI’s are unchanged, but any newly generated CLI's will only give the option of using ESLint. If you are running tslint in your CLI, we recommend you switch to ESLint as well.
In migrating our projects we took the following steps (for an example of these changes see this pull request).


Install eslint
$ yarn add eslint eslint-config-oclif eslint-config-oclif-typescript --dev


Add eslint related files


$ echo '{  "extends": [    "oclif",    "oclif-typescript"  ],  "rules": {  }}' > .eslintrc


Remove tslint and related packages
$ yarn remove @oclif/tslint tslint


Remove tslint related configuration files
$ rm tslint.json


Change lint script in our package.json from something like:
"lint": "tsc -p test --noEmit && tslint -p test -t stylish"
to
"lint": "eslint . --ext .ts --config .eslintrc"


To preserve the test compile (tsc -p test --noEmit) we also made the following updates to our scripts:
"pretest": "tsc -p test --noEmit"
In some cases we had our posttest duplicating the same steps as our lint script so it’s cleaner to have it reference the lint job directly with:
"posttest": "yarn lint"

Run yarn lint --fix. This attempts to auto-fix any linting violations automatically. In the case an auto-fix isn’t available it should be fixed manually or ignored (see the eslint configuration doc for more information)
Do a search in the codebase for tslint and remove any unnecessary tslint disabling comments, like:

/* tslint:disable:object-literal-sort-keys */
If you are on a version of Node that is not supported by ESLint, you will also need to update your Node engine. ESLint supports Node 8, 10, and 12 so you should upgrade to the most recent Node version compatible with your CLI and also supported by ESLint (see ESLint's Installation and Usage instructions).
When will this take effect​
These changes have taken effect in oclif v1.15.1. When you generate a new CLI or plugin it will now contain configuration for ESLint instead of TSLint.oclif's Current Node SupportOctober 31, 2019 · 3 min readTo maintain a healthy project trajectory, oclif follows and supports Node Active LTS release, currently Node 10 & Node 12. This means ensuring that oclif continues to play nice with coming Active LTS Node versions and other packages in the ecosystem. Moving forward also means leaving older versions behind. Starting in 2020, Node will stop maintaining Node 8 and it is our intent at that time to also follow suit. Let’s take a look at a few ways we will be supporting these changes.
CI Environments​
CLIs created with the oclif cli going forward will be generated with a CircleCI configuration with Node 10 & 12 and an Appveyor configuration using Node 10. We have also added Node latest to CircleCi to be an early warning detection against coming Node changes (Node latest is managed by CircleCI).
We have already updated every oclif repo's CI configs to reflect this.
If your existing CLI uses either Appveyor or CircleCI you can update your config files also, like so:
.circleci/config.yml​
Your CircleCI config should contain a node-latest job, aliased as test. From this, there should be two extensions of this job for the Active LTS Node versions, Node 10 and Node 12.
  node-10:    <<: *node-latest    docker:      - image: node:10  node-12:    <<: *node-latest    docker:      - image: node:12
Notice that these declarations only change the Docker Node images used to run that job.
Additionally, the jobs listed within workflows must also be updated to reflect our changes in configuration:
    jobs:      - node-latest      - node-10      - node-12
appveyor.yml​
For appveyor we are currently only testing the oldest Active LTS Node version, Node 10. Update the nodejs_version proppert in your appveyor.yml file to reflect this.
environment:  nodejs_version: "10"
Deprecating Node 8 & Updating packge.json engines​
In Jan 2020, Node will end its Node 8 maintenance. We will follow suit by setting the package.json engine property in oclif packages to >=10 and bumping the package's major versions.
Depending on how you ship your CLI you may wish to also bump the engines version in your CLI's package.json. You can read more about the implications of the engines property configuration in the npm documentation.
Also consider distributing your CLI with its own Node version.
Packaged Node Version​
When using dev-cli to pack your CLI it will use the Node version as specified in your package.json under the oclif.update.node.version property. This value should reflect an Active LTS Node version (dev-cli does not currently enforce versions).
Supporting the future​
As a community we may discover bumps along the way as we upgrade. If you notice something related to oclif please feel free to open an issue or submit a pull request under the relevant oclif package within the org.
We look forward to using the latest from Node and the community and keeping oclif healthy along the way.oclifconf 2019: A RecapSeptember 16, 2019 · 4 min readIn May, Heroku and Salesforce Open Source organized oclifconf, a conference for developers & product managers building CLI tools on top of the open source oclif framework. The speakers came from various tech companies, such as Adobe, Netlify, and Apollo, who have already built amazing CLI experiences. The topics covered everything from the incredible capabilities oclif has unlocked, to the community-built plugins extending its functionality, and even what the behavior of an adaptive CLI tool might look like.
Below is a listing of all of the talks from the event, along with a short summary. Enjoy!
The future of oclif by Jeff Dickey​

In its relatively short lifetime, oclif has already inspired many developers and companies to adopt its framework as a means for implementing their own command-line tooling. In this talk, Jeff Dickey, an oclif founding team member, recaps the project's history and inspiration. He also looks towards the future and outlines some features and improvements that the tool could adapt. This isn't so much a definitive roadmap of where oclif is headed, but rather, a call to inspiration for developers eager to contribute! And if you are interested in contributing, check out the open issues in the oclif GitHub repo and come say "Hello!" on Spectrum Chat.
Open Source Citizenship by Josh Simmons​

When it comes to open source, it's more than just individuals now. More and more frequently, large corporations are contributing to projects by donating to contributors, sponsoring events, or upstreaming contributions. But keeping open source projects and communities healthy requires more than just money and brainpower. Josh Simmons surveyed multiple open source communities and relays his findings as to what help maintainers and contributors actually need in this talk.
Building an enterprise-grade CLI with oclif by Thomas Dvornik​

Security and performance are all about trust. While oclif is an extremely extensible framework for building CLI tooling, there are additional requirements to fulfill for enterprise businesses to adopt it that might not be necessary for individual developers. Thomas Dvornik outlines what he and his colleagues at Salesforce have implemented as plugins to oclif to satisfy these needs, including encrypted OAuth, plugin signing, lazy loading dependencies, synchronizing weekly releases and deprecations across dozens of repositories, and establishing cross-team coding and documentation standards.
How Adobe I/O built an extensible CLI with oclif by Jesse MacFadyen​

Perhaps oclif's most appealing feature is its support for plugins. In Cordova's case, they've created a sophisticated telemetry system that helps Adobe developers see which commands users are using--and reports on which ones are erroring out. By embedding a feedback system into the tool, users are even able to quickly send their suggestions to a form, without ever leaving the terminal. Jesse MacFadyen demonstrates how oclif's plugin system can work beyond simply executing commands.
Integrating oclif with GraphQL and Apollo by Evans Hauser​

For Evans Hauser and the team at Apollo, oclif is best thought of as "React for the CLI." As a client paired with a strongly-typed API contract to a server, it can deliver structured and consistent commands to retrieve external data. What better mechanism to use for this transfer than GraphQL, a framework which empowers the client to ask precisely for the data it needs, and nothing more?
Adaptive Intent-based CLI State Machines by Shawn Wang​

In designing oclif, Jeff Dickey wrote out 12 CLI factors to keep in mind. In this talk, Shawn Wang outlines a 13th: state. State is hard, because it depends on context, and context depends on understanding what a user intends to do, not what they are asking. Shawn is working towards enabling oclif to better understand the commands a user has entered, so that it can predict and interpret future commands that might be entered next. This would enable CLI tools to not just interpret a users' commands, but to also interpret their intent.Older Entries\n\n\n\nIntroducing `oclif init` commandApril 10, 2024 · 2 min readThanks to the contribution of @joshcanhelp we released a new command for the oclif CLI called oclif init in version 4.8.0
The oclif init command allows you to initialize oclif in an existing project directory by adding the bare minimum requirements: a few pieces of configuration, bin scripts, and a couple of dependencies (@oclif/core and ts-node). This is slightly different from oclif generate, which will create an entirely new oclif project based on our templates.
oclif init will add the following:

bin scripts: bin/run.js, bin/run.cmd, bin/dev.js, and bin/dev.cmd
oclif section to package.json with bin, dirname, commands, and topicSeparator set (See Configuring Your CLI for more)
@oclif/core to dependencies in your package.json (if it's not already there)
ts-node to devDependencies in your package.json (if it's not already there)

Once you've initialized oclif, you can use the bin scripts to execute your CLI. You can also use the other oclif commands like oclif generate command and oclif generate hook to start adding new functionality.

❯ oclif init --helpInitialize a new oclif CLIUSAGE  $ oclif init [--bin <value>] [--module-type ESM|CommonJS] [--package-manager npm|yarn|pnpm] [--topic-separator    colons|spaces] [-d <value>] [-y]FLAGS  -d, --output-dir=<value>        Directory to initialize the CLI in.  -y, --yes                       Use defaults for all prompts. Individual flags will override defaults.      --bin=<value>               Supply answer for prompt: Command bin name the CLI will export      --module-type=<option>      Supply answer for prompt: Select a module type                                  <options: ESM|CommonJS>      --package-manager=<option>  Supply answer for prompt: Select a package manager                                  <options: npm|yarn|pnpm>      --topic-separator=<option>  Supply answer for prompt: Select a topic separator                                  <options: colons|spaces>DESCRIPTION  Initialize a new oclif CLI  This will add the necessary oclif bin files, add oclif config to package.json, and install @oclif/core and ts-node.EXAMPLES  Initialize a new CLI in the current directory    $ oclif init  Initialize a new CLI in a different directory    $ oclif init --output-dir "/path/to/existing/project"  Supply answers for specific prompts    $ oclif init --topic-separator colons --bin mycli
Hope you enjoy the new command! If you come across any issues or have any new ideas for this command, head over to the oclif/oclif repo and open a new issue.
All our best,
The oclif teamoclif Spring 2024 UpdateMarch 29, 2024 · 4 min readHello oclif developers! It's been a while since we last uploaded a blog - and a lot has happened.
We've been focusing on these high-level areas over the past couple of years:

Improving @oclif/core
ESM Support
Improving and revitalizing oclif.io
Re-engaging the oclif community

Improving @oclif/core​
Since we announced @oclif/core over three years ago, we've released two new major versions, each packed with lots of features that we're really excited about.
Here are some of these changes:

Full support for ESM and interoperability with CommonJS (more on this topic below).
Configurable command discovery strategies that give you more control over how commands are loaded at runtime. Check out the docs.
A new preparse hook that allows you to manipulate the provided arguments before they're parsed. Salesforce used this hook to implement a neat --flags-dir feature that translates local files into flags.
A new Performance class that you can use to track performance inside of @oclif/core and your own CLI or plugin. Check out the docs.
A new flag type, Flags.option, that lets you define a flag with a preset list of options. Typescript then uses the options to infer the flag's type.
Flags now have a relationship property that allows you to define more complex relationships between flags. Check out the flags docs for more information.
Flags now have a defaultHelp property that allows you to set the human readable default value in the command help. This property is useful when your flag's parse method returns a complex type, such as an object or a class. Check out the flags docs for more.
Commands now have a hiddenAliases property that allows you to define aliases that you want to hide from the user. The property is super helpful when you're trying to wean users off a deprecated command.
You can now use bun or tsx as dev runtimes (as opposed to node or ts-node).
A command's usage, args, and flags are now shown whenever a user forgets to provide a required arg or flag, or when they provided a non-existent flag.

If you need help migrating to the latest version, head over to core's README which has links to the migration guides. Feel free to open a new discussion if you need more hands-on help from us or the community.
ESM Support​
Version 3 of @oclif/core introduced full support for developing ESM plugins and CLIs. It also offered full support for interoperability between CommonJS and ESM plugins.
Put more simply, you can now migrate your CLI to ESM while keeping individual plugins in CommonJS (or vice versa). The upgrade path is now much simpler for you. You also don't need to worry about any community plugins that have migrated to ESM before you did (such as all the @oclif plugins) or are staunchly sticking with CommonJS for the foreseeable future.
Read more about this topic here.
Improving and Revitalizing oclif.io​
Another area of focus for us has been improving our documentation site, oclif.io.
While improving the quality and accuracy of the documentation was our priority, we also took the time to upgrade to the latest version of docusaurus. This new version gave our site a much-needed facelift, as well as cool new features such as dark mode and announcements.
If you have any feedback or are running into issues, we want to hear about it. Just create an issue in the oclif.io repo.
Re-engaging the oclif Community​
Lastly, our biggest priority at the moment is to re-engage the oclif community. We understand how frustrating it has been over the years to see your issues and pull requests go unacknowledged. We apologize for not prioritizing the community, and are earnestly trying to make sure that every issue and pull request gets the attention it deserves going forward.
We also opened up GitHub discussions for @oclif/core and the oclif CLI, where you can now post your questions or ideas. We hope you take advantage of them, we love hearing from you!
One last thing: we intend to publicly post our roadmap so you have more visibility into what we're working on. Stay tuned!
All our best,
The oclif teamAnnouncing oclif v2!January 12, 2022 · 5 min readHello and happy new year! It's our great pleasure to announce that we have released oclif v2, which uses the new @oclif/core library! 🎉
oclif v2 includes many changes that improve the experience of both creating and using an oclif CLI.
Going forward, we don't plan to make any updates to oclif v1 and its corresponding libraries, except for critical security fixes. See the compatibility matrix for a list of these libraries. In order to give developers time to migrate from v1 to v2, we're not completely dropping support yet. But at some point in the future we'll archive the v1 repositories and deprecate their versions on npm.
What’s changing?​
Repository Changes​
All repositories under the oclif org now use main as their primary branch and oclif-v1 as the legacy branch. The main  branch corresponds to oclif v2 and the oclif-v1 branch to oclif v1. If you find any repos that don’t have a main branch, you can safely assume that they're not used in oclif v2 and will be deprecated in the future.
Consolidating Tools & Libraries​
The oclif-dev CLI has now been incorporated into oclif. You now no longer need to install a separate package to manage your entire CLI’s lifecycle.
The following libraries have been consolidated under @oclif/core and will be deprecated at some point in the future. Read the migration guide to learn how to update your CLI or plugin to use the new core library.

@oclif/command
@oclif/config
@oclif/error
@oclif/help
@oclif/parser

No more single vs multi command CLIs​
There's only one "type" of oclif v2 CLI, but it can have as few or as many commands as a developer wants. As a result, there’s only one command to generate CLIs, oclif generate, as opposed to the old oclif single and oclif multi commands.
Node > 12​
To ensure oclif CLIs are as secure as possible, all v2 libraries and plugins support only Node 12 or higher as of now. Going forward, they'll support only Node Maintenance or higher, as defined by Node's release schedule here: https://nodejs.org/en/about/releases/.
What’s new?​
New example CLI​
oclif-hello-world is our new example repo. This is also the repo that's used as a template when running oclif generate to create a new CLI. This repo will always be able to be referenced as an example of what an oclif v2 CLI should look like.
Spaced commands​
oclif CLIs can now use spaces, instead of colons, to separate topics and subcommands. To enable this feature, simply add “topicSeparator": " " to the oclif config in your package.json. See an example in our example repo.
// Old commands that use :$ mycli do:something
// New spaced commands$ mycli do something

Note: Spaced commands are backwards compatible. So if you enable spaced commands for your CLI, users will still be able to use : as a separator. This ensures that any existing scripts don't break.

New Help Output​
We’ve revamped the way command help is outputted to the terminal, making it both easier to implement and easier to read. See the difference between the old help output on the left and the new help output on the right in the screenshots below.
oclif v1oclif v2
Notice that there are new sections for flags and global flags, examples are displayed with better spacing, and there is a section at the bottom called Configuration Variables. This Configuration Variables section is not part of the new help by default. But we've added support for custom help sections, which is what the sf CLI uses to create the new section.
Async Command Parsing​
We’ve also improved the performance of new CLIs by rewriting how commands are parsed on initialization. The new parser is asynchronous, which makes CLIs with a lot of commands or installed  plugins much faster.
What’s coming next?​
Part of our charter for the release of oclif v2 includes improving our engagement with the oclif community. We know that over the past couple of years we’ve reduced our involvement, and a lot of issues and PRs have languished in limbo. Hopefully you’ve already seen increased activity and responses from oclif maintainers recently, but if you haven’t, please don’t hesitate to ping us by tagging @admins in oclif repos.
We also want to start interviewing members of the oclif community to acquire feedback and prioritize the features and fixes you deem most important!
Best,
The oclif team

Reference material​
Migration Guide​
This guide explains how to upgrade a CLI or plugin from the old oclif v1 libraries to the new @oclif/core library that oclif v2 uses.
https://github.com/oclif/core/blob/main/MIGRATION.md
Compatibility Matrix​
The following matrix shows how the v1 libraries and plugins relate to the new v2 ones. Use this matrix as a guide to know what to drop and which versions to switch when upgrading your plugins and CLIs to v2.
oclif "v1"oclif "v2"Utility CLIsoclif@<2@oclif/dev-cli@<2oclif@>=2Main packages@oclif/command@oclif/config@oclif/errors@oclif/parser@oclif/plugin-help@oclif/core@>=1Node LTSNode v8-14Node v12+ (at time of writing)TypeScripttypescript@<4typescript@>=4Main plugins@oclif/plugin-autocomplete@<1@oclif/plugin-commands@<2@oclif/plugin-help@<4@oclif/plugin-not-found@<2@oclif/plugin-plugins@<2@oclif/plugin-update@<2plugin-warn-if-update-available@<2plugin-which@<2@oclif/plugin-autocomplete@>=1@oclif/plugin-commands@>=2@oclif/plugin-help@>=4@oclif/plugin-not-found@>=2@oclif/plugin-plugins@>=2@oclif/plugin-update@>=2@oclif/plugin-warn-if-update-available@>=2@oclif/plugin-which@>=2Introducing @oclif/coreMarch 1, 2021 · 3 min readGreetings!
We hope this blog post finds you well.
Introducing...​
We are excited to announce the next iteration of the oclif project today: @oclif/core.
We have learned a lot in the last three years of developing oclif, developing on oclif and supporting millions of command runs a day via Heroku and Salesforce CLIs.
@oclif/core ("Core") simplifies the oclif development experience and introduces highly requested new features.
Core combines the essential oclif packages into one "core" package, aptly named @oclif/core.
Core also introduces:

A default command option
Colon or space command syntax
Async command parsing
Command piping to arguments

With the introduction of default command functionality, Core simplifies the oclif project and removes the notion of single or multi command CLIs. Core CLIs can have 1 or many commands.
Along with Core, we moved the oclif-dev CLI into the oclif CLI creating a single "utility" CLI. This CLI also introduces a new AWS S3 compatible publishing scheme.
What to expect in the near future​
Core is in pre-release beta and being actively developed for new internal Salesforce CLIs.
Much documentation needs to be written in the coming months including migration paths. Migration onto Core should be as painless as possible with many exports remaining entirely unchanged. Look for forthcoming blog posts and documentation on oclif.io.
Early this summer, tentively June 1, we will release Core v1. Core's release will coincide with major bumps to many other oclif plugin packages. See the compatibility matrix below.
At Core's v1 release, the current "main" oclif packages (namely: command, config, errors & parser) will go into maintenance mode until Jan 2022. They will receive only bug and security fixes and they remain compatible with current versions of the oclif and oclif-dev CLIs. Afterwhich, they will be archived.
Companioning Core, the next major release of the oclif CLI (literally oclif@2) will generate Core CLIs.
Going forward​
We are excited to release Core! We invite you to poke around the Core repo. It may appear to be a big change but Core keeps what you already enjoy about oclif while reducing development complexity, project dependencies, package coupling and bundle size and introduces many requested features previously too prickly to weave into the current oclif architecture.
Best,
The oclif team
Reference: Compatibility matrix​
oclif "v1"oclif "Core"Utility CLIsoclif@<2@oclif/dev-cli@<2oclif@>=2Main packages@oclif/core@<2@oclif/config@<2@oclif/errors@<2@oclif/parser@<4@oclif/plugin-help@<4@oclif/core@>=1Node LTSNode v8-14Node v12+TypeScripttypescript@<4typescript@>=4Main plugins@oclif/plugin-autocomplete@<1@oclif/plugin-commands@<2@oclif/plugin-help@<4@oclif/plugin-not-found@<2@oclif/plugin-plugins@<2@oclif/plugin-update@<2plugin-warn-if-update-available@<2plugin-which@<2@oclif/plugin-autocomplete@>=2@oclif/plugin-commands@>=2@oclif/plugin-help@>=4@oclif/plugin-not-found@>=2@oclif/plugin-plugins@>=2@oclif/plugin-update@>=2@oclif/plugin-warn-if-update-available@>=2@oclif/plugin-which@>=2oclif Summer 2020 UpdateAugust 26, 2020 · 2 min readHello oclif developers! We hope you are all doing well.
Earlier this year, we started our planning for oclifconf v2 and, like all conference, had to change course. We opted not to hold a virtual conference, however, we wanted to take some time to highlight a few oclif features shipped this year.
Feature: Help templating​
One of the most requested features, help templating enables oclif developers to customize the help output for their CLI.
Read the announcement.
Feature: Custom error delegation​
This feature both improved how oclif throws and handles errors and allows oclif developers to overwrite or interject in oclif’s error handling.
Read the announcement.
Feature: postrun hooks​
We have added a new lifecycle event postrun. Your CLI can now run a hook after a command has ran.
See our hook documentation.
Feature: Root index command​
Previously, oclif would display CLI help if only the binary name with no command ID was invoked, oclif now supports a "root index" command. If present, a command defined at src/commands/index.ts will be run if no command ID is found.
1 million weekly downloads​
While exact oclif usage metrics are hard to pin down, we use npm download statistics of oclif packages as a rough approximation. Earlier this year, oclif's command package hit 1 million weekly downloads for the first time!
This year has been presented its challenges on everyone. We want to thank you, oclif developers, whom have taken the time to use and improve the oclif project. We look forward to seeing you all - in person - in the future!
All our best,
The oclif teamPretty Printable ErrorsJuly 1, 2020 · One min readOften CLIs are used as handy tools and when things go wrong it’s useful to have additional context. In oclif we have added a couple of additional properties that can show extra context to the users when an error is displayed. The code, ref and suggestions will now be displayed if they are included. This will work with an existing oclif CLI by adding the latest @oclif/errors and @oclif/core to the CLI's package.json dependencies.
For example, using this.error with the additional properties:
class TestError extends Command {  async run() {    this.error("An error has occurred!", {      code: "OCLIF_ERR",      ref: "https://oclif.io/docs/commands#thiserrormessage-string--error-options-code-string-exit-number",      suggestions: ["Use these extra properties to provide additional context"],    })  }}
would result with the following output:
›   Error: An error has occurred!›   Code: OCLIF_ERR›   Try this: Use these extra properties to provide additional context›   Reference: https://oclif.io/docs/commands#thiserrormessage-string--error-options-code-string-exit-number
If these properties are not provided then nothing changes and the CLI will continue to display the single error message output as it did before. Additionally, as part of this exercise we’ve added documentation around Error Handling in oclif which should come in handy if the need arises to extend oclif’s default handling of errors.Customizing Help in oclifMay 5, 2020 · 2 min readOut of the box oclif provides a great help experience for CLIs.
But what if, as an oclif developer, you want to customize some or all of the output?
You can now customize your CLI's help output by implementing the HelpBase abstract class.
Getting started with custom help​
If you have not done so yet, update @oclif/core.
$ yarn add --latest @oclif/core
To get started, first define the filepath to your help class in oclif's config in package.json. This is a relative path to the help class, without a file extension.
For this example, the help class will be created in a file at "[project root]/src/help.ts".
{  // ...  "oclif": {    "helpClass": "./lib/help"    // ...  }  // ...}
From here there are two paths, implement the HelpBase abstract class yourself or overwrite the parts of the default Help class you want to customize (ex: how command usage is displayed). We recommend the latter approach but cover both in the new Help Classes docs.
Separating TOPICS & COMMANDS in the new default Help class​
Previously, topics and child commands were listed in help output under a single list heading called "COMMANDS". But we found this can be slightly confusing. Some topics are commands also (a.k.a. topic-commands) while others are simply organizational namespacing (and when ran just show their help).
The new default Help class splits the list of children into distinct lists of "TOPICS" and "COMMANDS", with the possibility of an item appearing in both if it a topic-command. This makes it clearer what is expected to be ran - "COMMANDS" - and what is providing structure - "TOPICS" - when looking at the help output.
VERSION  plugin-help-example/0.0.0 darwin-x64 node-v12.12.0USAGE  $ plugin-help-example [COMMAND]TOPICS  topic  this is a topic and has child topics or commandsCOMMANDS  hello  describe the command here  help   display help for plugin-help-example
We look forward to seeing what custom help features you implement in your oclif CLIs with this new feature!oclif TSLint to ESLint MigrationDecember 5, 2019 · 3 min readBack in February of this year, plans were announced to deprecate TSLint in favor of ESLint. TSLint's goal has become to work toward a “unified developer experience” by supporting ESLint development going forward.
What has changed in oclif​
To keep inline with the community, oclif has transitioned to ESLint for all our core libraries as well as all our official plugins.
Starting in v1.15.x, oclif will now optionally generate projects with ESLint for both TypeScript and JavaScript CLI’s.
ESLint does require Node to be on stable LTS version, at the time of writing, Node 8.10.x, Node 10.13.x & Node 12.x.x.
How does this affect you​
Existing CLI’s are unchanged, but any newly generated CLI's will only give the option of using ESLint. If you are running tslint in your CLI, we recommend you switch to ESLint as well.
In migrating our projects we took the following steps (for an example of these changes see this pull request).


Install eslint
$ yarn add eslint eslint-config-oclif eslint-config-oclif-typescript --dev


Add eslint related files


$ echo '{  "extends": [    "oclif",    "oclif-typescript"  ],  "rules": {  }}' > .eslintrc


Remove tslint and related packages
$ yarn remove @oclif/tslint tslint


Remove tslint related configuration files
$ rm tslint.json


Change lint script in our package.json from something like:
"lint": "tsc -p test --noEmit && tslint -p test -t stylish"
to
"lint": "eslint . --ext .ts --config .eslintrc"


To preserve the test compile (tsc -p test --noEmit) we also made the following updates to our scripts:
"pretest": "tsc -p test --noEmit"
In some cases we had our posttest duplicating the same steps as our lint script so it’s cleaner to have it reference the lint job directly with:
"posttest": "yarn lint"

Run yarn lint --fix. This attempts to auto-fix any linting violations automatically. In the case an auto-fix isn’t available it should be fixed manually or ignored (see the eslint configuration doc for more information)
Do a search in the codebase for tslint and remove any unnecessary tslint disabling comments, like:

/* tslint:disable:object-literal-sort-keys */
If you are on a version of Node that is not supported by ESLint, you will also need to update your Node engine. ESLint supports Node 8, 10, and 12 so you should upgrade to the most recent Node version compatible with your CLI and also supported by ESLint (see ESLint's Installation and Usage instructions).
When will this take effect​
These changes have taken effect in oclif v1.15.1. When you generate a new CLI or plugin it will now contain configuration for ESLint instead of TSLint.oclif's Current Node SupportOctober 31, 2019 · 3 min readTo maintain a healthy project trajectory, oclif follows and supports Node Active LTS release, currently Node 10 & Node 12. This means ensuring that oclif continues to play nice with coming Active LTS Node versions and other packages in the ecosystem. Moving forward also means leaving older versions behind. Starting in 2020, Node will stop maintaining Node 8 and it is our intent at that time to also follow suit. Let’s take a look at a few ways we will be supporting these changes.
CI Environments​
CLIs created with the oclif cli going forward will be generated with a CircleCI configuration with Node 10 & 12 and an Appveyor configuration using Node 10. We have also added Node latest to CircleCi to be an early warning detection against coming Node changes (Node latest is managed by CircleCI).
We have already updated every oclif repo's CI configs to reflect this.
If your existing CLI uses either Appveyor or CircleCI you can update your config files also, like so:
.circleci/config.yml​
Your CircleCI config should contain a node-latest job, aliased as test. From this, there should be two extensions of this job for the Active LTS Node versions, Node 10 and Node 12.
  node-10:    <<: *node-latest    docker:      - image: node:10  node-12:    <<: *node-latest    docker:      - image: node:12
Notice that these declarations only change the Docker Node images used to run that job.
Additionally, the jobs listed within workflows must also be updated to reflect our changes in configuration:
    jobs:      - node-latest      - node-10      - node-12
appveyor.yml​
For appveyor we are currently only testing the oldest Active LTS Node version, Node 10. Update the nodejs_version proppert in your appveyor.yml file to reflect this.
environment:  nodejs_version: "10"
Deprecating Node 8 & Updating packge.json engines​
In Jan 2020, Node will end its Node 8 maintenance. We will follow suit by setting the package.json engine property in oclif packages to >=10 and bumping the package's major versions.
Depending on how you ship your CLI you may wish to also bump the engines version in your CLI's package.json. You can read more about the implications of the engines property configuration in the npm documentation.
Also consider distributing your CLI with its own Node version.
Packaged Node Version​
When using dev-cli to pack your CLI it will use the Node version as specified in your package.json under the oclif.update.node.version property. This value should reflect an Active LTS Node version (dev-cli does not currently enforce versions).
Supporting the future​
As a community we may discover bumps along the way as we upgrade. If you notice something related to oclif please feel free to open an issue or submit a pull request under the relevant oclif package within the org.
We look forward to using the latest from Node and the community and keeping oclif healthy along the way.oclifconf 2019: A RecapSeptember 16, 2019 · 4 min readIn May, Heroku and Salesforce Open Source organized oclifconf, a conference for developers & product managers building CLI tools on top of the open source oclif framework. The speakers came from various tech companies, such as Adobe, Netlify, and Apollo, who have already built amazing CLI experiences. The topics covered everything from the incredible capabilities oclif has unlocked, to the community-built plugins extending its functionality, and even what the behavior of an adaptive CLI tool might look like.
Below is a listing of all of the talks from the event, along with a short summary. Enjoy!
The future of oclif by Jeff Dickey​

In its relatively short lifetime, oclif has already inspired many developers and companies to adopt its framework as a means for implementing their own command-line tooling. In this talk, Jeff Dickey, an oclif founding team member, recaps the project's history and inspiration. He also looks towards the future and outlines some features and improvements that the tool could adapt. This isn't so much a definitive roadmap of where oclif is headed, but rather, a call to inspiration for developers eager to contribute! And if you are interested in contributing, check out the open issues in the oclif GitHub repo and come say "Hello!" on Spectrum Chat.
Open Source Citizenship by Josh Simmons​

When it comes to open source, it's more than just individuals now. More and more frequently, large corporations are contributing to projects by donating to contributors, sponsoring events, or upstreaming contributions. But keeping open source projects and communities healthy requires more than just money and brainpower. Josh Simmons surveyed multiple open source communities and relays his findings as to what help maintainers and contributors actually need in this talk.
Building an enterprise-grade CLI with oclif by Thomas Dvornik​

Security and performance are all about trust. While oclif is an extremely extensible framework for building CLI tooling, there are additional requirements to fulfill for enterprise businesses to adopt it that might not be necessary for individual developers. Thomas Dvornik outlines what he and his colleagues at Salesforce have implemented as plugins to oclif to satisfy these needs, including encrypted OAuth, plugin signing, lazy loading dependencies, synchronizing weekly releases and deprecations across dozens of repositories, and establishing cross-team coding and documentation standards.
How Adobe I/O built an extensible CLI with oclif by Jesse MacFadyen​

Perhaps oclif's most appealing feature is its support for plugins. In Cordova's case, they've created a sophisticated telemetry system that helps Adobe developers see which commands users are using--and reports on which ones are erroring out. By embedding a feedback system into the tool, users are even able to quickly send their suggestions to a form, without ever leaving the terminal. Jesse MacFadyen demonstrates how oclif's plugin system can work beyond simply executing commands.
Integrating oclif with GraphQL and Apollo by Evans Hauser​

For Evans Hauser and the team at Apollo, oclif is best thought of as "React for the CLI." As a client paired with a strongly-typed API contract to a server, it can deliver structured and consistent commands to retrieve external data. What better mechanism to use for this transfer than GraphQL, a framework which empowers the client to ask precisely for the data it needs, and nothing more?
Adaptive Intent-based CLI State Machines by Shawn Wang​

In designing oclif, Jeff Dickey wrote out 12 CLI factors to keep in mind. In this talk, Shawn Wang outlines a 13th: state. State is hard, because it depends on context, and context depends on understanding what a user intends to do, not what they are asking. Shawn is working towards enabling oclif to better understand the commands a user has entered, so that it can predict and interpret future commands that might be entered next. This would enable CLI tools to not just interpret a users' commands, but to also interpret their intent.\n\nIntroducing `oclif init` commandApril 10, 2024 · 2 min readThanks to the contribution of @joshcanhelp we released a new command for the oclif CLI called oclif init in version 4.8.0
The oclif init command allows you to initialize oclif in an existing project directory by adding the bare minimum requirements: a few pieces of configuration, bin scripts, and a couple of dependencies (@oclif/core and ts-node). This is slightly different from oclif generate, which will create an entirely new oclif project based on our templates.
oclif init will add the following:

bin scripts: bin/run.js, bin/run.cmd, bin/dev.js, and bin/dev.cmd
oclif section to package.json with bin, dirname, commands, and topicSeparator set (See Configuring Your CLI for more)
@oclif/core to dependencies in your package.json (if it's not already there)
ts-node to devDependencies in your package.json (if it's not already there)

Once you've initialized oclif, you can use the bin scripts to execute your CLI. You can also use the other oclif commands like oclif generate command and oclif generate hook to start adding new functionality.

❯ oclif init --helpInitialize a new oclif CLIUSAGE  $ oclif init [--bin <value>] [--module-type ESM|CommonJS] [--package-manager npm|yarn|pnpm] [--topic-separator    colons|spaces] [-d <value>] [-y]FLAGS  -d, --output-dir=<value>        Directory to initialize the CLI in.  -y, --yes                       Use defaults for all prompts. Individual flags will override defaults.      --bin=<value>               Supply answer for prompt: Command bin name the CLI will export      --module-type=<option>      Supply answer for prompt: Select a module type                                  <options: ESM|CommonJS>      --package-manager=<option>  Supply answer for prompt: Select a package manager                                  <options: npm|yarn|pnpm>      --topic-separator=<option>  Supply answer for prompt: Select a topic separator                                  <options: colons|spaces>DESCRIPTION  Initialize a new oclif CLI  This will add the necessary oclif bin files, add oclif config to package.json, and install @oclif/core and ts-node.EXAMPLES  Initialize a new CLI in the current directory    $ oclif init  Initialize a new CLI in a different directory    $ oclif init --output-dir "/path/to/existing/project"  Supply answers for specific prompts    $ oclif init --topic-separator colons --bin mycli
Hope you enjoy the new command! If you come across any issues or have any new ideas for this command, head over to the oclif/oclif repo and open a new issue.
All our best,
The oclif teamoclif Spring 2024 UpdateMarch 29, 2024 · 4 min readHello oclif developers! It's been a while since we last uploaded a blog - and a lot has happened.
We've been focusing on these high-level areas over the past couple of years:

Improving @oclif/core
ESM Support
Improving and revitalizing oclif.io
Re-engaging the oclif community

Improving @oclif/core​
Since we announced @oclif/core over three years ago, we've released two new major versions, each packed with lots of features that we're really excited about.
Here are some of these changes:

Full support for ESM and interoperability with CommonJS (more on this topic below).
Configurable command discovery strategies that give you more control over how commands are loaded at runtime. Check out the docs.
A new preparse hook that allows you to manipulate the provided arguments before they're parsed. Salesforce used this hook to implement a neat --flags-dir feature that translates local files into flags.
A new Performance class that you can use to track performance inside of @oclif/core and your own CLI or plugin. Check out the docs.
A new flag type, Flags.option, that lets you define a flag with a preset list of options. Typescript then uses the options to infer the flag's type.
Flags now have a relationship property that allows you to define more complex relationships between flags. Check out the flags docs for more information.
Flags now have a defaultHelp property that allows you to set the human readable default value in the command help. This property is useful when your flag's parse method returns a complex type, such as an object or a class. Check out the flags docs for more.
Commands now have a hiddenAliases property that allows you to define aliases that you want to hide from the user. The property is super helpful when you're trying to wean users off a deprecated command.
You can now use bun or tsx as dev runtimes (as opposed to node or ts-node).
A command's usage, args, and flags are now shown whenever a user forgets to provide a required arg or flag, or when they provided a non-existent flag.

If you need help migrating to the latest version, head over to core's README which has links to the migration guides. Feel free to open a new discussion if you need more hands-on help from us or the community.
ESM Support​
Version 3 of @oclif/core introduced full support for developing ESM plugins and CLIs. It also offered full support for interoperability between CommonJS and ESM plugins.
Put more simply, you can now migrate your CLI to ESM while keeping individual plugins in CommonJS (or vice versa). The upgrade path is now much simpler for you. You also don't need to worry about any community plugins that have migrated to ESM before you did (such as all the @oclif plugins) or are staunchly sticking with CommonJS for the foreseeable future.
Read more about this topic here.
Improving and Revitalizing oclif.io​
Another area of focus for us has been improving our documentation site, oclif.io.
While improving the quality and accuracy of the documentation was our priority, we also took the time to upgrade to the latest version of docusaurus. This new version gave our site a much-needed facelift, as well as cool new features such as dark mode and announcements.
If you have any feedback or are running into issues, we want to hear about it. Just create an issue in the oclif.io repo.
Re-engaging the oclif Community​
Lastly, our biggest priority at the moment is to re-engage the oclif community. We understand how frustrating it has been over the years to see your issues and pull requests go unacknowledged. We apologize for not prioritizing the community, and are earnestly trying to make sure that every issue and pull request gets the attention it deserves going forward.
We also opened up GitHub discussions for @oclif/core and the oclif CLI, where you can now post your questions or ideas. We hope you take advantage of them, we love hearing from you!
One last thing: we intend to publicly post our roadmap so you have more visibility into what we're working on. Stay tuned!
All our best,
The oclif teamAnnouncing oclif v2!January 12, 2022 · 5 min readHello and happy new year! It's our great pleasure to announce that we have released oclif v2, which uses the new @oclif/core library! 🎉
oclif v2 includes many changes that improve the experience of both creating and using an oclif CLI.
Going forward, we don't plan to make any updates to oclif v1 and its corresponding libraries, except for critical security fixes. See the compatibility matrix for a list of these libraries. In order to give developers time to migrate from v1 to v2, we're not completely dropping support yet. But at some point in the future we'll archive the v1 repositories and deprecate their versions on npm.
What’s changing?​
Repository Changes​
All repositories under the oclif org now use main as their primary branch and oclif-v1 as the legacy branch. The main  branch corresponds to oclif v2 and the oclif-v1 branch to oclif v1. If you find any repos that don’t have a main branch, you can safely assume that they're not used in oclif v2 and will be deprecated in the future.
Consolidating Tools & Libraries​
The oclif-dev CLI has now been incorporated into oclif. You now no longer need to install a separate package to manage your entire CLI’s lifecycle.
The following libraries have been consolidated under @oclif/core and will be deprecated at some point in the future. Read the migration guide to learn how to update your CLI or plugin to use the new core library.

@oclif/command
@oclif/config
@oclif/error
@oclif/help
@oclif/parser

No more single vs multi command CLIs​
There's only one "type" of oclif v2 CLI, but it can have as few or as many commands as a developer wants. As a result, there’s only one command to generate CLIs, oclif generate, as opposed to the old oclif single and oclif multi commands.
Node > 12​
To ensure oclif CLIs are as secure as possible, all v2 libraries and plugins support only Node 12 or higher as of now. Going forward, they'll support only Node Maintenance or higher, as defined by Node's release schedule here: https://nodejs.org/en/about/releases/.
What’s new?​
New example CLI​
oclif-hello-world is our new example repo. This is also the repo that's used as a template when running oclif generate to create a new CLI. This repo will always be able to be referenced as an example of what an oclif v2 CLI should look like.
Spaced commands​
oclif CLIs can now use spaces, instead of colons, to separate topics and subcommands. To enable this feature, simply add “topicSeparator": " " to the oclif config in your package.json. See an example in our example repo.
// Old commands that use :$ mycli do:something
// New spaced commands$ mycli do something

Note: Spaced commands are backwards compatible. So if you enable spaced commands for your CLI, users will still be able to use : as a separator. This ensures that any existing scripts don't break.

New Help Output​
We’ve revamped the way command help is outputted to the terminal, making it both easier to implement and easier to read. See the difference between the old help output on the left and the new help output on the right in the screenshots below.
oclif v1oclif v2
Notice that there are new sections for flags and global flags, examples are displayed with better spacing, and there is a section at the bottom called Configuration Variables. This Configuration Variables section is not part of the new help by default. But we've added support for custom help sections, which is what the sf CLI uses to create the new section.
Async Command Parsing​
We’ve also improved the performance of new CLIs by rewriting how commands are parsed on initialization. The new parser is asynchronous, which makes CLIs with a lot of commands or installed  plugins much faster.
What’s coming next?​
Part of our charter for the release of oclif v2 includes improving our engagement with the oclif community. We know that over the past couple of years we’ve reduced our involvement, and a lot of issues and PRs have languished in limbo. Hopefully you’ve already seen increased activity and responses from oclif maintainers recently, but if you haven’t, please don’t hesitate to ping us by tagging @admins in oclif repos.
We also want to start interviewing members of the oclif community to acquire feedback and prioritize the features and fixes you deem most important!
Best,
The oclif team

Reference material​
Migration Guide​
This guide explains how to upgrade a CLI or plugin from the old oclif v1 libraries to the new @oclif/core library that oclif v2 uses.
https://github.com/oclif/core/blob/main/MIGRATION.md
Compatibility Matrix​
The following matrix shows how the v1 libraries and plugins relate to the new v2 ones. Use this matrix as a guide to know what to drop and which versions to switch when upgrading your plugins and CLIs to v2.
oclif "v1"oclif "v2"Utility CLIsoclif@<2@oclif/dev-cli@<2oclif@>=2Main packages@oclif/command@oclif/config@oclif/errors@oclif/parser@oclif/plugin-help@oclif/core@>=1Node LTSNode v8-14Node v12+ (at time of writing)TypeScripttypescript@<4typescript@>=4Main plugins@oclif/plugin-autocomplete@<1@oclif/plugin-commands@<2@oclif/plugin-help@<4@oclif/plugin-not-found@<2@oclif/plugin-plugins@<2@oclif/plugin-update@<2plugin-warn-if-update-available@<2plugin-which@<2@oclif/plugin-autocomplete@>=1@oclif/plugin-commands@>=2@oclif/plugin-help@>=4@oclif/plugin-not-found@>=2@oclif/plugin-plugins@>=2@oclif/plugin-update@>=2@oclif/plugin-warn-if-update-available@>=2@oclif/plugin-which@>=2Introducing @oclif/coreMarch 1, 2021 · 3 min readGreetings!
We hope this blog post finds you well.
Introducing...​
We are excited to announce the next iteration of the oclif project today: @oclif/core.
We have learned a lot in the last three years of developing oclif, developing on oclif and supporting millions of command runs a day via Heroku and Salesforce CLIs.
@oclif/core ("Core") simplifies the oclif development experience and introduces highly requested new features.
Core combines the essential oclif packages into one "core" package, aptly named @oclif/core.
Core also introduces:

A default command option
Colon or space command syntax
Async command parsing
Command piping to arguments

With the introduction of default command functionality, Core simplifies the oclif project and removes the notion of single or multi command CLIs. Core CLIs can have 1 or many commands.
Along with Core, we moved the oclif-dev CLI into the oclif CLI creating a single "utility" CLI. This CLI also introduces a new AWS S3 compatible publishing scheme.
What to expect in the near future​
Core is in pre-release beta and being actively developed for new internal Salesforce CLIs.
Much documentation needs to be written in the coming months including migration paths. Migration onto Core should be as painless as possible with many exports remaining entirely unchanged. Look for forthcoming blog posts and documentation on oclif.io.
Early this summer, tentively June 1, we will release Core v1. Core's release will coincide with major bumps to many other oclif plugin packages. See the compatibility matrix below.
At Core's v1 release, the current "main" oclif packages (namely: command, config, errors & parser) will go into maintenance mode until Jan 2022. They will receive only bug and security fixes and they remain compatible with current versions of the oclif and oclif-dev CLIs. Afterwhich, they will be archived.
Companioning Core, the next major release of the oclif CLI (literally oclif@2) will generate Core CLIs.
Going forward​
We are excited to release Core! We invite you to poke around the Core repo. It may appear to be a big change but Core keeps what you already enjoy about oclif while reducing development complexity, project dependencies, package coupling and bundle size and introduces many requested features previously too prickly to weave into the current oclif architecture.
Best,
The oclif team
Reference: Compatibility matrix​
oclif "v1"oclif "Core"Utility CLIsoclif@<2@oclif/dev-cli@<2oclif@>=2Main packages@oclif/core@<2@oclif/config@<2@oclif/errors@<2@oclif/parser@<4@oclif/plugin-help@<4@oclif/core@>=1Node LTSNode v8-14Node v12+TypeScripttypescript@<4typescript@>=4Main plugins@oclif/plugin-autocomplete@<1@oclif/plugin-commands@<2@oclif/plugin-help@<4@oclif/plugin-not-found@<2@oclif/plugin-plugins@<2@oclif/plugin-update@<2plugin-warn-if-update-available@<2plugin-which@<2@oclif/plugin-autocomplete@>=2@oclif/plugin-commands@>=2@oclif/plugin-help@>=4@oclif/plugin-not-found@>=2@oclif/plugin-plugins@>=2@oclif/plugin-update@>=2@oclif/plugin-warn-if-update-available@>=2@oclif/plugin-which@>=2oclif Summer 2020 UpdateAugust 26, 2020 · 2 min readHello oclif developers! We hope you are all doing well.
Earlier this year, we started our planning for oclifconf v2 and, like all conference, had to change course. We opted not to hold a virtual conference, however, we wanted to take some time to highlight a few oclif features shipped this year.
Feature: Help templating​
One of the most requested features, help templating enables oclif developers to customize the help output for their CLI.
Read the announcement.
Feature: Custom error delegation​
This feature both improved how oclif throws and handles errors and allows oclif developers to overwrite or interject in oclif’s error handling.
Read the announcement.
Feature: postrun hooks​
We have added a new lifecycle event postrun. Your CLI can now run a hook after a command has ran.
See our hook documentation.
Feature: Root index command​
Previously, oclif would display CLI help if only the binary name with no command ID was invoked, oclif now supports a "root index" command. If present, a command defined at src/commands/index.ts will be run if no command ID is found.
1 million weekly downloads​
While exact oclif usage metrics are hard to pin down, we use npm download statistics of oclif packages as a rough approximation. Earlier this year, oclif's command package hit 1 million weekly downloads for the first time!
This year has been presented its challenges on everyone. We want to thank you, oclif developers, whom have taken the time to use and improve the oclif project. We look forward to seeing you all - in person - in the future!
All our best,
The oclif teamPretty Printable ErrorsJuly 1, 2020 · One min readOften CLIs are used as handy tools and when things go wrong it’s useful to have additional context. In oclif we have added a couple of additional properties that can show extra context to the users when an error is displayed. The code, ref and suggestions will now be displayed if they are included. This will work with an existing oclif CLI by adding the latest @oclif/errors and @oclif/core to the CLI's package.json dependencies.
For example, using this.error with the additional properties:
class TestError extends Command {  async run() {    this.error("An error has occurred!", {      code: "OCLIF_ERR",      ref: "https://oclif.io/docs/commands#thiserrormessage-string--error-options-code-string-exit-number",      suggestions: ["Use these extra properties to provide additional context"],    })  }}
would result with the following output:
›   Error: An error has occurred!›   Code: OCLIF_ERR›   Try this: Use these extra properties to provide additional context›   Reference: https://oclif.io/docs/commands#thiserrormessage-string--error-options-code-string-exit-number
If these properties are not provided then nothing changes and the CLI will continue to display the single error message output as it did before. Additionally, as part of this exercise we’ve added documentation around Error Handling in oclif which should come in handy if the need arises to extend oclif’s default handling of errors.Customizing Help in oclifMay 5, 2020 · 2 min readOut of the box oclif provides a great help experience for CLIs.
But what if, as an oclif developer, you want to customize some or all of the output?
You can now customize your CLI's help output by implementing the HelpBase abstract class.
Getting started with custom help​
If you have not done so yet, update @oclif/core.
$ yarn add --latest @oclif/core
To get started, first define the filepath to your help class in oclif's config in package.json. This is a relative path to the help class, without a file extension.
For this example, the help class will be created in a file at "[project root]/src/help.ts".
{  // ...  "oclif": {    "helpClass": "./lib/help"    // ...  }  // ...}
From here there are two paths, implement the HelpBase abstract class yourself or overwrite the parts of the default Help class you want to customize (ex: how command usage is displayed). We recommend the latter approach but cover both in the new Help Classes docs.
Separating TOPICS & COMMANDS in the new default Help class​
Previously, topics and child commands were listed in help output under a single list heading called "COMMANDS". But we found this can be slightly confusing. Some topics are commands also (a.k.a. topic-commands) while others are simply organizational namespacing (and when ran just show their help).
The new default Help class splits the list of children into distinct lists of "TOPICS" and "COMMANDS", with the possibility of an item appearing in both if it a topic-command. This makes it clearer what is expected to be ran - "COMMANDS" - and what is providing structure - "TOPICS" - when looking at the help output.
VERSION  plugin-help-example/0.0.0 darwin-x64 node-v12.12.0USAGE  $ plugin-help-example [COMMAND]TOPICS  topic  this is a topic and has child topics or commandsCOMMANDS  hello  describe the command here  help   display help for plugin-help-example
We look forward to seeing what custom help features you implement in your oclif CLIs with this new feature!oclif TSLint to ESLint MigrationDecember 5, 2019 · 3 min readBack in February of this year, plans were announced to deprecate TSLint in favor of ESLint. TSLint's goal has become to work toward a “unified developer experience” by supporting ESLint development going forward.
What has changed in oclif​
To keep inline with the community, oclif has transitioned to ESLint for all our core libraries as well as all our official plugins.
Starting in v1.15.x, oclif will now optionally generate projects with ESLint for both TypeScript and JavaScript CLI’s.
ESLint does require Node to be on stable LTS version, at the time of writing, Node 8.10.x, Node 10.13.x & Node 12.x.x.
How does this affect you​
Existing CLI’s are unchanged, but any newly generated CLI's will only give the option of using ESLint. If you are running tslint in your CLI, we recommend you switch to ESLint as well.
In migrating our projects we took the following steps (for an example of these changes see this pull request).


Install eslint
$ yarn add eslint eslint-config-oclif eslint-config-oclif-typescript --dev


Add eslint related files


$ echo '{  "extends": [    "oclif",    "oclif-typescript"  ],  "rules": {  }}' > .eslintrc


Remove tslint and related packages
$ yarn remove @oclif/tslint tslint


Remove tslint related configuration files
$ rm tslint.json


Change lint script in our package.json from something like:
"lint": "tsc -p test --noEmit && tslint -p test -t stylish"
to
"lint": "eslint . --ext .ts --config .eslintrc"


To preserve the test compile (tsc -p test --noEmit) we also made the following updates to our scripts:
"pretest": "tsc -p test --noEmit"
In some cases we had our posttest duplicating the same steps as our lint script so it’s cleaner to have it reference the lint job directly with:
"posttest": "yarn lint"

Run yarn lint --fix. This attempts to auto-fix any linting violations automatically. In the case an auto-fix isn’t available it should be fixed manually or ignored (see the eslint configuration doc for more information)
Do a search in the codebase for tslint and remove any unnecessary tslint disabling comments, like:

/* tslint:disable:object-literal-sort-keys */
If you are on a version of Node that is not supported by ESLint, you will also need to update your Node engine. ESLint supports Node 8, 10, and 12 so you should upgrade to the most recent Node version compatible with your CLI and also supported by ESLint (see ESLint's Installation and Usage instructions).
When will this take effect​
These changes have taken effect in oclif v1.15.1. When you generate a new CLI or plugin it will now contain configuration for ESLint instead of TSLint.oclif's Current Node SupportOctober 31, 2019 · 3 min readTo maintain a healthy project trajectory, oclif follows and supports Node Active LTS release, currently Node 10 & Node 12. This means ensuring that oclif continues to play nice with coming Active LTS Node versions and other packages in the ecosystem. Moving forward also means leaving older versions behind. Starting in 2020, Node will stop maintaining Node 8 and it is our intent at that time to also follow suit. Let’s take a look at a few ways we will be supporting these changes.
CI Environments​
CLIs created with the oclif cli going forward will be generated with a CircleCI configuration with Node 10 & 12 and an Appveyor configuration using Node 10. We have also added Node latest to CircleCi to be an early warning detection against coming Node changes (Node latest is managed by CircleCI).
We have already updated every oclif repo's CI configs to reflect this.
If your existing CLI uses either Appveyor or CircleCI you can update your config files also, like so:
.circleci/config.yml​
Your CircleCI config should contain a node-latest job, aliased as test. From this, there should be two extensions of this job for the Active LTS Node versions, Node 10 and Node 12.
  node-10:    <<: *node-latest    docker:      - image: node:10  node-12:    <<: *node-latest    docker:      - image: node:12
Notice that these declarations only change the Docker Node images used to run that job.
Additionally, the jobs listed within workflows must also be updated to reflect our changes in configuration:
    jobs:      - node-latest      - node-10      - node-12
appveyor.yml​
For appveyor we are currently only testing the oldest Active LTS Node version, Node 10. Update the nodejs_version proppert in your appveyor.yml file to reflect this.
environment:  nodejs_version: "10"
Deprecating Node 8 & Updating packge.json engines​
In Jan 2020, Node will end its Node 8 maintenance. We will follow suit by setting the package.json engine property in oclif packages to >=10 and bumping the package's major versions.
Depending on how you ship your CLI you may wish to also bump the engines version in your CLI's package.json. You can read more about the implications of the engines property configuration in the npm documentation.
Also consider distributing your CLI with its own Node version.
Packaged Node Version​
When using dev-cli to pack your CLI it will use the Node version as specified in your package.json under the oclif.update.node.version property. This value should reflect an Active LTS Node version (dev-cli does not currently enforce versions).
Supporting the future​
As a community we may discover bumps along the way as we upgrade. If you notice something related to oclif please feel free to open an issue or submit a pull request under the relevant oclif package within the org.
We look forward to using the latest from Node and the community and keeping oclif healthy along the way.oclifconf 2019: A RecapSeptember 16, 2019 · 4 min readIn May, Heroku and Salesforce Open Source organized oclifconf, a conference for developers & product managers building CLI tools on top of the open source oclif framework. The speakers came from various tech companies, such as Adobe, Netlify, and Apollo, who have already built amazing CLI experiences. The topics covered everything from the incredible capabilities oclif has unlocked, to the community-built plugins extending its functionality, and even what the behavior of an adaptive CLI tool might look like.
Below is a listing of all of the talks from the event, along with a short summary. Enjoy!
The future of oclif by Jeff Dickey​

In its relatively short lifetime, oclif has already inspired many developers and companies to adopt its framework as a means for implementing their own command-line tooling. In this talk, Jeff Dickey, an oclif founding team member, recaps the project's history and inspiration. He also looks towards the future and outlines some features and improvements that the tool could adapt. This isn't so much a definitive roadmap of where oclif is headed, but rather, a call to inspiration for developers eager to contribute! And if you are interested in contributing, check out the open issues in the oclif GitHub repo and come say "Hello!" on Spectrum Chat.
Open Source Citizenship by Josh Simmons​

When it comes to open source, it's more than just individuals now. More and more frequently, large corporations are contributing to projects by donating to contributors, sponsoring events, or upstreaming contributions. But keeping open source projects and communities healthy requires more than just money and brainpower. Josh Simmons surveyed multiple open source communities and relays his findings as to what help maintainers and contributors actually need in this talk.
Building an enterprise-grade CLI with oclif by Thomas Dvornik​

Security and performance are all about trust. While oclif is an extremely extensible framework for building CLI tooling, there are additional requirements to fulfill for enterprise businesses to adopt it that might not be necessary for individual developers. Thomas Dvornik outlines what he and his colleagues at Salesforce have implemented as plugins to oclif to satisfy these needs, including encrypted OAuth, plugin signing, lazy loading dependencies, synchronizing weekly releases and deprecations across dozens of repositories, and establishing cross-team coding and documentation standards.
How Adobe I/O built an extensible CLI with oclif by Jesse MacFadyen​

Perhaps oclif's most appealing feature is its support for plugins. In Cordova's case, they've created a sophisticated telemetry system that helps Adobe developers see which commands users are using--and reports on which ones are erroring out. By embedding a feedback system into the tool, users are even able to quickly send their suggestions to a form, without ever leaving the terminal. Jesse MacFadyen demonstrates how oclif's plugin system can work beyond simply executing commands.
Integrating oclif with GraphQL and Apollo by Evans Hauser​

For Evans Hauser and the team at Apollo, oclif is best thought of as "React for the CLI." As a client paired with a strongly-typed API contract to a server, it can deliver structured and consistent commands to retrieve external data. What better mechanism to use for this transfer than GraphQL, a framework which empowers the client to ask precisely for the data it needs, and nothing more?
Adaptive Intent-based CLI State Machines by Shawn Wang​

In designing oclif, Jeff Dickey wrote out 12 CLI factors to keep in mind. In this talk, Shawn Wang outlines a 13th: state. State is hard, because it depends on context, and context depends on understanding what a user intends to do, not what they are asking. Shawn is working towards enabling oclif to better understand the commands a user has entered, so that it can predict and interpret future commands that might be entered next. This would enable CLI tools to not just interpret a users' commands, but to also interpret their intent.Older Entries\n\n\n\nIntroducing `oclif init` commandApril 10, 2024 · 2 min readThanks to the contribution of @joshcanhelp we released a new command for the oclif CLI called oclif init in version 4.8.0
The oclif init command allows you to initialize oclif in an existing project directory by adding the bare minimum requirements: a few pieces of configuration, bin scripts, and a couple of dependencies (@oclif/core and ts-node). This is slightly different from oclif generate, which will create an entirely new oclif project based on our templates.
oclif init will add the following:

bin scripts: bin/run.js, bin/run.cmd, bin/dev.js, and bin/dev.cmd
oclif section to package.json with bin, dirname, commands, and topicSeparator set (See Configuring Your CLI for more)
@oclif/core to dependencies in your package.json (if it's not already there)
ts-node to devDependencies in your package.json (if it's not already there)

Once you've initialized oclif, you can use the bin scripts to execute your CLI. You can also use the other oclif commands like oclif generate command and oclif generate hook to start adding new functionality.

❯ oclif init --helpInitialize a new oclif CLIUSAGE  $ oclif init [--bin <value>] [--module-type ESM|CommonJS] [--package-manager npm|yarn|pnpm] [--topic-separator    colons|spaces] [-d <value>] [-y]FLAGS  -d, --output-dir=<value>        Directory to initialize the CLI in.  -y, --yes                       Use defaults for all prompts. Individual flags will override defaults.      --bin=<value>               Supply answer for prompt: Command bin name the CLI will export      --module-type=<option>      Supply answer for prompt: Select a module type                                  <options: ESM|CommonJS>      --package-manager=<option>  Supply answer for prompt: Select a package manager                                  <options: npm|yarn|pnpm>      --topic-separator=<option>  Supply answer for prompt: Select a topic separator                                  <options: colons|spaces>DESCRIPTION  Initialize a new oclif CLI  This will add the necessary oclif bin files, add oclif config to package.json, and install @oclif/core and ts-node.EXAMPLES  Initialize a new CLI in the current directory    $ oclif init  Initialize a new CLI in a different directory    $ oclif init --output-dir "/path/to/existing/project"  Supply answers for specific prompts    $ oclif init --topic-separator colons --bin mycli
Hope you enjoy the new command! If you come across any issues or have any new ideas for this command, head over to the oclif/oclif repo and open a new issue.
All our best,
The oclif teamoclif Spring 2024 UpdateMarch 29, 2024 · 4 min readHello oclif developers! It's been a while since we last uploaded a blog - and a lot has happened.
We've been focusing on these high-level areas over the past couple of years:

Improving @oclif/core
ESM Support
Improving and revitalizing oclif.io
Re-engaging the oclif community

Improving @oclif/core​
Since we announced @oclif/core over three years ago, we've released two new major versions, each packed with lots of features that we're really excited about.
Here are some of these changes:

Full support for ESM and interoperability with CommonJS (more on this topic below).
Configurable command discovery strategies that give you more control over how commands are loaded at runtime. Check out the docs.
A new preparse hook that allows you to manipulate the provided arguments before they're parsed. Salesforce used this hook to implement a neat --flags-dir feature that translates local files into flags.
A new Performance class that you can use to track performance inside of @oclif/core and your own CLI or plugin. Check out the docs.
A new flag type, Flags.option, that lets you define a flag with a preset list of options. Typescript then uses the options to infer the flag's type.
Flags now have a relationship property that allows you to define more complex relationships between flags. Check out the flags docs for more information.
Flags now have a defaultHelp property that allows you to set the human readable default value in the command help. This property is useful when your flag's parse method returns a complex type, such as an object or a class. Check out the flags docs for more.
Commands now have a hiddenAliases property that allows you to define aliases that you want to hide from the user. The property is super helpful when you're trying to wean users off a deprecated command.
You can now use bun or tsx as dev runtimes (as opposed to node or ts-node).
A command's usage, args, and flags are now shown whenever a user forgets to provide a required arg or flag, or when they provided a non-existent flag.

If you need help migrating to the latest version, head over to core's README which has links to the migration guides. Feel free to open a new discussion if you need more hands-on help from us or the community.
ESM Support​
Version 3 of @oclif/core introduced full support for developing ESM plugins and CLIs. It also offered full support for interoperability between CommonJS and ESM plugins.
Put more simply, you can now migrate your CLI to ESM while keeping individual plugins in CommonJS (or vice versa). The upgrade path is now much simpler for you. You also don't need to worry about any community plugins that have migrated to ESM before you did (such as all the @oclif plugins) or are staunchly sticking with CommonJS for the foreseeable future.
Read more about this topic here.
Improving and Revitalizing oclif.io​
Another area of focus for us has been improving our documentation site, oclif.io.
While improving the quality and accuracy of the documentation was our priority, we also took the time to upgrade to the latest version of docusaurus. This new version gave our site a much-needed facelift, as well as cool new features such as dark mode and announcements.
If you have any feedback or are running into issues, we want to hear about it. Just create an issue in the oclif.io repo.
Re-engaging the oclif Community​
Lastly, our biggest priority at the moment is to re-engage the oclif community. We understand how frustrating it has been over the years to see your issues and pull requests go unacknowledged. We apologize for not prioritizing the community, and are earnestly trying to make sure that every issue and pull request gets the attention it deserves going forward.
We also opened up GitHub discussions for @oclif/core and the oclif CLI, where you can now post your questions or ideas. We hope you take advantage of them, we love hearing from you!
One last thing: we intend to publicly post our roadmap so you have more visibility into what we're working on. Stay tuned!
All our best,
The oclif teamAnnouncing oclif v2!January 12, 2022 · 5 min readHello and happy new year! It's our great pleasure to announce that we have released oclif v2, which uses the new @oclif/core library! 🎉
oclif v2 includes many changes that improve the experience of both creating and using an oclif CLI.
Going forward, we don't plan to make any updates to oclif v1 and its corresponding libraries, except for critical security fixes. See the compatibility matrix for a list of these libraries. In order to give developers time to migrate from v1 to v2, we're not completely dropping support yet. But at some point in the future we'll archive the v1 repositories and deprecate their versions on npm.
What’s changing?​
Repository Changes​
All repositories under the oclif org now use main as their primary branch and oclif-v1 as the legacy branch. The main  branch corresponds to oclif v2 and the oclif-v1 branch to oclif v1. If you find any repos that don’t have a main branch, you can safely assume that they're not used in oclif v2 and will be deprecated in the future.
Consolidating Tools & Libraries​
The oclif-dev CLI has now been incorporated into oclif. You now no longer need to install a separate package to manage your entire CLI’s lifecycle.
The following libraries have been consolidated under @oclif/core and will be deprecated at some point in the future. Read the migration guide to learn how to update your CLI or plugin to use the new core library.

@oclif/command
@oclif/config
@oclif/error
@oclif/help
@oclif/parser

No more single vs multi command CLIs​
There's only one "type" of oclif v2 CLI, but it can have as few or as many commands as a developer wants. As a result, there’s only one command to generate CLIs, oclif generate, as opposed to the old oclif single and oclif multi commands.
Node > 12​
To ensure oclif CLIs are as secure as possible, all v2 libraries and plugins support only Node 12 or higher as of now. Going forward, they'll support only Node Maintenance or higher, as defined by Node's release schedule here: https://nodejs.org/en/about/releases/.
What’s new?​
New example CLI​
oclif-hello-world is our new example repo. This is also the repo that's used as a template when running oclif generate to create a new CLI. This repo will always be able to be referenced as an example of what an oclif v2 CLI should look like.
Spaced commands​
oclif CLIs can now use spaces, instead of colons, to separate topics and subcommands. To enable this feature, simply add “topicSeparator": " " to the oclif config in your package.json. See an example in our example repo.
// Old commands that use :$ mycli do:something
// New spaced commands$ mycli do something

Note: Spaced commands are backwards compatible. So if you enable spaced commands for your CLI, users will still be able to use : as a separator. This ensures that any existing scripts don't break.

New Help Output​
We’ve revamped the way command help is outputted to the terminal, making it both easier to implement and easier to read. See the difference between the old help output on the left and the new help output on the right in the screenshots below.
oclif v1oclif v2
Notice that there are new sections for flags and global flags, examples are displayed with better spacing, and there is a section at the bottom called Configuration Variables. This Configuration Variables section is not part of the new help by default. But we've added support for custom help sections, which is what the sf CLI uses to create the new section.
Async Command Parsing​
We’ve also improved the performance of new CLIs by rewriting how commands are parsed on initialization. The new parser is asynchronous, which makes CLIs with a lot of commands or installed  plugins much faster.
What’s coming next?​
Part of our charter for the release of oclif v2 includes improving our engagement with the oclif community. We know that over the past couple of years we’ve reduced our involvement, and a lot of issues and PRs have languished in limbo. Hopefully you’ve already seen increased activity and responses from oclif maintainers recently, but if you haven’t, please don’t hesitate to ping us by tagging @admins in oclif repos.
We also want to start interviewing members of the oclif community to acquire feedback and prioritize the features and fixes you deem most important!
Best,
The oclif team

Reference material​
Migration Guide​
This guide explains how to upgrade a CLI or plugin from the old oclif v1 libraries to the new @oclif/core library that oclif v2 uses.
https://github.com/oclif/core/blob/main/MIGRATION.md
Compatibility Matrix​
The following matrix shows how the v1 libraries and plugins relate to the new v2 ones. Use this matrix as a guide to know what to drop and which versions to switch when upgrading your plugins and CLIs to v2.
oclif "v1"oclif "v2"Utility CLIsoclif@<2@oclif/dev-cli@<2oclif@>=2Main packages@oclif/command@oclif/config@oclif/errors@oclif/parser@oclif/plugin-help@oclif/core@>=1Node LTSNode v8-14Node v12+ (at time of writing)TypeScripttypescript@<4typescript@>=4Main plugins@oclif/plugin-autocomplete@<1@oclif/plugin-commands@<2@oclif/plugin-help@<4@oclif/plugin-not-found@<2@oclif/plugin-plugins@<2@oclif/plugin-update@<2plugin-warn-if-update-available@<2plugin-which@<2@oclif/plugin-autocomplete@>=1@oclif/plugin-commands@>=2@oclif/plugin-help@>=4@oclif/plugin-not-found@>=2@oclif/plugin-plugins@>=2@oclif/plugin-update@>=2@oclif/plugin-warn-if-update-available@>=2@oclif/plugin-which@>=2Introducing @oclif/coreMarch 1, 2021 · 3 min readGreetings!
We hope this blog post finds you well.
Introducing...​
We are excited to announce the next iteration of the oclif project today: @oclif/core.
We have learned a lot in the last three years of developing oclif, developing on oclif and supporting millions of command runs a day via Heroku and Salesforce CLIs.
@oclif/core ("Core") simplifies the oclif development experience and introduces highly requested new features.
Core combines the essential oclif packages into one "core" package, aptly named @oclif/core.
Core also introduces:

A default command option
Colon or space command syntax
Async command parsing
Command piping to arguments

With the introduction of default command functionality, Core simplifies the oclif project and removes the notion of single or multi command CLIs. Core CLIs can have 1 or many commands.
Along with Core, we moved the oclif-dev CLI into the oclif CLI creating a single "utility" CLI. This CLI also introduces a new AWS S3 compatible publishing scheme.
What to expect in the near future​
Core is in pre-release beta and being actively developed for new internal Salesforce CLIs.
Much documentation needs to be written in the coming months including migration paths. Migration onto Core should be as painless as possible with many exports remaining entirely unchanged. Look for forthcoming blog posts and documentation on oclif.io.
Early this summer, tentively June 1, we will release Core v1. Core's release will coincide with major bumps to many other oclif plugin packages. See the compatibility matrix below.
At Core's v1 release, the current "main" oclif packages (namely: command, config, errors & parser) will go into maintenance mode until Jan 2022. They will receive only bug and security fixes and they remain compatible with current versions of the oclif and oclif-dev CLIs. Afterwhich, they will be archived.
Companioning Core, the next major release of the oclif CLI (literally oclif@2) will generate Core CLIs.
Going forward​
We are excited to release Core! We invite you to poke around the Core repo. It may appear to be a big change but Core keeps what you already enjoy about oclif while reducing development complexity, project dependencies, package coupling and bundle size and introduces many requested features previously too prickly to weave into the current oclif architecture.
Best,
The oclif team
Reference: Compatibility matrix​
oclif "v1"oclif "Core"Utility CLIsoclif@<2@oclif/dev-cli@<2oclif@>=2Main packages@oclif/core@<2@oclif/config@<2@oclif/errors@<2@oclif/parser@<4@oclif/plugin-help@<4@oclif/core@>=1Node LTSNode v8-14Node v12+TypeScripttypescript@<4typescript@>=4Main plugins@oclif/plugin-autocomplete@<1@oclif/plugin-commands@<2@oclif/plugin-help@<4@oclif/plugin-not-found@<2@oclif/plugin-plugins@<2@oclif/plugin-update@<2plugin-warn-if-update-available@<2plugin-which@<2@oclif/plugin-autocomplete@>=2@oclif/plugin-commands@>=2@oclif/plugin-help@>=4@oclif/plugin-not-found@>=2@oclif/plugin-plugins@>=2@oclif/plugin-update@>=2@oclif/plugin-warn-if-update-available@>=2@oclif/plugin-which@>=2oclif Summer 2020 UpdateAugust 26, 2020 · 2 min readHello oclif developers! We hope you are all doing well.
Earlier this year, we started our planning for oclifconf v2 and, like all conference, had to change course. We opted not to hold a virtual conference, however, we wanted to take some time to highlight a few oclif features shipped this year.
Feature: Help templating​
One of the most requested features, help templating enables oclif developers to customize the help output for their CLI.
Read the announcement.
Feature: Custom error delegation​
This feature both improved how oclif throws and handles errors and allows oclif developers to overwrite or interject in oclif’s error handling.
Read the announcement.
Feature: postrun hooks​
We have added a new lifecycle event postrun. Your CLI can now run a hook after a command has ran.
See our hook documentation.
Feature: Root index command​
Previously, oclif would display CLI help if only the binary name with no command ID was invoked, oclif now supports a "root index" command. If present, a command defined at src/commands/index.ts will be run if no command ID is found.
1 million weekly downloads​
While exact oclif usage metrics are hard to pin down, we use npm download statistics of oclif packages as a rough approximation. Earlier this year, oclif's command package hit 1 million weekly downloads for the first time!
This year has been presented its challenges on everyone. We want to thank you, oclif developers, whom have taken the time to use and improve the oclif project. We look forward to seeing you all - in person - in the future!
All our best,
The oclif teamPretty Printable ErrorsJuly 1, 2020 · One min readOften CLIs are used as handy tools and when things go wrong it’s useful to have additional context. In oclif we have added a couple of additional properties that can show extra context to the users when an error is displayed. The code, ref and suggestions will now be displayed if they are included. This will work with an existing oclif CLI by adding the latest @oclif/errors and @oclif/core to the CLI's package.json dependencies.
For example, using this.error with the additional properties:
class TestError extends Command {  async run() {    this.error("An error has occurred!", {      code: "OCLIF_ERR",      ref: "https://oclif.io/docs/commands#thiserrormessage-string--error-options-code-string-exit-number",      suggestions: ["Use these extra properties to provide additional context"],    })  }}
would result with the following output:
›   Error: An error has occurred!›   Code: OCLIF_ERR›   Try this: Use these extra properties to provide additional context›   Reference: https://oclif.io/docs/commands#thiserrormessage-string--error-options-code-string-exit-number
If these properties are not provided then nothing changes and the CLI will continue to display the single error message output as it did before. Additionally, as part of this exercise we’ve added documentation around Error Handling in oclif which should come in handy if the need arises to extend oclif’s default handling of errors.Customizing Help in oclifMay 5, 2020 · 2 min readOut of the box oclif provides a great help experience for CLIs.
But what if, as an oclif developer, you want to customize some or all of the output?
You can now customize your CLI's help output by implementing the HelpBase abstract class.
Getting started with custom help​
If you have not done so yet, update @oclif/core.
$ yarn add --latest @oclif/core
To get started, first define the filepath to your help class in oclif's config in package.json. This is a relative path to the help class, without a file extension.
For this example, the help class will be created in a file at "[project root]/src/help.ts".
{  // ...  "oclif": {    "helpClass": "./lib/help"    // ...  }  // ...}
From here there are two paths, implement the HelpBase abstract class yourself or overwrite the parts of the default Help class you want to customize (ex: how command usage is displayed). We recommend the latter approach but cover both in the new Help Classes docs.
Separating TOPICS & COMMANDS in the new default Help class​
Previously, topics and child commands were listed in help output under a single list heading called "COMMANDS". But we found this can be slightly confusing. Some topics are commands also (a.k.a. topic-commands) while others are simply organizational namespacing (and when ran just show their help).
The new default Help class splits the list of children into distinct lists of "TOPICS" and "COMMANDS", with the possibility of an item appearing in both if it a topic-command. This makes it clearer what is expected to be ran - "COMMANDS" - and what is providing structure - "TOPICS" - when looking at the help output.
VERSION  plugin-help-example/0.0.0 darwin-x64 node-v12.12.0USAGE  $ plugin-help-example [COMMAND]TOPICS  topic  this is a topic and has child topics or commandsCOMMANDS  hello  describe the command here  help   display help for plugin-help-example
We look forward to seeing what custom help features you implement in your oclif CLIs with this new feature!oclif TSLint to ESLint MigrationDecember 5, 2019 · 3 min readBack in February of this year, plans were announced to deprecate TSLint in favor of ESLint. TSLint's goal has become to work toward a “unified developer experience” by supporting ESLint development going forward.
What has changed in oclif​
To keep inline with the community, oclif has transitioned to ESLint for all our core libraries as well as all our official plugins.
Starting in v1.15.x, oclif will now optionally generate projects with ESLint for both TypeScript and JavaScript CLI’s.
ESLint does require Node to be on stable LTS version, at the time of writing, Node 8.10.x, Node 10.13.x & Node 12.x.x.
How does this affect you​
Existing CLI’s are unchanged, but any newly generated CLI's will only give the option of using ESLint. If you are running tslint in your CLI, we recommend you switch to ESLint as well.
In migrating our projects we took the following steps (for an example of these changes see this pull request).


Install eslint
$ yarn add eslint eslint-config-oclif eslint-config-oclif-typescript --dev


Add eslint related files


$ echo '{  "extends": [    "oclif",    "oclif-typescript"  ],  "rules": {  }}' > .eslintrc


Remove tslint and related packages
$ yarn remove @oclif/tslint tslint


Remove tslint related configuration files
$ rm tslint.json


Change lint script in our package.json from something like:
"lint": "tsc -p test --noEmit && tslint -p test -t stylish"
to
"lint": "eslint . --ext .ts --config .eslintrc"


To preserve the test compile (tsc -p test --noEmit) we also made the following updates to our scripts:
"pretest": "tsc -p test --noEmit"
In some cases we had our posttest duplicating the same steps as our lint script so it’s cleaner to have it reference the lint job directly with:
"posttest": "yarn lint"

Run yarn lint --fix. This attempts to auto-fix any linting violations automatically. In the case an auto-fix isn’t available it should be fixed manually or ignored (see the eslint configuration doc for more information)
Do a search in the codebase for tslint and remove any unnecessary tslint disabling comments, like:

/* tslint:disable:object-literal-sort-keys */
If you are on a version of Node that is not supported by ESLint, you will also need to update your Node engine. ESLint supports Node 8, 10, and 12 so you should upgrade to the most recent Node version compatible with your CLI and also supported by ESLint (see ESLint's Installation and Usage instructions).
When will this take effect​
These changes have taken effect in oclif v1.15.1. When you generate a new CLI or plugin it will now contain configuration for ESLint instead of TSLint.oclif's Current Node SupportOctober 31, 2019 · 3 min readTo maintain a healthy project trajectory, oclif follows and supports Node Active LTS release, currently Node 10 & Node 12. This means ensuring that oclif continues to play nice with coming Active LTS Node versions and other packages in the ecosystem. Moving forward also means leaving older versions behind. Starting in 2020, Node will stop maintaining Node 8 and it is our intent at that time to also follow suit. Let’s take a look at a few ways we will be supporting these changes.
CI Environments​
CLIs created with the oclif cli going forward will be generated with a CircleCI configuration with Node 10 & 12 and an Appveyor configuration using Node 10. We have also added Node latest to CircleCi to be an early warning detection against coming Node changes (Node latest is managed by CircleCI).
We have already updated every oclif repo's CI configs to reflect this.
If your existing CLI uses either Appveyor or CircleCI you can update your config files also, like so:
.circleci/config.yml​
Your CircleCI config should contain a node-latest job, aliased as test. From this, there should be two extensions of this job for the Active LTS Node versions, Node 10 and Node 12.
  node-10:    <<: *node-latest    docker:      - image: node:10  node-12:    <<: *node-latest    docker:      - image: node:12
Notice that these declarations only change the Docker Node images used to run that job.
Additionally, the jobs listed within workflows must also be updated to reflect our changes in configuration:
    jobs:      - node-latest      - node-10      - node-12
appveyor.yml​
For appveyor we are currently only testing the oldest Active LTS Node version, Node 10. Update the nodejs_version proppert in your appveyor.yml file to reflect this.
environment:  nodejs_version: "10"
Deprecating Node 8 & Updating packge.json engines​
In Jan 2020, Node will end its Node 8 maintenance. We will follow suit by setting the package.json engine property in oclif packages to >=10 and bumping the package's major versions.
Depending on how you ship your CLI you may wish to also bump the engines version in your CLI's package.json. You can read more about the implications of the engines property configuration in the npm documentation.
Also consider distributing your CLI with its own Node version.
Packaged Node Version​
When using dev-cli to pack your CLI it will use the Node version as specified in your package.json under the oclif.update.node.version property. This value should reflect an Active LTS Node version (dev-cli does not currently enforce versions).
Supporting the future​
As a community we may discover bumps along the way as we upgrade. If you notice something related to oclif please feel free to open an issue or submit a pull request under the relevant oclif package within the org.
We look forward to using the latest from Node and the community and keeping oclif healthy along the way.oclifconf 2019: A RecapSeptember 16, 2019 · 4 min readIn May, Heroku and Salesforce Open Source organized oclifconf, a conference for developers & product managers building CLI tools on top of the open source oclif framework. The speakers came from various tech companies, such as Adobe, Netlify, and Apollo, who have already built amazing CLI experiences. The topics covered everything from the incredible capabilities oclif has unlocked, to the community-built plugins extending its functionality, and even what the behavior of an adaptive CLI tool might look like.
Below is a listing of all of the talks from the event, along with a short summary. Enjoy!
The future of oclif by Jeff Dickey​

In its relatively short lifetime, oclif has already inspired many developers and companies to adopt its framework as a means for implementing their own command-line tooling. In this talk, Jeff Dickey, an oclif founding team member, recaps the project's history and inspiration. He also looks towards the future and outlines some features and improvements that the tool could adapt. This isn't so much a definitive roadmap of where oclif is headed, but rather, a call to inspiration for developers eager to contribute! And if you are interested in contributing, check out the open issues in the oclif GitHub repo and come say "Hello!" on Spectrum Chat.
Open Source Citizenship by Josh Simmons​

When it comes to open source, it's more than just individuals now. More and more frequently, large corporations are contributing to projects by donating to contributors, sponsoring events, or upstreaming contributions. But keeping open source projects and communities healthy requires more than just money and brainpower. Josh Simmons surveyed multiple open source communities and relays his findings as to what help maintainers and contributors actually need in this talk.
Building an enterprise-grade CLI with oclif by Thomas Dvornik​

Security and performance are all about trust. While oclif is an extremely extensible framework for building CLI tooling, there are additional requirements to fulfill for enterprise businesses to adopt it that might not be necessary for individual developers. Thomas Dvornik outlines what he and his colleagues at Salesforce have implemented as plugins to oclif to satisfy these needs, including encrypted OAuth, plugin signing, lazy loading dependencies, synchronizing weekly releases and deprecations across dozens of repositories, and establishing cross-team coding and documentation standards.
How Adobe I/O built an extensible CLI with oclif by Jesse MacFadyen​

Perhaps oclif's most appealing feature is its support for plugins. In Cordova's case, they've created a sophisticated telemetry system that helps Adobe developers see which commands users are using--and reports on which ones are erroring out. By embedding a feedback system into the tool, users are even able to quickly send their suggestions to a form, without ever leaving the terminal. Jesse MacFadyen demonstrates how oclif's plugin system can work beyond simply executing commands.
Integrating oclif with GraphQL and Apollo by Evans Hauser​

For Evans Hauser and the team at Apollo, oclif is best thought of as "React for the CLI." As a client paired with a strongly-typed API contract to a server, it can deliver structured and consistent commands to retrieve external data. What better mechanism to use for this transfer than GraphQL, a framework which empowers the client to ask precisely for the data it needs, and nothing more?
Adaptive Intent-based CLI State Machines by Shawn Wang​

In designing oclif, Jeff Dickey wrote out 12 CLI factors to keep in mind. In this talk, Shawn Wang outlines a 13th: state. State is hard, because it depends on context, and context depends on understanding what a user intends to do, not what they are asking. Shawn is working towards enabling oclif to better understand the commands a user has entered, so that it can predict and interpret future commands that might be entered next. This would enable CLI tools to not just interpret a users' commands, but to also interpret their intent.\n\nIntroducing `oclif init` commandApril 10, 2024 · 2 min readThanks to the contribution of @joshcanhelp we released a new command for the oclif CLI called oclif init in version 4.8.0
The oclif init command allows you to initialize oclif in an existing project directory by adding the bare minimum requirements: a few pieces of configuration, bin scripts, and a couple of dependencies (@oclif/core and ts-node). This is slightly different from oclif generate, which will create an entirely new oclif project based on our templates.
oclif init will add the following:

bin scripts: bin/run.js, bin/run.cmd, bin/dev.js, and bin/dev.cmd
oclif section to package.json with bin, dirname, commands, and topicSeparator set (See Configuring Your CLI for more)
@oclif/core to dependencies in your package.json (if it's not already there)
ts-node to devDependencies in your package.json (if it's not already there)

Once you've initialized oclif, you can use the bin scripts to execute your CLI. You can also use the other oclif commands like oclif generate command and oclif generate hook to start adding new functionality.

❯ oclif init --helpInitialize a new oclif CLIUSAGE  $ oclif init [--bin <value>] [--module-type ESM|CommonJS] [--package-manager npm|yarn|pnpm] [--topic-separator    colons|spaces] [-d <value>] [-y]FLAGS  -d, --output-dir=<value>        Directory to initialize the CLI in.  -y, --yes                       Use defaults for all prompts. Individual flags will override defaults.      --bin=<value>               Supply answer for prompt: Command bin name the CLI will export      --module-type=<option>      Supply answer for prompt: Select a module type                                  <options: ESM|CommonJS>      --package-manager=<option>  Supply answer for prompt: Select a package manager                                  <options: npm|yarn|pnpm>      --topic-separator=<option>  Supply answer for prompt: Select a topic separator                                  <options: colons|spaces>DESCRIPTION  Initialize a new oclif CLI  This will add the necessary oclif bin files, add oclif config to package.json, and install @oclif/core and ts-node.EXAMPLES  Initialize a new CLI in the current directory    $ oclif init  Initialize a new CLI in a different directory    $ oclif init --output-dir "/path/to/existing/project"  Supply answers for specific prompts    $ oclif init --topic-separator colons --bin mycli
Hope you enjoy the new command! If you come across any issues or have any new ideas for this command, head over to the oclif/oclif repo and open a new issue.
All our best,
The oclif teamoclif Spring 2024 UpdateMarch 29, 2024 · 4 min readHello oclif developers! It's been a while since we last uploaded a blog - and a lot has happened.
We've been focusing on these high-level areas over the past couple of years:

Improving @oclif/core
ESM Support
Improving and revitalizing oclif.io
Re-engaging the oclif community

Improving @oclif/core​
Since we announced @oclif/core over three years ago, we've released two new major versions, each packed with lots of features that we're really excited about.
Here are some of these changes:

Full support for ESM and interoperability with CommonJS (more on this topic below).
Configurable command discovery strategies that give you more control over how commands are loaded at runtime. Check out the docs.
A new preparse hook that allows you to manipulate the provided arguments before they're parsed. Salesforce used this hook to implement a neat --flags-dir feature that translates local files into flags.
A new Performance class that you can use to track performance inside of @oclif/core and your own CLI or plugin. Check out the docs.
A new flag type, Flags.option, that lets you define a flag with a preset list of options. Typescript then uses the options to infer the flag's type.
Flags now have a relationship property that allows you to define more complex relationships between flags. Check out the flags docs for more information.
Flags now have a defaultHelp property that allows you to set the human readable default value in the command help. This property is useful when your flag's parse method returns a complex type, such as an object or a class. Check out the flags docs for more.
Commands now have a hiddenAliases property that allows you to define aliases that you want to hide from the user. The property is super helpful when you're trying to wean users off a deprecated command.
You can now use bun or tsx as dev runtimes (as opposed to node or ts-node).
A command's usage, args, and flags are now shown whenever a user forgets to provide a required arg or flag, or when they provided a non-existent flag.

If you need help migrating to the latest version, head over to core's README which has links to the migration guides. Feel free to open a new discussion if you need more hands-on help from us or the community.
ESM Support​
Version 3 of @oclif/core introduced full support for developing ESM plugins and CLIs. It also offered full support for interoperability between CommonJS and ESM plugins.
Put more simply, you can now migrate your CLI to ESM while keeping individual plugins in CommonJS (or vice versa). The upgrade path is now much simpler for you. You also don't need to worry about any community plugins that have migrated to ESM before you did (such as all the @oclif plugins) or are staunchly sticking with CommonJS for the foreseeable future.
Read more about this topic here.
Improving and Revitalizing oclif.io​
Another area of focus for us has been improving our documentation site, oclif.io.
While improving the quality and accuracy of the documentation was our priority, we also took the time to upgrade to the latest version of docusaurus. This new version gave our site a much-needed facelift, as well as cool new features such as dark mode and announcements.
If you have any feedback or are running into issues, we want to hear about it. Just create an issue in the oclif.io repo.
Re-engaging the oclif Community​
Lastly, our biggest priority at the moment is to re-engage the oclif community. We understand how frustrating it has been over the years to see your issues and pull requests go unacknowledged. We apologize for not prioritizing the community, and are earnestly trying to make sure that every issue and pull request gets the attention it deserves going forward.
We also opened up GitHub discussions for @oclif/core and the oclif CLI, where you can now post your questions or ideas. We hope you take advantage of them, we love hearing from you!
One last thing: we intend to publicly post our roadmap so you have more visibility into what we're working on. Stay tuned!
All our best,
The oclif teamAnnouncing oclif v2!January 12, 2022 · 5 min readHello and happy new year! It's our great pleasure to announce that we have released oclif v2, which uses the new @oclif/core library! 🎉
oclif v2 includes many changes that improve the experience of both creating and using an oclif CLI.
Going forward, we don't plan to make any updates to oclif v1 and its corresponding libraries, except for critical security fixes. See the compatibility matrix for a list of these libraries. In order to give developers time to migrate from v1 to v2, we're not completely dropping support yet. But at some point in the future we'll archive the v1 repositories and deprecate their versions on npm.
What’s changing?​
Repository Changes​
All repositories under the oclif org now use main as their primary branch and oclif-v1 as the legacy branch. The main  branch corresponds to oclif v2 and the oclif-v1 branch to oclif v1. If you find any repos that don’t have a main branch, you can safely assume that they're not used in oclif v2 and will be deprecated in the future.
Consolidating Tools & Libraries​
The oclif-dev CLI has now been incorporated into oclif. You now no longer need to install a separate package to manage your entire CLI’s lifecycle.
The following libraries have been consolidated under @oclif/core and will be deprecated at some point in the future. Read the migration guide to learn how to update your CLI or plugin to use the new core library.

@oclif/command
@oclif/config
@oclif/error
@oclif/help
@oclif/parser

No more single vs multi command CLIs​
There's only one "type" of oclif v2 CLI, but it can have as few or as many commands as a developer wants. As a result, there’s only one command to generate CLIs, oclif generate, as opposed to the old oclif single and oclif multi commands.
Node > 12​
To ensure oclif CLIs are as secure as possible, all v2 libraries and plugins support only Node 12 or higher as of now. Going forward, they'll support only Node Maintenance or higher, as defined by Node's release schedule here: https://nodejs.org/en/about/releases/.
What’s new?​
New example CLI​
oclif-hello-world is our new example repo. This is also the repo that's used as a template when running oclif generate to create a new CLI. This repo will always be able to be referenced as an example of what an oclif v2 CLI should look like.
Spaced commands​
oclif CLIs can now use spaces, instead of colons, to separate topics and subcommands. To enable this feature, simply add “topicSeparator": " " to the oclif config in your package.json. See an example in our example repo.
// Old commands that use :$ mycli do:something
// New spaced commands$ mycli do something

Note: Spaced commands are backwards compatible. So if you enable spaced commands for your CLI, users will still be able to use : as a separator. This ensures that any existing scripts don't break.

New Help Output​
We’ve revamped the way command help is outputted to the terminal, making it both easier to implement and easier to read. See the difference between the old help output on the left and the new help output on the right in the screenshots below.
oclif v1oclif v2
Notice that there are new sections for flags and global flags, examples are displayed with better spacing, and there is a section at the bottom called Configuration Variables. This Configuration Variables section is not part of the new help by default. But we've added support for custom help sections, which is what the sf CLI uses to create the new section.
Async Command Parsing​
We’ve also improved the performance of new CLIs by rewriting how commands are parsed on initialization. The new parser is asynchronous, which makes CLIs with a lot of commands or installed  plugins much faster.
What’s coming next?​
Part of our charter for the release of oclif v2 includes improving our engagement with the oclif community. We know that over the past couple of years we’ve reduced our involvement, and a lot of issues and PRs have languished in limbo. Hopefully you’ve already seen increased activity and responses from oclif maintainers recently, but if you haven’t, please don’t hesitate to ping us by tagging @admins in oclif repos.
We also want to start interviewing members of the oclif community to acquire feedback and prioritize the features and fixes you deem most important!
Best,
The oclif team

Reference material​
Migration Guide​
This guide explains how to upgrade a CLI or plugin from the old oclif v1 libraries to the new @oclif/core library that oclif v2 uses.
https://github.com/oclif/core/blob/main/MIGRATION.md
Compatibility Matrix​
The following matrix shows how the v1 libraries and plugins relate to the new v2 ones. Use this matrix as a guide to know what to drop and which versions to switch when upgrading your plugins and CLIs to v2.
oclif "v1"oclif "v2"Utility CLIsoclif@<2@oclif/dev-cli@<2oclif@>=2Main packages@oclif/command@oclif/config@oclif/errors@oclif/parser@oclif/plugin-help@oclif/core@>=1Node LTSNode v8-14Node v12+ (at time of writing)TypeScripttypescript@<4typescript@>=4Main plugins@oclif/plugin-autocomplete@<1@oclif/plugin-commands@<2@oclif/plugin-help@<4@oclif/plugin-not-found@<2@oclif/plugin-plugins@<2@oclif/plugin-update@<2plugin-warn-if-update-available@<2plugin-which@<2@oclif/plugin-autocomplete@>=1@oclif/plugin-commands@>=2@oclif/plugin-help@>=4@oclif/plugin-not-found@>=2@oclif/plugin-plugins@>=2@oclif/plugin-update@>=2@oclif/plugin-warn-if-update-available@>=2@oclif/plugin-which@>=2Introducing @oclif/coreMarch 1, 2021 · 3 min readGreetings!
We hope this blog post finds you well.
Introducing...​
We are excited to announce the next iteration of the oclif project today: @oclif/core.
We have learned a lot in the last three years of developing oclif, developing on oclif and supporting millions of command runs a day via Heroku and Salesforce CLIs.
@oclif/core ("Core") simplifies the oclif development experience and introduces highly requested new features.
Core combines the essential oclif packages into one "core" package, aptly named @oclif/core.
Core also introduces:

A default command option
Colon or space command syntax
Async command parsing
Command piping to arguments

With the introduction of default command functionality, Core simplifies the oclif project and removes the notion of single or multi command CLIs. Core CLIs can have 1 or many commands.
Along with Core, we moved the oclif-dev CLI into the oclif CLI creating a single "utility" CLI. This CLI also introduces a new AWS S3 compatible publishing scheme.
What to expect in the near future​
Core is in pre-release beta and being actively developed for new internal Salesforce CLIs.
Much documentation needs to be written in the coming months including migration paths. Migration onto Core should be as painless as possible with many exports remaining entirely unchanged. Look for forthcoming blog posts and documentation on oclif.io.
Early this summer, tentively June 1, we will release Core v1. Core's release will coincide with major bumps to many other oclif plugin packages. See the compatibility matrix below.
At Core's v1 release, the current "main" oclif packages (namely: command, config, errors & parser) will go into maintenance mode until Jan 2022. They will receive only bug and security fixes and they remain compatible with current versions of the oclif and oclif-dev CLIs. Afterwhich, they will be archived.
Companioning Core, the next major release of the oclif CLI (literally oclif@2) will generate Core CLIs.
Going forward​
We are excited to release Core! We invite you to poke around the Core repo. It may appear to be a big change but Core keeps what you already enjoy about oclif while reducing development complexity, project dependencies, package coupling and bundle size and introduces many requested features previously too prickly to weave into the current oclif architecture.
Best,
The oclif team
Reference: Compatibility matrix​
oclif "v1"oclif "Core"Utility CLIsoclif@<2@oclif/dev-cli@<2oclif@>=2Main packages@oclif/core@<2@oclif/config@<2@oclif/errors@<2@oclif/parser@<4@oclif/plugin-help@<4@oclif/core@>=1Node LTSNode v8-14Node v12+TypeScripttypescript@<4typescript@>=4Main plugins@oclif/plugin-autocomplete@<1@oclif/plugin-commands@<2@oclif/plugin-help@<4@oclif/plugin-not-found@<2@oclif/plugin-plugins@<2@oclif/plugin-update@<2plugin-warn-if-update-available@<2plugin-which@<2@oclif/plugin-autocomplete@>=2@oclif/plugin-commands@>=2@oclif/plugin-help@>=4@oclif/plugin-not-found@>=2@oclif/plugin-plugins@>=2@oclif/plugin-update@>=2@oclif/plugin-warn-if-update-available@>=2@oclif/plugin-which@>=2oclif Summer 2020 UpdateAugust 26, 2020 · 2 min readHello oclif developers! We hope you are all doing well.
Earlier this year, we started our planning for oclifconf v2 and, like all conference, had to change course. We opted not to hold a virtual conference, however, we wanted to take some time to highlight a few oclif features shipped this year.
Feature: Help templating​
One of the most requested features, help templating enables oclif developers to customize the help output for their CLI.
Read the announcement.
Feature: Custom error delegation​
This feature both improved how oclif throws and handles errors and allows oclif developers to overwrite or interject in oclif’s error handling.
Read the announcement.
Feature: postrun hooks​
We have added a new lifecycle event postrun. Your CLI can now run a hook after a command has ran.
See our hook documentation.
Feature: Root index command​
Previously, oclif would display CLI help if only the binary name with no command ID was invoked, oclif now supports a "root index" command. If present, a command defined at src/commands/index.ts will be run if no command ID is found.
1 million weekly downloads​
While exact oclif usage metrics are hard to pin down, we use npm download statistics of oclif packages as a rough approximation. Earlier this year, oclif's command package hit 1 million weekly downloads for the first time!
This year has been presented its challenges on everyone. We want to thank you, oclif developers, whom have taken the time to use and improve the oclif project. We look forward to seeing you all - in person - in the future!
All our best,
The oclif teamPretty Printable ErrorsJuly 1, 2020 · One min readOften CLIs are used as handy tools and when things go wrong it’s useful to have additional context. In oclif we have added a couple of additional properties that can show extra context to the users when an error is displayed. The code, ref and suggestions will now be displayed if they are included. This will work with an existing oclif CLI by adding the latest @oclif/errors and @oclif/core to the CLI's package.json dependencies.
For example, using this.error with the additional properties:
class TestError extends Command {  async run() {    this.error("An error has occurred!", {      code: "OCLIF_ERR",      ref: "https://oclif.io/docs/commands#thiserrormessage-string--error-options-code-string-exit-number",      suggestions: ["Use these extra properties to provide additional context"],    })  }}
would result with the following output:
›   Error: An error has occurred!›   Code: OCLIF_ERR›   Try this: Use these extra properties to provide additional context›   Reference: https://oclif.io/docs/commands#thiserrormessage-string--error-options-code-string-exit-number
If these properties are not provided then nothing changes and the CLI will continue to display the single error message output as it did before. Additionally, as part of this exercise we’ve added documentation around Error Handling in oclif which should come in handy if the need arises to extend oclif’s default handling of errors.Customizing Help in oclifMay 5, 2020 · 2 min readOut of the box oclif provides a great help experience for CLIs.
But what if, as an oclif developer, you want to customize some or all of the output?
You can now customize your CLI's help output by implementing the HelpBase abstract class.
Getting started with custom help​
If you have not done so yet, update @oclif/core.
$ yarn add --latest @oclif/core
To get started, first define the filepath to your help class in oclif's config in package.json. This is a relative path to the help class, without a file extension.
For this example, the help class will be created in a file at "[project root]/src/help.ts".
{  // ...  "oclif": {    "helpClass": "./lib/help"    // ...  }  // ...}
From here there are two paths, implement the HelpBase abstract class yourself or overwrite the parts of the default Help class you want to customize (ex: how command usage is displayed). We recommend the latter approach but cover both in the new Help Classes docs.
Separating TOPICS & COMMANDS in the new default Help class​
Previously, topics and child commands were listed in help output under a single list heading called "COMMANDS". But we found this can be slightly confusing. Some topics are commands also (a.k.a. topic-commands) while others are simply organizational namespacing (and when ran just show their help).
The new default Help class splits the list of children into distinct lists of "TOPICS" and "COMMANDS", with the possibility of an item appearing in both if it a topic-command. This makes it clearer what is expected to be ran - "COMMANDS" - and what is providing structure - "TOPICS" - when looking at the help output.
VERSION  plugin-help-example/0.0.0 darwin-x64 node-v12.12.0USAGE  $ plugin-help-example [COMMAND]TOPICS  topic  this is a topic and has child topics or commandsCOMMANDS  hello  describe the command here  help   display help for plugin-help-example
We look forward to seeing what custom help features you implement in your oclif CLIs with this new feature!oclif TSLint to ESLint MigrationDecember 5, 2019 · 3 min readBack in February of this year, plans were announced to deprecate TSLint in favor of ESLint. TSLint's goal has become to work toward a “unified developer experience” by supporting ESLint development going forward.
What has changed in oclif​
To keep inline with the community, oclif has transitioned to ESLint for all our core libraries as well as all our official plugins.
Starting in v1.15.x, oclif will now optionally generate projects with ESLint for both TypeScript and JavaScript CLI’s.
ESLint does require Node to be on stable LTS version, at the time of writing, Node 8.10.x, Node 10.13.x & Node 12.x.x.
How does this affect you​
Existing CLI’s are unchanged, but any newly generated CLI's will only give the option of using ESLint. If you are running tslint in your CLI, we recommend you switch to ESLint as well.
In migrating our projects we took the following steps (for an example of these changes see this pull request).


Install eslint
$ yarn add eslint eslint-config-oclif eslint-config-oclif-typescript --dev


Add eslint related files


$ echo '{  "extends": [    "oclif",    "oclif-typescript"  ],  "rules": {  }}' > .eslintrc


Remove tslint and related packages
$ yarn remove @oclif/tslint tslint


Remove tslint related configuration files
$ rm tslint.json


Change lint script in our package.json from something like:
"lint": "tsc -p test --noEmit && tslint -p test -t stylish"
to
"lint": "eslint . --ext .ts --config .eslintrc"


To preserve the test compile (tsc -p test --noEmit) we also made the following updates to our scripts:
"pretest": "tsc -p test --noEmit"
In some cases we had our posttest duplicating the same steps as our lint script so it’s cleaner to have it reference the lint job directly with:
"posttest": "yarn lint"

Run yarn lint --fix. This attempts to auto-fix any linting violations automatically. In the case an auto-fix isn’t available it should be fixed manually or ignored (see the eslint configuration doc for more information)
Do a search in the codebase for tslint and remove any unnecessary tslint disabling comments, like:

/* tslint:disable:object-literal-sort-keys */
If you are on a version of Node that is not supported by ESLint, you will also need to update your Node engine. ESLint supports Node 8, 10, and 12 so you should upgrade to the most recent Node version compatible with your CLI and also supported by ESLint (see ESLint's Installation and Usage instructions).
When will this take effect​
These changes have taken effect in oclif v1.15.1. When you generate a new CLI or plugin it will now contain configuration for ESLint instead of TSLint.oclif's Current Node SupportOctober 31, 2019 · 3 min readTo maintain a healthy project trajectory, oclif follows and supports Node Active LTS release, currently Node 10 & Node 12. This means ensuring that oclif continues to play nice with coming Active LTS Node versions and other packages in the ecosystem. Moving forward also means leaving older versions behind. Starting in 2020, Node will stop maintaining Node 8 and it is our intent at that time to also follow suit. Let’s take a look at a few ways we will be supporting these changes.
CI Environments​
CLIs created with the oclif cli going forward will be generated with a CircleCI configuration with Node 10 & 12 and an Appveyor configuration using Node 10. We have also added Node latest to CircleCi to be an early warning detection against coming Node changes (Node latest is managed by CircleCI).
We have already updated every oclif repo's CI configs to reflect this.
If your existing CLI uses either Appveyor or CircleCI you can update your config files also, like so:
.circleci/config.yml​
Your CircleCI config should contain a node-latest job, aliased as test. From this, there should be two extensions of this job for the Active LTS Node versions, Node 10 and Node 12.
  node-10:    <<: *node-latest    docker:      - image: node:10  node-12:    <<: *node-latest    docker:      - image: node:12
Notice that these declarations only change the Docker Node images used to run that job.
Additionally, the jobs listed within workflows must also be updated to reflect our changes in configuration:
    jobs:      - node-latest      - node-10      - node-12
appveyor.yml​
For appveyor we are currently only testing the oldest Active LTS Node version, Node 10. Update the nodejs_version proppert in your appveyor.yml file to reflect this.
environment:  nodejs_version: "10"
Deprecating Node 8 & Updating packge.json engines​
In Jan 2020, Node will end its Node 8 maintenance. We will follow suit by setting the package.json engine property in oclif packages to >=10 and bumping the package's major versions.
Depending on how you ship your CLI you may wish to also bump the engines version in your CLI's package.json. You can read more about the implications of the engines property configuration in the npm documentation.
Also consider distributing your CLI with its own Node version.
Packaged Node Version​
When using dev-cli to pack your CLI it will use the Node version as specified in your package.json under the oclif.update.node.version property. This value should reflect an Active LTS Node version (dev-cli does not currently enforce versions).
Supporting the future​
As a community we may discover bumps along the way as we upgrade. If you notice something related to oclif please feel free to open an issue or submit a pull request under the relevant oclif package within the org.
We look forward to using the latest from Node and the community and keeping oclif healthy along the way.oclifconf 2019: A RecapSeptember 16, 2019 · 4 min readIn May, Heroku and Salesforce Open Source organized oclifconf, a conference for developers & product managers building CLI tools on top of the open source oclif framework. The speakers came from various tech companies, such as Adobe, Netlify, and Apollo, who have already built amazing CLI experiences. The topics covered everything from the incredible capabilities oclif has unlocked, to the community-built plugins extending its functionality, and even what the behavior of an adaptive CLI tool might look like.
Below is a listing of all of the talks from the event, along with a short summary. Enjoy!
The future of oclif by Jeff Dickey​

In its relatively short lifetime, oclif has already inspired many developers and companies to adopt its framework as a means for implementing their own command-line tooling. In this talk, Jeff Dickey, an oclif founding team member, recaps the project's history and inspiration. He also looks towards the future and outlines some features and improvements that the tool could adapt. This isn't so much a definitive roadmap of where oclif is headed, but rather, a call to inspiration for developers eager to contribute! And if you are interested in contributing, check out the open issues in the oclif GitHub repo and come say "Hello!" on Spectrum Chat.
Open Source Citizenship by Josh Simmons​

When it comes to open source, it's more than just individuals now. More and more frequently, large corporations are contributing to projects by donating to contributors, sponsoring events, or upstreaming contributions. But keeping open source projects and communities healthy requires more than just money and brainpower. Josh Simmons surveyed multiple open source communities and relays his findings as to what help maintainers and contributors actually need in this talk.
Building an enterprise-grade CLI with oclif by Thomas Dvornik​

Security and performance are all about trust. While oclif is an extremely extensible framework for building CLI tooling, there are additional requirements to fulfill for enterprise businesses to adopt it that might not be necessary for individual developers. Thomas Dvornik outlines what he and his colleagues at Salesforce have implemented as plugins to oclif to satisfy these needs, including encrypted OAuth, plugin signing, lazy loading dependencies, synchronizing weekly releases and deprecations across dozens of repositories, and establishing cross-team coding and documentation standards.
How Adobe I/O built an extensible CLI with oclif by Jesse MacFadyen​

Perhaps oclif's most appealing feature is its support for plugins. In Cordova's case, they've created a sophisticated telemetry system that helps Adobe developers see which commands users are using--and reports on which ones are erroring out. By embedding a feedback system into the tool, users are even able to quickly send their suggestions to a form, without ever leaving the terminal. Jesse MacFadyen demonstrates how oclif's plugin system can work beyond simply executing commands.
Integrating oclif with GraphQL and Apollo by Evans Hauser​

For Evans Hauser and the team at Apollo, oclif is best thought of as "React for the CLI." As a client paired with a strongly-typed API contract to a server, it can deliver structured and consistent commands to retrieve external data. What better mechanism to use for this transfer than GraphQL, a framework which empowers the client to ask precisely for the data it needs, and nothing more?
Adaptive Intent-based CLI State Machines by Shawn Wang​

In designing oclif, Jeff Dickey wrote out 12 CLI factors to keep in mind. In this talk, Shawn Wang outlines a 13th: state. State is hard, because it depends on context, and context depends on understanding what a user intends to do, not what they are asking. Shawn is working towards enabling oclif to better understand the commands a user has entered, so that it can predict and interpret future commands that might be entered next. This would enable CLI tools to not just interpret a users' commands, but to also interpret their intent.Older Entries\n\n\n\nIntroducing `oclif init` commandApril 10, 2024 · 2 min readThanks to the contribution of @joshcanhelp we released a new command for the oclif CLI called oclif init in version 4.8.0
The oclif init command allows you to initialize oclif in an existing project directory by adding the bare minimum requirements: a few pieces of configuration, bin scripts, and a couple of dependencies (@oclif/core and ts-node). This is slightly different from oclif generate, which will create an entirely new oclif project based on our templates.
oclif init will add the following:

bin scripts: bin/run.js, bin/run.cmd, bin/dev.js, and bin/dev.cmd
oclif section to package.json with bin, dirname, commands, and topicSeparator set (See Configuring Your CLI for more)
@oclif/core to dependencies in your package.json (if it's not already there)
ts-node to devDependencies in your package.json (if it's not already there)

Once you've initialized oclif, you can use the bin scripts to execute your CLI. You can also use the other oclif commands like oclif generate command and oclif generate hook to start adding new functionality.

❯ oclif init --helpInitialize a new oclif CLIUSAGE  $ oclif init [--bin <value>] [--module-type ESM|CommonJS] [--package-manager npm|yarn|pnpm] [--topic-separator    colons|spaces] [-d <value>] [-y]FLAGS  -d, --output-dir=<value>        Directory to initialize the CLI in.  -y, --yes                       Use defaults for all prompts. Individual flags will override defaults.      --bin=<value>               Supply answer for prompt: Command bin name the CLI will export      --module-type=<option>      Supply answer for prompt: Select a module type                                  <options: ESM|CommonJS>      --package-manager=<option>  Supply answer for prompt: Select a package manager                                  <options: npm|yarn|pnpm>      --topic-separator=<option>  Supply answer for prompt: Select a topic separator                                  <options: colons|spaces>DESCRIPTION  Initialize a new oclif CLI  This will add the necessary oclif bin files, add oclif config to package.json, and install @oclif/core and ts-node.EXAMPLES  Initialize a new CLI in the current directory    $ oclif init  Initialize a new CLI in a different directory    $ oclif init --output-dir "/path/to/existing/project"  Supply answers for specific prompts    $ oclif init --topic-separator colons --bin mycli
Hope you enjoy the new command! If you come across any issues or have any new ideas for this command, head over to the oclif/oclif repo and open a new issue.
All our best,
The oclif teamoclif Spring 2024 UpdateMarch 29, 2024 · 4 min readHello oclif developers! It's been a while since we last uploaded a blog - and a lot has happened.
We've been focusing on these high-level areas over the past couple of years:

Improving @oclif/core
ESM Support
Improving and revitalizing oclif.io
Re-engaging the oclif community

Improving @oclif/core​
Since we announced @oclif/core over three years ago, we've released two new major versions, each packed with lots of features that we're really excited about.
Here are some of these changes:

Full support for ESM and interoperability with CommonJS (more on this topic below).
Configurable command discovery strategies that give you more control over how commands are loaded at runtime. Check out the docs.
A new preparse hook that allows you to manipulate the provided arguments before they're parsed. Salesforce used this hook to implement a neat --flags-dir feature that translates local files into flags.
A new Performance class that you can use to track performance inside of @oclif/core and your own CLI or plugin. Check out the docs.
A new flag type, Flags.option, that lets you define a flag with a preset list of options. Typescript then uses the options to infer the flag's type.
Flags now have a relationship property that allows you to define more complex relationships between flags. Check out the flags docs for more information.
Flags now have a defaultHelp property that allows you to set the human readable default value in the command help. This property is useful when your flag's parse method returns a complex type, such as an object or a class. Check out the flags docs for more.
Commands now have a hiddenAliases property that allows you to define aliases that you want to hide from the user. The property is super helpful when you're trying to wean users off a deprecated command.
You can now use bun or tsx as dev runtimes (as opposed to node or ts-node).
A command's usage, args, and flags are now shown whenever a user forgets to provide a required arg or flag, or when they provided a non-existent flag.

If you need help migrating to the latest version, head over to core's README which has links to the migration guides. Feel free to open a new discussion if you need more hands-on help from us or the community.
ESM Support​
Version 3 of @oclif/core introduced full support for developing ESM plugins and CLIs. It also offered full support for interoperability between CommonJS and ESM plugins.
Put more simply, you can now migrate your CLI to ESM while keeping individual plugins in CommonJS (or vice versa). The upgrade path is now much simpler for you. You also don't need to worry about any community plugins that have migrated to ESM before you did (such as all the @oclif plugins) or are staunchly sticking with CommonJS for the foreseeable future.
Read more about this topic here.
Improving and Revitalizing oclif.io​
Another area of focus for us has been improving our documentation site, oclif.io.
While improving the quality and accuracy of the documentation was our priority, we also took the time to upgrade to the latest version of docusaurus. This new version gave our site a much-needed facelift, as well as cool new features such as dark mode and announcements.
If you have any feedback or are running into issues, we want to hear about it. Just create an issue in the oclif.io repo.
Re-engaging the oclif Community​
Lastly, our biggest priority at the moment is to re-engage the oclif community. We understand how frustrating it has been over the years to see your issues and pull requests go unacknowledged. We apologize for not prioritizing the community, and are earnestly trying to make sure that every issue and pull request gets the attention it deserves going forward.
We also opened up GitHub discussions for @oclif/core and the oclif CLI, where you can now post your questions or ideas. We hope you take advantage of them, we love hearing from you!
One last thing: we intend to publicly post our roadmap so you have more visibility into what we're working on. Stay tuned!
All our best,
The oclif teamAnnouncing oclif v2!January 12, 2022 · 5 min readHello and happy new year! It's our great pleasure to announce that we have released oclif v2, which uses the new @oclif/core library! 🎉
oclif v2 includes many changes that improve the experience of both creating and using an oclif CLI.
Going forward, we don't plan to make any updates to oclif v1 and its corresponding libraries, except for critical security fixes. See the compatibility matrix for a list of these libraries. In order to give developers time to migrate from v1 to v2, we're not completely dropping support yet. But at some point in the future we'll archive the v1 repositories and deprecate their versions on npm.
What’s changing?​
Repository Changes​
All repositories under the oclif org now use main as their primary branch and oclif-v1 as the legacy branch. The main  branch corresponds to oclif v2 and the oclif-v1 branch to oclif v1. If you find any repos that don’t have a main branch, you can safely assume that they're not used in oclif v2 and will be deprecated in the future.
Consolidating Tools & Libraries​
The oclif-dev CLI has now been incorporated into oclif. You now no longer need to install a separate package to manage your entire CLI’s lifecycle.
The following libraries have been consolidated under @oclif/core and will be deprecated at some point in the future. Read the migration guide to learn how to update your CLI or plugin to use the new core library.

@oclif/command
@oclif/config
@oclif/error
@oclif/help
@oclif/parser

No more single vs multi command CLIs​
There's only one "type" of oclif v2 CLI, but it can have as few or as many commands as a developer wants. As a result, there’s only one command to generate CLIs, oclif generate, as opposed to the old oclif single and oclif multi commands.
Node > 12​
To ensure oclif CLIs are as secure as possible, all v2 libraries and plugins support only Node 12 or higher as of now. Going forward, they'll support only Node Maintenance or higher, as defined by Node's release schedule here: https://nodejs.org/en/about/releases/.
What’s new?​
New example CLI​
oclif-hello-world is our new example repo. This is also the repo that's used as a template when running oclif generate to create a new CLI. This repo will always be able to be referenced as an example of what an oclif v2 CLI should look like.
Spaced commands​
oclif CLIs can now use spaces, instead of colons, to separate topics and subcommands. To enable this feature, simply add “topicSeparator": " " to the oclif config in your package.json. See an example in our example repo.
// Old commands that use :$ mycli do:something
// New spaced commands$ mycli do something

Note: Spaced commands are backwards compatible. So if you enable spaced commands for your CLI, users will still be able to use : as a separator. This ensures that any existing scripts don't break.

New Help Output​
We’ve revamped the way command help is outputted to the terminal, making it both easier to implement and easier to read. See the difference between the old help output on the left and the new help output on the right in the screenshots below.
oclif v1oclif v2
Notice that there are new sections for flags and global flags, examples are displayed with better spacing, and there is a section at the bottom called Configuration Variables. This Configuration Variables section is not part of the new help by default. But we've added support for custom help sections, which is what the sf CLI uses to create the new section.
Async Command Parsing​
We’ve also improved the performance of new CLIs by rewriting how commands are parsed on initialization. The new parser is asynchronous, which makes CLIs with a lot of commands or installed  plugins much faster.
What’s coming next?​
Part of our charter for the release of oclif v2 includes improving our engagement with the oclif community. We know that over the past couple of years we’ve reduced our involvement, and a lot of issues and PRs have languished in limbo. Hopefully you’ve already seen increased activity and responses from oclif maintainers recently, but if you haven’t, please don’t hesitate to ping us by tagging @admins in oclif repos.
We also want to start interviewing members of the oclif community to acquire feedback and prioritize the features and fixes you deem most important!
Best,
The oclif team

Reference material​
Migration Guide​
This guide explains how to upgrade a CLI or plugin from the old oclif v1 libraries to the new @oclif/core library that oclif v2 uses.
https://github.com/oclif/core/blob/main/MIGRATION.md
Compatibility Matrix​
The following matrix shows how the v1 libraries and plugins relate to the new v2 ones. Use this matrix as a guide to know what to drop and which versions to switch when upgrading your plugins and CLIs to v2.
oclif "v1"oclif "v2"Utility CLIsoclif@<2@oclif/dev-cli@<2oclif@>=2Main packages@oclif/command@oclif/config@oclif/errors@oclif/parser@oclif/plugin-help@oclif/core@>=1Node LTSNode v8-14Node v12+ (at time of writing)TypeScripttypescript@<4typescript@>=4Main plugins@oclif/plugin-autocomplete@<1@oclif/plugin-commands@<2@oclif/plugin-help@<4@oclif/plugin-not-found@<2@oclif/plugin-plugins@<2@oclif/plugin-update@<2plugin-warn-if-update-available@<2plugin-which@<2@oclif/plugin-autocomplete@>=1@oclif/plugin-commands@>=2@oclif/plugin-help@>=4@oclif/plugin-not-found@>=2@oclif/plugin-plugins@>=2@oclif/plugin-update@>=2@oclif/plugin-warn-if-update-available@>=2@oclif/plugin-which@>=2Introducing @oclif/coreMarch 1, 2021 · 3 min readGreetings!
We hope this blog post finds you well.
Introducing...​
We are excited to announce the next iteration of the oclif project today: @oclif/core.
We have learned a lot in the last three years of developing oclif, developing on oclif and supporting millions of command runs a day via Heroku and Salesforce CLIs.
@oclif/core ("Core") simplifies the oclif development experience and introduces highly requested new features.
Core combines the essential oclif packages into one "core" package, aptly named @oclif/core.
Core also introduces:

A default command option
Colon or space command syntax
Async command parsing
Command piping to arguments

With the introduction of default command functionality, Core simplifies the oclif project and removes the notion of single or multi command CLIs. Core CLIs can have 1 or many commands.
Along with Core, we moved the oclif-dev CLI into the oclif CLI creating a single "utility" CLI. This CLI also introduces a new AWS S3 compatible publishing scheme.
What to expect in the near future​
Core is in pre-release beta and being actively developed for new internal Salesforce CLIs.
Much documentation needs to be written in the coming months including migration paths. Migration onto Core should be as painless as possible with many exports remaining entirely unchanged. Look for forthcoming blog posts and documentation on oclif.io.
Early this summer, tentively June 1, we will release Core v1. Core's release will coincide with major bumps to many other oclif plugin packages. See the compatibility matrix below.
At Core's v1 release, the current "main" oclif packages (namely: command, config, errors & parser) will go into maintenance mode until Jan 2022. They will receive only bug and security fixes and they remain compatible with current versions of the oclif and oclif-dev CLIs. Afterwhich, they will be archived.
Companioning Core, the next major release of the oclif CLI (literally oclif@2) will generate Core CLIs.
Going forward​
We are excited to release Core! We invite you to poke around the Core repo. It may appear to be a big change but Core keeps what you already enjoy about oclif while reducing development complexity, project dependencies, package coupling and bundle size and introduces many requested features previously too prickly to weave into the current oclif architecture.
Best,
The oclif team
Reference: Compatibility matrix​
oclif "v1"oclif "Core"Utility CLIsoclif@<2@oclif/dev-cli@<2oclif@>=2Main packages@oclif/core@<2@oclif/config@<2@oclif/errors@<2@oclif/parser@<4@oclif/plugin-help@<4@oclif/core@>=1Node LTSNode v8-14Node v12+TypeScripttypescript@<4typescript@>=4Main plugins@oclif/plugin-autocomplete@<1@oclif/plugin-commands@<2@oclif/plugin-help@<4@oclif/plugin-not-found@<2@oclif/plugin-plugins@<2@oclif/plugin-update@<2plugin-warn-if-update-available@<2plugin-which@<2@oclif/plugin-autocomplete@>=2@oclif/plugin-commands@>=2@oclif/plugin-help@>=4@oclif/plugin-not-found@>=2@oclif/plugin-plugins@>=2@oclif/plugin-update@>=2@oclif/plugin-warn-if-update-available@>=2@oclif/plugin-which@>=2oclif Summer 2020 UpdateAugust 26, 2020 · 2 min readHello oclif developers! We hope you are all doing well.
Earlier this year, we started our planning for oclifconf v2 and, like all conference, had to change course. We opted not to hold a virtual conference, however, we wanted to take some time to highlight a few oclif features shipped this year.
Feature: Help templating​
One of the most requested features, help templating enables oclif developers to customize the help output for their CLI.
Read the announcement.
Feature: Custom error delegation​
This feature both improved how oclif throws and handles errors and allows oclif developers to overwrite or interject in oclif’s error handling.
Read the announcement.
Feature: postrun hooks​
We have added a new lifecycle event postrun. Your CLI can now run a hook after a command has ran.
See our hook documentation.
Feature: Root index command​
Previously, oclif would display CLI help if only the binary name with no command ID was invoked, oclif now supports a "root index" command. If present, a command defined at src/commands/index.ts will be run if no command ID is found.
1 million weekly downloads​
While exact oclif usage metrics are hard to pin down, we use npm download statistics of oclif packages as a rough approximation. Earlier this year, oclif's command package hit 1 million weekly downloads for the first time!
This year has been presented its challenges on everyone. We want to thank you, oclif developers, whom have taken the time to use and improve the oclif project. We look forward to seeing you all - in person - in the future!
All our best,
The oclif teamPretty Printable ErrorsJuly 1, 2020 · One min readOften CLIs are used as handy tools and when things go wrong it’s useful to have additional context. In oclif we have added a couple of additional properties that can show extra context to the users when an error is displayed. The code, ref and suggestions will now be displayed if they are included. This will work with an existing oclif CLI by adding the latest @oclif/errors and @oclif/core to the CLI's package.json dependencies.
For example, using this.error with the additional properties:
class TestError extends Command {  async run() {    this.error("An error has occurred!", {      code: "OCLIF_ERR",      ref: "https://oclif.io/docs/commands#thiserrormessage-string--error-options-code-string-exit-number",      suggestions: ["Use these extra properties to provide additional context"],    })  }}
would result with the following output:
›   Error: An error has occurred!›   Code: OCLIF_ERR›   Try this: Use these extra properties to provide additional context›   Reference: https://oclif.io/docs/commands#thiserrormessage-string--error-options-code-string-exit-number
If these properties are not provided then nothing changes and the CLI will continue to display the single error message output as it did before. Additionally, as part of this exercise we’ve added documentation around Error Handling in oclif which should come in handy if the need arises to extend oclif’s default handling of errors.Customizing Help in oclifMay 5, 2020 · 2 min readOut of the box oclif provides a great help experience for CLIs.
But what if, as an oclif developer, you want to customize some or all of the output?
You can now customize your CLI's help output by implementing the HelpBase abstract class.
Getting started with custom help​
If you have not done so yet, update @oclif/core.
$ yarn add --latest @oclif/core
To get started, first define the filepath to your help class in oclif's config in package.json. This is a relative path to the help class, without a file extension.
For this example, the help class will be created in a file at "[project root]/src/help.ts".
{  // ...  "oclif": {    "helpClass": "./lib/help"    // ...  }  // ...}
From here there are two paths, implement the HelpBase abstract class yourself or overwrite the parts of the default Help class you want to customize (ex: how command usage is displayed). We recommend the latter approach but cover both in the new Help Classes docs.
Separating TOPICS & COMMANDS in the new default Help class​
Previously, topics and child commands were listed in help output under a single list heading called "COMMANDS". But we found this can be slightly confusing. Some topics are commands also (a.k.a. topic-commands) while others are simply organizational namespacing (and when ran just show their help).
The new default Help class splits the list of children into distinct lists of "TOPICS" and "COMMANDS", with the possibility of an item appearing in both if it a topic-command. This makes it clearer what is expected to be ran - "COMMANDS" - and what is providing structure - "TOPICS" - when looking at the help output.
VERSION  plugin-help-example/0.0.0 darwin-x64 node-v12.12.0USAGE  $ plugin-help-example [COMMAND]TOPICS  topic  this is a topic and has child topics or commandsCOMMANDS  hello  describe the command here  help   display help for plugin-help-example
We look forward to seeing what custom help features you implement in your oclif CLIs with this new feature!oclif TSLint to ESLint MigrationDecember 5, 2019 · 3 min readBack in February of this year, plans were announced to deprecate TSLint in favor of ESLint. TSLint's goal has become to work toward a “unified developer experience” by supporting ESLint development going forward.
What has changed in oclif​
To keep inline with the community, oclif has transitioned to ESLint for all our core libraries as well as all our official plugins.
Starting in v1.15.x, oclif will now optionally generate projects with ESLint for both TypeScript and JavaScript CLI’s.
ESLint does require Node to be on stable LTS version, at the time of writing, Node 8.10.x, Node 10.13.x & Node 12.x.x.
How does this affect you​
Existing CLI’s are unchanged, but any newly generated CLI's will only give the option of using ESLint. If you are running tslint in your CLI, we recommend you switch to ESLint as well.
In migrating our projects we took the following steps (for an example of these changes see this pull request).


Install eslint
$ yarn add eslint eslint-config-oclif eslint-config-oclif-typescript --dev


Add eslint related files


$ echo '{  "extends": [    "oclif",    "oclif-typescript"  ],  "rules": {  }}' > .eslintrc


Remove tslint and related packages
$ yarn remove @oclif/tslint tslint


Remove tslint related configuration files
$ rm tslint.json


Change lint script in our package.json from something like:
"lint": "tsc -p test --noEmit && tslint -p test -t stylish"
to
"lint": "eslint . --ext .ts --config .eslintrc"


To preserve the test compile (tsc -p test --noEmit) we also made the following updates to our scripts:
"pretest": "tsc -p test --noEmit"
In some cases we had our posttest duplicating the same steps as our lint script so it’s cleaner to have it reference the lint job directly with:
"posttest": "yarn lint"

Run yarn lint --fix. This attempts to auto-fix any linting violations automatically. In the case an auto-fix isn’t available it should be fixed manually or ignored (see the eslint configuration doc for more information)
Do a search in the codebase for tslint and remove any unnecessary tslint disabling comments, like:

/* tslint:disable:object-literal-sort-keys */
If you are on a version of Node that is not supported by ESLint, you will also need to update your Node engine. ESLint supports Node 8, 10, and 12 so you should upgrade to the most recent Node version compatible with your CLI and also supported by ESLint (see ESLint's Installation and Usage instructions).
When will this take effect​
These changes have taken effect in oclif v1.15.1. When you generate a new CLI or plugin it will now contain configuration for ESLint instead of TSLint.oclif's Current Node SupportOctober 31, 2019 · 3 min readTo maintain a healthy project trajectory, oclif follows and supports Node Active LTS release, currently Node 10 & Node 12. This means ensuring that oclif continues to play nice with coming Active LTS Node versions and other packages in the ecosystem. Moving forward also means leaving older versions behind. Starting in 2020, Node will stop maintaining Node 8 and it is our intent at that time to also follow suit. Let’s take a look at a few ways we will be supporting these changes.
CI Environments​
CLIs created with the oclif cli going forward will be generated with a CircleCI configuration with Node 10 & 12 and an Appveyor configuration using Node 10. We have also added Node latest to CircleCi to be an early warning detection against coming Node changes (Node latest is managed by CircleCI).
We have already updated every oclif repo's CI configs to reflect this.
If your existing CLI uses either Appveyor or CircleCI you can update your config files also, like so:
.circleci/config.yml​
Your CircleCI config should contain a node-latest job, aliased as test. From this, there should be two extensions of this job for the Active LTS Node versions, Node 10 and Node 12.
  node-10:    <<: *node-latest    docker:      - image: node:10  node-12:    <<: *node-latest    docker:      - image: node:12
Notice that these declarations only change the Docker Node images used to run that job.
Additionally, the jobs listed within workflows must also be updated to reflect our changes in configuration:
    jobs:      - node-latest      - node-10      - node-12
appveyor.yml​
For appveyor we are currently only testing the oldest Active LTS Node version, Node 10. Update the nodejs_version proppert in your appveyor.yml file to reflect this.
environment:  nodejs_version: "10"
Deprecating Node 8 & Updating packge.json engines​
In Jan 2020, Node will end its Node 8 maintenance. We will follow suit by setting the package.json engine property in oclif packages to >=10 and bumping the package's major versions.
Depending on how you ship your CLI you may wish to also bump the engines version in your CLI's package.json. You can read more about the implications of the engines property configuration in the npm documentation.
Also consider distributing your CLI with its own Node version.
Packaged Node Version​
When using dev-cli to pack your CLI it will use the Node version as specified in your package.json under the oclif.update.node.version property. This value should reflect an Active LTS Node version (dev-cli does not currently enforce versions).
Supporting the future​
As a community we may discover bumps along the way as we upgrade. If you notice something related to oclif please feel free to open an issue or submit a pull request under the relevant oclif package within the org.
We look forward to using the latest from Node and the community and keeping oclif healthy along the way.oclifconf 2019: A RecapSeptember 16, 2019 · 4 min readIn May, Heroku and Salesforce Open Source organized oclifconf, a conference for developers & product managers building CLI tools on top of the open source oclif framework. The speakers came from various tech companies, such as Adobe, Netlify, and Apollo, who have already built amazing CLI experiences. The topics covered everything from the incredible capabilities oclif has unlocked, to the community-built plugins extending its functionality, and even what the behavior of an adaptive CLI tool might look like.
Below is a listing of all of the talks from the event, along with a short summary. Enjoy!
The future of oclif by Jeff Dickey​

In its relatively short lifetime, oclif has already inspired many developers and companies to adopt its framework as a means for implementing their own command-line tooling. In this talk, Jeff Dickey, an oclif founding team member, recaps the project's history and inspiration. He also looks towards the future and outlines some features and improvements that the tool could adapt. This isn't so much a definitive roadmap of where oclif is headed, but rather, a call to inspiration for developers eager to contribute! And if you are interested in contributing, check out the open issues in the oclif GitHub repo and come say "Hello!" on Spectrum Chat.
Open Source Citizenship by Josh Simmons​

When it comes to open source, it's more than just individuals now. More and more frequently, large corporations are contributing to projects by donating to contributors, sponsoring events, or upstreaming contributions. But keeping open source projects and communities healthy requires more than just money and brainpower. Josh Simmons surveyed multiple open source communities and relays his findings as to what help maintainers and contributors actually need in this talk.
Building an enterprise-grade CLI with oclif by Thomas Dvornik​

Security and performance are all about trust. While oclif is an extremely extensible framework for building CLI tooling, there are additional requirements to fulfill for enterprise businesses to adopt it that might not be necessary for individual developers. Thomas Dvornik outlines what he and his colleagues at Salesforce have implemented as plugins to oclif to satisfy these needs, including encrypted OAuth, plugin signing, lazy loading dependencies, synchronizing weekly releases and deprecations across dozens of repositories, and establishing cross-team coding and documentation standards.
How Adobe I/O built an extensible CLI with oclif by Jesse MacFadyen​

Perhaps oclif's most appealing feature is its support for plugins. In Cordova's case, they've created a sophisticated telemetry system that helps Adobe developers see which commands users are using--and reports on which ones are erroring out. By embedding a feedback system into the tool, users are even able to quickly send their suggestions to a form, without ever leaving the terminal. Jesse MacFadyen demonstrates how oclif's plugin system can work beyond simply executing commands.
Integrating oclif with GraphQL and Apollo by Evans Hauser​

For Evans Hauser and the team at Apollo, oclif is best thought of as "React for the CLI." As a client paired with a strongly-typed API contract to a server, it can deliver structured and consistent commands to retrieve external data. What better mechanism to use for this transfer than GraphQL, a framework which empowers the client to ask precisely for the data it needs, and nothing more?
Adaptive Intent-based CLI State Machines by Shawn Wang​

In designing oclif, Jeff Dickey wrote out 12 CLI factors to keep in mind. In this talk, Shawn Wang outlines a 13th: state. State is hard, because it depends on context, and context depends on understanding what a user intends to do, not what they are asking. Shawn is working towards enabling oclif to better understand the commands a user has entered, so that it can predict and interpret future commands that might be entered next. This would enable CLI tools to not just interpret a users' commands, but to also interpret their intent.\n\nIntroducing `oclif init` commandApril 10, 2024 · 2 min readThanks to the contribution of @joshcanhelp we released a new command for the oclif CLI called oclif init in version 4.8.0
The oclif init command allows you to initialize oclif in an existing project directory by adding the bare minimum requirements: a few pieces of configuration, bin scripts, and a couple of dependencies (@oclif/core and ts-node). This is slightly different from oclif generate, which will create an entirely new oclif project based on our templates.
oclif init will add the following:

bin scripts: bin/run.js, bin/run.cmd, bin/dev.js, and bin/dev.cmd
oclif section to package.json with bin, dirname, commands, and topicSeparator set (See Configuring Your CLI for more)
@oclif/core to dependencies in your package.json (if it's not already there)
ts-node to devDependencies in your package.json (if it's not already there)

Once you've initialized oclif, you can use the bin scripts to execute your CLI. You can also use the other oclif commands like oclif generate command and oclif generate hook to start adding new functionality.

❯ oclif init --helpInitialize a new oclif CLIUSAGE  $ oclif init [--bin <value>] [--module-type ESM|CommonJS] [--package-manager npm|yarn|pnpm] [--topic-separator    colons|spaces] [-d <value>] [-y]FLAGS  -d, --output-dir=<value>        Directory to initialize the CLI in.  -y, --yes                       Use defaults for all prompts. Individual flags will override defaults.      --bin=<value>               Supply answer for prompt: Command bin name the CLI will export      --module-type=<option>      Supply answer for prompt: Select a module type                                  <options: ESM|CommonJS>      --package-manager=<option>  Supply answer for prompt: Select a package manager                                  <options: npm|yarn|pnpm>      --topic-separator=<option>  Supply answer for prompt: Select a topic separator                                  <options: colons|spaces>DESCRIPTION  Initialize a new oclif CLI  This will add the necessary oclif bin files, add oclif config to package.json, and install @oclif/core and ts-node.EXAMPLES  Initialize a new CLI in the current directory    $ oclif init  Initialize a new CLI in a different directory    $ oclif init --output-dir "/path/to/existing/project"  Supply answers for specific prompts    $ oclif init --topic-separator colons --bin mycli
Hope you enjoy the new command! If you come across any issues or have any new ideas for this command, head over to the oclif/oclif repo and open a new issue.
All our best,
The oclif teamoclif Spring 2024 UpdateMarch 29, 2024 · 4 min readHello oclif developers! It's been a while since we last uploaded a blog - and a lot has happened.
We've been focusing on these high-level areas over the past couple of years:

Improving @oclif/core
ESM Support
Improving and revitalizing oclif.io
Re-engaging the oclif community

Improving @oclif/core​
Since we announced @oclif/core over three years ago, we've released two new major versions, each packed with lots of features that we're really excited about.
Here are some of these changes:

Full support for ESM and interoperability with CommonJS (more on this topic below).
Configurable command discovery strategies that give you more control over how commands are loaded at runtime. Check out the docs.
A new preparse hook that allows you to manipulate the provided arguments before they're parsed. Salesforce used this hook to implement a neat --flags-dir feature that translates local files into flags.
A new Performance class that you can use to track performance inside of @oclif/core and your own CLI or plugin. Check out the docs.
A new flag type, Flags.option, that lets you define a flag with a preset list of options. Typescript then uses the options to infer the flag's type.
Flags now have a relationship property that allows you to define more complex relationships between flags. Check out the flags docs for more information.
Flags now have a defaultHelp property that allows you to set the human readable default value in the command help. This property is useful when your flag's parse method returns a complex type, such as an object or a class. Check out the flags docs for more.
Commands now have a hiddenAliases property that allows you to define aliases that you want to hide from the user. The property is super helpful when you're trying to wean users off a deprecated command.
You can now use bun or tsx as dev runtimes (as opposed to node or ts-node).
A command's usage, args, and flags are now shown whenever a user forgets to provide a required arg or flag, or when they provided a non-existent flag.

If you need help migrating to the latest version, head over to core's README which has links to the migration guides. Feel free to open a new discussion if you need more hands-on help from us or the community.
ESM Support​
Version 3 of @oclif/core introduced full support for developing ESM plugins and CLIs. It also offered full support for interoperability between CommonJS and ESM plugins.
Put more simply, you can now migrate your CLI to ESM while keeping individual plugins in CommonJS (or vice versa). The upgrade path is now much simpler for you. You also don't need to worry about any community plugins that have migrated to ESM before you did (such as all the @oclif plugins) or are staunchly sticking with CommonJS for the foreseeable future.
Read more about this topic here.
Improving and Revitalizing oclif.io​
Another area of focus for us has been improving our documentation site, oclif.io.
While improving the quality and accuracy of the documentation was our priority, we also took the time to upgrade to the latest version of docusaurus. This new version gave our site a much-needed facelift, as well as cool new features such as dark mode and announcements.
If you have any feedback or are running into issues, we want to hear about it. Just create an issue in the oclif.io repo.
Re-engaging the oclif Community​
Lastly, our biggest priority at the moment is to re-engage the oclif community. We understand how frustrating it has been over the years to see your issues and pull requests go unacknowledged. We apologize for not prioritizing the community, and are earnestly trying to make sure that every issue and pull request gets the attention it deserves going forward.
We also opened up GitHub discussions for @oclif/core and the oclif CLI, where you can now post your questions or ideas. We hope you take advantage of them, we love hearing from you!
One last thing: we intend to publicly post our roadmap so you have more visibility into what we're working on. Stay tuned!
All our best,
The oclif teamAnnouncing oclif v2!January 12, 2022 · 5 min readHello and happy new year! It's our great pleasure to announce that we have released oclif v2, which uses the new @oclif/core library! 🎉
oclif v2 includes many changes that improve the experience of both creating and using an oclif CLI.
Going forward, we don't plan to make any updates to oclif v1 and its corresponding libraries, except for critical security fixes. See the compatibility matrix for a list of these libraries. In order to give developers time to migrate from v1 to v2, we're not completely dropping support yet. But at some point in the future we'll archive the v1 repositories and deprecate their versions on npm.
What’s changing?​
Repository Changes​
All repositories under the oclif org now use main as their primary branch and oclif-v1 as the legacy branch. The main  branch corresponds to oclif v2 and the oclif-v1 branch to oclif v1. If you find any repos that don’t have a main branch, you can safely assume that they're not used in oclif v2 and will be deprecated in the future.
Consolidating Tools & Libraries​
The oclif-dev CLI has now been incorporated into oclif. You now no longer need to install a separate package to manage your entire CLI’s lifecycle.
The following libraries have been consolidated under @oclif/core and will be deprecated at some point in the future. Read the migration guide to learn how to update your CLI or plugin to use the new core library.

@oclif/command
@oclif/config
@oclif/error
@oclif/help
@oclif/parser

No more single vs multi command CLIs​
There's only one "type" of oclif v2 CLI, but it can have as few or as many commands as a developer wants. As a result, there’s only one command to generate CLIs, oclif generate, as opposed to the old oclif single and oclif multi commands.
Node > 12​
To ensure oclif CLIs are as secure as possible, all v2 libraries and plugins support only Node 12 or higher as of now. Going forward, they'll support only Node Maintenance or higher, as defined by Node's release schedule here: https://nodejs.org/en/about/releases/.
What’s new?​
New example CLI​
oclif-hello-world is our new example repo. This is also the repo that's used as a template when running oclif generate to create a new CLI. This repo will always be able to be referenced as an example of what an oclif v2 CLI should look like.
Spaced commands​
oclif CLIs can now use spaces, instead of colons, to separate topics and subcommands. To enable this feature, simply add “topicSeparator": " " to the oclif config in your package.json. See an example in our example repo.
// Old commands that use :$ mycli do:something
// New spaced commands$ mycli do something

Note: Spaced commands are backwards compatible. So if you enable spaced commands for your CLI, users will still be able to use : as a separator. This ensures that any existing scripts don't break.

New Help Output​
We’ve revamped the way command help is outputted to the terminal, making it both easier to implement and easier to read. See the difference between the old help output on the left and the new help output on the right in the screenshots below.
oclif v1oclif v2
Notice that there are new sections for flags and global flags, examples are displayed with better spacing, and there is a section at the bottom called Configuration Variables. This Configuration Variables section is not part of the new help by default. But we've added support for custom help sections, which is what the sf CLI uses to create the new section.
Async Command Parsing​
We’ve also improved the performance of new CLIs by rewriting how commands are parsed on initialization. The new parser is asynchronous, which makes CLIs with a lot of commands or installed  plugins much faster.
What’s coming next?​
Part of our charter for the release of oclif v2 includes improving our engagement with the oclif community. We know that over the past couple of years we’ve reduced our involvement, and a lot of issues and PRs have languished in limbo. Hopefully you’ve already seen increased activity and responses from oclif maintainers recently, but if you haven’t, please don’t hesitate to ping us by tagging @admins in oclif repos.
We also want to start interviewing members of the oclif community to acquire feedback and prioritize the features and fixes you deem most important!
Best,
The oclif team

Reference material​
Migration Guide​
This guide explains how to upgrade a CLI or plugin from the old oclif v1 libraries to the new @oclif/core library that oclif v2 uses.
https://github.com/oclif/core/blob/main/MIGRATION.md
Compatibility Matrix​
The following matrix shows how the v1 libraries and plugins relate to the new v2 ones. Use this matrix as a guide to know what to drop and which versions to switch when upgrading your plugins and CLIs to v2.
oclif "v1"oclif "v2"Utility CLIsoclif@<2@oclif/dev-cli@<2oclif@>=2Main packages@oclif/command@oclif/config@oclif/errors@oclif/parser@oclif/plugin-help@oclif/core@>=1Node LTSNode v8-14Node v12+ (at time of writing)TypeScripttypescript@<4typescript@>=4Main plugins@oclif/plugin-autocomplete@<1@oclif/plugin-commands@<2@oclif/plugin-help@<4@oclif/plugin-not-found@<2@oclif/plugin-plugins@<2@oclif/plugin-update@<2plugin-warn-if-update-available@<2plugin-which@<2@oclif/plugin-autocomplete@>=1@oclif/plugin-commands@>=2@oclif/plugin-help@>=4@oclif/plugin-not-found@>=2@oclif/plugin-plugins@>=2@oclif/plugin-update@>=2@oclif/plugin-warn-if-update-available@>=2@oclif/plugin-which@>=2Introducing @oclif/coreMarch 1, 2021 · 3 min readGreetings!
We hope this blog post finds you well.
Introducing...​
We are excited to announce the next iteration of the oclif project today: @oclif/core.
We have learned a lot in the last three years of developing oclif, developing on oclif and supporting millions of command runs a day via Heroku and Salesforce CLIs.
@oclif/core ("Core") simplifies the oclif development experience and introduces highly requested new features.
Core combines the essential oclif packages into one "core" package, aptly named @oclif/core.
Core also introduces:

A default command option
Colon or space command syntax
Async command parsing
Command piping to arguments

With the introduction of default command functionality, Core simplifies the oclif project and removes the notion of single or multi command CLIs. Core CLIs can have 1 or many commands.
Along with Core, we moved the oclif-dev CLI into the oclif CLI creating a single "utility" CLI. This CLI also introduces a new AWS S3 compatible publishing scheme.
What to expect in the near future​
Core is in pre-release beta and being actively developed for new internal Salesforce CLIs.
Much documentation needs to be written in the coming months including migration paths. Migration onto Core should be as painless as possible with many exports remaining entirely unchanged. Look for forthcoming blog posts and documentation on oclif.io.
Early this summer, tentively June 1, we will release Core v1. Core's release will coincide with major bumps to many other oclif plugin packages. See the compatibility matrix below.
At Core's v1 release, the current "main" oclif packages (namely: command, config, errors & parser) will go into maintenance mode until Jan 2022. They will receive only bug and security fixes and they remain compatible with current versions of the oclif and oclif-dev CLIs. Afterwhich, they will be archived.
Companioning Core, the next major release of the oclif CLI (literally oclif@2) will generate Core CLIs.
Going forward​
We are excited to release Core! We invite you to poke around the Core repo. It may appear to be a big change but Core keeps what you already enjoy about oclif while reducing development complexity, project dependencies, package coupling and bundle size and introduces many requested features previously too prickly to weave into the current oclif architecture.
Best,
The oclif team
Reference: Compatibility matrix​
oclif "v1"oclif "Core"Utility CLIsoclif@<2@oclif/dev-cli@<2oclif@>=2Main packages@oclif/core@<2@oclif/config@<2@oclif/errors@<2@oclif/parser@<4@oclif/plugin-help@<4@oclif/core@>=1Node LTSNode v8-14Node v12+TypeScripttypescript@<4typescript@>=4Main plugins@oclif/plugin-autocomplete@<1@oclif/plugin-commands@<2@oclif/plugin-help@<4@oclif/plugin-not-found@<2@oclif/plugin-plugins@<2@oclif/plugin-update@<2plugin-warn-if-update-available@<2plugin-which@<2@oclif/plugin-autocomplete@>=2@oclif/plugin-commands@>=2@oclif/plugin-help@>=4@oclif/plugin-not-found@>=2@oclif/plugin-plugins@>=2@oclif/plugin-update@>=2@oclif/plugin-warn-if-update-available@>=2@oclif/plugin-which@>=2oclif Summer 2020 UpdateAugust 26, 2020 · 2 min readHello oclif developers! We hope you are all doing well.
Earlier this year, we started our planning for oclifconf v2 and, like all conference, had to change course. We opted not to hold a virtual conference, however, we wanted to take some time to highlight a few oclif features shipped this year.
Feature: Help templating​
One of the most requested features, help templating enables oclif developers to customize the help output for their CLI.
Read the announcement.
Feature: Custom error delegation​
This feature both improved how oclif throws and handles errors and allows oclif developers to overwrite or interject in oclif’s error handling.
Read the announcement.
Feature: postrun hooks​
We have added a new lifecycle event postrun. Your CLI can now run a hook after a command has ran.
See our hook documentation.
Feature: Root index command​
Previously, oclif would display CLI help if only the binary name with no command ID was invoked, oclif now supports a "root index" command. If present, a command defined at src/commands/index.ts will be run if no command ID is found.
1 million weekly downloads​
While exact oclif usage metrics are hard to pin down, we use npm download statistics of oclif packages as a rough approximation. Earlier this year, oclif's command package hit 1 million weekly downloads for the first time!
This year has been presented its challenges on everyone. We want to thank you, oclif developers, whom have taken the time to use and improve the oclif project. We look forward to seeing you all - in person - in the future!
All our best,
The oclif teamPretty Printable ErrorsJuly 1, 2020 · One min readOften CLIs are used as handy tools and when things go wrong it’s useful to have additional context. In oclif we have added a couple of additional properties that can show extra context to the users when an error is displayed. The code, ref and suggestions will now be displayed if they are included. This will work with an existing oclif CLI by adding the latest @oclif/errors and @oclif/core to the CLI's package.json dependencies.
For example, using this.error with the additional properties:
class TestError extends Command {  async run() {    this.error("An error has occurred!", {      code: "OCLIF_ERR",      ref: "https://oclif.io/docs/commands#thiserrormessage-string--error-options-code-string-exit-number",      suggestions: ["Use these extra properties to provide additional context"],    })  }}
would result with the following output:
›   Error: An error has occurred!›   Code: OCLIF_ERR›   Try this: Use these extra properties to provide additional context›   Reference: https://oclif.io/docs/commands#thiserrormessage-string--error-options-code-string-exit-number
If these properties are not provided then nothing changes and the CLI will continue to display the single error message output as it did before. Additionally, as part of this exercise we’ve added documentation around Error Handling in oclif which should come in handy if the need arises to extend oclif’s default handling of errors.Customizing Help in oclifMay 5, 2020 · 2 min readOut of the box oclif provides a great help experience for CLIs.
But what if, as an oclif developer, you want to customize some or all of the output?
You can now customize your CLI's help output by implementing the HelpBase abstract class.
Getting started with custom help​
If you have not done so yet, update @oclif/core.
$ yarn add --latest @oclif/core
To get started, first define the filepath to your help class in oclif's config in package.json. This is a relative path to the help class, without a file extension.
For this example, the help class will be created in a file at "[project root]/src/help.ts".
{  // ...  "oclif": {    "helpClass": "./lib/help"    // ...  }  // ...}
From here there are two paths, implement the HelpBase abstract class yourself or overwrite the parts of the default Help class you want to customize (ex: how command usage is displayed). We recommend the latter approach but cover both in the new Help Classes docs.
Separating TOPICS & COMMANDS in the new default Help class​
Previously, topics and child commands were listed in help output under a single list heading called "COMMANDS". But we found this can be slightly confusing. Some topics are commands also (a.k.a. topic-commands) while others are simply organizational namespacing (and when ran just show their help).
The new default Help class splits the list of children into distinct lists of "TOPICS" and "COMMANDS", with the possibility of an item appearing in both if it a topic-command. This makes it clearer what is expected to be ran - "COMMANDS" - and what is providing structure - "TOPICS" - when looking at the help output.
VERSION  plugin-help-example/0.0.0 darwin-x64 node-v12.12.0USAGE  $ plugin-help-example [COMMAND]TOPICS  topic  this is a topic and has child topics or commandsCOMMANDS  hello  describe the command here  help   display help for plugin-help-example
We look forward to seeing what custom help features you implement in your oclif CLIs with this new feature!oclif TSLint to ESLint MigrationDecember 5, 2019 · 3 min readBack in February of this year, plans were announced to deprecate TSLint in favor of ESLint. TSLint's goal has become to work toward a “unified developer experience” by supporting ESLint development going forward.
What has changed in oclif​
To keep inline with the community, oclif has transitioned to ESLint for all our core libraries as well as all our official plugins.
Starting in v1.15.x, oclif will now optionally generate projects with ESLint for both TypeScript and JavaScript CLI’s.
ESLint does require Node to be on stable LTS version, at the time of writing, Node 8.10.x, Node 10.13.x & Node 12.x.x.
How does this affect you​
Existing CLI’s are unchanged, but any newly generated CLI's will only give the option of using ESLint. If you are running tslint in your CLI, we recommend you switch to ESLint as well.
In migrating our projects we took the following steps (for an example of these changes see this pull request).


Install eslint
$ yarn add eslint eslint-config-oclif eslint-config-oclif-typescript --dev


Add eslint related files


$ echo '{  "extends": [    "oclif",    "oclif-typescript"  ],  "rules": {  }}' > .eslintrc


Remove tslint and related packages
$ yarn remove @oclif/tslint tslint


Remove tslint related configuration files
$ rm tslint.json


Change lint script in our package.json from something like:
"lint": "tsc -p test --noEmit && tslint -p test -t stylish"
to
"lint": "eslint . --ext .ts --config .eslintrc"


To preserve the test compile (tsc -p test --noEmit) we also made the following updates to our scripts:
"pretest": "tsc -p test --noEmit"
In some cases we had our posttest duplicating the same steps as our lint script so it’s cleaner to have it reference the lint job directly with:
"posttest": "yarn lint"

Run yarn lint --fix. This attempts to auto-fix any linting violations automatically. In the case an auto-fix isn’t available it should be fixed manually or ignored (see the eslint configuration doc for more information)
Do a search in the codebase for tslint and remove any unnecessary tslint disabling comments, like:

/* tslint:disable:object-literal-sort-keys */
If you are on a version of Node that is not supported by ESLint, you will also need to update your Node engine. ESLint supports Node 8, 10, and 12 so you should upgrade to the most recent Node version compatible with your CLI and also supported by ESLint (see ESLint's Installation and Usage instructions).
When will this take effect​
These changes have taken effect in oclif v1.15.1. When you generate a new CLI or plugin it will now contain configuration for ESLint instead of TSLint.oclif's Current Node SupportOctober 31, 2019 · 3 min readTo maintain a healthy project trajectory, oclif follows and supports Node Active LTS release, currently Node 10 & Node 12. This means ensuring that oclif continues to play nice with coming Active LTS Node versions and other packages in the ecosystem. Moving forward also means leaving older versions behind. Starting in 2020, Node will stop maintaining Node 8 and it is our intent at that time to also follow suit. Let’s take a look at a few ways we will be supporting these changes.
CI Environments​
CLIs created with the oclif cli going forward will be generated with a CircleCI configuration with Node 10 & 12 and an Appveyor configuration using Node 10. We have also added Node latest to CircleCi to be an early warning detection against coming Node changes (Node latest is managed by CircleCI).
We have already updated every oclif repo's CI configs to reflect this.
If your existing CLI uses either Appveyor or CircleCI you can update your config files also, like so:
.circleci/config.yml​
Your CircleCI config should contain a node-latest job, aliased as test. From this, there should be two extensions of this job for the Active LTS Node versions, Node 10 and Node 12.
  node-10:    <<: *node-latest    docker:      - image: node:10  node-12:    <<: *node-latest    docker:      - image: node:12
Notice that these declarations only change the Docker Node images used to run that job.
Additionally, the jobs listed within workflows must also be updated to reflect our changes in configuration:
    jobs:      - node-latest      - node-10      - node-12
appveyor.yml​
For appveyor we are currently only testing the oldest Active LTS Node version, Node 10. Update the nodejs_version proppert in your appveyor.yml file to reflect this.
environment:  nodejs_version: "10"
Deprecating Node 8 & Updating packge.json engines​
In Jan 2020, Node will end its Node 8 maintenance. We will follow suit by setting the package.json engine property in oclif packages to >=10 and bumping the package's major versions.
Depending on how you ship your CLI you may wish to also bump the engines version in your CLI's package.json. You can read more about the implications of the engines property configuration in the npm documentation.
Also consider distributing your CLI with its own Node version.
Packaged Node Version​
When using dev-cli to pack your CLI it will use the Node version as specified in your package.json under the oclif.update.node.version property. This value should reflect an Active LTS Node version (dev-cli does not currently enforce versions).
Supporting the future​
As a community we may discover bumps along the way as we upgrade. If you notice something related to oclif please feel free to open an issue or submit a pull request under the relevant oclif package within the org.
We look forward to using the latest from Node and the community and keeping oclif healthy along the way.oclifconf 2019: A RecapSeptember 16, 2019 · 4 min readIn May, Heroku and Salesforce Open Source organized oclifconf, a conference for developers & product managers building CLI tools on top of the open source oclif framework. The speakers came from various tech companies, such as Adobe, Netlify, and Apollo, who have already built amazing CLI experiences. The topics covered everything from the incredible capabilities oclif has unlocked, to the community-built plugins extending its functionality, and even what the behavior of an adaptive CLI tool might look like.
Below is a listing of all of the talks from the event, along with a short summary. Enjoy!
The future of oclif by Jeff Dickey​

In its relatively short lifetime, oclif has already inspired many developers and companies to adopt its framework as a means for implementing their own command-line tooling. In this talk, Jeff Dickey, an oclif founding team member, recaps the project's history and inspiration. He also looks towards the future and outlines some features and improvements that the tool could adapt. This isn't so much a definitive roadmap of where oclif is headed, but rather, a call to inspiration for developers eager to contribute! And if you are interested in contributing, check out the open issues in the oclif GitHub repo and come say "Hello!" on Spectrum Chat.
Open Source Citizenship by Josh Simmons​

When it comes to open source, it's more than just individuals now. More and more frequently, large corporations are contributing to projects by donating to contributors, sponsoring events, or upstreaming contributions. But keeping open source projects and communities healthy requires more than just money and brainpower. Josh Simmons surveyed multiple open source communities and relays his findings as to what help maintainers and contributors actually need in this talk.
Building an enterprise-grade CLI with oclif by Thomas Dvornik​

Security and performance are all about trust. While oclif is an extremely extensible framework for building CLI tooling, there are additional requirements to fulfill for enterprise businesses to adopt it that might not be necessary for individual developers. Thomas Dvornik outlines what he and his colleagues at Salesforce have implemented as plugins to oclif to satisfy these needs, including encrypted OAuth, plugin signing, lazy loading dependencies, synchronizing weekly releases and deprecations across dozens of repositories, and establishing cross-team coding and documentation standards.
How Adobe I/O built an extensible CLI with oclif by Jesse MacFadyen​

Perhaps oclif's most appealing feature is its support for plugins. In Cordova's case, they've created a sophisticated telemetry system that helps Adobe developers see which commands users are using--and reports on which ones are erroring out. By embedding a feedback system into the tool, users are even able to quickly send their suggestions to a form, without ever leaving the terminal. Jesse MacFadyen demonstrates how oclif's plugin system can work beyond simply executing commands.
Integrating oclif with GraphQL and Apollo by Evans Hauser​

For Evans Hauser and the team at Apollo, oclif is best thought of as "React for the CLI." As a client paired with a strongly-typed API contract to a server, it can deliver structured and consistent commands to retrieve external data. What better mechanism to use for this transfer than GraphQL, a framework which empowers the client to ask precisely for the data it needs, and nothing more?
Adaptive Intent-based CLI State Machines by Shawn Wang​

In designing oclif, Jeff Dickey wrote out 12 CLI factors to keep in mind. In this talk, Shawn Wang outlines a 13th: state. State is hard, because it depends on context, and context depends on understanding what a user intends to do, not what they are asking. Shawn is working towards enabling oclif to better understand the commands a user has entered, so that it can predict and interpret future commands that might be entered next. This would enable CLI tools to not just interpret a users' commands, but to also interpret their intent.Older Entries\n\n\n\nIntroducing `oclif init` commandApril 10, 2024 · 2 min readThanks to the contribution of @joshcanhelp we released a new command for the oclif CLI called oclif init in version 4.8.0
The oclif init command allows you to initialize oclif in an existing project directory by adding the bare minimum requirements: a few pieces of configuration, bin scripts, and a couple of dependencies (@oclif/core and ts-node). This is slightly different from oclif generate, which will create an entirely new oclif project based on our templates.
oclif init will add the following:

bin scripts: bin/run.js, bin/run.cmd, bin/dev.js, and bin/dev.cmd
oclif section to package.json with bin, dirname, commands, and topicSeparator set (See Configuring Your CLI for more)
@oclif/core to dependencies in your package.json (if it's not already there)
ts-node to devDependencies in your package.json (if it's not already there)

Once you've initialized oclif, you can use the bin scripts to execute your CLI. You can also use the other oclif commands like oclif generate command and oclif generate hook to start adding new functionality.

❯ oclif init --helpInitialize a new oclif CLIUSAGE  $ oclif init [--bin <value>] [--module-type ESM|CommonJS] [--package-manager npm|yarn|pnpm] [--topic-separator    colons|spaces] [-d <value>] [-y]FLAGS  -d, --output-dir=<value>        Directory to initialize the CLI in.  -y, --yes                       Use defaults for all prompts. Individual flags will override defaults.      --bin=<value>               Supply answer for prompt: Command bin name the CLI will export      --module-type=<option>      Supply answer for prompt: Select a module type                                  <options: ESM|CommonJS>      --package-manager=<option>  Supply answer for prompt: Select a package manager                                  <options: npm|yarn|pnpm>      --topic-separator=<option>  Supply answer for prompt: Select a topic separator                                  <options: colons|spaces>DESCRIPTION  Initialize a new oclif CLI  This will add the necessary oclif bin files, add oclif config to package.json, and install @oclif/core and ts-node.EXAMPLES  Initialize a new CLI in the current directory    $ oclif init  Initialize a new CLI in a different directory    $ oclif init --output-dir "/path/to/existing/project"  Supply answers for specific prompts    $ oclif init --topic-separator colons --bin mycli
Hope you enjoy the new command! If you come across any issues or have any new ideas for this command, head over to the oclif/oclif repo and open a new issue.
All our best,
The oclif teamoclif Spring 2024 UpdateMarch 29, 2024 · 4 min readHello oclif developers! It's been a while since we last uploaded a blog - and a lot has happened.
We've been focusing on these high-level areas over the past couple of years:

Improving @oclif/core
ESM Support
Improving and revitalizing oclif.io
Re-engaging the oclif community

Improving @oclif/core​
Since we announced @oclif/core over three years ago, we've released two new major versions, each packed with lots of features that we're really excited about.
Here are some of these changes:

Full support for ESM and interoperability with CommonJS (more on this topic below).
Configurable command discovery strategies that give you more control over how commands are loaded at runtime. Check out the docs.
A new preparse hook that allows you to manipulate the provided arguments before they're parsed. Salesforce used this hook to implement a neat --flags-dir feature that translates local files into flags.
A new Performance class that you can use to track performance inside of @oclif/core and your own CLI or plugin. Check out the docs.
A new flag type, Flags.option, that lets you define a flag with a preset list of options. Typescript then uses the options to infer the flag's type.
Flags now have a relationship property that allows you to define more complex relationships between flags. Check out the flags docs for more information.
Flags now have a defaultHelp property that allows you to set the human readable default value in the command help. This property is useful when your flag's parse method returns a complex type, such as an object or a class. Check out the flags docs for more.
Commands now have a hiddenAliases property that allows you to define aliases that you want to hide from the user. The property is super helpful when you're trying to wean users off a deprecated command.
You can now use bun or tsx as dev runtimes (as opposed to node or ts-node).
A command's usage, args, and flags are now shown whenever a user forgets to provide a required arg or flag, or when they provided a non-existent flag.

If you need help migrating to the latest version, head over to core's README which has links to the migration guides. Feel free to open a new discussion if you need more hands-on help from us or the community.
ESM Support​
Version 3 of @oclif/core introduced full support for developing ESM plugins and CLIs. It also offered full support for interoperability between CommonJS and ESM plugins.
Put more simply, you can now migrate your CLI to ESM while keeping individual plugins in CommonJS (or vice versa). The upgrade path is now much simpler for you. You also don't need to worry about any community plugins that have migrated to ESM before you did (such as all the @oclif plugins) or are staunchly sticking with CommonJS for the foreseeable future.
Read more about this topic here.
Improving and Revitalizing oclif.io​
Another area of focus for us has been improving our documentation site, oclif.io.
While improving the quality and accuracy of the documentation was our priority, we also took the time to upgrade to the latest version of docusaurus. This new version gave our site a much-needed facelift, as well as cool new features such as dark mode and announcements.
If you have any feedback or are running into issues, we want to hear about it. Just create an issue in the oclif.io repo.
Re-engaging the oclif Community​
Lastly, our biggest priority at the moment is to re-engage the oclif community. We understand how frustrating it has been over the years to see your issues and pull requests go unacknowledged. We apologize for not prioritizing the community, and are earnestly trying to make sure that every issue and pull request gets the attention it deserves going forward.
We also opened up GitHub discussions for @oclif/core and the oclif CLI, where you can now post your questions or ideas. We hope you take advantage of them, we love hearing from you!
One last thing: we intend to publicly post our roadmap so you have more visibility into what we're working on. Stay tuned!
All our best,
The oclif teamAnnouncing oclif v2!January 12, 2022 · 5 min readHello and happy new year! It's our great pleasure to announce that we have released oclif v2, which uses the new @oclif/core library! 🎉
oclif v2 includes many changes that improve the experience of both creating and using an oclif CLI.
Going forward, we don't plan to make any updates to oclif v1 and its corresponding libraries, except for critical security fixes. See the compatibility matrix for a list of these libraries. In order to give developers time to migrate from v1 to v2, we're not completely dropping support yet. But at some point in the future we'll archive the v1 repositories and deprecate their versions on npm.
What’s changing?​
Repository Changes​
All repositories under the oclif org now use main as their primary branch and oclif-v1 as the legacy branch. The main  branch corresponds to oclif v2 and the oclif-v1 branch to oclif v1. If you find any repos that don’t have a main branch, you can safely assume that they're not used in oclif v2 and will be deprecated in the future.
Consolidating Tools & Libraries​
The oclif-dev CLI has now been incorporated into oclif. You now no longer need to install a separate package to manage your entire CLI’s lifecycle.
The following libraries have been consolidated under @oclif/core and will be deprecated at some point in the future. Read the migration guide to learn how to update your CLI or plugin to use the new core library.

@oclif/command
@oclif/config
@oclif/error
@oclif/help
@oclif/parser

No more single vs multi command CLIs​
There's only one "type" of oclif v2 CLI, but it can have as few or as many commands as a developer wants. As a result, there’s only one command to generate CLIs, oclif generate, as opposed to the old oclif single and oclif multi commands.
Node > 12​
To ensure oclif CLIs are as secure as possible, all v2 libraries and plugins support only Node 12 or higher as of now. Going forward, they'll support only Node Maintenance or higher, as defined by Node's release schedule here: https://nodejs.org/en/about/releases/.
What’s new?​
New example CLI​
oclif-hello-world is our new example repo. This is also the repo that's used as a template when running oclif generate to create a new CLI. This repo will always be able to be referenced as an example of what an oclif v2 CLI should look like.
Spaced commands​
oclif CLIs can now use spaces, instead of colons, to separate topics and subcommands. To enable this feature, simply add “topicSeparator": " " to the oclif config in your package.json. See an example in our example repo.
// Old commands that use :$ mycli do:something
// New spaced commands$ mycli do something

Note: Spaced commands are backwards compatible. So if you enable spaced commands for your CLI, users will still be able to use : as a separator. This ensures that any existing scripts don't break.

New Help Output​
We’ve revamped the way command help is outputted to the terminal, making it both easier to implement and easier to read. See the difference between the old help output on the left and the new help output on the right in the screenshots below.
oclif v1oclif v2
Notice that there are new sections for flags and global flags, examples are displayed with better spacing, and there is a section at the bottom called Configuration Variables. This Configuration Variables section is not part of the new help by default. But we've added support for custom help sections, which is what the sf CLI uses to create the new section.
Async Command Parsing​
We’ve also improved the performance of new CLIs by rewriting how commands are parsed on initialization. The new parser is asynchronous, which makes CLIs with a lot of commands or installed  plugins much faster.
What’s coming next?​
Part of our charter for the release of oclif v2 includes improving our engagement with the oclif community. We know that over the past couple of years we’ve reduced our involvement, and a lot of issues and PRs have languished in limbo. Hopefully you’ve already seen increased activity and responses from oclif maintainers recently, but if you haven’t, please don’t hesitate to ping us by tagging @admins in oclif repos.
We also want to start interviewing members of the oclif community to acquire feedback and prioritize the features and fixes you deem most important!
Best,
The oclif team

Reference material​
Migration Guide​
This guide explains how to upgrade a CLI or plugin from the old oclif v1 libraries to the new @oclif/core library that oclif v2 uses.
https://github.com/oclif/core/blob/main/MIGRATION.md
Compatibility Matrix​
The following matrix shows how the v1 libraries and plugins relate to the new v2 ones. Use this matrix as a guide to know what to drop and which versions to switch when upgrading your plugins and CLIs to v2.
oclif "v1"oclif "v2"Utility CLIsoclif@<2@oclif/dev-cli@<2oclif@>=2Main packages@oclif/command@oclif/config@oclif/errors@oclif/parser@oclif/plugin-help@oclif/core@>=1Node LTSNode v8-14Node v12+ (at time of writing)TypeScripttypescript@<4typescript@>=4Main plugins@oclif/plugin-autocomplete@<1@oclif/plugin-commands@<2@oclif/plugin-help@<4@oclif/plugin-not-found@<2@oclif/plugin-plugins@<2@oclif/plugin-update@<2plugin-warn-if-update-available@<2plugin-which@<2@oclif/plugin-autocomplete@>=1@oclif/plugin-commands@>=2@oclif/plugin-help@>=4@oclif/plugin-not-found@>=2@oclif/plugin-plugins@>=2@oclif/plugin-update@>=2@oclif/plugin-warn-if-update-available@>=2@oclif/plugin-which@>=2Introducing @oclif/coreMarch 1, 2021 · 3 min readGreetings!
We hope this blog post finds you well.
Introducing...​
We are excited to announce the next iteration of the oclif project today: @oclif/core.
We have learned a lot in the last three years of developing oclif, developing on oclif and supporting millions of command runs a day via Heroku and Salesforce CLIs.
@oclif/core ("Core") simplifies the oclif development experience and introduces highly requested new features.
Core combines the essential oclif packages into one "core" package, aptly named @oclif/core.
Core also introduces:

A default command option
Colon or space command syntax
Async command parsing
Command piping to arguments

With the introduction of default command functionality, Core simplifies the oclif project and removes the notion of single or multi command CLIs. Core CLIs can have 1 or many commands.
Along with Core, we moved the oclif-dev CLI into the oclif CLI creating a single "utility" CLI. This CLI also introduces a new AWS S3 compatible publishing scheme.
What to expect in the near future​
Core is in pre-release beta and being actively developed for new internal Salesforce CLIs.
Much documentation needs to be written in the coming months including migration paths. Migration onto Core should be as painless as possible with many exports remaining entirely unchanged. Look for forthcoming blog posts and documentation on oclif.io.
Early this summer, tentively June 1, we will release Core v1. Core's release will coincide with major bumps to many other oclif plugin packages. See the compatibility matrix below.
At Core's v1 release, the current "main" oclif packages (namely: command, config, errors & parser) will go into maintenance mode until Jan 2022. They will receive only bug and security fixes and they remain compatible with current versions of the oclif and oclif-dev CLIs. Afterwhich, they will be archived.
Companioning Core, the next major release of the oclif CLI (literally oclif@2) will generate Core CLIs.
Going forward​
We are excited to release Core! We invite you to poke around the Core repo. It may appear to be a big change but Core keeps what you already enjoy about oclif while reducing development complexity, project dependencies, package coupling and bundle size and introduces many requested features previously too prickly to weave into the current oclif architecture.
Best,
The oclif team
Reference: Compatibility matrix​
oclif "v1"oclif "Core"Utility CLIsoclif@<2@oclif/dev-cli@<2oclif@>=2Main packages@oclif/core@<2@oclif/config@<2@oclif/errors@<2@oclif/parser@<4@oclif/plugin-help@<4@oclif/core@>=1Node LTSNode v8-14Node v12+TypeScripttypescript@<4typescript@>=4Main plugins@oclif/plugin-autocomplete@<1@oclif/plugin-commands@<2@oclif/plugin-help@<4@oclif/plugin-not-found@<2@oclif/plugin-plugins@<2@oclif/plugin-update@<2plugin-warn-if-update-available@<2plugin-which@<2@oclif/plugin-autocomplete@>=2@oclif/plugin-commands@>=2@oclif/plugin-help@>=4@oclif/plugin-not-found@>=2@oclif/plugin-plugins@>=2@oclif/plugin-update@>=2@oclif/plugin-warn-if-update-available@>=2@oclif/plugin-which@>=2oclif Summer 2020 UpdateAugust 26, 2020 · 2 min readHello oclif developers! We hope you are all doing well.
Earlier this year, we started our planning for oclifconf v2 and, like all conference, had to change course. We opted not to hold a virtual conference, however, we wanted to take some time to highlight a few oclif features shipped this year.
Feature: Help templating​
One of the most requested features, help templating enables oclif developers to customize the help output for their CLI.
Read the announcement.
Feature: Custom error delegation​
This feature both improved how oclif throws and handles errors and allows oclif developers to overwrite or interject in oclif’s error handling.
Read the announcement.
Feature: postrun hooks​
We have added a new lifecycle event postrun. Your CLI can now run a hook after a command has ran.
See our hook documentation.
Feature: Root index command​
Previously, oclif would display CLI help if only the binary name with no command ID was invoked, oclif now supports a "root index" command. If present, a command defined at src/commands/index.ts will be run if no command ID is found.
1 million weekly downloads​
While exact oclif usage metrics are hard to pin down, we use npm download statistics of oclif packages as a rough approximation. Earlier this year, oclif's command package hit 1 million weekly downloads for the first time!
This year has been presented its challenges on everyone. We want to thank you, oclif developers, whom have taken the time to use and improve the oclif project. We look forward to seeing you all - in person - in the future!
All our best,
The oclif teamPretty Printable ErrorsJuly 1, 2020 · One min readOften CLIs are used as handy tools and when things go wrong it’s useful to have additional context. In oclif we have added a couple of additional properties that can show extra context to the users when an error is displayed. The code, ref and suggestions will now be displayed if they are included. This will work with an existing oclif CLI by adding the latest @oclif/errors and @oclif/core to the CLI's package.json dependencies.
For example, using this.error with the additional properties:
class TestError extends Command {  async run() {    this.error("An error has occurred!", {      code: "OCLIF_ERR",      ref: "https://oclif.io/docs/commands#thiserrormessage-string--error-options-code-string-exit-number",      suggestions: ["Use these extra properties to provide additional context"],    })  }}
would result with the following output:
›   Error: An error has occurred!›   Code: OCLIF_ERR›   Try this: Use these extra properties to provide additional context›   Reference: https://oclif.io/docs/commands#thiserrormessage-string--error-options-code-string-exit-number
If these properties are not provided then nothing changes and the CLI will continue to display the single error message output as it did before. Additionally, as part of this exercise we’ve added documentation around Error Handling in oclif which should come in handy if the need arises to extend oclif’s default handling of errors.Customizing Help in oclifMay 5, 2020 · 2 min readOut of the box oclif provides a great help experience for CLIs.
But what if, as an oclif developer, you want to customize some or all of the output?
You can now customize your CLI's help output by implementing the HelpBase abstract class.
Getting started with custom help​
If you have not done so yet, update @oclif/core.
$ yarn add --latest @oclif/core
To get started, first define the filepath to your help class in oclif's config in package.json. This is a relative path to the help class, without a file extension.
For this example, the help class will be created in a file at "[project root]/src/help.ts".
{  // ...  "oclif": {    "helpClass": "./lib/help"    // ...  }  // ...}
From here there are two paths, implement the HelpBase abstract class yourself or overwrite the parts of the default Help class you want to customize (ex: how command usage is displayed). We recommend the latter approach but cover both in the new Help Classes docs.
Separating TOPICS & COMMANDS in the new default Help class​
Previously, topics and child commands were listed in help output under a single list heading called "COMMANDS". But we found this can be slightly confusing. Some topics are commands also (a.k.a. topic-commands) while others are simply organizational namespacing (and when ran just show their help).
The new default Help class splits the list of children into distinct lists of "TOPICS" and "COMMANDS", with the possibility of an item appearing in both if it a topic-command. This makes it clearer what is expected to be ran - "COMMANDS" - and what is providing structure - "TOPICS" - when looking at the help output.
VERSION  plugin-help-example/0.0.0 darwin-x64 node-v12.12.0USAGE  $ plugin-help-example [COMMAND]TOPICS  topic  this is a topic and has child topics or commandsCOMMANDS  hello  describe the command here  help   display help for plugin-help-example
We look forward to seeing what custom help features you implement in your oclif CLIs with this new feature!oclif TSLint to ESLint MigrationDecember 5, 2019 · 3 min readBack in February of this year, plans were announced to deprecate TSLint in favor of ESLint. TSLint's goal has become to work toward a “unified developer experience” by supporting ESLint development going forward.
What has changed in oclif​
To keep inline with the community, oclif has transitioned to ESLint for all our core libraries as well as all our official plugins.
Starting in v1.15.x, oclif will now optionally generate projects with ESLint for both TypeScript and JavaScript CLI’s.
ESLint does require Node to be on stable LTS version, at the time of writing, Node 8.10.x, Node 10.13.x & Node 12.x.x.
How does this affect you​
Existing CLI’s are unchanged, but any newly generated CLI's will only give the option of using ESLint. If you are running tslint in your CLI, we recommend you switch to ESLint as well.
In migrating our projects we took the following steps (for an example of these changes see this pull request).


Install eslint
$ yarn add eslint eslint-config-oclif eslint-config-oclif-typescript --dev


Add eslint related files


$ echo '{  "extends": [    "oclif",    "oclif-typescript"  ],  "rules": {  }}' > .eslintrc


Remove tslint and related packages
$ yarn remove @oclif/tslint tslint


Remove tslint related configuration files
$ rm tslint.json


Change lint script in our package.json from something like:
"lint": "tsc -p test --noEmit && tslint -p test -t stylish"
to
"lint": "eslint . --ext .ts --config .eslintrc"


To preserve the test compile (tsc -p test --noEmit) we also made the following updates to our scripts:
"pretest": "tsc -p test --noEmit"
In some cases we had our posttest duplicating the same steps as our lint script so it’s cleaner to have it reference the lint job directly with:
"posttest": "yarn lint"

Run yarn lint --fix. This attempts to auto-fix any linting violations automatically. In the case an auto-fix isn’t available it should be fixed manually or ignored (see the eslint configuration doc for more information)
Do a search in the codebase for tslint and remove any unnecessary tslint disabling comments, like:

/* tslint:disable:object-literal-sort-keys */
If you are on a version of Node that is not supported by ESLint, you will also need to update your Node engine. ESLint supports Node 8, 10, and 12 so you should upgrade to the most recent Node version compatible with your CLI and also supported by ESLint (see ESLint's Installation and Usage instructions).
When will this take effect​
These changes have taken effect in oclif v1.15.1. When you generate a new CLI or plugin it will now contain configuration for ESLint instead of TSLint.oclif's Current Node SupportOctober 31, 2019 · 3 min readTo maintain a healthy project trajectory, oclif follows and supports Node Active LTS release, currently Node 10 & Node 12. This means ensuring that oclif continues to play nice with coming Active LTS Node versions and other packages in the ecosystem. Moving forward also means leaving older versions behind. Starting in 2020, Node will stop maintaining Node 8 and it is our intent at that time to also follow suit. Let’s take a look at a few ways we will be supporting these changes.
CI Environments​
CLIs created with the oclif cli going forward will be generated with a CircleCI configuration with Node 10 & 12 and an Appveyor configuration using Node 10. We have also added Node latest to CircleCi to be an early warning detection against coming Node changes (Node latest is managed by CircleCI).
We have already updated every oclif repo's CI configs to reflect this.
If your existing CLI uses either Appveyor or CircleCI you can update your config files also, like so:
.circleci/config.yml​
Your CircleCI config should contain a node-latest job, aliased as test. From this, there should be two extensions of this job for the Active LTS Node versions, Node 10 and Node 12.
  node-10:    <<: *node-latest    docker:      - image: node:10  node-12:    <<: *node-latest    docker:      - image: node:12
Notice that these declarations only change the Docker Node images used to run that job.
Additionally, the jobs listed within workflows must also be updated to reflect our changes in configuration:
    jobs:      - node-latest      - node-10      - node-12
appveyor.yml​
For appveyor we are currently only testing the oldest Active LTS Node version, Node 10. Update the nodejs_version proppert in your appveyor.yml file to reflect this.
environment:  nodejs_version: "10"
Deprecating Node 8 & Updating packge.json engines​
In Jan 2020, Node will end its Node 8 maintenance. We will follow suit by setting the package.json engine property in oclif packages to >=10 and bumping the package's major versions.
Depending on how you ship your CLI you may wish to also bump the engines version in your CLI's package.json. You can read more about the implications of the engines property configuration in the npm documentation.
Also consider distributing your CLI with its own Node version.
Packaged Node Version​
When using dev-cli to pack your CLI it will use the Node version as specified in your package.json under the oclif.update.node.version property. This value should reflect an Active LTS Node version (dev-cli does not currently enforce versions).
Supporting the future​
As a community we may discover bumps along the way as we upgrade. If you notice something related to oclif please feel free to open an issue or submit a pull request under the relevant oclif package within the org.
We look forward to using the latest from Node and the community and keeping oclif healthy along the way.oclifconf 2019: A RecapSeptember 16, 2019 · 4 min readIn May, Heroku and Salesforce Open Source organized oclifconf, a conference for developers & product managers building CLI tools on top of the open source oclif framework. The speakers came from various tech companies, such as Adobe, Netlify, and Apollo, who have already built amazing CLI experiences. The topics covered everything from the incredible capabilities oclif has unlocked, to the community-built plugins extending its functionality, and even what the behavior of an adaptive CLI tool might look like.
Below is a listing of all of the talks from the event, along with a short summary. Enjoy!
The future of oclif by Jeff Dickey​

In its relatively short lifetime, oclif has already inspired many developers and companies to adopt its framework as a means for implementing their own command-line tooling. In this talk, Jeff Dickey, an oclif founding team member, recaps the project's history and inspiration. He also looks towards the future and outlines some features and improvements that the tool could adapt. This isn't so much a definitive roadmap of where oclif is headed, but rather, a call to inspiration for developers eager to contribute! And if you are interested in contributing, check out the open issues in the oclif GitHub repo and come say "Hello!" on Spectrum Chat.
Open Source Citizenship by Josh Simmons​

When it comes to open source, it's more than just individuals now. More and more frequently, large corporations are contributing to projects by donating to contributors, sponsoring events, or upstreaming contributions. But keeping open source projects and communities healthy requires more than just money and brainpower. Josh Simmons surveyed multiple open source communities and relays his findings as to what help maintainers and contributors actually need in this talk.
Building an enterprise-grade CLI with oclif by Thomas Dvornik​

Security and performance are all about trust. While oclif is an extremely extensible framework for building CLI tooling, there are additional requirements to fulfill for enterprise businesses to adopt it that might not be necessary for individual developers. Thomas Dvornik outlines what he and his colleagues at Salesforce have implemented as plugins to oclif to satisfy these needs, including encrypted OAuth, plugin signing, lazy loading dependencies, synchronizing weekly releases and deprecations across dozens of repositories, and establishing cross-team coding and documentation standards.
How Adobe I/O built an extensible CLI with oclif by Jesse MacFadyen​

Perhaps oclif's most appealing feature is its support for plugins. In Cordova's case, they've created a sophisticated telemetry system that helps Adobe developers see which commands users are using--and reports on which ones are erroring out. By embedding a feedback system into the tool, users are even able to quickly send their suggestions to a form, without ever leaving the terminal. Jesse MacFadyen demonstrates how oclif's plugin system can work beyond simply executing commands.
Integrating oclif with GraphQL and Apollo by Evans Hauser​

For Evans Hauser and the team at Apollo, oclif is best thought of as "React for the CLI." As a client paired with a strongly-typed API contract to a server, it can deliver structured and consistent commands to retrieve external data. What better mechanism to use for this transfer than GraphQL, a framework which empowers the client to ask precisely for the data it needs, and nothing more?
Adaptive Intent-based CLI State Machines by Shawn Wang​

In designing oclif, Jeff Dickey wrote out 12 CLI factors to keep in mind. In this talk, Shawn Wang outlines a 13th: state. State is hard, because it depends on context, and context depends on understanding what a user intends to do, not what they are asking. Shawn is working towards enabling oclif to better understand the commands a user has entered, so that it can predict and interpret future commands that might be entered next. This would enable CLI tools to not just interpret a users' commands, but to also interpret their intent.\n\nIntroducing `oclif init` commandApril 10, 2024 · 2 min readThanks to the contribution of @joshcanhelp we released a new command for the oclif CLI called oclif init in version 4.8.0
The oclif init command allows you to initialize oclif in an existing project directory by adding the bare minimum requirements: a few pieces of configuration, bin scripts, and a couple of dependencies (@oclif/core and ts-node). This is slightly different from oclif generate, which will create an entirely new oclif project based on our templates.
oclif init will add the following:

bin scripts: bin/run.js, bin/run.cmd, bin/dev.js, and bin/dev.cmd
oclif section to package.json with bin, dirname, commands, and topicSeparator set (See Configuring Your CLI for more)
@oclif/core to dependencies in your package.json (if it's not already there)
ts-node to devDependencies in your package.json (if it's not already there)

Once you've initialized oclif, you can use the bin scripts to execute your CLI. You can also use the other oclif commands like oclif generate command and oclif generate hook to start adding new functionality.

❯ oclif init --helpInitialize a new oclif CLIUSAGE  $ oclif init [--bin <value>] [--module-type ESM|CommonJS] [--package-manager npm|yarn|pnpm] [--topic-separator    colons|spaces] [-d <value>] [-y]FLAGS  -d, --output-dir=<value>        Directory to initialize the CLI in.  -y, --yes                       Use defaults for all prompts. Individual flags will override defaults.      --bin=<value>               Supply answer for prompt: Command bin name the CLI will export      --module-type=<option>      Supply answer for prompt: Select a module type                                  <options: ESM|CommonJS>      --package-manager=<option>  Supply answer for prompt: Select a package manager                                  <options: npm|yarn|pnpm>      --topic-separator=<option>  Supply answer for prompt: Select a topic separator                                  <options: colons|spaces>DESCRIPTION  Initialize a new oclif CLI  This will add the necessary oclif bin files, add oclif config to package.json, and install @oclif/core and ts-node.EXAMPLES  Initialize a new CLI in the current directory    $ oclif init  Initialize a new CLI in a different directory    $ oclif init --output-dir "/path/to/existing/project"  Supply answers for specific prompts    $ oclif init --topic-separator colons --bin mycli
Hope you enjoy the new command! If you come across any issues or have any new ideas for this command, head over to the oclif/oclif repo and open a new issue.
All our best,
The oclif teamoclif Spring 2024 UpdateMarch 29, 2024 · 4 min readHello oclif developers! It's been a while since we last uploaded a blog - and a lot has happened.
We've been focusing on these high-level areas over the past couple of years:

Improving @oclif/core
ESM Support
Improving and revitalizing oclif.io
Re-engaging the oclif community

Improving @oclif/core​
Since we announced @oclif/core over three years ago, we've released two new major versions, each packed with lots of features that we're really excited about.
Here are some of these changes:

Full support for ESM and interoperability with CommonJS (more on this topic below).
Configurable command discovery strategies that give you more control over how commands are loaded at runtime. Check out the docs.
A new preparse hook that allows you to manipulate the provided arguments before they're parsed. Salesforce used this hook to implement a neat --flags-dir feature that translates local files into flags.
A new Performance class that you can use to track performance inside of @oclif/core and your own CLI or plugin. Check out the docs.
A new flag type, Flags.option, that lets you define a flag with a preset list of options. Typescript then uses the options to infer the flag's type.
Flags now have a relationship property that allows you to define more complex relationships between flags. Check out the flags docs for more information.
Flags now have a defaultHelp property that allows you to set the human readable default value in the command help. This property is useful when your flag's parse method returns a complex type, such as an object or a class. Check out the flags docs for more.
Commands now have a hiddenAliases property that allows you to define aliases that you want to hide from the user. The property is super helpful when you're trying to wean users off a deprecated command.
You can now use bun or tsx as dev runtimes (as opposed to node or ts-node).
A command's usage, args, and flags are now shown whenever a user forgets to provide a required arg or flag, or when they provided a non-existent flag.

If you need help migrating to the latest version, head over to core's README which has links to the migration guides. Feel free to open a new discussion if you need more hands-on help from us or the community.
ESM Support​
Version 3 of @oclif/core introduced full support for developing ESM plugins and CLIs. It also offered full support for interoperability between CommonJS and ESM plugins.
Put more simply, you can now migrate your CLI to ESM while keeping individual plugins in CommonJS (or vice versa). The upgrade path is now much simpler for you. You also don't need to worry about any community plugins that have migrated to ESM before you did (such as all the @oclif plugins) or are staunchly sticking with CommonJS for the foreseeable future.
Read more about this topic here.
Improving and Revitalizing oclif.io​
Another area of focus for us has been improving our documentation site, oclif.io.
While improving the quality and accuracy of the documentation was our priority, we also took the time to upgrade to the latest version of docusaurus. This new version gave our site a much-needed facelift, as well as cool new features such as dark mode and announcements.
If you have any feedback or are running into issues, we want to hear about it. Just create an issue in the oclif.io repo.
Re-engaging the oclif Community​
Lastly, our biggest priority at the moment is to re-engage the oclif community. We understand how frustrating it has been over the years to see your issues and pull requests go unacknowledged. We apologize for not prioritizing the community, and are earnestly trying to make sure that every issue and pull request gets the attention it deserves going forward.
We also opened up GitHub discussions for @oclif/core and the oclif CLI, where you can now post your questions or ideas. We hope you take advantage of them, we love hearing from you!
One last thing: we intend to publicly post our roadmap so you have more visibility into what we're working on. Stay tuned!
All our best,
The oclif teamAnnouncing oclif v2!January 12, 2022 · 5 min readHello and happy new year! It's our great pleasure to announce that we have released oclif v2, which uses the new @oclif/core library! 🎉
oclif v2 includes many changes that improve the experience of both creating and using an oclif CLI.
Going forward, we don't plan to make any updates to oclif v1 and its corresponding libraries, except for critical security fixes. See the compatibility matrix for a list of these libraries. In order to give developers time to migrate from v1 to v2, we're not completely dropping support yet. But at some point in the future we'll archive the v1 repositories and deprecate their versions on npm.
What’s changing?​
Repository Changes​
All repositories under the oclif org now use main as their primary branch and oclif-v1 as the legacy branch. The main  branch corresponds to oclif v2 and the oclif-v1 branch to oclif v1. If you find any repos that don’t have a main branch, you can safely assume that they're not used in oclif v2 and will be deprecated in the future.
Consolidating Tools & Libraries​
The oclif-dev CLI has now been incorporated into oclif. You now no longer need to install a separate package to manage your entire CLI’s lifecycle.
The following libraries have been consolidated under @oclif/core and will be deprecated at some point in the future. Read the migration guide to learn how to update your CLI or plugin to use the new core library.

@oclif/command
@oclif/config
@oclif/error
@oclif/help
@oclif/parser

No more single vs multi command CLIs​
There's only one "type" of oclif v2 CLI, but it can have as few or as many commands as a developer wants. As a result, there’s only one command to generate CLIs, oclif generate, as opposed to the old oclif single and oclif multi commands.
Node > 12​
To ensure oclif CLIs are as secure as possible, all v2 libraries and plugins support only Node 12 or higher as of now. Going forward, they'll support only Node Maintenance or higher, as defined by Node's release schedule here: https://nodejs.org/en/about/releases/.
What’s new?​
New example CLI​
oclif-hello-world is our new example repo. This is also the repo that's used as a template when running oclif generate to create a new CLI. This repo will always be able to be referenced as an example of what an oclif v2 CLI should look like.
Spaced commands​
oclif CLIs can now use spaces, instead of colons, to separate topics and subcommands. To enable this feature, simply add “topicSeparator": " " to the oclif config in your package.json. See an example in our example repo.
// Old commands that use :$ mycli do:something
// New spaced commands$ mycli do something

Note: Spaced commands are backwards compatible. So if you enable spaced commands for your CLI, users will still be able to use : as a separator. This ensures that any existing scripts don't break.

New Help Output​
We’ve revamped the way command help is outputted to the terminal, making it both easier to implement and easier to read. See the difference between the old help output on the left and the new help output on the right in the screenshots below.
oclif v1oclif v2
Notice that there are new sections for flags and global flags, examples are displayed with better spacing, and there is a section at the bottom called Configuration Variables. This Configuration Variables section is not part of the new help by default. But we've added support for custom help sections, which is what the sf CLI uses to create the new section.
Async Command Parsing​
We’ve also improved the performance of new CLIs by rewriting how commands are parsed on initialization. The new parser is asynchronous, which makes CLIs with a lot of commands or installed  plugins much faster.
What’s coming next?​
Part of our charter for the release of oclif v2 includes improving our engagement with the oclif community. We know that over the past couple of years we’ve reduced our involvement, and a lot of issues and PRs have languished in limbo. Hopefully you’ve already seen increased activity and responses from oclif maintainers recently, but if you haven’t, please don’t hesitate to ping us by tagging @admins in oclif repos.
We also want to start interviewing members of the oclif community to acquire feedback and prioritize the features and fixes you deem most important!
Best,
The oclif team

Reference material​
Migration Guide​
This guide explains how to upgrade a CLI or plugin from the old oclif v1 libraries to the new @oclif/core library that oclif v2 uses.
https://github.com/oclif/core/blob/main/MIGRATION.md
Compatibility Matrix​
The following matrix shows how the v1 libraries and plugins relate to the new v2 ones. Use this matrix as a guide to know what to drop and which versions to switch when upgrading your plugins and CLIs to v2.
oclif "v1"oclif "v2"Utility CLIsoclif@<2@oclif/dev-cli@<2oclif@>=2Main packages@oclif/command@oclif/config@oclif/errors@oclif/parser@oclif/plugin-help@oclif/core@>=1Node LTSNode v8-14Node v12+ (at time of writing)TypeScripttypescript@<4typescript@>=4Main plugins@oclif/plugin-autocomplete@<1@oclif/plugin-commands@<2@oclif/plugin-help@<4@oclif/plugin-not-found@<2@oclif/plugin-plugins@<2@oclif/plugin-update@<2plugin-warn-if-update-available@<2plugin-which@<2@oclif/plugin-autocomplete@>=1@oclif/plugin-commands@>=2@oclif/plugin-help@>=4@oclif/plugin-not-found@>=2@oclif/plugin-plugins@>=2@oclif/plugin-update@>=2@oclif/plugin-warn-if-update-available@>=2@oclif/plugin-which@>=2Introducing @oclif/coreMarch 1, 2021 · 3 min readGreetings!
We hope this blog post finds you well.
Introducing...​
We are excited to announce the next iteration of the oclif project today: @oclif/core.
We have learned a lot in the last three years of developing oclif, developing on oclif and supporting millions of command runs a day via Heroku and Salesforce CLIs.
@oclif/core ("Core") simplifies the oclif development experience and introduces highly requested new features.
Core combines the essential oclif packages into one "core" package, aptly named @oclif/core.
Core also introduces:

A default command option
Colon or space command syntax
Async command parsing
Command piping to arguments

With the introduction of default command functionality, Core simplifies the oclif project and removes the notion of single or multi command CLIs. Core CLIs can have 1 or many commands.
Along with Core, we moved the oclif-dev CLI into the oclif CLI creating a single "utility" CLI. This CLI also introduces a new AWS S3 compatible publishing scheme.
What to expect in the near future​
Core is in pre-release beta and being actively developed for new internal Salesforce CLIs.
Much documentation needs to be written in the coming months including migration paths. Migration onto Core should be as painless as possible with many exports remaining entirely unchanged. Look for forthcoming blog posts and documentation on oclif.io.
Early this summer, tentively June 1, we will release Core v1. Core's release will coincide with major bumps to many other oclif plugin packages. See the compatibility matrix below.
At Core's v1 release, the current "main" oclif packages (namely: command, config, errors & parser) will go into maintenance mode until Jan 2022. They will receive only bug and security fixes and they remain compatible with current versions of the oclif and oclif-dev CLIs. Afterwhich, they will be archived.
Companioning Core, the next major release of the oclif CLI (literally oclif@2) will generate Core CLIs.
Going forward​
We are excited to release Core! We invite you to poke around the Core repo. It may appear to be a big change but Core keeps what you already enjoy about oclif while reducing development complexity, project dependencies, package coupling and bundle size and introduces many requested features previously too prickly to weave into the current oclif architecture.
Best,
The oclif team
Reference: Compatibility matrix​
oclif "v1"oclif "Core"Utility CLIsoclif@<2@oclif/dev-cli@<2oclif@>=2Main packages@oclif/core@<2@oclif/config@<2@oclif/errors@<2@oclif/parser@<4@oclif/plugin-help@<4@oclif/core@>=1Node LTSNode v8-14Node v12+TypeScripttypescript@<4typescript@>=4Main plugins@oclif/plugin-autocomplete@<1@oclif/plugin-commands@<2@oclif/plugin-help@<4@oclif/plugin-not-found@<2@oclif/plugin-plugins@<2@oclif/plugin-update@<2plugin-warn-if-update-available@<2plugin-which@<2@oclif/plugin-autocomplete@>=2@oclif/plugin-commands@>=2@oclif/plugin-help@>=4@oclif/plugin-not-found@>=2@oclif/plugin-plugins@>=2@oclif/plugin-update@>=2@oclif/plugin-warn-if-update-available@>=2@oclif/plugin-which@>=2oclif Summer 2020 UpdateAugust 26, 2020 · 2 min readHello oclif developers! We hope you are all doing well.
Earlier this year, we started our planning for oclifconf v2 and, like all conference, had to change course. We opted not to hold a virtual conference, however, we wanted to take some time to highlight a few oclif features shipped this year.
Feature: Help templating​
One of the most requested features, help templating enables oclif developers to customize the help output for their CLI.
Read the announcement.
Feature: Custom error delegation​
This feature both improved how oclif throws and handles errors and allows oclif developers to overwrite or interject in oclif’s error handling.
Read the announcement.
Feature: postrun hooks​
We have added a new lifecycle event postrun. Your CLI can now run a hook after a command has ran.
See our hook documentation.
Feature: Root index command​
Previously, oclif would display CLI help if only the binary name with no command ID was invoked, oclif now supports a "root index" command. If present, a command defined at src/commands/index.ts will be run if no command ID is found.
1 million weekly downloads​
While exact oclif usage metrics are hard to pin down, we use npm download statistics of oclif packages as a rough approximation. Earlier this year, oclif's command package hit 1 million weekly downloads for the first time!
This year has been presented its challenges on everyone. We want to thank you, oclif developers, whom have taken the time to use and improve the oclif project. We look forward to seeing you all - in person - in the future!
All our best,
The oclif teamPretty Printable ErrorsJuly 1, 2020 · One min readOften CLIs are used as handy tools and when things go wrong it’s useful to have additional context. In oclif we have added a couple of additional properties that can show extra context to the users when an error is displayed. The code, ref and suggestions will now be displayed if they are included. This will work with an existing oclif CLI by adding the latest @oclif/errors and @oclif/core to the CLI's package.json dependencies.
For example, using this.error with the additional properties:
class TestError extends Command {  async run() {    this.error("An error has occurred!", {      code: "OCLIF_ERR",      ref: "https://oclif.io/docs/commands#thiserrormessage-string--error-options-code-string-exit-number",      suggestions: ["Use these extra properties to provide additional context"],    })  }}
would result with the following output:
›   Error: An error has occurred!›   Code: OCLIF_ERR›   Try this: Use these extra properties to provide additional context›   Reference: https://oclif.io/docs/commands#thiserrormessage-string--error-options-code-string-exit-number
If these properties are not provided then nothing changes and the CLI will continue to display the single error message output as it did before. Additionally, as part of this exercise we’ve added documentation around Error Handling in oclif which should come in handy if the need arises to extend oclif’s default handling of errors.Customizing Help in oclifMay 5, 2020 · 2 min readOut of the box oclif provides a great help experience for CLIs.
But what if, as an oclif developer, you want to customize some or all of the output?
You can now customize your CLI's help output by implementing the HelpBase abstract class.
Getting started with custom help​
If you have not done so yet, update @oclif/core.
$ yarn add --latest @oclif/core
To get started, first define the filepath to your help class in oclif's config in package.json. This is a relative path to the help class, without a file extension.
For this example, the help class will be created in a file at "[project root]/src/help.ts".
{  // ...  "oclif": {    "helpClass": "./lib/help"    // ...  }  // ...}
From here there are two paths, implement the HelpBase abstract class yourself or overwrite the parts of the default Help class you want to customize (ex: how command usage is displayed). We recommend the latter approach but cover both in the new Help Classes docs.
Separating TOPICS & COMMANDS in the new default Help class​
Previously, topics and child commands were listed in help output under a single list heading called "COMMANDS". But we found this can be slightly confusing. Some topics are commands also (a.k.a. topic-commands) while others are simply organizational namespacing (and when ran just show their help).
The new default Help class splits the list of children into distinct lists of "TOPICS" and "COMMANDS", with the possibility of an item appearing in both if it a topic-command. This makes it clearer what is expected to be ran - "COMMANDS" - and what is providing structure - "TOPICS" - when looking at the help output.
VERSION  plugin-help-example/0.0.0 darwin-x64 node-v12.12.0USAGE  $ plugin-help-example [COMMAND]TOPICS  topic  this is a topic and has child topics or commandsCOMMANDS  hello  describe the command here  help   display help for plugin-help-example
We look forward to seeing what custom help features you implement in your oclif CLIs with this new feature!oclif TSLint to ESLint MigrationDecember 5, 2019 · 3 min readBack in February of this year, plans were announced to deprecate TSLint in favor of ESLint. TSLint's goal has become to work toward a “unified developer experience” by supporting ESLint development going forward.
What has changed in oclif​
To keep inline with the community, oclif has transitioned to ESLint for all our core libraries as well as all our official plugins.
Starting in v1.15.x, oclif will now optionally generate projects with ESLint for both TypeScript and JavaScript CLI’s.
ESLint does require Node to be on stable LTS version, at the time of writing, Node 8.10.x, Node 10.13.x & Node 12.x.x.
How does this affect you​
Existing CLI’s are unchanged, but any newly generated CLI's will only give the option of using ESLint. If you are running tslint in your CLI, we recommend you switch to ESLint as well.
In migrating our projects we took the following steps (for an example of these changes see this pull request).


Install eslint
$ yarn add eslint eslint-config-oclif eslint-config-oclif-typescript --dev


Add eslint related files


$ echo '{  "extends": [    "oclif",    "oclif-typescript"  ],  "rules": {  }}' > .eslintrc


Remove tslint and related packages
$ yarn remove @oclif/tslint tslint


Remove tslint related configuration files
$ rm tslint.json


Change lint script in our package.json from something like:
"lint": "tsc -p test --noEmit && tslint -p test -t stylish"
to
"lint": "eslint . --ext .ts --config .eslintrc"


To preserve the test compile (tsc -p test --noEmit) we also made the following updates to our scripts:
"pretest": "tsc -p test --noEmit"
In some cases we had our posttest duplicating the same steps as our lint script so it’s cleaner to have it reference the lint job directly with:
"posttest": "yarn lint"

Run yarn lint --fix. This attempts to auto-fix any linting violations automatically. In the case an auto-fix isn’t available it should be fixed manually or ignored (see the eslint configuration doc for more information)
Do a search in the codebase for tslint and remove any unnecessary tslint disabling comments, like:

/* tslint:disable:object-literal-sort-keys */
If you are on a version of Node that is not supported by ESLint, you will also need to update your Node engine. ESLint supports Node 8, 10, and 12 so you should upgrade to the most recent Node version compatible with your CLI and also supported by ESLint (see ESLint's Installation and Usage instructions).
When will this take effect​
These changes have taken effect in oclif v1.15.1. When you generate a new CLI or plugin it will now contain configuration for ESLint instead of TSLint.oclif's Current Node SupportOctober 31, 2019 · 3 min readTo maintain a healthy project trajectory, oclif follows and supports Node Active LTS release, currently Node 10 & Node 12. This means ensuring that oclif continues to play nice with coming Active LTS Node versions and other packages in the ecosystem. Moving forward also means leaving older versions behind. Starting in 2020, Node will stop maintaining Node 8 and it is our intent at that time to also follow suit. Let’s take a look at a few ways we will be supporting these changes.
CI Environments​
CLIs created with the oclif cli going forward will be generated with a CircleCI configuration with Node 10 & 12 and an Appveyor configuration using Node 10. We have also added Node latest to CircleCi to be an early warning detection against coming Node changes (Node latest is managed by CircleCI).
We have already updated every oclif repo's CI configs to reflect this.
If your existing CLI uses either Appveyor or CircleCI you can update your config files also, like so:
.circleci/config.yml​
Your CircleCI config should contain a node-latest job, aliased as test. From this, there should be two extensions of this job for the Active LTS Node versions, Node 10 and Node 12.
  node-10:    <<: *node-latest    docker:      - image: node:10  node-12:    <<: *node-latest    docker:      - image: node:12
Notice that these declarations only change the Docker Node images used to run that job.
Additionally, the jobs listed within workflows must also be updated to reflect our changes in configuration:
    jobs:      - node-latest      - node-10      - node-12
appveyor.yml​
For appveyor we are currently only testing the oldest Active LTS Node version, Node 10. Update the nodejs_version proppert in your appveyor.yml file to reflect this.
environment:  nodejs_version: "10"
Deprecating Node 8 & Updating packge.json engines​
In Jan 2020, Node will end its Node 8 maintenance. We will follow suit by setting the package.json engine property in oclif packages to >=10 and bumping the package's major versions.
Depending on how you ship your CLI you may wish to also bump the engines version in your CLI's package.json. You can read more about the implications of the engines property configuration in the npm documentation.
Also consider distributing your CLI with its own Node version.
Packaged Node Version​
When using dev-cli to pack your CLI it will use the Node version as specified in your package.json under the oclif.update.node.version property. This value should reflect an Active LTS Node version (dev-cli does not currently enforce versions).
Supporting the future​
As a community we may discover bumps along the way as we upgrade. If you notice something related to oclif please feel free to open an issue or submit a pull request under the relevant oclif package within the org.
We look forward to using the latest from Node and the community and keeping oclif healthy along the way.oclifconf 2019: A RecapSeptember 16, 2019 · 4 min readIn May, Heroku and Salesforce Open Source organized oclifconf, a conference for developers & product managers building CLI tools on top of the open source oclif framework. The speakers came from various tech companies, such as Adobe, Netlify, and Apollo, who have already built amazing CLI experiences. The topics covered everything from the incredible capabilities oclif has unlocked, to the community-built plugins extending its functionality, and even what the behavior of an adaptive CLI tool might look like.
Below is a listing of all of the talks from the event, along with a short summary. Enjoy!
The future of oclif by Jeff Dickey​

In its relatively short lifetime, oclif has already inspired many developers and companies to adopt its framework as a means for implementing their own command-line tooling. In this talk, Jeff Dickey, an oclif founding team member, recaps the project's history and inspiration. He also looks towards the future and outlines some features and improvements that the tool could adapt. This isn't so much a definitive roadmap of where oclif is headed, but rather, a call to inspiration for developers eager to contribute! And if you are interested in contributing, check out the open issues in the oclif GitHub repo and come say "Hello!" on Spectrum Chat.
Open Source Citizenship by Josh Simmons​

When it comes to open source, it's more than just individuals now. More and more frequently, large corporations are contributing to projects by donating to contributors, sponsoring events, or upstreaming contributions. But keeping open source projects and communities healthy requires more than just money and brainpower. Josh Simmons surveyed multiple open source communities and relays his findings as to what help maintainers and contributors actually need in this talk.
Building an enterprise-grade CLI with oclif by Thomas Dvornik​

Security and performance are all about trust. While oclif is an extremely extensible framework for building CLI tooling, there are additional requirements to fulfill for enterprise businesses to adopt it that might not be necessary for individual developers. Thomas Dvornik outlines what he and his colleagues at Salesforce have implemented as plugins to oclif to satisfy these needs, including encrypted OAuth, plugin signing, lazy loading dependencies, synchronizing weekly releases and deprecations across dozens of repositories, and establishing cross-team coding and documentation standards.
How Adobe I/O built an extensible CLI with oclif by Jesse MacFadyen​

Perhaps oclif's most appealing feature is its support for plugins. In Cordova's case, they've created a sophisticated telemetry system that helps Adobe developers see which commands users are using--and reports on which ones are erroring out. By embedding a feedback system into the tool, users are even able to quickly send their suggestions to a form, without ever leaving the terminal. Jesse MacFadyen demonstrates how oclif's plugin system can work beyond simply executing commands.
Integrating oclif with GraphQL and Apollo by Evans Hauser​

For Evans Hauser and the team at Apollo, oclif is best thought of as "React for the CLI." As a client paired with a strongly-typed API contract to a server, it can deliver structured and consistent commands to retrieve external data. What better mechanism to use for this transfer than GraphQL, a framework which empowers the client to ask precisely for the data it needs, and nothing more?
Adaptive Intent-based CLI State Machines by Shawn Wang​

In designing oclif, Jeff Dickey wrote out 12 CLI factors to keep in mind. In this talk, Shawn Wang outlines a 13th: state. State is hard, because it depends on context, and context depends on understanding what a user intends to do, not what they are asking. Shawn is working towards enabling oclif to better understand the commands a user has entered, so that it can predict and interpret future commands that might be entered next. This would enable CLI tools to not just interpret a users' commands, but to also interpret their intent.Older Entries\n\n\n\nIntroducing `oclif init` commandApril 10, 2024 · 2 min readThanks to the contribution of @joshcanhelp we released a new command for the oclif CLI called oclif init in version 4.8.0
The oclif init command allows you to initialize oclif in an existing project directory by adding the bare minimum requirements: a few pieces of configuration, bin scripts, and a couple of dependencies (@oclif/core and ts-node). This is slightly different from oclif generate, which will create an entirely new oclif project based on our templates.
oclif init will add the following:

bin scripts: bin/run.js, bin/run.cmd, bin/dev.js, and bin/dev.cmd
oclif section to package.json with bin, dirname, commands, and topicSeparator set (See Configuring Your CLI for more)
@oclif/core to dependencies in your package.json (if it's not already there)
ts-node to devDependencies in your package.json (if it's not already there)

Once you've initialized oclif, you can use the bin scripts to execute your CLI. You can also use the other oclif commands like oclif generate command and oclif generate hook to start adding new functionality.

❯ oclif init --helpInitialize a new oclif CLIUSAGE  $ oclif init [--bin <value>] [--module-type ESM|CommonJS] [--package-manager npm|yarn|pnpm] [--topic-separator    colons|spaces] [-d <value>] [-y]FLAGS  -d, --output-dir=<value>        Directory to initialize the CLI in.  -y, --yes                       Use defaults for all prompts. Individual flags will override defaults.      --bin=<value>               Supply answer for prompt: Command bin name the CLI will export      --module-type=<option>      Supply answer for prompt: Select a module type                                  <options: ESM|CommonJS>      --package-manager=<option>  Supply answer for prompt: Select a package manager                                  <options: npm|yarn|pnpm>      --topic-separator=<option>  Supply answer for prompt: Select a topic separator                                  <options: colons|spaces>DESCRIPTION  Initialize a new oclif CLI  This will add the necessary oclif bin files, add oclif config to package.json, and install @oclif/core and ts-node.EXAMPLES  Initialize a new CLI in the current directory    $ oclif init  Initialize a new CLI in a different directory    $ oclif init --output-dir "/path/to/existing/project"  Supply answers for specific prompts    $ oclif init --topic-separator colons --bin mycli
Hope you enjoy the new command! If you come across any issues or have any new ideas for this command, head over to the oclif/oclif repo and open a new issue.
All our best,
The oclif teamoclif Spring 2024 UpdateMarch 29, 2024 · 4 min readHello oclif developers! It's been a while since we last uploaded a blog - and a lot has happened.
We've been focusing on these high-level areas over the past couple of years:

Improving @oclif/core
ESM Support
Improving and revitalizing oclif.io
Re-engaging the oclif community

Improving @oclif/core​
Since we announced @oclif/core over three years ago, we've released two new major versions, each packed with lots of features that we're really excited about.
Here are some of these changes:

Full support for ESM and interoperability with CommonJS (more on this topic below).
Configurable command discovery strategies that give you more control over how commands are loaded at runtime. Check out the docs.
A new preparse hook that allows you to manipulate the provided arguments before they're parsed. Salesforce used this hook to implement a neat --flags-dir feature that translates local files into flags.
A new Performance class that you can use to track performance inside of @oclif/core and your own CLI or plugin. Check out the docs.
A new flag type, Flags.option, that lets you define a flag with a preset list of options. Typescript then uses the options to infer the flag's type.
Flags now have a relationship property that allows you to define more complex relationships between flags. Check out the flags docs for more information.
Flags now have a defaultHelp property that allows you to set the human readable default value in the command help. This property is useful when your flag's parse method returns a complex type, such as an object or a class. Check out the flags docs for more.
Commands now have a hiddenAliases property that allows you to define aliases that you want to hide from the user. The property is super helpful when you're trying to wean users off a deprecated command.
You can now use bun or tsx as dev runtimes (as opposed to node or ts-node).
A command's usage, args, and flags are now shown whenever a user forgets to provide a required arg or flag, or when they provided a non-existent flag.

If you need help migrating to the latest version, head over to core's README which has links to the migration guides. Feel free to open a new discussion if you need more hands-on help from us or the community.
ESM Support​
Version 3 of @oclif/core introduced full support for developing ESM plugins and CLIs. It also offered full support for interoperability between CommonJS and ESM plugins.
Put more simply, you can now migrate your CLI to ESM while keeping individual plugins in CommonJS (or vice versa). The upgrade path is now much simpler for you. You also don't need to worry about any community plugins that have migrated to ESM before you did (such as all the @oclif plugins) or are staunchly sticking with CommonJS for the foreseeable future.
Read more about this topic here.
Improving and Revitalizing oclif.io​
Another area of focus for us has been improving our documentation site, oclif.io.
While improving the quality and accuracy of the documentation was our priority, we also took the time to upgrade to the latest version of docusaurus. This new version gave our site a much-needed facelift, as well as cool new features such as dark mode and announcements.
If you have any feedback or are running into issues, we want to hear about it. Just create an issue in the oclif.io repo.
Re-engaging the oclif Community​
Lastly, our biggest priority at the moment is to re-engage the oclif community. We understand how frustrating it has been over the years to see your issues and pull requests go unacknowledged. We apologize for not prioritizing the community, and are earnestly trying to make sure that every issue and pull request gets the attention it deserves going forward.
We also opened up GitHub discussions for @oclif/core and the oclif CLI, where you can now post your questions or ideas. We hope you take advantage of them, we love hearing from you!
One last thing: we intend to publicly post our roadmap so you have more visibility into what we're working on. Stay tuned!
All our best,
The oclif teamAnnouncing oclif v2!January 12, 2022 · 5 min readHello and happy new year! It's our great pleasure to announce that we have released oclif v2, which uses the new @oclif/core library! 🎉
oclif v2 includes many changes that improve the experience of both creating and using an oclif CLI.
Going forward, we don't plan to make any updates to oclif v1 and its corresponding libraries, except for critical security fixes. See the compatibility matrix for a list of these libraries. In order to give developers time to migrate from v1 to v2, we're not completely dropping support yet. But at some point in the future we'll archive the v1 repositories and deprecate their versions on npm.
What’s changing?​
Repository Changes​
All repositories under the oclif org now use main as their primary branch and oclif-v1 as the legacy branch. The main  branch corresponds to oclif v2 and the oclif-v1 branch to oclif v1. If you find any repos that don’t have a main branch, you can safely assume that they're not used in oclif v2 and will be deprecated in the future.
Consolidating Tools & Libraries​
The oclif-dev CLI has now been incorporated into oclif. You now no longer need to install a separate package to manage your entire CLI’s lifecycle.
The following libraries have been consolidated under @oclif/core and will be deprecated at some point in the future. Read the migration guide to learn how to update your CLI or plugin to use the new core library.

@oclif/command
@oclif/config
@oclif/error
@oclif/help
@oclif/parser

No more single vs multi command CLIs​
There's only one "type" of oclif v2 CLI, but it can have as few or as many commands as a developer wants. As a result, there’s only one command to generate CLIs, oclif generate, as opposed to the old oclif single and oclif multi commands.
Node > 12​
To ensure oclif CLIs are as secure as possible, all v2 libraries and plugins support only Node 12 or higher as of now. Going forward, they'll support only Node Maintenance or higher, as defined by Node's release schedule here: https://nodejs.org/en/about/releases/.
What’s new?​
New example CLI​
oclif-hello-world is our new example repo. This is also the repo that's used as a template when running oclif generate to create a new CLI. This repo will always be able to be referenced as an example of what an oclif v2 CLI should look like.
Spaced commands​
oclif CLIs can now use spaces, instead of colons, to separate topics and subcommands. To enable this feature, simply add “topicSeparator": " " to the oclif config in your package.json. See an example in our example repo.
// Old commands that use :$ mycli do:something
// New spaced commands$ mycli do something

Note: Spaced commands are backwards compatible. So if you enable spaced commands for your CLI, users will still be able to use : as a separator. This ensures that any existing scripts don't break.

New Help Output​
We’ve revamped the way command help is outputted to the terminal, making it both easier to implement and easier to read. See the difference between the old help output on the left and the new help output on the right in the screenshots below.
oclif v1oclif v2
Notice that there are new sections for flags and global flags, examples are displayed with better spacing, and there is a section at the bottom called Configuration Variables. This Configuration Variables section is not part of the new help by default. But we've added support for custom help sections, which is what the sf CLI uses to create the new section.
Async Command Parsing​
We’ve also improved the performance of new CLIs by rewriting how commands are parsed on initialization. The new parser is asynchronous, which makes CLIs with a lot of commands or installed  plugins much faster.
What’s coming next?​
Part of our charter for the release of oclif v2 includes improving our engagement with the oclif community. We know that over the past couple of years we’ve reduced our involvement, and a lot of issues and PRs have languished in limbo. Hopefully you’ve already seen increased activity and responses from oclif maintainers recently, but if you haven’t, please don’t hesitate to ping us by tagging @admins in oclif repos.
We also want to start interviewing members of the oclif community to acquire feedback and prioritize the features and fixes you deem most important!
Best,
The oclif team

Reference material​
Migration Guide​
This guide explains how to upgrade a CLI or plugin from the old oclif v1 libraries to the new @oclif/core library that oclif v2 uses.
https://github.com/oclif/core/blob/main/MIGRATION.md
Compatibility Matrix​
The following matrix shows how the v1 libraries and plugins relate to the new v2 ones. Use this matrix as a guide to know what to drop and which versions to switch when upgrading your plugins and CLIs to v2.
oclif "v1"oclif "v2"Utility CLIsoclif@<2@oclif/dev-cli@<2oclif@>=2Main packages@oclif/command@oclif/config@oclif/errors@oclif/parser@oclif/plugin-help@oclif/core@>=1Node LTSNode v8-14Node v12+ (at time of writing)TypeScripttypescript@<4typescript@>=4Main plugins@oclif/plugin-autocomplete@<1@oclif/plugin-commands@<2@oclif/plugin-help@<4@oclif/plugin-not-found@<2@oclif/plugin-plugins@<2@oclif/plugin-update@<2plugin-warn-if-update-available@<2plugin-which@<2@oclif/plugin-autocomplete@>=1@oclif/plugin-commands@>=2@oclif/plugin-help@>=4@oclif/plugin-not-found@>=2@oclif/plugin-plugins@>=2@oclif/plugin-update@>=2@oclif/plugin-warn-if-update-available@>=2@oclif/plugin-which@>=2Introducing @oclif/coreMarch 1, 2021 · 3 min readGreetings!
We hope this blog post finds you well.
Introducing...​
We are excited to announce the next iteration of the oclif project today: @oclif/core.
We have learned a lot in the last three years of developing oclif, developing on oclif and supporting millions of command runs a day via Heroku and Salesforce CLIs.
@oclif/core ("Core") simplifies the oclif development experience and introduces highly requested new features.
Core combines the essential oclif packages into one "core" package, aptly named @oclif/core.
Core also introduces:

A default command option
Colon or space command syntax
Async command parsing
Command piping to arguments

With the introduction of default command functionality, Core simplifies the oclif project and removes the notion of single or multi command CLIs. Core CLIs can have 1 or many commands.
Along with Core, we moved the oclif-dev CLI into the oclif CLI creating a single "utility" CLI. This CLI also introduces a new AWS S3 compatible publishing scheme.
What to expect in the near future​
Core is in pre-release beta and being actively developed for new internal Salesforce CLIs.
Much documentation needs to be written in the coming months including migration paths. Migration onto Core should be as painless as possible with many exports remaining entirely unchanged. Look for forthcoming blog posts and documentation on oclif.io.
Early this summer, tentively June 1, we will release Core v1. Core's release will coincide with major bumps to many other oclif plugin packages. See the compatibility matrix below.
At Core's v1 release, the current "main" oclif packages (namely: command, config, errors & parser) will go into maintenance mode until Jan 2022. They will receive only bug and security fixes and they remain compatible with current versions of the oclif and oclif-dev CLIs. Afterwhich, they will be archived.
Companioning Core, the next major release of the oclif CLI (literally oclif@2) will generate Core CLIs.
Going forward​
We are excited to release Core! We invite you to poke around the Core repo. It may appear to be a big change but Core keeps what you already enjoy about oclif while reducing development complexity, project dependencies, package coupling and bundle size and introduces many requested features previously too prickly to weave into the current oclif architecture.
Best,
The oclif team
Reference: Compatibility matrix​
oclif "v1"oclif "Core"Utility CLIsoclif@<2@oclif/dev-cli@<2oclif@>=2Main packages@oclif/core@<2@oclif/config@<2@oclif/errors@<2@oclif/parser@<4@oclif/plugin-help@<4@oclif/core@>=1Node LTSNode v8-14Node v12+TypeScripttypescript@<4typescript@>=4Main plugins@oclif/plugin-autocomplete@<1@oclif/plugin-commands@<2@oclif/plugin-help@<4@oclif/plugin-not-found@<2@oclif/plugin-plugins@<2@oclif/plugin-update@<2plugin-warn-if-update-available@<2plugin-which@<2@oclif/plugin-autocomplete@>=2@oclif/plugin-commands@>=2@oclif/plugin-help@>=4@oclif/plugin-not-found@>=2@oclif/plugin-plugins@>=2@oclif/plugin-update@>=2@oclif/plugin-warn-if-update-available@>=2@oclif/plugin-which@>=2oclif Summer 2020 UpdateAugust 26, 2020 · 2 min readHello oclif developers! We hope you are all doing well.
Earlier this year, we started our planning for oclifconf v2 and, like all conference, had to change course. We opted not to hold a virtual conference, however, we wanted to take some time to highlight a few oclif features shipped this year.
Feature: Help templating​
One of the most requested features, help templating enables oclif developers to customize the help output for their CLI.
Read the announcement.
Feature: Custom error delegation​
This feature both improved how oclif throws and handles errors and allows oclif developers to overwrite or interject in oclif’s error handling.
Read the announcement.
Feature: postrun hooks​
We have added a new lifecycle event postrun. Your CLI can now run a hook after a command has ran.
See our hook documentation.
Feature: Root index command​
Previously, oclif would display CLI help if only the binary name with no command ID was invoked, oclif now supports a "root index" command. If present, a command defined at src/commands/index.ts will be run if no command ID is found.
1 million weekly downloads​
While exact oclif usage metrics are hard to pin down, we use npm download statistics of oclif packages as a rough approximation. Earlier this year, oclif's command package hit 1 million weekly downloads for the first time!
This year has been presented its challenges on everyone. We want to thank you, oclif developers, whom have taken the time to use and improve the oclif project. We look forward to seeing you all - in person - in the future!
All our best,
The oclif teamPretty Printable ErrorsJuly 1, 2020 · One min readOften CLIs are used as handy tools and when things go wrong it’s useful to have additional context. In oclif we have added a couple of additional properties that can show extra context to the users when an error is displayed. The code, ref and suggestions will now be displayed if they are included. This will work with an existing oclif CLI by adding the latest @oclif/errors and @oclif/core to the CLI's package.json dependencies.
For example, using this.error with the additional properties:
class TestError extends Command {  async run() {    this.error("An error has occurred!", {      code: "OCLIF_ERR",      ref: "https://oclif.io/docs/commands#thiserrormessage-string--error-options-code-string-exit-number",      suggestions: ["Use these extra properties to provide additional context"],    })  }}
would result with the following output:
›   Error: An error has occurred!›   Code: OCLIF_ERR›   Try this: Use these extra properties to provide additional context›   Reference: https://oclif.io/docs/commands#thiserrormessage-string--error-options-code-string-exit-number
If these properties are not provided then nothing changes and the CLI will continue to display the single error message output as it did before. Additionally, as part of this exercise we’ve added documentation around Error Handling in oclif which should come in handy if the need arises to extend oclif’s default handling of errors.Customizing Help in oclifMay 5, 2020 · 2 min readOut of the box oclif provides a great help experience for CLIs.
But what if, as an oclif developer, you want to customize some or all of the output?
You can now customize your CLI's help output by implementing the HelpBase abstract class.
Getting started with custom help​
If you have not done so yet, update @oclif/core.
$ yarn add --latest @oclif/core
To get started, first define the filepath to your help class in oclif's config in package.json. This is a relative path to the help class, without a file extension.
For this example, the help class will be created in a file at "[project root]/src/help.ts".
{  // ...  "oclif": {    "helpClass": "./lib/help"    // ...  }  // ...}
From here there are two paths, implement the HelpBase abstract class yourself or overwrite the parts of the default Help class you want to customize (ex: how command usage is displayed). We recommend the latter approach but cover both in the new Help Classes docs.
Separating TOPICS & COMMANDS in the new default Help class​
Previously, topics and child commands were listed in help output under a single list heading called "COMMANDS". But we found this can be slightly confusing. Some topics are commands also (a.k.a. topic-commands) while others are simply organizational namespacing (and when ran just show their help).
The new default Help class splits the list of children into distinct lists of "TOPICS" and "COMMANDS", with the possibility of an item appearing in both if it a topic-command. This makes it clearer what is expected to be ran - "COMMANDS" - and what is providing structure - "TOPICS" - when looking at the help output.
VERSION  plugin-help-example/0.0.0 darwin-x64 node-v12.12.0USAGE  $ plugin-help-example [COMMAND]TOPICS  topic  this is a topic and has child topics or commandsCOMMANDS  hello  describe the command here  help   display help for plugin-help-example
We look forward to seeing what custom help features you implement in your oclif CLIs with this new feature!oclif TSLint to ESLint MigrationDecember 5, 2019 · 3 min readBack in February of this year, plans were announced to deprecate TSLint in favor of ESLint. TSLint's goal has become to work toward a “unified developer experience” by supporting ESLint development going forward.
What has changed in oclif​
To keep inline with the community, oclif has transitioned to ESLint for all our core libraries as well as all our official plugins.
Starting in v1.15.x, oclif will now optionally generate projects with ESLint for both TypeScript and JavaScript CLI’s.
ESLint does require Node to be on stable LTS version, at the time of writing, Node 8.10.x, Node 10.13.x & Node 12.x.x.
How does this affect you​
Existing CLI’s are unchanged, but any newly generated CLI's will only give the option of using ESLint. If you are running tslint in your CLI, we recommend you switch to ESLint as well.
In migrating our projects we took the following steps (for an example of these changes see this pull request).


Install eslint
$ yarn add eslint eslint-config-oclif eslint-config-oclif-typescript --dev


Add eslint related files


$ echo '{  "extends": [    "oclif",    "oclif-typescript"  ],  "rules": {  }}' > .eslintrc


Remove tslint and related packages
$ yarn remove @oclif/tslint tslint


Remove tslint related configuration files
$ rm tslint.json


Change lint script in our package.json from something like:
"lint": "tsc -p test --noEmit && tslint -p test -t stylish"
to
"lint": "eslint . --ext .ts --config .eslintrc"


To preserve the test compile (tsc -p test --noEmit) we also made the following updates to our scripts:
"pretest": "tsc -p test --noEmit"
In some cases we had our posttest duplicating the same steps as our lint script so it’s cleaner to have it reference the lint job directly with:
"posttest": "yarn lint"

Run yarn lint --fix. This attempts to auto-fix any linting violations automatically. In the case an auto-fix isn’t available it should be fixed manually or ignored (see the eslint configuration doc for more information)
Do a search in the codebase for tslint and remove any unnecessary tslint disabling comments, like:

/* tslint:disable:object-literal-sort-keys */
If you are on a version of Node that is not supported by ESLint, you will also need to update your Node engine. ESLint supports Node 8, 10, and 12 so you should upgrade to the most recent Node version compatible with your CLI and also supported by ESLint (see ESLint's Installation and Usage instructions).
When will this take effect​
These changes have taken effect in oclif v1.15.1. When you generate a new CLI or plugin it will now contain configuration for ESLint instead of TSLint.oclif's Current Node SupportOctober 31, 2019 · 3 min readTo maintain a healthy project trajectory, oclif follows and supports Node Active LTS release, currently Node 10 & Node 12. This means ensuring that oclif continues to play nice with coming Active LTS Node versions and other packages in the ecosystem. Moving forward also means leaving older versions behind. Starting in 2020, Node will stop maintaining Node 8 and it is our intent at that time to also follow suit. Let’s take a look at a few ways we will be supporting these changes.
CI Environments​
CLIs created with the oclif cli going forward will be generated with a CircleCI configuration with Node 10 & 12 and an Appveyor configuration using Node 10. We have also added Node latest to CircleCi to be an early warning detection against coming Node changes (Node latest is managed by CircleCI).
We have already updated every oclif repo's CI configs to reflect this.
If your existing CLI uses either Appveyor or CircleCI you can update your config files also, like so:
.circleci/config.yml​
Your CircleCI config should contain a node-latest job, aliased as test. From this, there should be two extensions of this job for the Active LTS Node versions, Node 10 and Node 12.
  node-10:    <<: *node-latest    docker:      - image: node:10  node-12:    <<: *node-latest    docker:      - image: node:12
Notice that these declarations only change the Docker Node images used to run that job.
Additionally, the jobs listed within workflows must also be updated to reflect our changes in configuration:
    jobs:      - node-latest      - node-10      - node-12
appveyor.yml​
For appveyor we are currently only testing the oldest Active LTS Node version, Node 10. Update the nodejs_version proppert in your appveyor.yml file to reflect this.
environment:  nodejs_version: "10"
Deprecating Node 8 & Updating packge.json engines​
In Jan 2020, Node will end its Node 8 maintenance. We will follow suit by setting the package.json engine property in oclif packages to >=10 and bumping the package's major versions.
Depending on how you ship your CLI you may wish to also bump the engines version in your CLI's package.json. You can read more about the implications of the engines property configuration in the npm documentation.
Also consider distributing your CLI with its own Node version.
Packaged Node Version​
When using dev-cli to pack your CLI it will use the Node version as specified in your package.json under the oclif.update.node.version property. This value should reflect an Active LTS Node version (dev-cli does not currently enforce versions).
Supporting the future​
As a community we may discover bumps along the way as we upgrade. If you notice something related to oclif please feel free to open an issue or submit a pull request under the relevant oclif package within the org.
We look forward to using the latest from Node and the community and keeping oclif healthy along the way.oclifconf 2019: A RecapSeptember 16, 2019 · 4 min readIn May, Heroku and Salesforce Open Source organized oclifconf, a conference for developers & product managers building CLI tools on top of the open source oclif framework. The speakers came from various tech companies, such as Adobe, Netlify, and Apollo, who have already built amazing CLI experiences. The topics covered everything from the incredible capabilities oclif has unlocked, to the community-built plugins extending its functionality, and even what the behavior of an adaptive CLI tool might look like.
Below is a listing of all of the talks from the event, along with a short summary. Enjoy!
The future of oclif by Jeff Dickey​

In its relatively short lifetime, oclif has already inspired many developers and companies to adopt its framework as a means for implementing their own command-line tooling. In this talk, Jeff Dickey, an oclif founding team member, recaps the project's history and inspiration. He also looks towards the future and outlines some features and improvements that the tool could adapt. This isn't so much a definitive roadmap of where oclif is headed, but rather, a call to inspiration for developers eager to contribute! And if you are interested in contributing, check out the open issues in the oclif GitHub repo and come say "Hello!" on Spectrum Chat.
Open Source Citizenship by Josh Simmons​

When it comes to open source, it's more than just individuals now. More and more frequently, large corporations are contributing to projects by donating to contributors, sponsoring events, or upstreaming contributions. But keeping open source projects and communities healthy requires more than just money and brainpower. Josh Simmons surveyed multiple open source communities and relays his findings as to what help maintainers and contributors actually need in this talk.
Building an enterprise-grade CLI with oclif by Thomas Dvornik​

Security and performance are all about trust. While oclif is an extremely extensible framework for building CLI tooling, there are additional requirements to fulfill for enterprise businesses to adopt it that might not be necessary for individual developers. Thomas Dvornik outlines what he and his colleagues at Salesforce have implemented as plugins to oclif to satisfy these needs, including encrypted OAuth, plugin signing, lazy loading dependencies, synchronizing weekly releases and deprecations across dozens of repositories, and establishing cross-team coding and documentation standards.
How Adobe I/O built an extensible CLI with oclif by Jesse MacFadyen​

Perhaps oclif's most appealing feature is its support for plugins. In Cordova's case, they've created a sophisticated telemetry system that helps Adobe developers see which commands users are using--and reports on which ones are erroring out. By embedding a feedback system into the tool, users are even able to quickly send their suggestions to a form, without ever leaving the terminal. Jesse MacFadyen demonstrates how oclif's plugin system can work beyond simply executing commands.
Integrating oclif with GraphQL and Apollo by Evans Hauser​

For Evans Hauser and the team at Apollo, oclif is best thought of as "React for the CLI." As a client paired with a strongly-typed API contract to a server, it can deliver structured and consistent commands to retrieve external data. What better mechanism to use for this transfer than GraphQL, a framework which empowers the client to ask precisely for the data it needs, and nothing more?
Adaptive Intent-based CLI State Machines by Shawn Wang​

In designing oclif, Jeff Dickey wrote out 12 CLI factors to keep in mind. In this talk, Shawn Wang outlines a 13th: state. State is hard, because it depends on context, and context depends on understanding what a user intends to do, not what they are asking. Shawn is working towards enabling oclif to better understand the commands a user has entered, so that it can predict and interpret future commands that might be entered next. This would enable CLI tools to not just interpret a users' commands, but to also interpret their intent.\n\nIntroducing `oclif init` commandApril 10, 2024 · 2 min readThanks to the contribution of @joshcanhelp we released a new command for the oclif CLI called oclif init in version 4.8.0
The oclif init command allows you to initialize oclif in an existing project directory by adding the bare minimum requirements: a few pieces of configuration, bin scripts, and a couple of dependencies (@oclif/core and ts-node). This is slightly different from oclif generate, which will create an entirely new oclif project based on our templates.
oclif init will add the following:

bin scripts: bin/run.js, bin/run.cmd, bin/dev.js, and bin/dev.cmd
oclif section to package.json with bin, dirname, commands, and topicSeparator set (See Configuring Your CLI for more)
@oclif/core to dependencies in your package.json (if it's not already there)
ts-node to devDependencies in your package.json (if it's not already there)

Once you've initialized oclif, you can use the bin scripts to execute your CLI. You can also use the other oclif commands like oclif generate command and oclif generate hook to start adding new functionality.

❯ oclif init --helpInitialize a new oclif CLIUSAGE  $ oclif init [--bin <value>] [--module-type ESM|CommonJS] [--package-manager npm|yarn|pnpm] [--topic-separator    colons|spaces] [-d <value>] [-y]FLAGS  -d, --output-dir=<value>        Directory to initialize the CLI in.  -y, --yes                       Use defaults for all prompts. Individual flags will override defaults.      --bin=<value>               Supply answer for prompt: Command bin name the CLI will export      --module-type=<option>      Supply answer for prompt: Select a module type                                  <options: ESM|CommonJS>      --package-manager=<option>  Supply answer for prompt: Select a package manager                                  <options: npm|yarn|pnpm>      --topic-separator=<option>  Supply answer for prompt: Select a topic separator                                  <options: colons|spaces>DESCRIPTION  Initialize a new oclif CLI  This will add the necessary oclif bin files, add oclif config to package.json, and install @oclif/core and ts-node.EXAMPLES  Initialize a new CLI in the current directory    $ oclif init  Initialize a new CLI in a different directory    $ oclif init --output-dir "/path/to/existing/project"  Supply answers for specific prompts    $ oclif init --topic-separator colons --bin mycli
Hope you enjoy the new command! If you come across any issues or have any new ideas for this command, head over to the oclif/oclif repo and open a new issue.
All our best,
The oclif teamoclif Spring 2024 UpdateMarch 29, 2024 · 4 min readHello oclif developers! It's been a while since we last uploaded a blog - and a lot has happened.
We've been focusing on these high-level areas over the past couple of years:

Improving @oclif/core
ESM Support
Improving and revitalizing oclif.io
Re-engaging the oclif community

Improving @oclif/core​
Since we announced @oclif/core over three years ago, we've released two new major versions, each packed with lots of features that we're really excited about.
Here are some of these changes:

Full support for ESM and interoperability with CommonJS (more on this topic below).
Configurable command discovery strategies that give you more control over how commands are loaded at runtime. Check out the docs.
A new preparse hook that allows you to manipulate the provided arguments before they're parsed. Salesforce used this hook to implement a neat --flags-dir feature that translates local files into flags.
A new Performance class that you can use to track performance inside of @oclif/core and your own CLI or plugin. Check out the docs.
A new flag type, Flags.option, that lets you define a flag with a preset list of options. Typescript then uses the options to infer the flag's type.
Flags now have a relationship property that allows you to define more complex relationships between flags. Check out the flags docs for more information.
Flags now have a defaultHelp property that allows you to set the human readable default value in the command help. This property is useful when your flag's parse method returns a complex type, such as an object or a class. Check out the flags docs for more.
Commands now have a hiddenAliases property that allows you to define aliases that you want to hide from the user. The property is super helpful when you're trying to wean users off a deprecated command.
You can now use bun or tsx as dev runtimes (as opposed to node or ts-node).
A command's usage, args, and flags are now shown whenever a user forgets to provide a required arg or flag, or when they provided a non-existent flag.

If you need help migrating to the latest version, head over to core's README which has links to the migration guides. Feel free to open a new discussion if you need more hands-on help from us or the community.
ESM Support​
Version 3 of @oclif/core introduced full support for developing ESM plugins and CLIs. It also offered full support for interoperability between CommonJS and ESM plugins.
Put more simply, you can now migrate your CLI to ESM while keeping individual plugins in CommonJS (or vice versa). The upgrade path is now much simpler for you. You also don't need to worry about any community plugins that have migrated to ESM before you did (such as all the @oclif plugins) or are staunchly sticking with CommonJS for the foreseeable future.
Read more about this topic here.
Improving and Revitalizing oclif.io​
Another area of focus for us has been improving our documentation site, oclif.io.
While improving the quality and accuracy of the documentation was our priority, we also took the time to upgrade to the latest version of docusaurus. This new version gave our site a much-needed facelift, as well as cool new features such as dark mode and announcements.
If you have any feedback or are running into issues, we want to hear about it. Just create an issue in the oclif.io repo.
Re-engaging the oclif Community​
Lastly, our biggest priority at the moment is to re-engage the oclif community. We understand how frustrating it has been over the years to see your issues and pull requests go unacknowledged. We apologize for not prioritizing the community, and are earnestly trying to make sure that every issue and pull request gets the attention it deserves going forward.
We also opened up GitHub discussions for @oclif/core and the oclif CLI, where you can now post your questions or ideas. We hope you take advantage of them, we love hearing from you!
One last thing: we intend to publicly post our roadmap so you have more visibility into what we're working on. Stay tuned!
All our best,
The oclif teamAnnouncing oclif v2!January 12, 2022 · 5 min readHello and happy new year! It's our great pleasure to announce that we have released oclif v2, which uses the new @oclif/core library! 🎉
oclif v2 includes many changes that improve the experience of both creating and using an oclif CLI.
Going forward, we don't plan to make any updates to oclif v1 and its corresponding libraries, except for critical security fixes. See the compatibility matrix for a list of these libraries. In order to give developers time to migrate from v1 to v2, we're not completely dropping support yet. But at some point in the future we'll archive the v1 repositories and deprecate their versions on npm.
What’s changing?​
Repository Changes​
All repositories under the oclif org now use main as their primary branch and oclif-v1 as the legacy branch. The main  branch corresponds to oclif v2 and the oclif-v1 branch to oclif v1. If you find any repos that don’t have a main branch, you can safely assume that they're not used in oclif v2 and will be deprecated in the future.
Consolidating Tools & Libraries​
The oclif-dev CLI has now been incorporated into oclif. You now no longer need to install a separate package to manage your entire CLI’s lifecycle.
The following libraries have been consolidated under @oclif/core and will be deprecated at some point in the future. Read the migration guide to learn how to update your CLI or plugin to use the new core library.

@oclif/command
@oclif/config
@oclif/error
@oclif/help
@oclif/parser

No more single vs multi command CLIs​
There's only one "type" of oclif v2 CLI, but it can have as few or as many commands as a developer wants. As a result, there’s only one command to generate CLIs, oclif generate, as opposed to the old oclif single and oclif multi commands.
Node > 12​
To ensure oclif CLIs are as secure as possible, all v2 libraries and plugins support only Node 12 or higher as of now. Going forward, they'll support only Node Maintenance or higher, as defined by Node's release schedule here: https://nodejs.org/en/about/releases/.
What’s new?​
New example CLI​
oclif-hello-world is our new example repo. This is also the repo that's used as a template when running oclif generate to create a new CLI. This repo will always be able to be referenced as an example of what an oclif v2 CLI should look like.
Spaced commands​
oclif CLIs can now use spaces, instead of colons, to separate topics and subcommands. To enable this feature, simply add “topicSeparator": " " to the oclif config in your package.json. See an example in our example repo.
// Old commands that use :$ mycli do:something
// New spaced commands$ mycli do something

Note: Spaced commands are backwards compatible. So if you enable spaced commands for your CLI, users will still be able to use : as a separator. This ensures that any existing scripts don't break.

New Help Output​
We’ve revamped the way command help is outputted to the terminal, making it both easier to implement and easier to read. See the difference between the old help output on the left and the new help output on the right in the screenshots below.
oclif v1oclif v2
Notice that there are new sections for flags and global flags, examples are displayed with better spacing, and there is a section at the bottom called Configuration Variables. This Configuration Variables section is not part of the new help by default. But we've added support for custom help sections, which is what the sf CLI uses to create the new section.
Async Command Parsing​
We’ve also improved the performance of new CLIs by rewriting how commands are parsed on initialization. The new parser is asynchronous, which makes CLIs with a lot of commands or installed  plugins much faster.
What’s coming next?​
Part of our charter for the release of oclif v2 includes improving our engagement with the oclif community. We know that over the past couple of years we’ve reduced our involvement, and a lot of issues and PRs have languished in limbo. Hopefully you’ve already seen increased activity and responses from oclif maintainers recently, but if you haven’t, please don’t hesitate to ping us by tagging @admins in oclif repos.
We also want to start interviewing members of the oclif community to acquire feedback and prioritize the features and fixes you deem most important!
Best,
The oclif team

Reference material​
Migration Guide​
This guide explains how to upgrade a CLI or plugin from the old oclif v1 libraries to the new @oclif/core library that oclif v2 uses.
https://github.com/oclif/core/blob/main/MIGRATION.md
Compatibility Matrix​
The following matrix shows how the v1 libraries and plugins relate to the new v2 ones. Use this matrix as a guide to know what to drop and which versions to switch when upgrading your plugins and CLIs to v2.
oclif "v1"oclif "v2"Utility CLIsoclif@<2@oclif/dev-cli@<2oclif@>=2Main packages@oclif/command@oclif/config@oclif/errors@oclif/parser@oclif/plugin-help@oclif/core@>=1Node LTSNode v8-14Node v12+ (at time of writing)TypeScripttypescript@<4typescript@>=4Main plugins@oclif/plugin-autocomplete@<1@oclif/plugin-commands@<2@oclif/plugin-help@<4@oclif/plugin-not-found@<2@oclif/plugin-plugins@<2@oclif/plugin-update@<2plugin-warn-if-update-available@<2plugin-which@<2@oclif/plugin-autocomplete@>=1@oclif/plugin-commands@>=2@oclif/plugin-help@>=4@oclif/plugin-not-found@>=2@oclif/plugin-plugins@>=2@oclif/plugin-update@>=2@oclif/plugin-warn-if-update-available@>=2@oclif/plugin-which@>=2Introducing @oclif/coreMarch 1, 2021 · 3 min readGreetings!
We hope this blog post finds you well.
Introducing...​
We are excited to announce the next iteration of the oclif project today: @oclif/core.
We have learned a lot in the last three years of developing oclif, developing on oclif and supporting millions of command runs a day via Heroku and Salesforce CLIs.
@oclif/core ("Core") simplifies the oclif development experience and introduces highly requested new features.
Core combines the essential oclif packages into one "core" package, aptly named @oclif/core.
Core also introduces:

A default command option
Colon or space command syntax
Async command parsing
Command piping to arguments

With the introduction of default command functionality, Core simplifies the oclif project and removes the notion of single or multi command CLIs. Core CLIs can have 1 or many commands.
Along with Core, we moved the oclif-dev CLI into the oclif CLI creating a single "utility" CLI. This CLI also introduces a new AWS S3 compatible publishing scheme.
What to expect in the near future​
Core is in pre-release beta and being actively developed for new internal Salesforce CLIs.
Much documentation needs to be written in the coming months including migration paths. Migration onto Core should be as painless as possible with many exports remaining entirely unchanged. Look for forthcoming blog posts and documentation on oclif.io.
Early this summer, tentively June 1, we will release Core v1. Core's release will coincide with major bumps to many other oclif plugin packages. See the compatibility matrix below.
At Core's v1 release, the current "main" oclif packages (namely: command, config, errors & parser) will go into maintenance mode until Jan 2022. They will receive only bug and security fixes and they remain compatible with current versions of the oclif and oclif-dev CLIs. Afterwhich, they will be archived.
Companioning Core, the next major release of the oclif CLI (literally oclif@2) will generate Core CLIs.
Going forward​
We are excited to release Core! We invite you to poke around the Core repo. It may appear to be a big change but Core keeps what you already enjoy about oclif while reducing development complexity, project dependencies, package coupling and bundle size and introduces many requested features previously too prickly to weave into the current oclif architecture.
Best,
The oclif team
Reference: Compatibility matrix​
oclif "v1"oclif "Core"Utility CLIsoclif@<2@oclif/dev-cli@<2oclif@>=2Main packages@oclif/core@<2@oclif/config@<2@oclif/errors@<2@oclif/parser@<4@oclif/plugin-help@<4@oclif/core@>=1Node LTSNode v8-14Node v12+TypeScripttypescript@<4typescript@>=4Main plugins@oclif/plugin-autocomplete@<1@oclif/plugin-commands@<2@oclif/plugin-help@<4@oclif/plugin-not-found@<2@oclif/plugin-plugins@<2@oclif/plugin-update@<2plugin-warn-if-update-available@<2plugin-which@<2@oclif/plugin-autocomplete@>=2@oclif/plugin-commands@>=2@oclif/plugin-help@>=4@oclif/plugin-not-found@>=2@oclif/plugin-plugins@>=2@oclif/plugin-update@>=2@oclif/plugin-warn-if-update-available@>=2@oclif/plugin-which@>=2oclif Summer 2020 UpdateAugust 26, 2020 · 2 min readHello oclif developers! We hope you are all doing well.
Earlier this year, we started our planning for oclifconf v2 and, like all conference, had to change course. We opted not to hold a virtual conference, however, we wanted to take some time to highlight a few oclif features shipped this year.
Feature: Help templating​
One of the most requested features, help templating enables oclif developers to customize the help output for their CLI.
Read the announcement.
Feature: Custom error delegation​
This feature both improved how oclif throws and handles errors and allows oclif developers to overwrite or interject in oclif’s error handling.
Read the announcement.
Feature: postrun hooks​
We have added a new lifecycle event postrun. Your CLI can now run a hook after a command has ran.
See our hook documentation.
Feature: Root index command​
Previously, oclif would display CLI help if only the binary name with no command ID was invoked, oclif now supports a "root index" command. If present, a command defined at src/commands/index.ts will be run if no command ID is found.
1 million weekly downloads​
While exact oclif usage metrics are hard to pin down, we use npm download statistics of oclif packages as a rough approximation. Earlier this year, oclif's command package hit 1 million weekly downloads for the first time!
This year has been presented its challenges on everyone. We want to thank you, oclif developers, whom have taken the time to use and improve the oclif project. We look forward to seeing you all - in person - in the future!
All our best,
The oclif teamPretty Printable ErrorsJuly 1, 2020 · One min readOften CLIs are used as handy tools and when things go wrong it’s useful to have additional context. In oclif we have added a couple of additional properties that can show extra context to the users when an error is displayed. The code, ref and suggestions will now be displayed if they are included. This will work with an existing oclif CLI by adding the latest @oclif/errors and @oclif/core to the CLI's package.json dependencies.
For example, using this.error with the additional properties:
class TestError extends Command {  async run() {    this.error("An error has occurred!", {      code: "OCLIF_ERR",      ref: "https://oclif.io/docs/commands#thiserrormessage-string--error-options-code-string-exit-number",      suggestions: ["Use these extra properties to provide additional context"],    })  }}
would result with the following output:
›   Error: An error has occurred!›   Code: OCLIF_ERR›   Try this: Use these extra properties to provide additional context›   Reference: https://oclif.io/docs/commands#thiserrormessage-string--error-options-code-string-exit-number
If these properties are not provided then nothing changes and the CLI will continue to display the single error message output as it did before. Additionally, as part of this exercise we’ve added documentation around Error Handling in oclif which should come in handy if the need arises to extend oclif’s default handling of errors.Customizing Help in oclifMay 5, 2020 · 2 min readOut of the box oclif provides a great help experience for CLIs.
But what if, as an oclif developer, you want to customize some or all of the output?
You can now customize your CLI's help output by implementing the HelpBase abstract class.
Getting started with custom help​
If you have not done so yet, update @oclif/core.
$ yarn add --latest @oclif/core
To get started, first define the filepath to your help class in oclif's config in package.json. This is a relative path to the help class, without a file extension.
For this example, the help class will be created in a file at "[project root]/src/help.ts".
{  // ...  "oclif": {    "helpClass": "./lib/help"    // ...  }  // ...}
From here there are two paths, implement the HelpBase abstract class yourself or overwrite the parts of the default Help class you want to customize (ex: how command usage is displayed). We recommend the latter approach but cover both in the new Help Classes docs.
Separating TOPICS & COMMANDS in the new default Help class​
Previously, topics and child commands were listed in help output under a single list heading called "COMMANDS". But we found this can be slightly confusing. Some topics are commands also (a.k.a. topic-commands) while others are simply organizational namespacing (and when ran just show their help).
The new default Help class splits the list of children into distinct lists of "TOPICS" and "COMMANDS", with the possibility of an item appearing in both if it a topic-command. This makes it clearer what is expected to be ran - "COMMANDS" - and what is providing structure - "TOPICS" - when looking at the help output.
VERSION  plugin-help-example/0.0.0 darwin-x64 node-v12.12.0USAGE  $ plugin-help-example [COMMAND]TOPICS  topic  this is a topic and has child topics or commandsCOMMANDS  hello  describe the command here  help   display help for plugin-help-example
We look forward to seeing what custom help features you implement in your oclif CLIs with this new feature!oclif TSLint to ESLint MigrationDecember 5, 2019 · 3 min readBack in February of this year, plans were announced to deprecate TSLint in favor of ESLint. TSLint's goal has become to work toward a “unified developer experience” by supporting ESLint development going forward.
What has changed in oclif​
To keep inline with the community, oclif has transitioned to ESLint for all our core libraries as well as all our official plugins.
Starting in v1.15.x, oclif will now optionally generate projects with ESLint for both TypeScript and JavaScript CLI’s.
ESLint does require Node to be on stable LTS version, at the time of writing, Node 8.10.x, Node 10.13.x & Node 12.x.x.
How does this affect you​
Existing CLI’s are unchanged, but any newly generated CLI's will only give the option of using ESLint. If you are running tslint in your CLI, we recommend you switch to ESLint as well.
In migrating our projects we took the following steps (for an example of these changes see this pull request).


Install eslint
$ yarn add eslint eslint-config-oclif eslint-config-oclif-typescript --dev


Add eslint related files


$ echo '{  "extends": [    "oclif",    "oclif-typescript"  ],  "rules": {  }}' > .eslintrc


Remove tslint and related packages
$ yarn remove @oclif/tslint tslint


Remove tslint related configuration files
$ rm tslint.json


Change lint script in our package.json from something like:
"lint": "tsc -p test --noEmit && tslint -p test -t stylish"
to
"lint": "eslint . --ext .ts --config .eslintrc"


To preserve the test compile (tsc -p test --noEmit) we also made the following updates to our scripts:
"pretest": "tsc -p test --noEmit"
In some cases we had our posttest duplicating the same steps as our lint script so it’s cleaner to have it reference the lint job directly with:
"posttest": "yarn lint"

Run yarn lint --fix. This attempts to auto-fix any linting violations automatically. In the case an auto-fix isn’t available it should be fixed manually or ignored (see the eslint configuration doc for more information)
Do a search in the codebase for tslint and remove any unnecessary tslint disabling comments, like:

/* tslint:disable:object-literal-sort-keys */
If you are on a version of Node that is not supported by ESLint, you will also need to update your Node engine. ESLint supports Node 8, 10, and 12 so you should upgrade to the most recent Node version compatible with your CLI and also supported by ESLint (see ESLint's Installation and Usage instructions).
When will this take effect​
These changes have taken effect in oclif v1.15.1. When you generate a new CLI or plugin it will now contain configuration for ESLint instead of TSLint.oclif's Current Node SupportOctober 31, 2019 · 3 min readTo maintain a healthy project trajectory, oclif follows and supports Node Active LTS release, currently Node 10 & Node 12. This means ensuring that oclif continues to play nice with coming Active LTS Node versions and other packages in the ecosystem. Moving forward also means leaving older versions behind. Starting in 2020, Node will stop maintaining Node 8 and it is our intent at that time to also follow suit. Let’s take a look at a few ways we will be supporting these changes.
CI Environments​
CLIs created with the oclif cli going forward will be generated with a CircleCI configuration with Node 10 & 12 and an Appveyor configuration using Node 10. We have also added Node latest to CircleCi to be an early warning detection against coming Node changes (Node latest is managed by CircleCI).
We have already updated every oclif repo's CI configs to reflect this.
If your existing CLI uses either Appveyor or CircleCI you can update your config files also, like so:
.circleci/config.yml​
Your CircleCI config should contain a node-latest job, aliased as test. From this, there should be two extensions of this job for the Active LTS Node versions, Node 10 and Node 12.
  node-10:    <<: *node-latest    docker:      - image: node:10  node-12:    <<: *node-latest    docker:      - image: node:12
Notice that these declarations only change the Docker Node images used to run that job.
Additionally, the jobs listed within workflows must also be updated to reflect our changes in configuration:
    jobs:      - node-latest      - node-10      - node-12
appveyor.yml​
For appveyor we are currently only testing the oldest Active LTS Node version, Node 10. Update the nodejs_version proppert in your appveyor.yml file to reflect this.
environment:  nodejs_version: "10"
Deprecating Node 8 & Updating packge.json engines​
In Jan 2020, Node will end its Node 8 maintenance. We will follow suit by setting the package.json engine property in oclif packages to >=10 and bumping the package's major versions.
Depending on how you ship your CLI you may wish to also bump the engines version in your CLI's package.json. You can read more about the implications of the engines property configuration in the npm documentation.
Also consider distributing your CLI with its own Node version.
Packaged Node Version​
When using dev-cli to pack your CLI it will use the Node version as specified in your package.json under the oclif.update.node.version property. This value should reflect an Active LTS Node version (dev-cli does not currently enforce versions).
Supporting the future​
As a community we may discover bumps along the way as we upgrade. If you notice something related to oclif please feel free to open an issue or submit a pull request under the relevant oclif package within the org.
We look forward to using the latest from Node and the community and keeping oclif healthy along the way.oclifconf 2019: A RecapSeptember 16, 2019 · 4 min readIn May, Heroku and Salesforce Open Source organized oclifconf, a conference for developers & product managers building CLI tools on top of the open source oclif framework. The speakers came from various tech companies, such as Adobe, Netlify, and Apollo, who have already built amazing CLI experiences. The topics covered everything from the incredible capabilities oclif has unlocked, to the community-built plugins extending its functionality, and even what the behavior of an adaptive CLI tool might look like.
Below is a listing of all of the talks from the event, along with a short summary. Enjoy!
The future of oclif by Jeff Dickey​

In its relatively short lifetime, oclif has already inspired many developers and companies to adopt its framework as a means for implementing their own command-line tooling. In this talk, Jeff Dickey, an oclif founding team member, recaps the project's history and inspiration. He also looks towards the future and outlines some features and improvements that the tool could adapt. This isn't so much a definitive roadmap of where oclif is headed, but rather, a call to inspiration for developers eager to contribute! And if you are interested in contributing, check out the open issues in the oclif GitHub repo and come say "Hello!" on Spectrum Chat.
Open Source Citizenship by Josh Simmons​

When it comes to open source, it's more than just individuals now. More and more frequently, large corporations are contributing to projects by donating to contributors, sponsoring events, or upstreaming contributions. But keeping open source projects and communities healthy requires more than just money and brainpower. Josh Simmons surveyed multiple open source communities and relays his findings as to what help maintainers and contributors actually need in this talk.
Building an enterprise-grade CLI with oclif by Thomas Dvornik​

Security and performance are all about trust. While oclif is an extremely extensible framework for building CLI tooling, there are additional requirements to fulfill for enterprise businesses to adopt it that might not be necessary for individual developers. Thomas Dvornik outlines what he and his colleagues at Salesforce have implemented as plugins to oclif to satisfy these needs, including encrypted OAuth, plugin signing, lazy loading dependencies, synchronizing weekly releases and deprecations across dozens of repositories, and establishing cross-team coding and documentation standards.
How Adobe I/O built an extensible CLI with oclif by Jesse MacFadyen​

Perhaps oclif's most appealing feature is its support for plugins. In Cordova's case, they've created a sophisticated telemetry system that helps Adobe developers see which commands users are using--and reports on which ones are erroring out. By embedding a feedback system into the tool, users are even able to quickly send their suggestions to a form, without ever leaving the terminal. Jesse MacFadyen demonstrates how oclif's plugin system can work beyond simply executing commands.
Integrating oclif with GraphQL and Apollo by Evans Hauser​

For Evans Hauser and the team at Apollo, oclif is best thought of as "React for the CLI." As a client paired with a strongly-typed API contract to a server, it can deliver structured and consistent commands to retrieve external data. What better mechanism to use for this transfer than GraphQL, a framework which empowers the client to ask precisely for the data it needs, and nothing more?
Adaptive Intent-based CLI State Machines by Shawn Wang​

In designing oclif, Jeff Dickey wrote out 12 CLI factors to keep in mind. In this talk, Shawn Wang outlines a 13th: state. State is hard, because it depends on context, and context depends on understanding what a user intends to do, not what they are asking. Shawn is working towards enabling oclif to better understand the commands a user has entered, so that it can predict and interpret future commands that might be entered next. This would enable CLI tools to not just interpret a users' commands, but to also interpret their intent.Older Entries\n\n\n\nIntroducing `oclif init` commandApril 10, 2024 · 2 min readThanks to the contribution of @joshcanhelp we released a new command for the oclif CLI called oclif init in version 4.8.0
The oclif init command allows you to initialize oclif in an existing project directory by adding the bare minimum requirements: a few pieces of configuration, bin scripts, and a couple of dependencies (@oclif/core and ts-node). This is slightly different from oclif generate, which will create an entirely new oclif project based on our templates.
oclif init will add the following:

bin scripts: bin/run.js, bin/run.cmd, bin/dev.js, and bin/dev.cmd
oclif section to package.json with bin, dirname, commands, and topicSeparator set (See Configuring Your CLI for more)
@oclif/core to dependencies in your package.json (if it's not already there)
ts-node to devDependencies in your package.json (if it's not already there)

Once you've initialized oclif, you can use the bin scripts to execute your CLI. You can also use the other oclif commands like oclif generate command and oclif generate hook to start adding new functionality.

❯ oclif init --helpInitialize a new oclif CLIUSAGE  $ oclif init [--bin <value>] [--module-type ESM|CommonJS] [--package-manager npm|yarn|pnpm] [--topic-separator    colons|spaces] [-d <value>] [-y]FLAGS  -d, --output-dir=<value>        Directory to initialize the CLI in.  -y, --yes                       Use defaults for all prompts. Individual flags will override defaults.      --bin=<value>               Supply answer for prompt: Command bin name the CLI will export      --module-type=<option>      Supply answer for prompt: Select a module type                                  <options: ESM|CommonJS>      --package-manager=<option>  Supply answer for prompt: Select a package manager                                  <options: npm|yarn|pnpm>      --topic-separator=<option>  Supply answer for prompt: Select a topic separator                                  <options: colons|spaces>DESCRIPTION  Initialize a new oclif CLI  This will add the necessary oclif bin files, add oclif config to package.json, and install @oclif/core and ts-node.EXAMPLES  Initialize a new CLI in the current directory    $ oclif init  Initialize a new CLI in a different directory    $ oclif init --output-dir "/path/to/existing/project"  Supply answers for specific prompts    $ oclif init --topic-separator colons --bin mycli
Hope you enjoy the new command! If you come across any issues or have any new ideas for this command, head over to the oclif/oclif repo and open a new issue.
All our best,
The oclif teamoclif Spring 2024 UpdateMarch 29, 2024 · 4 min readHello oclif developers! It's been a while since we last uploaded a blog - and a lot has happened.
We've been focusing on these high-level areas over the past couple of years:

Improving @oclif/core
ESM Support
Improving and revitalizing oclif.io
Re-engaging the oclif community

Improving @oclif/core​
Since we announced @oclif/core over three years ago, we've released two new major versions, each packed with lots of features that we're really excited about.
Here are some of these changes:

Full support for ESM and interoperability with CommonJS (more on this topic below).
Configurable command discovery strategies that give you more control over how commands are loaded at runtime. Check out the docs.
A new preparse hook that allows you to manipulate the provided arguments before they're parsed. Salesforce used this hook to implement a neat --flags-dir feature that translates local files into flags.
A new Performance class that you can use to track performance inside of @oclif/core and your own CLI or plugin. Check out the docs.
A new flag type, Flags.option, that lets you define a flag with a preset list of options. Typescript then uses the options to infer the flag's type.
Flags now have a relationship property that allows you to define more complex relationships between flags. Check out the flags docs for more information.
Flags now have a defaultHelp property that allows you to set the human readable default value in the command help. This property is useful when your flag's parse method returns a complex type, such as an object or a class. Check out the flags docs for more.
Commands now have a hiddenAliases property that allows you to define aliases that you want to hide from the user. The property is super helpful when you're trying to wean users off a deprecated command.
You can now use bun or tsx as dev runtimes (as opposed to node or ts-node).
A command's usage, args, and flags are now shown whenever a user forgets to provide a required arg or flag, or when they provided a non-existent flag.

If you need help migrating to the latest version, head over to core's README which has links to the migration guides. Feel free to open a new discussion if you need more hands-on help from us or the community.
ESM Support​
Version 3 of @oclif/core introduced full support for developing ESM plugins and CLIs. It also offered full support for interoperability between CommonJS and ESM plugins.
Put more simply, you can now migrate your CLI to ESM while keeping individual plugins in CommonJS (or vice versa). The upgrade path is now much simpler for you. You also don't need to worry about any community plugins that have migrated to ESM before you did (such as all the @oclif plugins) or are staunchly sticking with CommonJS for the foreseeable future.
Read more about this topic here.
Improving and Revitalizing oclif.io​
Another area of focus for us has been improving our documentation site, oclif.io.
While improving the quality and accuracy of the documentation was our priority, we also took the time to upgrade to the latest version of docusaurus. This new version gave our site a much-needed facelift, as well as cool new features such as dark mode and announcements.
If you have any feedback or are running into issues, we want to hear about it. Just create an issue in the oclif.io repo.
Re-engaging the oclif Community​
Lastly, our biggest priority at the moment is to re-engage the oclif community. We understand how frustrating it has been over the years to see your issues and pull requests go unacknowledged. We apologize for not prioritizing the community, and are earnestly trying to make sure that every issue and pull request gets the attention it deserves going forward.
We also opened up GitHub discussions for @oclif/core and the oclif CLI, where you can now post your questions or ideas. We hope you take advantage of them, we love hearing from you!
One last thing: we intend to publicly post our roadmap so you have more visibility into what we're working on. Stay tuned!
All our best,
The oclif teamAnnouncing oclif v2!January 12, 2022 · 5 min readHello and happy new year! It's our great pleasure to announce that we have released oclif v2, which uses the new @oclif/core library! 🎉
oclif v2 includes many changes that improve the experience of both creating and using an oclif CLI.
Going forward, we don't plan to make any updates to oclif v1 and its corresponding libraries, except for critical security fixes. See the compatibility matrix for a list of these libraries. In order to give developers time to migrate from v1 to v2, we're not completely dropping support yet. But at some point in the future we'll archive the v1 repositories and deprecate their versions on npm.
What’s changing?​
Repository Changes​
All repositories under the oclif org now use main as their primary branch and oclif-v1 as the legacy branch. The main  branch corresponds to oclif v2 and the oclif-v1 branch to oclif v1. If you find any repos that don’t have a main branch, you can safely assume that they're not used in oclif v2 and will be deprecated in the future.
Consolidating Tools & Libraries​
The oclif-dev CLI has now been incorporated into oclif. You now no longer need to install a separate package to manage your entire CLI’s lifecycle.
The following libraries have been consolidated under @oclif/core and will be deprecated at some point in the future. Read the migration guide to learn how to update your CLI or plugin to use the new core library.

@oclif/command
@oclif/config
@oclif/error
@oclif/help
@oclif/parser

No more single vs multi command CLIs​
There's only one "type" of oclif v2 CLI, but it can have as few or as many commands as a developer wants. As a result, there’s only one command to generate CLIs, oclif generate, as opposed to the old oclif single and oclif multi commands.
Node > 12​
To ensure oclif CLIs are as secure as possible, all v2 libraries and plugins support only Node 12 or higher as of now. Going forward, they'll support only Node Maintenance or higher, as defined by Node's release schedule here: https://nodejs.org/en/about/releases/.
What’s new?​
New example CLI​
oclif-hello-world is our new example repo. This is also the repo that's used as a template when running oclif generate to create a new CLI. This repo will always be able to be referenced as an example of what an oclif v2 CLI should look like.
Spaced commands​
oclif CLIs can now use spaces, instead of colons, to separate topics and subcommands. To enable this feature, simply add “topicSeparator": " " to the oclif config in your package.json. See an example in our example repo.
// Old commands that use :$ mycli do:something
// New spaced commands$ mycli do something

Note: Spaced commands are backwards compatible. So if you enable spaced commands for your CLI, users will still be able to use : as a separator. This ensures that any existing scripts don't break.

New Help Output​
We’ve revamped the way command help is outputted to the terminal, making it both easier to implement and easier to read. See the difference between the old help output on the left and the new help output on the right in the screenshots below.
oclif v1oclif v2
Notice that there are new sections for flags and global flags, examples are displayed with better spacing, and there is a section at the bottom called Configuration Variables. This Configuration Variables section is not part of the new help by default. But we've added support for custom help sections, which is what the sf CLI uses to create the new section.
Async Command Parsing​
We’ve also improved the performance of new CLIs by rewriting how commands are parsed on initialization. The new parser is asynchronous, which makes CLIs with a lot of commands or installed  plugins much faster.
What’s coming next?​
Part of our charter for the release of oclif v2 includes improving our engagement with the oclif community. We know that over the past couple of years we’ve reduced our involvement, and a lot of issues and PRs have languished in limbo. Hopefully you’ve already seen increased activity and responses from oclif maintainers recently, but if you haven’t, please don’t hesitate to ping us by tagging @admins in oclif repos.
We also want to start interviewing members of the oclif community to acquire feedback and prioritize the features and fixes you deem most important!
Best,
The oclif team

Reference material​
Migration Guide​
This guide explains how to upgrade a CLI or plugin from the old oclif v1 libraries to the new @oclif/core library that oclif v2 uses.
https://github.com/oclif/core/blob/main/MIGRATION.md
Compatibility Matrix​
The following matrix shows how the v1 libraries and plugins relate to the new v2 ones. Use this matrix as a guide to know what to drop and which versions to switch when upgrading your plugins and CLIs to v2.
oclif "v1"oclif "v2"Utility CLIsoclif@<2@oclif/dev-cli@<2oclif@>=2Main packages@oclif/command@oclif/config@oclif/errors@oclif/parser@oclif/plugin-help@oclif/core@>=1Node LTSNode v8-14Node v12+ (at time of writing)TypeScripttypescript@<4typescript@>=4Main plugins@oclif/plugin-autocomplete@<1@oclif/plugin-commands@<2@oclif/plugin-help@<4@oclif/plugin-not-found@<2@oclif/plugin-plugins@<2@oclif/plugin-update@<2plugin-warn-if-update-available@<2plugin-which@<2@oclif/plugin-autocomplete@>=1@oclif/plugin-commands@>=2@oclif/plugin-help@>=4@oclif/plugin-not-found@>=2@oclif/plugin-plugins@>=2@oclif/plugin-update@>=2@oclif/plugin-warn-if-update-available@>=2@oclif/plugin-which@>=2Introducing @oclif/coreMarch 1, 2021 · 3 min readGreetings!
We hope this blog post finds you well.
Introducing...​
We are excited to announce the next iteration of the oclif project today: @oclif/core.
We have learned a lot in the last three years of developing oclif, developing on oclif and supporting millions of command runs a day via Heroku and Salesforce CLIs.
@oclif/core ("Core") simplifies the oclif development experience and introduces highly requested new features.
Core combines the essential oclif packages into one "core" package, aptly named @oclif/core.
Core also introduces:

A default command option
Colon or space command syntax
Async command parsing
Command piping to arguments

With the introduction of default command functionality, Core simplifies the oclif project and removes the notion of single or multi command CLIs. Core CLIs can have 1 or many commands.
Along with Core, we moved the oclif-dev CLI into the oclif CLI creating a single "utility" CLI. This CLI also introduces a new AWS S3 compatible publishing scheme.
What to expect in the near future​
Core is in pre-release beta and being actively developed for new internal Salesforce CLIs.
Much documentation needs to be written in the coming months including migration paths. Migration onto Core should be as painless as possible with many exports remaining entirely unchanged. Look for forthcoming blog posts and documentation on oclif.io.
Early this summer, tentively June 1, we will release Core v1. Core's release will coincide with major bumps to many other oclif plugin packages. See the compatibility matrix below.
At Core's v1 release, the current "main" oclif packages (namely: command, config, errors & parser) will go into maintenance mode until Jan 2022. They will receive only bug and security fixes and they remain compatible with current versions of the oclif and oclif-dev CLIs. Afterwhich, they will be archived.
Companioning Core, the next major release of the oclif CLI (literally oclif@2) will generate Core CLIs.
Going forward​
We are excited to release Core! We invite you to poke around the Core repo. It may appear to be a big change but Core keeps what you already enjoy about oclif while reducing development complexity, project dependencies, package coupling and bundle size and introduces many requested features previously too prickly to weave into the current oclif architecture.
Best,
The oclif team
Reference: Compatibility matrix​
oclif "v1"oclif "Core"Utility CLIsoclif@<2@oclif/dev-cli@<2oclif@>=2Main packages@oclif/core@<2@oclif/config@<2@oclif/errors@<2@oclif/parser@<4@oclif/plugin-help@<4@oclif/core@>=1Node LTSNode v8-14Node v12+TypeScripttypescript@<4typescript@>=4Main plugins@oclif/plugin-autocomplete@<1@oclif/plugin-commands@<2@oclif/plugin-help@<4@oclif/plugin-not-found@<2@oclif/plugin-plugins@<2@oclif/plugin-update@<2plugin-warn-if-update-available@<2plugin-which@<2@oclif/plugin-autocomplete@>=2@oclif/plugin-commands@>=2@oclif/plugin-help@>=4@oclif/plugin-not-found@>=2@oclif/plugin-plugins@>=2@oclif/plugin-update@>=2@oclif/plugin-warn-if-update-available@>=2@oclif/plugin-which@>=2oclif Summer 2020 UpdateAugust 26, 2020 · 2 min readHello oclif developers! We hope you are all doing well.
Earlier this year, we started our planning for oclifconf v2 and, like all conference, had to change course. We opted not to hold a virtual conference, however, we wanted to take some time to highlight a few oclif features shipped this year.
Feature: Help templating​
One of the most requested features, help templating enables oclif developers to customize the help output for their CLI.
Read the announcement.
Feature: Custom error delegation​
This feature both improved how oclif throws and handles errors and allows oclif developers to overwrite or interject in oclif’s error handling.
Read the announcement.
Feature: postrun hooks​
We have added a new lifecycle event postrun. Your CLI can now run a hook after a command has ran.
See our hook documentation.
Feature: Root index command​
Previously, oclif would display CLI help if only the binary name with no command ID was invoked, oclif now supports a "root index" command. If present, a command defined at src/commands/index.ts will be run if no command ID is found.
1 million weekly downloads​
While exact oclif usage metrics are hard to pin down, we use npm download statistics of oclif packages as a rough approximation. Earlier this year, oclif's command package hit 1 million weekly downloads for the first time!
This year has been presented its challenges on everyone. We want to thank you, oclif developers, whom have taken the time to use and improve the oclif project. We look forward to seeing you all - in person - in the future!
All our best,
The oclif teamPretty Printable ErrorsJuly 1, 2020 · One min readOften CLIs are used as handy tools and when things go wrong it’s useful to have additional context. In oclif we have added a couple of additional properties that can show extra context to the users when an error is displayed. The code, ref and suggestions will now be displayed if they are included. This will work with an existing oclif CLI by adding the latest @oclif/errors and @oclif/core to the CLI's package.json dependencies.
For example, using this.error with the additional properties:
class TestError extends Command {  async run() {    this.error("An error has occurred!", {      code: "OCLIF_ERR",      ref: "https://oclif.io/docs/commands#thiserrormessage-string--error-options-code-string-exit-number",      suggestions: ["Use these extra properties to provide additional context"],    })  }}
would result with the following output:
›   Error: An error has occurred!›   Code: OCLIF_ERR›   Try this: Use these extra properties to provide additional context›   Reference: https://oclif.io/docs/commands#thiserrormessage-string--error-options-code-string-exit-number
If these properties are not provided then nothing changes and the CLI will continue to display the single error message output as it did before. Additionally, as part of this exercise we’ve added documentation around Error Handling in oclif which should come in handy if the need arises to extend oclif’s default handling of errors.Customizing Help in oclifMay 5, 2020 · 2 min readOut of the box oclif provides a great help experience for CLIs.
But what if, as an oclif developer, you want to customize some or all of the output?
You can now customize your CLI's help output by implementing the HelpBase abstract class.
Getting started with custom help​
If you have not done so yet, update @oclif/core.
$ yarn add --latest @oclif/core
To get started, first define the filepath to your help class in oclif's config in package.json. This is a relative path to the help class, without a file extension.
For this example, the help class will be created in a file at "[project root]/src/help.ts".
{  // ...  "oclif": {    "helpClass": "./lib/help"    // ...  }  // ...}
From here there are two paths, implement the HelpBase abstract class yourself or overwrite the parts of the default Help class you want to customize (ex: how command usage is displayed). We recommend the latter approach but cover both in the new Help Classes docs.
Separating TOPICS & COMMANDS in the new default Help class​
Previously, topics and child commands were listed in help output under a single list heading called "COMMANDS". But we found this can be slightly confusing. Some topics are commands also (a.k.a. topic-commands) while others are simply organizational namespacing (and when ran just show their help).
The new default Help class splits the list of children into distinct lists of "TOPICS" and "COMMANDS", with the possibility of an item appearing in both if it a topic-command. This makes it clearer what is expected to be ran - "COMMANDS" - and what is providing structure - "TOPICS" - when looking at the help output.
VERSION  plugin-help-example/0.0.0 darwin-x64 node-v12.12.0USAGE  $ plugin-help-example [COMMAND]TOPICS  topic  this is a topic and has child topics or commandsCOMMANDS  hello  describe the command here  help   display help for plugin-help-example
We look forward to seeing what custom help features you implement in your oclif CLIs with this new feature!oclif TSLint to ESLint MigrationDecember 5, 2019 · 3 min readBack in February of this year, plans were announced to deprecate TSLint in favor of ESLint. TSLint's goal has become to work toward a “unified developer experience” by supporting ESLint development going forward.
What has changed in oclif​
To keep inline with the community, oclif has transitioned to ESLint for all our core libraries as well as all our official plugins.
Starting in v1.15.x, oclif will now optionally generate projects with ESLint for both TypeScript and JavaScript CLI’s.
ESLint does require Node to be on stable LTS version, at the time of writing, Node 8.10.x, Node 10.13.x & Node 12.x.x.
How does this affect you​
Existing CLI’s are unchanged, but any newly generated CLI's will only give the option of using ESLint. If you are running tslint in your CLI, we recommend you switch to ESLint as well.
In migrating our projects we took the following steps (for an example of these changes see this pull request).


Install eslint
$ yarn add eslint eslint-config-oclif eslint-config-oclif-typescript --dev


Add eslint related files


$ echo '{  "extends": [    "oclif",    "oclif-typescript"  ],  "rules": {  }}' > .eslintrc


Remove tslint and related packages
$ yarn remove @oclif/tslint tslint


Remove tslint related configuration files
$ rm tslint.json


Change lint script in our package.json from something like:
"lint": "tsc -p test --noEmit && tslint -p test -t stylish"
to
"lint": "eslint . --ext .ts --config .eslintrc"


To preserve the test compile (tsc -p test --noEmit) we also made the following updates to our scripts:
"pretest": "tsc -p test --noEmit"
In some cases we had our posttest duplicating the same steps as our lint script so it’s cleaner to have it reference the lint job directly with:
"posttest": "yarn lint"

Run yarn lint --fix. This attempts to auto-fix any linting violations automatically. In the case an auto-fix isn’t available it should be fixed manually or ignored (see the eslint configuration doc for more information)
Do a search in the codebase for tslint and remove any unnecessary tslint disabling comments, like:

/* tslint:disable:object-literal-sort-keys */
If you are on a version of Node that is not supported by ESLint, you will also need to update your Node engine. ESLint supports Node 8, 10, and 12 so you should upgrade to the most recent Node version compatible with your CLI and also supported by ESLint (see ESLint's Installation and Usage instructions).
When will this take effect​
These changes have taken effect in oclif v1.15.1. When you generate a new CLI or plugin it will now contain configuration for ESLint instead of TSLint.oclif's Current Node SupportOctober 31, 2019 · 3 min readTo maintain a healthy project trajectory, oclif follows and supports Node Active LTS release, currently Node 10 & Node 12. This means ensuring that oclif continues to play nice with coming Active LTS Node versions and other packages in the ecosystem. Moving forward also means leaving older versions behind. Starting in 2020, Node will stop maintaining Node 8 and it is our intent at that time to also follow suit. Let’s take a look at a few ways we will be supporting these changes.
CI Environments​
CLIs created with the oclif cli going forward will be generated with a CircleCI configuration with Node 10 & 12 and an Appveyor configuration using Node 10. We have also added Node latest to CircleCi to be an early warning detection against coming Node changes (Node latest is managed by CircleCI).
We have already updated every oclif repo's CI configs to reflect this.
If your existing CLI uses either Appveyor or CircleCI you can update your config files also, like so:
.circleci/config.yml​
Your CircleCI config should contain a node-latest job, aliased as test. From this, there should be two extensions of this job for the Active LTS Node versions, Node 10 and Node 12.
  node-10:    <<: *node-latest    docker:      - image: node:10  node-12:    <<: *node-latest    docker:      - image: node:12
Notice that these declarations only change the Docker Node images used to run that job.
Additionally, the jobs listed within workflows must also be updated to reflect our changes in configuration:
    jobs:      - node-latest      - node-10      - node-12
appveyor.yml​
For appveyor we are currently only testing the oldest Active LTS Node version, Node 10. Update the nodejs_version proppert in your appveyor.yml file to reflect this.
environment:  nodejs_version: "10"
Deprecating Node 8 & Updating packge.json engines​
In Jan 2020, Node will end its Node 8 maintenance. We will follow suit by setting the package.json engine property in oclif packages to >=10 and bumping the package's major versions.
Depending on how you ship your CLI you may wish to also bump the engines version in your CLI's package.json. You can read more about the implications of the engines property configuration in the npm documentation.
Also consider distributing your CLI with its own Node version.
Packaged Node Version​
When using dev-cli to pack your CLI it will use the Node version as specified in your package.json under the oclif.update.node.version property. This value should reflect an Active LTS Node version (dev-cli does not currently enforce versions).
Supporting the future​
As a community we may discover bumps along the way as we upgrade. If you notice something related to oclif please feel free to open an issue or submit a pull request under the relevant oclif package within the org.
We look forward to using the latest from Node and the community and keeping oclif healthy along the way.oclifconf 2019: A RecapSeptember 16, 2019 · 4 min readIn May, Heroku and Salesforce Open Source organized oclifconf, a conference for developers & product managers building CLI tools on top of the open source oclif framework. The speakers came from various tech companies, such as Adobe, Netlify, and Apollo, who have already built amazing CLI experiences. The topics covered everything from the incredible capabilities oclif has unlocked, to the community-built plugins extending its functionality, and even what the behavior of an adaptive CLI tool might look like.
Below is a listing of all of the talks from the event, along with a short summary. Enjoy!
The future of oclif by Jeff Dickey​

In its relatively short lifetime, oclif has already inspired many developers and companies to adopt its framework as a means for implementing their own command-line tooling. In this talk, Jeff Dickey, an oclif founding team member, recaps the project's history and inspiration. He also looks towards the future and outlines some features and improvements that the tool could adapt. This isn't so much a definitive roadmap of where oclif is headed, but rather, a call to inspiration for developers eager to contribute! And if you are interested in contributing, check out the open issues in the oclif GitHub repo and come say "Hello!" on Spectrum Chat.
Open Source Citizenship by Josh Simmons​

When it comes to open source, it's more than just individuals now. More and more frequently, large corporations are contributing to projects by donating to contributors, sponsoring events, or upstreaming contributions. But keeping open source projects and communities healthy requires more than just money and brainpower. Josh Simmons surveyed multiple open source communities and relays his findings as to what help maintainers and contributors actually need in this talk.
Building an enterprise-grade CLI with oclif by Thomas Dvornik​

Security and performance are all about trust. While oclif is an extremely extensible framework for building CLI tooling, there are additional requirements to fulfill for enterprise businesses to adopt it that might not be necessary for individual developers. Thomas Dvornik outlines what he and his colleagues at Salesforce have implemented as plugins to oclif to satisfy these needs, including encrypted OAuth, plugin signing, lazy loading dependencies, synchronizing weekly releases and deprecations across dozens of repositories, and establishing cross-team coding and documentation standards.
How Adobe I/O built an extensible CLI with oclif by Jesse MacFadyen​

Perhaps oclif's most appealing feature is its support for plugins. In Cordova's case, they've created a sophisticated telemetry system that helps Adobe developers see which commands users are using--and reports on which ones are erroring out. By embedding a feedback system into the tool, users are even able to quickly send their suggestions to a form, without ever leaving the terminal. Jesse MacFadyen demonstrates how oclif's plugin system can work beyond simply executing commands.
Integrating oclif with GraphQL and Apollo by Evans Hauser​

For Evans Hauser and the team at Apollo, oclif is best thought of as "React for the CLI." As a client paired with a strongly-typed API contract to a server, it can deliver structured and consistent commands to retrieve external data. What better mechanism to use for this transfer than GraphQL, a framework which empowers the client to ask precisely for the data it needs, and nothing more?
Adaptive Intent-based CLI State Machines by Shawn Wang​

In designing oclif, Jeff Dickey wrote out 12 CLI factors to keep in mind. In this talk, Shawn Wang outlines a 13th: state. State is hard, because it depends on context, and context depends on understanding what a user intends to do, not what they are asking. Shawn is working towards enabling oclif to better understand the commands a user has entered, so that it can predict and interpret future commands that might be entered next. This would enable CLI tools to not just interpret a users' commands, but to also interpret their intent.\n\nIntroducing `oclif init` commandApril 10, 2024 · 2 min readThanks to the contribution of @joshcanhelp we released a new command for the oclif CLI called oclif init in version 4.8.0
The oclif init command allows you to initialize oclif in an existing project directory by adding the bare minimum requirements: a few pieces of configuration, bin scripts, and a couple of dependencies (@oclif/core and ts-node). This is slightly different from oclif generate, which will create an entirely new oclif project based on our templates.
oclif init will add the following:

bin scripts: bin/run.js, bin/run.cmd, bin/dev.js, and bin/dev.cmd
oclif section to package.json with bin, dirname, commands, and topicSeparator set (See Configuring Your CLI for more)
@oclif/core to dependencies in your package.json (if it's not already there)
ts-node to devDependencies in your package.json (if it's not already there)

Once you've initialized oclif, you can use the bin scripts to execute your CLI. You can also use the other oclif commands like oclif generate command and oclif generate hook to start adding new functionality.

❯ oclif init --helpInitialize a new oclif CLIUSAGE  $ oclif init [--bin <value>] [--module-type ESM|CommonJS] [--package-manager npm|yarn|pnpm] [--topic-separator    colons|spaces] [-d <value>] [-y]FLAGS  -d, --output-dir=<value>        Directory to initialize the CLI in.  -y, --yes                       Use defaults for all prompts. Individual flags will override defaults.      --bin=<value>               Supply answer for prompt: Command bin name the CLI will export      --module-type=<option>      Supply answer for prompt: Select a module type                                  <options: ESM|CommonJS>      --package-manager=<option>  Supply answer for prompt: Select a package manager                                  <options: npm|yarn|pnpm>      --topic-separator=<option>  Supply answer for prompt: Select a topic separator                                  <options: colons|spaces>DESCRIPTION  Initialize a new oclif CLI  This will add the necessary oclif bin files, add oclif config to package.json, and install @oclif/core and ts-node.EXAMPLES  Initialize a new CLI in the current directory    $ oclif init  Initialize a new CLI in a different directory    $ oclif init --output-dir "/path/to/existing/project"  Supply answers for specific prompts    $ oclif init --topic-separator colons --bin mycli
Hope you enjoy the new command! If you come across any issues or have any new ideas for this command, head over to the oclif/oclif repo and open a new issue.
All our best,
The oclif teamoclif Spring 2024 UpdateMarch 29, 2024 · 4 min readHello oclif developers! It's been a while since we last uploaded a blog - and a lot has happened.
We've been focusing on these high-level areas over the past couple of years:

Improving @oclif/core
ESM Support
Improving and revitalizing oclif.io
Re-engaging the oclif community

Improving @oclif/core​
Since we announced @oclif/core over three years ago, we've released two new major versions, each packed with lots of features that we're really excited about.
Here are some of these changes:

Full support for ESM and interoperability with CommonJS (more on this topic below).
Configurable command discovery strategies that give you more control over how commands are loaded at runtime. Check out the docs.
A new preparse hook that allows you to manipulate the provided arguments before they're parsed. Salesforce used this hook to implement a neat --flags-dir feature that translates local files into flags.
A new Performance class that you can use to track performance inside of @oclif/core and your own CLI or plugin. Check out the docs.
A new flag type, Flags.option, that lets you define a flag with a preset list of options. Typescript then uses the options to infer the flag's type.
Flags now have a relationship property that allows you to define more complex relationships between flags. Check out the flags docs for more information.
Flags now have a defaultHelp property that allows you to set the human readable default value in the command help. This property is useful when your flag's parse method returns a complex type, such as an object or a class. Check out the flags docs for more.
Commands now have a hiddenAliases property that allows you to define aliases that you want to hide from the user. The property is super helpful when you're trying to wean users off a deprecated command.
You can now use bun or tsx as dev runtimes (as opposed to node or ts-node).
A command's usage, args, and flags are now shown whenever a user forgets to provide a required arg or flag, or when they provided a non-existent flag.

If you need help migrating to the latest version, head over to core's README which has links to the migration guides. Feel free to open a new discussion if you need more hands-on help from us or the community.
ESM Support​
Version 3 of @oclif/core introduced full support for developing ESM plugins and CLIs. It also offered full support for interoperability between CommonJS and ESM plugins.
Put more simply, you can now migrate your CLI to ESM while keeping individual plugins in CommonJS (or vice versa). The upgrade path is now much simpler for you. You also don't need to worry about any community plugins that have migrated to ESM before you did (such as all the @oclif plugins) or are staunchly sticking with CommonJS for the foreseeable future.
Read more about this topic here.
Improving and Revitalizing oclif.io​
Another area of focus for us has been improving our documentation site, oclif.io.
While improving the quality and accuracy of the documentation was our priority, we also took the time to upgrade to the latest version of docusaurus. This new version gave our site a much-needed facelift, as well as cool new features such as dark mode and announcements.
If you have any feedback or are running into issues, we want to hear about it. Just create an issue in the oclif.io repo.
Re-engaging the oclif Community​
Lastly, our biggest priority at the moment is to re-engage the oclif community. We understand how frustrating it has been over the years to see your issues and pull requests go unacknowledged. We apologize for not prioritizing the community, and are earnestly trying to make sure that every issue and pull request gets the attention it deserves going forward.
We also opened up GitHub discussions for @oclif/core and the oclif CLI, where you can now post your questions or ideas. We hope you take advantage of them, we love hearing from you!
One last thing: we intend to publicly post our roadmap so you have more visibility into what we're working on. Stay tuned!
All our best,
The oclif teamAnnouncing oclif v2!January 12, 2022 · 5 min readHello and happy new year! It's our great pleasure to announce that we have released oclif v2, which uses the new @oclif/core library! 🎉
oclif v2 includes many changes that improve the experience of both creating and using an oclif CLI.
Going forward, we don't plan to make any updates to oclif v1 and its corresponding libraries, except for critical security fixes. See the compatibility matrix for a list of these libraries. In order to give developers time to migrate from v1 to v2, we're not completely dropping support yet. But at some point in the future we'll archive the v1 repositories and deprecate their versions on npm.
What’s changing?​
Repository Changes​
All repositories under the oclif org now use main as their primary branch and oclif-v1 as the legacy branch. The main  branch corresponds to oclif v2 and the oclif-v1 branch to oclif v1. If you find any repos that don’t have a main branch, you can safely assume that they're not used in oclif v2 and will be deprecated in the future.
Consolidating Tools & Libraries​
The oclif-dev CLI has now been incorporated into oclif. You now no longer need to install a separate package to manage your entire CLI’s lifecycle.
The following libraries have been consolidated under @oclif/core and will be deprecated at some point in the future. Read the migration guide to learn how to update your CLI or plugin to use the new core library.

@oclif/command
@oclif/config
@oclif/error
@oclif/help
@oclif/parser

No more single vs multi command CLIs​
There's only one "type" of oclif v2 CLI, but it can have as few or as many commands as a developer wants. As a result, there’s only one command to generate CLIs, oclif generate, as opposed to the old oclif single and oclif multi commands.
Node > 12​
To ensure oclif CLIs are as secure as possible, all v2 libraries and plugins support only Node 12 or higher as of now. Going forward, they'll support only Node Maintenance or higher, as defined by Node's release schedule here: https://nodejs.org/en/about/releases/.
What’s new?​
New example CLI​
oclif-hello-world is our new example repo. This is also the repo that's used as a template when running oclif generate to create a new CLI. This repo will always be able to be referenced as an example of what an oclif v2 CLI should look like.
Spaced commands​
oclif CLIs can now use spaces, instead of colons, to separate topics and subcommands. To enable this feature, simply add “topicSeparator": " " to the oclif config in your package.json. See an example in our example repo.
// Old commands that use :$ mycli do:something
// New spaced commands$ mycli do something

Note: Spaced commands are backwards compatible. So if you enable spaced commands for your CLI, users will still be able to use : as a separator. This ensures that any existing scripts don't break.

New Help Output​
We’ve revamped the way command help is outputted to the terminal, making it both easier to implement and easier to read. See the difference between the old help output on the left and the new help output on the right in the screenshots below.
oclif v1oclif v2
Notice that there are new sections for flags and global flags, examples are displayed with better spacing, and there is a section at the bottom called Configuration Variables. This Configuration Variables section is not part of the new help by default. But we've added support for custom help sections, which is what the sf CLI uses to create the new section.
Async Command Parsing​
We’ve also improved the performance of new CLIs by rewriting how commands are parsed on initialization. The new parser is asynchronous, which makes CLIs with a lot of commands or installed  plugins much faster.
What’s coming next?​
Part of our charter for the release of oclif v2 includes improving our engagement with the oclif community. We know that over the past couple of years we’ve reduced our involvement, and a lot of issues and PRs have languished in limbo. Hopefully you’ve already seen increased activity and responses from oclif maintainers recently, but if you haven’t, please don’t hesitate to ping us by tagging @admins in oclif repos.
We also want to start interviewing members of the oclif community to acquire feedback and prioritize the features and fixes you deem most important!
Best,
The oclif team

Reference material​
Migration Guide​
This guide explains how to upgrade a CLI or plugin from the old oclif v1 libraries to the new @oclif/core library that oclif v2 uses.
https://github.com/oclif/core/blob/main/MIGRATION.md
Compatibility Matrix​
The following matrix shows how the v1 libraries and plugins relate to the new v2 ones. Use this matrix as a guide to know what to drop and which versions to switch when upgrading your plugins and CLIs to v2.
oclif "v1"oclif "v2"Utility CLIsoclif@<2@oclif/dev-cli@<2oclif@>=2Main packages@oclif/command@oclif/config@oclif/errors@oclif/parser@oclif/plugin-help@oclif/core@>=1Node LTSNode v8-14Node v12+ (at time of writing)TypeScripttypescript@<4typescript@>=4Main plugins@oclif/plugin-autocomplete@<1@oclif/plugin-commands@<2@oclif/plugin-help@<4@oclif/plugin-not-found@<2@oclif/plugin-plugins@<2@oclif/plugin-update@<2plugin-warn-if-update-available@<2plugin-which@<2@oclif/plugin-autocomplete@>=1@oclif/plugin-commands@>=2@oclif/plugin-help@>=4@oclif/plugin-not-found@>=2@oclif/plugin-plugins@>=2@oclif/plugin-update@>=2@oclif/plugin-warn-if-update-available@>=2@oclif/plugin-which@>=2Introducing @oclif/coreMarch 1, 2021 · 3 min readGreetings!
We hope this blog post finds you well.
Introducing...​
We are excited to announce the next iteration of the oclif project today: @oclif/core.
We have learned a lot in the last three years of developing oclif, developing on oclif and supporting millions of command runs a day via Heroku and Salesforce CLIs.
@oclif/core ("Core") simplifies the oclif development experience and introduces highly requested new features.
Core combines the essential oclif packages into one "core" package, aptly named @oclif/core.
Core also introduces:

A default command option
Colon or space command syntax
Async command parsing
Command piping to arguments

With the introduction of default command functionality, Core simplifies the oclif project and removes the notion of single or multi command CLIs. Core CLIs can have 1 or many commands.
Along with Core, we moved the oclif-dev CLI into the oclif CLI creating a single "utility" CLI. This CLI also introduces a new AWS S3 compatible publishing scheme.
What to expect in the near future​
Core is in pre-release beta and being actively developed for new internal Salesforce CLIs.
Much documentation needs to be written in the coming months including migration paths. Migration onto Core should be as painless as possible with many exports remaining entirely unchanged. Look for forthcoming blog posts and documentation on oclif.io.
Early this summer, tentively June 1, we will release Core v1. Core's release will coincide with major bumps to many other oclif plugin packages. See the compatibility matrix below.
At Core's v1 release, the current "main" oclif packages (namely: command, config, errors & parser) will go into maintenance mode until Jan 2022. They will receive only bug and security fixes and they remain compatible with current versions of the oclif and oclif-dev CLIs. Afterwhich, they will be archived.
Companioning Core, the next major release of the oclif CLI (literally oclif@2) will generate Core CLIs.
Going forward​
We are excited to release Core! We invite you to poke around the Core repo. It may appear to be a big change but Core keeps what you already enjoy about oclif while reducing development complexity, project dependencies, package coupling and bundle size and introduces many requested features previously too prickly to weave into the current oclif architecture.
Best,
The oclif team
Reference: Compatibility matrix​
oclif "v1"oclif "Core"Utility CLIsoclif@<2@oclif/dev-cli@<2oclif@>=2Main packages@oclif/core@<2@oclif/config@<2@oclif/errors@<2@oclif/parser@<4@oclif/plugin-help@<4@oclif/core@>=1Node LTSNode v8-14Node v12+TypeScripttypescript@<4typescript@>=4Main plugins@oclif/plugin-autocomplete@<1@oclif/plugin-commands@<2@oclif/plugin-help@<4@oclif/plugin-not-found@<2@oclif/plugin-plugins@<2@oclif/plugin-update@<2plugin-warn-if-update-available@<2plugin-which@<2@oclif/plugin-autocomplete@>=2@oclif/plugin-commands@>=2@oclif/plugin-help@>=4@oclif/plugin-not-found@>=2@oclif/plugin-plugins@>=2@oclif/plugin-update@>=2@oclif/plugin-warn-if-update-available@>=2@oclif/plugin-which@>=2oclif Summer 2020 UpdateAugust 26, 2020 · 2 min readHello oclif developers! We hope you are all doing well.
Earlier this year, we started our planning for oclifconf v2 and, like all conference, had to change course. We opted not to hold a virtual conference, however, we wanted to take some time to highlight a few oclif features shipped this year.
Feature: Help templating​
One of the most requested features, help templating enables oclif developers to customize the help output for their CLI.
Read the announcement.
Feature: Custom error delegation​
This feature both improved how oclif throws and handles errors and allows oclif developers to overwrite or interject in oclif’s error handling.
Read the announcement.
Feature: postrun hooks​
We have added a new lifecycle event postrun. Your CLI can now run a hook after a command has ran.
See our hook documentation.
Feature: Root index command​
Previously, oclif would display CLI help if only the binary name with no command ID was invoked, oclif now supports a "root index" command. If present, a command defined at src/commands/index.ts will be run if no command ID is found.
1 million weekly downloads​
While exact oclif usage metrics are hard to pin down, we use npm download statistics of oclif packages as a rough approximation. Earlier this year, oclif's command package hit 1 million weekly downloads for the first time!
This year has been presented its challenges on everyone. We want to thank you, oclif developers, whom have taken the time to use and improve the oclif project. We look forward to seeing you all - in person - in the future!
All our best,
The oclif teamPretty Printable ErrorsJuly 1, 2020 · One min readOften CLIs are used as handy tools and when things go wrong it’s useful to have additional context. In oclif we have added a couple of additional properties that can show extra context to the users when an error is displayed. The code, ref and suggestions will now be displayed if they are included. This will work with an existing oclif CLI by adding the latest @oclif/errors and @oclif/core to the CLI's package.json dependencies.
For example, using this.error with the additional properties:
class TestError extends Command {  async run() {    this.error("An error has occurred!", {      code: "OCLIF_ERR",      ref: "https://oclif.io/docs/commands#thiserrormessage-string--error-options-code-string-exit-number",      suggestions: ["Use these extra properties to provide additional context"],    })  }}
would result with the following output:
›   Error: An error has occurred!›   Code: OCLIF_ERR›   Try this: Use these extra properties to provide additional context›   Reference: https://oclif.io/docs/commands#thiserrormessage-string--error-options-code-string-exit-number
If these properties are not provided then nothing changes and the CLI will continue to display the single error message output as it did before. Additionally, as part of this exercise we’ve added documentation around Error Handling in oclif which should come in handy if the need arises to extend oclif’s default handling of errors.Customizing Help in oclifMay 5, 2020 · 2 min readOut of the box oclif provides a great help experience for CLIs.
But what if, as an oclif developer, you want to customize some or all of the output?
You can now customize your CLI's help output by implementing the HelpBase abstract class.
Getting started with custom help​
If you have not done so yet, update @oclif/core.
$ yarn add --latest @oclif/core
To get started, first define the filepath to your help class in oclif's config in package.json. This is a relative path to the help class, without a file extension.
For this example, the help class will be created in a file at "[project root]/src/help.ts".
{  // ...  "oclif": {    "helpClass": "./lib/help"    // ...  }  // ...}
From here there are two paths, implement the HelpBase abstract class yourself or overwrite the parts of the default Help class you want to customize (ex: how command usage is displayed). We recommend the latter approach but cover both in the new Help Classes docs.
Separating TOPICS & COMMANDS in the new default Help class​
Previously, topics and child commands were listed in help output under a single list heading called "COMMANDS". But we found this can be slightly confusing. Some topics are commands also (a.k.a. topic-commands) while others are simply organizational namespacing (and when ran just show their help).
The new default Help class splits the list of children into distinct lists of "TOPICS" and "COMMANDS", with the possibility of an item appearing in both if it a topic-command. This makes it clearer what is expected to be ran - "COMMANDS" - and what is providing structure - "TOPICS" - when looking at the help output.
VERSION  plugin-help-example/0.0.0 darwin-x64 node-v12.12.0USAGE  $ plugin-help-example [COMMAND]TOPICS  topic  this is a topic and has child topics or commandsCOMMANDS  hello  describe the command here  help   display help for plugin-help-example
We look forward to seeing what custom help features you implement in your oclif CLIs with this new feature!oclif TSLint to ESLint MigrationDecember 5, 2019 · 3 min readBack in February of this year, plans were announced to deprecate TSLint in favor of ESLint. TSLint's goal has become to work toward a “unified developer experience” by supporting ESLint development going forward.
What has changed in oclif​
To keep inline with the community, oclif has transitioned to ESLint for all our core libraries as well as all our official plugins.
Starting in v1.15.x, oclif will now optionally generate projects with ESLint for both TypeScript and JavaScript CLI’s.
ESLint does require Node to be on stable LTS version, at the time of writing, Node 8.10.x, Node 10.13.x & Node 12.x.x.
How does this affect you​
Existing CLI’s are unchanged, but any newly generated CLI's will only give the option of using ESLint. If you are running tslint in your CLI, we recommend you switch to ESLint as well.
In migrating our projects we took the following steps (for an example of these changes see this pull request).


Install eslint
$ yarn add eslint eslint-config-oclif eslint-config-oclif-typescript --dev


Add eslint related files


$ echo '{  "extends": [    "oclif",    "oclif-typescript"  ],  "rules": {  }}' > .eslintrc


Remove tslint and related packages
$ yarn remove @oclif/tslint tslint


Remove tslint related configuration files
$ rm tslint.json


Change lint script in our package.json from something like:
"lint": "tsc -p test --noEmit && tslint -p test -t stylish"
to
"lint": "eslint . --ext .ts --config .eslintrc"


To preserve the test compile (tsc -p test --noEmit) we also made the following updates to our scripts:
"pretest": "tsc -p test --noEmit"
In some cases we had our posttest duplicating the same steps as our lint script so it’s cleaner to have it reference the lint job directly with:
"posttest": "yarn lint"

Run yarn lint --fix. This attempts to auto-fix any linting violations automatically. In the case an auto-fix isn’t available it should be fixed manually or ignored (see the eslint configuration doc for more information)
Do a search in the codebase for tslint and remove any unnecessary tslint disabling comments, like:

/* tslint:disable:object-literal-sort-keys */
If you are on a version of Node that is not supported by ESLint, you will also need to update your Node engine. ESLint supports Node 8, 10, and 12 so you should upgrade to the most recent Node version compatible with your CLI and also supported by ESLint (see ESLint's Installation and Usage instructions).
When will this take effect​
These changes have taken effect in oclif v1.15.1. When you generate a new CLI or plugin it will now contain configuration for ESLint instead of TSLint.oclif's Current Node SupportOctober 31, 2019 · 3 min readTo maintain a healthy project trajectory, oclif follows and supports Node Active LTS release, currently Node 10 & Node 12. This means ensuring that oclif continues to play nice with coming Active LTS Node versions and other packages in the ecosystem. Moving forward also means leaving older versions behind. Starting in 2020, Node will stop maintaining Node 8 and it is our intent at that time to also follow suit. Let’s take a look at a few ways we will be supporting these changes.
CI Environments​
CLIs created with the oclif cli going forward will be generated with a CircleCI configuration with Node 10 & 12 and an Appveyor configuration using Node 10. We have also added Node latest to CircleCi to be an early warning detection against coming Node changes (Node latest is managed by CircleCI).
We have already updated every oclif repo's CI configs to reflect this.
If your existing CLI uses either Appveyor or CircleCI you can update your config files also, like so:
.circleci/config.yml​
Your CircleCI config should contain a node-latest job, aliased as test. From this, there should be two extensions of this job for the Active LTS Node versions, Node 10 and Node 12.
  node-10:    <<: *node-latest    docker:      - image: node:10  node-12:    <<: *node-latest    docker:      - image: node:12
Notice that these declarations only change the Docker Node images used to run that job.
Additionally, the jobs listed within workflows must also be updated to reflect our changes in configuration:
    jobs:      - node-latest      - node-10      - node-12
appveyor.yml​
For appveyor we are currently only testing the oldest Active LTS Node version, Node 10. Update the nodejs_version proppert in your appveyor.yml file to reflect this.
environment:  nodejs_version: "10"
Deprecating Node 8 & Updating packge.json engines​
In Jan 2020, Node will end its Node 8 maintenance. We will follow suit by setting the package.json engine property in oclif packages to >=10 and bumping the package's major versions.
Depending on how you ship your CLI you may wish to also bump the engines version in your CLI's package.json. You can read more about the implications of the engines property configuration in the npm documentation.
Also consider distributing your CLI with its own Node version.
Packaged Node Version​
When using dev-cli to pack your CLI it will use the Node version as specified in your package.json under the oclif.update.node.version property. This value should reflect an Active LTS Node version (dev-cli does not currently enforce versions).
Supporting the future​
As a community we may discover bumps along the way as we upgrade. If you notice something related to oclif please feel free to open an issue or submit a pull request under the relevant oclif package within the org.
We look forward to using the latest from Node and the community and keeping oclif healthy along the way.oclifconf 2019: A RecapSeptember 16, 2019 · 4 min readIn May, Heroku and Salesforce Open Source organized oclifconf, a conference for developers & product managers building CLI tools on top of the open source oclif framework. The speakers came from various tech companies, such as Adobe, Netlify, and Apollo, who have already built amazing CLI experiences. The topics covered everything from the incredible capabilities oclif has unlocked, to the community-built plugins extending its functionality, and even what the behavior of an adaptive CLI tool might look like.
Below is a listing of all of the talks from the event, along with a short summary. Enjoy!
The future of oclif by Jeff Dickey​

In its relatively short lifetime, oclif has already inspired many developers and companies to adopt its framework as a means for implementing their own command-line tooling. In this talk, Jeff Dickey, an oclif founding team member, recaps the project's history and inspiration. He also looks towards the future and outlines some features and improvements that the tool could adapt. This isn't so much a definitive roadmap of where oclif is headed, but rather, a call to inspiration for developers eager to contribute! And if you are interested in contributing, check out the open issues in the oclif GitHub repo and come say "Hello!" on Spectrum Chat.
Open Source Citizenship by Josh Simmons​

When it comes to open source, it's more than just individuals now. More and more frequently, large corporations are contributing to projects by donating to contributors, sponsoring events, or upstreaming contributions. But keeping open source projects and communities healthy requires more than just money and brainpower. Josh Simmons surveyed multiple open source communities and relays his findings as to what help maintainers and contributors actually need in this talk.
Building an enterprise-grade CLI with oclif by Thomas Dvornik​

Security and performance are all about trust. While oclif is an extremely extensible framework for building CLI tooling, there are additional requirements to fulfill for enterprise businesses to adopt it that might not be necessary for individual developers. Thomas Dvornik outlines what he and his colleagues at Salesforce have implemented as plugins to oclif to satisfy these needs, including encrypted OAuth, plugin signing, lazy loading dependencies, synchronizing weekly releases and deprecations across dozens of repositories, and establishing cross-team coding and documentation standards.
How Adobe I/O built an extensible CLI with oclif by Jesse MacFadyen​

Perhaps oclif's most appealing feature is its support for plugins. In Cordova's case, they've created a sophisticated telemetry system that helps Adobe developers see which commands users are using--and reports on which ones are erroring out. By embedding a feedback system into the tool, users are even able to quickly send their suggestions to a form, without ever leaving the terminal. Jesse MacFadyen demonstrates how oclif's plugin system can work beyond simply executing commands.
Integrating oclif with GraphQL and Apollo by Evans Hauser​

For Evans Hauser and the team at Apollo, oclif is best thought of as "React for the CLI." As a client paired with a strongly-typed API contract to a server, it can deliver structured and consistent commands to retrieve external data. What better mechanism to use for this transfer than GraphQL, a framework which empowers the client to ask precisely for the data it needs, and nothing more?
Adaptive Intent-based CLI State Machines by Shawn Wang​

In designing oclif, Jeff Dickey wrote out 12 CLI factors to keep in mind. In this talk, Shawn Wang outlines a 13th: state. State is hard, because it depends on context, and context depends on understanding what a user intends to do, not what they are asking. Shawn is working towards enabling oclif to better understand the commands a user has entered, so that it can predict and interpret future commands that might be entered next. This would enable CLI tools to not just interpret a users' commands, but to also interpret their intent.Older Entries\n\n\n\nIntroducing `oclif init` commandApril 10, 2024 · 2 min readThanks to the contribution of @joshcanhelp we released a new command for the oclif CLI called oclif init in version 4.8.0
The oclif init command allows you to initialize oclif in an existing project directory by adding the bare minimum requirements: a few pieces of configuration, bin scripts, and a couple of dependencies (@oclif/core and ts-node). This is slightly different from oclif generate, which will create an entirely new oclif project based on our templates.
oclif init will add the following:

bin scripts: bin/run.js, bin/run.cmd, bin/dev.js, and bin/dev.cmd
oclif section to package.json with bin, dirname, commands, and topicSeparator set (See Configuring Your CLI for more)
@oclif/core to dependencies in your package.json (if it's not already there)
ts-node to devDependencies in your package.json (if it's not already there)

Once you've initialized oclif, you can use the bin scripts to execute your CLI. You can also use the other oclif commands like oclif generate command and oclif generate hook to start adding new functionality.

❯ oclif init --helpInitialize a new oclif CLIUSAGE  $ oclif init [--bin <value>] [--module-type ESM|CommonJS] [--package-manager npm|yarn|pnpm] [--topic-separator    colons|spaces] [-d <value>] [-y]FLAGS  -d, --output-dir=<value>        Directory to initialize the CLI in.  -y, --yes                       Use defaults for all prompts. Individual flags will override defaults.      --bin=<value>               Supply answer for prompt: Command bin name the CLI will export      --module-type=<option>      Supply answer for prompt: Select a module type                                  <options: ESM|CommonJS>      --package-manager=<option>  Supply answer for prompt: Select a package manager                                  <options: npm|yarn|pnpm>      --topic-separator=<option>  Supply answer for prompt: Select a topic separator                                  <options: colons|spaces>DESCRIPTION  Initialize a new oclif CLI  This will add the necessary oclif bin files, add oclif config to package.json, and install @oclif/core and ts-node.EXAMPLES  Initialize a new CLI in the current directory    $ oclif init  Initialize a new CLI in a different directory    $ oclif init --output-dir "/path/to/existing/project"  Supply answers for specific prompts    $ oclif init --topic-separator colons --bin mycli
Hope you enjoy the new command! If you come across any issues or have any new ideas for this command, head over to the oclif/oclif repo and open a new issue.
All our best,
The oclif teamoclif Spring 2024 UpdateMarch 29, 2024 · 4 min readHello oclif developers! It's been a while since we last uploaded a blog - and a lot has happened.
We've been focusing on these high-level areas over the past couple of years:

Improving @oclif/core
ESM Support
Improving and revitalizing oclif.io
Re-engaging the oclif community

Improving @oclif/core​
Since we announced @oclif/core over three years ago, we've released two new major versions, each packed with lots of features that we're really excited about.
Here are some of these changes:

Full support for ESM and interoperability with CommonJS (more on this topic below).
Configurable command discovery strategies that give you more control over how commands are loaded at runtime. Check out the docs.
A new preparse hook that allows you to manipulate the provided arguments before they're parsed. Salesforce used this hook to implement a neat --flags-dir feature that translates local files into flags.
A new Performance class that you can use to track performance inside of @oclif/core and your own CLI or plugin. Check out the docs.
A new flag type, Flags.option, that lets you define a flag with a preset list of options. Typescript then uses the options to infer the flag's type.
Flags now have a relationship property that allows you to define more complex relationships between flags. Check out the flags docs for more information.
Flags now have a defaultHelp property that allows you to set the human readable default value in the command help. This property is useful when your flag's parse method returns a complex type, such as an object or a class. Check out the flags docs for more.
Commands now have a hiddenAliases property that allows you to define aliases that you want to hide from the user. The property is super helpful when you're trying to wean users off a deprecated command.
You can now use bun or tsx as dev runtimes (as opposed to node or ts-node).
A command's usage, args, and flags are now shown whenever a user forgets to provide a required arg or flag, or when they provided a non-existent flag.

If you need help migrating to the latest version, head over to core's README which has links to the migration guides. Feel free to open a new discussion if you need more hands-on help from us or the community.
ESM Support​
Version 3 of @oclif/core introduced full support for developing ESM plugins and CLIs. It also offered full support for interoperability between CommonJS and ESM plugins.
Put more simply, you can now migrate your CLI to ESM while keeping individual plugins in CommonJS (or vice versa). The upgrade path is now much simpler for you. You also don't need to worry about any community plugins that have migrated to ESM before you did (such as all the @oclif plugins) or are staunchly sticking with CommonJS for the foreseeable future.
Read more about this topic here.
Improving and Revitalizing oclif.io​
Another area of focus for us has been improving our documentation site, oclif.io.
While improving the quality and accuracy of the documentation was our priority, we also took the time to upgrade to the latest version of docusaurus. This new version gave our site a much-needed facelift, as well as cool new features such as dark mode and announcements.
If you have any feedback or are running into issues, we want to hear about it. Just create an issue in the oclif.io repo.
Re-engaging the oclif Community​
Lastly, our biggest priority at the moment is to re-engage the oclif community. We understand how frustrating it has been over the years to see your issues and pull requests go unacknowledged. We apologize for not prioritizing the community, and are earnestly trying to make sure that every issue and pull request gets the attention it deserves going forward.
We also opened up GitHub discussions for @oclif/core and the oclif CLI, where you can now post your questions or ideas. We hope you take advantage of them, we love hearing from you!
One last thing: we intend to publicly post our roadmap so you have more visibility into what we're working on. Stay tuned!
All our best,
The oclif teamAnnouncing oclif v2!January 12, 2022 · 5 min readHello and happy new year! It's our great pleasure to announce that we have released oclif v2, which uses the new @oclif/core library! 🎉
oclif v2 includes many changes that improve the experience of both creating and using an oclif CLI.
Going forward, we don't plan to make any updates to oclif v1 and its corresponding libraries, except for critical security fixes. See the compatibility matrix for a list of these libraries. In order to give developers time to migrate from v1 to v2, we're not completely dropping support yet. But at some point in the future we'll archive the v1 repositories and deprecate their versions on npm.
What’s changing?​
Repository Changes​
All repositories under the oclif org now use main as their primary branch and oclif-v1 as the legacy branch. The main  branch corresponds to oclif v2 and the oclif-v1 branch to oclif v1. If you find any repos that don’t have a main branch, you can safely assume that they're not used in oclif v2 and will be deprecated in the future.
Consolidating Tools & Libraries​
The oclif-dev CLI has now been incorporated into oclif. You now no longer need to install a separate package to manage your entire CLI’s lifecycle.
The following libraries have been consolidated under @oclif/core and will be deprecated at some point in the future. Read the migration guide to learn how to update your CLI or plugin to use the new core library.

@oclif/command
@oclif/config
@oclif/error
@oclif/help
@oclif/parser

No more single vs multi command CLIs​
There's only one "type" of oclif v2 CLI, but it can have as few or as many commands as a developer wants. As a result, there’s only one command to generate CLIs, oclif generate, as opposed to the old oclif single and oclif multi commands.
Node > 12​
To ensure oclif CLIs are as secure as possible, all v2 libraries and plugins support only Node 12 or higher as of now. Going forward, they'll support only Node Maintenance or higher, as defined by Node's release schedule here: https://nodejs.org/en/about/releases/.
What’s new?​
New example CLI​
oclif-hello-world is our new example repo. This is also the repo that's used as a template when running oclif generate to create a new CLI. This repo will always be able to be referenced as an example of what an oclif v2 CLI should look like.
Spaced commands​
oclif CLIs can now use spaces, instead of colons, to separate topics and subcommands. To enable this feature, simply add “topicSeparator": " " to the oclif config in your package.json. See an example in our example repo.
// Old commands that use :$ mycli do:something
// New spaced commands$ mycli do something

Note: Spaced commands are backwards compatible. So if you enable spaced commands for your CLI, users will still be able to use : as a separator. This ensures that any existing scripts don't break.

New Help Output​
We’ve revamped the way command help is outputted to the terminal, making it both easier to implement and easier to read. See the difference between the old help output on the left and the new help output on the right in the screenshots below.
oclif v1oclif v2
Notice that there are new sections for flags and global flags, examples are displayed with better spacing, and there is a section at the bottom called Configuration Variables. This Configuration Variables section is not part of the new help by default. But we've added support for custom help sections, which is what the sf CLI uses to create the new section.
Async Command Parsing​
We’ve also improved the performance of new CLIs by rewriting how commands are parsed on initialization. The new parser is asynchronous, which makes CLIs with a lot of commands or installed  plugins much faster.
What’s coming next?​
Part of our charter for the release of oclif v2 includes improving our engagement with the oclif community. We know that over the past couple of years we’ve reduced our involvement, and a lot of issues and PRs have languished in limbo. Hopefully you’ve already seen increased activity and responses from oclif maintainers recently, but if you haven’t, please don’t hesitate to ping us by tagging @admins in oclif repos.
We also want to start interviewing members of the oclif community to acquire feedback and prioritize the features and fixes you deem most important!
Best,
The oclif team

Reference material​
Migration Guide​
This guide explains how to upgrade a CLI or plugin from the old oclif v1 libraries to the new @oclif/core library that oclif v2 uses.
https://github.com/oclif/core/blob/main/MIGRATION.md
Compatibility Matrix​
The following matrix shows how the v1 libraries and plugins relate to the new v2 ones. Use this matrix as a guide to know what to drop and which versions to switch when upgrading your plugins and CLIs to v2.
oclif "v1"oclif "v2"Utility CLIsoclif@<2@oclif/dev-cli@<2oclif@>=2Main packages@oclif/command@oclif/config@oclif/errors@oclif/parser@oclif/plugin-help@oclif/core@>=1Node LTSNode v8-14Node v12+ (at time of writing)TypeScripttypescript@<4typescript@>=4Main plugins@oclif/plugin-autocomplete@<1@oclif/plugin-commands@<2@oclif/plugin-help@<4@oclif/plugin-not-found@<2@oclif/plugin-plugins@<2@oclif/plugin-update@<2plugin-warn-if-update-available@<2plugin-which@<2@oclif/plugin-autocomplete@>=1@oclif/plugin-commands@>=2@oclif/plugin-help@>=4@oclif/plugin-not-found@>=2@oclif/plugin-plugins@>=2@oclif/plugin-update@>=2@oclif/plugin-warn-if-update-available@>=2@oclif/plugin-which@>=2Introducing @oclif/coreMarch 1, 2021 · 3 min readGreetings!
We hope this blog post finds you well.
Introducing...​
We are excited to announce the next iteration of the oclif project today: @oclif/core.
We have learned a lot in the last three years of developing oclif, developing on oclif and supporting millions of command runs a day via Heroku and Salesforce CLIs.
@oclif/core ("Core") simplifies the oclif development experience and introduces highly requested new features.
Core combines the essential oclif packages into one "core" package, aptly named @oclif/core.
Core also introduces:

A default command option
Colon or space command syntax
Async command parsing
Command piping to arguments

With the introduction of default command functionality, Core simplifies the oclif project and removes the notion of single or multi command CLIs. Core CLIs can have 1 or many commands.
Along with Core, we moved the oclif-dev CLI into the oclif CLI creating a single "utility" CLI. This CLI also introduces a new AWS S3 compatible publishing scheme.
What to expect in the near future​
Core is in pre-release beta and being actively developed for new internal Salesforce CLIs.
Much documentation needs to be written in the coming months including migration paths. Migration onto Core should be as painless as possible with many exports remaining entirely unchanged. Look for forthcoming blog posts and documentation on oclif.io.
Early this summer, tentively June 1, we will release Core v1. Core's release will coincide with major bumps to many other oclif plugin packages. See the compatibility matrix below.
At Core's v1 release, the current "main" oclif packages (namely: command, config, errors & parser) will go into maintenance mode until Jan 2022. They will receive only bug and security fixes and they remain compatible with current versions of the oclif and oclif-dev CLIs. Afterwhich, they will be archived.
Companioning Core, the next major release of the oclif CLI (literally oclif@2) will generate Core CLIs.
Going forward​
We are excited to release Core! We invite you to poke around the Core repo. It may appear to be a big change but Core keeps what you already enjoy about oclif while reducing development complexity, project dependencies, package coupling and bundle size and introduces many requested features previously too prickly to weave into the current oclif architecture.
Best,
The oclif team
Reference: Compatibility matrix​
oclif "v1"oclif "Core"Utility CLIsoclif@<2@oclif/dev-cli@<2oclif@>=2Main packages@oclif/core@<2@oclif/config@<2@oclif/errors@<2@oclif/parser@<4@oclif/plugin-help@<4@oclif/core@>=1Node LTSNode v8-14Node v12+TypeScripttypescript@<4typescript@>=4Main plugins@oclif/plugin-autocomplete@<1@oclif/plugin-commands@<2@oclif/plugin-help@<4@oclif/plugin-not-found@<2@oclif/plugin-plugins@<2@oclif/plugin-update@<2plugin-warn-if-update-available@<2plugin-which@<2@oclif/plugin-autocomplete@>=2@oclif/plugin-commands@>=2@oclif/plugin-help@>=4@oclif/plugin-not-found@>=2@oclif/plugin-plugins@>=2@oclif/plugin-update@>=2@oclif/plugin-warn-if-update-available@>=2@oclif/plugin-which@>=2oclif Summer 2020 UpdateAugust 26, 2020 · 2 min readHello oclif developers! We hope you are all doing well.
Earlier this year, we started our planning for oclifconf v2 and, like all conference, had to change course. We opted not to hold a virtual conference, however, we wanted to take some time to highlight a few oclif features shipped this year.
Feature: Help templating​
One of the most requested features, help templating enables oclif developers to customize the help output for their CLI.
Read the announcement.
Feature: Custom error delegation​
This feature both improved how oclif throws and handles errors and allows oclif developers to overwrite or interject in oclif’s error handling.
Read the announcement.
Feature: postrun hooks​
We have added a new lifecycle event postrun. Your CLI can now run a hook after a command has ran.
See our hook documentation.
Feature: Root index command​
Previously, oclif would display CLI help if only the binary name with no command ID was invoked, oclif now supports a "root index" command. If present, a command defined at src/commands/index.ts will be run if no command ID is found.
1 million weekly downloads​
While exact oclif usage metrics are hard to pin down, we use npm download statistics of oclif packages as a rough approximation. Earlier this year, oclif's command package hit 1 million weekly downloads for the first time!
This year has been presented its challenges on everyone. We want to thank you, oclif developers, whom have taken the time to use and improve the oclif project. We look forward to seeing you all - in person - in the future!
All our best,
The oclif teamPretty Printable ErrorsJuly 1, 2020 · One min readOften CLIs are used as handy tools and when things go wrong it’s useful to have additional context. In oclif we have added a couple of additional properties that can show extra context to the users when an error is displayed. The code, ref and suggestions will now be displayed if they are included. This will work with an existing oclif CLI by adding the latest @oclif/errors and @oclif/core to the CLI's package.json dependencies.
For example, using this.error with the additional properties:
class TestError extends Command {  async run() {    this.error("An error has occurred!", {      code: "OCLIF_ERR",      ref: "https://oclif.io/docs/commands#thiserrormessage-string--error-options-code-string-exit-number",      suggestions: ["Use these extra properties to provide additional context"],    })  }}
would result with the following output:
›   Error: An error has occurred!›   Code: OCLIF_ERR›   Try this: Use these extra properties to provide additional context›   Reference: https://oclif.io/docs/commands#thiserrormessage-string--error-options-code-string-exit-number
If these properties are not provided then nothing changes and the CLI will continue to display the single error message output as it did before. Additionally, as part of this exercise we’ve added documentation around Error Handling in oclif which should come in handy if the need arises to extend oclif’s default handling of errors.Customizing Help in oclifMay 5, 2020 · 2 min readOut of the box oclif provides a great help experience for CLIs.
But what if, as an oclif developer, you want to customize some or all of the output?
You can now customize your CLI's help output by implementing the HelpBase abstract class.
Getting started with custom help​
If you have not done so yet, update @oclif/core.
$ yarn add --latest @oclif/core
To get started, first define the filepath to your help class in oclif's config in package.json. This is a relative path to the help class, without a file extension.
For this example, the help class will be created in a file at "[project root]/src/help.ts".
{  // ...  "oclif": {    "helpClass": "./lib/help"    // ...  }  // ...}
From here there are two paths, implement the HelpBase abstract class yourself or overwrite the parts of the default Help class you want to customize (ex: how command usage is displayed). We recommend the latter approach but cover both in the new Help Classes docs.
Separating TOPICS & COMMANDS in the new default Help class​
Previously, topics and child commands were listed in help output under a single list heading called "COMMANDS". But we found this can be slightly confusing. Some topics are commands also (a.k.a. topic-commands) while others are simply organizational namespacing (and when ran just show their help).
The new default Help class splits the list of children into distinct lists of "TOPICS" and "COMMANDS", with the possibility of an item appearing in both if it a topic-command. This makes it clearer what is expected to be ran - "COMMANDS" - and what is providing structure - "TOPICS" - when looking at the help output.
VERSION  plugin-help-example/0.0.0 darwin-x64 node-v12.12.0USAGE  $ plugin-help-example [COMMAND]TOPICS  topic  this is a topic and has child topics or commandsCOMMANDS  hello  describe the command here  help   display help for plugin-help-example
We look forward to seeing what custom help features you implement in your oclif CLIs with this new feature!oclif TSLint to ESLint MigrationDecember 5, 2019 · 3 min readBack in February of this year, plans were announced to deprecate TSLint in favor of ESLint. TSLint's goal has become to work toward a “unified developer experience” by supporting ESLint development going forward.
What has changed in oclif​
To keep inline with the community, oclif has transitioned to ESLint for all our core libraries as well as all our official plugins.
Starting in v1.15.x, oclif will now optionally generate projects with ESLint for both TypeScript and JavaScript CLI’s.
ESLint does require Node to be on stable LTS version, at the time of writing, Node 8.10.x, Node 10.13.x & Node 12.x.x.
How does this affect you​
Existing CLI’s are unchanged, but any newly generated CLI's will only give the option of using ESLint. If you are running tslint in your CLI, we recommend you switch to ESLint as well.
In migrating our projects we took the following steps (for an example of these changes see this pull request).


Install eslint
$ yarn add eslint eslint-config-oclif eslint-config-oclif-typescript --dev


Add eslint related files


$ echo '{  "extends": [    "oclif",    "oclif-typescript"  ],  "rules": {  }}' > .eslintrc


Remove tslint and related packages
$ yarn remove @oclif/tslint tslint


Remove tslint related configuration files
$ rm tslint.json


Change lint script in our package.json from something like:
"lint": "tsc -p test --noEmit && tslint -p test -t stylish"
to
"lint": "eslint . --ext .ts --config .eslintrc"


To preserve the test compile (tsc -p test --noEmit) we also made the following updates to our scripts:
"pretest": "tsc -p test --noEmit"
In some cases we had our posttest duplicating the same steps as our lint script so it’s cleaner to have it reference the lint job directly with:
"posttest": "yarn lint"

Run yarn lint --fix. This attempts to auto-fix any linting violations automatically. In the case an auto-fix isn’t available it should be fixed manually or ignored (see the eslint configuration doc for more information)
Do a search in the codebase for tslint and remove any unnecessary tslint disabling comments, like:

/* tslint:disable:object-literal-sort-keys */
If you are on a version of Node that is not supported by ESLint, you will also need to update your Node engine. ESLint supports Node 8, 10, and 12 so you should upgrade to the most recent Node version compatible with your CLI and also supported by ESLint (see ESLint's Installation and Usage instructions).
When will this take effect​
These changes have taken effect in oclif v1.15.1. When you generate a new CLI or plugin it will now contain configuration for ESLint instead of TSLint.oclif's Current Node SupportOctober 31, 2019 · 3 min readTo maintain a healthy project trajectory, oclif follows and supports Node Active LTS release, currently Node 10 & Node 12. This means ensuring that oclif continues to play nice with coming Active LTS Node versions and other packages in the ecosystem. Moving forward also means leaving older versions behind. Starting in 2020, Node will stop maintaining Node 8 and it is our intent at that time to also follow suit. Let’s take a look at a few ways we will be supporting these changes.
CI Environments​
CLIs created with the oclif cli going forward will be generated with a CircleCI configuration with Node 10 & 12 and an Appveyor configuration using Node 10. We have also added Node latest to CircleCi to be an early warning detection against coming Node changes (Node latest is managed by CircleCI).
We have already updated every oclif repo's CI configs to reflect this.
If your existing CLI uses either Appveyor or CircleCI you can update your config files also, like so:
.circleci/config.yml​
Your CircleCI config should contain a node-latest job, aliased as test. From this, there should be two extensions of this job for the Active LTS Node versions, Node 10 and Node 12.
  node-10:    <<: *node-latest    docker:      - image: node:10  node-12:    <<: *node-latest    docker:      - image: node:12
Notice that these declarations only change the Docker Node images used to run that job.
Additionally, the jobs listed within workflows must also be updated to reflect our changes in configuration:
    jobs:      - node-latest      - node-10      - node-12
appveyor.yml​
For appveyor we are currently only testing the oldest Active LTS Node version, Node 10. Update the nodejs_version proppert in your appveyor.yml file to reflect this.
environment:  nodejs_version: "10"
Deprecating Node 8 & Updating packge.json engines​
In Jan 2020, Node will end its Node 8 maintenance. We will follow suit by setting the package.json engine property in oclif packages to >=10 and bumping the package's major versions.
Depending on how you ship your CLI you may wish to also bump the engines version in your CLI's package.json. You can read more about the implications of the engines property configuration in the npm documentation.
Also consider distributing your CLI with its own Node version.
Packaged Node Version​
When using dev-cli to pack your CLI it will use the Node version as specified in your package.json under the oclif.update.node.version property. This value should reflect an Active LTS Node version (dev-cli does not currently enforce versions).
Supporting the future​
As a community we may discover bumps along the way as we upgrade. If you notice something related to oclif please feel free to open an issue or submit a pull request under the relevant oclif package within the org.
We look forward to using the latest from Node and the community and keeping oclif healthy along the way.oclifconf 2019: A RecapSeptember 16, 2019 · 4 min readIn May, Heroku and Salesforce Open Source organized oclifconf, a conference for developers & product managers building CLI tools on top of the open source oclif framework. The speakers came from various tech companies, such as Adobe, Netlify, and Apollo, who have already built amazing CLI experiences. The topics covered everything from the incredible capabilities oclif has unlocked, to the community-built plugins extending its functionality, and even what the behavior of an adaptive CLI tool might look like.
Below is a listing of all of the talks from the event, along with a short summary. Enjoy!
The future of oclif by Jeff Dickey​

In its relatively short lifetime, oclif has already inspired many developers and companies to adopt its framework as a means for implementing their own command-line tooling. In this talk, Jeff Dickey, an oclif founding team member, recaps the project's history and inspiration. He also looks towards the future and outlines some features and improvements that the tool could adapt. This isn't so much a definitive roadmap of where oclif is headed, but rather, a call to inspiration for developers eager to contribute! And if you are interested in contributing, check out the open issues in the oclif GitHub repo and come say "Hello!" on Spectrum Chat.
Open Source Citizenship by Josh Simmons​

When it comes to open source, it's more than just individuals now. More and more frequently, large corporations are contributing to projects by donating to contributors, sponsoring events, or upstreaming contributions. But keeping open source projects and communities healthy requires more than just money and brainpower. Josh Simmons surveyed multiple open source communities and relays his findings as to what help maintainers and contributors actually need in this talk.
Building an enterprise-grade CLI with oclif by Thomas Dvornik​

Security and performance are all about trust. While oclif is an extremely extensible framework for building CLI tooling, there are additional requirements to fulfill for enterprise businesses to adopt it that might not be necessary for individual developers. Thomas Dvornik outlines what he and his colleagues at Salesforce have implemented as plugins to oclif to satisfy these needs, including encrypted OAuth, plugin signing, lazy loading dependencies, synchronizing weekly releases and deprecations across dozens of repositories, and establishing cross-team coding and documentation standards.
How Adobe I/O built an extensible CLI with oclif by Jesse MacFadyen​

Perhaps oclif's most appealing feature is its support for plugins. In Cordova's case, they've created a sophisticated telemetry system that helps Adobe developers see which commands users are using--and reports on which ones are erroring out. By embedding a feedback system into the tool, users are even able to quickly send their suggestions to a form, without ever leaving the terminal. Jesse MacFadyen demonstrates how oclif's plugin system can work beyond simply executing commands.
Integrating oclif with GraphQL and Apollo by Evans Hauser​

For Evans Hauser and the team at Apollo, oclif is best thought of as "React for the CLI." As a client paired with a strongly-typed API contract to a server, it can deliver structured and consistent commands to retrieve external data. What better mechanism to use for this transfer than GraphQL, a framework which empowers the client to ask precisely for the data it needs, and nothing more?
Adaptive Intent-based CLI State Machines by Shawn Wang​

In designing oclif, Jeff Dickey wrote out 12 CLI factors to keep in mind. In this talk, Shawn Wang outlines a 13th: state. State is hard, because it depends on context, and context depends on understanding what a user intends to do, not what they are asking. Shawn is working towards enabling oclif to better understand the commands a user has entered, so that it can predict and interpret future commands that might be entered next. This would enable CLI tools to not just interpret a users' commands, but to also interpret their intent.\n\nIntroducing `oclif init` commandApril 10, 2024 · 2 min readThanks to the contribution of @joshcanhelp we released a new command for the oclif CLI called oclif init in version 4.8.0
The oclif init command allows you to initialize oclif in an existing project directory by adding the bare minimum requirements: a few pieces of configuration, bin scripts, and a couple of dependencies (@oclif/core and ts-node). This is slightly different from oclif generate, which will create an entirely new oclif project based on our templates.
oclif init will add the following:

bin scripts: bin/run.js, bin/run.cmd, bin/dev.js, and bin/dev.cmd
oclif section to package.json with bin, dirname, commands, and topicSeparator set (See Configuring Your CLI for more)
@oclif/core to dependencies in your package.json (if it's not already there)
ts-node to devDependencies in your package.json (if it's not already there)

Once you've initialized oclif, you can use the bin scripts to execute your CLI. You can also use the other oclif commands like oclif generate command and oclif generate hook to start adding new functionality.

❯ oclif init --helpInitialize a new oclif CLIUSAGE  $ oclif init [--bin <value>] [--module-type ESM|CommonJS] [--package-manager npm|yarn|pnpm] [--topic-separator    colons|spaces] [-d <value>] [-y]FLAGS  -d, --output-dir=<value>        Directory to initialize the CLI in.  -y, --yes                       Use defaults for all prompts. Individual flags will override defaults.      --bin=<value>               Supply answer for prompt: Command bin name the CLI will export      --module-type=<option>      Supply answer for prompt: Select a module type                                  <options: ESM|CommonJS>      --package-manager=<option>  Supply answer for prompt: Select a package manager                                  <options: npm|yarn|pnpm>      --topic-separator=<option>  Supply answer for prompt: Select a topic separator                                  <options: colons|spaces>DESCRIPTION  Initialize a new oclif CLI  This will add the necessary oclif bin files, add oclif config to package.json, and install @oclif/core and ts-node.EXAMPLES  Initialize a new CLI in the current directory    $ oclif init  Initialize a new CLI in a different directory    $ oclif init --output-dir "/path/to/existing/project"  Supply answers for specific prompts    $ oclif init --topic-separator colons --bin mycli
Hope you enjoy the new command! If you come across any issues or have any new ideas for this command, head over to the oclif/oclif repo and open a new issue.
All our best,
The oclif teamoclif Spring 2024 UpdateMarch 29, 2024 · 4 min readHello oclif developers! It's been a while since we last uploaded a blog - and a lot has happened.
We've been focusing on these high-level areas over the past couple of years:

Improving @oclif/core
ESM Support
Improving and revitalizing oclif.io
Re-engaging the oclif community

Improving @oclif/core​
Since we announced @oclif/core over three years ago, we've released two new major versions, each packed with lots of features that we're really excited about.
Here are some of these changes:

Full support for ESM and interoperability with CommonJS (more on this topic below).
Configurable command discovery strategies that give you more control over how commands are loaded at runtime. Check out the docs.
A new preparse hook that allows you to manipulate the provided arguments before they're parsed. Salesforce used this hook to implement a neat --flags-dir feature that translates local files into flags.
A new Performance class that you can use to track performance inside of @oclif/core and your own CLI or plugin. Check out the docs.
A new flag type, Flags.option, that lets you define a flag with a preset list of options. Typescript then uses the options to infer the flag's type.
Flags now have a relationship property that allows you to define more complex relationships between flags. Check out the flags docs for more information.
Flags now have a defaultHelp property that allows you to set the human readable default value in the command help. This property is useful when your flag's parse method returns a complex type, such as an object or a class. Check out the flags docs for more.
Commands now have a hiddenAliases property that allows you to define aliases that you want to hide from the user. The property is super helpful when you're trying to wean users off a deprecated command.
You can now use bun or tsx as dev runtimes (as opposed to node or ts-node).
A command's usage, args, and flags are now shown whenever a user forgets to provide a required arg or flag, or when they provided a non-existent flag.

If you need help migrating to the latest version, head over to core's README which has links to the migration guides. Feel free to open a new discussion if you need more hands-on help from us or the community.
ESM Support​
Version 3 of @oclif/core introduced full support for developing ESM plugins and CLIs. It also offered full support for interoperability between CommonJS and ESM plugins.
Put more simply, you can now migrate your CLI to ESM while keeping individual plugins in CommonJS (or vice versa). The upgrade path is now much simpler for you. You also don't need to worry about any community plugins that have migrated to ESM before you did (such as all the @oclif plugins) or are staunchly sticking with CommonJS for the foreseeable future.
Read more about this topic here.
Improving and Revitalizing oclif.io​
Another area of focus for us has been improving our documentation site, oclif.io.
While improving the quality and accuracy of the documentation was our priority, we also took the time to upgrade to the latest version of docusaurus. This new version gave our site a much-needed facelift, as well as cool new features such as dark mode and announcements.
If you have any feedback or are running into issues, we want to hear about it. Just create an issue in the oclif.io repo.
Re-engaging the oclif Community​
Lastly, our biggest priority at the moment is to re-engage the oclif community. We understand how frustrating it has been over the years to see your issues and pull requests go unacknowledged. We apologize for not prioritizing the community, and are earnestly trying to make sure that every issue and pull request gets the attention it deserves going forward.
We also opened up GitHub discussions for @oclif/core and the oclif CLI, where you can now post your questions or ideas. We hope you take advantage of them, we love hearing from you!
One last thing: we intend to publicly post our roadmap so you have more visibility into what we're working on. Stay tuned!
All our best,
The oclif teamAnnouncing oclif v2!January 12, 2022 · 5 min readHello and happy new year! It's our great pleasure to announce that we have released oclif v2, which uses the new @oclif/core library! 🎉
oclif v2 includes many changes that improve the experience of both creating and using an oclif CLI.
Going forward, we don't plan to make any updates to oclif v1 and its corresponding libraries, except for critical security fixes. See the compatibility matrix for a list of these libraries. In order to give developers time to migrate from v1 to v2, we're not completely dropping support yet. But at some point in the future we'll archive the v1 repositories and deprecate their versions on npm.
What’s changing?​
Repository Changes​
All repositories under the oclif org now use main as their primary branch and oclif-v1 as the legacy branch. The main  branch corresponds to oclif v2 and the oclif-v1 branch to oclif v1. If you find any repos that don’t have a main branch, you can safely assume that they're not used in oclif v2 and will be deprecated in the future.
Consolidating Tools & Libraries​
The oclif-dev CLI has now been incorporated into oclif. You now no longer need to install a separate package to manage your entire CLI’s lifecycle.
The following libraries have been consolidated under @oclif/core and will be deprecated at some point in the future. Read the migration guide to learn how to update your CLI or plugin to use the new core library.

@oclif/command
@oclif/config
@oclif/error
@oclif/help
@oclif/parser

No more single vs multi command CLIs​
There's only one "type" of oclif v2 CLI, but it can have as few or as many commands as a developer wants. As a result, there’s only one command to generate CLIs, oclif generate, as opposed to the old oclif single and oclif multi commands.
Node > 12​
To ensure oclif CLIs are as secure as possible, all v2 libraries and plugins support only Node 12 or higher as of now. Going forward, they'll support only Node Maintenance or higher, as defined by Node's release schedule here: https://nodejs.org/en/about/releases/.
What’s new?​
New example CLI​
oclif-hello-world is our new example repo. This is also the repo that's used as a template when running oclif generate to create a new CLI. This repo will always be able to be referenced as an example of what an oclif v2 CLI should look like.
Spaced commands​
oclif CLIs can now use spaces, instead of colons, to separate topics and subcommands. To enable this feature, simply add “topicSeparator": " " to the oclif config in your package.json. See an example in our example repo.
// Old commands that use :$ mycli do:something
// New spaced commands$ mycli do something

Note: Spaced commands are backwards compatible. So if you enable spaced commands for your CLI, users will still be able to use : as a separator. This ensures that any existing scripts don't break.

New Help Output​
We’ve revamped the way command help is outputted to the terminal, making it both easier to implement and easier to read. See the difference between the old help output on the left and the new help output on the right in the screenshots below.
oclif v1oclif v2
Notice that there are new sections for flags and global flags, examples are displayed with better spacing, and there is a section at the bottom called Configuration Variables. This Configuration Variables section is not part of the new help by default. But we've added support for custom help sections, which is what the sf CLI uses to create the new section.
Async Command Parsing​
We’ve also improved the performance of new CLIs by rewriting how commands are parsed on initialization. The new parser is asynchronous, which makes CLIs with a lot of commands or installed  plugins much faster.
What’s coming next?​
Part of our charter for the release of oclif v2 includes improving our engagement with the oclif community. We know that over the past couple of years we’ve reduced our involvement, and a lot of issues and PRs have languished in limbo. Hopefully you’ve already seen increased activity and responses from oclif maintainers recently, but if you haven’t, please don’t hesitate to ping us by tagging @admins in oclif repos.
We also want to start interviewing members of the oclif community to acquire feedback and prioritize the features and fixes you deem most important!
Best,
The oclif team

Reference material​
Migration Guide​
This guide explains how to upgrade a CLI or plugin from the old oclif v1 libraries to the new @oclif/core library that oclif v2 uses.
https://github.com/oclif/core/blob/main/MIGRATION.md
Compatibility Matrix​
The following matrix shows how the v1 libraries and plugins relate to the new v2 ones. Use this matrix as a guide to know what to drop and which versions to switch when upgrading your plugins and CLIs to v2.
oclif "v1"oclif "v2"Utility CLIsoclif@<2@oclif/dev-cli@<2oclif@>=2Main packages@oclif/command@oclif/config@oclif/errors@oclif/parser@oclif/plugin-help@oclif/core@>=1Node LTSNode v8-14Node v12+ (at time of writing)TypeScripttypescript@<4typescript@>=4Main plugins@oclif/plugin-autocomplete@<1@oclif/plugin-commands@<2@oclif/plugin-help@<4@oclif/plugin-not-found@<2@oclif/plugin-plugins@<2@oclif/plugin-update@<2plugin-warn-if-update-available@<2plugin-which@<2@oclif/plugin-autocomplete@>=1@oclif/plugin-commands@>=2@oclif/plugin-help@>=4@oclif/plugin-not-found@>=2@oclif/plugin-plugins@>=2@oclif/plugin-update@>=2@oclif/plugin-warn-if-update-available@>=2@oclif/plugin-which@>=2Introducing @oclif/coreMarch 1, 2021 · 3 min readGreetings!
We hope this blog post finds you well.
Introducing...​
We are excited to announce the next iteration of the oclif project today: @oclif/core.
We have learned a lot in the last three years of developing oclif, developing on oclif and supporting millions of command runs a day via Heroku and Salesforce CLIs.
@oclif/core ("Core") simplifies the oclif development experience and introduces highly requested new features.
Core combines the essential oclif packages into one "core" package, aptly named @oclif/core.
Core also introduces:

A default command option
Colon or space command syntax
Async command parsing
Command piping to arguments

With the introduction of default command functionality, Core simplifies the oclif project and removes the notion of single or multi command CLIs. Core CLIs can have 1 or many commands.
Along with Core, we moved the oclif-dev CLI into the oclif CLI creating a single "utility" CLI. This CLI also introduces a new AWS S3 compatible publishing scheme.
What to expect in the near future​
Core is in pre-release beta and being actively developed for new internal Salesforce CLIs.
Much documentation needs to be written in the coming months including migration paths. Migration onto Core should be as painless as possible with many exports remaining entirely unchanged. Look for forthcoming blog posts and documentation on oclif.io.
Early this summer, tentively June 1, we will release Core v1. Core's release will coincide with major bumps to many other oclif plugin packages. See the compatibility matrix below.
At Core's v1 release, the current "main" oclif packages (namely: command, config, errors & parser) will go into maintenance mode until Jan 2022. They will receive only bug and security fixes and they remain compatible with current versions of the oclif and oclif-dev CLIs. Afterwhich, they will be archived.
Companioning Core, the next major release of the oclif CLI (literally oclif@2) will generate Core CLIs.
Going forward​
We are excited to release Core! We invite you to poke around the Core repo. It may appear to be a big change but Core keeps what you already enjoy about oclif while reducing development complexity, project dependencies, package coupling and bundle size and introduces many requested features previously too prickly to weave into the current oclif architecture.
Best,
The oclif team
Reference: Compatibility matrix​
oclif "v1"oclif "Core"Utility CLIsoclif@<2@oclif/dev-cli@<2oclif@>=2Main packages@oclif/core@<2@oclif/config@<2@oclif/errors@<2@oclif/parser@<4@oclif/plugin-help@<4@oclif/core@>=1Node LTSNode v8-14Node v12+TypeScripttypescript@<4typescript@>=4Main plugins@oclif/plugin-autocomplete@<1@oclif/plugin-commands@<2@oclif/plugin-help@<4@oclif/plugin-not-found@<2@oclif/plugin-plugins@<2@oclif/plugin-update@<2plugin-warn-if-update-available@<2plugin-which@<2@oclif/plugin-autocomplete@>=2@oclif/plugin-commands@>=2@oclif/plugin-help@>=4@oclif/plugin-not-found@>=2@oclif/plugin-plugins@>=2@oclif/plugin-update@>=2@oclif/plugin-warn-if-update-available@>=2@oclif/plugin-which@>=2oclif Summer 2020 UpdateAugust 26, 2020 · 2 min readHello oclif developers! We hope you are all doing well.
Earlier this year, we started our planning for oclifconf v2 and, like all conference, had to change course. We opted not to hold a virtual conference, however, we wanted to take some time to highlight a few oclif features shipped this year.
Feature: Help templating​
One of the most requested features, help templating enables oclif developers to customize the help output for their CLI.
Read the announcement.
Feature: Custom error delegation​
This feature both improved how oclif throws and handles errors and allows oclif developers to overwrite or interject in oclif’s error handling.
Read the announcement.
Feature: postrun hooks​
We have added a new lifecycle event postrun. Your CLI can now run a hook after a command has ran.
See our hook documentation.
Feature: Root index command​
Previously, oclif would display CLI help if only the binary name with no command ID was invoked, oclif now supports a "root index" command. If present, a command defined at src/commands/index.ts will be run if no command ID is found.
1 million weekly downloads​
While exact oclif usage metrics are hard to pin down, we use npm download statistics of oclif packages as a rough approximation. Earlier this year, oclif's command package hit 1 million weekly downloads for the first time!
This year has been presented its challenges on everyone. We want to thank you, oclif developers, whom have taken the time to use and improve the oclif project. We look forward to seeing you all - in person - in the future!
All our best,
The oclif teamPretty Printable ErrorsJuly 1, 2020 · One min readOften CLIs are used as handy tools and when things go wrong it’s useful to have additional context. In oclif we have added a couple of additional properties that can show extra context to the users when an error is displayed. The code, ref and suggestions will now be displayed if they are included. This will work with an existing oclif CLI by adding the latest @oclif/errors and @oclif/core to the CLI's package.json dependencies.
For example, using this.error with the additional properties:
class TestError extends Command {  async run() {    this.error("An error has occurred!", {      code: "OCLIF_ERR",      ref: "https://oclif.io/docs/commands#thiserrormessage-string--error-options-code-string-exit-number",      suggestions: ["Use these extra properties to provide additional context"],    })  }}
would result with the following output:
›   Error: An error has occurred!›   Code: OCLIF_ERR›   Try this: Use these extra properties to provide additional context›   Reference: https://oclif.io/docs/commands#thiserrormessage-string--error-options-code-string-exit-number
If these properties are not provided then nothing changes and the CLI will continue to display the single error message output as it did before. Additionally, as part of this exercise we’ve added documentation around Error Handling in oclif which should come in handy if the need arises to extend oclif’s default handling of errors.Customizing Help in oclifMay 5, 2020 · 2 min readOut of the box oclif provides a great help experience for CLIs.
But what if, as an oclif developer, you want to customize some or all of the output?
You can now customize your CLI's help output by implementing the HelpBase abstract class.
Getting started with custom help​
If you have not done so yet, update @oclif/core.
$ yarn add --latest @oclif/core
To get started, first define the filepath to your help class in oclif's config in package.json. This is a relative path to the help class, without a file extension.
For this example, the help class will be created in a file at "[project root]/src/help.ts".
{  // ...  "oclif": {    "helpClass": "./lib/help"    // ...  }  // ...}
From here there are two paths, implement the HelpBase abstract class yourself or overwrite the parts of the default Help class you want to customize (ex: how command usage is displayed). We recommend the latter approach but cover both in the new Help Classes docs.
Separating TOPICS & COMMANDS in the new default Help class​
Previously, topics and child commands were listed in help output under a single list heading called "COMMANDS". But we found this can be slightly confusing. Some topics are commands also (a.k.a. topic-commands) while others are simply organizational namespacing (and when ran just show their help).
The new default Help class splits the list of children into distinct lists of "TOPICS" and "COMMANDS", with the possibility of an item appearing in both if it a topic-command. This makes it clearer what is expected to be ran - "COMMANDS" - and what is providing structure - "TOPICS" - when looking at the help output.
VERSION  plugin-help-example/0.0.0 darwin-x64 node-v12.12.0USAGE  $ plugin-help-example [COMMAND]TOPICS  topic  this is a topic and has child topics or commandsCOMMANDS  hello  describe the command here  help   display help for plugin-help-example
We look forward to seeing what custom help features you implement in your oclif CLIs with this new feature!oclif TSLint to ESLint MigrationDecember 5, 2019 · 3 min readBack in February of this year, plans were announced to deprecate TSLint in favor of ESLint. TSLint's goal has become to work toward a “unified developer experience” by supporting ESLint development going forward.
What has changed in oclif​
To keep inline with the community, oclif has transitioned to ESLint for all our core libraries as well as all our official plugins.
Starting in v1.15.x, oclif will now optionally generate projects with ESLint for both TypeScript and JavaScript CLI’s.
ESLint does require Node to be on stable LTS version, at the time of writing, Node 8.10.x, Node 10.13.x & Node 12.x.x.
How does this affect you​
Existing CLI’s are unchanged, but any newly generated CLI's will only give the option of using ESLint. If you are running tslint in your CLI, we recommend you switch to ESLint as well.
In migrating our projects we took the following steps (for an example of these changes see this pull request).


Install eslint
$ yarn add eslint eslint-config-oclif eslint-config-oclif-typescript --dev


Add eslint related files


$ echo '{  "extends": [    "oclif",    "oclif-typescript"  ],  "rules": {  }}' > .eslintrc


Remove tslint and related packages
$ yarn remove @oclif/tslint tslint


Remove tslint related configuration files
$ rm tslint.json


Change lint script in our package.json from something like:
"lint": "tsc -p test --noEmit && tslint -p test -t stylish"
to
"lint": "eslint . --ext .ts --config .eslintrc"


To preserve the test compile (tsc -p test --noEmit) we also made the following updates to our scripts:
"pretest": "tsc -p test --noEmit"
In some cases we had our posttest duplicating the same steps as our lint script so it’s cleaner to have it reference the lint job directly with:
"posttest": "yarn lint"

Run yarn lint --fix. This attempts to auto-fix any linting violations automatically. In the case an auto-fix isn’t available it should be fixed manually or ignored (see the eslint configuration doc for more information)
Do a search in the codebase for tslint and remove any unnecessary tslint disabling comments, like:

/* tslint:disable:object-literal-sort-keys */
If you are on a version of Node that is not supported by ESLint, you will also need to update your Node engine. ESLint supports Node 8, 10, and 12 so you should upgrade to the most recent Node version compatible with your CLI and also supported by ESLint (see ESLint's Installation and Usage instructions).
When will this take effect​
These changes have taken effect in oclif v1.15.1. When you generate a new CLI or plugin it will now contain configuration for ESLint instead of TSLint.oclif's Current Node SupportOctober 31, 2019 · 3 min readTo maintain a healthy project trajectory, oclif follows and supports Node Active LTS release, currently Node 10 & Node 12. This means ensuring that oclif continues to play nice with coming Active LTS Node versions and other packages in the ecosystem. Moving forward also means leaving older versions behind. Starting in 2020, Node will stop maintaining Node 8 and it is our intent at that time to also follow suit. Let’s take a look at a few ways we will be supporting these changes.
CI Environments​
CLIs created with the oclif cli going forward will be generated with a CircleCI configuration with Node 10 & 12 and an Appveyor configuration using Node 10. We have also added Node latest to CircleCi to be an early warning detection against coming Node changes (Node latest is managed by CircleCI).
We have already updated every oclif repo's CI configs to reflect this.
If your existing CLI uses either Appveyor or CircleCI you can update your config files also, like so:
.circleci/config.yml​
Your CircleCI config should contain a node-latest job, aliased as test. From this, there should be two extensions of this job for the Active LTS Node versions, Node 10 and Node 12.
  node-10:    <<: *node-latest    docker:      - image: node:10  node-12:    <<: *node-latest    docker:      - image: node:12
Notice that these declarations only change the Docker Node images used to run that job.
Additionally, the jobs listed within workflows must also be updated to reflect our changes in configuration:
    jobs:      - node-latest      - node-10      - node-12
appveyor.yml​
For appveyor we are currently only testing the oldest Active LTS Node version, Node 10. Update the nodejs_version proppert in your appveyor.yml file to reflect this.
environment:  nodejs_version: "10"
Deprecating Node 8 & Updating packge.json engines​
In Jan 2020, Node will end its Node 8 maintenance. We will follow suit by setting the package.json engine property in oclif packages to >=10 and bumping the package's major versions.
Depending on how you ship your CLI you may wish to also bump the engines version in your CLI's package.json. You can read more about the implications of the engines property configuration in the npm documentation.
Also consider distributing your CLI with its own Node version.
Packaged Node Version​
When using dev-cli to pack your CLI it will use the Node version as specified in your package.json under the oclif.update.node.version property. This value should reflect an Active LTS Node version (dev-cli does not currently enforce versions).
Supporting the future​
As a community we may discover bumps along the way as we upgrade. If you notice something related to oclif please feel free to open an issue or submit a pull request under the relevant oclif package within the org.
We look forward to using the latest from Node and the community and keeping oclif healthy along the way.oclifconf 2019: A RecapSeptember 16, 2019 · 4 min readIn May, Heroku and Salesforce Open Source organized oclifconf, a conference for developers & product managers building CLI tools on top of the open source oclif framework. The speakers came from various tech companies, such as Adobe, Netlify, and Apollo, who have already built amazing CLI experiences. The topics covered everything from the incredible capabilities oclif has unlocked, to the community-built plugins extending its functionality, and even what the behavior of an adaptive CLI tool might look like.
Below is a listing of all of the talks from the event, along with a short summary. Enjoy!
The future of oclif by Jeff Dickey​

In its relatively short lifetime, oclif has already inspired many developers and companies to adopt its framework as a means for implementing their own command-line tooling. In this talk, Jeff Dickey, an oclif founding team member, recaps the project's history and inspiration. He also looks towards the future and outlines some features and improvements that the tool could adapt. This isn't so much a definitive roadmap of where oclif is headed, but rather, a call to inspiration for developers eager to contribute! And if you are interested in contributing, check out the open issues in the oclif GitHub repo and come say "Hello!" on Spectrum Chat.
Open Source Citizenship by Josh Simmons​

When it comes to open source, it's more than just individuals now. More and more frequently, large corporations are contributing to projects by donating to contributors, sponsoring events, or upstreaming contributions. But keeping open source projects and communities healthy requires more than just money and brainpower. Josh Simmons surveyed multiple open source communities and relays his findings as to what help maintainers and contributors actually need in this talk.
Building an enterprise-grade CLI with oclif by Thomas Dvornik​

Security and performance are all about trust. While oclif is an extremely extensible framework for building CLI tooling, there are additional requirements to fulfill for enterprise businesses to adopt it that might not be necessary for individual developers. Thomas Dvornik outlines what he and his colleagues at Salesforce have implemented as plugins to oclif to satisfy these needs, including encrypted OAuth, plugin signing, lazy loading dependencies, synchronizing weekly releases and deprecations across dozens of repositories, and establishing cross-team coding and documentation standards.
How Adobe I/O built an extensible CLI with oclif by Jesse MacFadyen​

Perhaps oclif's most appealing feature is its support for plugins. In Cordova's case, they've created a sophisticated telemetry system that helps Adobe developers see which commands users are using--and reports on which ones are erroring out. By embedding a feedback system into the tool, users are even able to quickly send their suggestions to a form, without ever leaving the terminal. Jesse MacFadyen demonstrates how oclif's plugin system can work beyond simply executing commands.
Integrating oclif with GraphQL and Apollo by Evans Hauser​

For Evans Hauser and the team at Apollo, oclif is best thought of as "React for the CLI." As a client paired with a strongly-typed API contract to a server, it can deliver structured and consistent commands to retrieve external data. What better mechanism to use for this transfer than GraphQL, a framework which empowers the client to ask precisely for the data it needs, and nothing more?
Adaptive Intent-based CLI State Machines by Shawn Wang​

In designing oclif, Jeff Dickey wrote out 12 CLI factors to keep in mind. In this talk, Shawn Wang outlines a 13th: state. State is hard, because it depends on context, and context depends on understanding what a user intends to do, not what they are asking. Shawn is working towards enabling oclif to better understand the commands a user has entered, so that it can predict and interpret future commands that might be entered next. This would enable CLI tools to not just interpret a users' commands, but to also interpret their intent.Older Entries\n\n\n\nIntroducing `oclif init` commandApril 10, 2024 · 2 min readThanks to the contribution of @joshcanhelp we released a new command for the oclif CLI called oclif init in version 4.8.0
The oclif init command allows you to initialize oclif in an existing project directory by adding the bare minimum requirements: a few pieces of configuration, bin scripts, and a couple of dependencies (@oclif/core and ts-node). This is slightly different from oclif generate, which will create an entirely new oclif project based on our templates.
oclif init will add the following:

bin scripts: bin/run.js, bin/run.cmd, bin/dev.js, and bin/dev.cmd
oclif section to package.json with bin, dirname, commands, and topicSeparator set (See Configuring Your CLI for more)
@oclif/core to dependencies in your package.json (if it's not already there)
ts-node to devDependencies in your package.json (if it's not already there)

Once you've initialized oclif, you can use the bin scripts to execute your CLI. You can also use the other oclif commands like oclif generate command and oclif generate hook to start adding new functionality.

❯ oclif init --helpInitialize a new oclif CLIUSAGE  $ oclif init [--bin <value>] [--module-type ESM|CommonJS] [--package-manager npm|yarn|pnpm] [--topic-separator    colons|spaces] [-d <value>] [-y]FLAGS  -d, --output-dir=<value>        Directory to initialize the CLI in.  -y, --yes                       Use defaults for all prompts. Individual flags will override defaults.      --bin=<value>               Supply answer for prompt: Command bin name the CLI will export      --module-type=<option>      Supply answer for prompt: Select a module type                                  <options: ESM|CommonJS>      --package-manager=<option>  Supply answer for prompt: Select a package manager                                  <options: npm|yarn|pnpm>      --topic-separator=<option>  Supply answer for prompt: Select a topic separator                                  <options: colons|spaces>DESCRIPTION  Initialize a new oclif CLI  This will add the necessary oclif bin files, add oclif config to package.json, and install @oclif/core and ts-node.EXAMPLES  Initialize a new CLI in the current directory    $ oclif init  Initialize a new CLI in a different directory    $ oclif init --output-dir "/path/to/existing/project"  Supply answers for specific prompts    $ oclif init --topic-separator colons --bin mycli
Hope you enjoy the new command! If you come across any issues or have any new ideas for this command, head over to the oclif/oclif repo and open a new issue.
All our best,
The oclif teamoclif Spring 2024 UpdateMarch 29, 2024 · 4 min readHello oclif developers! It's been a while since we last uploaded a blog - and a lot has happened.
We've been focusing on these high-level areas over the past couple of years:

Improving @oclif/core
ESM Support
Improving and revitalizing oclif.io
Re-engaging the oclif community

Improving @oclif/core​
Since we announced @oclif/core over three years ago, we've released two new major versions, each packed with lots of features that we're really excited about.
Here are some of these changes:

Full support for ESM and interoperability with CommonJS (more on this topic below).
Configurable command discovery strategies that give you more control over how commands are loaded at runtime. Check out the docs.
A new preparse hook that allows you to manipulate the provided arguments before they're parsed. Salesforce used this hook to implement a neat --flags-dir feature that translates local files into flags.
A new Performance class that you can use to track performance inside of @oclif/core and your own CLI or plugin. Check out the docs.
A new flag type, Flags.option, that lets you define a flag with a preset list of options. Typescript then uses the options to infer the flag's type.
Flags now have a relationship property that allows you to define more complex relationships between flags. Check out the flags docs for more information.
Flags now have a defaultHelp property that allows you to set the human readable default value in the command help. This property is useful when your flag's parse method returns a complex type, such as an object or a class. Check out the flags docs for more.
Commands now have a hiddenAliases property that allows you to define aliases that you want to hide from the user. The property is super helpful when you're trying to wean users off a deprecated command.
You can now use bun or tsx as dev runtimes (as opposed to node or ts-node).
A command's usage, args, and flags are now shown whenever a user forgets to provide a required arg or flag, or when they provided a non-existent flag.

If you need help migrating to the latest version, head over to core's README which has links to the migration guides. Feel free to open a new discussion if you need more hands-on help from us or the community.
ESM Support​
Version 3 of @oclif/core introduced full support for developing ESM plugins and CLIs. It also offered full support for interoperability between CommonJS and ESM plugins.
Put more simply, you can now migrate your CLI to ESM while keeping individual plugins in CommonJS (or vice versa). The upgrade path is now much simpler for you. You also don't need to worry about any community plugins that have migrated to ESM before you did (such as all the @oclif plugins) or are staunchly sticking with CommonJS for the foreseeable future.
Read more about this topic here.
Improving and Revitalizing oclif.io​
Another area of focus for us has been improving our documentation site, oclif.io.
While improving the quality and accuracy of the documentation was our priority, we also took the time to upgrade to the latest version of docusaurus. This new version gave our site a much-needed facelift, as well as cool new features such as dark mode and announcements.
If you have any feedback or are running into issues, we want to hear about it. Just create an issue in the oclif.io repo.
Re-engaging the oclif Community​
Lastly, our biggest priority at the moment is to re-engage the oclif community. We understand how frustrating it has been over the years to see your issues and pull requests go unacknowledged. We apologize for not prioritizing the community, and are earnestly trying to make sure that every issue and pull request gets the attention it deserves going forward.
We also opened up GitHub discussions for @oclif/core and the oclif CLI, where you can now post your questions or ideas. We hope you take advantage of them, we love hearing from you!
One last thing: we intend to publicly post our roadmap so you have more visibility into what we're working on. Stay tuned!
All our best,
The oclif teamAnnouncing oclif v2!January 12, 2022 · 5 min readHello and happy new year! It's our great pleasure to announce that we have released oclif v2, which uses the new @oclif/core library! 🎉
oclif v2 includes many changes that improve the experience of both creating and using an oclif CLI.
Going forward, we don't plan to make any updates to oclif v1 and its corresponding libraries, except for critical security fixes. See the compatibility matrix for a list of these libraries. In order to give developers time to migrate from v1 to v2, we're not completely dropping support yet. But at some point in the future we'll archive the v1 repositories and deprecate their versions on npm.
What’s changing?​
Repository Changes​
All repositories under the oclif org now use main as their primary branch and oclif-v1 as the legacy branch. The main  branch corresponds to oclif v2 and the oclif-v1 branch to oclif v1. If you find any repos that don’t have a main branch, you can safely assume that they're not used in oclif v2 and will be deprecated in the future.
Consolidating Tools & Libraries​
The oclif-dev CLI has now been incorporated into oclif. You now no longer need to install a separate package to manage your entire CLI’s lifecycle.
The following libraries have been consolidated under @oclif/core and will be deprecated at some point in the future. Read the migration guide to learn how to update your CLI or plugin to use the new core library.

@oclif/command
@oclif/config
@oclif/error
@oclif/help
@oclif/parser

No more single vs multi command CLIs​
There's only one "type" of oclif v2 CLI, but it can have as few or as many commands as a developer wants. As a result, there’s only one command to generate CLIs, oclif generate, as opposed to the old oclif single and oclif multi commands.
Node > 12​
To ensure oclif CLIs are as secure as possible, all v2 libraries and plugins support only Node 12 or higher as of now. Going forward, they'll support only Node Maintenance or higher, as defined by Node's release schedule here: https://nodejs.org/en/about/releases/.
What’s new?​
New example CLI​
oclif-hello-world is our new example repo. This is also the repo that's used as a template when running oclif generate to create a new CLI. This repo will always be able to be referenced as an example of what an oclif v2 CLI should look like.
Spaced commands​
oclif CLIs can now use spaces, instead of colons, to separate topics and subcommands. To enable this feature, simply add “topicSeparator": " " to the oclif config in your package.json. See an example in our example repo.
// Old commands that use :$ mycli do:something
// New spaced commands$ mycli do something

Note: Spaced commands are backwards compatible. So if you enable spaced commands for your CLI, users will still be able to use : as a separator. This ensures that any existing scripts don't break.

New Help Output​
We’ve revamped the way command help is outputted to the terminal, making it both easier to implement and easier to read. See the difference between the old help output on the left and the new help output on the right in the screenshots below.
oclif v1oclif v2
Notice that there are new sections for flags and global flags, examples are displayed with better spacing, and there is a section at the bottom called Configuration Variables. This Configuration Variables section is not part of the new help by default. But we've added support for custom help sections, which is what the sf CLI uses to create the new section.
Async Command Parsing​
We’ve also improved the performance of new CLIs by rewriting how commands are parsed on initialization. The new parser is asynchronous, which makes CLIs with a lot of commands or installed  plugins much faster.
What’s coming next?​
Part of our charter for the release of oclif v2 includes improving our engagement with the oclif community. We know that over the past couple of years we’ve reduced our involvement, and a lot of issues and PRs have languished in limbo. Hopefully you’ve already seen increased activity and responses from oclif maintainers recently, but if you haven’t, please don’t hesitate to ping us by tagging @admins in oclif repos.
We also want to start interviewing members of the oclif community to acquire feedback and prioritize the features and fixes you deem most important!
Best,
The oclif team

Reference material​
Migration Guide​
This guide explains how to upgrade a CLI or plugin from the old oclif v1 libraries to the new @oclif/core library that oclif v2 uses.
https://github.com/oclif/core/blob/main/MIGRATION.md
Compatibility Matrix​
The following matrix shows how the v1 libraries and plugins relate to the new v2 ones. Use this matrix as a guide to know what to drop and which versions to switch when upgrading your plugins and CLIs to v2.
oclif "v1"oclif "v2"Utility CLIsoclif@<2@oclif/dev-cli@<2oclif@>=2Main packages@oclif/command@oclif/config@oclif/errors@oclif/parser@oclif/plugin-help@oclif/core@>=1Node LTSNode v8-14Node v12+ (at time of writing)TypeScripttypescript@<4typescript@>=4Main plugins@oclif/plugin-autocomplete@<1@oclif/plugin-commands@<2@oclif/plugin-help@<4@oclif/plugin-not-found@<2@oclif/plugin-plugins@<2@oclif/plugin-update@<2plugin-warn-if-update-available@<2plugin-which@<2@oclif/plugin-autocomplete@>=1@oclif/plugin-commands@>=2@oclif/plugin-help@>=4@oclif/plugin-not-found@>=2@oclif/plugin-plugins@>=2@oclif/plugin-update@>=2@oclif/plugin-warn-if-update-available@>=2@oclif/plugin-which@>=2Introducing @oclif/coreMarch 1, 2021 · 3 min readGreetings!
We hope this blog post finds you well.
Introducing...​
We are excited to announce the next iteration of the oclif project today: @oclif/core.
We have learned a lot in the last three years of developing oclif, developing on oclif and supporting millions of command runs a day via Heroku and Salesforce CLIs.
@oclif/core ("Core") simplifies the oclif development experience and introduces highly requested new features.
Core combines the essential oclif packages into one "core" package, aptly named @oclif/core.
Core also introduces:

A default command option
Colon or space command syntax
Async command parsing
Command piping to arguments

With the introduction of default command functionality, Core simplifies the oclif project and removes the notion of single or multi command CLIs. Core CLIs can have 1 or many commands.
Along with Core, we moved the oclif-dev CLI into the oclif CLI creating a single "utility" CLI. This CLI also introduces a new AWS S3 compatible publishing scheme.
What to expect in the near future​
Core is in pre-release beta and being actively developed for new internal Salesforce CLIs.
Much documentation needs to be written in the coming months including migration paths. Migration onto Core should be as painless as possible with many exports remaining entirely unchanged. Look for forthcoming blog posts and documentation on oclif.io.
Early this summer, tentively June 1, we will release Core v1. Core's release will coincide with major bumps to many other oclif plugin packages. See the compatibility matrix below.
At Core's v1 release, the current "main" oclif packages (namely: command, config, errors & parser) will go into maintenance mode until Jan 2022. They will receive only bug and security fixes and they remain compatible with current versions of the oclif and oclif-dev CLIs. Afterwhich, they will be archived.
Companioning Core, the next major release of the oclif CLI (literally oclif@2) will generate Core CLIs.
Going forward​
We are excited to release Core! We invite you to poke around the Core repo. It may appear to be a big change but Core keeps what you already enjoy about oclif while reducing development complexity, project dependencies, package coupling and bundle size and introduces many requested features previously too prickly to weave into the current oclif architecture.
Best,
The oclif team
Reference: Compatibility matrix​
oclif "v1"oclif "Core"Utility CLIsoclif@<2@oclif/dev-cli@<2oclif@>=2Main packages@oclif/core@<2@oclif/config@<2@oclif/errors@<2@oclif/parser@<4@oclif/plugin-help@<4@oclif/core@>=1Node LTSNode v8-14Node v12+TypeScripttypescript@<4typescript@>=4Main plugins@oclif/plugin-autocomplete@<1@oclif/plugin-commands@<2@oclif/plugin-help@<4@oclif/plugin-not-found@<2@oclif/plugin-plugins@<2@oclif/plugin-update@<2plugin-warn-if-update-available@<2plugin-which@<2@oclif/plugin-autocomplete@>=2@oclif/plugin-commands@>=2@oclif/plugin-help@>=4@oclif/plugin-not-found@>=2@oclif/plugin-plugins@>=2@oclif/plugin-update@>=2@oclif/plugin-warn-if-update-available@>=2@oclif/plugin-which@>=2oclif Summer 2020 UpdateAugust 26, 2020 · 2 min readHello oclif developers! We hope you are all doing well.
Earlier this year, we started our planning for oclifconf v2 and, like all conference, had to change course. We opted not to hold a virtual conference, however, we wanted to take some time to highlight a few oclif features shipped this year.
Feature: Help templating​
One of the most requested features, help templating enables oclif developers to customize the help output for their CLI.
Read the announcement.
Feature: Custom error delegation​
This feature both improved how oclif throws and handles errors and allows oclif developers to overwrite or interject in oclif’s error handling.
Read the announcement.
Feature: postrun hooks​
We have added a new lifecycle event postrun. Your CLI can now run a hook after a command has ran.
See our hook documentation.
Feature: Root index command​
Previously, oclif would display CLI help if only the binary name with no command ID was invoked, oclif now supports a "root index" command. If present, a command defined at src/commands/index.ts will be run if no command ID is found.
1 million weekly downloads​
While exact oclif usage metrics are hard to pin down, we use npm download statistics of oclif packages as a rough approximation. Earlier this year, oclif's command package hit 1 million weekly downloads for the first time!
This year has been presented its challenges on everyone. We want to thank you, oclif developers, whom have taken the time to use and improve the oclif project. We look forward to seeing you all - in person - in the future!
All our best,
The oclif teamPretty Printable ErrorsJuly 1, 2020 · One min readOften CLIs are used as handy tools and when things go wrong it’s useful to have additional context. In oclif we have added a couple of additional properties that can show extra context to the users when an error is displayed. The code, ref and suggestions will now be displayed if they are included. This will work with an existing oclif CLI by adding the latest @oclif/errors and @oclif/core to the CLI's package.json dependencies.
For example, using this.error with the additional properties:
class TestError extends Command {  async run() {    this.error("An error has occurred!", {      code: "OCLIF_ERR",      ref: "https://oclif.io/docs/commands#thiserrormessage-string--error-options-code-string-exit-number",      suggestions: ["Use these extra properties to provide additional context"],    })  }}
would result with the following output:
›   Error: An error has occurred!›   Code: OCLIF_ERR›   Try this: Use these extra properties to provide additional context›   Reference: https://oclif.io/docs/commands#thiserrormessage-string--error-options-code-string-exit-number
If these properties are not provided then nothing changes and the CLI will continue to display the single error message output as it did before. Additionally, as part of this exercise we’ve added documentation around Error Handling in oclif which should come in handy if the need arises to extend oclif’s default handling of errors.Customizing Help in oclifMay 5, 2020 · 2 min readOut of the box oclif provides a great help experience for CLIs.
But what if, as an oclif developer, you want to customize some or all of the output?
You can now customize your CLI's help output by implementing the HelpBase abstract class.
Getting started with custom help​
If you have not done so yet, update @oclif/core.
$ yarn add --latest @oclif/core
To get started, first define the filepath to your help class in oclif's config in package.json. This is a relative path to the help class, without a file extension.
For this example, the help class will be created in a file at "[project root]/src/help.ts".
{  // ...  "oclif": {    "helpClass": "./lib/help"    // ...  }  // ...}
From here there are two paths, implement the HelpBase abstract class yourself or overwrite the parts of the default Help class you want to customize (ex: how command usage is displayed). We recommend the latter approach but cover both in the new Help Classes docs.
Separating TOPICS & COMMANDS in the new default Help class​
Previously, topics and child commands were listed in help output under a single list heading called "COMMANDS". But we found this can be slightly confusing. Some topics are commands also (a.k.a. topic-commands) while others are simply organizational namespacing (and when ran just show their help).
The new default Help class splits the list of children into distinct lists of "TOPICS" and "COMMANDS", with the possibility of an item appearing in both if it a topic-command. This makes it clearer what is expected to be ran - "COMMANDS" - and what is providing structure - "TOPICS" - when looking at the help output.
VERSION  plugin-help-example/0.0.0 darwin-x64 node-v12.12.0USAGE  $ plugin-help-example [COMMAND]TOPICS  topic  this is a topic and has child topics or commandsCOMMANDS  hello  describe the command here  help   display help for plugin-help-example
We look forward to seeing what custom help features you implement in your oclif CLIs with this new feature!oclif TSLint to ESLint MigrationDecember 5, 2019 · 3 min readBack in February of this year, plans were announced to deprecate TSLint in favor of ESLint. TSLint's goal has become to work toward a “unified developer experience” by supporting ESLint development going forward.
What has changed in oclif​
To keep inline with the community, oclif has transitioned to ESLint for all our core libraries as well as all our official plugins.
Starting in v1.15.x, oclif will now optionally generate projects with ESLint for both TypeScript and JavaScript CLI’s.
ESLint does require Node to be on stable LTS version, at the time of writing, Node 8.10.x, Node 10.13.x & Node 12.x.x.
How does this affect you​
Existing CLI’s are unchanged, but any newly generated CLI's will only give the option of using ESLint. If you are running tslint in your CLI, we recommend you switch to ESLint as well.
In migrating our projects we took the following steps (for an example of these changes see this pull request).


Install eslint
$ yarn add eslint eslint-config-oclif eslint-config-oclif-typescript --dev


Add eslint related files


$ echo '{  "extends": [    "oclif",    "oclif-typescript"  ],  "rules": {  }}' > .eslintrc


Remove tslint and related packages
$ yarn remove @oclif/tslint tslint


Remove tslint related configuration files
$ rm tslint.json


Change lint script in our package.json from something like:
"lint": "tsc -p test --noEmit && tslint -p test -t stylish"
to
"lint": "eslint . --ext .ts --config .eslintrc"


To preserve the test compile (tsc -p test --noEmit) we also made the following updates to our scripts:
"pretest": "tsc -p test --noEmit"
In some cases we had our posttest duplicating the same steps as our lint script so it’s cleaner to have it reference the lint job directly with:
"posttest": "yarn lint"

Run yarn lint --fix. This attempts to auto-fix any linting violations automatically. In the case an auto-fix isn’t available it should be fixed manually or ignored (see the eslint configuration doc for more information)
Do a search in the codebase for tslint and remove any unnecessary tslint disabling comments, like:

/* tslint:disable:object-literal-sort-keys */
If you are on a version of Node that is not supported by ESLint, you will also need to update your Node engine. ESLint supports Node 8, 10, and 12 so you should upgrade to the most recent Node version compatible with your CLI and also supported by ESLint (see ESLint's Installation and Usage instructions).
When will this take effect​
These changes have taken effect in oclif v1.15.1. When you generate a new CLI or plugin it will now contain configuration for ESLint instead of TSLint.oclif's Current Node SupportOctober 31, 2019 · 3 min readTo maintain a healthy project trajectory, oclif follows and supports Node Active LTS release, currently Node 10 & Node 12. This means ensuring that oclif continues to play nice with coming Active LTS Node versions and other packages in the ecosystem. Moving forward also means leaving older versions behind. Starting in 2020, Node will stop maintaining Node 8 and it is our intent at that time to also follow suit. Let’s take a look at a few ways we will be supporting these changes.
CI Environments​
CLIs created with the oclif cli going forward will be generated with a CircleCI configuration with Node 10 & 12 and an Appveyor configuration using Node 10. We have also added Node latest to CircleCi to be an early warning detection against coming Node changes (Node latest is managed by CircleCI).
We have already updated every oclif repo's CI configs to reflect this.
If your existing CLI uses either Appveyor or CircleCI you can update your config files also, like so:
.circleci/config.yml​
Your CircleCI config should contain a node-latest job, aliased as test. From this, there should be two extensions of this job for the Active LTS Node versions, Node 10 and Node 12.
  node-10:    <<: *node-latest    docker:      - image: node:10  node-12:    <<: *node-latest    docker:      - image: node:12
Notice that these declarations only change the Docker Node images used to run that job.
Additionally, the jobs listed within workflows must also be updated to reflect our changes in configuration:
    jobs:      - node-latest      - node-10      - node-12
appveyor.yml​
For appveyor we are currently only testing the oldest Active LTS Node version, Node 10. Update the nodejs_version proppert in your appveyor.yml file to reflect this.
environment:  nodejs_version: "10"
Deprecating Node 8 & Updating packge.json engines​
In Jan 2020, Node will end its Node 8 maintenance. We will follow suit by setting the package.json engine property in oclif packages to >=10 and bumping the package's major versions.
Depending on how you ship your CLI you may wish to also bump the engines version in your CLI's package.json. You can read more about the implications of the engines property configuration in the npm documentation.
Also consider distributing your CLI with its own Node version.
Packaged Node Version​
When using dev-cli to pack your CLI it will use the Node version as specified in your package.json under the oclif.update.node.version property. This value should reflect an Active LTS Node version (dev-cli does not currently enforce versions).
Supporting the future​
As a community we may discover bumps along the way as we upgrade. If you notice something related to oclif please feel free to open an issue or submit a pull request under the relevant oclif package within the org.
We look forward to using the latest from Node and the community and keeping oclif healthy along the way.oclifconf 2019: A RecapSeptember 16, 2019 · 4 min readIn May, Heroku and Salesforce Open Source organized oclifconf, a conference for developers & product managers building CLI tools on top of the open source oclif framework. The speakers came from various tech companies, such as Adobe, Netlify, and Apollo, who have already built amazing CLI experiences. The topics covered everything from the incredible capabilities oclif has unlocked, to the community-built plugins extending its functionality, and even what the behavior of an adaptive CLI tool might look like.
Below is a listing of all of the talks from the event, along with a short summary. Enjoy!
The future of oclif by Jeff Dickey​

In its relatively short lifetime, oclif has already inspired many developers and companies to adopt its framework as a means for implementing their own command-line tooling. In this talk, Jeff Dickey, an oclif founding team member, recaps the project's history and inspiration. He also looks towards the future and outlines some features and improvements that the tool could adapt. This isn't so much a definitive roadmap of where oclif is headed, but rather, a call to inspiration for developers eager to contribute! And if you are interested in contributing, check out the open issues in the oclif GitHub repo and come say "Hello!" on Spectrum Chat.
Open Source Citizenship by Josh Simmons​

When it comes to open source, it's more than just individuals now. More and more frequently, large corporations are contributing to projects by donating to contributors, sponsoring events, or upstreaming contributions. But keeping open source projects and communities healthy requires more than just money and brainpower. Josh Simmons surveyed multiple open source communities and relays his findings as to what help maintainers and contributors actually need in this talk.
Building an enterprise-grade CLI with oclif by Thomas Dvornik​

Security and performance are all about trust. While oclif is an extremely extensible framework for building CLI tooling, there are additional requirements to fulfill for enterprise businesses to adopt it that might not be necessary for individual developers. Thomas Dvornik outlines what he and his colleagues at Salesforce have implemented as plugins to oclif to satisfy these needs, including encrypted OAuth, plugin signing, lazy loading dependencies, synchronizing weekly releases and deprecations across dozens of repositories, and establishing cross-team coding and documentation standards.
How Adobe I/O built an extensible CLI with oclif by Jesse MacFadyen​

Perhaps oclif's most appealing feature is its support for plugins. In Cordova's case, they've created a sophisticated telemetry system that helps Adobe developers see which commands users are using--and reports on which ones are erroring out. By embedding a feedback system into the tool, users are even able to quickly send their suggestions to a form, without ever leaving the terminal. Jesse MacFadyen demonstrates how oclif's plugin system can work beyond simply executing commands.
Integrating oclif with GraphQL and Apollo by Evans Hauser​

For Evans Hauser and the team at Apollo, oclif is best thought of as "React for the CLI." As a client paired with a strongly-typed API contract to a server, it can deliver structured and consistent commands to retrieve external data. What better mechanism to use for this transfer than GraphQL, a framework which empowers the client to ask precisely for the data it needs, and nothing more?
Adaptive Intent-based CLI State Machines by Shawn Wang​

In designing oclif, Jeff Dickey wrote out 12 CLI factors to keep in mind. In this talk, Shawn Wang outlines a 13th: state. State is hard, because it depends on context, and context depends on understanding what a user intends to do, not what they are asking. Shawn is working towards enabling oclif to better understand the commands a user has entered, so that it can predict and interpret future commands that might be entered next. This would enable CLI tools to not just interpret a users' commands, but to also interpret their intent.\n\nIntroducing `oclif init` commandApril 10, 2024 · 2 min readThanks to the contribution of @joshcanhelp we released a new command for the oclif CLI called oclif init in version 4.8.0
The oclif init command allows you to initialize oclif in an existing project directory by adding the bare minimum requirements: a few pieces of configuration, bin scripts, and a couple of dependencies (@oclif/core and ts-node). This is slightly different from oclif generate, which will create an entirely new oclif project based on our templates.
oclif init will add the following:

bin scripts: bin/run.js, bin/run.cmd, bin/dev.js, and bin/dev.cmd
oclif section to package.json with bin, dirname, commands, and topicSeparator set (See Configuring Your CLI for more)
@oclif/core to dependencies in your package.json (if it's not already there)
ts-node to devDependencies in your package.json (if it's not already there)

Once you've initialized oclif, you can use the bin scripts to execute your CLI. You can also use the other oclif commands like oclif generate command and oclif generate hook to start adding new functionality.

❯ oclif init --helpInitialize a new oclif CLIUSAGE  $ oclif init [--bin <value>] [--module-type ESM|CommonJS] [--package-manager npm|yarn|pnpm] [--topic-separator    colons|spaces] [-d <value>] [-y]FLAGS  -d, --output-dir=<value>        Directory to initialize the CLI in.  -y, --yes                       Use defaults for all prompts. Individual flags will override defaults.      --bin=<value>               Supply answer for prompt: Command bin name the CLI will export      --module-type=<option>      Supply answer for prompt: Select a module type                                  <options: ESM|CommonJS>      --package-manager=<option>  Supply answer for prompt: Select a package manager                                  <options: npm|yarn|pnpm>      --topic-separator=<option>  Supply answer for prompt: Select a topic separator                                  <options: colons|spaces>DESCRIPTION  Initialize a new oclif CLI  This will add the necessary oclif bin files, add oclif config to package.json, and install @oclif/core and ts-node.EXAMPLES  Initialize a new CLI in the current directory    $ oclif init  Initialize a new CLI in a different directory    $ oclif init --output-dir "/path/to/existing/project"  Supply answers for specific prompts    $ oclif init --topic-separator colons --bin mycli
Hope you enjoy the new command! If you come across any issues or have any new ideas for this command, head over to the oclif/oclif repo and open a new issue.
All our best,
The oclif teamoclif Spring 2024 UpdateMarch 29, 2024 · 4 min readHello oclif developers! It's been a while since we last uploaded a blog - and a lot has happened.
We've been focusing on these high-level areas over the past couple of years:

Improving @oclif/core
ESM Support
Improving and revitalizing oclif.io
Re-engaging the oclif community

Improving @oclif/core​
Since we announced @oclif/core over three years ago, we've released two new major versions, each packed with lots of features that we're really excited about.
Here are some of these changes:

Full support for ESM and interoperability with CommonJS (more on this topic below).
Configurable command discovery strategies that give you more control over how commands are loaded at runtime. Check out the docs.
A new preparse hook that allows you to manipulate the provided arguments before they're parsed. Salesforce used this hook to implement a neat --flags-dir feature that translates local files into flags.
A new Performance class that you can use to track performance inside of @oclif/core and your own CLI or plugin. Check out the docs.
A new flag type, Flags.option, that lets you define a flag with a preset list of options. Typescript then uses the options to infer the flag's type.
Flags now have a relationship property that allows you to define more complex relationships between flags. Check out the flags docs for more information.
Flags now have a defaultHelp property that allows you to set the human readable default value in the command help. This property is useful when your flag's parse method returns a complex type, such as an object or a class. Check out the flags docs for more.
Commands now have a hiddenAliases property that allows you to define aliases that you want to hide from the user. The property is super helpful when you're trying to wean users off a deprecated command.
You can now use bun or tsx as dev runtimes (as opposed to node or ts-node).
A command's usage, args, and flags are now shown whenever a user forgets to provide a required arg or flag, or when they provided a non-existent flag.

If you need help migrating to the latest version, head over to core's README which has links to the migration guides. Feel free to open a new discussion if you need more hands-on help from us or the community.
ESM Support​
Version 3 of @oclif/core introduced full support for developing ESM plugins and CLIs. It also offered full support for interoperability between CommonJS and ESM plugins.
Put more simply, you can now migrate your CLI to ESM while keeping individual plugins in CommonJS (or vice versa). The upgrade path is now much simpler for you. You also don't need to worry about any community plugins that have migrated to ESM before you did (such as all the @oclif plugins) or are staunchly sticking with CommonJS for the foreseeable future.
Read more about this topic here.
Improving and Revitalizing oclif.io​
Another area of focus for us has been improving our documentation site, oclif.io.
While improving the quality and accuracy of the documentation was our priority, we also took the time to upgrade to the latest version of docusaurus. This new version gave our site a much-needed facelift, as well as cool new features such as dark mode and announcements.
If you have any feedback or are running into issues, we want to hear about it. Just create an issue in the oclif.io repo.
Re-engaging the oclif Community​
Lastly, our biggest priority at the moment is to re-engage the oclif community. We understand how frustrating it has been over the years to see your issues and pull requests go unacknowledged. We apologize for not prioritizing the community, and are earnestly trying to make sure that every issue and pull request gets the attention it deserves going forward.
We also opened up GitHub discussions for @oclif/core and the oclif CLI, where you can now post your questions or ideas. We hope you take advantage of them, we love hearing from you!
One last thing: we intend to publicly post our roadmap so you have more visibility into what we're working on. Stay tuned!
All our best,
The oclif teamAnnouncing oclif v2!January 12, 2022 · 5 min readHello and happy new year! It's our great pleasure to announce that we have released oclif v2, which uses the new @oclif/core library! 🎉
oclif v2 includes many changes that improve the experience of both creating and using an oclif CLI.
Going forward, we don't plan to make any updates to oclif v1 and its corresponding libraries, except for critical security fixes. See the compatibility matrix for a list of these libraries. In order to give developers time to migrate from v1 to v2, we're not completely dropping support yet. But at some point in the future we'll archive the v1 repositories and deprecate their versions on npm.
What’s changing?​
Repository Changes​
All repositories under the oclif org now use main as their primary branch and oclif-v1 as the legacy branch. The main  branch corresponds to oclif v2 and the oclif-v1 branch to oclif v1. If you find any repos that don’t have a main branch, you can safely assume that they're not used in oclif v2 and will be deprecated in the future.
Consolidating Tools & Libraries​
The oclif-dev CLI has now been incorporated into oclif. You now no longer need to install a separate package to manage your entire CLI’s lifecycle.
The following libraries have been consolidated under @oclif/core and will be deprecated at some point in the future. Read the migration guide to learn how to update your CLI or plugin to use the new core library.

@oclif/command
@oclif/config
@oclif/error
@oclif/help
@oclif/parser

No more single vs multi command CLIs​
There's only one "type" of oclif v2 CLI, but it can have as few or as many commands as a developer wants. As a result, there’s only one command to generate CLIs, oclif generate, as opposed to the old oclif single and oclif multi commands.
Node > 12​
To ensure oclif CLIs are as secure as possible, all v2 libraries and plugins support only Node 12 or higher as of now. Going forward, they'll support only Node Maintenance or higher, as defined by Node's release schedule here: https://nodejs.org/en/about/releases/.
What’s new?​
New example CLI​
oclif-hello-world is our new example repo. This is also the repo that's used as a template when running oclif generate to create a new CLI. This repo will always be able to be referenced as an example of what an oclif v2 CLI should look like.
Spaced commands​
oclif CLIs can now use spaces, instead of colons, to separate topics and subcommands. To enable this feature, simply add “topicSeparator": " " to the oclif config in your package.json. See an example in our example repo.
// Old commands that use :$ mycli do:something
// New spaced commands$ mycli do something

Note: Spaced commands are backwards compatible. So if you enable spaced commands for your CLI, users will still be able to use : as a separator. This ensures that any existing scripts don't break.

New Help Output​
We’ve revamped the way command help is outputted to the terminal, making it both easier to implement and easier to read. See the difference between the old help output on the left and the new help output on the right in the screenshots below.
oclif v1oclif v2
Notice that there are new sections for flags and global flags, examples are displayed with better spacing, and there is a section at the bottom called Configuration Variables. This Configuration Variables section is not part of the new help by default. But we've added support for custom help sections, which is what the sf CLI uses to create the new section.
Async Command Parsing​
We’ve also improved the performance of new CLIs by rewriting how commands are parsed on initialization. The new parser is asynchronous, which makes CLIs with a lot of commands or installed  plugins much faster.
What’s coming next?​
Part of our charter for the release of oclif v2 includes improving our engagement with the oclif community. We know that over the past couple of years we’ve reduced our involvement, and a lot of issues and PRs have languished in limbo. Hopefully you’ve already seen increased activity and responses from oclif maintainers recently, but if you haven’t, please don’t hesitate to ping us by tagging @admins in oclif repos.
We also want to start interviewing members of the oclif community to acquire feedback and prioritize the features and fixes you deem most important!
Best,
The oclif team

Reference material​
Migration Guide​
This guide explains how to upgrade a CLI or plugin from the old oclif v1 libraries to the new @oclif/core library that oclif v2 uses.
https://github.com/oclif/core/blob/main/MIGRATION.md
Compatibility Matrix​
The following matrix shows how the v1 libraries and plugins relate to the new v2 ones. Use this matrix as a guide to know what to drop and which versions to switch when upgrading your plugins and CLIs to v2.
oclif "v1"oclif "v2"Utility CLIsoclif@<2@oclif/dev-cli@<2oclif@>=2Main packages@oclif/command@oclif/config@oclif/errors@oclif/parser@oclif/plugin-help@oclif/core@>=1Node LTSNode v8-14Node v12+ (at time of writing)TypeScripttypescript@<4typescript@>=4Main plugins@oclif/plugin-autocomplete@<1@oclif/plugin-commands@<2@oclif/plugin-help@<4@oclif/plugin-not-found@<2@oclif/plugin-plugins@<2@oclif/plugin-update@<2plugin-warn-if-update-available@<2plugin-which@<2@oclif/plugin-autocomplete@>=1@oclif/plugin-commands@>=2@oclif/plugin-help@>=4@oclif/plugin-not-found@>=2@oclif/plugin-plugins@>=2@oclif/plugin-update@>=2@oclif/plugin-warn-if-update-available@>=2@oclif/plugin-which@>=2Introducing @oclif/coreMarch 1, 2021 · 3 min readGreetings!
We hope this blog post finds you well.
Introducing...​
We are excited to announce the next iteration of the oclif project today: @oclif/core.
We have learned a lot in the last three years of developing oclif, developing on oclif and supporting millions of command runs a day via Heroku and Salesforce CLIs.
@oclif/core ("Core") simplifies the oclif development experience and introduces highly requested new features.
Core combines the essential oclif packages into one "core" package, aptly named @oclif/core.
Core also introduces:

A default command option
Colon or space command syntax
Async command parsing
Command piping to arguments

With the introduction of default command functionality, Core simplifies the oclif project and removes the notion of single or multi command CLIs. Core CLIs can have 1 or many commands.
Along with Core, we moved the oclif-dev CLI into the oclif CLI creating a single "utility" CLI. This CLI also introduces a new AWS S3 compatible publishing scheme.
What to expect in the near future​
Core is in pre-release beta and being actively developed for new internal Salesforce CLIs.
Much documentation needs to be written in the coming months including migration paths. Migration onto Core should be as painless as possible with many exports remaining entirely unchanged. Look for forthcoming blog posts and documentation on oclif.io.
Early this summer, tentively June 1, we will release Core v1. Core's release will coincide with major bumps to many other oclif plugin packages. See the compatibility matrix below.
At Core's v1 release, the current "main" oclif packages (namely: command, config, errors & parser) will go into maintenance mode until Jan 2022. They will receive only bug and security fixes and they remain compatible with current versions of the oclif and oclif-dev CLIs. Afterwhich, they will be archived.
Companioning Core, the next major release of the oclif CLI (literally oclif@2) will generate Core CLIs.
Going forward​
We are excited to release Core! We invite you to poke around the Core repo. It may appear to be a big change but Core keeps what you already enjoy about oclif while reducing development complexity, project dependencies, package coupling and bundle size and introduces many requested features previously too prickly to weave into the current oclif architecture.
Best,
The oclif team
Reference: Compatibility matrix​
oclif "v1"oclif "Core"Utility CLIsoclif@<2@oclif/dev-cli@<2oclif@>=2Main packages@oclif/core@<2@oclif/config@<2@oclif/errors@<2@oclif/parser@<4@oclif/plugin-help@<4@oclif/core@>=1Node LTSNode v8-14Node v12+TypeScripttypescript@<4typescript@>=4Main plugins@oclif/plugin-autocomplete@<1@oclif/plugin-commands@<2@oclif/plugin-help@<4@oclif/plugin-not-found@<2@oclif/plugin-plugins@<2@oclif/plugin-update@<2plugin-warn-if-update-available@<2plugin-which@<2@oclif/plugin-autocomplete@>=2@oclif/plugin-commands@>=2@oclif/plugin-help@>=4@oclif/plugin-not-found@>=2@oclif/plugin-plugins@>=2@oclif/plugin-update@>=2@oclif/plugin-warn-if-update-available@>=2@oclif/plugin-which@>=2oclif Summer 2020 UpdateAugust 26, 2020 · 2 min readHello oclif developers! We hope you are all doing well.
Earlier this year, we started our planning for oclifconf v2 and, like all conference, had to change course. We opted not to hold a virtual conference, however, we wanted to take some time to highlight a few oclif features shipped this year.
Feature: Help templating​
One of the most requested features, help templating enables oclif developers to customize the help output for their CLI.
Read the announcement.
Feature: Custom error delegation​
This feature both improved how oclif throws and handles errors and allows oclif developers to overwrite or interject in oclif’s error handling.
Read the announcement.
Feature: postrun hooks​
We have added a new lifecycle event postrun. Your CLI can now run a hook after a command has ran.
See our hook documentation.
Feature: Root index command​
Previously, oclif would display CLI help if only the binary name with no command ID was invoked, oclif now supports a "root index" command. If present, a command defined at src/commands/index.ts will be run if no command ID is found.
1 million weekly downloads​
While exact oclif usage metrics are hard to pin down, we use npm download statistics of oclif packages as a rough approximation. Earlier this year, oclif's command package hit 1 million weekly downloads for the first time!
This year has been presented its challenges on everyone. We want to thank you, oclif developers, whom have taken the time to use and improve the oclif project. We look forward to seeing you all - in person - in the future!
All our best,
The oclif teamPretty Printable ErrorsJuly 1, 2020 · One min readOften CLIs are used as handy tools and when things go wrong it’s useful to have additional context. In oclif we have added a couple of additional properties that can show extra context to the users when an error is displayed. The code, ref and suggestions will now be displayed if they are included. This will work with an existing oclif CLI by adding the latest @oclif/errors and @oclif/core to the CLI's package.json dependencies.
For example, using this.error with the additional properties:
class TestError extends Command {  async run() {    this.error("An error has occurred!", {      code: "OCLIF_ERR",      ref: "https://oclif.io/docs/commands#thiserrormessage-string--error-options-code-string-exit-number",      suggestions: ["Use these extra properties to provide additional context"],    })  }}
would result with the following output:
›   Error: An error has occurred!›   Code: OCLIF_ERR›   Try this: Use these extra properties to provide additional context›   Reference: https://oclif.io/docs/commands#thiserrormessage-string--error-options-code-string-exit-number
If these properties are not provided then nothing changes and the CLI will continue to display the single error message output as it did before. Additionally, as part of this exercise we’ve added documentation around Error Handling in oclif which should come in handy if the need arises to extend oclif’s default handling of errors.Customizing Help in oclifMay 5, 2020 · 2 min readOut of the box oclif provides a great help experience for CLIs.
But what if, as an oclif developer, you want to customize some or all of the output?
You can now customize your CLI's help output by implementing the HelpBase abstract class.
Getting started with custom help​
If you have not done so yet, update @oclif/core.
$ yarn add --latest @oclif/core
To get started, first define the filepath to your help class in oclif's config in package.json. This is a relative path to the help class, without a file extension.
For this example, the help class will be created in a file at "[project root]/src/help.ts".
{  // ...  "oclif": {    "helpClass": "./lib/help"    // ...  }  // ...}
From here there are two paths, implement the HelpBase abstract class yourself or overwrite the parts of the default Help class you want to customize (ex: how command usage is displayed). We recommend the latter approach but cover both in the new Help Classes docs.
Separating TOPICS & COMMANDS in the new default Help class​
Previously, topics and child commands were listed in help output under a single list heading called "COMMANDS". But we found this can be slightly confusing. Some topics are commands also (a.k.a. topic-commands) while others are simply organizational namespacing (and when ran just show their help).
The new default Help class splits the list of children into distinct lists of "TOPICS" and "COMMANDS", with the possibility of an item appearing in both if it a topic-command. This makes it clearer what is expected to be ran - "COMMANDS" - and what is providing structure - "TOPICS" - when looking at the help output.
VERSION  plugin-help-example/0.0.0 darwin-x64 node-v12.12.0USAGE  $ plugin-help-example [COMMAND]TOPICS  topic  this is a topic and has child topics or commandsCOMMANDS  hello  describe the command here  help   display help for plugin-help-example
We look forward to seeing what custom help features you implement in your oclif CLIs with this new feature!oclif TSLint to ESLint MigrationDecember 5, 2019 · 3 min readBack in February of this year, plans were announced to deprecate TSLint in favor of ESLint. TSLint's goal has become to work toward a “unified developer experience” by supporting ESLint development going forward.
What has changed in oclif​
To keep inline with the community, oclif has transitioned to ESLint for all our core libraries as well as all our official plugins.
Starting in v1.15.x, oclif will now optionally generate projects with ESLint for both TypeScript and JavaScript CLI’s.
ESLint does require Node to be on stable LTS version, at the time of writing, Node 8.10.x, Node 10.13.x & Node 12.x.x.
How does this affect you​
Existing CLI’s are unchanged, but any newly generated CLI's will only give the option of using ESLint. If you are running tslint in your CLI, we recommend you switch to ESLint as well.
In migrating our projects we took the following steps (for an example of these changes see this pull request).


Install eslint
$ yarn add eslint eslint-config-oclif eslint-config-oclif-typescript --dev


Add eslint related files


$ echo '{  "extends": [    "oclif",    "oclif-typescript"  ],  "rules": {  }}' > .eslintrc


Remove tslint and related packages
$ yarn remove @oclif/tslint tslint


Remove tslint related configuration files
$ rm tslint.json


Change lint script in our package.json from something like:
"lint": "tsc -p test --noEmit && tslint -p test -t stylish"
to
"lint": "eslint . --ext .ts --config .eslintrc"


To preserve the test compile (tsc -p test --noEmit) we also made the following updates to our scripts:
"pretest": "tsc -p test --noEmit"
In some cases we had our posttest duplicating the same steps as our lint script so it’s cleaner to have it reference the lint job directly with:
"posttest": "yarn lint"

Run yarn lint --fix. This attempts to auto-fix any linting violations automatically. In the case an auto-fix isn’t available it should be fixed manually or ignored (see the eslint configuration doc for more information)
Do a search in the codebase for tslint and remove any unnecessary tslint disabling comments, like:

/* tslint:disable:object-literal-sort-keys */
If you are on a version of Node that is not supported by ESLint, you will also need to update your Node engine. ESLint supports Node 8, 10, and 12 so you should upgrade to the most recent Node version compatible with your CLI and also supported by ESLint (see ESLint's Installation and Usage instructions).
When will this take effect​
These changes have taken effect in oclif v1.15.1. When you generate a new CLI or plugin it will now contain configuration for ESLint instead of TSLint.oclif's Current Node SupportOctober 31, 2019 · 3 min readTo maintain a healthy project trajectory, oclif follows and supports Node Active LTS release, currently Node 10 & Node 12. This means ensuring that oclif continues to play nice with coming Active LTS Node versions and other packages in the ecosystem. Moving forward also means leaving older versions behind. Starting in 2020, Node will stop maintaining Node 8 and it is our intent at that time to also follow suit. Let’s take a look at a few ways we will be supporting these changes.
CI Environments​
CLIs created with the oclif cli going forward will be generated with a CircleCI configuration with Node 10 & 12 and an Appveyor configuration using Node 10. We have also added Node latest to CircleCi to be an early warning detection against coming Node changes (Node latest is managed by CircleCI).
We have already updated every oclif repo's CI configs to reflect this.
If your existing CLI uses either Appveyor or CircleCI you can update your config files also, like so:
.circleci/config.yml​
Your CircleCI config should contain a node-latest job, aliased as test. From this, there should be two extensions of this job for the Active LTS Node versions, Node 10 and Node 12.
  node-10:    <<: *node-latest    docker:      - image: node:10  node-12:    <<: *node-latest    docker:      - image: node:12
Notice that these declarations only change the Docker Node images used to run that job.
Additionally, the jobs listed within workflows must also be updated to reflect our changes in configuration:
    jobs:      - node-latest      - node-10      - node-12
appveyor.yml​
For appveyor we are currently only testing the oldest Active LTS Node version, Node 10. Update the nodejs_version proppert in your appveyor.yml file to reflect this.
environment:  nodejs_version: "10"
Deprecating Node 8 & Updating packge.json engines​
In Jan 2020, Node will end its Node 8 maintenance. We will follow suit by setting the package.json engine property in oclif packages to >=10 and bumping the package's major versions.
Depending on how you ship your CLI you may wish to also bump the engines version in your CLI's package.json. You can read more about the implications of the engines property configuration in the npm documentation.
Also consider distributing your CLI with its own Node version.
Packaged Node Version​
When using dev-cli to pack your CLI it will use the Node version as specified in your package.json under the oclif.update.node.version property. This value should reflect an Active LTS Node version (dev-cli does not currently enforce versions).
Supporting the future​
As a community we may discover bumps along the way as we upgrade. If you notice something related to oclif please feel free to open an issue or submit a pull request under the relevant oclif package within the org.
We look forward to using the latest from Node and the community and keeping oclif healthy along the way.oclifconf 2019: A RecapSeptember 16, 2019 · 4 min readIn May, Heroku and Salesforce Open Source organized oclifconf, a conference for developers & product managers building CLI tools on top of the open source oclif framework. The speakers came from various tech companies, such as Adobe, Netlify, and Apollo, who have already built amazing CLI experiences. The topics covered everything from the incredible capabilities oclif has unlocked, to the community-built plugins extending its functionality, and even what the behavior of an adaptive CLI tool might look like.
Below is a listing of all of the talks from the event, along with a short summary. Enjoy!
The future of oclif by Jeff Dickey​

In its relatively short lifetime, oclif has already inspired many developers and companies to adopt its framework as a means for implementing their own command-line tooling. In this talk, Jeff Dickey, an oclif founding team member, recaps the project's history and inspiration. He also looks towards the future and outlines some features and improvements that the tool could adapt. This isn't so much a definitive roadmap of where oclif is headed, but rather, a call to inspiration for developers eager to contribute! And if you are interested in contributing, check out the open issues in the oclif GitHub repo and come say "Hello!" on Spectrum Chat.
Open Source Citizenship by Josh Simmons​

When it comes to open source, it's more than just individuals now. More and more frequently, large corporations are contributing to projects by donating to contributors, sponsoring events, or upstreaming contributions. But keeping open source projects and communities healthy requires more than just money and brainpower. Josh Simmons surveyed multiple open source communities and relays his findings as to what help maintainers and contributors actually need in this talk.
Building an enterprise-grade CLI with oclif by Thomas Dvornik​

Security and performance are all about trust. While oclif is an extremely extensible framework for building CLI tooling, there are additional requirements to fulfill for enterprise businesses to adopt it that might not be necessary for individual developers. Thomas Dvornik outlines what he and his colleagues at Salesforce have implemented as plugins to oclif to satisfy these needs, including encrypted OAuth, plugin signing, lazy loading dependencies, synchronizing weekly releases and deprecations across dozens of repositories, and establishing cross-team coding and documentation standards.
How Adobe I/O built an extensible CLI with oclif by Jesse MacFadyen​

Perhaps oclif's most appealing feature is its support for plugins. In Cordova's case, they've created a sophisticated telemetry system that helps Adobe developers see which commands users are using--and reports on which ones are erroring out. By embedding a feedback system into the tool, users are even able to quickly send their suggestions to a form, without ever leaving the terminal. Jesse MacFadyen demonstrates how oclif's plugin system can work beyond simply executing commands.
Integrating oclif with GraphQL and Apollo by Evans Hauser​

For Evans Hauser and the team at Apollo, oclif is best thought of as "React for the CLI." As a client paired with a strongly-typed API contract to a server, it can deliver structured and consistent commands to retrieve external data. What better mechanism to use for this transfer than GraphQL, a framework which empowers the client to ask precisely for the data it needs, and nothing more?
Adaptive Intent-based CLI State Machines by Shawn Wang​

In designing oclif, Jeff Dickey wrote out 12 CLI factors to keep in mind. In this talk, Shawn Wang outlines a 13th: state. State is hard, because it depends on context, and context depends on understanding what a user intends to do, not what they are asking. Shawn is working towards enabling oclif to better understand the commands a user has entered, so that it can predict and interpret future commands that might be entered next. This would enable CLI tools to not just interpret a users' commands, but to also interpret their intent.Older Entries\n\n\n\nIntroducing `oclif init` commandApril 10, 2024 · 2 min readThanks to the contribution of @joshcanhelp we released a new command for the oclif CLI called oclif init in version 4.8.0
The oclif init command allows you to initialize oclif in an existing project directory by adding the bare minimum requirements: a few pieces of configuration, bin scripts, and a couple of dependencies (@oclif/core and ts-node). This is slightly different from oclif generate, which will create an entirely new oclif project based on our templates.
oclif init will add the following:

bin scripts: bin/run.js, bin/run.cmd, bin/dev.js, and bin/dev.cmd
oclif section to package.json with bin, dirname, commands, and topicSeparator set (See Configuring Your CLI for more)
@oclif/core to dependencies in your package.json (if it's not already there)
ts-node to devDependencies in your package.json (if it's not already there)

Once you've initialized oclif, you can use the bin scripts to execute your CLI. You can also use the other oclif commands like oclif generate command and oclif generate hook to start adding new functionality.

❯ oclif init --helpInitialize a new oclif CLIUSAGE  $ oclif init [--bin <value>] [--module-type ESM|CommonJS] [--package-manager npm|yarn|pnpm] [--topic-separator    colons|spaces] [-d <value>] [-y]FLAGS  -d, --output-dir=<value>        Directory to initialize the CLI in.  -y, --yes                       Use defaults for all prompts. Individual flags will override defaults.      --bin=<value>               Supply answer for prompt: Command bin name the CLI will export      --module-type=<option>      Supply answer for prompt: Select a module type                                  <options: ESM|CommonJS>      --package-manager=<option>  Supply answer for prompt: Select a package manager                                  <options: npm|yarn|pnpm>      --topic-separator=<option>  Supply answer for prompt: Select a topic separator                                  <options: colons|spaces>DESCRIPTION  Initialize a new oclif CLI  This will add the necessary oclif bin files, add oclif config to package.json, and install @oclif/core and ts-node.EXAMPLES  Initialize a new CLI in the current directory    $ oclif init  Initialize a new CLI in a different directory    $ oclif init --output-dir "/path/to/existing/project"  Supply answers for specific prompts    $ oclif init --topic-separator colons --bin mycli
Hope you enjoy the new command! If you come across any issues or have any new ideas for this command, head over to the oclif/oclif repo and open a new issue.
All our best,
The oclif teamoclif Spring 2024 UpdateMarch 29, 2024 · 4 min readHello oclif developers! It's been a while since we last uploaded a blog - and a lot has happened.
We've been focusing on these high-level areas over the past couple of years:

Improving @oclif/core
ESM Support
Improving and revitalizing oclif.io
Re-engaging the oclif community

Improving @oclif/core​
Since we announced @oclif/core over three years ago, we've released two new major versions, each packed with lots of features that we're really excited about.
Here are some of these changes:

Full support for ESM and interoperability with CommonJS (more on this topic below).
Configurable command discovery strategies that give you more control over how commands are loaded at runtime. Check out the docs.
A new preparse hook that allows you to manipulate the provided arguments before they're parsed. Salesforce used this hook to implement a neat --flags-dir feature that translates local files into flags.
A new Performance class that you can use to track performance inside of @oclif/core and your own CLI or plugin. Check out the docs.
A new flag type, Flags.option, that lets you define a flag with a preset list of options. Typescript then uses the options to infer the flag's type.
Flags now have a relationship property that allows you to define more complex relationships between flags. Check out the flags docs for more information.
Flags now have a defaultHelp property that allows you to set the human readable default value in the command help. This property is useful when your flag's parse method returns a complex type, such as an object or a class. Check out the flags docs for more.
Commands now have a hiddenAliases property that allows you to define aliases that you want to hide from the user. The property is super helpful when you're trying to wean users off a deprecated command.
You can now use bun or tsx as dev runtimes (as opposed to node or ts-node).
A command's usage, args, and flags are now shown whenever a user forgets to provide a required arg or flag, or when they provided a non-existent flag.

If you need help migrating to the latest version, head over to core's README which has links to the migration guides. Feel free to open a new discussion if you need more hands-on help from us or the community.
ESM Support​
Version 3 of @oclif/core introduced full support for developing ESM plugins and CLIs. It also offered full support for interoperability between CommonJS and ESM plugins.
Put more simply, you can now migrate your CLI to ESM while keeping individual plugins in CommonJS (or vice versa). The upgrade path is now much simpler for you. You also don't need to worry about any community plugins that have migrated to ESM before you did (such as all the @oclif plugins) or are staunchly sticking with CommonJS for the foreseeable future.
Read more about this topic here.
Improving and Revitalizing oclif.io​
Another area of focus for us has been improving our documentation site, oclif.io.
While improving the quality and accuracy of the documentation was our priority, we also took the time to upgrade to the latest version of docusaurus. This new version gave our site a much-needed facelift, as well as cool new features such as dark mode and announcements.
If you have any feedback or are running into issues, we want to hear about it. Just create an issue in the oclif.io repo.
Re-engaging the oclif Community​
Lastly, our biggest priority at the moment is to re-engage the oclif community. We understand how frustrating it has been over the years to see your issues and pull requests go unacknowledged. We apologize for not prioritizing the community, and are earnestly trying to make sure that every issue and pull request gets the attention it deserves going forward.
We also opened up GitHub discussions for @oclif/core and the oclif CLI, where you can now post your questions or ideas. We hope you take advantage of them, we love hearing from you!
One last thing: we intend to publicly post our roadmap so you have more visibility into what we're working on. Stay tuned!
All our best,
The oclif teamAnnouncing oclif v2!January 12, 2022 · 5 min readHello and happy new year! It's our great pleasure to announce that we have released oclif v2, which uses the new @oclif/core library! 🎉
oclif v2 includes many changes that improve the experience of both creating and using an oclif CLI.
Going forward, we don't plan to make any updates to oclif v1 and its corresponding libraries, except for critical security fixes. See the compatibility matrix for a list of these libraries. In order to give developers time to migrate from v1 to v2, we're not completely dropping support yet. But at some point in the future we'll archive the v1 repositories and deprecate their versions on npm.
What’s changing?​
Repository Changes​
All repositories under the oclif org now use main as their primary branch and oclif-v1 as the legacy branch. The main  branch corresponds to oclif v2 and the oclif-v1 branch to oclif v1. If you find any repos that don’t have a main branch, you can safely assume that they're not used in oclif v2 and will be deprecated in the future.
Consolidating Tools & Libraries​
The oclif-dev CLI has now been incorporated into oclif. You now no longer need to install a separate package to manage your entire CLI’s lifecycle.
The following libraries have been consolidated under @oclif/core and will be deprecated at some point in the future. Read the migration guide to learn how to update your CLI or plugin to use the new core library.

@oclif/command
@oclif/config
@oclif/error
@oclif/help
@oclif/parser

No more single vs multi command CLIs​
There's only one "type" of oclif v2 CLI, but it can have as few or as many commands as a developer wants. As a result, there’s only one command to generate CLIs, oclif generate, as opposed to the old oclif single and oclif multi commands.
Node > 12​
To ensure oclif CLIs are as secure as possible, all v2 libraries and plugins support only Node 12 or higher as of now. Going forward, they'll support only Node Maintenance or higher, as defined by Node's release schedule here: https://nodejs.org/en/about/releases/.
What’s new?​
New example CLI​
oclif-hello-world is our new example repo. This is also the repo that's used as a template when running oclif generate to create a new CLI. This repo will always be able to be referenced as an example of what an oclif v2 CLI should look like.
Spaced commands​
oclif CLIs can now use spaces, instead of colons, to separate topics and subcommands. To enable this feature, simply add “topicSeparator": " " to the oclif config in your package.json. See an example in our example repo.
// Old commands that use :$ mycli do:something
// New spaced commands$ mycli do something

Note: Spaced commands are backwards compatible. So if you enable spaced commands for your CLI, users will still be able to use : as a separator. This ensures that any existing scripts don't break.

New Help Output​
We’ve revamped the way command help is outputted to the terminal, making it both easier to implement and easier to read. See the difference between the old help output on the left and the new help output on the right in the screenshots below.
oclif v1oclif v2
Notice that there are new sections for flags and global flags, examples are displayed with better spacing, and there is a section at the bottom called Configuration Variables. This Configuration Variables section is not part of the new help by default. But we've added support for custom help sections, which is what the sf CLI uses to create the new section.
Async Command Parsing​
We’ve also improved the performance of new CLIs by rewriting how commands are parsed on initialization. The new parser is asynchronous, which makes CLIs with a lot of commands or installed  plugins much faster.
What’s coming next?​
Part of our charter for the release of oclif v2 includes improving our engagement with the oclif community. We know that over the past couple of years we’ve reduced our involvement, and a lot of issues and PRs have languished in limbo. Hopefully you’ve already seen increased activity and responses from oclif maintainers recently, but if you haven’t, please don’t hesitate to ping us by tagging @admins in oclif repos.
We also want to start interviewing members of the oclif community to acquire feedback and prioritize the features and fixes you deem most important!
Best,
The oclif team

Reference material​
Migration Guide​
This guide explains how to upgrade a CLI or plugin from the old oclif v1 libraries to the new @oclif/core library that oclif v2 uses.
https://github.com/oclif/core/blob/main/MIGRATION.md
Compatibility Matrix​
The following matrix shows how the v1 libraries and plugins relate to the new v2 ones. Use this matrix as a guide to know what to drop and which versions to switch when upgrading your plugins and CLIs to v2.
oclif "v1"oclif "v2"Utility CLIsoclif@<2@oclif/dev-cli@<2oclif@>=2Main packages@oclif/command@oclif/config@oclif/errors@oclif/parser@oclif/plugin-help@oclif/core@>=1Node LTSNode v8-14Node v12+ (at time of writing)TypeScripttypescript@<4typescript@>=4Main plugins@oclif/plugin-autocomplete@<1@oclif/plugin-commands@<2@oclif/plugin-help@<4@oclif/plugin-not-found@<2@oclif/plugin-plugins@<2@oclif/plugin-update@<2plugin-warn-if-update-available@<2plugin-which@<2@oclif/plugin-autocomplete@>=1@oclif/plugin-commands@>=2@oclif/plugin-help@>=4@oclif/plugin-not-found@>=2@oclif/plugin-plugins@>=2@oclif/plugin-update@>=2@oclif/plugin-warn-if-update-available@>=2@oclif/plugin-which@>=2Introducing @oclif/coreMarch 1, 2021 · 3 min readGreetings!
We hope this blog post finds you well.
Introducing...​
We are excited to announce the next iteration of the oclif project today: @oclif/core.
We have learned a lot in the last three years of developing oclif, developing on oclif and supporting millions of command runs a day via Heroku and Salesforce CLIs.
@oclif/core ("Core") simplifies the oclif development experience and introduces highly requested new features.
Core combines the essential oclif packages into one "core" package, aptly named @oclif/core.
Core also introduces:

A default command option
Colon or space command syntax
Async command parsing
Command piping to arguments

With the introduction of default command functionality, Core simplifies the oclif project and removes the notion of single or multi command CLIs. Core CLIs can have 1 or many commands.
Along with Core, we moved the oclif-dev CLI into the oclif CLI creating a single "utility" CLI. This CLI also introduces a new AWS S3 compatible publishing scheme.
What to expect in the near future​
Core is in pre-release beta and being actively developed for new internal Salesforce CLIs.
Much documentation needs to be written in the coming months including migration paths. Migration onto Core should be as painless as possible with many exports remaining entirely unchanged. Look for forthcoming blog posts and documentation on oclif.io.
Early this summer, tentively June 1, we will release Core v1. Core's release will coincide with major bumps to many other oclif plugin packages. See the compatibility matrix below.
At Core's v1 release, the current "main" oclif packages (namely: command, config, errors & parser) will go into maintenance mode until Jan 2022. They will receive only bug and security fixes and they remain compatible with current versions of the oclif and oclif-dev CLIs. Afterwhich, they will be archived.
Companioning Core, the next major release of the oclif CLI (literally oclif@2) will generate Core CLIs.
Going forward​
We are excited to release Core! We invite you to poke around the Core repo. It may appear to be a big change but Core keeps what you already enjoy about oclif while reducing development complexity, project dependencies, package coupling and bundle size and introduces many requested features previously too prickly to weave into the current oclif architecture.
Best,
The oclif team
Reference: Compatibility matrix​
oclif "v1"oclif "Core"Utility CLIsoclif@<2@oclif/dev-cli@<2oclif@>=2Main packages@oclif/core@<2@oclif/config@<2@oclif/errors@<2@oclif/parser@<4@oclif/plugin-help@<4@oclif/core@>=1Node LTSNode v8-14Node v12+TypeScripttypescript@<4typescript@>=4Main plugins@oclif/plugin-autocomplete@<1@oclif/plugin-commands@<2@oclif/plugin-help@<4@oclif/plugin-not-found@<2@oclif/plugin-plugins@<2@oclif/plugin-update@<2plugin-warn-if-update-available@<2plugin-which@<2@oclif/plugin-autocomplete@>=2@oclif/plugin-commands@>=2@oclif/plugin-help@>=4@oclif/plugin-not-found@>=2@oclif/plugin-plugins@>=2@oclif/plugin-update@>=2@oclif/plugin-warn-if-update-available@>=2@oclif/plugin-which@>=2oclif Summer 2020 UpdateAugust 26, 2020 · 2 min readHello oclif developers! We hope you are all doing well.
Earlier this year, we started our planning for oclifconf v2 and, like all conference, had to change course. We opted not to hold a virtual conference, however, we wanted to take some time to highlight a few oclif features shipped this year.
Feature: Help templating​
One of the most requested features, help templating enables oclif developers to customize the help output for their CLI.
Read the announcement.
Feature: Custom error delegation​
This feature both improved how oclif throws and handles errors and allows oclif developers to overwrite or interject in oclif’s error handling.
Read the announcement.
Feature: postrun hooks​
We have added a new lifecycle event postrun. Your CLI can now run a hook after a command has ran.
See our hook documentation.
Feature: Root index command​
Previously, oclif would display CLI help if only the binary name with no command ID was invoked, oclif now supports a "root index" command. If present, a command defined at src/commands/index.ts will be run if no command ID is found.
1 million weekly downloads​
While exact oclif usage metrics are hard to pin down, we use npm download statistics of oclif packages as a rough approximation. Earlier this year, oclif's command package hit 1 million weekly downloads for the first time!
This year has been presented its challenges on everyone. We want to thank you, oclif developers, whom have taken the time to use and improve the oclif project. We look forward to seeing you all - in person - in the future!
All our best,
The oclif teamPretty Printable ErrorsJuly 1, 2020 · One min readOften CLIs are used as handy tools and when things go wrong it’s useful to have additional context. In oclif we have added a couple of additional properties that can show extra context to the users when an error is displayed. The code, ref and suggestions will now be displayed if they are included. This will work with an existing oclif CLI by adding the latest @oclif/errors and @oclif/core to the CLI's package.json dependencies.
For example, using this.error with the additional properties:
class TestError extends Command {  async run() {    this.error("An error has occurred!", {      code: "OCLIF_ERR",      ref: "https://oclif.io/docs/commands#thiserrormessage-string--error-options-code-string-exit-number",      suggestions: ["Use these extra properties to provide additional context"],    })  }}
would result with the following output:
›   Error: An error has occurred!›   Code: OCLIF_ERR›   Try this: Use these extra properties to provide additional context›   Reference: https://oclif.io/docs/commands#thiserrormessage-string--error-options-code-string-exit-number
If these properties are not provided then nothing changes and the CLI will continue to display the single error message output as it did before. Additionally, as part of this exercise we’ve added documentation around Error Handling in oclif which should come in handy if the need arises to extend oclif’s default handling of errors.Customizing Help in oclifMay 5, 2020 · 2 min readOut of the box oclif provides a great help experience for CLIs.
But what if, as an oclif developer, you want to customize some or all of the output?
You can now customize your CLI's help output by implementing the HelpBase abstract class.
Getting started with custom help​
If you have not done so yet, update @oclif/core.
$ yarn add --latest @oclif/core
To get started, first define the filepath to your help class in oclif's config in package.json. This is a relative path to the help class, without a file extension.
For this example, the help class will be created in a file at "[project root]/src/help.ts".
{  // ...  "oclif": {    "helpClass": "./lib/help"    // ...  }  // ...}
From here there are two paths, implement the HelpBase abstract class yourself or overwrite the parts of the default Help class you want to customize (ex: how command usage is displayed). We recommend the latter approach but cover both in the new Help Classes docs.
Separating TOPICS & COMMANDS in the new default Help class​
Previously, topics and child commands were listed in help output under a single list heading called "COMMANDS". But we found this can be slightly confusing. Some topics are commands also (a.k.a. topic-commands) while others are simply organizational namespacing (and when ran just show their help).
The new default Help class splits the list of children into distinct lists of "TOPICS" and "COMMANDS", with the possibility of an item appearing in both if it a topic-command. This makes it clearer what is expected to be ran - "COMMANDS" - and what is providing structure - "TOPICS" - when looking at the help output.
VERSION  plugin-help-example/0.0.0 darwin-x64 node-v12.12.0USAGE  $ plugin-help-example [COMMAND]TOPICS  topic  this is a topic and has child topics or commandsCOMMANDS  hello  describe the command here  help   display help for plugin-help-example
We look forward to seeing what custom help features you implement in your oclif CLIs with this new feature!oclif TSLint to ESLint MigrationDecember 5, 2019 · 3 min readBack in February of this year, plans were announced to deprecate TSLint in favor of ESLint. TSLint's goal has become to work toward a “unified developer experience” by supporting ESLint development going forward.
What has changed in oclif​
To keep inline with the community, oclif has transitioned to ESLint for all our core libraries as well as all our official plugins.
Starting in v1.15.x, oclif will now optionally generate projects with ESLint for both TypeScript and JavaScript CLI’s.
ESLint does require Node to be on stable LTS version, at the time of writing, Node 8.10.x, Node 10.13.x & Node 12.x.x.
How does this affect you​
Existing CLI’s are unchanged, but any newly generated CLI's will only give the option of using ESLint. If you are running tslint in your CLI, we recommend you switch to ESLint as well.
In migrating our projects we took the following steps (for an example of these changes see this pull request).


Install eslint
$ yarn add eslint eslint-config-oclif eslint-config-oclif-typescript --dev


Add eslint related files


$ echo '{  "extends": [    "oclif",    "oclif-typescript"  ],  "rules": {  }}' > .eslintrc


Remove tslint and related packages
$ yarn remove @oclif/tslint tslint


Remove tslint related configuration files
$ rm tslint.json


Change lint script in our package.json from something like:
"lint": "tsc -p test --noEmit && tslint -p test -t stylish"
to
"lint": "eslint . --ext .ts --config .eslintrc"


To preserve the test compile (tsc -p test --noEmit) we also made the following updates to our scripts:
"pretest": "tsc -p test --noEmit"
In some cases we had our posttest duplicating the same steps as our lint script so it’s cleaner to have it reference the lint job directly with:
"posttest": "yarn lint"

Run yarn lint --fix. This attempts to auto-fix any linting violations automatically. In the case an auto-fix isn’t available it should be fixed manually or ignored (see the eslint configuration doc for more information)
Do a search in the codebase for tslint and remove any unnecessary tslint disabling comments, like:

/* tslint:disable:object-literal-sort-keys */
If you are on a version of Node that is not supported by ESLint, you will also need to update your Node engine. ESLint supports Node 8, 10, and 12 so you should upgrade to the most recent Node version compatible with your CLI and also supported by ESLint (see ESLint's Installation and Usage instructions).
When will this take effect​
These changes have taken effect in oclif v1.15.1. When you generate a new CLI or plugin it will now contain configuration for ESLint instead of TSLint.oclif's Current Node SupportOctober 31, 2019 · 3 min readTo maintain a healthy project trajectory, oclif follows and supports Node Active LTS release, currently Node 10 & Node 12. This means ensuring that oclif continues to play nice with coming Active LTS Node versions and other packages in the ecosystem. Moving forward also means leaving older versions behind. Starting in 2020, Node will stop maintaining Node 8 and it is our intent at that time to also follow suit. Let’s take a look at a few ways we will be supporting these changes.
CI Environments​
CLIs created with the oclif cli going forward will be generated with a CircleCI configuration with Node 10 & 12 and an Appveyor configuration using Node 10. We have also added Node latest to CircleCi to be an early warning detection against coming Node changes (Node latest is managed by CircleCI).
We have already updated every oclif repo's CI configs to reflect this.
If your existing CLI uses either Appveyor or CircleCI you can update your config files also, like so:
.circleci/config.yml​
Your CircleCI config should contain a node-latest job, aliased as test. From this, there should be two extensions of this job for the Active LTS Node versions, Node 10 and Node 12.
  node-10:    <<: *node-latest    docker:      - image: node:10  node-12:    <<: *node-latest    docker:      - image: node:12
Notice that these declarations only change the Docker Node images used to run that job.
Additionally, the jobs listed within workflows must also be updated to reflect our changes in configuration:
    jobs:      - node-latest      - node-10      - node-12
appveyor.yml​
For appveyor we are currently only testing the oldest Active LTS Node version, Node 10. Update the nodejs_version proppert in your appveyor.yml file to reflect this.
environment:  nodejs_version: "10"
Deprecating Node 8 & Updating packge.json engines​
In Jan 2020, Node will end its Node 8 maintenance. We will follow suit by setting the package.json engine property in oclif packages to >=10 and bumping the package's major versions.
Depending on how you ship your CLI you may wish to also bump the engines version in your CLI's package.json. You can read more about the implications of the engines property configuration in the npm documentation.
Also consider distributing your CLI with its own Node version.
Packaged Node Version​
When using dev-cli to pack your CLI it will use the Node version as specified in your package.json under the oclif.update.node.version property. This value should reflect an Active LTS Node version (dev-cli does not currently enforce versions).
Supporting the future​
As a community we may discover bumps along the way as we upgrade. If you notice something related to oclif please feel free to open an issue or submit a pull request under the relevant oclif package within the org.
We look forward to using the latest from Node and the community and keeping oclif healthy along the way.oclifconf 2019: A RecapSeptember 16, 2019 · 4 min readIn May, Heroku and Salesforce Open Source organized oclifconf, a conference for developers & product managers building CLI tools on top of the open source oclif framework. The speakers came from various tech companies, such as Adobe, Netlify, and Apollo, who have already built amazing CLI experiences. The topics covered everything from the incredible capabilities oclif has unlocked, to the community-built plugins extending its functionality, and even what the behavior of an adaptive CLI tool might look like.
Below is a listing of all of the talks from the event, along with a short summary. Enjoy!
The future of oclif by Jeff Dickey​

In its relatively short lifetime, oclif has already inspired many developers and companies to adopt its framework as a means for implementing their own command-line tooling. In this talk, Jeff Dickey, an oclif founding team member, recaps the project's history and inspiration. He also looks towards the future and outlines some features and improvements that the tool could adapt. This isn't so much a definitive roadmap of where oclif is headed, but rather, a call to inspiration for developers eager to contribute! And if you are interested in contributing, check out the open issues in the oclif GitHub repo and come say "Hello!" on Spectrum Chat.
Open Source Citizenship by Josh Simmons​

When it comes to open source, it's more than just individuals now. More and more frequently, large corporations are contributing to projects by donating to contributors, sponsoring events, or upstreaming contributions. But keeping open source projects and communities healthy requires more than just money and brainpower. Josh Simmons surveyed multiple open source communities and relays his findings as to what help maintainers and contributors actually need in this talk.
Building an enterprise-grade CLI with oclif by Thomas Dvornik​

Security and performance are all about trust. While oclif is an extremely extensible framework for building CLI tooling, there are additional requirements to fulfill for enterprise businesses to adopt it that might not be necessary for individual developers. Thomas Dvornik outlines what he and his colleagues at Salesforce have implemented as plugins to oclif to satisfy these needs, including encrypted OAuth, plugin signing, lazy loading dependencies, synchronizing weekly releases and deprecations across dozens of repositories, and establishing cross-team coding and documentation standards.
How Adobe I/O built an extensible CLI with oclif by Jesse MacFadyen​

Perhaps oclif's most appealing feature is its support for plugins. In Cordova's case, they've created a sophisticated telemetry system that helps Adobe developers see which commands users are using--and reports on which ones are erroring out. By embedding a feedback system into the tool, users are even able to quickly send their suggestions to a form, without ever leaving the terminal. Jesse MacFadyen demonstrates how oclif's plugin system can work beyond simply executing commands.
Integrating oclif with GraphQL and Apollo by Evans Hauser​

For Evans Hauser and the team at Apollo, oclif is best thought of as "React for the CLI." As a client paired with a strongly-typed API contract to a server, it can deliver structured and consistent commands to retrieve external data. What better mechanism to use for this transfer than GraphQL, a framework which empowers the client to ask precisely for the data it needs, and nothing more?
Adaptive Intent-based CLI State Machines by Shawn Wang​

In designing oclif, Jeff Dickey wrote out 12 CLI factors to keep in mind. In this talk, Shawn Wang outlines a 13th: state. State is hard, because it depends on context, and context depends on understanding what a user intends to do, not what they are asking. Shawn is working towards enabling oclif to better understand the commands a user has entered, so that it can predict and interpret future commands that might be entered next. This would enable CLI tools to not just interpret a users' commands, but to also interpret their intent.\n\nIntroducing `oclif init` commandApril 10, 2024 · 2 min readThanks to the contribution of @joshcanhelp we released a new command for the oclif CLI called oclif init in version 4.8.0
The oclif init command allows you to initialize oclif in an existing project directory by adding the bare minimum requirements: a few pieces of configuration, bin scripts, and a couple of dependencies (@oclif/core and ts-node). This is slightly different from oclif generate, which will create an entirely new oclif project based on our templates.
oclif init will add the following:

bin scripts: bin/run.js, bin/run.cmd, bin/dev.js, and bin/dev.cmd
oclif section to package.json with bin, dirname, commands, and topicSeparator set (See Configuring Your CLI for more)
@oclif/core to dependencies in your package.json (if it's not already there)
ts-node to devDependencies in your package.json (if it's not already there)

Once you've initialized oclif, you can use the bin scripts to execute your CLI. You can also use the other oclif commands like oclif generate command and oclif generate hook to start adding new functionality.

❯ oclif init --helpInitialize a new oclif CLIUSAGE  $ oclif init [--bin <value>] [--module-type ESM|CommonJS] [--package-manager npm|yarn|pnpm] [--topic-separator    colons|spaces] [-d <value>] [-y]FLAGS  -d, --output-dir=<value>        Directory to initialize the CLI in.  -y, --yes                       Use defaults for all prompts. Individual flags will override defaults.      --bin=<value>               Supply answer for prompt: Command bin name the CLI will export      --module-type=<option>      Supply answer for prompt: Select a module type                                  <options: ESM|CommonJS>      --package-manager=<option>  Supply answer for prompt: Select a package manager                                  <options: npm|yarn|pnpm>      --topic-separator=<option>  Supply answer for prompt: Select a topic separator                                  <options: colons|spaces>DESCRIPTION  Initialize a new oclif CLI  This will add the necessary oclif bin files, add oclif config to package.json, and install @oclif/core and ts-node.EXAMPLES  Initialize a new CLI in the current directory    $ oclif init  Initialize a new CLI in a different directory    $ oclif init --output-dir "/path/to/existing/project"  Supply answers for specific prompts    $ oclif init --topic-separator colons --bin mycli
Hope you enjoy the new command! If you come across any issues or have any new ideas for this command, head over to the oclif/oclif repo and open a new issue.
All our best,
The oclif teamoclif Spring 2024 UpdateMarch 29, 2024 · 4 min readHello oclif developers! It's been a while since we last uploaded a blog - and a lot has happened.
We've been focusing on these high-level areas over the past couple of years:

Improving @oclif/core
ESM Support
Improving and revitalizing oclif.io
Re-engaging the oclif community

Improving @oclif/core​
Since we announced @oclif/core over three years ago, we've released two new major versions, each packed with lots of features that we're really excited about.
Here are some of these changes:

Full support for ESM and interoperability with CommonJS (more on this topic below).
Configurable command discovery strategies that give you more control over how commands are loaded at runtime. Check out the docs.
A new preparse hook that allows you to manipulate the provided arguments before they're parsed. Salesforce used this hook to implement a neat --flags-dir feature that translates local files into flags.
A new Performance class that you can use to track performance inside of @oclif/core and your own CLI or plugin. Check out the docs.
A new flag type, Flags.option, that lets you define a flag with a preset list of options. Typescript then uses the options to infer the flag's type.
Flags now have a relationship property that allows you to define more complex relationships between flags. Check out the flags docs for more information.
Flags now have a defaultHelp property that allows you to set the human readable default value in the command help. This property is useful when your flag's parse method returns a complex type, such as an object or a class. Check out the flags docs for more.
Commands now have a hiddenAliases property that allows you to define aliases that you want to hide from the user. The property is super helpful when you're trying to wean users off a deprecated command.
You can now use bun or tsx as dev runtimes (as opposed to node or ts-node).
A command's usage, args, and flags are now shown whenever a user forgets to provide a required arg or flag, or when they provided a non-existent flag.

If you need help migrating to the latest version, head over to core's README which has links to the migration guides. Feel free to open a new discussion if you need more hands-on help from us or the community.
ESM Support​
Version 3 of @oclif/core introduced full support for developing ESM plugins and CLIs. It also offered full support for interoperability between CommonJS and ESM plugins.
Put more simply, you can now migrate your CLI to ESM while keeping individual plugins in CommonJS (or vice versa). The upgrade path is now much simpler for you. You also don't need to worry about any community plugins that have migrated to ESM before you did (such as all the @oclif plugins) or are staunchly sticking with CommonJS for the foreseeable future.
Read more about this topic here.
Improving and Revitalizing oclif.io​
Another area of focus for us has been improving our documentation site, oclif.io.
While improving the quality and accuracy of the documentation was our priority, we also took the time to upgrade to the latest version of docusaurus. This new version gave our site a much-needed facelift, as well as cool new features such as dark mode and announcements.
If you have any feedback or are running into issues, we want to hear about it. Just create an issue in the oclif.io repo.
Re-engaging the oclif Community​
Lastly, our biggest priority at the moment is to re-engage the oclif community. We understand how frustrating it has been over the years to see your issues and pull requests go unacknowledged. We apologize for not prioritizing the community, and are earnestly trying to make sure that every issue and pull request gets the attention it deserves going forward.
We also opened up GitHub discussions for @oclif/core and the oclif CLI, where you can now post your questions or ideas. We hope you take advantage of them, we love hearing from you!
One last thing: we intend to publicly post our roadmap so you have more visibility into what we're working on. Stay tuned!
All our best,
The oclif teamAnnouncing oclif v2!January 12, 2022 · 5 min readHello and happy new year! It's our great pleasure to announce that we have released oclif v2, which uses the new @oclif/core library! 🎉
oclif v2 includes many changes that improve the experience of both creating and using an oclif CLI.
Going forward, we don't plan to make any updates to oclif v1 and its corresponding libraries, except for critical security fixes. See the compatibility matrix for a list of these libraries. In order to give developers time to migrate from v1 to v2, we're not completely dropping support yet. But at some point in the future we'll archive the v1 repositories and deprecate their versions on npm.
What’s changing?​
Repository Changes​
All repositories under the oclif org now use main as their primary branch and oclif-v1 as the legacy branch. The main  branch corresponds to oclif v2 and the oclif-v1 branch to oclif v1. If you find any repos that don’t have a main branch, you can safely assume that they're not used in oclif v2 and will be deprecated in the future.
Consolidating Tools & Libraries​
The oclif-dev CLI has now been incorporated into oclif. You now no longer need to install a separate package to manage your entire CLI’s lifecycle.
The following libraries have been consolidated under @oclif/core and will be deprecated at some point in the future. Read the migration guide to learn how to update your CLI or plugin to use the new core library.

@oclif/command
@oclif/config
@oclif/error
@oclif/help
@oclif/parser

No more single vs multi command CLIs​
There's only one "type" of oclif v2 CLI, but it can have as few or as many commands as a developer wants. As a result, there’s only one command to generate CLIs, oclif generate, as opposed to the old oclif single and oclif multi commands.
Node > 12​
To ensure oclif CLIs are as secure as possible, all v2 libraries and plugins support only Node 12 or higher as of now. Going forward, they'll support only Node Maintenance or higher, as defined by Node's release schedule here: https://nodejs.org/en/about/releases/.
What’s new?​
New example CLI​
oclif-hello-world is our new example repo. This is also the repo that's used as a template when running oclif generate to create a new CLI. This repo will always be able to be referenced as an example of what an oclif v2 CLI should look like.
Spaced commands​
oclif CLIs can now use spaces, instead of colons, to separate topics and subcommands. To enable this feature, simply add “topicSeparator": " " to the oclif config in your package.json. See an example in our example repo.
// Old commands that use :$ mycli do:something
// New spaced commands$ mycli do something

Note: Spaced commands are backwards compatible. So if you enable spaced commands for your CLI, users will still be able to use : as a separator. This ensures that any existing scripts don't break.

New Help Output​
We’ve revamped the way command help is outputted to the terminal, making it both easier to implement and easier to read. See the difference between the old help output on the left and the new help output on the right in the screenshots below.
oclif v1oclif v2
Notice that there are new sections for flags and global flags, examples are displayed with better spacing, and there is a section at the bottom called Configuration Variables. This Configuration Variables section is not part of the new help by default. But we've added support for custom help sections, which is what the sf CLI uses to create the new section.
Async Command Parsing​
We’ve also improved the performance of new CLIs by rewriting how commands are parsed on initialization. The new parser is asynchronous, which makes CLIs with a lot of commands or installed  plugins much faster.
What’s coming next?​
Part of our charter for the release of oclif v2 includes improving our engagement with the oclif community. We know that over the past couple of years we’ve reduced our involvement, and a lot of issues and PRs have languished in limbo. Hopefully you’ve already seen increased activity and responses from oclif maintainers recently, but if you haven’t, please don’t hesitate to ping us by tagging @admins in oclif repos.
We also want to start interviewing members of the oclif community to acquire feedback and prioritize the features and fixes you deem most important!
Best,
The oclif team

Reference material​
Migration Guide​
This guide explains how to upgrade a CLI or plugin from the old oclif v1 libraries to the new @oclif/core library that oclif v2 uses.
https://github.com/oclif/core/blob/main/MIGRATION.md
Compatibility Matrix​
The following matrix shows how the v1 libraries and plugins relate to the new v2 ones. Use this matrix as a guide to know what to drop and which versions to switch when upgrading your plugins and CLIs to v2.
oclif "v1"oclif "v2"Utility CLIsoclif@<2@oclif/dev-cli@<2oclif@>=2Main packages@oclif/command@oclif/config@oclif/errors@oclif/parser@oclif/plugin-help@oclif/core@>=1Node LTSNode v8-14Node v12+ (at time of writing)TypeScripttypescript@<4typescript@>=4Main plugins@oclif/plugin-autocomplete@<1@oclif/plugin-commands@<2@oclif/plugin-help@<4@oclif/plugin-not-found@<2@oclif/plugin-plugins@<2@oclif/plugin-update@<2plugin-warn-if-update-available@<2plugin-which@<2@oclif/plugin-autocomplete@>=1@oclif/plugin-commands@>=2@oclif/plugin-help@>=4@oclif/plugin-not-found@>=2@oclif/plugin-plugins@>=2@oclif/plugin-update@>=2@oclif/plugin-warn-if-update-available@>=2@oclif/plugin-which@>=2Introducing @oclif/coreMarch 1, 2021 · 3 min readGreetings!
We hope this blog post finds you well.
Introducing...​
We are excited to announce the next iteration of the oclif project today: @oclif/core.
We have learned a lot in the last three years of developing oclif, developing on oclif and supporting millions of command runs a day via Heroku and Salesforce CLIs.
@oclif/core ("Core") simplifies the oclif development experience and introduces highly requested new features.
Core combines the essential oclif packages into one "core" package, aptly named @oclif/core.
Core also introduces:

A default command option
Colon or space command syntax
Async command parsing
Command piping to arguments

With the introduction of default command functionality, Core simplifies the oclif project and removes the notion of single or multi command CLIs. Core CLIs can have 1 or many commands.
Along with Core, we moved the oclif-dev CLI into the oclif CLI creating a single "utility" CLI. This CLI also introduces a new AWS S3 compatible publishing scheme.
What to expect in the near future​
Core is in pre-release beta and being actively developed for new internal Salesforce CLIs.
Much documentation needs to be written in the coming months including migration paths. Migration onto Core should be as painless as possible with many exports remaining entirely unchanged. Look for forthcoming blog posts and documentation on oclif.io.
Early this summer, tentively June 1, we will release Core v1. Core's release will coincide with major bumps to many other oclif plugin packages. See the compatibility matrix below.
At Core's v1 release, the current "main" oclif packages (namely: command, config, errors & parser) will go into maintenance mode until Jan 2022. They will receive only bug and security fixes and they remain compatible with current versions of the oclif and oclif-dev CLIs. Afterwhich, they will be archived.
Companioning Core, the next major release of the oclif CLI (literally oclif@2) will generate Core CLIs.
Going forward​
We are excited to release Core! We invite you to poke around the Core repo. It may appear to be a big change but Core keeps what you already enjoy about oclif while reducing development complexity, project dependencies, package coupling and bundle size and introduces many requested features previously too prickly to weave into the current oclif architecture.
Best,
The oclif team
Reference: Compatibility matrix​
oclif "v1"oclif "Core"Utility CLIsoclif@<2@oclif/dev-cli@<2oclif@>=2Main packages@oclif/core@<2@oclif/config@<2@oclif/errors@<2@oclif/parser@<4@oclif/plugin-help@<4@oclif/core@>=1Node LTSNode v8-14Node v12+TypeScripttypescript@<4typescript@>=4Main plugins@oclif/plugin-autocomplete@<1@oclif/plugin-commands@<2@oclif/plugin-help@<4@oclif/plugin-not-found@<2@oclif/plugin-plugins@<2@oclif/plugin-update@<2plugin-warn-if-update-available@<2plugin-which@<2@oclif/plugin-autocomplete@>=2@oclif/plugin-commands@>=2@oclif/plugin-help@>=4@oclif/plugin-not-found@>=2@oclif/plugin-plugins@>=2@oclif/plugin-update@>=2@oclif/plugin-warn-if-update-available@>=2@oclif/plugin-which@>=2oclif Summer 2020 UpdateAugust 26, 2020 · 2 min readHello oclif developers! We hope you are all doing well.
Earlier this year, we started our planning for oclifconf v2 and, like all conference, had to change course. We opted not to hold a virtual conference, however, we wanted to take some time to highlight a few oclif features shipped this year.
Feature: Help templating​
One of the most requested features, help templating enables oclif developers to customize the help output for their CLI.
Read the announcement.
Feature: Custom error delegation​
This feature both improved how oclif throws and handles errors and allows oclif developers to overwrite or interject in oclif’s error handling.
Read the announcement.
Feature: postrun hooks​
We have added a new lifecycle event postrun. Your CLI can now run a hook after a command has ran.
See our hook documentation.
Feature: Root index command​
Previously, oclif would display CLI help if only the binary name with no command ID was invoked, oclif now supports a "root index" command. If present, a command defined at src/commands/index.ts will be run if no command ID is found.
1 million weekly downloads​
While exact oclif usage metrics are hard to pin down, we use npm download statistics of oclif packages as a rough approximation. Earlier this year, oclif's command package hit 1 million weekly downloads for the first time!
This year has been presented its challenges on everyone. We want to thank you, oclif developers, whom have taken the time to use and improve the oclif project. We look forward to seeing you all - in person - in the future!
All our best,
The oclif teamPretty Printable ErrorsJuly 1, 2020 · One min readOften CLIs are used as handy tools and when things go wrong it’s useful to have additional context. In oclif we have added a couple of additional properties that can show extra context to the users when an error is displayed. The code, ref and suggestions will now be displayed if they are included. This will work with an existing oclif CLI by adding the latest @oclif/errors and @oclif/core to the CLI's package.json dependencies.
For example, using this.error with the additional properties:
class TestError extends Command {  async run() {    this.error("An error has occurred!", {      code: "OCLIF_ERR",      ref: "https://oclif.io/docs/commands#thiserrormessage-string--error-options-code-string-exit-number",      suggestions: ["Use these extra properties to provide additional context"],    })  }}
would result with the following output:
›   Error: An error has occurred!›   Code: OCLIF_ERR›   Try this: Use these extra properties to provide additional context›   Reference: https://oclif.io/docs/commands#thiserrormessage-string--error-options-code-string-exit-number
If these properties are not provided then nothing changes and the CLI will continue to display the single error message output as it did before. Additionally, as part of this exercise we’ve added documentation around Error Handling in oclif which should come in handy if the need arises to extend oclif’s default handling of errors.Customizing Help in oclifMay 5, 2020 · 2 min readOut of the box oclif provides a great help experience for CLIs.
But what if, as an oclif developer, you want to customize some or all of the output?
You can now customize your CLI's help output by implementing the HelpBase abstract class.
Getting started with custom help​
If you have not done so yet, update @oclif/core.
$ yarn add --latest @oclif/core
To get started, first define the filepath to your help class in oclif's config in package.json. This is a relative path to the help class, without a file extension.
For this example, the help class will be created in a file at "[project root]/src/help.ts".
{  // ...  "oclif": {    "helpClass": "./lib/help"    // ...  }  // ...}
From here there are two paths, implement the HelpBase abstract class yourself or overwrite the parts of the default Help class you want to customize (ex: how command usage is displayed). We recommend the latter approach but cover both in the new Help Classes docs.
Separating TOPICS & COMMANDS in the new default Help class​
Previously, topics and child commands were listed in help output under a single list heading called "COMMANDS". But we found this can be slightly confusing. Some topics are commands also (a.k.a. topic-commands) while others are simply organizational namespacing (and when ran just show their help).
The new default Help class splits the list of children into distinct lists of "TOPICS" and "COMMANDS", with the possibility of an item appearing in both if it a topic-command. This makes it clearer what is expected to be ran - "COMMANDS" - and what is providing structure - "TOPICS" - when looking at the help output.
VERSION  plugin-help-example/0.0.0 darwin-x64 node-v12.12.0USAGE  $ plugin-help-example [COMMAND]TOPICS  topic  this is a topic and has child topics or commandsCOMMANDS  hello  describe the command here  help   display help for plugin-help-example
We look forward to seeing what custom help features you implement in your oclif CLIs with this new feature!oclif TSLint to ESLint MigrationDecember 5, 2019 · 3 min readBack in February of this year, plans were announced to deprecate TSLint in favor of ESLint. TSLint's goal has become to work toward a “unified developer experience” by supporting ESLint development going forward.
What has changed in oclif​
To keep inline with the community, oclif has transitioned to ESLint for all our core libraries as well as all our official plugins.
Starting in v1.15.x, oclif will now optionally generate projects with ESLint for both TypeScript and JavaScript CLI’s.
ESLint does require Node to be on stable LTS version, at the time of writing, Node 8.10.x, Node 10.13.x & Node 12.x.x.
How does this affect you​
Existing CLI’s are unchanged, but any newly generated CLI's will only give the option of using ESLint. If you are running tslint in your CLI, we recommend you switch to ESLint as well.
In migrating our projects we took the following steps (for an example of these changes see this pull request).


Install eslint
$ yarn add eslint eslint-config-oclif eslint-config-oclif-typescript --dev


Add eslint related files


$ echo '{  "extends": [    "oclif",    "oclif-typescript"  ],  "rules": {  }}' > .eslintrc


Remove tslint and related packages
$ yarn remove @oclif/tslint tslint


Remove tslint related configuration files
$ rm tslint.json


Change lint script in our package.json from something like:
"lint": "tsc -p test --noEmit && tslint -p test -t stylish"
to
"lint": "eslint . --ext .ts --config .eslintrc"


To preserve the test compile (tsc -p test --noEmit) we also made the following updates to our scripts:
"pretest": "tsc -p test --noEmit"
In some cases we had our posttest duplicating the same steps as our lint script so it’s cleaner to have it reference the lint job directly with:
"posttest": "yarn lint"

Run yarn lint --fix. This attempts to auto-fix any linting violations automatically. In the case an auto-fix isn’t available it should be fixed manually or ignored (see the eslint configuration doc for more information)
Do a search in the codebase for tslint and remove any unnecessary tslint disabling comments, like:

/* tslint:disable:object-literal-sort-keys */
If you are on a version of Node that is not supported by ESLint, you will also need to update your Node engine. ESLint supports Node 8, 10, and 12 so you should upgrade to the most recent Node version compatible with your CLI and also supported by ESLint (see ESLint's Installation and Usage instructions).
When will this take effect​
These changes have taken effect in oclif v1.15.1. When you generate a new CLI or plugin it will now contain configuration for ESLint instead of TSLint.oclif's Current Node SupportOctober 31, 2019 · 3 min readTo maintain a healthy project trajectory, oclif follows and supports Node Active LTS release, currently Node 10 & Node 12. This means ensuring that oclif continues to play nice with coming Active LTS Node versions and other packages in the ecosystem. Moving forward also means leaving older versions behind. Starting in 2020, Node will stop maintaining Node 8 and it is our intent at that time to also follow suit. Let’s take a look at a few ways we will be supporting these changes.
CI Environments​
CLIs created with the oclif cli going forward will be generated with a CircleCI configuration with Node 10 & 12 and an Appveyor configuration using Node 10. We have also added Node latest to CircleCi to be an early warning detection against coming Node changes (Node latest is managed by CircleCI).
We have already updated every oclif repo's CI configs to reflect this.
If your existing CLI uses either Appveyor or CircleCI you can update your config files also, like so:
.circleci/config.yml​
Your CircleCI config should contain a node-latest job, aliased as test. From this, there should be two extensions of this job for the Active LTS Node versions, Node 10 and Node 12.
  node-10:    <<: *node-latest    docker:      - image: node:10  node-12:    <<: *node-latest    docker:      - image: node:12
Notice that these declarations only change the Docker Node images used to run that job.
Additionally, the jobs listed within workflows must also be updated to reflect our changes in configuration:
    jobs:      - node-latest      - node-10      - node-12
appveyor.yml​
For appveyor we are currently only testing the oldest Active LTS Node version, Node 10. Update the nodejs_version proppert in your appveyor.yml file to reflect this.
environment:  nodejs_version: "10"
Deprecating Node 8 & Updating packge.json engines​
In Jan 2020, Node will end its Node 8 maintenance. We will follow suit by setting the package.json engine property in oclif packages to >=10 and bumping the package's major versions.
Depending on how you ship your CLI you may wish to also bump the engines version in your CLI's package.json. You can read more about the implications of the engines property configuration in the npm documentation.
Also consider distributing your CLI with its own Node version.
Packaged Node Version​
When using dev-cli to pack your CLI it will use the Node version as specified in your package.json under the oclif.update.node.version property. This value should reflect an Active LTS Node version (dev-cli does not currently enforce versions).
Supporting the future​
As a community we may discover bumps along the way as we upgrade. If you notice something related to oclif please feel free to open an issue or submit a pull request under the relevant oclif package within the org.
We look forward to using the latest from Node and the community and keeping oclif healthy along the way.oclifconf 2019: A RecapSeptember 16, 2019 · 4 min readIn May, Heroku and Salesforce Open Source organized oclifconf, a conference for developers & product managers building CLI tools on top of the open source oclif framework. The speakers came from various tech companies, such as Adobe, Netlify, and Apollo, who have already built amazing CLI experiences. The topics covered everything from the incredible capabilities oclif has unlocked, to the community-built plugins extending its functionality, and even what the behavior of an adaptive CLI tool might look like.
Below is a listing of all of the talks from the event, along with a short summary. Enjoy!
The future of oclif by Jeff Dickey​

In its relatively short lifetime, oclif has already inspired many developers and companies to adopt its framework as a means for implementing their own command-line tooling. In this talk, Jeff Dickey, an oclif founding team member, recaps the project's history and inspiration. He also looks towards the future and outlines some features and improvements that the tool could adapt. This isn't so much a definitive roadmap of where oclif is headed, but rather, a call to inspiration for developers eager to contribute! And if you are interested in contributing, check out the open issues in the oclif GitHub repo and come say "Hello!" on Spectrum Chat.
Open Source Citizenship by Josh Simmons​

When it comes to open source, it's more than just individuals now. More and more frequently, large corporations are contributing to projects by donating to contributors, sponsoring events, or upstreaming contributions. But keeping open source projects and communities healthy requires more than just money and brainpower. Josh Simmons surveyed multiple open source communities and relays his findings as to what help maintainers and contributors actually need in this talk.
Building an enterprise-grade CLI with oclif by Thomas Dvornik​

Security and performance are all about trust. While oclif is an extremely extensible framework for building CLI tooling, there are additional requirements to fulfill for enterprise businesses to adopt it that might not be necessary for individual developers. Thomas Dvornik outlines what he and his colleagues at Salesforce have implemented as plugins to oclif to satisfy these needs, including encrypted OAuth, plugin signing, lazy loading dependencies, synchronizing weekly releases and deprecations across dozens of repositories, and establishing cross-team coding and documentation standards.
How Adobe I/O built an extensible CLI with oclif by Jesse MacFadyen​

Perhaps oclif's most appealing feature is its support for plugins. In Cordova's case, they've created a sophisticated telemetry system that helps Adobe developers see which commands users are using--and reports on which ones are erroring out. By embedding a feedback system into the tool, users are even able to quickly send their suggestions to a form, without ever leaving the terminal. Jesse MacFadyen demonstrates how oclif's plugin system can work beyond simply executing commands.
Integrating oclif with GraphQL and Apollo by Evans Hauser​

For Evans Hauser and the team at Apollo, oclif is best thought of as "React for the CLI." As a client paired with a strongly-typed API contract to a server, it can deliver structured and consistent commands to retrieve external data. What better mechanism to use for this transfer than GraphQL, a framework which empowers the client to ask precisely for the data it needs, and nothing more?
Adaptive Intent-based CLI State Machines by Shawn Wang​

In designing oclif, Jeff Dickey wrote out 12 CLI factors to keep in mind. In this talk, Shawn Wang outlines a 13th: state. State is hard, because it depends on context, and context depends on understanding what a user intends to do, not what they are asking. Shawn is working towards enabling oclif to better understand the commands a user has entered, so that it can predict and interpret future commands that might be entered next. This would enable CLI tools to not just interpret a users' commands, but to also interpret their intent.Older Entries\n\n\n\nThe Open CLI FrameworkCreate command line tools your users loveoclif is an open source framework for building a command line interface (CLI) in Node.js and Typescript. Create CLIs with a few flags or advanced CLIs that have subcommands. oclif makes it easy for you to build CLIs for your company, service, or your own development needs.$ npx oclif generate mynewcli? npm package name (mynewcli): mynewcli$ cd mynewcli$ ./bin/run.js hello worldhello world! (./src/commands/hello/world.ts)Get Started →⚡Ready to goScaffold a fully functional CLI to get started quickly. oclif packages our years of experience into out-of-the-box functionality for argument parsing, command testing, and auto-documentation of CLI features.👐Open sourceoclif is open source and free to use or modify. We think you’ll love it too and you can also help make it better.✅ExtendableYou or your users can easily extend your CLI functionality to meet custom needs using plugins. Plugins are modular and shareable, encouraging reuse.🔒Trustedoclif is actively used to build the Heroku and Salesforce CLIs, powering millions of interactions for developers every day.CLIs built using With oclif you can build command line tools for your business, open source project, or your own development workflow. Check out what others have built.\n\n\n\nIntroducing `oclif init` commandApril 10, 2024 · 2 min readThanks to the contribution of @joshcanhelp we released a new command for the oclif CLI called oclif init in version 4.8.0
The oclif init command allows you to initialize oclif in an existing project directory by adding the bare minimum requirements: a few pieces of configuration, bin scripts, and a couple of dependencies (@oclif/core and ts-node). This is slightly different from oclif generate, which will create an entirely new oclif project based on our templates.
oclif init will add the following:

bin scripts: bin/run.js, bin/run.cmd, bin/dev.js, and bin/dev.cmd
oclif section to package.json with bin, dirname, commands, and topicSeparator set (See Configuring Your CLI for more)
@oclif/core to dependencies in your package.json (if it's not already there)
ts-node to devDependencies in your package.json (if it's not already there)

Once you've initialized oclif, you can use the bin scripts to execute your CLI. You can also use the other oclif commands like oclif generate command and oclif generate hook to start adding new functionality.

❯ oclif init --helpInitialize a new oclif CLIUSAGE  $ oclif init [--bin <value>] [--module-type ESM|CommonJS] [--package-manager npm|yarn|pnpm] [--topic-separator    colons|spaces] [-d <value>] [-y]FLAGS  -d, --output-dir=<value>        Directory to initialize the CLI in.  -y, --yes                       Use defaults for all prompts. Individual flags will override defaults.      --bin=<value>               Supply answer for prompt: Command bin name the CLI will export      --module-type=<option>      Supply answer for prompt: Select a module type                                  <options: ESM|CommonJS>      --package-manager=<option>  Supply answer for prompt: Select a package manager                                  <options: npm|yarn|pnpm>      --topic-separator=<option>  Supply answer for prompt: Select a topic separator                                  <options: colons|spaces>DESCRIPTION  Initialize a new oclif CLI  This will add the necessary oclif bin files, add oclif config to package.json, and install @oclif/core and ts-node.EXAMPLES  Initialize a new CLI in the current directory    $ oclif init  Initialize a new CLI in a different directory    $ oclif init --output-dir "/path/to/existing/project"  Supply answers for specific prompts    $ oclif init --topic-separator colons --bin mycli
Hope you enjoy the new command! If you come across any issues or have any new ideas for this command, head over to the oclif/oclif repo and open a new issue.
All our best,
The oclif teamoclif Spring 2024 UpdateMarch 29, 2024 · 4 min readHello oclif developers! It's been a while since we last uploaded a blog - and a lot has happened.
We've been focusing on these high-level areas over the past couple of years:

Improving @oclif/core
ESM Support
Improving and revitalizing oclif.io
Re-engaging the oclif community

Improving @oclif/core​
Since we announced @oclif/core over three years ago, we've released two new major versions, each packed with lots of features that we're really excited about.
Here are some of these changes:

Full support for ESM and interoperability with CommonJS (more on this topic below).
Configurable command discovery strategies that give you more control over how commands are loaded at runtime. Check out the docs.
A new preparse hook that allows you to manipulate the provided arguments before they're parsed. Salesforce used this hook to implement a neat --flags-dir feature that translates local files into flags.
A new Performance class that you can use to track performance inside of @oclif/core and your own CLI or plugin. Check out the docs.
A new flag type, Flags.option, that lets you define a flag with a preset list of options. Typescript then uses the options to infer the flag's type.
Flags now have a relationship property that allows you to define more complex relationships between flags. Check out the flags docs for more information.
Flags now have a defaultHelp property that allows you to set the human readable default value in the command help. This property is useful when your flag's parse method returns a complex type, such as an object or a class. Check out the flags docs for more.
Commands now have a hiddenAliases property that allows you to define aliases that you want to hide from the user. The property is super helpful when you're trying to wean users off a deprecated command.
You can now use bun or tsx as dev runtimes (as opposed to node or ts-node).
A command's usage, args, and flags are now shown whenever a user forgets to provide a required arg or flag, or when they provided a non-existent flag.

If you need help migrating to the latest version, head over to core's README which has links to the migration guides. Feel free to open a new discussion if you need more hands-on help from us or the community.
ESM Support​
Version 3 of @oclif/core introduced full support for developing ESM plugins and CLIs. It also offered full support for interoperability between CommonJS and ESM plugins.
Put more simply, you can now migrate your CLI to ESM while keeping individual plugins in CommonJS (or vice versa). The upgrade path is now much simpler for you. You also don't need to worry about any community plugins that have migrated to ESM before you did (such as all the @oclif plugins) or are staunchly sticking with CommonJS for the foreseeable future.
Read more about this topic here.
Improving and Revitalizing oclif.io​
Another area of focus for us has been improving our documentation site, oclif.io.
While improving the quality and accuracy of the documentation was our priority, we also took the time to upgrade to the latest version of docusaurus. This new version gave our site a much-needed facelift, as well as cool new features such as dark mode and announcements.
If you have any feedback or are running into issues, we want to hear about it. Just create an issue in the oclif.io repo.
Re-engaging the oclif Community​
Lastly, our biggest priority at the moment is to re-engage the oclif community. We understand how frustrating it has been over the years to see your issues and pull requests go unacknowledged. We apologize for not prioritizing the community, and are earnestly trying to make sure that every issue and pull request gets the attention it deserves going forward.
We also opened up GitHub discussions for @oclif/core and the oclif CLI, where you can now post your questions or ideas. We hope you take advantage of them, we love hearing from you!
One last thing: we intend to publicly post our roadmap so you have more visibility into what we're working on. Stay tuned!
All our best,
The oclif teamAnnouncing oclif v2!January 12, 2022 · 5 min readHello and happy new year! It's our great pleasure to announce that we have released oclif v2, which uses the new @oclif/core library! 🎉
oclif v2 includes many changes that improve the experience of both creating and using an oclif CLI.
Going forward, we don't plan to make any updates to oclif v1 and its corresponding libraries, except for critical security fixes. See the compatibility matrix for a list of these libraries. In order to give developers time to migrate from v1 to v2, we're not completely dropping support yet. But at some point in the future we'll archive the v1 repositories and deprecate their versions on npm.
What’s changing?​
Repository Changes​
All repositories under the oclif org now use main as their primary branch and oclif-v1 as the legacy branch. The main  branch corresponds to oclif v2 and the oclif-v1 branch to oclif v1. If you find any repos that don’t have a main branch, you can safely assume that they're not used in oclif v2 and will be deprecated in the future.
Consolidating Tools & Libraries​
The oclif-dev CLI has now been incorporated into oclif. You now no longer need to install a separate package to manage your entire CLI’s lifecycle.
The following libraries have been consolidated under @oclif/core and will be deprecated at some point in the future. Read the migration guide to learn how to update your CLI or plugin to use the new core library.

@oclif/command
@oclif/config
@oclif/error
@oclif/help
@oclif/parser

No more single vs multi command CLIs​
There's only one "type" of oclif v2 CLI, but it can have as few or as many commands as a developer wants. As a result, there’s only one command to generate CLIs, oclif generate, as opposed to the old oclif single and oclif multi commands.
Node > 12​
To ensure oclif CLIs are as secure as possible, all v2 libraries and plugins support only Node 12 or higher as of now. Going forward, they'll support only Node Maintenance or higher, as defined by Node's release schedule here: https://nodejs.org/en/about/releases/.
What’s new?​
New example CLI​
oclif-hello-world is our new example repo. This is also the repo that's used as a template when running oclif generate to create a new CLI. This repo will always be able to be referenced as an example of what an oclif v2 CLI should look like.
Spaced commands​
oclif CLIs can now use spaces, instead of colons, to separate topics and subcommands. To enable this feature, simply add “topicSeparator": " " to the oclif config in your package.json. See an example in our example repo.
// Old commands that use :$ mycli do:something
// New spaced commands$ mycli do something

Note: Spaced commands are backwards compatible. So if you enable spaced commands for your CLI, users will still be able to use : as a separator. This ensures that any existing scripts don't break.

New Help Output​
We’ve revamped the way command help is outputted to the terminal, making it both easier to implement and easier to read. See the difference between the old help output on the left and the new help output on the right in the screenshots below.
oclif v1oclif v2
Notice that there are new sections for flags and global flags, examples are displayed with better spacing, and there is a section at the bottom called Configuration Variables. This Configuration Variables section is not part of the new help by default. But we've added support for custom help sections, which is what the sf CLI uses to create the new section.
Async Command Parsing​
We’ve also improved the performance of new CLIs by rewriting how commands are parsed on initialization. The new parser is asynchronous, which makes CLIs with a lot of commands or installed  plugins much faster.
What’s coming next?​
Part of our charter for the release of oclif v2 includes improving our engagement with the oclif community. We know that over the past couple of years we’ve reduced our involvement, and a lot of issues and PRs have languished in limbo. Hopefully you’ve already seen increased activity and responses from oclif maintainers recently, but if you haven’t, please don’t hesitate to ping us by tagging @admins in oclif repos.
We also want to start interviewing members of the oclif community to acquire feedback and prioritize the features and fixes you deem most important!
Best,
The oclif team

Reference material​
Migration Guide​
This guide explains how to upgrade a CLI or plugin from the old oclif v1 libraries to the new @oclif/core library that oclif v2 uses.
https://github.com/oclif/core/blob/main/MIGRATION.md
Compatibility Matrix​
The following matrix shows how the v1 libraries and plugins relate to the new v2 ones. Use this matrix as a guide to know what to drop and which versions to switch when upgrading your plugins and CLIs to v2.
oclif "v1"oclif "v2"Utility CLIsoclif@<2@oclif/dev-cli@<2oclif@>=2Main packages@oclif/command@oclif/config@oclif/errors@oclif/parser@oclif/plugin-help@oclif/core@>=1Node LTSNode v8-14Node v12+ (at time of writing)TypeScripttypescript@<4typescript@>=4Main plugins@oclif/plugin-autocomplete@<1@oclif/plugin-commands@<2@oclif/plugin-help@<4@oclif/plugin-not-found@<2@oclif/plugin-plugins@<2@oclif/plugin-update@<2plugin-warn-if-update-available@<2plugin-which@<2@oclif/plugin-autocomplete@>=1@oclif/plugin-commands@>=2@oclif/plugin-help@>=4@oclif/plugin-not-found@>=2@oclif/plugin-plugins@>=2@oclif/plugin-update@>=2@oclif/plugin-warn-if-update-available@>=2@oclif/plugin-which@>=2Introducing @oclif/coreMarch 1, 2021 · 3 min readGreetings!
We hope this blog post finds you well.
Introducing...​
We are excited to announce the next iteration of the oclif project today: @oclif/core.
We have learned a lot in the last three years of developing oclif, developing on oclif and supporting millions of command runs a day via Heroku and Salesforce CLIs.
@oclif/core ("Core") simplifies the oclif development experience and introduces highly requested new features.
Core combines the essential oclif packages into one "core" package, aptly named @oclif/core.
Core also introduces:

A default command option
Colon or space command syntax
Async command parsing
Command piping to arguments

With the introduction of default command functionality, Core simplifies the oclif project and removes the notion of single or multi command CLIs. Core CLIs can have 1 or many commands.
Along with Core, we moved the oclif-dev CLI into the oclif CLI creating a single "utility" CLI. This CLI also introduces a new AWS S3 compatible publishing scheme.
What to expect in the near future​
Core is in pre-release beta and being actively developed for new internal Salesforce CLIs.
Much documentation needs to be written in the coming months including migration paths. Migration onto Core should be as painless as possible with many exports remaining entirely unchanged. Look for forthcoming blog posts and documentation on oclif.io.
Early this summer, tentively June 1, we will release Core v1. Core's release will coincide with major bumps to many other oclif plugin packages. See the compatibility matrix below.
At Core's v1 release, the current "main" oclif packages (namely: command, config, errors & parser) will go into maintenance mode until Jan 2022. They will receive only bug and security fixes and they remain compatible with current versions of the oclif and oclif-dev CLIs. Afterwhich, they will be archived.
Companioning Core, the next major release of the oclif CLI (literally oclif@2) will generate Core CLIs.
Going forward​
We are excited to release Core! We invite you to poke around the Core repo. It may appear to be a big change but Core keeps what you already enjoy about oclif while reducing development complexity, project dependencies, package coupling and bundle size and introduces many requested features previously too prickly to weave into the current oclif architecture.
Best,
The oclif team
Reference: Compatibility matrix​
oclif "v1"oclif "Core"Utility CLIsoclif@<2@oclif/dev-cli@<2oclif@>=2Main packages@oclif/core@<2@oclif/config@<2@oclif/errors@<2@oclif/parser@<4@oclif/plugin-help@<4@oclif/core@>=1Node LTSNode v8-14Node v12+TypeScripttypescript@<4typescript@>=4Main plugins@oclif/plugin-autocomplete@<1@oclif/plugin-commands@<2@oclif/plugin-help@<4@oclif/plugin-not-found@<2@oclif/plugin-plugins@<2@oclif/plugin-update@<2plugin-warn-if-update-available@<2plugin-which@<2@oclif/plugin-autocomplete@>=2@oclif/plugin-commands@>=2@oclif/plugin-help@>=4@oclif/plugin-not-found@>=2@oclif/plugin-plugins@>=2@oclif/plugin-update@>=2@oclif/plugin-warn-if-update-available@>=2@oclif/plugin-which@>=2oclif Summer 2020 UpdateAugust 26, 2020 · 2 min readHello oclif developers! We hope you are all doing well.
Earlier this year, we started our planning for oclifconf v2 and, like all conference, had to change course. We opted not to hold a virtual conference, however, we wanted to take some time to highlight a few oclif features shipped this year.
Feature: Help templating​
One of the most requested features, help templating enables oclif developers to customize the help output for their CLI.
Read the announcement.
Feature: Custom error delegation​
This feature both improved how oclif throws and handles errors and allows oclif developers to overwrite or interject in oclif’s error handling.
Read the announcement.
Feature: postrun hooks​
We have added a new lifecycle event postrun. Your CLI can now run a hook after a command has ran.
See our hook documentation.
Feature: Root index command​
Previously, oclif would display CLI help if only the binary name with no command ID was invoked, oclif now supports a "root index" command. If present, a command defined at src/commands/index.ts will be run if no command ID is found.
1 million weekly downloads​
While exact oclif usage metrics are hard to pin down, we use npm download statistics of oclif packages as a rough approximation. Earlier this year, oclif's command package hit 1 million weekly downloads for the first time!
This year has been presented its challenges on everyone. We want to thank you, oclif developers, whom have taken the time to use and improve the oclif project. We look forward to seeing you all - in person - in the future!
All our best,
The oclif teamPretty Printable ErrorsJuly 1, 2020 · One min readOften CLIs are used as handy tools and when things go wrong it’s useful to have additional context. In oclif we have added a couple of additional properties that can show extra context to the users when an error is displayed. The code, ref and suggestions will now be displayed if they are included. This will work with an existing oclif CLI by adding the latest @oclif/errors and @oclif/core to the CLI's package.json dependencies.
For example, using this.error with the additional properties:
class TestError extends Command {  async run() {    this.error("An error has occurred!", {      code: "OCLIF_ERR",      ref: "https://oclif.io/docs/commands#thiserrormessage-string--error-options-code-string-exit-number",      suggestions: ["Use these extra properties to provide additional context"],    })  }}
would result with the following output:
›   Error: An error has occurred!›   Code: OCLIF_ERR›   Try this: Use these extra properties to provide additional context›   Reference: https://oclif.io/docs/commands#thiserrormessage-string--error-options-code-string-exit-number
If these properties are not provided then nothing changes and the CLI will continue to display the single error message output as it did before. Additionally, as part of this exercise we’ve added documentation around Error Handling in oclif which should come in handy if the need arises to extend oclif’s default handling of errors.Customizing Help in oclifMay 5, 2020 · 2 min readOut of the box oclif provides a great help experience for CLIs.
But what if, as an oclif developer, you want to customize some or all of the output?
You can now customize your CLI's help output by implementing the HelpBase abstract class.
Getting started with custom help​
If you have not done so yet, update @oclif/core.
$ yarn add --latest @oclif/core
To get started, first define the filepath to your help class in oclif's config in package.json. This is a relative path to the help class, without a file extension.
For this example, the help class will be created in a file at "[project root]/src/help.ts".
{  // ...  "oclif": {    "helpClass": "./lib/help"    // ...  }  // ...}
From here there are two paths, implement the HelpBase abstract class yourself or overwrite the parts of the default Help class you want to customize (ex: how command usage is displayed). We recommend the latter approach but cover both in the new Help Classes docs.
Separating TOPICS & COMMANDS in the new default Help class​
Previously, topics and child commands were listed in help output under a single list heading called "COMMANDS". But we found this can be slightly confusing. Some topics are commands also (a.k.a. topic-commands) while others are simply organizational namespacing (and when ran just show their help).
The new default Help class splits the list of children into distinct lists of "TOPICS" and "COMMANDS", with the possibility of an item appearing in both if it a topic-command. This makes it clearer what is expected to be ran - "COMMANDS" - and what is providing structure - "TOPICS" - when looking at the help output.
VERSION  plugin-help-example/0.0.0 darwin-x64 node-v12.12.0USAGE  $ plugin-help-example [COMMAND]TOPICS  topic  this is a topic and has child topics or commandsCOMMANDS  hello  describe the command here  help   display help for plugin-help-example
We look forward to seeing what custom help features you implement in your oclif CLIs with this new feature!oclif TSLint to ESLint MigrationDecember 5, 2019 · 3 min readBack in February of this year, plans were announced to deprecate TSLint in favor of ESLint. TSLint's goal has become to work toward a “unified developer experience” by supporting ESLint development going forward.
What has changed in oclif​
To keep inline with the community, oclif has transitioned to ESLint for all our core libraries as well as all our official plugins.
Starting in v1.15.x, oclif will now optionally generate projects with ESLint for both TypeScript and JavaScript CLI’s.
ESLint does require Node to be on stable LTS version, at the time of writing, Node 8.10.x, Node 10.13.x & Node 12.x.x.
How does this affect you​
Existing CLI’s are unchanged, but any newly generated CLI's will only give the option of using ESLint. If you are running tslint in your CLI, we recommend you switch to ESLint as well.
In migrating our projects we took the following steps (for an example of these changes see this pull request).


Install eslint
$ yarn add eslint eslint-config-oclif eslint-config-oclif-typescript --dev


Add eslint related files


$ echo '{  "extends": [    "oclif",    "oclif-typescript"  ],  "rules": {  }}' > .eslintrc


Remove tslint and related packages
$ yarn remove @oclif/tslint tslint


Remove tslint related configuration files
$ rm tslint.json


Change lint script in our package.json from something like:
"lint": "tsc -p test --noEmit && tslint -p test -t stylish"
to
"lint": "eslint . --ext .ts --config .eslintrc"


To preserve the test compile (tsc -p test --noEmit) we also made the following updates to our scripts:
"pretest": "tsc -p test --noEmit"
In some cases we had our posttest duplicating the same steps as our lint script so it’s cleaner to have it reference the lint job directly with:
"posttest": "yarn lint"

Run yarn lint --fix. This attempts to auto-fix any linting violations automatically. In the case an auto-fix isn’t available it should be fixed manually or ignored (see the eslint configuration doc for more information)
Do a search in the codebase for tslint and remove any unnecessary tslint disabling comments, like:

/* tslint:disable:object-literal-sort-keys */
If you are on a version of Node that is not supported by ESLint, you will also need to update your Node engine. ESLint supports Node 8, 10, and 12 so you should upgrade to the most recent Node version compatible with your CLI and also supported by ESLint (see ESLint's Installation and Usage instructions).
When will this take effect​
These changes have taken effect in oclif v1.15.1. When you generate a new CLI or plugin it will now contain configuration for ESLint instead of TSLint.oclif's Current Node SupportOctober 31, 2019 · 3 min readTo maintain a healthy project trajectory, oclif follows and supports Node Active LTS release, currently Node 10 & Node 12. This means ensuring that oclif continues to play nice with coming Active LTS Node versions and other packages in the ecosystem. Moving forward also means leaving older versions behind. Starting in 2020, Node will stop maintaining Node 8 and it is our intent at that time to also follow suit. Let’s take a look at a few ways we will be supporting these changes.
CI Environments​
CLIs created with the oclif cli going forward will be generated with a CircleCI configuration with Node 10 & 12 and an Appveyor configuration using Node 10. We have also added Node latest to CircleCi to be an early warning detection against coming Node changes (Node latest is managed by CircleCI).
We have already updated every oclif repo's CI configs to reflect this.
If your existing CLI uses either Appveyor or CircleCI you can update your config files also, like so:
.circleci/config.yml​
Your CircleCI config should contain a node-latest job, aliased as test. From this, there should be two extensions of this job for the Active LTS Node versions, Node 10 and Node 12.
  node-10:    <<: *node-latest    docker:      - image: node:10  node-12:    <<: *node-latest    docker:      - image: node:12
Notice that these declarations only change the Docker Node images used to run that job.
Additionally, the jobs listed within workflows must also be updated to reflect our changes in configuration:
    jobs:      - node-latest      - node-10      - node-12
appveyor.yml​
For appveyor we are currently only testing the oldest Active LTS Node version, Node 10. Update the nodejs_version proppert in your appveyor.yml file to reflect this.
environment:  nodejs_version: "10"
Deprecating Node 8 & Updating packge.json engines​
In Jan 2020, Node will end its Node 8 maintenance. We will follow suit by setting the package.json engine property in oclif packages to >=10 and bumping the package's major versions.
Depending on how you ship your CLI you may wish to also bump the engines version in your CLI's package.json. You can read more about the implications of the engines property configuration in the npm documentation.
Also consider distributing your CLI with its own Node version.
Packaged Node Version​
When using dev-cli to pack your CLI it will use the Node version as specified in your package.json under the oclif.update.node.version property. This value should reflect an Active LTS Node version (dev-cli does not currently enforce versions).
Supporting the future​
As a community we may discover bumps along the way as we upgrade. If you notice something related to oclif please feel free to open an issue or submit a pull request under the relevant oclif package within the org.
We look forward to using the latest from Node and the community and keeping oclif healthy along the way.oclifconf 2019: A RecapSeptember 16, 2019 · 4 min readIn May, Heroku and Salesforce Open Source organized oclifconf, a conference for developers & product managers building CLI tools on top of the open source oclif framework. The speakers came from various tech companies, such as Adobe, Netlify, and Apollo, who have already built amazing CLI experiences. The topics covered everything from the incredible capabilities oclif has unlocked, to the community-built plugins extending its functionality, and even what the behavior of an adaptive CLI tool might look like.
Below is a listing of all of the talks from the event, along with a short summary. Enjoy!
The future of oclif by Jeff Dickey​

In its relatively short lifetime, oclif has already inspired many developers and companies to adopt its framework as a means for implementing their own command-line tooling. In this talk, Jeff Dickey, an oclif founding team member, recaps the project's history and inspiration. He also looks towards the future and outlines some features and improvements that the tool could adapt. This isn't so much a definitive roadmap of where oclif is headed, but rather, a call to inspiration for developers eager to contribute! And if you are interested in contributing, check out the open issues in the oclif GitHub repo and come say "Hello!" on Spectrum Chat.
Open Source Citizenship by Josh Simmons​

When it comes to open source, it's more than just individuals now. More and more frequently, large corporations are contributing to projects by donating to contributors, sponsoring events, or upstreaming contributions. But keeping open source projects and communities healthy requires more than just money and brainpower. Josh Simmons surveyed multiple open source communities and relays his findings as to what help maintainers and contributors actually need in this talk.
Building an enterprise-grade CLI with oclif by Thomas Dvornik​

Security and performance are all about trust. While oclif is an extremely extensible framework for building CLI tooling, there are additional requirements to fulfill for enterprise businesses to adopt it that might not be necessary for individual developers. Thomas Dvornik outlines what he and his colleagues at Salesforce have implemented as plugins to oclif to satisfy these needs, including encrypted OAuth, plugin signing, lazy loading dependencies, synchronizing weekly releases and deprecations across dozens of repositories, and establishing cross-team coding and documentation standards.
How Adobe I/O built an extensible CLI with oclif by Jesse MacFadyen​

Perhaps oclif's most appealing feature is its support for plugins. In Cordova's case, they've created a sophisticated telemetry system that helps Adobe developers see which commands users are using--and reports on which ones are erroring out. By embedding a feedback system into the tool, users are even able to quickly send their suggestions to a form, without ever leaving the terminal. Jesse MacFadyen demonstrates how oclif's plugin system can work beyond simply executing commands.
Integrating oclif with GraphQL and Apollo by Evans Hauser​

For Evans Hauser and the team at Apollo, oclif is best thought of as "React for the CLI." As a client paired with a strongly-typed API contract to a server, it can deliver structured and consistent commands to retrieve external data. What better mechanism to use for this transfer than GraphQL, a framework which empowers the client to ask precisely for the data it needs, and nothing more?
Adaptive Intent-based CLI State Machines by Shawn Wang​

In designing oclif, Jeff Dickey wrote out 12 CLI factors to keep in mind. In this talk, Shawn Wang outlines a 13th: state. State is hard, because it depends on context, and context depends on understanding what a user intends to do, not what they are asking. Shawn is working towards enabling oclif to better understand the commands a user has entered, so that it can predict and interpret future commands that might be entered next. This would enable CLI tools to not just interpret a users' commands, but to also interpret their intent.\n\nIntroducing `oclif init` commandApril 10, 2024 · 2 min readThanks to the contribution of @joshcanhelp we released a new command for the oclif CLI called oclif init in version 4.8.0
The oclif init command allows you to initialize oclif in an existing project directory by adding the bare minimum requirements: a few pieces of configuration, bin scripts, and a couple of dependencies (@oclif/core and ts-node). This is slightly different from oclif generate, which will create an entirely new oclif project based on our templates.
oclif init will add the following:

bin scripts: bin/run.js, bin/run.cmd, bin/dev.js, and bin/dev.cmd
oclif section to package.json with bin, dirname, commands, and topicSeparator set (See Configuring Your CLI for more)
@oclif/core to dependencies in your package.json (if it's not already there)
ts-node to devDependencies in your package.json (if it's not already there)

Once you've initialized oclif, you can use the bin scripts to execute your CLI. You can also use the other oclif commands like oclif generate command and oclif generate hook to start adding new functionality.

❯ oclif init --helpInitialize a new oclif CLIUSAGE  $ oclif init [--bin <value>] [--module-type ESM|CommonJS] [--package-manager npm|yarn|pnpm] [--topic-separator    colons|spaces] [-d <value>] [-y]FLAGS  -d, --output-dir=<value>        Directory to initialize the CLI in.  -y, --yes                       Use defaults for all prompts. Individual flags will override defaults.      --bin=<value>               Supply answer for prompt: Command bin name the CLI will export      --module-type=<option>      Supply answer for prompt: Select a module type                                  <options: ESM|CommonJS>      --package-manager=<option>  Supply answer for prompt: Select a package manager                                  <options: npm|yarn|pnpm>      --topic-separator=<option>  Supply answer for prompt: Select a topic separator                                  <options: colons|spaces>DESCRIPTION  Initialize a new oclif CLI  This will add the necessary oclif bin files, add oclif config to package.json, and install @oclif/core and ts-node.EXAMPLES  Initialize a new CLI in the current directory    $ oclif init  Initialize a new CLI in a different directory    $ oclif init --output-dir "/path/to/existing/project"  Supply answers for specific prompts    $ oclif init --topic-separator colons --bin mycli
Hope you enjoy the new command! If you come across any issues or have any new ideas for this command, head over to the oclif/oclif repo and open a new issue.
All our best,
The oclif teamoclif Spring 2024 UpdateMarch 29, 2024 · 4 min readHello oclif developers! It's been a while since we last uploaded a blog - and a lot has happened.
We've been focusing on these high-level areas over the past couple of years:

Improving @oclif/core
ESM Support
Improving and revitalizing oclif.io
Re-engaging the oclif community

Improving @oclif/core​
Since we announced @oclif/core over three years ago, we've released two new major versions, each packed with lots of features that we're really excited about.
Here are some of these changes:

Full support for ESM and interoperability with CommonJS (more on this topic below).
Configurable command discovery strategies that give you more control over how commands are loaded at runtime. Check out the docs.
A new preparse hook that allows you to manipulate the provided arguments before they're parsed. Salesforce used this hook to implement a neat --flags-dir feature that translates local files into flags.
A new Performance class that you can use to track performance inside of @oclif/core and your own CLI or plugin. Check out the docs.
A new flag type, Flags.option, that lets you define a flag with a preset list of options. Typescript then uses the options to infer the flag's type.
Flags now have a relationship property that allows you to define more complex relationships between flags. Check out the flags docs for more information.
Flags now have a defaultHelp property that allows you to set the human readable default value in the command help. This property is useful when your flag's parse method returns a complex type, such as an object or a class. Check out the flags docs for more.
Commands now have a hiddenAliases property that allows you to define aliases that you want to hide from the user. The property is super helpful when you're trying to wean users off a deprecated command.
You can now use bun or tsx as dev runtimes (as opposed to node or ts-node).
A command's usage, args, and flags are now shown whenever a user forgets to provide a required arg or flag, or when they provided a non-existent flag.

If you need help migrating to the latest version, head over to core's README which has links to the migration guides. Feel free to open a new discussion if you need more hands-on help from us or the community.
ESM Support​
Version 3 of @oclif/core introduced full support for developing ESM plugins and CLIs. It also offered full support for interoperability between CommonJS and ESM plugins.
Put more simply, you can now migrate your CLI to ESM while keeping individual plugins in CommonJS (or vice versa). The upgrade path is now much simpler for you. You also don't need to worry about any community plugins that have migrated to ESM before you did (such as all the @oclif plugins) or are staunchly sticking with CommonJS for the foreseeable future.
Read more about this topic here.
Improving and Revitalizing oclif.io​
Another area of focus for us has been improving our documentation site, oclif.io.
While improving the quality and accuracy of the documentation was our priority, we also took the time to upgrade to the latest version of docusaurus. This new version gave our site a much-needed facelift, as well as cool new features such as dark mode and announcements.
If you have any feedback or are running into issues, we want to hear about it. Just create an issue in the oclif.io repo.
Re-engaging the oclif Community​
Lastly, our biggest priority at the moment is to re-engage the oclif community. We understand how frustrating it has been over the years to see your issues and pull requests go unacknowledged. We apologize for not prioritizing the community, and are earnestly trying to make sure that every issue and pull request gets the attention it deserves going forward.
We also opened up GitHub discussions for @oclif/core and the oclif CLI, where you can now post your questions or ideas. We hope you take advantage of them, we love hearing from you!
One last thing: we intend to publicly post our roadmap so you have more visibility into what we're working on. Stay tuned!
All our best,
The oclif teamAnnouncing oclif v2!January 12, 2022 · 5 min readHello and happy new year! It's our great pleasure to announce that we have released oclif v2, which uses the new @oclif/core library! 🎉
oclif v2 includes many changes that improve the experience of both creating and using an oclif CLI.
Going forward, we don't plan to make any updates to oclif v1 and its corresponding libraries, except for critical security fixes. See the compatibility matrix for a list of these libraries. In order to give developers time to migrate from v1 to v2, we're not completely dropping support yet. But at some point in the future we'll archive the v1 repositories and deprecate their versions on npm.
What’s changing?​
Repository Changes​
All repositories under the oclif org now use main as their primary branch and oclif-v1 as the legacy branch. The main  branch corresponds to oclif v2 and the oclif-v1 branch to oclif v1. If you find any repos that don’t have a main branch, you can safely assume that they're not used in oclif v2 and will be deprecated in the future.
Consolidating Tools & Libraries​
The oclif-dev CLI has now been incorporated into oclif. You now no longer need to install a separate package to manage your entire CLI’s lifecycle.
The following libraries have been consolidated under @oclif/core and will be deprecated at some point in the future. Read the migration guide to learn how to update your CLI or plugin to use the new core library.

@oclif/command
@oclif/config
@oclif/error
@oclif/help
@oclif/parser

No more single vs multi command CLIs​
There's only one "type" of oclif v2 CLI, but it can have as few or as many commands as a developer wants. As a result, there’s only one command to generate CLIs, oclif generate, as opposed to the old oclif single and oclif multi commands.
Node > 12​
To ensure oclif CLIs are as secure as possible, all v2 libraries and plugins support only Node 12 or higher as of now. Going forward, they'll support only Node Maintenance or higher, as defined by Node's release schedule here: https://nodejs.org/en/about/releases/.
What’s new?​
New example CLI​
oclif-hello-world is our new example repo. This is also the repo that's used as a template when running oclif generate to create a new CLI. This repo will always be able to be referenced as an example of what an oclif v2 CLI should look like.
Spaced commands​
oclif CLIs can now use spaces, instead of colons, to separate topics and subcommands. To enable this feature, simply add “topicSeparator": " " to the oclif config in your package.json. See an example in our example repo.
// Old commands that use :$ mycli do:something
// New spaced commands$ mycli do something

Note: Spaced commands are backwards compatible. So if you enable spaced commands for your CLI, users will still be able to use : as a separator. This ensures that any existing scripts don't break.

New Help Output​
We’ve revamped the way command help is outputted to the terminal, making it both easier to implement and easier to read. See the difference between the old help output on the left and the new help output on the right in the screenshots below.
oclif v1oclif v2
Notice that there are new sections for flags and global flags, examples are displayed with better spacing, and there is a section at the bottom called Configuration Variables. This Configuration Variables section is not part of the new help by default. But we've added support for custom help sections, which is what the sf CLI uses to create the new section.
Async Command Parsing​
We’ve also improved the performance of new CLIs by rewriting how commands are parsed on initialization. The new parser is asynchronous, which makes CLIs with a lot of commands or installed  plugins much faster.
What’s coming next?​
Part of our charter for the release of oclif v2 includes improving our engagement with the oclif community. We know that over the past couple of years we’ve reduced our involvement, and a lot of issues and PRs have languished in limbo. Hopefully you’ve already seen increased activity and responses from oclif maintainers recently, but if you haven’t, please don’t hesitate to ping us by tagging @admins in oclif repos.
We also want to start interviewing members of the oclif community to acquire feedback and prioritize the features and fixes you deem most important!
Best,
The oclif team

Reference material​
Migration Guide​
This guide explains how to upgrade a CLI or plugin from the old oclif v1 libraries to the new @oclif/core library that oclif v2 uses.
https://github.com/oclif/core/blob/main/MIGRATION.md
Compatibility Matrix​
The following matrix shows how the v1 libraries and plugins relate to the new v2 ones. Use this matrix as a guide to know what to drop and which versions to switch when upgrading your plugins and CLIs to v2.
oclif "v1"oclif "v2"Utility CLIsoclif@<2@oclif/dev-cli@<2oclif@>=2Main packages@oclif/command@oclif/config@oclif/errors@oclif/parser@oclif/plugin-help@oclif/core@>=1Node LTSNode v8-14Node v12+ (at time of writing)TypeScripttypescript@<4typescript@>=4Main plugins@oclif/plugin-autocomplete@<1@oclif/plugin-commands@<2@oclif/plugin-help@<4@oclif/plugin-not-found@<2@oclif/plugin-plugins@<2@oclif/plugin-update@<2plugin-warn-if-update-available@<2plugin-which@<2@oclif/plugin-autocomplete@>=1@oclif/plugin-commands@>=2@oclif/plugin-help@>=4@oclif/plugin-not-found@>=2@oclif/plugin-plugins@>=2@oclif/plugin-update@>=2@oclif/plugin-warn-if-update-available@>=2@oclif/plugin-which@>=2Introducing @oclif/coreMarch 1, 2021 · 3 min readGreetings!
We hope this blog post finds you well.
Introducing...​
We are excited to announce the next iteration of the oclif project today: @oclif/core.
We have learned a lot in the last three years of developing oclif, developing on oclif and supporting millions of command runs a day via Heroku and Salesforce CLIs.
@oclif/core ("Core") simplifies the oclif development experience and introduces highly requested new features.
Core combines the essential oclif packages into one "core" package, aptly named @oclif/core.
Core also introduces:

A default command option
Colon or space command syntax
Async command parsing
Command piping to arguments

With the introduction of default command functionality, Core simplifies the oclif project and removes the notion of single or multi command CLIs. Core CLIs can have 1 or many commands.
Along with Core, we moved the oclif-dev CLI into the oclif CLI creating a single "utility" CLI. This CLI also introduces a new AWS S3 compatible publishing scheme.
What to expect in the near future​
Core is in pre-release beta and being actively developed for new internal Salesforce CLIs.
Much documentation needs to be written in the coming months including migration paths. Migration onto Core should be as painless as possible with many exports remaining entirely unchanged. Look for forthcoming blog posts and documentation on oclif.io.
Early this summer, tentively June 1, we will release Core v1. Core's release will coincide with major bumps to many other oclif plugin packages. See the compatibility matrix below.
At Core's v1 release, the current "main" oclif packages (namely: command, config, errors & parser) will go into maintenance mode until Jan 2022. They will receive only bug and security fixes and they remain compatible with current versions of the oclif and oclif-dev CLIs. Afterwhich, they will be archived.
Companioning Core, the next major release of the oclif CLI (literally oclif@2) will generate Core CLIs.
Going forward​
We are excited to release Core! We invite you to poke around the Core repo. It may appear to be a big change but Core keeps what you already enjoy about oclif while reducing development complexity, project dependencies, package coupling and bundle size and introduces many requested features previously too prickly to weave into the current oclif architecture.
Best,
The oclif team
Reference: Compatibility matrix​
oclif "v1"oclif "Core"Utility CLIsoclif@<2@oclif/dev-cli@<2oclif@>=2Main packages@oclif/core@<2@oclif/config@<2@oclif/errors@<2@oclif/parser@<4@oclif/plugin-help@<4@oclif/core@>=1Node LTSNode v8-14Node v12+TypeScripttypescript@<4typescript@>=4Main plugins@oclif/plugin-autocomplete@<1@oclif/plugin-commands@<2@oclif/plugin-help@<4@oclif/plugin-not-found@<2@oclif/plugin-plugins@<2@oclif/plugin-update@<2plugin-warn-if-update-available@<2plugin-which@<2@oclif/plugin-autocomplete@>=2@oclif/plugin-commands@>=2@oclif/plugin-help@>=4@oclif/plugin-not-found@>=2@oclif/plugin-plugins@>=2@oclif/plugin-update@>=2@oclif/plugin-warn-if-update-available@>=2@oclif/plugin-which@>=2oclif Summer 2020 UpdateAugust 26, 2020 · 2 min readHello oclif developers! We hope you are all doing well.
Earlier this year, we started our planning for oclifconf v2 and, like all conference, had to change course. We opted not to hold a virtual conference, however, we wanted to take some time to highlight a few oclif features shipped this year.
Feature: Help templating​
One of the most requested features, help templating enables oclif developers to customize the help output for their CLI.
Read the announcement.
Feature: Custom error delegation​
This feature both improved how oclif throws and handles errors and allows oclif developers to overwrite or interject in oclif’s error handling.
Read the announcement.
Feature: postrun hooks​
We have added a new lifecycle event postrun. Your CLI can now run a hook after a command has ran.
See our hook documentation.
Feature: Root index command​
Previously, oclif would display CLI help if only the binary name with no command ID was invoked, oclif now supports a "root index" command. If present, a command defined at src/commands/index.ts will be run if no command ID is found.
1 million weekly downloads​
While exact oclif usage metrics are hard to pin down, we use npm download statistics of oclif packages as a rough approximation. Earlier this year, oclif's command package hit 1 million weekly downloads for the first time!
This year has been presented its challenges on everyone. We want to thank you, oclif developers, whom have taken the time to use and improve the oclif project. We look forward to seeing you all - in person - in the future!
All our best,
The oclif teamPretty Printable ErrorsJuly 1, 2020 · One min readOften CLIs are used as handy tools and when things go wrong it’s useful to have additional context. In oclif we have added a couple of additional properties that can show extra context to the users when an error is displayed. The code, ref and suggestions will now be displayed if they are included. This will work with an existing oclif CLI by adding the latest @oclif/errors and @oclif/core to the CLI's package.json dependencies.
For example, using this.error with the additional properties:
class TestError extends Command {  async run() {    this.error("An error has occurred!", {      code: "OCLIF_ERR",      ref: "https://oclif.io/docs/commands#thiserrormessage-string--error-options-code-string-exit-number",      suggestions: ["Use these extra properties to provide additional context"],    })  }}
would result with the following output:
›   Error: An error has occurred!›   Code: OCLIF_ERR›   Try this: Use these extra properties to provide additional context›   Reference: https://oclif.io/docs/commands#thiserrormessage-string--error-options-code-string-exit-number
If these properties are not provided then nothing changes and the CLI will continue to display the single error message output as it did before. Additionally, as part of this exercise we’ve added documentation around Error Handling in oclif which should come in handy if the need arises to extend oclif’s default handling of errors.Customizing Help in oclifMay 5, 2020 · 2 min readOut of the box oclif provides a great help experience for CLIs.
But what if, as an oclif developer, you want to customize some or all of the output?
You can now customize your CLI's help output by implementing the HelpBase abstract class.
Getting started with custom help​
If you have not done so yet, update @oclif/core.
$ yarn add --latest @oclif/core
To get started, first define the filepath to your help class in oclif's config in package.json. This is a relative path to the help class, without a file extension.
For this example, the help class will be created in a file at "[project root]/src/help.ts".
{  // ...  "oclif": {    "helpClass": "./lib/help"    // ...  }  // ...}
From here there are two paths, implement the HelpBase abstract class yourself or overwrite the parts of the default Help class you want to customize (ex: how command usage is displayed). We recommend the latter approach but cover both in the new Help Classes docs.
Separating TOPICS & COMMANDS in the new default Help class​
Previously, topics and child commands were listed in help output under a single list heading called "COMMANDS". But we found this can be slightly confusing. Some topics are commands also (a.k.a. topic-commands) while others are simply organizational namespacing (and when ran just show their help).
The new default Help class splits the list of children into distinct lists of "TOPICS" and "COMMANDS", with the possibility of an item appearing in both if it a topic-command. This makes it clearer what is expected to be ran - "COMMANDS" - and what is providing structure - "TOPICS" - when looking at the help output.
VERSION  plugin-help-example/0.0.0 darwin-x64 node-v12.12.0USAGE  $ plugin-help-example [COMMAND]TOPICS  topic  this is a topic and has child topics or commandsCOMMANDS  hello  describe the command here  help   display help for plugin-help-example
We look forward to seeing what custom help features you implement in your oclif CLIs with this new feature!oclif TSLint to ESLint MigrationDecember 5, 2019 · 3 min readBack in February of this year, plans were announced to deprecate TSLint in favor of ESLint. TSLint's goal has become to work toward a “unified developer experience” by supporting ESLint development going forward.
What has changed in oclif​
To keep inline with the community, oclif has transitioned to ESLint for all our core libraries as well as all our official plugins.
Starting in v1.15.x, oclif will now optionally generate projects with ESLint for both TypeScript and JavaScript CLI’s.
ESLint does require Node to be on stable LTS version, at the time of writing, Node 8.10.x, Node 10.13.x & Node 12.x.x.
How does this affect you​
Existing CLI’s are unchanged, but any newly generated CLI's will only give the option of using ESLint. If you are running tslint in your CLI, we recommend you switch to ESLint as well.
In migrating our projects we took the following steps (for an example of these changes see this pull request).


Install eslint
$ yarn add eslint eslint-config-oclif eslint-config-oclif-typescript --dev


Add eslint related files


$ echo '{  "extends": [    "oclif",    "oclif-typescript"  ],  "rules": {  }}' > .eslintrc


Remove tslint and related packages
$ yarn remove @oclif/tslint tslint


Remove tslint related configuration files
$ rm tslint.json


Change lint script in our package.json from something like:
"lint": "tsc -p test --noEmit && tslint -p test -t stylish"
to
"lint": "eslint . --ext .ts --config .eslintrc"


To preserve the test compile (tsc -p test --noEmit) we also made the following updates to our scripts:
"pretest": "tsc -p test --noEmit"
In some cases we had our posttest duplicating the same steps as our lint script so it’s cleaner to have it reference the lint job directly with:
"posttest": "yarn lint"

Run yarn lint --fix. This attempts to auto-fix any linting violations automatically. In the case an auto-fix isn’t available it should be fixed manually or ignored (see the eslint configuration doc for more information)
Do a search in the codebase for tslint and remove any unnecessary tslint disabling comments, like:

/* tslint:disable:object-literal-sort-keys */
If you are on a version of Node that is not supported by ESLint, you will also need to update your Node engine. ESLint supports Node 8, 10, and 12 so you should upgrade to the most recent Node version compatible with your CLI and also supported by ESLint (see ESLint's Installation and Usage instructions).
When will this take effect​
These changes have taken effect in oclif v1.15.1. When you generate a new CLI or plugin it will now contain configuration for ESLint instead of TSLint.oclif's Current Node SupportOctober 31, 2019 · 3 min readTo maintain a healthy project trajectory, oclif follows and supports Node Active LTS release, currently Node 10 & Node 12. This means ensuring that oclif continues to play nice with coming Active LTS Node versions and other packages in the ecosystem. Moving forward also means leaving older versions behind. Starting in 2020, Node will stop maintaining Node 8 and it is our intent at that time to also follow suit. Let’s take a look at a few ways we will be supporting these changes.
CI Environments​
CLIs created with the oclif cli going forward will be generated with a CircleCI configuration with Node 10 & 12 and an Appveyor configuration using Node 10. We have also added Node latest to CircleCi to be an early warning detection against coming Node changes (Node latest is managed by CircleCI).
We have already updated every oclif repo's CI configs to reflect this.
If your existing CLI uses either Appveyor or CircleCI you can update your config files also, like so:
.circleci/config.yml​
Your CircleCI config should contain a node-latest job, aliased as test. From this, there should be two extensions of this job for the Active LTS Node versions, Node 10 and Node 12.
  node-10:    <<: *node-latest    docker:      - image: node:10  node-12:    <<: *node-latest    docker:      - image: node:12
Notice that these declarations only change the Docker Node images used to run that job.
Additionally, the jobs listed within workflows must also be updated to reflect our changes in configuration:
    jobs:      - node-latest      - node-10      - node-12
appveyor.yml​
For appveyor we are currently only testing the oldest Active LTS Node version, Node 10. Update the nodejs_version proppert in your appveyor.yml file to reflect this.
environment:  nodejs_version: "10"
Deprecating Node 8 & Updating packge.json engines​
In Jan 2020, Node will end its Node 8 maintenance. We will follow suit by setting the package.json engine property in oclif packages to >=10 and bumping the package's major versions.
Depending on how you ship your CLI you may wish to also bump the engines version in your CLI's package.json. You can read more about the implications of the engines property configuration in the npm documentation.
Also consider distributing your CLI with its own Node version.
Packaged Node Version​
When using dev-cli to pack your CLI it will use the Node version as specified in your package.json under the oclif.update.node.version property. This value should reflect an Active LTS Node version (dev-cli does not currently enforce versions).
Supporting the future​
As a community we may discover bumps along the way as we upgrade. If you notice something related to oclif please feel free to open an issue or submit a pull request under the relevant oclif package within the org.
We look forward to using the latest from Node and the community and keeping oclif healthy along the way.oclifconf 2019: A RecapSeptember 16, 2019 · 4 min readIn May, Heroku and Salesforce Open Source organized oclifconf, a conference for developers & product managers building CLI tools on top of the open source oclif framework. The speakers came from various tech companies, such as Adobe, Netlify, and Apollo, who have already built amazing CLI experiences. The topics covered everything from the incredible capabilities oclif has unlocked, to the community-built plugins extending its functionality, and even what the behavior of an adaptive CLI tool might look like.
Below is a listing of all of the talks from the event, along with a short summary. Enjoy!
The future of oclif by Jeff Dickey​

In its relatively short lifetime, oclif has already inspired many developers and companies to adopt its framework as a means for implementing their own command-line tooling. In this talk, Jeff Dickey, an oclif founding team member, recaps the project's history and inspiration. He also looks towards the future and outlines some features and improvements that the tool could adapt. This isn't so much a definitive roadmap of where oclif is headed, but rather, a call to inspiration for developers eager to contribute! And if you are interested in contributing, check out the open issues in the oclif GitHub repo and come say "Hello!" on Spectrum Chat.
Open Source Citizenship by Josh Simmons​

When it comes to open source, it's more than just individuals now. More and more frequently, large corporations are contributing to projects by donating to contributors, sponsoring events, or upstreaming contributions. But keeping open source projects and communities healthy requires more than just money and brainpower. Josh Simmons surveyed multiple open source communities and relays his findings as to what help maintainers and contributors actually need in this talk.
Building an enterprise-grade CLI with oclif by Thomas Dvornik​

Security and performance are all about trust. While oclif is an extremely extensible framework for building CLI tooling, there are additional requirements to fulfill for enterprise businesses to adopt it that might not be necessary for individual developers. Thomas Dvornik outlines what he and his colleagues at Salesforce have implemented as plugins to oclif to satisfy these needs, including encrypted OAuth, plugin signing, lazy loading dependencies, synchronizing weekly releases and deprecations across dozens of repositories, and establishing cross-team coding and documentation standards.
How Adobe I/O built an extensible CLI with oclif by Jesse MacFadyen​

Perhaps oclif's most appealing feature is its support for plugins. In Cordova's case, they've created a sophisticated telemetry system that helps Adobe developers see which commands users are using--and reports on which ones are erroring out. By embedding a feedback system into the tool, users are even able to quickly send their suggestions to a form, without ever leaving the terminal. Jesse MacFadyen demonstrates how oclif's plugin system can work beyond simply executing commands.
Integrating oclif with GraphQL and Apollo by Evans Hauser​

For Evans Hauser and the team at Apollo, oclif is best thought of as "React for the CLI." As a client paired with a strongly-typed API contract to a server, it can deliver structured and consistent commands to retrieve external data. What better mechanism to use for this transfer than GraphQL, a framework which empowers the client to ask precisely for the data it needs, and nothing more?
Adaptive Intent-based CLI State Machines by Shawn Wang​

In designing oclif, Jeff Dickey wrote out 12 CLI factors to keep in mind. In this talk, Shawn Wang outlines a 13th: state. State is hard, because it depends on context, and context depends on understanding what a user intends to do, not what they are asking. Shawn is working towards enabling oclif to better understand the commands a user has entered, so that it can predict and interpret future commands that might be entered next. This would enable CLI tools to not just interpret a users' commands, but to also interpret their intent.Older Entries\n\n\n\nIntroducing `oclif init` commandApril 10, 2024 · 2 min readThanks to the contribution of @joshcanhelp we released a new command for the oclif CLI called oclif init in version 4.8.0
The oclif init command allows you to initialize oclif in an existing project directory by adding the bare minimum requirements: a few pieces of configuration, bin scripts, and a couple of dependencies (@oclif/core and ts-node). This is slightly different from oclif generate, which will create an entirely new oclif project based on our templates.
oclif init will add the following:

bin scripts: bin/run.js, bin/run.cmd, bin/dev.js, and bin/dev.cmd
oclif section to package.json with bin, dirname, commands, and topicSeparator set (See Configuring Your CLI for more)
@oclif/core to dependencies in your package.json (if it's not already there)
ts-node to devDependencies in your package.json (if it's not already there)

Once you've initialized oclif, you can use the bin scripts to execute your CLI. You can also use the other oclif commands like oclif generate command and oclif generate hook to start adding new functionality.

❯ oclif init --helpInitialize a new oclif CLIUSAGE  $ oclif init [--bin <value>] [--module-type ESM|CommonJS] [--package-manager npm|yarn|pnpm] [--topic-separator    colons|spaces] [-d <value>] [-y]FLAGS  -d, --output-dir=<value>        Directory to initialize the CLI in.  -y, --yes                       Use defaults for all prompts. Individual flags will override defaults.      --bin=<value>               Supply answer for prompt: Command bin name the CLI will export      --module-type=<option>      Supply answer for prompt: Select a module type                                  <options: ESM|CommonJS>      --package-manager=<option>  Supply answer for prompt: Select a package manager                                  <options: npm|yarn|pnpm>      --topic-separator=<option>  Supply answer for prompt: Select a topic separator                                  <options: colons|spaces>DESCRIPTION  Initialize a new oclif CLI  This will add the necessary oclif bin files, add oclif config to package.json, and install @oclif/core and ts-node.EXAMPLES  Initialize a new CLI in the current directory    $ oclif init  Initialize a new CLI in a different directory    $ oclif init --output-dir "/path/to/existing/project"  Supply answers for specific prompts    $ oclif init --topic-separator colons --bin mycli
Hope you enjoy the new command! If you come across any issues or have any new ideas for this command, head over to the oclif/oclif repo and open a new issue.
All our best,
The oclif teamoclif Spring 2024 UpdateMarch 29, 2024 · 4 min readHello oclif developers! It's been a while since we last uploaded a blog - and a lot has happened.
We've been focusing on these high-level areas over the past couple of years:

Improving @oclif/core
ESM Support
Improving and revitalizing oclif.io
Re-engaging the oclif community

Improving @oclif/core​
Since we announced @oclif/core over three years ago, we've released two new major versions, each packed with lots of features that we're really excited about.
Here are some of these changes:

Full support for ESM and interoperability with CommonJS (more on this topic below).
Configurable command discovery strategies that give you more control over how commands are loaded at runtime. Check out the docs.
A new preparse hook that allows you to manipulate the provided arguments before they're parsed. Salesforce used this hook to implement a neat --flags-dir feature that translates local files into flags.
A new Performance class that you can use to track performance inside of @oclif/core and your own CLI or plugin. Check out the docs.
A new flag type, Flags.option, that lets you define a flag with a preset list of options. Typescript then uses the options to infer the flag's type.
Flags now have a relationship property that allows you to define more complex relationships between flags. Check out the flags docs for more information.
Flags now have a defaultHelp property that allows you to set the human readable default value in the command help. This property is useful when your flag's parse method returns a complex type, such as an object or a class. Check out the flags docs for more.
Commands now have a hiddenAliases property that allows you to define aliases that you want to hide from the user. The property is super helpful when you're trying to wean users off a deprecated command.
You can now use bun or tsx as dev runtimes (as opposed to node or ts-node).
A command's usage, args, and flags are now shown whenever a user forgets to provide a required arg or flag, or when they provided a non-existent flag.

If you need help migrating to the latest version, head over to core's README which has links to the migration guides. Feel free to open a new discussion if you need more hands-on help from us or the community.
ESM Support​
Version 3 of @oclif/core introduced full support for developing ESM plugins and CLIs. It also offered full support for interoperability between CommonJS and ESM plugins.
Put more simply, you can now migrate your CLI to ESM while keeping individual plugins in CommonJS (or vice versa). The upgrade path is now much simpler for you. You also don't need to worry about any community plugins that have migrated to ESM before you did (such as all the @oclif plugins) or are staunchly sticking with CommonJS for the foreseeable future.
Read more about this topic here.
Improving and Revitalizing oclif.io​
Another area of focus for us has been improving our documentation site, oclif.io.
While improving the quality and accuracy of the documentation was our priority, we also took the time to upgrade to the latest version of docusaurus. This new version gave our site a much-needed facelift, as well as cool new features such as dark mode and announcements.
If you have any feedback or are running into issues, we want to hear about it. Just create an issue in the oclif.io repo.
Re-engaging the oclif Community​
Lastly, our biggest priority at the moment is to re-engage the oclif community. We understand how frustrating it has been over the years to see your issues and pull requests go unacknowledged. We apologize for not prioritizing the community, and are earnestly trying to make sure that every issue and pull request gets the attention it deserves going forward.
We also opened up GitHub discussions for @oclif/core and the oclif CLI, where you can now post your questions or ideas. We hope you take advantage of them, we love hearing from you!
One last thing: we intend to publicly post our roadmap so you have more visibility into what we're working on. Stay tuned!
All our best,
The oclif teamAnnouncing oclif v2!January 12, 2022 · 5 min readHello and happy new year! It's our great pleasure to announce that we have released oclif v2, which uses the new @oclif/core library! 🎉
oclif v2 includes many changes that improve the experience of both creating and using an oclif CLI.
Going forward, we don't plan to make any updates to oclif v1 and its corresponding libraries, except for critical security fixes. See the compatibility matrix for a list of these libraries. In order to give developers time to migrate from v1 to v2, we're not completely dropping support yet. But at some point in the future we'll archive the v1 repositories and deprecate their versions on npm.
What’s changing?​
Repository Changes​
All repositories under the oclif org now use main as their primary branch and oclif-v1 as the legacy branch. The main  branch corresponds to oclif v2 and the oclif-v1 branch to oclif v1. If you find any repos that don’t have a main branch, you can safely assume that they're not used in oclif v2 and will be deprecated in the future.
Consolidating Tools & Libraries​
The oclif-dev CLI has now been incorporated into oclif. You now no longer need to install a separate package to manage your entire CLI’s lifecycle.
The following libraries have been consolidated under @oclif/core and will be deprecated at some point in the future. Read the migration guide to learn how to update your CLI or plugin to use the new core library.

@oclif/command
@oclif/config
@oclif/error
@oclif/help
@oclif/parser

No more single vs multi command CLIs​
There's only one "type" of oclif v2 CLI, but it can have as few or as many commands as a developer wants. As a result, there’s only one command to generate CLIs, oclif generate, as opposed to the old oclif single and oclif multi commands.
Node > 12​
To ensure oclif CLIs are as secure as possible, all v2 libraries and plugins support only Node 12 or higher as of now. Going forward, they'll support only Node Maintenance or higher, as defined by Node's release schedule here: https://nodejs.org/en/about/releases/.
What’s new?​
New example CLI​
oclif-hello-world is our new example repo. This is also the repo that's used as a template when running oclif generate to create a new CLI. This repo will always be able to be referenced as an example of what an oclif v2 CLI should look like.
Spaced commands​
oclif CLIs can now use spaces, instead of colons, to separate topics and subcommands. To enable this feature, simply add “topicSeparator": " " to the oclif config in your package.json. See an example in our example repo.
// Old commands that use :$ mycli do:something
// New spaced commands$ mycli do something

Note: Spaced commands are backwards compatible. So if you enable spaced commands for your CLI, users will still be able to use : as a separator. This ensures that any existing scripts don't break.

New Help Output​
We’ve revamped the way command help is outputted to the terminal, making it both easier to implement and easier to read. See the difference between the old help output on the left and the new help output on the right in the screenshots below.
oclif v1oclif v2
Notice that there are new sections for flags and global flags, examples are displayed with better spacing, and there is a section at the bottom called Configuration Variables. This Configuration Variables section is not part of the new help by default. But we've added support for custom help sections, which is what the sf CLI uses to create the new section.
Async Command Parsing​
We’ve also improved the performance of new CLIs by rewriting how commands are parsed on initialization. The new parser is asynchronous, which makes CLIs with a lot of commands or installed  plugins much faster.
What’s coming next?​
Part of our charter for the release of oclif v2 includes improving our engagement with the oclif community. We know that over the past couple of years we’ve reduced our involvement, and a lot of issues and PRs have languished in limbo. Hopefully you’ve already seen increased activity and responses from oclif maintainers recently, but if you haven’t, please don’t hesitate to ping us by tagging @admins in oclif repos.
We also want to start interviewing members of the oclif community to acquire feedback and prioritize the features and fixes you deem most important!
Best,
The oclif team

Reference material​
Migration Guide​
This guide explains how to upgrade a CLI or plugin from the old oclif v1 libraries to the new @oclif/core library that oclif v2 uses.
https://github.com/oclif/core/blob/main/MIGRATION.md
Compatibility Matrix​
The following matrix shows how the v1 libraries and plugins relate to the new v2 ones. Use this matrix as a guide to know what to drop and which versions to switch when upgrading your plugins and CLIs to v2.
oclif "v1"oclif "v2"Utility CLIsoclif@<2@oclif/dev-cli@<2oclif@>=2Main packages@oclif/command@oclif/config@oclif/errors@oclif/parser@oclif/plugin-help@oclif/core@>=1Node LTSNode v8-14Node v12+ (at time of writing)TypeScripttypescript@<4typescript@>=4Main plugins@oclif/plugin-autocomplete@<1@oclif/plugin-commands@<2@oclif/plugin-help@<4@oclif/plugin-not-found@<2@oclif/plugin-plugins@<2@oclif/plugin-update@<2plugin-warn-if-update-available@<2plugin-which@<2@oclif/plugin-autocomplete@>=1@oclif/plugin-commands@>=2@oclif/plugin-help@>=4@oclif/plugin-not-found@>=2@oclif/plugin-plugins@>=2@oclif/plugin-update@>=2@oclif/plugin-warn-if-update-available@>=2@oclif/plugin-which@>=2Introducing @oclif/coreMarch 1, 2021 · 3 min readGreetings!
We hope this blog post finds you well.
Introducing...​
We are excited to announce the next iteration of the oclif project today: @oclif/core.
We have learned a lot in the last three years of developing oclif, developing on oclif and supporting millions of command runs a day via Heroku and Salesforce CLIs.
@oclif/core ("Core") simplifies the oclif development experience and introduces highly requested new features.
Core combines the essential oclif packages into one "core" package, aptly named @oclif/core.
Core also introduces:

A default command option
Colon or space command syntax
Async command parsing
Command piping to arguments

With the introduction of default command functionality, Core simplifies the oclif project and removes the notion of single or multi command CLIs. Core CLIs can have 1 or many commands.
Along with Core, we moved the oclif-dev CLI into the oclif CLI creating a single "utility" CLI. This CLI also introduces a new AWS S3 compatible publishing scheme.
What to expect in the near future​
Core is in pre-release beta and being actively developed for new internal Salesforce CLIs.
Much documentation needs to be written in the coming months including migration paths. Migration onto Core should be as painless as possible with many exports remaining entirely unchanged. Look for forthcoming blog posts and documentation on oclif.io.
Early this summer, tentively June 1, we will release Core v1. Core's release will coincide with major bumps to many other oclif plugin packages. See the compatibility matrix below.
At Core's v1 release, the current "main" oclif packages (namely: command, config, errors & parser) will go into maintenance mode until Jan 2022. They will receive only bug and security fixes and they remain compatible with current versions of the oclif and oclif-dev CLIs. Afterwhich, they will be archived.
Companioning Core, the next major release of the oclif CLI (literally oclif@2) will generate Core CLIs.
Going forward​
We are excited to release Core! We invite you to poke around the Core repo. It may appear to be a big change but Core keeps what you already enjoy about oclif while reducing development complexity, project dependencies, package coupling and bundle size and introduces many requested features previously too prickly to weave into the current oclif architecture.
Best,
The oclif team
Reference: Compatibility matrix​
oclif "v1"oclif "Core"Utility CLIsoclif@<2@oclif/dev-cli@<2oclif@>=2Main packages@oclif/core@<2@oclif/config@<2@oclif/errors@<2@oclif/parser@<4@oclif/plugin-help@<4@oclif/core@>=1Node LTSNode v8-14Node v12+TypeScripttypescript@<4typescript@>=4Main plugins@oclif/plugin-autocomplete@<1@oclif/plugin-commands@<2@oclif/plugin-help@<4@oclif/plugin-not-found@<2@oclif/plugin-plugins@<2@oclif/plugin-update@<2plugin-warn-if-update-available@<2plugin-which@<2@oclif/plugin-autocomplete@>=2@oclif/plugin-commands@>=2@oclif/plugin-help@>=4@oclif/plugin-not-found@>=2@oclif/plugin-plugins@>=2@oclif/plugin-update@>=2@oclif/plugin-warn-if-update-available@>=2@oclif/plugin-which@>=2oclif Summer 2020 UpdateAugust 26, 2020 · 2 min readHello oclif developers! We hope you are all doing well.
Earlier this year, we started our planning for oclifconf v2 and, like all conference, had to change course. We opted not to hold a virtual conference, however, we wanted to take some time to highlight a few oclif features shipped this year.
Feature: Help templating​
One of the most requested features, help templating enables oclif developers to customize the help output for their CLI.
Read the announcement.
Feature: Custom error delegation​
This feature both improved how oclif throws and handles errors and allows oclif developers to overwrite or interject in oclif’s error handling.
Read the announcement.
Feature: postrun hooks​
We have added a new lifecycle event postrun. Your CLI can now run a hook after a command has ran.
See our hook documentation.
Feature: Root index command​
Previously, oclif would display CLI help if only the binary name with no command ID was invoked, oclif now supports a "root index" command. If present, a command defined at src/commands/index.ts will be run if no command ID is found.
1 million weekly downloads​
While exact oclif usage metrics are hard to pin down, we use npm download statistics of oclif packages as a rough approximation. Earlier this year, oclif's command package hit 1 million weekly downloads for the first time!
This year has been presented its challenges on everyone. We want to thank you, oclif developers, whom have taken the time to use and improve the oclif project. We look forward to seeing you all - in person - in the future!
All our best,
The oclif teamPretty Printable ErrorsJuly 1, 2020 · One min readOften CLIs are used as handy tools and when things go wrong it’s useful to have additional context. In oclif we have added a couple of additional properties that can show extra context to the users when an error is displayed. The code, ref and suggestions will now be displayed if they are included. This will work with an existing oclif CLI by adding the latest @oclif/errors and @oclif/core to the CLI's package.json dependencies.
For example, using this.error with the additional properties:
class TestError extends Command {  async run() {    this.error("An error has occurred!", {      code: "OCLIF_ERR",      ref: "https://oclif.io/docs/commands#thiserrormessage-string--error-options-code-string-exit-number",      suggestions: ["Use these extra properties to provide additional context"],    })  }}
would result with the following output:
›   Error: An error has occurred!›   Code: OCLIF_ERR›   Try this: Use these extra properties to provide additional context›   Reference: https://oclif.io/docs/commands#thiserrormessage-string--error-options-code-string-exit-number
If these properties are not provided then nothing changes and the CLI will continue to display the single error message output as it did before. Additionally, as part of this exercise we’ve added documentation around Error Handling in oclif which should come in handy if the need arises to extend oclif’s default handling of errors.Customizing Help in oclifMay 5, 2020 · 2 min readOut of the box oclif provides a great help experience for CLIs.
But what if, as an oclif developer, you want to customize some or all of the output?
You can now customize your CLI's help output by implementing the HelpBase abstract class.
Getting started with custom help​
If you have not done so yet, update @oclif/core.
$ yarn add --latest @oclif/core
To get started, first define the filepath to your help class in oclif's config in package.json. This is a relative path to the help class, without a file extension.
For this example, the help class will be created in a file at "[project root]/src/help.ts".
{  // ...  "oclif": {    "helpClass": "./lib/help"    // ...  }  // ...}
From here there are two paths, implement the HelpBase abstract class yourself or overwrite the parts of the default Help class you want to customize (ex: how command usage is displayed). We recommend the latter approach but cover both in the new Help Classes docs.
Separating TOPICS & COMMANDS in the new default Help class​
Previously, topics and child commands were listed in help output under a single list heading called "COMMANDS". But we found this can be slightly confusing. Some topics are commands also (a.k.a. topic-commands) while others are simply organizational namespacing (and when ran just show their help).
The new default Help class splits the list of children into distinct lists of "TOPICS" and "COMMANDS", with the possibility of an item appearing in both if it a topic-command. This makes it clearer what is expected to be ran - "COMMANDS" - and what is providing structure - "TOPICS" - when looking at the help output.
VERSION  plugin-help-example/0.0.0 darwin-x64 node-v12.12.0USAGE  $ plugin-help-example [COMMAND]TOPICS  topic  this is a topic and has child topics or commandsCOMMANDS  hello  describe the command here  help   display help for plugin-help-example
We look forward to seeing what custom help features you implement in your oclif CLIs with this new feature!oclif TSLint to ESLint MigrationDecember 5, 2019 · 3 min readBack in February of this year, plans were announced to deprecate TSLint in favor of ESLint. TSLint's goal has become to work toward a “unified developer experience” by supporting ESLint development going forward.
What has changed in oclif​
To keep inline with the community, oclif has transitioned to ESLint for all our core libraries as well as all our official plugins.
Starting in v1.15.x, oclif will now optionally generate projects with ESLint for both TypeScript and JavaScript CLI’s.
ESLint does require Node to be on stable LTS version, at the time of writing, Node 8.10.x, Node 10.13.x & Node 12.x.x.
How does this affect you​
Existing CLI’s are unchanged, but any newly generated CLI's will only give the option of using ESLint. If you are running tslint in your CLI, we recommend you switch to ESLint as well.
In migrating our projects we took the following steps (for an example of these changes see this pull request).


Install eslint
$ yarn add eslint eslint-config-oclif eslint-config-oclif-typescript --dev


Add eslint related files


$ echo '{  "extends": [    "oclif",    "oclif-typescript"  ],  "rules": {  }}' > .eslintrc


Remove tslint and related packages
$ yarn remove @oclif/tslint tslint


Remove tslint related configuration files
$ rm tslint.json


Change lint script in our package.json from something like:
"lint": "tsc -p test --noEmit && tslint -p test -t stylish"
to
"lint": "eslint . --ext .ts --config .eslintrc"


To preserve the test compile (tsc -p test --noEmit) we also made the following updates to our scripts:
"pretest": "tsc -p test --noEmit"
In some cases we had our posttest duplicating the same steps as our lint script so it’s cleaner to have it reference the lint job directly with:
"posttest": "yarn lint"

Run yarn lint --fix. This attempts to auto-fix any linting violations automatically. In the case an auto-fix isn’t available it should be fixed manually or ignored (see the eslint configuration doc for more information)
Do a search in the codebase for tslint and remove any unnecessary tslint disabling comments, like:

/* tslint:disable:object-literal-sort-keys */
If you are on a version of Node that is not supported by ESLint, you will also need to update your Node engine. ESLint supports Node 8, 10, and 12 so you should upgrade to the most recent Node version compatible with your CLI and also supported by ESLint (see ESLint's Installation and Usage instructions).
When will this take effect​
These changes have taken effect in oclif v1.15.1. When you generate a new CLI or plugin it will now contain configuration for ESLint instead of TSLint.oclif's Current Node SupportOctober 31, 2019 · 3 min readTo maintain a healthy project trajectory, oclif follows and supports Node Active LTS release, currently Node 10 & Node 12. This means ensuring that oclif continues to play nice with coming Active LTS Node versions and other packages in the ecosystem. Moving forward also means leaving older versions behind. Starting in 2020, Node will stop maintaining Node 8 and it is our intent at that time to also follow suit. Let’s take a look at a few ways we will be supporting these changes.
CI Environments​
CLIs created with the oclif cli going forward will be generated with a CircleCI configuration with Node 10 & 12 and an Appveyor configuration using Node 10. We have also added Node latest to CircleCi to be an early warning detection against coming Node changes (Node latest is managed by CircleCI).
We have already updated every oclif repo's CI configs to reflect this.
If your existing CLI uses either Appveyor or CircleCI you can update your config files also, like so:
.circleci/config.yml​
Your CircleCI config should contain a node-latest job, aliased as test. From this, there should be two extensions of this job for the Active LTS Node versions, Node 10 and Node 12.
  node-10:    <<: *node-latest    docker:      - image: node:10  node-12:    <<: *node-latest    docker:      - image: node:12
Notice that these declarations only change the Docker Node images used to run that job.
Additionally, the jobs listed within workflows must also be updated to reflect our changes in configuration:
    jobs:      - node-latest      - node-10      - node-12
appveyor.yml​
For appveyor we are currently only testing the oldest Active LTS Node version, Node 10. Update the nodejs_version proppert in your appveyor.yml file to reflect this.
environment:  nodejs_version: "10"
Deprecating Node 8 & Updating packge.json engines​
In Jan 2020, Node will end its Node 8 maintenance. We will follow suit by setting the package.json engine property in oclif packages to >=10 and bumping the package's major versions.
Depending on how you ship your CLI you may wish to also bump the engines version in your CLI's package.json. You can read more about the implications of the engines property configuration in the npm documentation.
Also consider distributing your CLI with its own Node version.
Packaged Node Version​
When using dev-cli to pack your CLI it will use the Node version as specified in your package.json under the oclif.update.node.version property. This value should reflect an Active LTS Node version (dev-cli does not currently enforce versions).
Supporting the future​
As a community we may discover bumps along the way as we upgrade. If you notice something related to oclif please feel free to open an issue or submit a pull request under the relevant oclif package within the org.
We look forward to using the latest from Node and the community and keeping oclif healthy along the way.oclifconf 2019: A RecapSeptember 16, 2019 · 4 min readIn May, Heroku and Salesforce Open Source organized oclifconf, a conference for developers & product managers building CLI tools on top of the open source oclif framework. The speakers came from various tech companies, such as Adobe, Netlify, and Apollo, who have already built amazing CLI experiences. The topics covered everything from the incredible capabilities oclif has unlocked, to the community-built plugins extending its functionality, and even what the behavior of an adaptive CLI tool might look like.
Below is a listing of all of the talks from the event, along with a short summary. Enjoy!
The future of oclif by Jeff Dickey​

In its relatively short lifetime, oclif has already inspired many developers and companies to adopt its framework as a means for implementing their own command-line tooling. In this talk, Jeff Dickey, an oclif founding team member, recaps the project's history and inspiration. He also looks towards the future and outlines some features and improvements that the tool could adapt. This isn't so much a definitive roadmap of where oclif is headed, but rather, a call to inspiration for developers eager to contribute! And if you are interested in contributing, check out the open issues in the oclif GitHub repo and come say "Hello!" on Spectrum Chat.
Open Source Citizenship by Josh Simmons​

When it comes to open source, it's more than just individuals now. More and more frequently, large corporations are contributing to projects by donating to contributors, sponsoring events, or upstreaming contributions. But keeping open source projects and communities healthy requires more than just money and brainpower. Josh Simmons surveyed multiple open source communities and relays his findings as to what help maintainers and contributors actually need in this talk.
Building an enterprise-grade CLI with oclif by Thomas Dvornik​

Security and performance are all about trust. While oclif is an extremely extensible framework for building CLI tooling, there are additional requirements to fulfill for enterprise businesses to adopt it that might not be necessary for individual developers. Thomas Dvornik outlines what he and his colleagues at Salesforce have implemented as plugins to oclif to satisfy these needs, including encrypted OAuth, plugin signing, lazy loading dependencies, synchronizing weekly releases and deprecations across dozens of repositories, and establishing cross-team coding and documentation standards.
How Adobe I/O built an extensible CLI with oclif by Jesse MacFadyen​

Perhaps oclif's most appealing feature is its support for plugins. In Cordova's case, they've created a sophisticated telemetry system that helps Adobe developers see which commands users are using--and reports on which ones are erroring out. By embedding a feedback system into the tool, users are even able to quickly send their suggestions to a form, without ever leaving the terminal. Jesse MacFadyen demonstrates how oclif's plugin system can work beyond simply executing commands.
Integrating oclif with GraphQL and Apollo by Evans Hauser​

For Evans Hauser and the team at Apollo, oclif is best thought of as "React for the CLI." As a client paired with a strongly-typed API contract to a server, it can deliver structured and consistent commands to retrieve external data. What better mechanism to use for this transfer than GraphQL, a framework which empowers the client to ask precisely for the data it needs, and nothing more?
Adaptive Intent-based CLI State Machines by Shawn Wang​

In designing oclif, Jeff Dickey wrote out 12 CLI factors to keep in mind. In this talk, Shawn Wang outlines a 13th: state. State is hard, because it depends on context, and context depends on understanding what a user intends to do, not what they are asking. Shawn is working towards enabling oclif to better understand the commands a user has entered, so that it can predict and interpret future commands that might be entered next. This would enable CLI tools to not just interpret a users' commands, but to also interpret their intent.\n\nIntroducing `oclif init` commandApril 10, 2024 · 2 min readThanks to the contribution of @joshcanhelp we released a new command for the oclif CLI called oclif init in version 4.8.0
The oclif init command allows you to initialize oclif in an existing project directory by adding the bare minimum requirements: a few pieces of configuration, bin scripts, and a couple of dependencies (@oclif/core and ts-node). This is slightly different from oclif generate, which will create an entirely new oclif project based on our templates.
oclif init will add the following:

bin scripts: bin/run.js, bin/run.cmd, bin/dev.js, and bin/dev.cmd
oclif section to package.json with bin, dirname, commands, and topicSeparator set (See Configuring Your CLI for more)
@oclif/core to dependencies in your package.json (if it's not already there)
ts-node to devDependencies in your package.json (if it's not already there)

Once you've initialized oclif, you can use the bin scripts to execute your CLI. You can also use the other oclif commands like oclif generate command and oclif generate hook to start adding new functionality.

❯ oclif init --helpInitialize a new oclif CLIUSAGE  $ oclif init [--bin <value>] [--module-type ESM|CommonJS] [--package-manager npm|yarn|pnpm] [--topic-separator    colons|spaces] [-d <value>] [-y]FLAGS  -d, --output-dir=<value>        Directory to initialize the CLI in.  -y, --yes                       Use defaults for all prompts. Individual flags will override defaults.      --bin=<value>               Supply answer for prompt: Command bin name the CLI will export      --module-type=<option>      Supply answer for prompt: Select a module type                                  <options: ESM|CommonJS>      --package-manager=<option>  Supply answer for prompt: Select a package manager                                  <options: npm|yarn|pnpm>      --topic-separator=<option>  Supply answer for prompt: Select a topic separator                                  <options: colons|spaces>DESCRIPTION  Initialize a new oclif CLI  This will add the necessary oclif bin files, add oclif config to package.json, and install @oclif/core and ts-node.EXAMPLES  Initialize a new CLI in the current directory    $ oclif init  Initialize a new CLI in a different directory    $ oclif init --output-dir "/path/to/existing/project"  Supply answers for specific prompts    $ oclif init --topic-separator colons --bin mycli
Hope you enjoy the new command! If you come across any issues or have any new ideas for this command, head over to the oclif/oclif repo and open a new issue.
All our best,
The oclif teamoclif Spring 2024 UpdateMarch 29, 2024 · 4 min readHello oclif developers! It's been a while since we last uploaded a blog - and a lot has happened.
We've been focusing on these high-level areas over the past couple of years:

Improving @oclif/core
ESM Support
Improving and revitalizing oclif.io
Re-engaging the oclif community

Improving @oclif/core​
Since we announced @oclif/core over three years ago, we've released two new major versions, each packed with lots of features that we're really excited about.
Here are some of these changes:

Full support for ESM and interoperability with CommonJS (more on this topic below).
Configurable command discovery strategies that give you more control over how commands are loaded at runtime. Check out the docs.
A new preparse hook that allows you to manipulate the provided arguments before they're parsed. Salesforce used this hook to implement a neat --flags-dir feature that translates local files into flags.
A new Performance class that you can use to track performance inside of @oclif/core and your own CLI or plugin. Check out the docs.
A new flag type, Flags.option, that lets you define a flag with a preset list of options. Typescript then uses the options to infer the flag's type.
Flags now have a relationship property that allows you to define more complex relationships between flags. Check out the flags docs for more information.
Flags now have a defaultHelp property that allows you to set the human readable default value in the command help. This property is useful when your flag's parse method returns a complex type, such as an object or a class. Check out the flags docs for more.
Commands now have a hiddenAliases property that allows you to define aliases that you want to hide from the user. The property is super helpful when you're trying to wean users off a deprecated command.
You can now use bun or tsx as dev runtimes (as opposed to node or ts-node).
A command's usage, args, and flags are now shown whenever a user forgets to provide a required arg or flag, or when they provided a non-existent flag.

If you need help migrating to the latest version, head over to core's README which has links to the migration guides. Feel free to open a new discussion if you need more hands-on help from us or the community.
ESM Support​
Version 3 of @oclif/core introduced full support for developing ESM plugins and CLIs. It also offered full support for interoperability between CommonJS and ESM plugins.
Put more simply, you can now migrate your CLI to ESM while keeping individual plugins in CommonJS (or vice versa). The upgrade path is now much simpler for you. You also don't need to worry about any community plugins that have migrated to ESM before you did (such as all the @oclif plugins) or are staunchly sticking with CommonJS for the foreseeable future.
Read more about this topic here.
Improving and Revitalizing oclif.io​
Another area of focus for us has been improving our documentation site, oclif.io.
While improving the quality and accuracy of the documentation was our priority, we also took the time to upgrade to the latest version of docusaurus. This new version gave our site a much-needed facelift, as well as cool new features such as dark mode and announcements.
If you have any feedback or are running into issues, we want to hear about it. Just create an issue in the oclif.io repo.
Re-engaging the oclif Community​
Lastly, our biggest priority at the moment is to re-engage the oclif community. We understand how frustrating it has been over the years to see your issues and pull requests go unacknowledged. We apologize for not prioritizing the community, and are earnestly trying to make sure that every issue and pull request gets the attention it deserves going forward.
We also opened up GitHub discussions for @oclif/core and the oclif CLI, where you can now post your questions or ideas. We hope you take advantage of them, we love hearing from you!
One last thing: we intend to publicly post our roadmap so you have more visibility into what we're working on. Stay tuned!
All our best,
The oclif teamAnnouncing oclif v2!January 12, 2022 · 5 min readHello and happy new year! It's our great pleasure to announce that we have released oclif v2, which uses the new @oclif/core library! 🎉
oclif v2 includes many changes that improve the experience of both creating and using an oclif CLI.
Going forward, we don't plan to make any updates to oclif v1 and its corresponding libraries, except for critical security fixes. See the compatibility matrix for a list of these libraries. In order to give developers time to migrate from v1 to v2, we're not completely dropping support yet. But at some point in the future we'll archive the v1 repositories and deprecate their versions on npm.
What’s changing?​
Repository Changes​
All repositories under the oclif org now use main as their primary branch and oclif-v1 as the legacy branch. The main  branch corresponds to oclif v2 and the oclif-v1 branch to oclif v1. If you find any repos that don’t have a main branch, you can safely assume that they're not used in oclif v2 and will be deprecated in the future.
Consolidating Tools & Libraries​
The oclif-dev CLI has now been incorporated into oclif. You now no longer need to install a separate package to manage your entire CLI’s lifecycle.
The following libraries have been consolidated under @oclif/core and will be deprecated at some point in the future. Read the migration guide to learn how to update your CLI or plugin to use the new core library.

@oclif/command
@oclif/config
@oclif/error
@oclif/help
@oclif/parser

No more single vs multi command CLIs​
There's only one "type" of oclif v2 CLI, but it can have as few or as many commands as a developer wants. As a result, there’s only one command to generate CLIs, oclif generate, as opposed to the old oclif single and oclif multi commands.
Node > 12​
To ensure oclif CLIs are as secure as possible, all v2 libraries and plugins support only Node 12 or higher as of now. Going forward, they'll support only Node Maintenance or higher, as defined by Node's release schedule here: https://nodejs.org/en/about/releases/.
What’s new?​
New example CLI​
oclif-hello-world is our new example repo. This is also the repo that's used as a template when running oclif generate to create a new CLI. This repo will always be able to be referenced as an example of what an oclif v2 CLI should look like.
Spaced commands​
oclif CLIs can now use spaces, instead of colons, to separate topics and subcommands. To enable this feature, simply add “topicSeparator": " " to the oclif config in your package.json. See an example in our example repo.
// Old commands that use :$ mycli do:something
// New spaced commands$ mycli do something

Note: Spaced commands are backwards compatible. So if you enable spaced commands for your CLI, users will still be able to use : as a separator. This ensures that any existing scripts don't break.

New Help Output​
We’ve revamped the way command help is outputted to the terminal, making it both easier to implement and easier to read. See the difference between the old help output on the left and the new help output on the right in the screenshots below.
oclif v1oclif v2
Notice that there are new sections for flags and global flags, examples are displayed with better spacing, and there is a section at the bottom called Configuration Variables. This Configuration Variables section is not part of the new help by default. But we've added support for custom help sections, which is what the sf CLI uses to create the new section.
Async Command Parsing​
We’ve also improved the performance of new CLIs by rewriting how commands are parsed on initialization. The new parser is asynchronous, which makes CLIs with a lot of commands or installed  plugins much faster.
What’s coming next?​
Part of our charter for the release of oclif v2 includes improving our engagement with the oclif community. We know that over the past couple of years we’ve reduced our involvement, and a lot of issues and PRs have languished in limbo. Hopefully you’ve already seen increased activity and responses from oclif maintainers recently, but if you haven’t, please don’t hesitate to ping us by tagging @admins in oclif repos.
We also want to start interviewing members of the oclif community to acquire feedback and prioritize the features and fixes you deem most important!
Best,
The oclif team

Reference material​
Migration Guide​
This guide explains how to upgrade a CLI or plugin from the old oclif v1 libraries to the new @oclif/core library that oclif v2 uses.
https://github.com/oclif/core/blob/main/MIGRATION.md
Compatibility Matrix​
The following matrix shows how the v1 libraries and plugins relate to the new v2 ones. Use this matrix as a guide to know what to drop and which versions to switch when upgrading your plugins and CLIs to v2.
oclif "v1"oclif "v2"Utility CLIsoclif@<2@oclif/dev-cli@<2oclif@>=2Main packages@oclif/command@oclif/config@oclif/errors@oclif/parser@oclif/plugin-help@oclif/core@>=1Node LTSNode v8-14Node v12+ (at time of writing)TypeScripttypescript@<4typescript@>=4Main plugins@oclif/plugin-autocomplete@<1@oclif/plugin-commands@<2@oclif/plugin-help@<4@oclif/plugin-not-found@<2@oclif/plugin-plugins@<2@oclif/plugin-update@<2plugin-warn-if-update-available@<2plugin-which@<2@oclif/plugin-autocomplete@>=1@oclif/plugin-commands@>=2@oclif/plugin-help@>=4@oclif/plugin-not-found@>=2@oclif/plugin-plugins@>=2@oclif/plugin-update@>=2@oclif/plugin-warn-if-update-available@>=2@oclif/plugin-which@>=2Introducing @oclif/coreMarch 1, 2021 · 3 min readGreetings!
We hope this blog post finds you well.
Introducing...​
We are excited to announce the next iteration of the oclif project today: @oclif/core.
We have learned a lot in the last three years of developing oclif, developing on oclif and supporting millions of command runs a day via Heroku and Salesforce CLIs.
@oclif/core ("Core") simplifies the oclif development experience and introduces highly requested new features.
Core combines the essential oclif packages into one "core" package, aptly named @oclif/core.
Core also introduces:

A default command option
Colon or space command syntax
Async command parsing
Command piping to arguments

With the introduction of default command functionality, Core simplifies the oclif project and removes the notion of single or multi command CLIs. Core CLIs can have 1 or many commands.
Along with Core, we moved the oclif-dev CLI into the oclif CLI creating a single "utility" CLI. This CLI also introduces a new AWS S3 compatible publishing scheme.
What to expect in the near future​
Core is in pre-release beta and being actively developed for new internal Salesforce CLIs.
Much documentation needs to be written in the coming months including migration paths. Migration onto Core should be as painless as possible with many exports remaining entirely unchanged. Look for forthcoming blog posts and documentation on oclif.io.
Early this summer, tentively June 1, we will release Core v1. Core's release will coincide with major bumps to many other oclif plugin packages. See the compatibility matrix below.
At Core's v1 release, the current "main" oclif packages (namely: command, config, errors & parser) will go into maintenance mode until Jan 2022. They will receive only bug and security fixes and they remain compatible with current versions of the oclif and oclif-dev CLIs. Afterwhich, they will be archived.
Companioning Core, the next major release of the oclif CLI (literally oclif@2) will generate Core CLIs.
Going forward​
We are excited to release Core! We invite you to poke around the Core repo. It may appear to be a big change but Core keeps what you already enjoy about oclif while reducing development complexity, project dependencies, package coupling and bundle size and introduces many requested features previously too prickly to weave into the current oclif architecture.
Best,
The oclif team
Reference: Compatibility matrix​
oclif "v1"oclif "Core"Utility CLIsoclif@<2@oclif/dev-cli@<2oclif@>=2Main packages@oclif/core@<2@oclif/config@<2@oclif/errors@<2@oclif/parser@<4@oclif/plugin-help@<4@oclif/core@>=1Node LTSNode v8-14Node v12+TypeScripttypescript@<4typescript@>=4Main plugins@oclif/plugin-autocomplete@<1@oclif/plugin-commands@<2@oclif/plugin-help@<4@oclif/plugin-not-found@<2@oclif/plugin-plugins@<2@oclif/plugin-update@<2plugin-warn-if-update-available@<2plugin-which@<2@oclif/plugin-autocomplete@>=2@oclif/plugin-commands@>=2@oclif/plugin-help@>=4@oclif/plugin-not-found@>=2@oclif/plugin-plugins@>=2@oclif/plugin-update@>=2@oclif/plugin-warn-if-update-available@>=2@oclif/plugin-which@>=2oclif Summer 2020 UpdateAugust 26, 2020 · 2 min readHello oclif developers! We hope you are all doing well.
Earlier this year, we started our planning for oclifconf v2 and, like all conference, had to change course. We opted not to hold a virtual conference, however, we wanted to take some time to highlight a few oclif features shipped this year.
Feature: Help templating​
One of the most requested features, help templating enables oclif developers to customize the help output for their CLI.
Read the announcement.
Feature: Custom error delegation​
This feature both improved how oclif throws and handles errors and allows oclif developers to overwrite or interject in oclif’s error handling.
Read the announcement.
Feature: postrun hooks​
We have added a new lifecycle event postrun. Your CLI can now run a hook after a command has ran.
See our hook documentation.
Feature: Root index command​
Previously, oclif would display CLI help if only the binary name with no command ID was invoked, oclif now supports a "root index" command. If present, a command defined at src/commands/index.ts will be run if no command ID is found.
1 million weekly downloads​
While exact oclif usage metrics are hard to pin down, we use npm download statistics of oclif packages as a rough approximation. Earlier this year, oclif's command package hit 1 million weekly downloads for the first time!
This year has been presented its challenges on everyone. We want to thank you, oclif developers, whom have taken the time to use and improve the oclif project. We look forward to seeing you all - in person - in the future!
All our best,
The oclif teamPretty Printable ErrorsJuly 1, 2020 · One min readOften CLIs are used as handy tools and when things go wrong it’s useful to have additional context. In oclif we have added a couple of additional properties that can show extra context to the users when an error is displayed. The code, ref and suggestions will now be displayed if they are included. This will work with an existing oclif CLI by adding the latest @oclif/errors and @oclif/core to the CLI's package.json dependencies.
For example, using this.error with the additional properties:
class TestError extends Command {  async run() {    this.error("An error has occurred!", {      code: "OCLIF_ERR",      ref: "https://oclif.io/docs/commands#thiserrormessage-string--error-options-code-string-exit-number",      suggestions: ["Use these extra properties to provide additional context"],    })  }}
would result with the following output:
›   Error: An error has occurred!›   Code: OCLIF_ERR›   Try this: Use these extra properties to provide additional context›   Reference: https://oclif.io/docs/commands#thiserrormessage-string--error-options-code-string-exit-number
If these properties are not provided then nothing changes and the CLI will continue to display the single error message output as it did before. Additionally, as part of this exercise we’ve added documentation around Error Handling in oclif which should come in handy if the need arises to extend oclif’s default handling of errors.Customizing Help in oclifMay 5, 2020 · 2 min readOut of the box oclif provides a great help experience for CLIs.
But what if, as an oclif developer, you want to customize some or all of the output?
You can now customize your CLI's help output by implementing the HelpBase abstract class.
Getting started with custom help​
If you have not done so yet, update @oclif/core.
$ yarn add --latest @oclif/core
To get started, first define the filepath to your help class in oclif's config in package.json. This is a relative path to the help class, without a file extension.
For this example, the help class will be created in a file at "[project root]/src/help.ts".
{  // ...  "oclif": {    "helpClass": "./lib/help"    // ...  }  // ...}
From here there are two paths, implement the HelpBase abstract class yourself or overwrite the parts of the default Help class you want to customize (ex: how command usage is displayed). We recommend the latter approach but cover both in the new Help Classes docs.
Separating TOPICS & COMMANDS in the new default Help class​
Previously, topics and child commands were listed in help output under a single list heading called "COMMANDS". But we found this can be slightly confusing. Some topics are commands also (a.k.a. topic-commands) while others are simply organizational namespacing (and when ran just show their help).
The new default Help class splits the list of children into distinct lists of "TOPICS" and "COMMANDS", with the possibility of an item appearing in both if it a topic-command. This makes it clearer what is expected to be ran - "COMMANDS" - and what is providing structure - "TOPICS" - when looking at the help output.
VERSION  plugin-help-example/0.0.0 darwin-x64 node-v12.12.0USAGE  $ plugin-help-example [COMMAND]TOPICS  topic  this is a topic and has child topics or commandsCOMMANDS  hello  describe the command here  help   display help for plugin-help-example
We look forward to seeing what custom help features you implement in your oclif CLIs with this new feature!oclif TSLint to ESLint MigrationDecember 5, 2019 · 3 min readBack in February of this year, plans were announced to deprecate TSLint in favor of ESLint. TSLint's goal has become to work toward a “unified developer experience” by supporting ESLint development going forward.
What has changed in oclif​
To keep inline with the community, oclif has transitioned to ESLint for all our core libraries as well as all our official plugins.
Starting in v1.15.x, oclif will now optionally generate projects with ESLint for both TypeScript and JavaScript CLI’s.
ESLint does require Node to be on stable LTS version, at the time of writing, Node 8.10.x, Node 10.13.x & Node 12.x.x.
How does this affect you​
Existing CLI’s are unchanged, but any newly generated CLI's will only give the option of using ESLint. If you are running tslint in your CLI, we recommend you switch to ESLint as well.
In migrating our projects we took the following steps (for an example of these changes see this pull request).


Install eslint
$ yarn add eslint eslint-config-oclif eslint-config-oclif-typescript --dev


Add eslint related files


$ echo '{  "extends": [    "oclif",    "oclif-typescript"  ],  "rules": {  }}' > .eslintrc


Remove tslint and related packages
$ yarn remove @oclif/tslint tslint


Remove tslint related configuration files
$ rm tslint.json


Change lint script in our package.json from something like:
"lint": "tsc -p test --noEmit && tslint -p test -t stylish"
to
"lint": "eslint . --ext .ts --config .eslintrc"


To preserve the test compile (tsc -p test --noEmit) we also made the following updates to our scripts:
"pretest": "tsc -p test --noEmit"
In some cases we had our posttest duplicating the same steps as our lint script so it’s cleaner to have it reference the lint job directly with:
"posttest": "yarn lint"

Run yarn lint --fix. This attempts to auto-fix any linting violations automatically. In the case an auto-fix isn’t available it should be fixed manually or ignored (see the eslint configuration doc for more information)
Do a search in the codebase for tslint and remove any unnecessary tslint disabling comments, like:

/* tslint:disable:object-literal-sort-keys */
If you are on a version of Node that is not supported by ESLint, you will also need to update your Node engine. ESLint supports Node 8, 10, and 12 so you should upgrade to the most recent Node version compatible with your CLI and also supported by ESLint (see ESLint's Installation and Usage instructions).
When will this take effect​
These changes have taken effect in oclif v1.15.1. When you generate a new CLI or plugin it will now contain configuration for ESLint instead of TSLint.oclif's Current Node SupportOctober 31, 2019 · 3 min readTo maintain a healthy project trajectory, oclif follows and supports Node Active LTS release, currently Node 10 & Node 12. This means ensuring that oclif continues to play nice with coming Active LTS Node versions and other packages in the ecosystem. Moving forward also means leaving older versions behind. Starting in 2020, Node will stop maintaining Node 8 and it is our intent at that time to also follow suit. Let’s take a look at a few ways we will be supporting these changes.
CI Environments​
CLIs created with the oclif cli going forward will be generated with a CircleCI configuration with Node 10 & 12 and an Appveyor configuration using Node 10. We have also added Node latest to CircleCi to be an early warning detection against coming Node changes (Node latest is managed by CircleCI).
We have already updated every oclif repo's CI configs to reflect this.
If your existing CLI uses either Appveyor or CircleCI you can update your config files also, like so:
.circleci/config.yml​
Your CircleCI config should contain a node-latest job, aliased as test. From this, there should be two extensions of this job for the Active LTS Node versions, Node 10 and Node 12.
  node-10:    <<: *node-latest    docker:      - image: node:10  node-12:    <<: *node-latest    docker:      - image: node:12
Notice that these declarations only change the Docker Node images used to run that job.
Additionally, the jobs listed within workflows must also be updated to reflect our changes in configuration:
    jobs:      - node-latest      - node-10      - node-12
appveyor.yml​
For appveyor we are currently only testing the oldest Active LTS Node version, Node 10. Update the nodejs_version proppert in your appveyor.yml file to reflect this.
environment:  nodejs_version: "10"
Deprecating Node 8 & Updating packge.json engines​
In Jan 2020, Node will end its Node 8 maintenance. We will follow suit by setting the package.json engine property in oclif packages to >=10 and bumping the package's major versions.
Depending on how you ship your CLI you may wish to also bump the engines version in your CLI's package.json. You can read more about the implications of the engines property configuration in the npm documentation.
Also consider distributing your CLI with its own Node version.
Packaged Node Version​
When using dev-cli to pack your CLI it will use the Node version as specified in your package.json under the oclif.update.node.version property. This value should reflect an Active LTS Node version (dev-cli does not currently enforce versions).
Supporting the future​
As a community we may discover bumps along the way as we upgrade. If you notice something related to oclif please feel free to open an issue or submit a pull request under the relevant oclif package within the org.
We look forward to using the latest from Node and the community and keeping oclif healthy along the way.oclifconf 2019: A RecapSeptember 16, 2019 · 4 min readIn May, Heroku and Salesforce Open Source organized oclifconf, a conference for developers & product managers building CLI tools on top of the open source oclif framework. The speakers came from various tech companies, such as Adobe, Netlify, and Apollo, who have already built amazing CLI experiences. The topics covered everything from the incredible capabilities oclif has unlocked, to the community-built plugins extending its functionality, and even what the behavior of an adaptive CLI tool might look like.
Below is a listing of all of the talks from the event, along with a short summary. Enjoy!
The future of oclif by Jeff Dickey​

In its relatively short lifetime, oclif has already inspired many developers and companies to adopt its framework as a means for implementing their own command-line tooling. In this talk, Jeff Dickey, an oclif founding team member, recaps the project's history and inspiration. He also looks towards the future and outlines some features and improvements that the tool could adapt. This isn't so much a definitive roadmap of where oclif is headed, but rather, a call to inspiration for developers eager to contribute! And if you are interested in contributing, check out the open issues in the oclif GitHub repo and come say "Hello!" on Spectrum Chat.
Open Source Citizenship by Josh Simmons​

When it comes to open source, it's more than just individuals now. More and more frequently, large corporations are contributing to projects by donating to contributors, sponsoring events, or upstreaming contributions. But keeping open source projects and communities healthy requires more than just money and brainpower. Josh Simmons surveyed multiple open source communities and relays his findings as to what help maintainers and contributors actually need in this talk.
Building an enterprise-grade CLI with oclif by Thomas Dvornik​

Security and performance are all about trust. While oclif is an extremely extensible framework for building CLI tooling, there are additional requirements to fulfill for enterprise businesses to adopt it that might not be necessary for individual developers. Thomas Dvornik outlines what he and his colleagues at Salesforce have implemented as plugins to oclif to satisfy these needs, including encrypted OAuth, plugin signing, lazy loading dependencies, synchronizing weekly releases and deprecations across dozens of repositories, and establishing cross-team coding and documentation standards.
How Adobe I/O built an extensible CLI with oclif by Jesse MacFadyen​

Perhaps oclif's most appealing feature is its support for plugins. In Cordova's case, they've created a sophisticated telemetry system that helps Adobe developers see which commands users are using--and reports on which ones are erroring out. By embedding a feedback system into the tool, users are even able to quickly send their suggestions to a form, without ever leaving the terminal. Jesse MacFadyen demonstrates how oclif's plugin system can work beyond simply executing commands.
Integrating oclif with GraphQL and Apollo by Evans Hauser​

For Evans Hauser and the team at Apollo, oclif is best thought of as "React for the CLI." As a client paired with a strongly-typed API contract to a server, it can deliver structured and consistent commands to retrieve external data. What better mechanism to use for this transfer than GraphQL, a framework which empowers the client to ask precisely for the data it needs, and nothing more?
Adaptive Intent-based CLI State Machines by Shawn Wang​

In designing oclif, Jeff Dickey wrote out 12 CLI factors to keep in mind. In this talk, Shawn Wang outlines a 13th: state. State is hard, because it depends on context, and context depends on understanding what a user intends to do, not what they are asking. Shawn is working towards enabling oclif to better understand the commands a user has entered, so that it can predict and interpret future commands that might be entered next. This would enable CLI tools to not just interpret a users' commands, but to also interpret their intent.Older Entries\n\n\n\nIntroducing `oclif init` commandApril 10, 2024 · 2 min readThanks to the contribution of @joshcanhelp we released a new command for the oclif CLI called oclif init in version 4.8.0
The oclif init command allows you to initialize oclif in an existing project directory by adding the bare minimum requirements: a few pieces of configuration, bin scripts, and a couple of dependencies (@oclif/core and ts-node). This is slightly different from oclif generate, which will create an entirely new oclif project based on our templates.
oclif init will add the following:

bin scripts: bin/run.js, bin/run.cmd, bin/dev.js, and bin/dev.cmd
oclif section to package.json with bin, dirname, commands, and topicSeparator set (See Configuring Your CLI for more)
@oclif/core to dependencies in your package.json (if it's not already there)
ts-node to devDependencies in your package.json (if it's not already there)

Once you've initialized oclif, you can use the bin scripts to execute your CLI. You can also use the other oclif commands like oclif generate command and oclif generate hook to start adding new functionality.

❯ oclif init --helpInitialize a new oclif CLIUSAGE  $ oclif init [--bin <value>] [--module-type ESM|CommonJS] [--package-manager npm|yarn|pnpm] [--topic-separator    colons|spaces] [-d <value>] [-y]FLAGS  -d, --output-dir=<value>        Directory to initialize the CLI in.  -y, --yes                       Use defaults for all prompts. Individual flags will override defaults.      --bin=<value>               Supply answer for prompt: Command bin name the CLI will export      --module-type=<option>      Supply answer for prompt: Select a module type                                  <options: ESM|CommonJS>      --package-manager=<option>  Supply answer for prompt: Select a package manager                                  <options: npm|yarn|pnpm>      --topic-separator=<option>  Supply answer for prompt: Select a topic separator                                  <options: colons|spaces>DESCRIPTION  Initialize a new oclif CLI  This will add the necessary oclif bin files, add oclif config to package.json, and install @oclif/core and ts-node.EXAMPLES  Initialize a new CLI in the current directory    $ oclif init  Initialize a new CLI in a different directory    $ oclif init --output-dir "/path/to/existing/project"  Supply answers for specific prompts    $ oclif init --topic-separator colons --bin mycli
Hope you enjoy the new command! If you come across any issues or have any new ideas for this command, head over to the oclif/oclif repo and open a new issue.
All our best,
The oclif teamoclif Spring 2024 UpdateMarch 29, 2024 · 4 min readHello oclif developers! It's been a while since we last uploaded a blog - and a lot has happened.
We've been focusing on these high-level areas over the past couple of years:

Improving @oclif/core
ESM Support
Improving and revitalizing oclif.io
Re-engaging the oclif community

Improving @oclif/core​
Since we announced @oclif/core over three years ago, we've released two new major versions, each packed with lots of features that we're really excited about.
Here are some of these changes:

Full support for ESM and interoperability with CommonJS (more on this topic below).
Configurable command discovery strategies that give you more control over how commands are loaded at runtime. Check out the docs.
A new preparse hook that allows you to manipulate the provided arguments before they're parsed. Salesforce used this hook to implement a neat --flags-dir feature that translates local files into flags.
A new Performance class that you can use to track performance inside of @oclif/core and your own CLI or plugin. Check out the docs.
A new flag type, Flags.option, that lets you define a flag with a preset list of options. Typescript then uses the options to infer the flag's type.
Flags now have a relationship property that allows you to define more complex relationships between flags. Check out the flags docs for more information.
Flags now have a defaultHelp property that allows you to set the human readable default value in the command help. This property is useful when your flag's parse method returns a complex type, such as an object or a class. Check out the flags docs for more.
Commands now have a hiddenAliases property that allows you to define aliases that you want to hide from the user. The property is super helpful when you're trying to wean users off a deprecated command.
You can now use bun or tsx as dev runtimes (as opposed to node or ts-node).
A command's usage, args, and flags are now shown whenever a user forgets to provide a required arg or flag, or when they provided a non-existent flag.

If you need help migrating to the latest version, head over to core's README which has links to the migration guides. Feel free to open a new discussion if you need more hands-on help from us or the community.
ESM Support​
Version 3 of @oclif/core introduced full support for developing ESM plugins and CLIs. It also offered full support for interoperability between CommonJS and ESM plugins.
Put more simply, you can now migrate your CLI to ESM while keeping individual plugins in CommonJS (or vice versa). The upgrade path is now much simpler for you. You also don't need to worry about any community plugins that have migrated to ESM before you did (such as all the @oclif plugins) or are staunchly sticking with CommonJS for the foreseeable future.
Read more about this topic here.
Improving and Revitalizing oclif.io​
Another area of focus for us has been improving our documentation site, oclif.io.
While improving the quality and accuracy of the documentation was our priority, we also took the time to upgrade to the latest version of docusaurus. This new version gave our site a much-needed facelift, as well as cool new features such as dark mode and announcements.
If you have any feedback or are running into issues, we want to hear about it. Just create an issue in the oclif.io repo.
Re-engaging the oclif Community​
Lastly, our biggest priority at the moment is to re-engage the oclif community. We understand how frustrating it has been over the years to see your issues and pull requests go unacknowledged. We apologize for not prioritizing the community, and are earnestly trying to make sure that every issue and pull request gets the attention it deserves going forward.
We also opened up GitHub discussions for @oclif/core and the oclif CLI, where you can now post your questions or ideas. We hope you take advantage of them, we love hearing from you!
One last thing: we intend to publicly post our roadmap so you have more visibility into what we're working on. Stay tuned!
All our best,
The oclif teamAnnouncing oclif v2!January 12, 2022 · 5 min readHello and happy new year! It's our great pleasure to announce that we have released oclif v2, which uses the new @oclif/core library! 🎉
oclif v2 includes many changes that improve the experience of both creating and using an oclif CLI.
Going forward, we don't plan to make any updates to oclif v1 and its corresponding libraries, except for critical security fixes. See the compatibility matrix for a list of these libraries. In order to give developers time to migrate from v1 to v2, we're not completely dropping support yet. But at some point in the future we'll archive the v1 repositories and deprecate their versions on npm.
What’s changing?​
Repository Changes​
All repositories under the oclif org now use main as their primary branch and oclif-v1 as the legacy branch. The main  branch corresponds to oclif v2 and the oclif-v1 branch to oclif v1. If you find any repos that don’t have a main branch, you can safely assume that they're not used in oclif v2 and will be deprecated in the future.
Consolidating Tools & Libraries​
The oclif-dev CLI has now been incorporated into oclif. You now no longer need to install a separate package to manage your entire CLI’s lifecycle.
The following libraries have been consolidated under @oclif/core and will be deprecated at some point in the future. Read the migration guide to learn how to update your CLI or plugin to use the new core library.

@oclif/command
@oclif/config
@oclif/error
@oclif/help
@oclif/parser

No more single vs multi command CLIs​
There's only one "type" of oclif v2 CLI, but it can have as few or as many commands as a developer wants. As a result, there’s only one command to generate CLIs, oclif generate, as opposed to the old oclif single and oclif multi commands.
Node > 12​
To ensure oclif CLIs are as secure as possible, all v2 libraries and plugins support only Node 12 or higher as of now. Going forward, they'll support only Node Maintenance or higher, as defined by Node's release schedule here: https://nodejs.org/en/about/releases/.
What’s new?​
New example CLI​
oclif-hello-world is our new example repo. This is also the repo that's used as a template when running oclif generate to create a new CLI. This repo will always be able to be referenced as an example of what an oclif v2 CLI should look like.
Spaced commands​
oclif CLIs can now use spaces, instead of colons, to separate topics and subcommands. To enable this feature, simply add “topicSeparator": " " to the oclif config in your package.json. See an example in our example repo.
// Old commands that use :$ mycli do:something
// New spaced commands$ mycli do something

Note: Spaced commands are backwards compatible. So if you enable spaced commands for your CLI, users will still be able to use : as a separator. This ensures that any existing scripts don't break.

New Help Output​
We’ve revamped the way command help is outputted to the terminal, making it both easier to implement and easier to read. See the difference between the old help output on the left and the new help output on the right in the screenshots below.
oclif v1oclif v2
Notice that there are new sections for flags and global flags, examples are displayed with better spacing, and there is a section at the bottom called Configuration Variables. This Configuration Variables section is not part of the new help by default. But we've added support for custom help sections, which is what the sf CLI uses to create the new section.
Async Command Parsing​
We’ve also improved the performance of new CLIs by rewriting how commands are parsed on initialization. The new parser is asynchronous, which makes CLIs with a lot of commands or installed  plugins much faster.
What’s coming next?​
Part of our charter for the release of oclif v2 includes improving our engagement with the oclif community. We know that over the past couple of years we’ve reduced our involvement, and a lot of issues and PRs have languished in limbo. Hopefully you’ve already seen increased activity and responses from oclif maintainers recently, but if you haven’t, please don’t hesitate to ping us by tagging @admins in oclif repos.
We also want to start interviewing members of the oclif community to acquire feedback and prioritize the features and fixes you deem most important!
Best,
The oclif team

Reference material​
Migration Guide​
This guide explains how to upgrade a CLI or plugin from the old oclif v1 libraries to the new @oclif/core library that oclif v2 uses.
https://github.com/oclif/core/blob/main/MIGRATION.md
Compatibility Matrix​
The following matrix shows how the v1 libraries and plugins relate to the new v2 ones. Use this matrix as a guide to know what to drop and which versions to switch when upgrading your plugins and CLIs to v2.
oclif "v1"oclif "v2"Utility CLIsoclif@<2@oclif/dev-cli@<2oclif@>=2Main packages@oclif/command@oclif/config@oclif/errors@oclif/parser@oclif/plugin-help@oclif/core@>=1Node LTSNode v8-14Node v12+ (at time of writing)TypeScripttypescript@<4typescript@>=4Main plugins@oclif/plugin-autocomplete@<1@oclif/plugin-commands@<2@oclif/plugin-help@<4@oclif/plugin-not-found@<2@oclif/plugin-plugins@<2@oclif/plugin-update@<2plugin-warn-if-update-available@<2plugin-which@<2@oclif/plugin-autocomplete@>=1@oclif/plugin-commands@>=2@oclif/plugin-help@>=4@oclif/plugin-not-found@>=2@oclif/plugin-plugins@>=2@oclif/plugin-update@>=2@oclif/plugin-warn-if-update-available@>=2@oclif/plugin-which@>=2Introducing @oclif/coreMarch 1, 2021 · 3 min readGreetings!
We hope this blog post finds you well.
Introducing...​
We are excited to announce the next iteration of the oclif project today: @oclif/core.
We have learned a lot in the last three years of developing oclif, developing on oclif and supporting millions of command runs a day via Heroku and Salesforce CLIs.
@oclif/core ("Core") simplifies the oclif development experience and introduces highly requested new features.
Core combines the essential oclif packages into one "core" package, aptly named @oclif/core.
Core also introduces:

A default command option
Colon or space command syntax
Async command parsing
Command piping to arguments

With the introduction of default command functionality, Core simplifies the oclif project and removes the notion of single or multi command CLIs. Core CLIs can have 1 or many commands.
Along with Core, we moved the oclif-dev CLI into the oclif CLI creating a single "utility" CLI. This CLI also introduces a new AWS S3 compatible publishing scheme.
What to expect in the near future​
Core is in pre-release beta and being actively developed for new internal Salesforce CLIs.
Much documentation needs to be written in the coming months including migration paths. Migration onto Core should be as painless as possible with many exports remaining entirely unchanged. Look for forthcoming blog posts and documentation on oclif.io.
Early this summer, tentively June 1, we will release Core v1. Core's release will coincide with major bumps to many other oclif plugin packages. See the compatibility matrix below.
At Core's v1 release, the current "main" oclif packages (namely: command, config, errors & parser) will go into maintenance mode until Jan 2022. They will receive only bug and security fixes and they remain compatible with current versions of the oclif and oclif-dev CLIs. Afterwhich, they will be archived.
Companioning Core, the next major release of the oclif CLI (literally oclif@2) will generate Core CLIs.
Going forward​
We are excited to release Core! We invite you to poke around the Core repo. It may appear to be a big change but Core keeps what you already enjoy about oclif while reducing development complexity, project dependencies, package coupling and bundle size and introduces many requested features previously too prickly to weave into the current oclif architecture.
Best,
The oclif team
Reference: Compatibility matrix​
oclif "v1"oclif "Core"Utility CLIsoclif@<2@oclif/dev-cli@<2oclif@>=2Main packages@oclif/core@<2@oclif/config@<2@oclif/errors@<2@oclif/parser@<4@oclif/plugin-help@<4@oclif/core@>=1Node LTSNode v8-14Node v12+TypeScripttypescript@<4typescript@>=4Main plugins@oclif/plugin-autocomplete@<1@oclif/plugin-commands@<2@oclif/plugin-help@<4@oclif/plugin-not-found@<2@oclif/plugin-plugins@<2@oclif/plugin-update@<2plugin-warn-if-update-available@<2plugin-which@<2@oclif/plugin-autocomplete@>=2@oclif/plugin-commands@>=2@oclif/plugin-help@>=4@oclif/plugin-not-found@>=2@oclif/plugin-plugins@>=2@oclif/plugin-update@>=2@oclif/plugin-warn-if-update-available@>=2@oclif/plugin-which@>=2oclif Summer 2020 UpdateAugust 26, 2020 · 2 min readHello oclif developers! We hope you are all doing well.
Earlier this year, we started our planning for oclifconf v2 and, like all conference, had to change course. We opted not to hold a virtual conference, however, we wanted to take some time to highlight a few oclif features shipped this year.
Feature: Help templating​
One of the most requested features, help templating enables oclif developers to customize the help output for their CLI.
Read the announcement.
Feature: Custom error delegation​
This feature both improved how oclif throws and handles errors and allows oclif developers to overwrite or interject in oclif’s error handling.
Read the announcement.
Feature: postrun hooks​
We have added a new lifecycle event postrun. Your CLI can now run a hook after a command has ran.
See our hook documentation.
Feature: Root index command​
Previously, oclif would display CLI help if only the binary name with no command ID was invoked, oclif now supports a "root index" command. If present, a command defined at src/commands/index.ts will be run if no command ID is found.
1 million weekly downloads​
While exact oclif usage metrics are hard to pin down, we use npm download statistics of oclif packages as a rough approximation. Earlier this year, oclif's command package hit 1 million weekly downloads for the first time!
This year has been presented its challenges on everyone. We want to thank you, oclif developers, whom have taken the time to use and improve the oclif project. We look forward to seeing you all - in person - in the future!
All our best,
The oclif teamPretty Printable ErrorsJuly 1, 2020 · One min readOften CLIs are used as handy tools and when things go wrong it’s useful to have additional context. In oclif we have added a couple of additional properties that can show extra context to the users when an error is displayed. The code, ref and suggestions will now be displayed if they are included. This will work with an existing oclif CLI by adding the latest @oclif/errors and @oclif/core to the CLI's package.json dependencies.
For example, using this.error with the additional properties:
class TestError extends Command {  async run() {    this.error("An error has occurred!", {      code: "OCLIF_ERR",      ref: "https://oclif.io/docs/commands#thiserrormessage-string--error-options-code-string-exit-number",      suggestions: ["Use these extra properties to provide additional context"],    })  }}
would result with the following output:
›   Error: An error has occurred!›   Code: OCLIF_ERR›   Try this: Use these extra properties to provide additional context›   Reference: https://oclif.io/docs/commands#thiserrormessage-string--error-options-code-string-exit-number
If these properties are not provided then nothing changes and the CLI will continue to display the single error message output as it did before. Additionally, as part of this exercise we’ve added documentation around Error Handling in oclif which should come in handy if the need arises to extend oclif’s default handling of errors.Customizing Help in oclifMay 5, 2020 · 2 min readOut of the box oclif provides a great help experience for CLIs.
But what if, as an oclif developer, you want to customize some or all of the output?
You can now customize your CLI's help output by implementing the HelpBase abstract class.
Getting started with custom help​
If you have not done so yet, update @oclif/core.
$ yarn add --latest @oclif/core
To get started, first define the filepath to your help class in oclif's config in package.json. This is a relative path to the help class, without a file extension.
For this example, the help class will be created in a file at "[project root]/src/help.ts".
{  // ...  "oclif": {    "helpClass": "./lib/help"    // ...  }  // ...}
From here there are two paths, implement the HelpBase abstract class yourself or overwrite the parts of the default Help class you want to customize (ex: how command usage is displayed). We recommend the latter approach but cover both in the new Help Classes docs.
Separating TOPICS & COMMANDS in the new default Help class​
Previously, topics and child commands were listed in help output under a single list heading called "COMMANDS". But we found this can be slightly confusing. Some topics are commands also (a.k.a. topic-commands) while others are simply organizational namespacing (and when ran just show their help).
The new default Help class splits the list of children into distinct lists of "TOPICS" and "COMMANDS", with the possibility of an item appearing in both if it a topic-command. This makes it clearer what is expected to be ran - "COMMANDS" - and what is providing structure - "TOPICS" - when looking at the help output.
VERSION  plugin-help-example/0.0.0 darwin-x64 node-v12.12.0USAGE  $ plugin-help-example [COMMAND]TOPICS  topic  this is a topic and has child topics or commandsCOMMANDS  hello  describe the command here  help   display help for plugin-help-example
We look forward to seeing what custom help features you implement in your oclif CLIs with this new feature!oclif TSLint to ESLint MigrationDecember 5, 2019 · 3 min readBack in February of this year, plans were announced to deprecate TSLint in favor of ESLint. TSLint's goal has become to work toward a “unified developer experience” by supporting ESLint development going forward.
What has changed in oclif​
To keep inline with the community, oclif has transitioned to ESLint for all our core libraries as well as all our official plugins.
Starting in v1.15.x, oclif will now optionally generate projects with ESLint for both TypeScript and JavaScript CLI’s.
ESLint does require Node to be on stable LTS version, at the time of writing, Node 8.10.x, Node 10.13.x & Node 12.x.x.
How does this affect you​
Existing CLI’s are unchanged, but any newly generated CLI's will only give the option of using ESLint. If you are running tslint in your CLI, we recommend you switch to ESLint as well.
In migrating our projects we took the following steps (for an example of these changes see this pull request).


Install eslint
$ yarn add eslint eslint-config-oclif eslint-config-oclif-typescript --dev


Add eslint related files


$ echo '{  "extends": [    "oclif",    "oclif-typescript"  ],  "rules": {  }}' > .eslintrc


Remove tslint and related packages
$ yarn remove @oclif/tslint tslint


Remove tslint related configuration files
$ rm tslint.json


Change lint script in our package.json from something like:
"lint": "tsc -p test --noEmit && tslint -p test -t stylish"
to
"lint": "eslint . --ext .ts --config .eslintrc"


To preserve the test compile (tsc -p test --noEmit) we also made the following updates to our scripts:
"pretest": "tsc -p test --noEmit"
In some cases we had our posttest duplicating the same steps as our lint script so it’s cleaner to have it reference the lint job directly with:
"posttest": "yarn lint"

Run yarn lint --fix. This attempts to auto-fix any linting violations automatically. In the case an auto-fix isn’t available it should be fixed manually or ignored (see the eslint configuration doc for more information)
Do a search in the codebase for tslint and remove any unnecessary tslint disabling comments, like:

/* tslint:disable:object-literal-sort-keys */
If you are on a version of Node that is not supported by ESLint, you will also need to update your Node engine. ESLint supports Node 8, 10, and 12 so you should upgrade to the most recent Node version compatible with your CLI and also supported by ESLint (see ESLint's Installation and Usage instructions).
When will this take effect​
These changes have taken effect in oclif v1.15.1. When you generate a new CLI or plugin it will now contain configuration for ESLint instead of TSLint.oclif's Current Node SupportOctober 31, 2019 · 3 min readTo maintain a healthy project trajectory, oclif follows and supports Node Active LTS release, currently Node 10 & Node 12. This means ensuring that oclif continues to play nice with coming Active LTS Node versions and other packages in the ecosystem. Moving forward also means leaving older versions behind. Starting in 2020, Node will stop maintaining Node 8 and it is our intent at that time to also follow suit. Let’s take a look at a few ways we will be supporting these changes.
CI Environments​
CLIs created with the oclif cli going forward will be generated with a CircleCI configuration with Node 10 & 12 and an Appveyor configuration using Node 10. We have also added Node latest to CircleCi to be an early warning detection against coming Node changes (Node latest is managed by CircleCI).
We have already updated every oclif repo's CI configs to reflect this.
If your existing CLI uses either Appveyor or CircleCI you can update your config files also, like so:
.circleci/config.yml​
Your CircleCI config should contain a node-latest job, aliased as test. From this, there should be two extensions of this job for the Active LTS Node versions, Node 10 and Node 12.
  node-10:    <<: *node-latest    docker:      - image: node:10  node-12:    <<: *node-latest    docker:      - image: node:12
Notice that these declarations only change the Docker Node images used to run that job.
Additionally, the jobs listed within workflows must also be updated to reflect our changes in configuration:
    jobs:      - node-latest      - node-10      - node-12
appveyor.yml​
For appveyor we are currently only testing the oldest Active LTS Node version, Node 10. Update the nodejs_version proppert in your appveyor.yml file to reflect this.
environment:  nodejs_version: "10"
Deprecating Node 8 & Updating packge.json engines​
In Jan 2020, Node will end its Node 8 maintenance. We will follow suit by setting the package.json engine property in oclif packages to >=10 and bumping the package's major versions.
Depending on how you ship your CLI you may wish to also bump the engines version in your CLI's package.json. You can read more about the implications of the engines property configuration in the npm documentation.
Also consider distributing your CLI with its own Node version.
Packaged Node Version​
When using dev-cli to pack your CLI it will use the Node version as specified in your package.json under the oclif.update.node.version property. This value should reflect an Active LTS Node version (dev-cli does not currently enforce versions).
Supporting the future​
As a community we may discover bumps along the way as we upgrade. If you notice something related to oclif please feel free to open an issue or submit a pull request under the relevant oclif package within the org.
We look forward to using the latest from Node and the community and keeping oclif healthy along the way.oclifconf 2019: A RecapSeptember 16, 2019 · 4 min readIn May, Heroku and Salesforce Open Source organized oclifconf, a conference for developers & product managers building CLI tools on top of the open source oclif framework. The speakers came from various tech companies, such as Adobe, Netlify, and Apollo, who have already built amazing CLI experiences. The topics covered everything from the incredible capabilities oclif has unlocked, to the community-built plugins extending its functionality, and even what the behavior of an adaptive CLI tool might look like.
Below is a listing of all of the talks from the event, along with a short summary. Enjoy!
The future of oclif by Jeff Dickey​

In its relatively short lifetime, oclif has already inspired many developers and companies to adopt its framework as a means for implementing their own command-line tooling. In this talk, Jeff Dickey, an oclif founding team member, recaps the project's history and inspiration. He also looks towards the future and outlines some features and improvements that the tool could adapt. This isn't so much a definitive roadmap of where oclif is headed, but rather, a call to inspiration for developers eager to contribute! And if you are interested in contributing, check out the open issues in the oclif GitHub repo and come say "Hello!" on Spectrum Chat.
Open Source Citizenship by Josh Simmons​

When it comes to open source, it's more than just individuals now. More and more frequently, large corporations are contributing to projects by donating to contributors, sponsoring events, or upstreaming contributions. But keeping open source projects and communities healthy requires more than just money and brainpower. Josh Simmons surveyed multiple open source communities and relays his findings as to what help maintainers and contributors actually need in this talk.
Building an enterprise-grade CLI with oclif by Thomas Dvornik​

Security and performance are all about trust. While oclif is an extremely extensible framework for building CLI tooling, there are additional requirements to fulfill for enterprise businesses to adopt it that might not be necessary for individual developers. Thomas Dvornik outlines what he and his colleagues at Salesforce have implemented as plugins to oclif to satisfy these needs, including encrypted OAuth, plugin signing, lazy loading dependencies, synchronizing weekly releases and deprecations across dozens of repositories, and establishing cross-team coding and documentation standards.
How Adobe I/O built an extensible CLI with oclif by Jesse MacFadyen​

Perhaps oclif's most appealing feature is its support for plugins. In Cordova's case, they've created a sophisticated telemetry system that helps Adobe developers see which commands users are using--and reports on which ones are erroring out. By embedding a feedback system into the tool, users are even able to quickly send their suggestions to a form, without ever leaving the terminal. Jesse MacFadyen demonstrates how oclif's plugin system can work beyond simply executing commands.
Integrating oclif with GraphQL and Apollo by Evans Hauser​

For Evans Hauser and the team at Apollo, oclif is best thought of as "React for the CLI." As a client paired with a strongly-typed API contract to a server, it can deliver structured and consistent commands to retrieve external data. What better mechanism to use for this transfer than GraphQL, a framework which empowers the client to ask precisely for the data it needs, and nothing more?
Adaptive Intent-based CLI State Machines by Shawn Wang​

In designing oclif, Jeff Dickey wrote out 12 CLI factors to keep in mind. In this talk, Shawn Wang outlines a 13th: state. State is hard, because it depends on context, and context depends on understanding what a user intends to do, not what they are asking. Shawn is working towards enabling oclif to better understand the commands a user has entered, so that it can predict and interpret future commands that might be entered next. This would enable CLI tools to not just interpret a users' commands, but to also interpret their intent.\n\nIntroducing `oclif init` commandApril 10, 2024 · 2 min readThanks to the contribution of @joshcanhelp we released a new command for the oclif CLI called oclif init in version 4.8.0
The oclif init command allows you to initialize oclif in an existing project directory by adding the bare minimum requirements: a few pieces of configuration, bin scripts, and a couple of dependencies (@oclif/core and ts-node). This is slightly different from oclif generate, which will create an entirely new oclif project based on our templates.
oclif init will add the following:

bin scripts: bin/run.js, bin/run.cmd, bin/dev.js, and bin/dev.cmd
oclif section to package.json with bin, dirname, commands, and topicSeparator set (See Configuring Your CLI for more)
@oclif/core to dependencies in your package.json (if it's not already there)
ts-node to devDependencies in your package.json (if it's not already there)

Once you've initialized oclif, you can use the bin scripts to execute your CLI. You can also use the other oclif commands like oclif generate command and oclif generate hook to start adding new functionality.

❯ oclif init --helpInitialize a new oclif CLIUSAGE  $ oclif init [--bin <value>] [--module-type ESM|CommonJS] [--package-manager npm|yarn|pnpm] [--topic-separator    colons|spaces] [-d <value>] [-y]FLAGS  -d, --output-dir=<value>        Directory to initialize the CLI in.  -y, --yes                       Use defaults for all prompts. Individual flags will override defaults.      --bin=<value>               Supply answer for prompt: Command bin name the CLI will export      --module-type=<option>      Supply answer for prompt: Select a module type                                  <options: ESM|CommonJS>      --package-manager=<option>  Supply answer for prompt: Select a package manager                                  <options: npm|yarn|pnpm>      --topic-separator=<option>  Supply answer for prompt: Select a topic separator                                  <options: colons|spaces>DESCRIPTION  Initialize a new oclif CLI  This will add the necessary oclif bin files, add oclif config to package.json, and install @oclif/core and ts-node.EXAMPLES  Initialize a new CLI in the current directory    $ oclif init  Initialize a new CLI in a different directory    $ oclif init --output-dir "/path/to/existing/project"  Supply answers for specific prompts    $ oclif init --topic-separator colons --bin mycli
Hope you enjoy the new command! If you come across any issues or have any new ideas for this command, head over to the oclif/oclif repo and open a new issue.
All our best,
The oclif teamoclif Spring 2024 UpdateMarch 29, 2024 · 4 min readHello oclif developers! It's been a while since we last uploaded a blog - and a lot has happened.
We've been focusing on these high-level areas over the past couple of years:

Improving @oclif/core
ESM Support
Improving and revitalizing oclif.io
Re-engaging the oclif community

Improving @oclif/core​
Since we announced @oclif/core over three years ago, we've released two new major versions, each packed with lots of features that we're really excited about.
Here are some of these changes:

Full support for ESM and interoperability with CommonJS (more on this topic below).
Configurable command discovery strategies that give you more control over how commands are loaded at runtime. Check out the docs.
A new preparse hook that allows you to manipulate the provided arguments before they're parsed. Salesforce used this hook to implement a neat --flags-dir feature that translates local files into flags.
A new Performance class that you can use to track performance inside of @oclif/core and your own CLI or plugin. Check out the docs.
A new flag type, Flags.option, that lets you define a flag with a preset list of options. Typescript then uses the options to infer the flag's type.
Flags now have a relationship property that allows you to define more complex relationships between flags. Check out the flags docs for more information.
Flags now have a defaultHelp property that allows you to set the human readable default value in the command help. This property is useful when your flag's parse method returns a complex type, such as an object or a class. Check out the flags docs for more.
Commands now have a hiddenAliases property that allows you to define aliases that you want to hide from the user. The property is super helpful when you're trying to wean users off a deprecated command.
You can now use bun or tsx as dev runtimes (as opposed to node or ts-node).
A command's usage, args, and flags are now shown whenever a user forgets to provide a required arg or flag, or when they provided a non-existent flag.

If you need help migrating to the latest version, head over to core's README which has links to the migration guides. Feel free to open a new discussion if you need more hands-on help from us or the community.
ESM Support​
Version 3 of @oclif/core introduced full support for developing ESM plugins and CLIs. It also offered full support for interoperability between CommonJS and ESM plugins.
Put more simply, you can now migrate your CLI to ESM while keeping individual plugins in CommonJS (or vice versa). The upgrade path is now much simpler for you. You also don't need to worry about any community plugins that have migrated to ESM before you did (such as all the @oclif plugins) or are staunchly sticking with CommonJS for the foreseeable future.
Read more about this topic here.
Improving and Revitalizing oclif.io​
Another area of focus for us has been improving our documentation site, oclif.io.
While improving the quality and accuracy of the documentation was our priority, we also took the time to upgrade to the latest version of docusaurus. This new version gave our site a much-needed facelift, as well as cool new features such as dark mode and announcements.
If you have any feedback or are running into issues, we want to hear about it. Just create an issue in the oclif.io repo.
Re-engaging the oclif Community​
Lastly, our biggest priority at the moment is to re-engage the oclif community. We understand how frustrating it has been over the years to see your issues and pull requests go unacknowledged. We apologize for not prioritizing the community, and are earnestly trying to make sure that every issue and pull request gets the attention it deserves going forward.
We also opened up GitHub discussions for @oclif/core and the oclif CLI, where you can now post your questions or ideas. We hope you take advantage of them, we love hearing from you!
One last thing: we intend to publicly post our roadmap so you have more visibility into what we're working on. Stay tuned!
All our best,
The oclif teamAnnouncing oclif v2!January 12, 2022 · 5 min readHello and happy new year! It's our great pleasure to announce that we have released oclif v2, which uses the new @oclif/core library! 🎉
oclif v2 includes many changes that improve the experience of both creating and using an oclif CLI.
Going forward, we don't plan to make any updates to oclif v1 and its corresponding libraries, except for critical security fixes. See the compatibility matrix for a list of these libraries. In order to give developers time to migrate from v1 to v2, we're not completely dropping support yet. But at some point in the future we'll archive the v1 repositories and deprecate their versions on npm.
What’s changing?​
Repository Changes​
All repositories under the oclif org now use main as their primary branch and oclif-v1 as the legacy branch. The main  branch corresponds to oclif v2 and the oclif-v1 branch to oclif v1. If you find any repos that don’t have a main branch, you can safely assume that they're not used in oclif v2 and will be deprecated in the future.
Consolidating Tools & Libraries​
The oclif-dev CLI has now been incorporated into oclif. You now no longer need to install a separate package to manage your entire CLI’s lifecycle.
The following libraries have been consolidated under @oclif/core and will be deprecated at some point in the future. Read the migration guide to learn how to update your CLI or plugin to use the new core library.

@oclif/command
@oclif/config
@oclif/error
@oclif/help
@oclif/parser

No more single vs multi command CLIs​
There's only one "type" of oclif v2 CLI, but it can have as few or as many commands as a developer wants. As a result, there’s only one command to generate CLIs, oclif generate, as opposed to the old oclif single and oclif multi commands.
Node > 12​
To ensure oclif CLIs are as secure as possible, all v2 libraries and plugins support only Node 12 or higher as of now. Going forward, they'll support only Node Maintenance or higher, as defined by Node's release schedule here: https://nodejs.org/en/about/releases/.
What’s new?​
New example CLI​
oclif-hello-world is our new example repo. This is also the repo that's used as a template when running oclif generate to create a new CLI. This repo will always be able to be referenced as an example of what an oclif v2 CLI should look like.
Spaced commands​
oclif CLIs can now use spaces, instead of colons, to separate topics and subcommands. To enable this feature, simply add “topicSeparator": " " to the oclif config in your package.json. See an example in our example repo.
// Old commands that use :$ mycli do:something
// New spaced commands$ mycli do something

Note: Spaced commands are backwards compatible. So if you enable spaced commands for your CLI, users will still be able to use : as a separator. This ensures that any existing scripts don't break.

New Help Output​
We’ve revamped the way command help is outputted to the terminal, making it both easier to implement and easier to read. See the difference between the old help output on the left and the new help output on the right in the screenshots below.
oclif v1oclif v2
Notice that there are new sections for flags and global flags, examples are displayed with better spacing, and there is a section at the bottom called Configuration Variables. This Configuration Variables section is not part of the new help by default. But we've added support for custom help sections, which is what the sf CLI uses to create the new section.
Async Command Parsing​
We’ve also improved the performance of new CLIs by rewriting how commands are parsed on initialization. The new parser is asynchronous, which makes CLIs with a lot of commands or installed  plugins much faster.
What’s coming next?​
Part of our charter for the release of oclif v2 includes improving our engagement with the oclif community. We know that over the past couple of years we’ve reduced our involvement, and a lot of issues and PRs have languished in limbo. Hopefully you’ve already seen increased activity and responses from oclif maintainers recently, but if you haven’t, please don’t hesitate to ping us by tagging @admins in oclif repos.
We also want to start interviewing members of the oclif community to acquire feedback and prioritize the features and fixes you deem most important!
Best,
The oclif team

Reference material​
Migration Guide​
This guide explains how to upgrade a CLI or plugin from the old oclif v1 libraries to the new @oclif/core library that oclif v2 uses.
https://github.com/oclif/core/blob/main/MIGRATION.md
Compatibility Matrix​
The following matrix shows how the v1 libraries and plugins relate to the new v2 ones. Use this matrix as a guide to know what to drop and which versions to switch when upgrading your plugins and CLIs to v2.
oclif "v1"oclif "v2"Utility CLIsoclif@<2@oclif/dev-cli@<2oclif@>=2Main packages@oclif/command@oclif/config@oclif/errors@oclif/parser@oclif/plugin-help@oclif/core@>=1Node LTSNode v8-14Node v12+ (at time of writing)TypeScripttypescript@<4typescript@>=4Main plugins@oclif/plugin-autocomplete@<1@oclif/plugin-commands@<2@oclif/plugin-help@<4@oclif/plugin-not-found@<2@oclif/plugin-plugins@<2@oclif/plugin-update@<2plugin-warn-if-update-available@<2plugin-which@<2@oclif/plugin-autocomplete@>=1@oclif/plugin-commands@>=2@oclif/plugin-help@>=4@oclif/plugin-not-found@>=2@oclif/plugin-plugins@>=2@oclif/plugin-update@>=2@oclif/plugin-warn-if-update-available@>=2@oclif/plugin-which@>=2Introducing @oclif/coreMarch 1, 2021 · 3 min readGreetings!
We hope this blog post finds you well.
Introducing...​
We are excited to announce the next iteration of the oclif project today: @oclif/core.
We have learned a lot in the last three years of developing oclif, developing on oclif and supporting millions of command runs a day via Heroku and Salesforce CLIs.
@oclif/core ("Core") simplifies the oclif development experience and introduces highly requested new features.
Core combines the essential oclif packages into one "core" package, aptly named @oclif/core.
Core also introduces:

A default command option
Colon or space command syntax
Async command parsing
Command piping to arguments

With the introduction of default command functionality, Core simplifies the oclif project and removes the notion of single or multi command CLIs. Core CLIs can have 1 or many commands.
Along with Core, we moved the oclif-dev CLI into the oclif CLI creating a single "utility" CLI. This CLI also introduces a new AWS S3 compatible publishing scheme.
What to expect in the near future​
Core is in pre-release beta and being actively developed for new internal Salesforce CLIs.
Much documentation needs to be written in the coming months including migration paths. Migration onto Core should be as painless as possible with many exports remaining entirely unchanged. Look for forthcoming blog posts and documentation on oclif.io.
Early this summer, tentively June 1, we will release Core v1. Core's release will coincide with major bumps to many other oclif plugin packages. See the compatibility matrix below.
At Core's v1 release, the current "main" oclif packages (namely: command, config, errors & parser) will go into maintenance mode until Jan 2022. They will receive only bug and security fixes and they remain compatible with current versions of the oclif and oclif-dev CLIs. Afterwhich, they will be archived.
Companioning Core, the next major release of the oclif CLI (literally oclif@2) will generate Core CLIs.
Going forward​
We are excited to release Core! We invite you to poke around the Core repo. It may appear to be a big change but Core keeps what you already enjoy about oclif while reducing development complexity, project dependencies, package coupling and bundle size and introduces many requested features previously too prickly to weave into the current oclif architecture.
Best,
The oclif team
Reference: Compatibility matrix​
oclif "v1"oclif "Core"Utility CLIsoclif@<2@oclif/dev-cli@<2oclif@>=2Main packages@oclif/core@<2@oclif/config@<2@oclif/errors@<2@oclif/parser@<4@oclif/plugin-help@<4@oclif/core@>=1Node LTSNode v8-14Node v12+TypeScripttypescript@<4typescript@>=4Main plugins@oclif/plugin-autocomplete@<1@oclif/plugin-commands@<2@oclif/plugin-help@<4@oclif/plugin-not-found@<2@oclif/plugin-plugins@<2@oclif/plugin-update@<2plugin-warn-if-update-available@<2plugin-which@<2@oclif/plugin-autocomplete@>=2@oclif/plugin-commands@>=2@oclif/plugin-help@>=4@oclif/plugin-not-found@>=2@oclif/plugin-plugins@>=2@oclif/plugin-update@>=2@oclif/plugin-warn-if-update-available@>=2@oclif/plugin-which@>=2oclif Summer 2020 UpdateAugust 26, 2020 · 2 min readHello oclif developers! We hope you are all doing well.
Earlier this year, we started our planning for oclifconf v2 and, like all conference, had to change course. We opted not to hold a virtual conference, however, we wanted to take some time to highlight a few oclif features shipped this year.
Feature: Help templating​
One of the most requested features, help templating enables oclif developers to customize the help output for their CLI.
Read the announcement.
Feature: Custom error delegation​
This feature both improved how oclif throws and handles errors and allows oclif developers to overwrite or interject in oclif’s error handling.
Read the announcement.
Feature: postrun hooks​
We have added a new lifecycle event postrun. Your CLI can now run a hook after a command has ran.
See our hook documentation.
Feature: Root index command​
Previously, oclif would display CLI help if only the binary name with no command ID was invoked, oclif now supports a "root index" command. If present, a command defined at src/commands/index.ts will be run if no command ID is found.
1 million weekly downloads​
While exact oclif usage metrics are hard to pin down, we use npm download statistics of oclif packages as a rough approximation. Earlier this year, oclif's command package hit 1 million weekly downloads for the first time!
This year has been presented its challenges on everyone. We want to thank you, oclif developers, whom have taken the time to use and improve the oclif project. We look forward to seeing you all - in person - in the future!
All our best,
The oclif teamPretty Printable ErrorsJuly 1, 2020 · One min readOften CLIs are used as handy tools and when things go wrong it’s useful to have additional context. In oclif we have added a couple of additional properties that can show extra context to the users when an error is displayed. The code, ref and suggestions will now be displayed if they are included. This will work with an existing oclif CLI by adding the latest @oclif/errors and @oclif/core to the CLI's package.json dependencies.
For example, using this.error with the additional properties:
class TestError extends Command {  async run() {    this.error("An error has occurred!", {      code: "OCLIF_ERR",      ref: "https://oclif.io/docs/commands#thiserrormessage-string--error-options-code-string-exit-number",      suggestions: ["Use these extra properties to provide additional context"],    })  }}
would result with the following output:
›   Error: An error has occurred!›   Code: OCLIF_ERR›   Try this: Use these extra properties to provide additional context›   Reference: https://oclif.io/docs/commands#thiserrormessage-string--error-options-code-string-exit-number
If these properties are not provided then nothing changes and the CLI will continue to display the single error message output as it did before. Additionally, as part of this exercise we’ve added documentation around Error Handling in oclif which should come in handy if the need arises to extend oclif’s default handling of errors.Customizing Help in oclifMay 5, 2020 · 2 min readOut of the box oclif provides a great help experience for CLIs.
But what if, as an oclif developer, you want to customize some or all of the output?
You can now customize your CLI's help output by implementing the HelpBase abstract class.
Getting started with custom help​
If you have not done so yet, update @oclif/core.
$ yarn add --latest @oclif/core
To get started, first define the filepath to your help class in oclif's config in package.json. This is a relative path to the help class, without a file extension.
For this example, the help class will be created in a file at "[project root]/src/help.ts".
{  // ...  "oclif": {    "helpClass": "./lib/help"    // ...  }  // ...}
From here there are two paths, implement the HelpBase abstract class yourself or overwrite the parts of the default Help class you want to customize (ex: how command usage is displayed). We recommend the latter approach but cover both in the new Help Classes docs.
Separating TOPICS & COMMANDS in the new default Help class​
Previously, topics and child commands were listed in help output under a single list heading called "COMMANDS". But we found this can be slightly confusing. Some topics are commands also (a.k.a. topic-commands) while others are simply organizational namespacing (and when ran just show their help).
The new default Help class splits the list of children into distinct lists of "TOPICS" and "COMMANDS", with the possibility of an item appearing in both if it a topic-command. This makes it clearer what is expected to be ran - "COMMANDS" - and what is providing structure - "TOPICS" - when looking at the help output.
VERSION  plugin-help-example/0.0.0 darwin-x64 node-v12.12.0USAGE  $ plugin-help-example [COMMAND]TOPICS  topic  this is a topic and has child topics or commandsCOMMANDS  hello  describe the command here  help   display help for plugin-help-example
We look forward to seeing what custom help features you implement in your oclif CLIs with this new feature!oclif TSLint to ESLint MigrationDecember 5, 2019 · 3 min readBack in February of this year, plans were announced to deprecate TSLint in favor of ESLint. TSLint's goal has become to work toward a “unified developer experience” by supporting ESLint development going forward.
What has changed in oclif​
To keep inline with the community, oclif has transitioned to ESLint for all our core libraries as well as all our official plugins.
Starting in v1.15.x, oclif will now optionally generate projects with ESLint for both TypeScript and JavaScript CLI’s.
ESLint does require Node to be on stable LTS version, at the time of writing, Node 8.10.x, Node 10.13.x & Node 12.x.x.
How does this affect you​
Existing CLI’s are unchanged, but any newly generated CLI's will only give the option of using ESLint. If you are running tslint in your CLI, we recommend you switch to ESLint as well.
In migrating our projects we took the following steps (for an example of these changes see this pull request).


Install eslint
$ yarn add eslint eslint-config-oclif eslint-config-oclif-typescript --dev


Add eslint related files


$ echo '{  "extends": [    "oclif",    "oclif-typescript"  ],  "rules": {  }}' > .eslintrc


Remove tslint and related packages
$ yarn remove @oclif/tslint tslint


Remove tslint related configuration files
$ rm tslint.json


Change lint script in our package.json from something like:
"lint": "tsc -p test --noEmit && tslint -p test -t stylish"
to
"lint": "eslint . --ext .ts --config .eslintrc"


To preserve the test compile (tsc -p test --noEmit) we also made the following updates to our scripts:
"pretest": "tsc -p test --noEmit"
In some cases we had our posttest duplicating the same steps as our lint script so it’s cleaner to have it reference the lint job directly with:
"posttest": "yarn lint"

Run yarn lint --fix. This attempts to auto-fix any linting violations automatically. In the case an auto-fix isn’t available it should be fixed manually or ignored (see the eslint configuration doc for more information)
Do a search in the codebase for tslint and remove any unnecessary tslint disabling comments, like:

/* tslint:disable:object-literal-sort-keys */
If you are on a version of Node that is not supported by ESLint, you will also need to update your Node engine. ESLint supports Node 8, 10, and 12 so you should upgrade to the most recent Node version compatible with your CLI and also supported by ESLint (see ESLint's Installation and Usage instructions).
When will this take effect​
These changes have taken effect in oclif v1.15.1. When you generate a new CLI or plugin it will now contain configuration for ESLint instead of TSLint.oclif's Current Node SupportOctober 31, 2019 · 3 min readTo maintain a healthy project trajectory, oclif follows and supports Node Active LTS release, currently Node 10 & Node 12. This means ensuring that oclif continues to play nice with coming Active LTS Node versions and other packages in the ecosystem. Moving forward also means leaving older versions behind. Starting in 2020, Node will stop maintaining Node 8 and it is our intent at that time to also follow suit. Let’s take a look at a few ways we will be supporting these changes.
CI Environments​
CLIs created with the oclif cli going forward will be generated with a CircleCI configuration with Node 10 & 12 and an Appveyor configuration using Node 10. We have also added Node latest to CircleCi to be an early warning detection against coming Node changes (Node latest is managed by CircleCI).
We have already updated every oclif repo's CI configs to reflect this.
If your existing CLI uses either Appveyor or CircleCI you can update your config files also, like so:
.circleci/config.yml​
Your CircleCI config should contain a node-latest job, aliased as test. From this, there should be two extensions of this job for the Active LTS Node versions, Node 10 and Node 12.
  node-10:    <<: *node-latest    docker:      - image: node:10  node-12:    <<: *node-latest    docker:      - image: node:12
Notice that these declarations only change the Docker Node images used to run that job.
Additionally, the jobs listed within workflows must also be updated to reflect our changes in configuration:
    jobs:      - node-latest      - node-10      - node-12
appveyor.yml​
For appveyor we are currently only testing the oldest Active LTS Node version, Node 10. Update the nodejs_version proppert in your appveyor.yml file to reflect this.
environment:  nodejs_version: "10"
Deprecating Node 8 & Updating packge.json engines​
In Jan 2020, Node will end its Node 8 maintenance. We will follow suit by setting the package.json engine property in oclif packages to >=10 and bumping the package's major versions.
Depending on how you ship your CLI you may wish to also bump the engines version in your CLI's package.json. You can read more about the implications of the engines property configuration in the npm documentation.
Also consider distributing your CLI with its own Node version.
Packaged Node Version​
When using dev-cli to pack your CLI it will use the Node version as specified in your package.json under the oclif.update.node.version property. This value should reflect an Active LTS Node version (dev-cli does not currently enforce versions).
Supporting the future​
As a community we may discover bumps along the way as we upgrade. If you notice something related to oclif please feel free to open an issue or submit a pull request under the relevant oclif package within the org.
We look forward to using the latest from Node and the community and keeping oclif healthy along the way.oclifconf 2019: A RecapSeptember 16, 2019 · 4 min readIn May, Heroku and Salesforce Open Source organized oclifconf, a conference for developers & product managers building CLI tools on top of the open source oclif framework. The speakers came from various tech companies, such as Adobe, Netlify, and Apollo, who have already built amazing CLI experiences. The topics covered everything from the incredible capabilities oclif has unlocked, to the community-built plugins extending its functionality, and even what the behavior of an adaptive CLI tool might look like.
Below is a listing of all of the talks from the event, along with a short summary. Enjoy!
The future of oclif by Jeff Dickey​

In its relatively short lifetime, oclif has already inspired many developers and companies to adopt its framework as a means for implementing their own command-line tooling. In this talk, Jeff Dickey, an oclif founding team member, recaps the project's history and inspiration. He also looks towards the future and outlines some features and improvements that the tool could adapt. This isn't so much a definitive roadmap of where oclif is headed, but rather, a call to inspiration for developers eager to contribute! And if you are interested in contributing, check out the open issues in the oclif GitHub repo and come say "Hello!" on Spectrum Chat.
Open Source Citizenship by Josh Simmons​

When it comes to open source, it's more than just individuals now. More and more frequently, large corporations are contributing to projects by donating to contributors, sponsoring events, or upstreaming contributions. But keeping open source projects and communities healthy requires more than just money and brainpower. Josh Simmons surveyed multiple open source communities and relays his findings as to what help maintainers and contributors actually need in this talk.
Building an enterprise-grade CLI with oclif by Thomas Dvornik​

Security and performance are all about trust. While oclif is an extremely extensible framework for building CLI tooling, there are additional requirements to fulfill for enterprise businesses to adopt it that might not be necessary for individual developers. Thomas Dvornik outlines what he and his colleagues at Salesforce have implemented as plugins to oclif to satisfy these needs, including encrypted OAuth, plugin signing, lazy loading dependencies, synchronizing weekly releases and deprecations across dozens of repositories, and establishing cross-team coding and documentation standards.
How Adobe I/O built an extensible CLI with oclif by Jesse MacFadyen​

Perhaps oclif's most appealing feature is its support for plugins. In Cordova's case, they've created a sophisticated telemetry system that helps Adobe developers see which commands users are using--and reports on which ones are erroring out. By embedding a feedback system into the tool, users are even able to quickly send their suggestions to a form, without ever leaving the terminal. Jesse MacFadyen demonstrates how oclif's plugin system can work beyond simply executing commands.
Integrating oclif with GraphQL and Apollo by Evans Hauser​

For Evans Hauser and the team at Apollo, oclif is best thought of as "React for the CLI." As a client paired with a strongly-typed API contract to a server, it can deliver structured and consistent commands to retrieve external data. What better mechanism to use for this transfer than GraphQL, a framework which empowers the client to ask precisely for the data it needs, and nothing more?
Adaptive Intent-based CLI State Machines by Shawn Wang​

In designing oclif, Jeff Dickey wrote out 12 CLI factors to keep in mind. In this talk, Shawn Wang outlines a 13th: state. State is hard, because it depends on context, and context depends on understanding what a user intends to do, not what they are asking. Shawn is working towards enabling oclif to better understand the commands a user has entered, so that it can predict and interpret future commands that might be entered next. This would enable CLI tools to not just interpret a users' commands, but to also interpret their intent.Older Entries\n\n\n\nIntroducing `oclif init` commandApril 10, 2024 · 2 min readThanks to the contribution of @joshcanhelp we released a new command for the oclif CLI called oclif init in version 4.8.0
The oclif init command allows you to initialize oclif in an existing project directory by adding the bare minimum requirements: a few pieces of configuration, bin scripts, and a couple of dependencies (@oclif/core and ts-node). This is slightly different from oclif generate, which will create an entirely new oclif project based on our templates.
oclif init will add the following:

bin scripts: bin/run.js, bin/run.cmd, bin/dev.js, and bin/dev.cmd
oclif section to package.json with bin, dirname, commands, and topicSeparator set (See Configuring Your CLI for more)
@oclif/core to dependencies in your package.json (if it's not already there)
ts-node to devDependencies in your package.json (if it's not already there)

Once you've initialized oclif, you can use the bin scripts to execute your CLI. You can also use the other oclif commands like oclif generate command and oclif generate hook to start adding new functionality.

❯ oclif init --helpInitialize a new oclif CLIUSAGE  $ oclif init [--bin <value>] [--module-type ESM|CommonJS] [--package-manager npm|yarn|pnpm] [--topic-separator    colons|spaces] [-d <value>] [-y]FLAGS  -d, --output-dir=<value>        Directory to initialize the CLI in.  -y, --yes                       Use defaults for all prompts. Individual flags will override defaults.      --bin=<value>               Supply answer for prompt: Command bin name the CLI will export      --module-type=<option>      Supply answer for prompt: Select a module type                                  <options: ESM|CommonJS>      --package-manager=<option>  Supply answer for prompt: Select a package manager                                  <options: npm|yarn|pnpm>      --topic-separator=<option>  Supply answer for prompt: Select a topic separator                                  <options: colons|spaces>DESCRIPTION  Initialize a new oclif CLI  This will add the necessary oclif bin files, add oclif config to package.json, and install @oclif/core and ts-node.EXAMPLES  Initialize a new CLI in the current directory    $ oclif init  Initialize a new CLI in a different directory    $ oclif init --output-dir "/path/to/existing/project"  Supply answers for specific prompts    $ oclif init --topic-separator colons --bin mycli
Hope you enjoy the new command! If you come across any issues or have any new ideas for this command, head over to the oclif/oclif repo and open a new issue.
All our best,
The oclif teamoclif Spring 2024 UpdateMarch 29, 2024 · 4 min readHello oclif developers! It's been a while since we last uploaded a blog - and a lot has happened.
We've been focusing on these high-level areas over the past couple of years:

Improving @oclif/core
ESM Support
Improving and revitalizing oclif.io
Re-engaging the oclif community

Improving @oclif/core​
Since we announced @oclif/core over three years ago, we've released two new major versions, each packed with lots of features that we're really excited about.
Here are some of these changes:

Full support for ESM and interoperability with CommonJS (more on this topic below).
Configurable command discovery strategies that give you more control over how commands are loaded at runtime. Check out the docs.
A new preparse hook that allows you to manipulate the provided arguments before they're parsed. Salesforce used this hook to implement a neat --flags-dir feature that translates local files into flags.
A new Performance class that you can use to track performance inside of @oclif/core and your own CLI or plugin. Check out the docs.
A new flag type, Flags.option, that lets you define a flag with a preset list of options. Typescript then uses the options to infer the flag's type.
Flags now have a relationship property that allows you to define more complex relationships between flags. Check out the flags docs for more information.
Flags now have a defaultHelp property that allows you to set the human readable default value in the command help. This property is useful when your flag's parse method returns a complex type, such as an object or a class. Check out the flags docs for more.
Commands now have a hiddenAliases property that allows you to define aliases that you want to hide from the user. The property is super helpful when you're trying to wean users off a deprecated command.
You can now use bun or tsx as dev runtimes (as opposed to node or ts-node).
A command's usage, args, and flags are now shown whenever a user forgets to provide a required arg or flag, or when they provided a non-existent flag.

If you need help migrating to the latest version, head over to core's README which has links to the migration guides. Feel free to open a new discussion if you need more hands-on help from us or the community.
ESM Support​
Version 3 of @oclif/core introduced full support for developing ESM plugins and CLIs. It also offered full support for interoperability between CommonJS and ESM plugins.
Put more simply, you can now migrate your CLI to ESM while keeping individual plugins in CommonJS (or vice versa). The upgrade path is now much simpler for you. You also don't need to worry about any community plugins that have migrated to ESM before you did (such as all the @oclif plugins) or are staunchly sticking with CommonJS for the foreseeable future.
Read more about this topic here.
Improving and Revitalizing oclif.io​
Another area of focus for us has been improving our documentation site, oclif.io.
While improving the quality and accuracy of the documentation was our priority, we also took the time to upgrade to the latest version of docusaurus. This new version gave our site a much-needed facelift, as well as cool new features such as dark mode and announcements.
If you have any feedback or are running into issues, we want to hear about it. Just create an issue in the oclif.io repo.
Re-engaging the oclif Community​
Lastly, our biggest priority at the moment is to re-engage the oclif community. We understand how frustrating it has been over the years to see your issues and pull requests go unacknowledged. We apologize for not prioritizing the community, and are earnestly trying to make sure that every issue and pull request gets the attention it deserves going forward.
We also opened up GitHub discussions for @oclif/core and the oclif CLI, where you can now post your questions or ideas. We hope you take advantage of them, we love hearing from you!
One last thing: we intend to publicly post our roadmap so you have more visibility into what we're working on. Stay tuned!
All our best,
The oclif teamAnnouncing oclif v2!January 12, 2022 · 5 min readHello and happy new year! It's our great pleasure to announce that we have released oclif v2, which uses the new @oclif/core library! 🎉
oclif v2 includes many changes that improve the experience of both creating and using an oclif CLI.
Going forward, we don't plan to make any updates to oclif v1 and its corresponding libraries, except for critical security fixes. See the compatibility matrix for a list of these libraries. In order to give developers time to migrate from v1 to v2, we're not completely dropping support yet. But at some point in the future we'll archive the v1 repositories and deprecate their versions on npm.
What’s changing?​
Repository Changes​
All repositories under the oclif org now use main as their primary branch and oclif-v1 as the legacy branch. The main  branch corresponds to oclif v2 and the oclif-v1 branch to oclif v1. If you find any repos that don’t have a main branch, you can safely assume that they're not used in oclif v2 and will be deprecated in the future.
Consolidating Tools & Libraries​
The oclif-dev CLI has now been incorporated into oclif. You now no longer need to install a separate package to manage your entire CLI’s lifecycle.
The following libraries have been consolidated under @oclif/core and will be deprecated at some point in the future. Read the migration guide to learn how to update your CLI or plugin to use the new core library.

@oclif/command
@oclif/config
@oclif/error
@oclif/help
@oclif/parser

No more single vs multi command CLIs​
There's only one "type" of oclif v2 CLI, but it can have as few or as many commands as a developer wants. As a result, there’s only one command to generate CLIs, oclif generate, as opposed to the old oclif single and oclif multi commands.
Node > 12​
To ensure oclif CLIs are as secure as possible, all v2 libraries and plugins support only Node 12 or higher as of now. Going forward, they'll support only Node Maintenance or higher, as defined by Node's release schedule here: https://nodejs.org/en/about/releases/.
What’s new?​
New example CLI​
oclif-hello-world is our new example repo. This is also the repo that's used as a template when running oclif generate to create a new CLI. This repo will always be able to be referenced as an example of what an oclif v2 CLI should look like.
Spaced commands​
oclif CLIs can now use spaces, instead of colons, to separate topics and subcommands. To enable this feature, simply add “topicSeparator": " " to the oclif config in your package.json. See an example in our example repo.
// Old commands that use :$ mycli do:something
// New spaced commands$ mycli do something

Note: Spaced commands are backwards compatible. So if you enable spaced commands for your CLI, users will still be able to use : as a separator. This ensures that any existing scripts don't break.

New Help Output​
We’ve revamped the way command help is outputted to the terminal, making it both easier to implement and easier to read. See the difference between the old help output on the left and the new help output on the right in the screenshots below.
oclif v1oclif v2
Notice that there are new sections for flags and global flags, examples are displayed with better spacing, and there is a section at the bottom called Configuration Variables. This Configuration Variables section is not part of the new help by default. But we've added support for custom help sections, which is what the sf CLI uses to create the new section.
Async Command Parsing​
We’ve also improved the performance of new CLIs by rewriting how commands are parsed on initialization. The new parser is asynchronous, which makes CLIs with a lot of commands or installed  plugins much faster.
What’s coming next?​
Part of our charter for the release of oclif v2 includes improving our engagement with the oclif community. We know that over the past couple of years we’ve reduced our involvement, and a lot of issues and PRs have languished in limbo. Hopefully you’ve already seen increased activity and responses from oclif maintainers recently, but if you haven’t, please don’t hesitate to ping us by tagging @admins in oclif repos.
We also want to start interviewing members of the oclif community to acquire feedback and prioritize the features and fixes you deem most important!
Best,
The oclif team

Reference material​
Migration Guide​
This guide explains how to upgrade a CLI or plugin from the old oclif v1 libraries to the new @oclif/core library that oclif v2 uses.
https://github.com/oclif/core/blob/main/MIGRATION.md
Compatibility Matrix​
The following matrix shows how the v1 libraries and plugins relate to the new v2 ones. Use this matrix as a guide to know what to drop and which versions to switch when upgrading your plugins and CLIs to v2.
oclif "v1"oclif "v2"Utility CLIsoclif@<2@oclif/dev-cli@<2oclif@>=2Main packages@oclif/command@oclif/config@oclif/errors@oclif/parser@oclif/plugin-help@oclif/core@>=1Node LTSNode v8-14Node v12+ (at time of writing)TypeScripttypescript@<4typescript@>=4Main plugins@oclif/plugin-autocomplete@<1@oclif/plugin-commands@<2@oclif/plugin-help@<4@oclif/plugin-not-found@<2@oclif/plugin-plugins@<2@oclif/plugin-update@<2plugin-warn-if-update-available@<2plugin-which@<2@oclif/plugin-autocomplete@>=1@oclif/plugin-commands@>=2@oclif/plugin-help@>=4@oclif/plugin-not-found@>=2@oclif/plugin-plugins@>=2@oclif/plugin-update@>=2@oclif/plugin-warn-if-update-available@>=2@oclif/plugin-which@>=2Introducing @oclif/coreMarch 1, 2021 · 3 min readGreetings!
We hope this blog post finds you well.
Introducing...​
We are excited to announce the next iteration of the oclif project today: @oclif/core.
We have learned a lot in the last three years of developing oclif, developing on oclif and supporting millions of command runs a day via Heroku and Salesforce CLIs.
@oclif/core ("Core") simplifies the oclif development experience and introduces highly requested new features.
Core combines the essential oclif packages into one "core" package, aptly named @oclif/core.
Core also introduces:

A default command option
Colon or space command syntax
Async command parsing
Command piping to arguments

With the introduction of default command functionality, Core simplifies the oclif project and removes the notion of single or multi command CLIs. Core CLIs can have 1 or many commands.
Along with Core, we moved the oclif-dev CLI into the oclif CLI creating a single "utility" CLI. This CLI also introduces a new AWS S3 compatible publishing scheme.
What to expect in the near future​
Core is in pre-release beta and being actively developed for new internal Salesforce CLIs.
Much documentation needs to be written in the coming months including migration paths. Migration onto Core should be as painless as possible with many exports remaining entirely unchanged. Look for forthcoming blog posts and documentation on oclif.io.
Early this summer, tentively June 1, we will release Core v1. Core's release will coincide with major bumps to many other oclif plugin packages. See the compatibility matrix below.
At Core's v1 release, the current "main" oclif packages (namely: command, config, errors & parser) will go into maintenance mode until Jan 2022. They will receive only bug and security fixes and they remain compatible with current versions of the oclif and oclif-dev CLIs. Afterwhich, they will be archived.
Companioning Core, the next major release of the oclif CLI (literally oclif@2) will generate Core CLIs.
Going forward​
We are excited to release Core! We invite you to poke around the Core repo. It may appear to be a big change but Core keeps what you already enjoy about oclif while reducing development complexity, project dependencies, package coupling and bundle size and introduces many requested features previously too prickly to weave into the current oclif architecture.
Best,
The oclif team
Reference: Compatibility matrix​
oclif "v1"oclif "Core"Utility CLIsoclif@<2@oclif/dev-cli@<2oclif@>=2Main packages@oclif/core@<2@oclif/config@<2@oclif/errors@<2@oclif/parser@<4@oclif/plugin-help@<4@oclif/core@>=1Node LTSNode v8-14Node v12+TypeScripttypescript@<4typescript@>=4Main plugins@oclif/plugin-autocomplete@<1@oclif/plugin-commands@<2@oclif/plugin-help@<4@oclif/plugin-not-found@<2@oclif/plugin-plugins@<2@oclif/plugin-update@<2plugin-warn-if-update-available@<2plugin-which@<2@oclif/plugin-autocomplete@>=2@oclif/plugin-commands@>=2@oclif/plugin-help@>=4@oclif/plugin-not-found@>=2@oclif/plugin-plugins@>=2@oclif/plugin-update@>=2@oclif/plugin-warn-if-update-available@>=2@oclif/plugin-which@>=2oclif Summer 2020 UpdateAugust 26, 2020 · 2 min readHello oclif developers! We hope you are all doing well.
Earlier this year, we started our planning for oclifconf v2 and, like all conference, had to change course. We opted not to hold a virtual conference, however, we wanted to take some time to highlight a few oclif features shipped this year.
Feature: Help templating​
One of the most requested features, help templating enables oclif developers to customize the help output for their CLI.
Read the announcement.
Feature: Custom error delegation​
This feature both improved how oclif throws and handles errors and allows oclif developers to overwrite or interject in oclif’s error handling.
Read the announcement.
Feature: postrun hooks​
We have added a new lifecycle event postrun. Your CLI can now run a hook after a command has ran.
See our hook documentation.
Feature: Root index command​
Previously, oclif would display CLI help if only the binary name with no command ID was invoked, oclif now supports a "root index" command. If present, a command defined at src/commands/index.ts will be run if no command ID is found.
1 million weekly downloads​
While exact oclif usage metrics are hard to pin down, we use npm download statistics of oclif packages as a rough approximation. Earlier this year, oclif's command package hit 1 million weekly downloads for the first time!
This year has been presented its challenges on everyone. We want to thank you, oclif developers, whom have taken the time to use and improve the oclif project. We look forward to seeing you all - in person - in the future!
All our best,
The oclif teamPretty Printable ErrorsJuly 1, 2020 · One min readOften CLIs are used as handy tools and when things go wrong it’s useful to have additional context. In oclif we have added a couple of additional properties that can show extra context to the users when an error is displayed. The code, ref and suggestions will now be displayed if they are included. This will work with an existing oclif CLI by adding the latest @oclif/errors and @oclif/core to the CLI's package.json dependencies.
For example, using this.error with the additional properties:
class TestError extends Command {  async run() {    this.error("An error has occurred!", {      code: "OCLIF_ERR",      ref: "https://oclif.io/docs/commands#thiserrormessage-string--error-options-code-string-exit-number",      suggestions: ["Use these extra properties to provide additional context"],    })  }}
would result with the following output:
›   Error: An error has occurred!›   Code: OCLIF_ERR›   Try this: Use these extra properties to provide additional context›   Reference: https://oclif.io/docs/commands#thiserrormessage-string--error-options-code-string-exit-number
If these properties are not provided then nothing changes and the CLI will continue to display the single error message output as it did before. Additionally, as part of this exercise we’ve added documentation around Error Handling in oclif which should come in handy if the need arises to extend oclif’s default handling of errors.Customizing Help in oclifMay 5, 2020 · 2 min readOut of the box oclif provides a great help experience for CLIs.
But what if, as an oclif developer, you want to customize some or all of the output?
You can now customize your CLI's help output by implementing the HelpBase abstract class.
Getting started with custom help​
If you have not done so yet, update @oclif/core.
$ yarn add --latest @oclif/core
To get started, first define the filepath to your help class in oclif's config in package.json. This is a relative path to the help class, without a file extension.
For this example, the help class will be created in a file at "[project root]/src/help.ts".
{  // ...  "oclif": {    "helpClass": "./lib/help"    // ...  }  // ...}
From here there are two paths, implement the HelpBase abstract class yourself or overwrite the parts of the default Help class you want to customize (ex: how command usage is displayed). We recommend the latter approach but cover both in the new Help Classes docs.
Separating TOPICS & COMMANDS in the new default Help class​
Previously, topics and child commands were listed in help output under a single list heading called "COMMANDS". But we found this can be slightly confusing. Some topics are commands also (a.k.a. topic-commands) while others are simply organizational namespacing (and when ran just show their help).
The new default Help class splits the list of children into distinct lists of "TOPICS" and "COMMANDS", with the possibility of an item appearing in both if it a topic-command. This makes it clearer what is expected to be ran - "COMMANDS" - and what is providing structure - "TOPICS" - when looking at the help output.
VERSION  plugin-help-example/0.0.0 darwin-x64 node-v12.12.0USAGE  $ plugin-help-example [COMMAND]TOPICS  topic  this is a topic and has child topics or commandsCOMMANDS  hello  describe the command here  help   display help for plugin-help-example
We look forward to seeing what custom help features you implement in your oclif CLIs with this new feature!oclif TSLint to ESLint MigrationDecember 5, 2019 · 3 min readBack in February of this year, plans were announced to deprecate TSLint in favor of ESLint. TSLint's goal has become to work toward a “unified developer experience” by supporting ESLint development going forward.
What has changed in oclif​
To keep inline with the community, oclif has transitioned to ESLint for all our core libraries as well as all our official plugins.
Starting in v1.15.x, oclif will now optionally generate projects with ESLint for both TypeScript and JavaScript CLI’s.
ESLint does require Node to be on stable LTS version, at the time of writing, Node 8.10.x, Node 10.13.x & Node 12.x.x.
How does this affect you​
Existing CLI’s are unchanged, but any newly generated CLI's will only give the option of using ESLint. If you are running tslint in your CLI, we recommend you switch to ESLint as well.
In migrating our projects we took the following steps (for an example of these changes see this pull request).


Install eslint
$ yarn add eslint eslint-config-oclif eslint-config-oclif-typescript --dev


Add eslint related files


$ echo '{  "extends": [    "oclif",    "oclif-typescript"  ],  "rules": {  }}' > .eslintrc


Remove tslint and related packages
$ yarn remove @oclif/tslint tslint


Remove tslint related configuration files
$ rm tslint.json


Change lint script in our package.json from something like:
"lint": "tsc -p test --noEmit && tslint -p test -t stylish"
to
"lint": "eslint . --ext .ts --config .eslintrc"


To preserve the test compile (tsc -p test --noEmit) we also made the following updates to our scripts:
"pretest": "tsc -p test --noEmit"
In some cases we had our posttest duplicating the same steps as our lint script so it’s cleaner to have it reference the lint job directly with:
"posttest": "yarn lint"

Run yarn lint --fix. This attempts to auto-fix any linting violations automatically. In the case an auto-fix isn’t available it should be fixed manually or ignored (see the eslint configuration doc for more information)
Do a search in the codebase for tslint and remove any unnecessary tslint disabling comments, like:

/* tslint:disable:object-literal-sort-keys */
If you are on a version of Node that is not supported by ESLint, you will also need to update your Node engine. ESLint supports Node 8, 10, and 12 so you should upgrade to the most recent Node version compatible with your CLI and also supported by ESLint (see ESLint's Installation and Usage instructions).
When will this take effect​
These changes have taken effect in oclif v1.15.1. When you generate a new CLI or plugin it will now contain configuration for ESLint instead of TSLint.oclif's Current Node SupportOctober 31, 2019 · 3 min readTo maintain a healthy project trajectory, oclif follows and supports Node Active LTS release, currently Node 10 & Node 12. This means ensuring that oclif continues to play nice with coming Active LTS Node versions and other packages in the ecosystem. Moving forward also means leaving older versions behind. Starting in 2020, Node will stop maintaining Node 8 and it is our intent at that time to also follow suit. Let’s take a look at a few ways we will be supporting these changes.
CI Environments​
CLIs created with the oclif cli going forward will be generated with a CircleCI configuration with Node 10 & 12 and an Appveyor configuration using Node 10. We have also added Node latest to CircleCi to be an early warning detection against coming Node changes (Node latest is managed by CircleCI).
We have already updated every oclif repo's CI configs to reflect this.
If your existing CLI uses either Appveyor or CircleCI you can update your config files also, like so:
.circleci/config.yml​
Your CircleCI config should contain a node-latest job, aliased as test. From this, there should be two extensions of this job for the Active LTS Node versions, Node 10 and Node 12.
  node-10:    <<: *node-latest    docker:      - image: node:10  node-12:    <<: *node-latest    docker:      - image: node:12
Notice that these declarations only change the Docker Node images used to run that job.
Additionally, the jobs listed within workflows must also be updated to reflect our changes in configuration:
    jobs:      - node-latest      - node-10      - node-12
appveyor.yml​
For appveyor we are currently only testing the oldest Active LTS Node version, Node 10. Update the nodejs_version proppert in your appveyor.yml file to reflect this.
environment:  nodejs_version: "10"
Deprecating Node 8 & Updating packge.json engines​
In Jan 2020, Node will end its Node 8 maintenance. We will follow suit by setting the package.json engine property in oclif packages to >=10 and bumping the package's major versions.
Depending on how you ship your CLI you may wish to also bump the engines version in your CLI's package.json. You can read more about the implications of the engines property configuration in the npm documentation.
Also consider distributing your CLI with its own Node version.
Packaged Node Version​
When using dev-cli to pack your CLI it will use the Node version as specified in your package.json under the oclif.update.node.version property. This value should reflect an Active LTS Node version (dev-cli does not currently enforce versions).
Supporting the future​
As a community we may discover bumps along the way as we upgrade. If you notice something related to oclif please feel free to open an issue or submit a pull request under the relevant oclif package within the org.
We look forward to using the latest from Node and the community and keeping oclif healthy along the way.oclifconf 2019: A RecapSeptember 16, 2019 · 4 min readIn May, Heroku and Salesforce Open Source organized oclifconf, a conference for developers & product managers building CLI tools on top of the open source oclif framework. The speakers came from various tech companies, such as Adobe, Netlify, and Apollo, who have already built amazing CLI experiences. The topics covered everything from the incredible capabilities oclif has unlocked, to the community-built plugins extending its functionality, and even what the behavior of an adaptive CLI tool might look like.
Below is a listing of all of the talks from the event, along with a short summary. Enjoy!
The future of oclif by Jeff Dickey​

In its relatively short lifetime, oclif has already inspired many developers and companies to adopt its framework as a means for implementing their own command-line tooling. In this talk, Jeff Dickey, an oclif founding team member, recaps the project's history and inspiration. He also looks towards the future and outlines some features and improvements that the tool could adapt. This isn't so much a definitive roadmap of where oclif is headed, but rather, a call to inspiration for developers eager to contribute! And if you are interested in contributing, check out the open issues in the oclif GitHub repo and come say "Hello!" on Spectrum Chat.
Open Source Citizenship by Josh Simmons​

When it comes to open source, it's more than just individuals now. More and more frequently, large corporations are contributing to projects by donating to contributors, sponsoring events, or upstreaming contributions. But keeping open source projects and communities healthy requires more than just money and brainpower. Josh Simmons surveyed multiple open source communities and relays his findings as to what help maintainers and contributors actually need in this talk.
Building an enterprise-grade CLI with oclif by Thomas Dvornik​

Security and performance are all about trust. While oclif is an extremely extensible framework for building CLI tooling, there are additional requirements to fulfill for enterprise businesses to adopt it that might not be necessary for individual developers. Thomas Dvornik outlines what he and his colleagues at Salesforce have implemented as plugins to oclif to satisfy these needs, including encrypted OAuth, plugin signing, lazy loading dependencies, synchronizing weekly releases and deprecations across dozens of repositories, and establishing cross-team coding and documentation standards.
How Adobe I/O built an extensible CLI with oclif by Jesse MacFadyen​

Perhaps oclif's most appealing feature is its support for plugins. In Cordova's case, they've created a sophisticated telemetry system that helps Adobe developers see which commands users are using--and reports on which ones are erroring out. By embedding a feedback system into the tool, users are even able to quickly send their suggestions to a form, without ever leaving the terminal. Jesse MacFadyen demonstrates how oclif's plugin system can work beyond simply executing commands.
Integrating oclif with GraphQL and Apollo by Evans Hauser​

For Evans Hauser and the team at Apollo, oclif is best thought of as "React for the CLI." As a client paired with a strongly-typed API contract to a server, it can deliver structured and consistent commands to retrieve external data. What better mechanism to use for this transfer than GraphQL, a framework which empowers the client to ask precisely for the data it needs, and nothing more?
Adaptive Intent-based CLI State Machines by Shawn Wang​

In designing oclif, Jeff Dickey wrote out 12 CLI factors to keep in mind. In this talk, Shawn Wang outlines a 13th: state. State is hard, because it depends on context, and context depends on understanding what a user intends to do, not what they are asking. Shawn is working towards enabling oclif to better understand the commands a user has entered, so that it can predict and interpret future commands that might be entered next. This would enable CLI tools to not just interpret a users' commands, but to also interpret their intent.\n\nIntroducing `oclif init` commandApril 10, 2024 · 2 min readThanks to the contribution of @joshcanhelp we released a new command for the oclif CLI called oclif init in version 4.8.0
The oclif init command allows you to initialize oclif in an existing project directory by adding the bare minimum requirements: a few pieces of configuration, bin scripts, and a couple of dependencies (@oclif/core and ts-node). This is slightly different from oclif generate, which will create an entirely new oclif project based on our templates.
oclif init will add the following:

bin scripts: bin/run.js, bin/run.cmd, bin/dev.js, and bin/dev.cmd
oclif section to package.json with bin, dirname, commands, and topicSeparator set (See Configuring Your CLI for more)
@oclif/core to dependencies in your package.json (if it's not already there)
ts-node to devDependencies in your package.json (if it's not already there)

Once you've initialized oclif, you can use the bin scripts to execute your CLI. You can also use the other oclif commands like oclif generate command and oclif generate hook to start adding new functionality.

❯ oclif init --helpInitialize a new oclif CLIUSAGE  $ oclif init [--bin <value>] [--module-type ESM|CommonJS] [--package-manager npm|yarn|pnpm] [--topic-separator    colons|spaces] [-d <value>] [-y]FLAGS  -d, --output-dir=<value>        Directory to initialize the CLI in.  -y, --yes                       Use defaults for all prompts. Individual flags will override defaults.      --bin=<value>               Supply answer for prompt: Command bin name the CLI will export      --module-type=<option>      Supply answer for prompt: Select a module type                                  <options: ESM|CommonJS>      --package-manager=<option>  Supply answer for prompt: Select a package manager                                  <options: npm|yarn|pnpm>      --topic-separator=<option>  Supply answer for prompt: Select a topic separator                                  <options: colons|spaces>DESCRIPTION  Initialize a new oclif CLI  This will add the necessary oclif bin files, add oclif config to package.json, and install @oclif/core and ts-node.EXAMPLES  Initialize a new CLI in the current directory    $ oclif init  Initialize a new CLI in a different directory    $ oclif init --output-dir "/path/to/existing/project"  Supply answers for specific prompts    $ oclif init --topic-separator colons --bin mycli
Hope you enjoy the new command! If you come across any issues or have any new ideas for this command, head over to the oclif/oclif repo and open a new issue.
All our best,
The oclif teamoclif Spring 2024 UpdateMarch 29, 2024 · 4 min readHello oclif developers! It's been a while since we last uploaded a blog - and a lot has happened.
We've been focusing on these high-level areas over the past couple of years:

Improving @oclif/core
ESM Support
Improving and revitalizing oclif.io
Re-engaging the oclif community

Improving @oclif/core​
Since we announced @oclif/core over three years ago, we've released two new major versions, each packed with lots of features that we're really excited about.
Here are some of these changes:

Full support for ESM and interoperability with CommonJS (more on this topic below).
Configurable command discovery strategies that give you more control over how commands are loaded at runtime. Check out the docs.
A new preparse hook that allows you to manipulate the provided arguments before they're parsed. Salesforce used this hook to implement a neat --flags-dir feature that translates local files into flags.
A new Performance class that you can use to track performance inside of @oclif/core and your own CLI or plugin. Check out the docs.
A new flag type, Flags.option, that lets you define a flag with a preset list of options. Typescript then uses the options to infer the flag's type.
Flags now have a relationship property that allows you to define more complex relationships between flags. Check out the flags docs for more information.
Flags now have a defaultHelp property that allows you to set the human readable default value in the command help. This property is useful when your flag's parse method returns a complex type, such as an object or a class. Check out the flags docs for more.
Commands now have a hiddenAliases property that allows you to define aliases that you want to hide from the user. The property is super helpful when you're trying to wean users off a deprecated command.
You can now use bun or tsx as dev runtimes (as opposed to node or ts-node).
A command's usage, args, and flags are now shown whenever a user forgets to provide a required arg or flag, or when they provided a non-existent flag.

If you need help migrating to the latest version, head over to core's README which has links to the migration guides. Feel free to open a new discussion if you need more hands-on help from us or the community.
ESM Support​
Version 3 of @oclif/core introduced full support for developing ESM plugins and CLIs. It also offered full support for interoperability between CommonJS and ESM plugins.
Put more simply, you can now migrate your CLI to ESM while keeping individual plugins in CommonJS (or vice versa). The upgrade path is now much simpler for you. You also don't need to worry about any community plugins that have migrated to ESM before you did (such as all the @oclif plugins) or are staunchly sticking with CommonJS for the foreseeable future.
Read more about this topic here.
Improving and Revitalizing oclif.io​
Another area of focus for us has been improving our documentation site, oclif.io.
While improving the quality and accuracy of the documentation was our priority, we also took the time to upgrade to the latest version of docusaurus. This new version gave our site a much-needed facelift, as well as cool new features such as dark mode and announcements.
If you have any feedback or are running into issues, we want to hear about it. Just create an issue in the oclif.io repo.
Re-engaging the oclif Community​
Lastly, our biggest priority at the moment is to re-engage the oclif community. We understand how frustrating it has been over the years to see your issues and pull requests go unacknowledged. We apologize for not prioritizing the community, and are earnestly trying to make sure that every issue and pull request gets the attention it deserves going forward.
We also opened up GitHub discussions for @oclif/core and the oclif CLI, where you can now post your questions or ideas. We hope you take advantage of them, we love hearing from you!
One last thing: we intend to publicly post our roadmap so you have more visibility into what we're working on. Stay tuned!
All our best,
The oclif teamAnnouncing oclif v2!January 12, 2022 · 5 min readHello and happy new year! It's our great pleasure to announce that we have released oclif v2, which uses the new @oclif/core library! 🎉
oclif v2 includes many changes that improve the experience of both creating and using an oclif CLI.
Going forward, we don't plan to make any updates to oclif v1 and its corresponding libraries, except for critical security fixes. See the compatibility matrix for a list of these libraries. In order to give developers time to migrate from v1 to v2, we're not completely dropping support yet. But at some point in the future we'll archive the v1 repositories and deprecate their versions on npm.
What’s changing?​
Repository Changes​
All repositories under the oclif org now use main as their primary branch and oclif-v1 as the legacy branch. The main  branch corresponds to oclif v2 and the oclif-v1 branch to oclif v1. If you find any repos that don’t have a main branch, you can safely assume that they're not used in oclif v2 and will be deprecated in the future.
Consolidating Tools & Libraries​
The oclif-dev CLI has now been incorporated into oclif. You now no longer need to install a separate package to manage your entire CLI’s lifecycle.
The following libraries have been consolidated under @oclif/core and will be deprecated at some point in the future. Read the migration guide to learn how to update your CLI or plugin to use the new core library.

@oclif/command
@oclif/config
@oclif/error
@oclif/help
@oclif/parser

No more single vs multi command CLIs​
There's only one "type" of oclif v2 CLI, but it can have as few or as many commands as a developer wants. As a result, there’s only one command to generate CLIs, oclif generate, as opposed to the old oclif single and oclif multi commands.
Node > 12​
To ensure oclif CLIs are as secure as possible, all v2 libraries and plugins support only Node 12 or higher as of now. Going forward, they'll support only Node Maintenance or higher, as defined by Node's release schedule here: https://nodejs.org/en/about/releases/.
What’s new?​
New example CLI​
oclif-hello-world is our new example repo. This is also the repo that's used as a template when running oclif generate to create a new CLI. This repo will always be able to be referenced as an example of what an oclif v2 CLI should look like.
Spaced commands​
oclif CLIs can now use spaces, instead of colons, to separate topics and subcommands. To enable this feature, simply add “topicSeparator": " " to the oclif config in your package.json. See an example in our example repo.
// Old commands that use :$ mycli do:something
// New spaced commands$ mycli do something

Note: Spaced commands are backwards compatible. So if you enable spaced commands for your CLI, users will still be able to use : as a separator. This ensures that any existing scripts don't break.

New Help Output​
We’ve revamped the way command help is outputted to the terminal, making it both easier to implement and easier to read. See the difference between the old help output on the left and the new help output on the right in the screenshots below.
oclif v1oclif v2
Notice that there are new sections for flags and global flags, examples are displayed with better spacing, and there is a section at the bottom called Configuration Variables. This Configuration Variables section is not part of the new help by default. But we've added support for custom help sections, which is what the sf CLI uses to create the new section.
Async Command Parsing​
We’ve also improved the performance of new CLIs by rewriting how commands are parsed on initialization. The new parser is asynchronous, which makes CLIs with a lot of commands or installed  plugins much faster.
What’s coming next?​
Part of our charter for the release of oclif v2 includes improving our engagement with the oclif community. We know that over the past couple of years we’ve reduced our involvement, and a lot of issues and PRs have languished in limbo. Hopefully you’ve already seen increased activity and responses from oclif maintainers recently, but if you haven’t, please don’t hesitate to ping us by tagging @admins in oclif repos.
We also want to start interviewing members of the oclif community to acquire feedback and prioritize the features and fixes you deem most important!
Best,
The oclif team

Reference material​
Migration Guide​
This guide explains how to upgrade a CLI or plugin from the old oclif v1 libraries to the new @oclif/core library that oclif v2 uses.
https://github.com/oclif/core/blob/main/MIGRATION.md
Compatibility Matrix​
The following matrix shows how the v1 libraries and plugins relate to the new v2 ones. Use this matrix as a guide to know what to drop and which versions to switch when upgrading your plugins and CLIs to v2.
oclif "v1"oclif "v2"Utility CLIsoclif@<2@oclif/dev-cli@<2oclif@>=2Main packages@oclif/command@oclif/config@oclif/errors@oclif/parser@oclif/plugin-help@oclif/core@>=1Node LTSNode v8-14Node v12+ (at time of writing)TypeScripttypescript@<4typescript@>=4Main plugins@oclif/plugin-autocomplete@<1@oclif/plugin-commands@<2@oclif/plugin-help@<4@oclif/plugin-not-found@<2@oclif/plugin-plugins@<2@oclif/plugin-update@<2plugin-warn-if-update-available@<2plugin-which@<2@oclif/plugin-autocomplete@>=1@oclif/plugin-commands@>=2@oclif/plugin-help@>=4@oclif/plugin-not-found@>=2@oclif/plugin-plugins@>=2@oclif/plugin-update@>=2@oclif/plugin-warn-if-update-available@>=2@oclif/plugin-which@>=2Introducing @oclif/coreMarch 1, 2021 · 3 min readGreetings!
We hope this blog post finds you well.
Introducing...​
We are excited to announce the next iteration of the oclif project today: @oclif/core.
We have learned a lot in the last three years of developing oclif, developing on oclif and supporting millions of command runs a day via Heroku and Salesforce CLIs.
@oclif/core ("Core") simplifies the oclif development experience and introduces highly requested new features.
Core combines the essential oclif packages into one "core" package, aptly named @oclif/core.
Core also introduces:

A default command option
Colon or space command syntax
Async command parsing
Command piping to arguments

With the introduction of default command functionality, Core simplifies the oclif project and removes the notion of single or multi command CLIs. Core CLIs can have 1 or many commands.
Along with Core, we moved the oclif-dev CLI into the oclif CLI creating a single "utility" CLI. This CLI also introduces a new AWS S3 compatible publishing scheme.
What to expect in the near future​
Core is in pre-release beta and being actively developed for new internal Salesforce CLIs.
Much documentation needs to be written in the coming months including migration paths. Migration onto Core should be as painless as possible with many exports remaining entirely unchanged. Look for forthcoming blog posts and documentation on oclif.io.
Early this summer, tentively June 1, we will release Core v1. Core's release will coincide with major bumps to many other oclif plugin packages. See the compatibility matrix below.
At Core's v1 release, the current "main" oclif packages (namely: command, config, errors & parser) will go into maintenance mode until Jan 2022. They will receive only bug and security fixes and they remain compatible with current versions of the oclif and oclif-dev CLIs. Afterwhich, they will be archived.
Companioning Core, the next major release of the oclif CLI (literally oclif@2) will generate Core CLIs.
Going forward​
We are excited to release Core! We invite you to poke around the Core repo. It may appear to be a big change but Core keeps what you already enjoy about oclif while reducing development complexity, project dependencies, package coupling and bundle size and introduces many requested features previously too prickly to weave into the current oclif architecture.
Best,
The oclif team
Reference: Compatibility matrix​
oclif "v1"oclif "Core"Utility CLIsoclif@<2@oclif/dev-cli@<2oclif@>=2Main packages@oclif/core@<2@oclif/config@<2@oclif/errors@<2@oclif/parser@<4@oclif/plugin-help@<4@oclif/core@>=1Node LTSNode v8-14Node v12+TypeScripttypescript@<4typescript@>=4Main plugins@oclif/plugin-autocomplete@<1@oclif/plugin-commands@<2@oclif/plugin-help@<4@oclif/plugin-not-found@<2@oclif/plugin-plugins@<2@oclif/plugin-update@<2plugin-warn-if-update-available@<2plugin-which@<2@oclif/plugin-autocomplete@>=2@oclif/plugin-commands@>=2@oclif/plugin-help@>=4@oclif/plugin-not-found@>=2@oclif/plugin-plugins@>=2@oclif/plugin-update@>=2@oclif/plugin-warn-if-update-available@>=2@oclif/plugin-which@>=2oclif Summer 2020 UpdateAugust 26, 2020 · 2 min readHello oclif developers! We hope you are all doing well.
Earlier this year, we started our planning for oclifconf v2 and, like all conference, had to change course. We opted not to hold a virtual conference, however, we wanted to take some time to highlight a few oclif features shipped this year.
Feature: Help templating​
One of the most requested features, help templating enables oclif developers to customize the help output for their CLI.
Read the announcement.
Feature: Custom error delegation​
This feature both improved how oclif throws and handles errors and allows oclif developers to overwrite or interject in oclif’s error handling.
Read the announcement.
Feature: postrun hooks​
We have added a new lifecycle event postrun. Your CLI can now run a hook after a command has ran.
See our hook documentation.
Feature: Root index command​
Previously, oclif would display CLI help if only the binary name with no command ID was invoked, oclif now supports a "root index" command. If present, a command defined at src/commands/index.ts will be run if no command ID is found.
1 million weekly downloads​
While exact oclif usage metrics are hard to pin down, we use npm download statistics of oclif packages as a rough approximation. Earlier this year, oclif's command package hit 1 million weekly downloads for the first time!
This year has been presented its challenges on everyone. We want to thank you, oclif developers, whom have taken the time to use and improve the oclif project. We look forward to seeing you all - in person - in the future!
All our best,
The oclif teamPretty Printable ErrorsJuly 1, 2020 · One min readOften CLIs are used as handy tools and when things go wrong it’s useful to have additional context. In oclif we have added a couple of additional properties that can show extra context to the users when an error is displayed. The code, ref and suggestions will now be displayed if they are included. This will work with an existing oclif CLI by adding the latest @oclif/errors and @oclif/core to the CLI's package.json dependencies.
For example, using this.error with the additional properties:
class TestError extends Command {  async run() {    this.error("An error has occurred!", {      code: "OCLIF_ERR",      ref: "https://oclif.io/docs/commands#thiserrormessage-string--error-options-code-string-exit-number",      suggestions: ["Use these extra properties to provide additional context"],    })  }}
would result with the following output:
›   Error: An error has occurred!›   Code: OCLIF_ERR›   Try this: Use these extra properties to provide additional context›   Reference: https://oclif.io/docs/commands#thiserrormessage-string--error-options-code-string-exit-number
If these properties are not provided then nothing changes and the CLI will continue to display the single error message output as it did before. Additionally, as part of this exercise we’ve added documentation around Error Handling in oclif which should come in handy if the need arises to extend oclif’s default handling of errors.Customizing Help in oclifMay 5, 2020 · 2 min readOut of the box oclif provides a great help experience for CLIs.
But what if, as an oclif developer, you want to customize some or all of the output?
You can now customize your CLI's help output by implementing the HelpBase abstract class.
Getting started with custom help​
If you have not done so yet, update @oclif/core.
$ yarn add --latest @oclif/core
To get started, first define the filepath to your help class in oclif's config in package.json. This is a relative path to the help class, without a file extension.
For this example, the help class will be created in a file at "[project root]/src/help.ts".
{  // ...  "oclif": {    "helpClass": "./lib/help"    // ...  }  // ...}
From here there are two paths, implement the HelpBase abstract class yourself or overwrite the parts of the default Help class you want to customize (ex: how command usage is displayed). We recommend the latter approach but cover both in the new Help Classes docs.
Separating TOPICS & COMMANDS in the new default Help class​
Previously, topics and child commands were listed in help output under a single list heading called "COMMANDS". But we found this can be slightly confusing. Some topics are commands also (a.k.a. topic-commands) while others are simply organizational namespacing (and when ran just show their help).
The new default Help class splits the list of children into distinct lists of "TOPICS" and "COMMANDS", with the possibility of an item appearing in both if it a topic-command. This makes it clearer what is expected to be ran - "COMMANDS" - and what is providing structure - "TOPICS" - when looking at the help output.
VERSION  plugin-help-example/0.0.0 darwin-x64 node-v12.12.0USAGE  $ plugin-help-example [COMMAND]TOPICS  topic  this is a topic and has child topics or commandsCOMMANDS  hello  describe the command here  help   display help for plugin-help-example
We look forward to seeing what custom help features you implement in your oclif CLIs with this new feature!oclif TSLint to ESLint MigrationDecember 5, 2019 · 3 min readBack in February of this year, plans were announced to deprecate TSLint in favor of ESLint. TSLint's goal has become to work toward a “unified developer experience” by supporting ESLint development going forward.
What has changed in oclif​
To keep inline with the community, oclif has transitioned to ESLint for all our core libraries as well as all our official plugins.
Starting in v1.15.x, oclif will now optionally generate projects with ESLint for both TypeScript and JavaScript CLI’s.
ESLint does require Node to be on stable LTS version, at the time of writing, Node 8.10.x, Node 10.13.x & Node 12.x.x.
How does this affect you​
Existing CLI’s are unchanged, but any newly generated CLI's will only give the option of using ESLint. If you are running tslint in your CLI, we recommend you switch to ESLint as well.
In migrating our projects we took the following steps (for an example of these changes see this pull request).


Install eslint
$ yarn add eslint eslint-config-oclif eslint-config-oclif-typescript --dev


Add eslint related files


$ echo '{  "extends": [    "oclif",    "oclif-typescript"  ],  "rules": {  }}' > .eslintrc


Remove tslint and related packages
$ yarn remove @oclif/tslint tslint


Remove tslint related configuration files
$ rm tslint.json


Change lint script in our package.json from something like:
"lint": "tsc -p test --noEmit && tslint -p test -t stylish"
to
"lint": "eslint . --ext .ts --config .eslintrc"


To preserve the test compile (tsc -p test --noEmit) we also made the following updates to our scripts:
"pretest": "tsc -p test --noEmit"
In some cases we had our posttest duplicating the same steps as our lint script so it’s cleaner to have it reference the lint job directly with:
"posttest": "yarn lint"

Run yarn lint --fix. This attempts to auto-fix any linting violations automatically. In the case an auto-fix isn’t available it should be fixed manually or ignored (see the eslint configuration doc for more information)
Do a search in the codebase for tslint and remove any unnecessary tslint disabling comments, like:

/* tslint:disable:object-literal-sort-keys */
If you are on a version of Node that is not supported by ESLint, you will also need to update your Node engine. ESLint supports Node 8, 10, and 12 so you should upgrade to the most recent Node version compatible with your CLI and also supported by ESLint (see ESLint's Installation and Usage instructions).
When will this take effect​
These changes have taken effect in oclif v1.15.1. When you generate a new CLI or plugin it will now contain configuration for ESLint instead of TSLint.oclif's Current Node SupportOctober 31, 2019 · 3 min readTo maintain a healthy project trajectory, oclif follows and supports Node Active LTS release, currently Node 10 & Node 12. This means ensuring that oclif continues to play nice with coming Active LTS Node versions and other packages in the ecosystem. Moving forward also means leaving older versions behind. Starting in 2020, Node will stop maintaining Node 8 and it is our intent at that time to also follow suit. Let’s take a look at a few ways we will be supporting these changes.
CI Environments​
CLIs created with the oclif cli going forward will be generated with a CircleCI configuration with Node 10 & 12 and an Appveyor configuration using Node 10. We have also added Node latest to CircleCi to be an early warning detection against coming Node changes (Node latest is managed by CircleCI).
We have already updated every oclif repo's CI configs to reflect this.
If your existing CLI uses either Appveyor or CircleCI you can update your config files also, like so:
.circleci/config.yml​
Your CircleCI config should contain a node-latest job, aliased as test. From this, there should be two extensions of this job for the Active LTS Node versions, Node 10 and Node 12.
  node-10:    <<: *node-latest    docker:      - image: node:10  node-12:    <<: *node-latest    docker:      - image: node:12
Notice that these declarations only change the Docker Node images used to run that job.
Additionally, the jobs listed within workflows must also be updated to reflect our changes in configuration:
    jobs:      - node-latest      - node-10      - node-12
appveyor.yml​
For appveyor we are currently only testing the oldest Active LTS Node version, Node 10. Update the nodejs_version proppert in your appveyor.yml file to reflect this.
environment:  nodejs_version: "10"
Deprecating Node 8 & Updating packge.json engines​
In Jan 2020, Node will end its Node 8 maintenance. We will follow suit by setting the package.json engine property in oclif packages to >=10 and bumping the package's major versions.
Depending on how you ship your CLI you may wish to also bump the engines version in your CLI's package.json. You can read more about the implications of the engines property configuration in the npm documentation.
Also consider distributing your CLI with its own Node version.
Packaged Node Version​
When using dev-cli to pack your CLI it will use the Node version as specified in your package.json under the oclif.update.node.version property. This value should reflect an Active LTS Node version (dev-cli does not currently enforce versions).
Supporting the future​
As a community we may discover bumps along the way as we upgrade. If you notice something related to oclif please feel free to open an issue or submit a pull request under the relevant oclif package within the org.
We look forward to using the latest from Node and the community and keeping oclif healthy along the way.oclifconf 2019: A RecapSeptember 16, 2019 · 4 min readIn May, Heroku and Salesforce Open Source organized oclifconf, a conference for developers & product managers building CLI tools on top of the open source oclif framework. The speakers came from various tech companies, such as Adobe, Netlify, and Apollo, who have already built amazing CLI experiences. The topics covered everything from the incredible capabilities oclif has unlocked, to the community-built plugins extending its functionality, and even what the behavior of an adaptive CLI tool might look like.
Below is a listing of all of the talks from the event, along with a short summary. Enjoy!
The future of oclif by Jeff Dickey​

In its relatively short lifetime, oclif has already inspired many developers and companies to adopt its framework as a means for implementing their own command-line tooling. In this talk, Jeff Dickey, an oclif founding team member, recaps the project's history and inspiration. He also looks towards the future and outlines some features and improvements that the tool could adapt. This isn't so much a definitive roadmap of where oclif is headed, but rather, a call to inspiration for developers eager to contribute! And if you are interested in contributing, check out the open issues in the oclif GitHub repo and come say "Hello!" on Spectrum Chat.
Open Source Citizenship by Josh Simmons​

When it comes to open source, it's more than just individuals now. More and more frequently, large corporations are contributing to projects by donating to contributors, sponsoring events, or upstreaming contributions. But keeping open source projects and communities healthy requires more than just money and brainpower. Josh Simmons surveyed multiple open source communities and relays his findings as to what help maintainers and contributors actually need in this talk.
Building an enterprise-grade CLI with oclif by Thomas Dvornik​

Security and performance are all about trust. While oclif is an extremely extensible framework for building CLI tooling, there are additional requirements to fulfill for enterprise businesses to adopt it that might not be necessary for individual developers. Thomas Dvornik outlines what he and his colleagues at Salesforce have implemented as plugins to oclif to satisfy these needs, including encrypted OAuth, plugin signing, lazy loading dependencies, synchronizing weekly releases and deprecations across dozens of repositories, and establishing cross-team coding and documentation standards.
How Adobe I/O built an extensible CLI with oclif by Jesse MacFadyen​

Perhaps oclif's most appealing feature is its support for plugins. In Cordova's case, they've created a sophisticated telemetry system that helps Adobe developers see which commands users are using--and reports on which ones are erroring out. By embedding a feedback system into the tool, users are even able to quickly send their suggestions to a form, without ever leaving the terminal. Jesse MacFadyen demonstrates how oclif's plugin system can work beyond simply executing commands.
Integrating oclif with GraphQL and Apollo by Evans Hauser​

For Evans Hauser and the team at Apollo, oclif is best thought of as "React for the CLI." As a client paired with a strongly-typed API contract to a server, it can deliver structured and consistent commands to retrieve external data. What better mechanism to use for this transfer than GraphQL, a framework which empowers the client to ask precisely for the data it needs, and nothing more?
Adaptive Intent-based CLI State Machines by Shawn Wang​

In designing oclif, Jeff Dickey wrote out 12 CLI factors to keep in mind. In this talk, Shawn Wang outlines a 13th: state. State is hard, because it depends on context, and context depends on understanding what a user intends to do, not what they are asking. Shawn is working towards enabling oclif to better understand the commands a user has entered, so that it can predict and interpret future commands that might be entered next. This would enable CLI tools to not just interpret a users' commands, but to also interpret their intent.Older Entries\n\n\n\nIntroducing `oclif init` commandApril 10, 2024 · 2 min readThanks to the contribution of @joshcanhelp we released a new command for the oclif CLI called oclif init in version 4.8.0
The oclif init command allows you to initialize oclif in an existing project directory by adding the bare minimum requirements: a few pieces of configuration, bin scripts, and a couple of dependencies (@oclif/core and ts-node). This is slightly different from oclif generate, which will create an entirely new oclif project based on our templates.
oclif init will add the following:

bin scripts: bin/run.js, bin/run.cmd, bin/dev.js, and bin/dev.cmd
oclif section to package.json with bin, dirname, commands, and topicSeparator set (See Configuring Your CLI for more)
@oclif/core to dependencies in your package.json (if it's not already there)
ts-node to devDependencies in your package.json (if it's not already there)

Once you've initialized oclif, you can use the bin scripts to execute your CLI. You can also use the other oclif commands like oclif generate command and oclif generate hook to start adding new functionality.

❯ oclif init --helpInitialize a new oclif CLIUSAGE  $ oclif init [--bin <value>] [--module-type ESM|CommonJS] [--package-manager npm|yarn|pnpm] [--topic-separator    colons|spaces] [-d <value>] [-y]FLAGS  -d, --output-dir=<value>        Directory to initialize the CLI in.  -y, --yes                       Use defaults for all prompts. Individual flags will override defaults.      --bin=<value>               Supply answer for prompt: Command bin name the CLI will export      --module-type=<option>      Supply answer for prompt: Select a module type                                  <options: ESM|CommonJS>      --package-manager=<option>  Supply answer for prompt: Select a package manager                                  <options: npm|yarn|pnpm>      --topic-separator=<option>  Supply answer for prompt: Select a topic separator                                  <options: colons|spaces>DESCRIPTION  Initialize a new oclif CLI  This will add the necessary oclif bin files, add oclif config to package.json, and install @oclif/core and ts-node.EXAMPLES  Initialize a new CLI in the current directory    $ oclif init  Initialize a new CLI in a different directory    $ oclif init --output-dir "/path/to/existing/project"  Supply answers for specific prompts    $ oclif init --topic-separator colons --bin mycli
Hope you enjoy the new command! If you come across any issues or have any new ideas for this command, head over to the oclif/oclif repo and open a new issue.
All our best,
The oclif teamoclif Spring 2024 UpdateMarch 29, 2024 · 4 min readHello oclif developers! It's been a while since we last uploaded a blog - and a lot has happened.
We've been focusing on these high-level areas over the past couple of years:

Improving @oclif/core
ESM Support
Improving and revitalizing oclif.io
Re-engaging the oclif community

Improving @oclif/core​
Since we announced @oclif/core over three years ago, we've released two new major versions, each packed with lots of features that we're really excited about.
Here are some of these changes:

Full support for ESM and interoperability with CommonJS (more on this topic below).
Configurable command discovery strategies that give you more control over how commands are loaded at runtime. Check out the docs.
A new preparse hook that allows you to manipulate the provided arguments before they're parsed. Salesforce used this hook to implement a neat --flags-dir feature that translates local files into flags.
A new Performance class that you can use to track performance inside of @oclif/core and your own CLI or plugin. Check out the docs.
A new flag type, Flags.option, that lets you define a flag with a preset list of options. Typescript then uses the options to infer the flag's type.
Flags now have a relationship property that allows you to define more complex relationships between flags. Check out the flags docs for more information.
Flags now have a defaultHelp property that allows you to set the human readable default value in the command help. This property is useful when your flag's parse method returns a complex type, such as an object or a class. Check out the flags docs for more.
Commands now have a hiddenAliases property that allows you to define aliases that you want to hide from the user. The property is super helpful when you're trying to wean users off a deprecated command.
You can now use bun or tsx as dev runtimes (as opposed to node or ts-node).
A command's usage, args, and flags are now shown whenever a user forgets to provide a required arg or flag, or when they provided a non-existent flag.

If you need help migrating to the latest version, head over to core's README which has links to the migration guides. Feel free to open a new discussion if you need more hands-on help from us or the community.
ESM Support​
Version 3 of @oclif/core introduced full support for developing ESM plugins and CLIs. It also offered full support for interoperability between CommonJS and ESM plugins.
Put more simply, you can now migrate your CLI to ESM while keeping individual plugins in CommonJS (or vice versa). The upgrade path is now much simpler for you. You also don't need to worry about any community plugins that have migrated to ESM before you did (such as all the @oclif plugins) or are staunchly sticking with CommonJS for the foreseeable future.
Read more about this topic here.
Improving and Revitalizing oclif.io​
Another area of focus for us has been improving our documentation site, oclif.io.
While improving the quality and accuracy of the documentation was our priority, we also took the time to upgrade to the latest version of docusaurus. This new version gave our site a much-needed facelift, as well as cool new features such as dark mode and announcements.
If you have any feedback or are running into issues, we want to hear about it. Just create an issue in the oclif.io repo.
Re-engaging the oclif Community​
Lastly, our biggest priority at the moment is to re-engage the oclif community. We understand how frustrating it has been over the years to see your issues and pull requests go unacknowledged. We apologize for not prioritizing the community, and are earnestly trying to make sure that every issue and pull request gets the attention it deserves going forward.
We also opened up GitHub discussions for @oclif/core and the oclif CLI, where you can now post your questions or ideas. We hope you take advantage of them, we love hearing from you!
One last thing: we intend to publicly post our roadmap so you have more visibility into what we're working on. Stay tuned!
All our best,
The oclif teamAnnouncing oclif v2!January 12, 2022 · 5 min readHello and happy new year! It's our great pleasure to announce that we have released oclif v2, which uses the new @oclif/core library! 🎉
oclif v2 includes many changes that improve the experience of both creating and using an oclif CLI.
Going forward, we don't plan to make any updates to oclif v1 and its corresponding libraries, except for critical security fixes. See the compatibility matrix for a list of these libraries. In order to give developers time to migrate from v1 to v2, we're not completely dropping support yet. But at some point in the future we'll archive the v1 repositories and deprecate their versions on npm.
What’s changing?​
Repository Changes​
All repositories under the oclif org now use main as their primary branch and oclif-v1 as the legacy branch. The main  branch corresponds to oclif v2 and the oclif-v1 branch to oclif v1. If you find any repos that don’t have a main branch, you can safely assume that they're not used in oclif v2 and will be deprecated in the future.
Consolidating Tools & Libraries​
The oclif-dev CLI has now been incorporated into oclif. You now no longer need to install a separate package to manage your entire CLI’s lifecycle.
The following libraries have been consolidated under @oclif/core and will be deprecated at some point in the future. Read the migration guide to learn how to update your CLI or plugin to use the new core library.

@oclif/command
@oclif/config
@oclif/error
@oclif/help
@oclif/parser

No more single vs multi command CLIs​
There's only one "type" of oclif v2 CLI, but it can have as few or as many commands as a developer wants. As a result, there’s only one command to generate CLIs, oclif generate, as opposed to the old oclif single and oclif multi commands.
Node > 12​
To ensure oclif CLIs are as secure as possible, all v2 libraries and plugins support only Node 12 or higher as of now. Going forward, they'll support only Node Maintenance or higher, as defined by Node's release schedule here: https://nodejs.org/en/about/releases/.
What’s new?​
New example CLI​
oclif-hello-world is our new example repo. This is also the repo that's used as a template when running oclif generate to create a new CLI. This repo will always be able to be referenced as an example of what an oclif v2 CLI should look like.
Spaced commands​
oclif CLIs can now use spaces, instead of colons, to separate topics and subcommands. To enable this feature, simply add “topicSeparator": " " to the oclif config in your package.json. See an example in our example repo.
// Old commands that use :$ mycli do:something
// New spaced commands$ mycli do something

Note: Spaced commands are backwards compatible. So if you enable spaced commands for your CLI, users will still be able to use : as a separator. This ensures that any existing scripts don't break.

New Help Output​
We’ve revamped the way command help is outputted to the terminal, making it both easier to implement and easier to read. See the difference between the old help output on the left and the new help output on the right in the screenshots below.
oclif v1oclif v2
Notice that there are new sections for flags and global flags, examples are displayed with better spacing, and there is a section at the bottom called Configuration Variables. This Configuration Variables section is not part of the new help by default. But we've added support for custom help sections, which is what the sf CLI uses to create the new section.
Async Command Parsing​
We’ve also improved the performance of new CLIs by rewriting how commands are parsed on initialization. The new parser is asynchronous, which makes CLIs with a lot of commands or installed  plugins much faster.
What’s coming next?​
Part of our charter for the release of oclif v2 includes improving our engagement with the oclif community. We know that over the past couple of years we’ve reduced our involvement, and a lot of issues and PRs have languished in limbo. Hopefully you’ve already seen increased activity and responses from oclif maintainers recently, but if you haven’t, please don’t hesitate to ping us by tagging @admins in oclif repos.
We also want to start interviewing members of the oclif community to acquire feedback and prioritize the features and fixes you deem most important!
Best,
The oclif team

Reference material​
Migration Guide​
This guide explains how to upgrade a CLI or plugin from the old oclif v1 libraries to the new @oclif/core library that oclif v2 uses.
https://github.com/oclif/core/blob/main/MIGRATION.md
Compatibility Matrix​
The following matrix shows how the v1 libraries and plugins relate to the new v2 ones. Use this matrix as a guide to know what to drop and which versions to switch when upgrading your plugins and CLIs to v2.
oclif "v1"oclif "v2"Utility CLIsoclif@<2@oclif/dev-cli@<2oclif@>=2Main packages@oclif/command@oclif/config@oclif/errors@oclif/parser@oclif/plugin-help@oclif/core@>=1Node LTSNode v8-14Node v12+ (at time of writing)TypeScripttypescript@<4typescript@>=4Main plugins@oclif/plugin-autocomplete@<1@oclif/plugin-commands@<2@oclif/plugin-help@<4@oclif/plugin-not-found@<2@oclif/plugin-plugins@<2@oclif/plugin-update@<2plugin-warn-if-update-available@<2plugin-which@<2@oclif/plugin-autocomplete@>=1@oclif/plugin-commands@>=2@oclif/plugin-help@>=4@oclif/plugin-not-found@>=2@oclif/plugin-plugins@>=2@oclif/plugin-update@>=2@oclif/plugin-warn-if-update-available@>=2@oclif/plugin-which@>=2Introducing @oclif/coreMarch 1, 2021 · 3 min readGreetings!
We hope this blog post finds you well.
Introducing...​
We are excited to announce the next iteration of the oclif project today: @oclif/core.
We have learned a lot in the last three years of developing oclif, developing on oclif and supporting millions of command runs a day via Heroku and Salesforce CLIs.
@oclif/core ("Core") simplifies the oclif development experience and introduces highly requested new features.
Core combines the essential oclif packages into one "core" package, aptly named @oclif/core.
Core also introduces:

A default command option
Colon or space command syntax
Async command parsing
Command piping to arguments

With the introduction of default command functionality, Core simplifies the oclif project and removes the notion of single or multi command CLIs. Core CLIs can have 1 or many commands.
Along with Core, we moved the oclif-dev CLI into the oclif CLI creating a single "utility" CLI. This CLI also introduces a new AWS S3 compatible publishing scheme.
What to expect in the near future​
Core is in pre-release beta and being actively developed for new internal Salesforce CLIs.
Much documentation needs to be written in the coming months including migration paths. Migration onto Core should be as painless as possible with many exports remaining entirely unchanged. Look for forthcoming blog posts and documentation on oclif.io.
Early this summer, tentively June 1, we will release Core v1. Core's release will coincide with major bumps to many other oclif plugin packages. See the compatibility matrix below.
At Core's v1 release, the current "main" oclif packages (namely: command, config, errors & parser) will go into maintenance mode until Jan 2022. They will receive only bug and security fixes and they remain compatible with current versions of the oclif and oclif-dev CLIs. Afterwhich, they will be archived.
Companioning Core, the next major release of the oclif CLI (literally oclif@2) will generate Core CLIs.
Going forward​
We are excited to release Core! We invite you to poke around the Core repo. It may appear to be a big change but Core keeps what you already enjoy about oclif while reducing development complexity, project dependencies, package coupling and bundle size and introduces many requested features previously too prickly to weave into the current oclif architecture.
Best,
The oclif team
Reference: Compatibility matrix​
oclif "v1"oclif "Core"Utility CLIsoclif@<2@oclif/dev-cli@<2oclif@>=2Main packages@oclif/core@<2@oclif/config@<2@oclif/errors@<2@oclif/parser@<4@oclif/plugin-help@<4@oclif/core@>=1Node LTSNode v8-14Node v12+TypeScripttypescript@<4typescript@>=4Main plugins@oclif/plugin-autocomplete@<1@oclif/plugin-commands@<2@oclif/plugin-help@<4@oclif/plugin-not-found@<2@oclif/plugin-plugins@<2@oclif/plugin-update@<2plugin-warn-if-update-available@<2plugin-which@<2@oclif/plugin-autocomplete@>=2@oclif/plugin-commands@>=2@oclif/plugin-help@>=4@oclif/plugin-not-found@>=2@oclif/plugin-plugins@>=2@oclif/plugin-update@>=2@oclif/plugin-warn-if-update-available@>=2@oclif/plugin-which@>=2oclif Summer 2020 UpdateAugust 26, 2020 · 2 min readHello oclif developers! We hope you are all doing well.
Earlier this year, we started our planning for oclifconf v2 and, like all conference, had to change course. We opted not to hold a virtual conference, however, we wanted to take some time to highlight a few oclif features shipped this year.
Feature: Help templating​
One of the most requested features, help templating enables oclif developers to customize the help output for their CLI.
Read the announcement.
Feature: Custom error delegation​
This feature both improved how oclif throws and handles errors and allows oclif developers to overwrite or interject in oclif’s error handling.
Read the announcement.
Feature: postrun hooks​
We have added a new lifecycle event postrun. Your CLI can now run a hook after a command has ran.
See our hook documentation.
Feature: Root index command​
Previously, oclif would display CLI help if only the binary name with no command ID was invoked, oclif now supports a "root index" command. If present, a command defined at src/commands/index.ts will be run if no command ID is found.
1 million weekly downloads​
While exact oclif usage metrics are hard to pin down, we use npm download statistics of oclif packages as a rough approximation. Earlier this year, oclif's command package hit 1 million weekly downloads for the first time!
This year has been presented its challenges on everyone. We want to thank you, oclif developers, whom have taken the time to use and improve the oclif project. We look forward to seeing you all - in person - in the future!
All our best,
The oclif teamPretty Printable ErrorsJuly 1, 2020 · One min readOften CLIs are used as handy tools and when things go wrong it’s useful to have additional context. In oclif we have added a couple of additional properties that can show extra context to the users when an error is displayed. The code, ref and suggestions will now be displayed if they are included. This will work with an existing oclif CLI by adding the latest @oclif/errors and @oclif/core to the CLI's package.json dependencies.
For example, using this.error with the additional properties:
class TestError extends Command {  async run() {    this.error("An error has occurred!", {      code: "OCLIF_ERR",      ref: "https://oclif.io/docs/commands#thiserrormessage-string--error-options-code-string-exit-number",      suggestions: ["Use these extra properties to provide additional context"],    })  }}
would result with the following output:
›   Error: An error has occurred!›   Code: OCLIF_ERR›   Try this: Use these extra properties to provide additional context›   Reference: https://oclif.io/docs/commands#thiserrormessage-string--error-options-code-string-exit-number
If these properties are not provided then nothing changes and the CLI will continue to display the single error message output as it did before. Additionally, as part of this exercise we’ve added documentation around Error Handling in oclif which should come in handy if the need arises to extend oclif’s default handling of errors.Customizing Help in oclifMay 5, 2020 · 2 min readOut of the box oclif provides a great help experience for CLIs.
But what if, as an oclif developer, you want to customize some or all of the output?
You can now customize your CLI's help output by implementing the HelpBase abstract class.
Getting started with custom help​
If you have not done so yet, update @oclif/core.
$ yarn add --latest @oclif/core
To get started, first define the filepath to your help class in oclif's config in package.json. This is a relative path to the help class, without a file extension.
For this example, the help class will be created in a file at "[project root]/src/help.ts".
{  // ...  "oclif": {    "helpClass": "./lib/help"    // ...  }  // ...}
From here there are two paths, implement the HelpBase abstract class yourself or overwrite the parts of the default Help class you want to customize (ex: how command usage is displayed). We recommend the latter approach but cover both in the new Help Classes docs.
Separating TOPICS & COMMANDS in the new default Help class​
Previously, topics and child commands were listed in help output under a single list heading called "COMMANDS". But we found this can be slightly confusing. Some topics are commands also (a.k.a. topic-commands) while others are simply organizational namespacing (and when ran just show their help).
The new default Help class splits the list of children into distinct lists of "TOPICS" and "COMMANDS", with the possibility of an item appearing in both if it a topic-command. This makes it clearer what is expected to be ran - "COMMANDS" - and what is providing structure - "TOPICS" - when looking at the help output.
VERSION  plugin-help-example/0.0.0 darwin-x64 node-v12.12.0USAGE  $ plugin-help-example [COMMAND]TOPICS  topic  this is a topic and has child topics or commandsCOMMANDS  hello  describe the command here  help   display help for plugin-help-example
We look forward to seeing what custom help features you implement in your oclif CLIs with this new feature!oclif TSLint to ESLint MigrationDecember 5, 2019 · 3 min readBack in February of this year, plans were announced to deprecate TSLint in favor of ESLint. TSLint's goal has become to work toward a “unified developer experience” by supporting ESLint development going forward.
What has changed in oclif​
To keep inline with the community, oclif has transitioned to ESLint for all our core libraries as well as all our official plugins.
Starting in v1.15.x, oclif will now optionally generate projects with ESLint for both TypeScript and JavaScript CLI’s.
ESLint does require Node to be on stable LTS version, at the time of writing, Node 8.10.x, Node 10.13.x & Node 12.x.x.
How does this affect you​
Existing CLI’s are unchanged, but any newly generated CLI's will only give the option of using ESLint. If you are running tslint in your CLI, we recommend you switch to ESLint as well.
In migrating our projects we took the following steps (for an example of these changes see this pull request).


Install eslint
$ yarn add eslint eslint-config-oclif eslint-config-oclif-typescript --dev


Add eslint related files


$ echo '{  "extends": [    "oclif",    "oclif-typescript"  ],  "rules": {  }}' > .eslintrc


Remove tslint and related packages
$ yarn remove @oclif/tslint tslint


Remove tslint related configuration files
$ rm tslint.json


Change lint script in our package.json from something like:
"lint": "tsc -p test --noEmit && tslint -p test -t stylish"
to
"lint": "eslint . --ext .ts --config .eslintrc"


To preserve the test compile (tsc -p test --noEmit) we also made the following updates to our scripts:
"pretest": "tsc -p test --noEmit"
In some cases we had our posttest duplicating the same steps as our lint script so it’s cleaner to have it reference the lint job directly with:
"posttest": "yarn lint"

Run yarn lint --fix. This attempts to auto-fix any linting violations automatically. In the case an auto-fix isn’t available it should be fixed manually or ignored (see the eslint configuration doc for more information)
Do a search in the codebase for tslint and remove any unnecessary tslint disabling comments, like:

/* tslint:disable:object-literal-sort-keys */
If you are on a version of Node that is not supported by ESLint, you will also need to update your Node engine. ESLint supports Node 8, 10, and 12 so you should upgrade to the most recent Node version compatible with your CLI and also supported by ESLint (see ESLint's Installation and Usage instructions).
When will this take effect​
These changes have taken effect in oclif v1.15.1. When you generate a new CLI or plugin it will now contain configuration for ESLint instead of TSLint.oclif's Current Node SupportOctober 31, 2019 · 3 min readTo maintain a healthy project trajectory, oclif follows and supports Node Active LTS release, currently Node 10 & Node 12. This means ensuring that oclif continues to play nice with coming Active LTS Node versions and other packages in the ecosystem. Moving forward also means leaving older versions behind. Starting in 2020, Node will stop maintaining Node 8 and it is our intent at that time to also follow suit. Let’s take a look at a few ways we will be supporting these changes.
CI Environments​
CLIs created with the oclif cli going forward will be generated with a CircleCI configuration with Node 10 & 12 and an Appveyor configuration using Node 10. We have also added Node latest to CircleCi to be an early warning detection against coming Node changes (Node latest is managed by CircleCI).
We have already updated every oclif repo's CI configs to reflect this.
If your existing CLI uses either Appveyor or CircleCI you can update your config files also, like so:
.circleci/config.yml​
Your CircleCI config should contain a node-latest job, aliased as test. From this, there should be two extensions of this job for the Active LTS Node versions, Node 10 and Node 12.
  node-10:    <<: *node-latest    docker:      - image: node:10  node-12:    <<: *node-latest    docker:      - image: node:12
Notice that these declarations only change the Docker Node images used to run that job.
Additionally, the jobs listed within workflows must also be updated to reflect our changes in configuration:
    jobs:      - node-latest      - node-10      - node-12
appveyor.yml​
For appveyor we are currently only testing the oldest Active LTS Node version, Node 10. Update the nodejs_version proppert in your appveyor.yml file to reflect this.
environment:  nodejs_version: "10"
Deprecating Node 8 & Updating packge.json engines​
In Jan 2020, Node will end its Node 8 maintenance. We will follow suit by setting the package.json engine property in oclif packages to >=10 and bumping the package's major versions.
Depending on how you ship your CLI you may wish to also bump the engines version in your CLI's package.json. You can read more about the implications of the engines property configuration in the npm documentation.
Also consider distributing your CLI with its own Node version.
Packaged Node Version​
When using dev-cli to pack your CLI it will use the Node version as specified in your package.json under the oclif.update.node.version property. This value should reflect an Active LTS Node version (dev-cli does not currently enforce versions).
Supporting the future​
As a community we may discover bumps along the way as we upgrade. If you notice something related to oclif please feel free to open an issue or submit a pull request under the relevant oclif package within the org.
We look forward to using the latest from Node and the community and keeping oclif healthy along the way.oclifconf 2019: A RecapSeptember 16, 2019 · 4 min readIn May, Heroku and Salesforce Open Source organized oclifconf, a conference for developers & product managers building CLI tools on top of the open source oclif framework. The speakers came from various tech companies, such as Adobe, Netlify, and Apollo, who have already built amazing CLI experiences. The topics covered everything from the incredible capabilities oclif has unlocked, to the community-built plugins extending its functionality, and even what the behavior of an adaptive CLI tool might look like.
Below is a listing of all of the talks from the event, along with a short summary. Enjoy!
The future of oclif by Jeff Dickey​

In its relatively short lifetime, oclif has already inspired many developers and companies to adopt its framework as a means for implementing their own command-line tooling. In this talk, Jeff Dickey, an oclif founding team member, recaps the project's history and inspiration. He also looks towards the future and outlines some features and improvements that the tool could adapt. This isn't so much a definitive roadmap of where oclif is headed, but rather, a call to inspiration for developers eager to contribute! And if you are interested in contributing, check out the open issues in the oclif GitHub repo and come say "Hello!" on Spectrum Chat.
Open Source Citizenship by Josh Simmons​

When it comes to open source, it's more than just individuals now. More and more frequently, large corporations are contributing to projects by donating to contributors, sponsoring events, or upstreaming contributions. But keeping open source projects and communities healthy requires more than just money and brainpower. Josh Simmons surveyed multiple open source communities and relays his findings as to what help maintainers and contributors actually need in this talk.
Building an enterprise-grade CLI with oclif by Thomas Dvornik​

Security and performance are all about trust. While oclif is an extremely extensible framework for building CLI tooling, there are additional requirements to fulfill for enterprise businesses to adopt it that might not be necessary for individual developers. Thomas Dvornik outlines what he and his colleagues at Salesforce have implemented as plugins to oclif to satisfy these needs, including encrypted OAuth, plugin signing, lazy loading dependencies, synchronizing weekly releases and deprecations across dozens of repositories, and establishing cross-team coding and documentation standards.
How Adobe I/O built an extensible CLI with oclif by Jesse MacFadyen​

Perhaps oclif's most appealing feature is its support for plugins. In Cordova's case, they've created a sophisticated telemetry system that helps Adobe developers see which commands users are using--and reports on which ones are erroring out. By embedding a feedback system into the tool, users are even able to quickly send their suggestions to a form, without ever leaving the terminal. Jesse MacFadyen demonstrates how oclif's plugin system can work beyond simply executing commands.
Integrating oclif with GraphQL and Apollo by Evans Hauser​

For Evans Hauser and the team at Apollo, oclif is best thought of as "React for the CLI." As a client paired with a strongly-typed API contract to a server, it can deliver structured and consistent commands to retrieve external data. What better mechanism to use for this transfer than GraphQL, a framework which empowers the client to ask precisely for the data it needs, and nothing more?
Adaptive Intent-based CLI State Machines by Shawn Wang​

In designing oclif, Jeff Dickey wrote out 12 CLI factors to keep in mind. In this talk, Shawn Wang outlines a 13th: state. State is hard, because it depends on context, and context depends on understanding what a user intends to do, not what they are asking. Shawn is working towards enabling oclif to better understand the commands a user has entered, so that it can predict and interpret future commands that might be entered next. This would enable CLI tools to not just interpret a users' commands, but to also interpret their intent.\n\nIntroducing `oclif init` commandApril 10, 2024 · 2 min readThanks to the contribution of @joshcanhelp we released a new command for the oclif CLI called oclif init in version 4.8.0
The oclif init command allows you to initialize oclif in an existing project directory by adding the bare minimum requirements: a few pieces of configuration, bin scripts, and a couple of dependencies (@oclif/core and ts-node). This is slightly different from oclif generate, which will create an entirely new oclif project based on our templates.
oclif init will add the following:

bin scripts: bin/run.js, bin/run.cmd, bin/dev.js, and bin/dev.cmd
oclif section to package.json with bin, dirname, commands, and topicSeparator set (See Configuring Your CLI for more)
@oclif/core to dependencies in your package.json (if it's not already there)
ts-node to devDependencies in your package.json (if it's not already there)

Once you've initialized oclif, you can use the bin scripts to execute your CLI. You can also use the other oclif commands like oclif generate command and oclif generate hook to start adding new functionality.

❯ oclif init --helpInitialize a new oclif CLIUSAGE  $ oclif init [--bin <value>] [--module-type ESM|CommonJS] [--package-manager npm|yarn|pnpm] [--topic-separator    colons|spaces] [-d <value>] [-y]FLAGS  -d, --output-dir=<value>        Directory to initialize the CLI in.  -y, --yes                       Use defaults for all prompts. Individual flags will override defaults.      --bin=<value>               Supply answer for prompt: Command bin name the CLI will export      --module-type=<option>      Supply answer for prompt: Select a module type                                  <options: ESM|CommonJS>      --package-manager=<option>  Supply answer for prompt: Select a package manager                                  <options: npm|yarn|pnpm>      --topic-separator=<option>  Supply answer for prompt: Select a topic separator                                  <options: colons|spaces>DESCRIPTION  Initialize a new oclif CLI  This will add the necessary oclif bin files, add oclif config to package.json, and install @oclif/core and ts-node.EXAMPLES  Initialize a new CLI in the current directory    $ oclif init  Initialize a new CLI in a different directory    $ oclif init --output-dir "/path/to/existing/project"  Supply answers for specific prompts    $ oclif init --topic-separator colons --bin mycli
Hope you enjoy the new command! If you come across any issues or have any new ideas for this command, head over to the oclif/oclif repo and open a new issue.
All our best,
The oclif teamoclif Spring 2024 UpdateMarch 29, 2024 · 4 min readHello oclif developers! It's been a while since we last uploaded a blog - and a lot has happened.
We've been focusing on these high-level areas over the past couple of years:

Improving @oclif/core
ESM Support
Improving and revitalizing oclif.io
Re-engaging the oclif community

Improving @oclif/core​
Since we announced @oclif/core over three years ago, we've released two new major versions, each packed with lots of features that we're really excited about.
Here are some of these changes:

Full support for ESM and interoperability with CommonJS (more on this topic below).
Configurable command discovery strategies that give you more control over how commands are loaded at runtime. Check out the docs.
A new preparse hook that allows you to manipulate the provided arguments before they're parsed. Salesforce used this hook to implement a neat --flags-dir feature that translates local files into flags.
A new Performance class that you can use to track performance inside of @oclif/core and your own CLI or plugin. Check out the docs.
A new flag type, Flags.option, that lets you define a flag with a preset list of options. Typescript then uses the options to infer the flag's type.
Flags now have a relationship property that allows you to define more complex relationships between flags. Check out the flags docs for more information.
Flags now have a defaultHelp property that allows you to set the human readable default value in the command help. This property is useful when your flag's parse method returns a complex type, such as an object or a class. Check out the flags docs for more.
Commands now have a hiddenAliases property that allows you to define aliases that you want to hide from the user. The property is super helpful when you're trying to wean users off a deprecated command.
You can now use bun or tsx as dev runtimes (as opposed to node or ts-node).
A command's usage, args, and flags are now shown whenever a user forgets to provide a required arg or flag, or when they provided a non-existent flag.

If you need help migrating to the latest version, head over to core's README which has links to the migration guides. Feel free to open a new discussion if you need more hands-on help from us or the community.
ESM Support​
Version 3 of @oclif/core introduced full support for developing ESM plugins and CLIs. It also offered full support for interoperability between CommonJS and ESM plugins.
Put more simply, you can now migrate your CLI to ESM while keeping individual plugins in CommonJS (or vice versa). The upgrade path is now much simpler for you. You also don't need to worry about any community plugins that have migrated to ESM before you did (such as all the @oclif plugins) or are staunchly sticking with CommonJS for the foreseeable future.
Read more about this topic here.
Improving and Revitalizing oclif.io​
Another area of focus for us has been improving our documentation site, oclif.io.
While improving the quality and accuracy of the documentation was our priority, we also took the time to upgrade to the latest version of docusaurus. This new version gave our site a much-needed facelift, as well as cool new features such as dark mode and announcements.
If you have any feedback or are running into issues, we want to hear about it. Just create an issue in the oclif.io repo.
Re-engaging the oclif Community​
Lastly, our biggest priority at the moment is to re-engage the oclif community. We understand how frustrating it has been over the years to see your issues and pull requests go unacknowledged. We apologize for not prioritizing the community, and are earnestly trying to make sure that every issue and pull request gets the attention it deserves going forward.
We also opened up GitHub discussions for @oclif/core and the oclif CLI, where you can now post your questions or ideas. We hope you take advantage of them, we love hearing from you!
One last thing: we intend to publicly post our roadmap so you have more visibility into what we're working on. Stay tuned!
All our best,
The oclif teamAnnouncing oclif v2!January 12, 2022 · 5 min readHello and happy new year! It's our great pleasure to announce that we have released oclif v2, which uses the new @oclif/core library! 🎉
oclif v2 includes many changes that improve the experience of both creating and using an oclif CLI.
Going forward, we don't plan to make any updates to oclif v1 and its corresponding libraries, except for critical security fixes. See the compatibility matrix for a list of these libraries. In order to give developers time to migrate from v1 to v2, we're not completely dropping support yet. But at some point in the future we'll archive the v1 repositories and deprecate their versions on npm.
What’s changing?​
Repository Changes​
All repositories under the oclif org now use main as their primary branch and oclif-v1 as the legacy branch. The main  branch corresponds to oclif v2 and the oclif-v1 branch to oclif v1. If you find any repos that don’t have a main branch, you can safely assume that they're not used in oclif v2 and will be deprecated in the future.
Consolidating Tools & Libraries​
The oclif-dev CLI has now been incorporated into oclif. You now no longer need to install a separate package to manage your entire CLI’s lifecycle.
The following libraries have been consolidated under @oclif/core and will be deprecated at some point in the future. Read the migration guide to learn how to update your CLI or plugin to use the new core library.

@oclif/command
@oclif/config
@oclif/error
@oclif/help
@oclif/parser

No more single vs multi command CLIs​
There's only one "type" of oclif v2 CLI, but it can have as few or as many commands as a developer wants. As a result, there’s only one command to generate CLIs, oclif generate, as opposed to the old oclif single and oclif multi commands.
Node > 12​
To ensure oclif CLIs are as secure as possible, all v2 libraries and plugins support only Node 12 or higher as of now. Going forward, they'll support only Node Maintenance or higher, as defined by Node's release schedule here: https://nodejs.org/en/about/releases/.
What’s new?​
New example CLI​
oclif-hello-world is our new example repo. This is also the repo that's used as a template when running oclif generate to create a new CLI. This repo will always be able to be referenced as an example of what an oclif v2 CLI should look like.
Spaced commands​
oclif CLIs can now use spaces, instead of colons, to separate topics and subcommands. To enable this feature, simply add “topicSeparator": " " to the oclif config in your package.json. See an example in our example repo.
// Old commands that use :$ mycli do:something
// New spaced commands$ mycli do something

Note: Spaced commands are backwards compatible. So if you enable spaced commands for your CLI, users will still be able to use : as a separator. This ensures that any existing scripts don't break.

New Help Output​
We’ve revamped the way command help is outputted to the terminal, making it both easier to implement and easier to read. See the difference between the old help output on the left and the new help output on the right in the screenshots below.
oclif v1oclif v2
Notice that there are new sections for flags and global flags, examples are displayed with better spacing, and there is a section at the bottom called Configuration Variables. This Configuration Variables section is not part of the new help by default. But we've added support for custom help sections, which is what the sf CLI uses to create the new section.
Async Command Parsing​
We’ve also improved the performance of new CLIs by rewriting how commands are parsed on initialization. The new parser is asynchronous, which makes CLIs with a lot of commands or installed  plugins much faster.
What’s coming next?​
Part of our charter for the release of oclif v2 includes improving our engagement with the oclif community. We know that over the past couple of years we’ve reduced our involvement, and a lot of issues and PRs have languished in limbo. Hopefully you’ve already seen increased activity and responses from oclif maintainers recently, but if you haven’t, please don’t hesitate to ping us by tagging @admins in oclif repos.
We also want to start interviewing members of the oclif community to acquire feedback and prioritize the features and fixes you deem most important!
Best,
The oclif team

Reference material​
Migration Guide​
This guide explains how to upgrade a CLI or plugin from the old oclif v1 libraries to the new @oclif/core library that oclif v2 uses.
https://github.com/oclif/core/blob/main/MIGRATION.md
Compatibility Matrix​
The following matrix shows how the v1 libraries and plugins relate to the new v2 ones. Use this matrix as a guide to know what to drop and which versions to switch when upgrading your plugins and CLIs to v2.
oclif "v1"oclif "v2"Utility CLIsoclif@<2@oclif/dev-cli@<2oclif@>=2Main packages@oclif/command@oclif/config@oclif/errors@oclif/parser@oclif/plugin-help@oclif/core@>=1Node LTSNode v8-14Node v12+ (at time of writing)TypeScripttypescript@<4typescript@>=4Main plugins@oclif/plugin-autocomplete@<1@oclif/plugin-commands@<2@oclif/plugin-help@<4@oclif/plugin-not-found@<2@oclif/plugin-plugins@<2@oclif/plugin-update@<2plugin-warn-if-update-available@<2plugin-which@<2@oclif/plugin-autocomplete@>=1@oclif/plugin-commands@>=2@oclif/plugin-help@>=4@oclif/plugin-not-found@>=2@oclif/plugin-plugins@>=2@oclif/plugin-update@>=2@oclif/plugin-warn-if-update-available@>=2@oclif/plugin-which@>=2Introducing @oclif/coreMarch 1, 2021 · 3 min readGreetings!
We hope this blog post finds you well.
Introducing...​
We are excited to announce the next iteration of the oclif project today: @oclif/core.
We have learned a lot in the last three years of developing oclif, developing on oclif and supporting millions of command runs a day via Heroku and Salesforce CLIs.
@oclif/core ("Core") simplifies the oclif development experience and introduces highly requested new features.
Core combines the essential oclif packages into one "core" package, aptly named @oclif/core.
Core also introduces:

A default command option
Colon or space command syntax
Async command parsing
Command piping to arguments

With the introduction of default command functionality, Core simplifies the oclif project and removes the notion of single or multi command CLIs. Core CLIs can have 1 or many commands.
Along with Core, we moved the oclif-dev CLI into the oclif CLI creating a single "utility" CLI. This CLI also introduces a new AWS S3 compatible publishing scheme.
What to expect in the near future​
Core is in pre-release beta and being actively developed for new internal Salesforce CLIs.
Much documentation needs to be written in the coming months including migration paths. Migration onto Core should be as painless as possible with many exports remaining entirely unchanged. Look for forthcoming blog posts and documentation on oclif.io.
Early this summer, tentively June 1, we will release Core v1. Core's release will coincide with major bumps to many other oclif plugin packages. See the compatibility matrix below.
At Core's v1 release, the current "main" oclif packages (namely: command, config, errors & parser) will go into maintenance mode until Jan 2022. They will receive only bug and security fixes and they remain compatible with current versions of the oclif and oclif-dev CLIs. Afterwhich, they will be archived.
Companioning Core, the next major release of the oclif CLI (literally oclif@2) will generate Core CLIs.
Going forward​
We are excited to release Core! We invite you to poke around the Core repo. It may appear to be a big change but Core keeps what you already enjoy about oclif while reducing development complexity, project dependencies, package coupling and bundle size and introduces many requested features previously too prickly to weave into the current oclif architecture.
Best,
The oclif team
Reference: Compatibility matrix​
oclif "v1"oclif "Core"Utility CLIsoclif@<2@oclif/dev-cli@<2oclif@>=2Main packages@oclif/core@<2@oclif/config@<2@oclif/errors@<2@oclif/parser@<4@oclif/plugin-help@<4@oclif/core@>=1Node LTSNode v8-14Node v12+TypeScripttypescript@<4typescript@>=4Main plugins@oclif/plugin-autocomplete@<1@oclif/plugin-commands@<2@oclif/plugin-help@<4@oclif/plugin-not-found@<2@oclif/plugin-plugins@<2@oclif/plugin-update@<2plugin-warn-if-update-available@<2plugin-which@<2@oclif/plugin-autocomplete@>=2@oclif/plugin-commands@>=2@oclif/plugin-help@>=4@oclif/plugin-not-found@>=2@oclif/plugin-plugins@>=2@oclif/plugin-update@>=2@oclif/plugin-warn-if-update-available@>=2@oclif/plugin-which@>=2oclif Summer 2020 UpdateAugust 26, 2020 · 2 min readHello oclif developers! We hope you are all doing well.
Earlier this year, we started our planning for oclifconf v2 and, like all conference, had to change course. We opted not to hold a virtual conference, however, we wanted to take some time to highlight a few oclif features shipped this year.
Feature: Help templating​
One of the most requested features, help templating enables oclif developers to customize the help output for their CLI.
Read the announcement.
Feature: Custom error delegation​
This feature both improved how oclif throws and handles errors and allows oclif developers to overwrite or interject in oclif’s error handling.
Read the announcement.
Feature: postrun hooks​
We have added a new lifecycle event postrun. Your CLI can now run a hook after a command has ran.
See our hook documentation.
Feature: Root index command​
Previously, oclif would display CLI help if only the binary name with no command ID was invoked, oclif now supports a "root index" command. If present, a command defined at src/commands/index.ts will be run if no command ID is found.
1 million weekly downloads​
While exact oclif usage metrics are hard to pin down, we use npm download statistics of oclif packages as a rough approximation. Earlier this year, oclif's command package hit 1 million weekly downloads for the first time!
This year has been presented its challenges on everyone. We want to thank you, oclif developers, whom have taken the time to use and improve the oclif project. We look forward to seeing you all - in person - in the future!
All our best,
The oclif teamPretty Printable ErrorsJuly 1, 2020 · One min readOften CLIs are used as handy tools and when things go wrong it’s useful to have additional context. In oclif we have added a couple of additional properties that can show extra context to the users when an error is displayed. The code, ref and suggestions will now be displayed if they are included. This will work with an existing oclif CLI by adding the latest @oclif/errors and @oclif/core to the CLI's package.json dependencies.
For example, using this.error with the additional properties:
class TestError extends Command {  async run() {    this.error("An error has occurred!", {      code: "OCLIF_ERR",      ref: "https://oclif.io/docs/commands#thiserrormessage-string--error-options-code-string-exit-number",      suggestions: ["Use these extra properties to provide additional context"],    })  }}
would result with the following output:
›   Error: An error has occurred!›   Code: OCLIF_ERR›   Try this: Use these extra properties to provide additional context›   Reference: https://oclif.io/docs/commands#thiserrormessage-string--error-options-code-string-exit-number
If these properties are not provided then nothing changes and the CLI will continue to display the single error message output as it did before. Additionally, as part of this exercise we’ve added documentation around Error Handling in oclif which should come in handy if the need arises to extend oclif’s default handling of errors.Customizing Help in oclifMay 5, 2020 · 2 min readOut of the box oclif provides a great help experience for CLIs.
But what if, as an oclif developer, you want to customize some or all of the output?
You can now customize your CLI's help output by implementing the HelpBase abstract class.
Getting started with custom help​
If you have not done so yet, update @oclif/core.
$ yarn add --latest @oclif/core
To get started, first define the filepath to your help class in oclif's config in package.json. This is a relative path to the help class, without a file extension.
For this example, the help class will be created in a file at "[project root]/src/help.ts".
{  // ...  "oclif": {    "helpClass": "./lib/help"    // ...  }  // ...}
From here there are two paths, implement the HelpBase abstract class yourself or overwrite the parts of the default Help class you want to customize (ex: how command usage is displayed). We recommend the latter approach but cover both in the new Help Classes docs.
Separating TOPICS & COMMANDS in the new default Help class​
Previously, topics and child commands were listed in help output under a single list heading called "COMMANDS". But we found this can be slightly confusing. Some topics are commands also (a.k.a. topic-commands) while others are simply organizational namespacing (and when ran just show their help).
The new default Help class splits the list of children into distinct lists of "TOPICS" and "COMMANDS", with the possibility of an item appearing in both if it a topic-command. This makes it clearer what is expected to be ran - "COMMANDS" - and what is providing structure - "TOPICS" - when looking at the help output.
VERSION  plugin-help-example/0.0.0 darwin-x64 node-v12.12.0USAGE  $ plugin-help-example [COMMAND]TOPICS  topic  this is a topic and has child topics or commandsCOMMANDS  hello  describe the command here  help   display help for plugin-help-example
We look forward to seeing what custom help features you implement in your oclif CLIs with this new feature!oclif TSLint to ESLint MigrationDecember 5, 2019 · 3 min readBack in February of this year, plans were announced to deprecate TSLint in favor of ESLint. TSLint's goal has become to work toward a “unified developer experience” by supporting ESLint development going forward.
What has changed in oclif​
To keep inline with the community, oclif has transitioned to ESLint for all our core libraries as well as all our official plugins.
Starting in v1.15.x, oclif will now optionally generate projects with ESLint for both TypeScript and JavaScript CLI’s.
ESLint does require Node to be on stable LTS version, at the time of writing, Node 8.10.x, Node 10.13.x & Node 12.x.x.
How does this affect you​
Existing CLI’s are unchanged, but any newly generated CLI's will only give the option of using ESLint. If you are running tslint in your CLI, we recommend you switch to ESLint as well.
In migrating our projects we took the following steps (for an example of these changes see this pull request).


Install eslint
$ yarn add eslint eslint-config-oclif eslint-config-oclif-typescript --dev


Add eslint related files


$ echo '{  "extends": [    "oclif",    "oclif-typescript"  ],  "rules": {  }}' > .eslintrc


Remove tslint and related packages
$ yarn remove @oclif/tslint tslint


Remove tslint related configuration files
$ rm tslint.json


Change lint script in our package.json from something like:
"lint": "tsc -p test --noEmit && tslint -p test -t stylish"
to
"lint": "eslint . --ext .ts --config .eslintrc"


To preserve the test compile (tsc -p test --noEmit) we also made the following updates to our scripts:
"pretest": "tsc -p test --noEmit"
In some cases we had our posttest duplicating the same steps as our lint script so it’s cleaner to have it reference the lint job directly with:
"posttest": "yarn lint"

Run yarn lint --fix. This attempts to auto-fix any linting violations automatically. In the case an auto-fix isn’t available it should be fixed manually or ignored (see the eslint configuration doc for more information)
Do a search in the codebase for tslint and remove any unnecessary tslint disabling comments, like:

/* tslint:disable:object-literal-sort-keys */
If you are on a version of Node that is not supported by ESLint, you will also need to update your Node engine. ESLint supports Node 8, 10, and 12 so you should upgrade to the most recent Node version compatible with your CLI and also supported by ESLint (see ESLint's Installation and Usage instructions).
When will this take effect​
These changes have taken effect in oclif v1.15.1. When you generate a new CLI or plugin it will now contain configuration for ESLint instead of TSLint.oclif's Current Node SupportOctober 31, 2019 · 3 min readTo maintain a healthy project trajectory, oclif follows and supports Node Active LTS release, currently Node 10 & Node 12. This means ensuring that oclif continues to play nice with coming Active LTS Node versions and other packages in the ecosystem. Moving forward also means leaving older versions behind. Starting in 2020, Node will stop maintaining Node 8 and it is our intent at that time to also follow suit. Let’s take a look at a few ways we will be supporting these changes.
CI Environments​
CLIs created with the oclif cli going forward will be generated with a CircleCI configuration with Node 10 & 12 and an Appveyor configuration using Node 10. We have also added Node latest to CircleCi to be an early warning detection against coming Node changes (Node latest is managed by CircleCI).
We have already updated every oclif repo's CI configs to reflect this.
If your existing CLI uses either Appveyor or CircleCI you can update your config files also, like so:
.circleci/config.yml​
Your CircleCI config should contain a node-latest job, aliased as test. From this, there should be two extensions of this job for the Active LTS Node versions, Node 10 and Node 12.
  node-10:    <<: *node-latest    docker:      - image: node:10  node-12:    <<: *node-latest    docker:      - image: node:12
Notice that these declarations only change the Docker Node images used to run that job.
Additionally, the jobs listed within workflows must also be updated to reflect our changes in configuration:
    jobs:      - node-latest      - node-10      - node-12
appveyor.yml​
For appveyor we are currently only testing the oldest Active LTS Node version, Node 10. Update the nodejs_version proppert in your appveyor.yml file to reflect this.
environment:  nodejs_version: "10"
Deprecating Node 8 & Updating packge.json engines​
In Jan 2020, Node will end its Node 8 maintenance. We will follow suit by setting the package.json engine property in oclif packages to >=10 and bumping the package's major versions.
Depending on how you ship your CLI you may wish to also bump the engines version in your CLI's package.json. You can read more about the implications of the engines property configuration in the npm documentation.
Also consider distributing your CLI with its own Node version.
Packaged Node Version​
When using dev-cli to pack your CLI it will use the Node version as specified in your package.json under the oclif.update.node.version property. This value should reflect an Active LTS Node version (dev-cli does not currently enforce versions).
Supporting the future​
As a community we may discover bumps along the way as we upgrade. If you notice something related to oclif please feel free to open an issue or submit a pull request under the relevant oclif package within the org.
We look forward to using the latest from Node and the community and keeping oclif healthy along the way.oclifconf 2019: A RecapSeptember 16, 2019 · 4 min readIn May, Heroku and Salesforce Open Source organized oclifconf, a conference for developers & product managers building CLI tools on top of the open source oclif framework. The speakers came from various tech companies, such as Adobe, Netlify, and Apollo, who have already built amazing CLI experiences. The topics covered everything from the incredible capabilities oclif has unlocked, to the community-built plugins extending its functionality, and even what the behavior of an adaptive CLI tool might look like.
Below is a listing of all of the talks from the event, along with a short summary. Enjoy!
The future of oclif by Jeff Dickey​

In its relatively short lifetime, oclif has already inspired many developers and companies to adopt its framework as a means for implementing their own command-line tooling. In this talk, Jeff Dickey, an oclif founding team member, recaps the project's history and inspiration. He also looks towards the future and outlines some features and improvements that the tool could adapt. This isn't so much a definitive roadmap of where oclif is headed, but rather, a call to inspiration for developers eager to contribute! And if you are interested in contributing, check out the open issues in the oclif GitHub repo and come say "Hello!" on Spectrum Chat.
Open Source Citizenship by Josh Simmons​

When it comes to open source, it's more than just individuals now. More and more frequently, large corporations are contributing to projects by donating to contributors, sponsoring events, or upstreaming contributions. But keeping open source projects and communities healthy requires more than just money and brainpower. Josh Simmons surveyed multiple open source communities and relays his findings as to what help maintainers and contributors actually need in this talk.
Building an enterprise-grade CLI with oclif by Thomas Dvornik​

Security and performance are all about trust. While oclif is an extremely extensible framework for building CLI tooling, there are additional requirements to fulfill for enterprise businesses to adopt it that might not be necessary for individual developers. Thomas Dvornik outlines what he and his colleagues at Salesforce have implemented as plugins to oclif to satisfy these needs, including encrypted OAuth, plugin signing, lazy loading dependencies, synchronizing weekly releases and deprecations across dozens of repositories, and establishing cross-team coding and documentation standards.
How Adobe I/O built an extensible CLI with oclif by Jesse MacFadyen​

Perhaps oclif's most appealing feature is its support for plugins. In Cordova's case, they've created a sophisticated telemetry system that helps Adobe developers see which commands users are using--and reports on which ones are erroring out. By embedding a feedback system into the tool, users are even able to quickly send their suggestions to a form, without ever leaving the terminal. Jesse MacFadyen demonstrates how oclif's plugin system can work beyond simply executing commands.
Integrating oclif with GraphQL and Apollo by Evans Hauser​

For Evans Hauser and the team at Apollo, oclif is best thought of as "React for the CLI." As a client paired with a strongly-typed API contract to a server, it can deliver structured and consistent commands to retrieve external data. What better mechanism to use for this transfer than GraphQL, a framework which empowers the client to ask precisely for the data it needs, and nothing more?
Adaptive Intent-based CLI State Machines by Shawn Wang​

In designing oclif, Jeff Dickey wrote out 12 CLI factors to keep in mind. In this talk, Shawn Wang outlines a 13th: state. State is hard, because it depends on context, and context depends on understanding what a user intends to do, not what they are asking. Shawn is working towards enabling oclif to better understand the commands a user has entered, so that it can predict and interpret future commands that might be entered next. This would enable CLI tools to not just interpret a users' commands, but to also interpret their intent.Older Entries\n\n\n\nIntroducing `oclif init` commandApril 10, 2024 · 2 min readThanks to the contribution of @joshcanhelp we released a new command for the oclif CLI called oclif init in version 4.8.0
The oclif init command allows you to initialize oclif in an existing project directory by adding the bare minimum requirements: a few pieces of configuration, bin scripts, and a couple of dependencies (@oclif/core and ts-node). This is slightly different from oclif generate, which will create an entirely new oclif project based on our templates.
oclif init will add the following:

bin scripts: bin/run.js, bin/run.cmd, bin/dev.js, and bin/dev.cmd
oclif section to package.json with bin, dirname, commands, and topicSeparator set (See Configuring Your CLI for more)
@oclif/core to dependencies in your package.json (if it's not already there)
ts-node to devDependencies in your package.json (if it's not already there)

Once you've initialized oclif, you can use the bin scripts to execute your CLI. You can also use the other oclif commands like oclif generate command and oclif generate hook to start adding new functionality.

❯ oclif init --helpInitialize a new oclif CLIUSAGE  $ oclif init [--bin <value>] [--module-type ESM|CommonJS] [--package-manager npm|yarn|pnpm] [--topic-separator    colons|spaces] [-d <value>] [-y]FLAGS  -d, --output-dir=<value>        Directory to initialize the CLI in.  -y, --yes                       Use defaults for all prompts. Individual flags will override defaults.      --bin=<value>               Supply answer for prompt: Command bin name the CLI will export      --module-type=<option>      Supply answer for prompt: Select a module type                                  <options: ESM|CommonJS>      --package-manager=<option>  Supply answer for prompt: Select a package manager                                  <options: npm|yarn|pnpm>      --topic-separator=<option>  Supply answer for prompt: Select a topic separator                                  <options: colons|spaces>DESCRIPTION  Initialize a new oclif CLI  This will add the necessary oclif bin files, add oclif config to package.json, and install @oclif/core and ts-node.EXAMPLES  Initialize a new CLI in the current directory    $ oclif init  Initialize a new CLI in a different directory    $ oclif init --output-dir "/path/to/existing/project"  Supply answers for specific prompts    $ oclif init --topic-separator colons --bin mycli
Hope you enjoy the new command! If you come across any issues or have any new ideas for this command, head over to the oclif/oclif repo and open a new issue.
All our best,
The oclif teamoclif Spring 2024 UpdateMarch 29, 2024 · 4 min readHello oclif developers! It's been a while since we last uploaded a blog - and a lot has happened.
We've been focusing on these high-level areas over the past couple of years:

Improving @oclif/core
ESM Support
Improving and revitalizing oclif.io
Re-engaging the oclif community

Improving @oclif/core​
Since we announced @oclif/core over three years ago, we've released two new major versions, each packed with lots of features that we're really excited about.
Here are some of these changes:

Full support for ESM and interoperability with CommonJS (more on this topic below).
Configurable command discovery strategies that give you more control over how commands are loaded at runtime. Check out the docs.
A new preparse hook that allows you to manipulate the provided arguments before they're parsed. Salesforce used this hook to implement a neat --flags-dir feature that translates local files into flags.
A new Performance class that you can use to track performance inside of @oclif/core and your own CLI or plugin. Check out the docs.
A new flag type, Flags.option, that lets you define a flag with a preset list of options. Typescript then uses the options to infer the flag's type.
Flags now have a relationship property that allows you to define more complex relationships between flags. Check out the flags docs for more information.
Flags now have a defaultHelp property that allows you to set the human readable default value in the command help. This property is useful when your flag's parse method returns a complex type, such as an object or a class. Check out the flags docs for more.
Commands now have a hiddenAliases property that allows you to define aliases that you want to hide from the user. The property is super helpful when you're trying to wean users off a deprecated command.
You can now use bun or tsx as dev runtimes (as opposed to node or ts-node).
A command's usage, args, and flags are now shown whenever a user forgets to provide a required arg or flag, or when they provided a non-existent flag.

If you need help migrating to the latest version, head over to core's README which has links to the migration guides. Feel free to open a new discussion if you need more hands-on help from us or the community.
ESM Support​
Version 3 of @oclif/core introduced full support for developing ESM plugins and CLIs. It also offered full support for interoperability between CommonJS and ESM plugins.
Put more simply, you can now migrate your CLI to ESM while keeping individual plugins in CommonJS (or vice versa). The upgrade path is now much simpler for you. You also don't need to worry about any community plugins that have migrated to ESM before you did (such as all the @oclif plugins) or are staunchly sticking with CommonJS for the foreseeable future.
Read more about this topic here.
Improving and Revitalizing oclif.io​
Another area of focus for us has been improving our documentation site, oclif.io.
While improving the quality and accuracy of the documentation was our priority, we also took the time to upgrade to the latest version of docusaurus. This new version gave our site a much-needed facelift, as well as cool new features such as dark mode and announcements.
If you have any feedback or are running into issues, we want to hear about it. Just create an issue in the oclif.io repo.
Re-engaging the oclif Community​
Lastly, our biggest priority at the moment is to re-engage the oclif community. We understand how frustrating it has been over the years to see your issues and pull requests go unacknowledged. We apologize for not prioritizing the community, and are earnestly trying to make sure that every issue and pull request gets the attention it deserves going forward.
We also opened up GitHub discussions for @oclif/core and the oclif CLI, where you can now post your questions or ideas. We hope you take advantage of them, we love hearing from you!
One last thing: we intend to publicly post our roadmap so you have more visibility into what we're working on. Stay tuned!
All our best,
The oclif teamAnnouncing oclif v2!January 12, 2022 · 5 min readHello and happy new year! It's our great pleasure to announce that we have released oclif v2, which uses the new @oclif/core library! 🎉
oclif v2 includes many changes that improve the experience of both creating and using an oclif CLI.
Going forward, we don't plan to make any updates to oclif v1 and its corresponding libraries, except for critical security fixes. See the compatibility matrix for a list of these libraries. In order to give developers time to migrate from v1 to v2, we're not completely dropping support yet. But at some point in the future we'll archive the v1 repositories and deprecate their versions on npm.
What’s changing?​
Repository Changes​
All repositories under the oclif org now use main as their primary branch and oclif-v1 as the legacy branch. The main  branch corresponds to oclif v2 and the oclif-v1 branch to oclif v1. If you find any repos that don’t have a main branch, you can safely assume that they're not used in oclif v2 and will be deprecated in the future.
Consolidating Tools & Libraries​
The oclif-dev CLI has now been incorporated into oclif. You now no longer need to install a separate package to manage your entire CLI’s lifecycle.
The following libraries have been consolidated under @oclif/core and will be deprecated at some point in the future. Read the migration guide to learn how to update your CLI or plugin to use the new core library.

@oclif/command
@oclif/config
@oclif/error
@oclif/help
@oclif/parser

No more single vs multi command CLIs​
There's only one "type" of oclif v2 CLI, but it can have as few or as many commands as a developer wants. As a result, there’s only one command to generate CLIs, oclif generate, as opposed to the old oclif single and oclif multi commands.
Node > 12​
To ensure oclif CLIs are as secure as possible, all v2 libraries and plugins support only Node 12 or higher as of now. Going forward, they'll support only Node Maintenance or higher, as defined by Node's release schedule here: https://nodejs.org/en/about/releases/.
What’s new?​
New example CLI​
oclif-hello-world is our new example repo. This is also the repo that's used as a template when running oclif generate to create a new CLI. This repo will always be able to be referenced as an example of what an oclif v2 CLI should look like.
Spaced commands​
oclif CLIs can now use spaces, instead of colons, to separate topics and subcommands. To enable this feature, simply add “topicSeparator": " " to the oclif config in your package.json. See an example in our example repo.
// Old commands that use :$ mycli do:something
// New spaced commands$ mycli do something

Note: Spaced commands are backwards compatible. So if you enable spaced commands for your CLI, users will still be able to use : as a separator. This ensures that any existing scripts don't break.

New Help Output​
We’ve revamped the way command help is outputted to the terminal, making it both easier to implement and easier to read. See the difference between the old help output on the left and the new help output on the right in the screenshots below.
oclif v1oclif v2
Notice that there are new sections for flags and global flags, examples are displayed with better spacing, and there is a section at the bottom called Configuration Variables. This Configuration Variables section is not part of the new help by default. But we've added support for custom help sections, which is what the sf CLI uses to create the new section.
Async Command Parsing​
We’ve also improved the performance of new CLIs by rewriting how commands are parsed on initialization. The new parser is asynchronous, which makes CLIs with a lot of commands or installed  plugins much faster.
What’s coming next?​
Part of our charter for the release of oclif v2 includes improving our engagement with the oclif community. We know that over the past couple of years we’ve reduced our involvement, and a lot of issues and PRs have languished in limbo. Hopefully you’ve already seen increased activity and responses from oclif maintainers recently, but if you haven’t, please don’t hesitate to ping us by tagging @admins in oclif repos.
We also want to start interviewing members of the oclif community to acquire feedback and prioritize the features and fixes you deem most important!
Best,
The oclif team

Reference material​
Migration Guide​
This guide explains how to upgrade a CLI or plugin from the old oclif v1 libraries to the new @oclif/core library that oclif v2 uses.
https://github.com/oclif/core/blob/main/MIGRATION.md
Compatibility Matrix​
The following matrix shows how the v1 libraries and plugins relate to the new v2 ones. Use this matrix as a guide to know what to drop and which versions to switch when upgrading your plugins and CLIs to v2.
oclif "v1"oclif "v2"Utility CLIsoclif@<2@oclif/dev-cli@<2oclif@>=2Main packages@oclif/command@oclif/config@oclif/errors@oclif/parser@oclif/plugin-help@oclif/core@>=1Node LTSNode v8-14Node v12+ (at time of writing)TypeScripttypescript@<4typescript@>=4Main plugins@oclif/plugin-autocomplete@<1@oclif/plugin-commands@<2@oclif/plugin-help@<4@oclif/plugin-not-found@<2@oclif/plugin-plugins@<2@oclif/plugin-update@<2plugin-warn-if-update-available@<2plugin-which@<2@oclif/plugin-autocomplete@>=1@oclif/plugin-commands@>=2@oclif/plugin-help@>=4@oclif/plugin-not-found@>=2@oclif/plugin-plugins@>=2@oclif/plugin-update@>=2@oclif/plugin-warn-if-update-available@>=2@oclif/plugin-which@>=2Introducing @oclif/coreMarch 1, 2021 · 3 min readGreetings!
We hope this blog post finds you well.
Introducing...​
We are excited to announce the next iteration of the oclif project today: @oclif/core.
We have learned a lot in the last three years of developing oclif, developing on oclif and supporting millions of command runs a day via Heroku and Salesforce CLIs.
@oclif/core ("Core") simplifies the oclif development experience and introduces highly requested new features.
Core combines the essential oclif packages into one "core" package, aptly named @oclif/core.
Core also introduces:

A default command option
Colon or space command syntax
Async command parsing
Command piping to arguments

With the introduction of default command functionality, Core simplifies the oclif project and removes the notion of single or multi command CLIs. Core CLIs can have 1 or many commands.
Along with Core, we moved the oclif-dev CLI into the oclif CLI creating a single "utility" CLI. This CLI also introduces a new AWS S3 compatible publishing scheme.
What to expect in the near future​
Core is in pre-release beta and being actively developed for new internal Salesforce CLIs.
Much documentation needs to be written in the coming months including migration paths. Migration onto Core should be as painless as possible with many exports remaining entirely unchanged. Look for forthcoming blog posts and documentation on oclif.io.
Early this summer, tentively June 1, we will release Core v1. Core's release will coincide with major bumps to many other oclif plugin packages. See the compatibility matrix below.
At Core's v1 release, the current "main" oclif packages (namely: command, config, errors & parser) will go into maintenance mode until Jan 2022. They will receive only bug and security fixes and they remain compatible with current versions of the oclif and oclif-dev CLIs. Afterwhich, they will be archived.
Companioning Core, the next major release of the oclif CLI (literally oclif@2) will generate Core CLIs.
Going forward​
We are excited to release Core! We invite you to poke around the Core repo. It may appear to be a big change but Core keeps what you already enjoy about oclif while reducing development complexity, project dependencies, package coupling and bundle size and introduces many requested features previously too prickly to weave into the current oclif architecture.
Best,
The oclif team
Reference: Compatibility matrix​
oclif "v1"oclif "Core"Utility CLIsoclif@<2@oclif/dev-cli@<2oclif@>=2Main packages@oclif/core@<2@oclif/config@<2@oclif/errors@<2@oclif/parser@<4@oclif/plugin-help@<4@oclif/core@>=1Node LTSNode v8-14Node v12+TypeScripttypescript@<4typescript@>=4Main plugins@oclif/plugin-autocomplete@<1@oclif/plugin-commands@<2@oclif/plugin-help@<4@oclif/plugin-not-found@<2@oclif/plugin-plugins@<2@oclif/plugin-update@<2plugin-warn-if-update-available@<2plugin-which@<2@oclif/plugin-autocomplete@>=2@oclif/plugin-commands@>=2@oclif/plugin-help@>=4@oclif/plugin-not-found@>=2@oclif/plugin-plugins@>=2@oclif/plugin-update@>=2@oclif/plugin-warn-if-update-available@>=2@oclif/plugin-which@>=2oclif Summer 2020 UpdateAugust 26, 2020 · 2 min readHello oclif developers! We hope you are all doing well.
Earlier this year, we started our planning for oclifconf v2 and, like all conference, had to change course. We opted not to hold a virtual conference, however, we wanted to take some time to highlight a few oclif features shipped this year.
Feature: Help templating​
One of the most requested features, help templating enables oclif developers to customize the help output for their CLI.
Read the announcement.
Feature: Custom error delegation​
This feature both improved how oclif throws and handles errors and allows oclif developers to overwrite or interject in oclif’s error handling.
Read the announcement.
Feature: postrun hooks​
We have added a new lifecycle event postrun. Your CLI can now run a hook after a command has ran.
See our hook documentation.
Feature: Root index command​
Previously, oclif would display CLI help if only the binary name with no command ID was invoked, oclif now supports a "root index" command. If present, a command defined at src/commands/index.ts will be run if no command ID is found.
1 million weekly downloads​
While exact oclif usage metrics are hard to pin down, we use npm download statistics of oclif packages as a rough approximation. Earlier this year, oclif's command package hit 1 million weekly downloads for the first time!
This year has been presented its challenges on everyone. We want to thank you, oclif developers, whom have taken the time to use and improve the oclif project. We look forward to seeing you all - in person - in the future!
All our best,
The oclif teamPretty Printable ErrorsJuly 1, 2020 · One min readOften CLIs are used as handy tools and when things go wrong it’s useful to have additional context. In oclif we have added a couple of additional properties that can show extra context to the users when an error is displayed. The code, ref and suggestions will now be displayed if they are included. This will work with an existing oclif CLI by adding the latest @oclif/errors and @oclif/core to the CLI's package.json dependencies.
For example, using this.error with the additional properties:
class TestError extends Command {  async run() {    this.error("An error has occurred!", {      code: "OCLIF_ERR",      ref: "https://oclif.io/docs/commands#thiserrormessage-string--error-options-code-string-exit-number",      suggestions: ["Use these extra properties to provide additional context"],    })  }}
would result with the following output:
›   Error: An error has occurred!›   Code: OCLIF_ERR›   Try this: Use these extra properties to provide additional context›   Reference: https://oclif.io/docs/commands#thiserrormessage-string--error-options-code-string-exit-number
If these properties are not provided then nothing changes and the CLI will continue to display the single error message output as it did before. Additionally, as part of this exercise we’ve added documentation around Error Handling in oclif which should come in handy if the need arises to extend oclif’s default handling of errors.Customizing Help in oclifMay 5, 2020 · 2 min readOut of the box oclif provides a great help experience for CLIs.
But what if, as an oclif developer, you want to customize some or all of the output?
You can now customize your CLI's help output by implementing the HelpBase abstract class.
Getting started with custom help​
If you have not done so yet, update @oclif/core.
$ yarn add --latest @oclif/core
To get started, first define the filepath to your help class in oclif's config in package.json. This is a relative path to the help class, without a file extension.
For this example, the help class will be created in a file at "[project root]/src/help.ts".
{  // ...  "oclif": {    "helpClass": "./lib/help"    // ...  }  // ...}
From here there are two paths, implement the HelpBase abstract class yourself or overwrite the parts of the default Help class you want to customize (ex: how command usage is displayed). We recommend the latter approach but cover both in the new Help Classes docs.
Separating TOPICS & COMMANDS in the new default Help class​
Previously, topics and child commands were listed in help output under a single list heading called "COMMANDS". But we found this can be slightly confusing. Some topics are commands also (a.k.a. topic-commands) while others are simply organizational namespacing (and when ran just show their help).
The new default Help class splits the list of children into distinct lists of "TOPICS" and "COMMANDS", with the possibility of an item appearing in both if it a topic-command. This makes it clearer what is expected to be ran - "COMMANDS" - and what is providing structure - "TOPICS" - when looking at the help output.
VERSION  plugin-help-example/0.0.0 darwin-x64 node-v12.12.0USAGE  $ plugin-help-example [COMMAND]TOPICS  topic  this is a topic and has child topics or commandsCOMMANDS  hello  describe the command here  help   display help for plugin-help-example
We look forward to seeing what custom help features you implement in your oclif CLIs with this new feature!oclif TSLint to ESLint MigrationDecember 5, 2019 · 3 min readBack in February of this year, plans were announced to deprecate TSLint in favor of ESLint. TSLint's goal has become to work toward a “unified developer experience” by supporting ESLint development going forward.
What has changed in oclif​
To keep inline with the community, oclif has transitioned to ESLint for all our core libraries as well as all our official plugins.
Starting in v1.15.x, oclif will now optionally generate projects with ESLint for both TypeScript and JavaScript CLI’s.
ESLint does require Node to be on stable LTS version, at the time of writing, Node 8.10.x, Node 10.13.x & Node 12.x.x.
How does this affect you​
Existing CLI’s are unchanged, but any newly generated CLI's will only give the option of using ESLint. If you are running tslint in your CLI, we recommend you switch to ESLint as well.
In migrating our projects we took the following steps (for an example of these changes see this pull request).


Install eslint
$ yarn add eslint eslint-config-oclif eslint-config-oclif-typescript --dev


Add eslint related files


$ echo '{  "extends": [    "oclif",    "oclif-typescript"  ],  "rules": {  }}' > .eslintrc


Remove tslint and related packages
$ yarn remove @oclif/tslint tslint


Remove tslint related configuration files
$ rm tslint.json


Change lint script in our package.json from something like:
"lint": "tsc -p test --noEmit && tslint -p test -t stylish"
to
"lint": "eslint . --ext .ts --config .eslintrc"


To preserve the test compile (tsc -p test --noEmit) we also made the following updates to our scripts:
"pretest": "tsc -p test --noEmit"
In some cases we had our posttest duplicating the same steps as our lint script so it’s cleaner to have it reference the lint job directly with:
"posttest": "yarn lint"

Run yarn lint --fix. This attempts to auto-fix any linting violations automatically. In the case an auto-fix isn’t available it should be fixed manually or ignored (see the eslint configuration doc for more information)
Do a search in the codebase for tslint and remove any unnecessary tslint disabling comments, like:

/* tslint:disable:object-literal-sort-keys */
If you are on a version of Node that is not supported by ESLint, you will also need to update your Node engine. ESLint supports Node 8, 10, and 12 so you should upgrade to the most recent Node version compatible with your CLI and also supported by ESLint (see ESLint's Installation and Usage instructions).
When will this take effect​
These changes have taken effect in oclif v1.15.1. When you generate a new CLI or plugin it will now contain configuration for ESLint instead of TSLint.oclif's Current Node SupportOctober 31, 2019 · 3 min readTo maintain a healthy project trajectory, oclif follows and supports Node Active LTS release, currently Node 10 & Node 12. This means ensuring that oclif continues to play nice with coming Active LTS Node versions and other packages in the ecosystem. Moving forward also means leaving older versions behind. Starting in 2020, Node will stop maintaining Node 8 and it is our intent at that time to also follow suit. Let’s take a look at a few ways we will be supporting these changes.
CI Environments​
CLIs created with the oclif cli going forward will be generated with a CircleCI configuration with Node 10 & 12 and an Appveyor configuration using Node 10. We have also added Node latest to CircleCi to be an early warning detection against coming Node changes (Node latest is managed by CircleCI).
We have already updated every oclif repo's CI configs to reflect this.
If your existing CLI uses either Appveyor or CircleCI you can update your config files also, like so:
.circleci/config.yml​
Your CircleCI config should contain a node-latest job, aliased as test. From this, there should be two extensions of this job for the Active LTS Node versions, Node 10 and Node 12.
  node-10:    <<: *node-latest    docker:      - image: node:10  node-12:    <<: *node-latest    docker:      - image: node:12
Notice that these declarations only change the Docker Node images used to run that job.
Additionally, the jobs listed within workflows must also be updated to reflect our changes in configuration:
    jobs:      - node-latest      - node-10      - node-12
appveyor.yml​
For appveyor we are currently only testing the oldest Active LTS Node version, Node 10. Update the nodejs_version proppert in your appveyor.yml file to reflect this.
environment:  nodejs_version: "10"
Deprecating Node 8 & Updating packge.json engines​
In Jan 2020, Node will end its Node 8 maintenance. We will follow suit by setting the package.json engine property in oclif packages to >=10 and bumping the package's major versions.
Depending on how you ship your CLI you may wish to also bump the engines version in your CLI's package.json. You can read more about the implications of the engines property configuration in the npm documentation.
Also consider distributing your CLI with its own Node version.
Packaged Node Version​
When using dev-cli to pack your CLI it will use the Node version as specified in your package.json under the oclif.update.node.version property. This value should reflect an Active LTS Node version (dev-cli does not currently enforce versions).
Supporting the future​
As a community we may discover bumps along the way as we upgrade. If you notice something related to oclif please feel free to open an issue or submit a pull request under the relevant oclif package within the org.
We look forward to using the latest from Node and the community and keeping oclif healthy along the way.oclifconf 2019: A RecapSeptember 16, 2019 · 4 min readIn May, Heroku and Salesforce Open Source organized oclifconf, a conference for developers & product managers building CLI tools on top of the open source oclif framework. The speakers came from various tech companies, such as Adobe, Netlify, and Apollo, who have already built amazing CLI experiences. The topics covered everything from the incredible capabilities oclif has unlocked, to the community-built plugins extending its functionality, and even what the behavior of an adaptive CLI tool might look like.
Below is a listing of all of the talks from the event, along with a short summary. Enjoy!
The future of oclif by Jeff Dickey​

In its relatively short lifetime, oclif has already inspired many developers and companies to adopt its framework as a means for implementing their own command-line tooling. In this talk, Jeff Dickey, an oclif founding team member, recaps the project's history and inspiration. He also looks towards the future and outlines some features and improvements that the tool could adapt. This isn't so much a definitive roadmap of where oclif is headed, but rather, a call to inspiration for developers eager to contribute! And if you are interested in contributing, check out the open issues in the oclif GitHub repo and come say "Hello!" on Spectrum Chat.
Open Source Citizenship by Josh Simmons​

When it comes to open source, it's more than just individuals now. More and more frequently, large corporations are contributing to projects by donating to contributors, sponsoring events, or upstreaming contributions. But keeping open source projects and communities healthy requires more than just money and brainpower. Josh Simmons surveyed multiple open source communities and relays his findings as to what help maintainers and contributors actually need in this talk.
Building an enterprise-grade CLI with oclif by Thomas Dvornik​

Security and performance are all about trust. While oclif is an extremely extensible framework for building CLI tooling, there are additional requirements to fulfill for enterprise businesses to adopt it that might not be necessary for individual developers. Thomas Dvornik outlines what he and his colleagues at Salesforce have implemented as plugins to oclif to satisfy these needs, including encrypted OAuth, plugin signing, lazy loading dependencies, synchronizing weekly releases and deprecations across dozens of repositories, and establishing cross-team coding and documentation standards.
How Adobe I/O built an extensible CLI with oclif by Jesse MacFadyen​

Perhaps oclif's most appealing feature is its support for plugins. In Cordova's case, they've created a sophisticated telemetry system that helps Adobe developers see which commands users are using--and reports on which ones are erroring out. By embedding a feedback system into the tool, users are even able to quickly send their suggestions to a form, without ever leaving the terminal. Jesse MacFadyen demonstrates how oclif's plugin system can work beyond simply executing commands.
Integrating oclif with GraphQL and Apollo by Evans Hauser​

For Evans Hauser and the team at Apollo, oclif is best thought of as "React for the CLI." As a client paired with a strongly-typed API contract to a server, it can deliver structured and consistent commands to retrieve external data. What better mechanism to use for this transfer than GraphQL, a framework which empowers the client to ask precisely for the data it needs, and nothing more?
Adaptive Intent-based CLI State Machines by Shawn Wang​

In designing oclif, Jeff Dickey wrote out 12 CLI factors to keep in mind. In this talk, Shawn Wang outlines a 13th: state. State is hard, because it depends on context, and context depends on understanding what a user intends to do, not what they are asking. Shawn is working towards enabling oclif to better understand the commands a user has entered, so that it can predict and interpret future commands that might be entered next. This would enable CLI tools to not just interpret a users' commands, but to also interpret their intent.\n\nIntroducing `oclif init` commandApril 10, 2024 · 2 min readThanks to the contribution of @joshcanhelp we released a new command for the oclif CLI called oclif init in version 4.8.0
The oclif init command allows you to initialize oclif in an existing project directory by adding the bare minimum requirements: a few pieces of configuration, bin scripts, and a couple of dependencies (@oclif/core and ts-node). This is slightly different from oclif generate, which will create an entirely new oclif project based on our templates.
oclif init will add the following:

bin scripts: bin/run.js, bin/run.cmd, bin/dev.js, and bin/dev.cmd
oclif section to package.json with bin, dirname, commands, and topicSeparator set (See Configuring Your CLI for more)
@oclif/core to dependencies in your package.json (if it's not already there)
ts-node to devDependencies in your package.json (if it's not already there)

Once you've initialized oclif, you can use the bin scripts to execute your CLI. You can also use the other oclif commands like oclif generate command and oclif generate hook to start adding new functionality.

❯ oclif init --helpInitialize a new oclif CLIUSAGE  $ oclif init [--bin <value>] [--module-type ESM|CommonJS] [--package-manager npm|yarn|pnpm] [--topic-separator    colons|spaces] [-d <value>] [-y]FLAGS  -d, --output-dir=<value>        Directory to initialize the CLI in.  -y, --yes                       Use defaults for all prompts. Individual flags will override defaults.      --bin=<value>               Supply answer for prompt: Command bin name the CLI will export      --module-type=<option>      Supply answer for prompt: Select a module type                                  <options: ESM|CommonJS>      --package-manager=<option>  Supply answer for prompt: Select a package manager                                  <options: npm|yarn|pnpm>      --topic-separator=<option>  Supply answer for prompt: Select a topic separator                                  <options: colons|spaces>DESCRIPTION  Initialize a new oclif CLI  This will add the necessary oclif bin files, add oclif config to package.json, and install @oclif/core and ts-node.EXAMPLES  Initialize a new CLI in the current directory    $ oclif init  Initialize a new CLI in a different directory    $ oclif init --output-dir "/path/to/existing/project"  Supply answers for specific prompts    $ oclif init --topic-separator colons --bin mycli
Hope you enjoy the new command! If you come across any issues or have any new ideas for this command, head over to the oclif/oclif repo and open a new issue.
All our best,
The oclif teamoclif Spring 2024 UpdateMarch 29, 2024 · 4 min readHello oclif developers! It's been a while since we last uploaded a blog - and a lot has happened.
We've been focusing on these high-level areas over the past couple of years:

Improving @oclif/core
ESM Support
Improving and revitalizing oclif.io
Re-engaging the oclif community

Improving @oclif/core​
Since we announced @oclif/core over three years ago, we've released two new major versions, each packed with lots of features that we're really excited about.
Here are some of these changes:

Full support for ESM and interoperability with CommonJS (more on this topic below).
Configurable command discovery strategies that give you more control over how commands are loaded at runtime. Check out the docs.
A new preparse hook that allows you to manipulate the provided arguments before they're parsed. Salesforce used this hook to implement a neat --flags-dir feature that translates local files into flags.
A new Performance class that you can use to track performance inside of @oclif/core and your own CLI or plugin. Check out the docs.
A new flag type, Flags.option, that lets you define a flag with a preset list of options. Typescript then uses the options to infer the flag's type.
Flags now have a relationship property that allows you to define more complex relationships between flags. Check out the flags docs for more information.
Flags now have a defaultHelp property that allows you to set the human readable default value in the command help. This property is useful when your flag's parse method returns a complex type, such as an object or a class. Check out the flags docs for more.
Commands now have a hiddenAliases property that allows you to define aliases that you want to hide from the user. The property is super helpful when you're trying to wean users off a deprecated command.
You can now use bun or tsx as dev runtimes (as opposed to node or ts-node).
A command's usage, args, and flags are now shown whenever a user forgets to provide a required arg or flag, or when they provided a non-existent flag.

If you need help migrating to the latest version, head over to core's README which has links to the migration guides. Feel free to open a new discussion if you need more hands-on help from us or the community.
ESM Support​
Version 3 of @oclif/core introduced full support for developing ESM plugins and CLIs. It also offered full support for interoperability between CommonJS and ESM plugins.
Put more simply, you can now migrate your CLI to ESM while keeping individual plugins in CommonJS (or vice versa). The upgrade path is now much simpler for you. You also don't need to worry about any community plugins that have migrated to ESM before you did (such as all the @oclif plugins) or are staunchly sticking with CommonJS for the foreseeable future.
Read more about this topic here.
Improving and Revitalizing oclif.io​
Another area of focus for us has been improving our documentation site, oclif.io.
While improving the quality and accuracy of the documentation was our priority, we also took the time to upgrade to the latest version of docusaurus. This new version gave our site a much-needed facelift, as well as cool new features such as dark mode and announcements.
If you have any feedback or are running into issues, we want to hear about it. Just create an issue in the oclif.io repo.
Re-engaging the oclif Community​
Lastly, our biggest priority at the moment is to re-engage the oclif community. We understand how frustrating it has been over the years to see your issues and pull requests go unacknowledged. We apologize for not prioritizing the community, and are earnestly trying to make sure that every issue and pull request gets the attention it deserves going forward.
We also opened up GitHub discussions for @oclif/core and the oclif CLI, where you can now post your questions or ideas. We hope you take advantage of them, we love hearing from you!
One last thing: we intend to publicly post our roadmap so you have more visibility into what we're working on. Stay tuned!
All our best,
The oclif teamAnnouncing oclif v2!January 12, 2022 · 5 min readHello and happy new year! It's our great pleasure to announce that we have released oclif v2, which uses the new @oclif/core library! 🎉
oclif v2 includes many changes that improve the experience of both creating and using an oclif CLI.
Going forward, we don't plan to make any updates to oclif v1 and its corresponding libraries, except for critical security fixes. See the compatibility matrix for a list of these libraries. In order to give developers time to migrate from v1 to v2, we're not completely dropping support yet. But at some point in the future we'll archive the v1 repositories and deprecate their versions on npm.
What’s changing?​
Repository Changes​
All repositories under the oclif org now use main as their primary branch and oclif-v1 as the legacy branch. The main  branch corresponds to oclif v2 and the oclif-v1 branch to oclif v1. If you find any repos that don’t have a main branch, you can safely assume that they're not used in oclif v2 and will be deprecated in the future.
Consolidating Tools & Libraries​
The oclif-dev CLI has now been incorporated into oclif. You now no longer need to install a separate package to manage your entire CLI’s lifecycle.
The following libraries have been consolidated under @oclif/core and will be deprecated at some point in the future. Read the migration guide to learn how to update your CLI or plugin to use the new core library.

@oclif/command
@oclif/config
@oclif/error
@oclif/help
@oclif/parser

No more single vs multi command CLIs​
There's only one "type" of oclif v2 CLI, but it can have as few or as many commands as a developer wants. As a result, there’s only one command to generate CLIs, oclif generate, as opposed to the old oclif single and oclif multi commands.
Node > 12​
To ensure oclif CLIs are as secure as possible, all v2 libraries and plugins support only Node 12 or higher as of now. Going forward, they'll support only Node Maintenance or higher, as defined by Node's release schedule here: https://nodejs.org/en/about/releases/.
What’s new?​
New example CLI​
oclif-hello-world is our new example repo. This is also the repo that's used as a template when running oclif generate to create a new CLI. This repo will always be able to be referenced as an example of what an oclif v2 CLI should look like.
Spaced commands​
oclif CLIs can now use spaces, instead of colons, to separate topics and subcommands. To enable this feature, simply add “topicSeparator": " " to the oclif config in your package.json. See an example in our example repo.
// Old commands that use :$ mycli do:something
// New spaced commands$ mycli do something

Note: Spaced commands are backwards compatible. So if you enable spaced commands for your CLI, users will still be able to use : as a separator. This ensures that any existing scripts don't break.

New Help Output​
We’ve revamped the way command help is outputted to the terminal, making it both easier to implement and easier to read. See the difference between the old help output on the left and the new help output on the right in the screenshots below.
oclif v1oclif v2
Notice that there are new sections for flags and global flags, examples are displayed with better spacing, and there is a section at the bottom called Configuration Variables. This Configuration Variables section is not part of the new help by default. But we've added support for custom help sections, which is what the sf CLI uses to create the new section.
Async Command Parsing​
We’ve also improved the performance of new CLIs by rewriting how commands are parsed on initialization. The new parser is asynchronous, which makes CLIs with a lot of commands or installed  plugins much faster.
What’s coming next?​
Part of our charter for the release of oclif v2 includes improving our engagement with the oclif community. We know that over the past couple of years we’ve reduced our involvement, and a lot of issues and PRs have languished in limbo. Hopefully you’ve already seen increased activity and responses from oclif maintainers recently, but if you haven’t, please don’t hesitate to ping us by tagging @admins in oclif repos.
We also want to start interviewing members of the oclif community to acquire feedback and prioritize the features and fixes you deem most important!
Best,
The oclif team

Reference material​
Migration Guide​
This guide explains how to upgrade a CLI or plugin from the old oclif v1 libraries to the new @oclif/core library that oclif v2 uses.
https://github.com/oclif/core/blob/main/MIGRATION.md
Compatibility Matrix​
The following matrix shows how the v1 libraries and plugins relate to the new v2 ones. Use this matrix as a guide to know what to drop and which versions to switch when upgrading your plugins and CLIs to v2.
oclif "v1"oclif "v2"Utility CLIsoclif@<2@oclif/dev-cli@<2oclif@>=2Main packages@oclif/command@oclif/config@oclif/errors@oclif/parser@oclif/plugin-help@oclif/core@>=1Node LTSNode v8-14Node v12+ (at time of writing)TypeScripttypescript@<4typescript@>=4Main plugins@oclif/plugin-autocomplete@<1@oclif/plugin-commands@<2@oclif/plugin-help@<4@oclif/plugin-not-found@<2@oclif/plugin-plugins@<2@oclif/plugin-update@<2plugin-warn-if-update-available@<2plugin-which@<2@oclif/plugin-autocomplete@>=1@oclif/plugin-commands@>=2@oclif/plugin-help@>=4@oclif/plugin-not-found@>=2@oclif/plugin-plugins@>=2@oclif/plugin-update@>=2@oclif/plugin-warn-if-update-available@>=2@oclif/plugin-which@>=2Introducing @oclif/coreMarch 1, 2021 · 3 min readGreetings!
We hope this blog post finds you well.
Introducing...​
We are excited to announce the next iteration of the oclif project today: @oclif/core.
We have learned a lot in the last three years of developing oclif, developing on oclif and supporting millions of command runs a day via Heroku and Salesforce CLIs.
@oclif/core ("Core") simplifies the oclif development experience and introduces highly requested new features.
Core combines the essential oclif packages into one "core" package, aptly named @oclif/core.
Core also introduces:

A default command option
Colon or space command syntax
Async command parsing
Command piping to arguments

With the introduction of default command functionality, Core simplifies the oclif project and removes the notion of single or multi command CLIs. Core CLIs can have 1 or many commands.
Along with Core, we moved the oclif-dev CLI into the oclif CLI creating a single "utility" CLI. This CLI also introduces a new AWS S3 compatible publishing scheme.
What to expect in the near future​
Core is in pre-release beta and being actively developed for new internal Salesforce CLIs.
Much documentation needs to be written in the coming months including migration paths. Migration onto Core should be as painless as possible with many exports remaining entirely unchanged. Look for forthcoming blog posts and documentation on oclif.io.
Early this summer, tentively June 1, we will release Core v1. Core's release will coincide with major bumps to many other oclif plugin packages. See the compatibility matrix below.
At Core's v1 release, the current "main" oclif packages (namely: command, config, errors & parser) will go into maintenance mode until Jan 2022. They will receive only bug and security fixes and they remain compatible with current versions of the oclif and oclif-dev CLIs. Afterwhich, they will be archived.
Companioning Core, the next major release of the oclif CLI (literally oclif@2) will generate Core CLIs.
Going forward​
We are excited to release Core! We invite you to poke around the Core repo. It may appear to be a big change but Core keeps what you already enjoy about oclif while reducing development complexity, project dependencies, package coupling and bundle size and introduces many requested features previously too prickly to weave into the current oclif architecture.
Best,
The oclif team
Reference: Compatibility matrix​
oclif "v1"oclif "Core"Utility CLIsoclif@<2@oclif/dev-cli@<2oclif@>=2Main packages@oclif/core@<2@oclif/config@<2@oclif/errors@<2@oclif/parser@<4@oclif/plugin-help@<4@oclif/core@>=1Node LTSNode v8-14Node v12+TypeScripttypescript@<4typescript@>=4Main plugins@oclif/plugin-autocomplete@<1@oclif/plugin-commands@<2@oclif/plugin-help@<4@oclif/plugin-not-found@<2@oclif/plugin-plugins@<2@oclif/plugin-update@<2plugin-warn-if-update-available@<2plugin-which@<2@oclif/plugin-autocomplete@>=2@oclif/plugin-commands@>=2@oclif/plugin-help@>=4@oclif/plugin-not-found@>=2@oclif/plugin-plugins@>=2@oclif/plugin-update@>=2@oclif/plugin-warn-if-update-available@>=2@oclif/plugin-which@>=2oclif Summer 2020 UpdateAugust 26, 2020 · 2 min readHello oclif developers! We hope you are all doing well.
Earlier this year, we started our planning for oclifconf v2 and, like all conference, had to change course. We opted not to hold a virtual conference, however, we wanted to take some time to highlight a few oclif features shipped this year.
Feature: Help templating​
One of the most requested features, help templating enables oclif developers to customize the help output for their CLI.
Read the announcement.
Feature: Custom error delegation​
This feature both improved how oclif throws and handles errors and allows oclif developers to overwrite or interject in oclif’s error handling.
Read the announcement.
Feature: postrun hooks​
We have added a new lifecycle event postrun. Your CLI can now run a hook after a command has ran.
See our hook documentation.
Feature: Root index command​
Previously, oclif would display CLI help if only the binary name with no command ID was invoked, oclif now supports a "root index" command. If present, a command defined at src/commands/index.ts will be run if no command ID is found.
1 million weekly downloads​
While exact oclif usage metrics are hard to pin down, we use npm download statistics of oclif packages as a rough approximation. Earlier this year, oclif's command package hit 1 million weekly downloads for the first time!
This year has been presented its challenges on everyone. We want to thank you, oclif developers, whom have taken the time to use and improve the oclif project. We look forward to seeing you all - in person - in the future!
All our best,
The oclif teamPretty Printable ErrorsJuly 1, 2020 · One min readOften CLIs are used as handy tools and when things go wrong it’s useful to have additional context. In oclif we have added a couple of additional properties that can show extra context to the users when an error is displayed. The code, ref and suggestions will now be displayed if they are included. This will work with an existing oclif CLI by adding the latest @oclif/errors and @oclif/core to the CLI's package.json dependencies.
For example, using this.error with the additional properties:
class TestError extends Command {  async run() {    this.error("An error has occurred!", {      code: "OCLIF_ERR",      ref: "https://oclif.io/docs/commands#thiserrormessage-string--error-options-code-string-exit-number",      suggestions: ["Use these extra properties to provide additional context"],    })  }}
would result with the following output:
›   Error: An error has occurred!›   Code: OCLIF_ERR›   Try this: Use these extra properties to provide additional context›   Reference: https://oclif.io/docs/commands#thiserrormessage-string--error-options-code-string-exit-number
If these properties are not provided then nothing changes and the CLI will continue to display the single error message output as it did before. Additionally, as part of this exercise we’ve added documentation around Error Handling in oclif which should come in handy if the need arises to extend oclif’s default handling of errors.Customizing Help in oclifMay 5, 2020 · 2 min readOut of the box oclif provides a great help experience for CLIs.
But what if, as an oclif developer, you want to customize some or all of the output?
You can now customize your CLI's help output by implementing the HelpBase abstract class.
Getting started with custom help​
If you have not done so yet, update @oclif/core.
$ yarn add --latest @oclif/core
To get started, first define the filepath to your help class in oclif's config in package.json. This is a relative path to the help class, without a file extension.
For this example, the help class will be created in a file at "[project root]/src/help.ts".
{  // ...  "oclif": {    "helpClass": "./lib/help"    // ...  }  // ...}
From here there are two paths, implement the HelpBase abstract class yourself or overwrite the parts of the default Help class you want to customize (ex: how command usage is displayed). We recommend the latter approach but cover both in the new Help Classes docs.
Separating TOPICS & COMMANDS in the new default Help class​
Previously, topics and child commands were listed in help output under a single list heading called "COMMANDS". But we found this can be slightly confusing. Some topics are commands also (a.k.a. topic-commands) while others are simply organizational namespacing (and when ran just show their help).
The new default Help class splits the list of children into distinct lists of "TOPICS" and "COMMANDS", with the possibility of an item appearing in both if it a topic-command. This makes it clearer what is expected to be ran - "COMMANDS" - and what is providing structure - "TOPICS" - when looking at the help output.
VERSION  plugin-help-example/0.0.0 darwin-x64 node-v12.12.0USAGE  $ plugin-help-example [COMMAND]TOPICS  topic  this is a topic and has child topics or commandsCOMMANDS  hello  describe the command here  help   display help for plugin-help-example
We look forward to seeing what custom help features you implement in your oclif CLIs with this new feature!oclif TSLint to ESLint MigrationDecember 5, 2019 · 3 min readBack in February of this year, plans were announced to deprecate TSLint in favor of ESLint. TSLint's goal has become to work toward a “unified developer experience” by supporting ESLint development going forward.
What has changed in oclif​
To keep inline with the community, oclif has transitioned to ESLint for all our core libraries as well as all our official plugins.
Starting in v1.15.x, oclif will now optionally generate projects with ESLint for both TypeScript and JavaScript CLI’s.
ESLint does require Node to be on stable LTS version, at the time of writing, Node 8.10.x, Node 10.13.x & Node 12.x.x.
How does this affect you​
Existing CLI’s are unchanged, but any newly generated CLI's will only give the option of using ESLint. If you are running tslint in your CLI, we recommend you switch to ESLint as well.
In migrating our projects we took the following steps (for an example of these changes see this pull request).


Install eslint
$ yarn add eslint eslint-config-oclif eslint-config-oclif-typescript --dev


Add eslint related files


$ echo '{  "extends": [    "oclif",    "oclif-typescript"  ],  "rules": {  }}' > .eslintrc


Remove tslint and related packages
$ yarn remove @oclif/tslint tslint


Remove tslint related configuration files
$ rm tslint.json


Change lint script in our package.json from something like:
"lint": "tsc -p test --noEmit && tslint -p test -t stylish"
to
"lint": "eslint . --ext .ts --config .eslintrc"


To preserve the test compile (tsc -p test --noEmit) we also made the following updates to our scripts:
"pretest": "tsc -p test --noEmit"
In some cases we had our posttest duplicating the same steps as our lint script so it’s cleaner to have it reference the lint job directly with:
"posttest": "yarn lint"

Run yarn lint --fix. This attempts to auto-fix any linting violations automatically. In the case an auto-fix isn’t available it should be fixed manually or ignored (see the eslint configuration doc for more information)
Do a search in the codebase for tslint and remove any unnecessary tslint disabling comments, like:

/* tslint:disable:object-literal-sort-keys */
If you are on a version of Node that is not supported by ESLint, you will also need to update your Node engine. ESLint supports Node 8, 10, and 12 so you should upgrade to the most recent Node version compatible with your CLI and also supported by ESLint (see ESLint's Installation and Usage instructions).
When will this take effect​
These changes have taken effect in oclif v1.15.1. When you generate a new CLI or plugin it will now contain configuration for ESLint instead of TSLint.oclif's Current Node SupportOctober 31, 2019 · 3 min readTo maintain a healthy project trajectory, oclif follows and supports Node Active LTS release, currently Node 10 & Node 12. This means ensuring that oclif continues to play nice with coming Active LTS Node versions and other packages in the ecosystem. Moving forward also means leaving older versions behind. Starting in 2020, Node will stop maintaining Node 8 and it is our intent at that time to also follow suit. Let’s take a look at a few ways we will be supporting these changes.
CI Environments​
CLIs created with the oclif cli going forward will be generated with a CircleCI configuration with Node 10 & 12 and an Appveyor configuration using Node 10. We have also added Node latest to CircleCi to be an early warning detection against coming Node changes (Node latest is managed by CircleCI).
We have already updated every oclif repo's CI configs to reflect this.
If your existing CLI uses either Appveyor or CircleCI you can update your config files also, like so:
.circleci/config.yml​
Your CircleCI config should contain a node-latest job, aliased as test. From this, there should be two extensions of this job for the Active LTS Node versions, Node 10 and Node 12.
  node-10:    <<: *node-latest    docker:      - image: node:10  node-12:    <<: *node-latest    docker:      - image: node:12
Notice that these declarations only change the Docker Node images used to run that job.
Additionally, the jobs listed within workflows must also be updated to reflect our changes in configuration:
    jobs:      - node-latest      - node-10      - node-12
appveyor.yml​
For appveyor we are currently only testing the oldest Active LTS Node version, Node 10. Update the nodejs_version proppert in your appveyor.yml file to reflect this.
environment:  nodejs_version: "10"
Deprecating Node 8 & Updating packge.json engines​
In Jan 2020, Node will end its Node 8 maintenance. We will follow suit by setting the package.json engine property in oclif packages to >=10 and bumping the package's major versions.
Depending on how you ship your CLI you may wish to also bump the engines version in your CLI's package.json. You can read more about the implications of the engines property configuration in the npm documentation.
Also consider distributing your CLI with its own Node version.
Packaged Node Version​
When using dev-cli to pack your CLI it will use the Node version as specified in your package.json under the oclif.update.node.version property. This value should reflect an Active LTS Node version (dev-cli does not currently enforce versions).
Supporting the future​
As a community we may discover bumps along the way as we upgrade. If you notice something related to oclif please feel free to open an issue or submit a pull request under the relevant oclif package within the org.
We look forward to using the latest from Node and the community and keeping oclif healthy along the way.oclifconf 2019: A RecapSeptember 16, 2019 · 4 min readIn May, Heroku and Salesforce Open Source organized oclifconf, a conference for developers & product managers building CLI tools on top of the open source oclif framework. The speakers came from various tech companies, such as Adobe, Netlify, and Apollo, who have already built amazing CLI experiences. The topics covered everything from the incredible capabilities oclif has unlocked, to the community-built plugins extending its functionality, and even what the behavior of an adaptive CLI tool might look like.
Below is a listing of all of the talks from the event, along with a short summary. Enjoy!
The future of oclif by Jeff Dickey​

In its relatively short lifetime, oclif has already inspired many developers and companies to adopt its framework as a means for implementing their own command-line tooling. In this talk, Jeff Dickey, an oclif founding team member, recaps the project's history and inspiration. He also looks towards the future and outlines some features and improvements that the tool could adapt. This isn't so much a definitive roadmap of where oclif is headed, but rather, a call to inspiration for developers eager to contribute! And if you are interested in contributing, check out the open issues in the oclif GitHub repo and come say "Hello!" on Spectrum Chat.
Open Source Citizenship by Josh Simmons​

When it comes to open source, it's more than just individuals now. More and more frequently, large corporations are contributing to projects by donating to contributors, sponsoring events, or upstreaming contributions. But keeping open source projects and communities healthy requires more than just money and brainpower. Josh Simmons surveyed multiple open source communities and relays his findings as to what help maintainers and contributors actually need in this talk.
Building an enterprise-grade CLI with oclif by Thomas Dvornik​

Security and performance are all about trust. While oclif is an extremely extensible framework for building CLI tooling, there are additional requirements to fulfill for enterprise businesses to adopt it that might not be necessary for individual developers. Thomas Dvornik outlines what he and his colleagues at Salesforce have implemented as plugins to oclif to satisfy these needs, including encrypted OAuth, plugin signing, lazy loading dependencies, synchronizing weekly releases and deprecations across dozens of repositories, and establishing cross-team coding and documentation standards.
How Adobe I/O built an extensible CLI with oclif by Jesse MacFadyen​

Perhaps oclif's most appealing feature is its support for plugins. In Cordova's case, they've created a sophisticated telemetry system that helps Adobe developers see which commands users are using--and reports on which ones are erroring out. By embedding a feedback system into the tool, users are even able to quickly send their suggestions to a form, without ever leaving the terminal. Jesse MacFadyen demonstrates how oclif's plugin system can work beyond simply executing commands.
Integrating oclif with GraphQL and Apollo by Evans Hauser​

For Evans Hauser and the team at Apollo, oclif is best thought of as "React for the CLI." As a client paired with a strongly-typed API contract to a server, it can deliver structured and consistent commands to retrieve external data. What better mechanism to use for this transfer than GraphQL, a framework which empowers the client to ask precisely for the data it needs, and nothing more?
Adaptive Intent-based CLI State Machines by Shawn Wang​

In designing oclif, Jeff Dickey wrote out 12 CLI factors to keep in mind. In this talk, Shawn Wang outlines a 13th: state. State is hard, because it depends on context, and context depends on understanding what a user intends to do, not what they are asking. Shawn is working towards enabling oclif to better understand the commands a user has entered, so that it can predict and interpret future commands that might be entered next. This would enable CLI tools to not just interpret a users' commands, but to also interpret their intent.Older Entries\n\n\n\nIntroducing `oclif init` commandApril 10, 2024 · 2 min readThanks to the contribution of @joshcanhelp we released a new command for the oclif CLI called oclif init in version 4.8.0
The oclif init command allows you to initialize oclif in an existing project directory by adding the bare minimum requirements: a few pieces of configuration, bin scripts, and a couple of dependencies (@oclif/core and ts-node). This is slightly different from oclif generate, which will create an entirely new oclif project based on our templates.
oclif init will add the following:

bin scripts: bin/run.js, bin/run.cmd, bin/dev.js, and bin/dev.cmd
oclif section to package.json with bin, dirname, commands, and topicSeparator set (See Configuring Your CLI for more)
@oclif/core to dependencies in your package.json (if it's not already there)
ts-node to devDependencies in your package.json (if it's not already there)

Once you've initialized oclif, you can use the bin scripts to execute your CLI. You can also use the other oclif commands like oclif generate command and oclif generate hook to start adding new functionality.

❯ oclif init --helpInitialize a new oclif CLIUSAGE  $ oclif init [--bin <value>] [--module-type ESM|CommonJS] [--package-manager npm|yarn|pnpm] [--topic-separator    colons|spaces] [-d <value>] [-y]FLAGS  -d, --output-dir=<value>        Directory to initialize the CLI in.  -y, --yes                       Use defaults for all prompts. Individual flags will override defaults.      --bin=<value>               Supply answer for prompt: Command bin name the CLI will export      --module-type=<option>      Supply answer for prompt: Select a module type                                  <options: ESM|CommonJS>      --package-manager=<option>  Supply answer for prompt: Select a package manager                                  <options: npm|yarn|pnpm>      --topic-separator=<option>  Supply answer for prompt: Select a topic separator                                  <options: colons|spaces>DESCRIPTION  Initialize a new oclif CLI  This will add the necessary oclif bin files, add oclif config to package.json, and install @oclif/core and ts-node.EXAMPLES  Initialize a new CLI in the current directory    $ oclif init  Initialize a new CLI in a different directory    $ oclif init --output-dir "/path/to/existing/project"  Supply answers for specific prompts    $ oclif init --topic-separator colons --bin mycli
Hope you enjoy the new command! If you come across any issues or have any new ideas for this command, head over to the oclif/oclif repo and open a new issue.
All our best,
The oclif teamoclif Spring 2024 UpdateMarch 29, 2024 · 4 min readHello oclif developers! It's been a while since we last uploaded a blog - and a lot has happened.
We've been focusing on these high-level areas over the past couple of years:

Improving @oclif/core
ESM Support
Improving and revitalizing oclif.io
Re-engaging the oclif community

Improving @oclif/core​
Since we announced @oclif/core over three years ago, we've released two new major versions, each packed with lots of features that we're really excited about.
Here are some of these changes:

Full support for ESM and interoperability with CommonJS (more on this topic below).
Configurable command discovery strategies that give you more control over how commands are loaded at runtime. Check out the docs.
A new preparse hook that allows you to manipulate the provided arguments before they're parsed. Salesforce used this hook to implement a neat --flags-dir feature that translates local files into flags.
A new Performance class that you can use to track performance inside of @oclif/core and your own CLI or plugin. Check out the docs.
A new flag type, Flags.option, that lets you define a flag with a preset list of options. Typescript then uses the options to infer the flag's type.
Flags now have a relationship property that allows you to define more complex relationships between flags. Check out the flags docs for more information.
Flags now have a defaultHelp property that allows you to set the human readable default value in the command help. This property is useful when your flag's parse method returns a complex type, such as an object or a class. Check out the flags docs for more.
Commands now have a hiddenAliases property that allows you to define aliases that you want to hide from the user. The property is super helpful when you're trying to wean users off a deprecated command.
You can now use bun or tsx as dev runtimes (as opposed to node or ts-node).
A command's usage, args, and flags are now shown whenever a user forgets to provide a required arg or flag, or when they provided a non-existent flag.

If you need help migrating to the latest version, head over to core's README which has links to the migration guides. Feel free to open a new discussion if you need more hands-on help from us or the community.
ESM Support​
Version 3 of @oclif/core introduced full support for developing ESM plugins and CLIs. It also offered full support for interoperability between CommonJS and ESM plugins.
Put more simply, you can now migrate your CLI to ESM while keeping individual plugins in CommonJS (or vice versa). The upgrade path is now much simpler for you. You also don't need to worry about any community plugins that have migrated to ESM before you did (such as all the @oclif plugins) or are staunchly sticking with CommonJS for the foreseeable future.
Read more about this topic here.
Improving and Revitalizing oclif.io​
Another area of focus for us has been improving our documentation site, oclif.io.
While improving the quality and accuracy of the documentation was our priority, we also took the time to upgrade to the latest version of docusaurus. This new version gave our site a much-needed facelift, as well as cool new features such as dark mode and announcements.
If you have any feedback or are running into issues, we want to hear about it. Just create an issue in the oclif.io repo.
Re-engaging the oclif Community​
Lastly, our biggest priority at the moment is to re-engage the oclif community. We understand how frustrating it has been over the years to see your issues and pull requests go unacknowledged. We apologize for not prioritizing the community, and are earnestly trying to make sure that every issue and pull request gets the attention it deserves going forward.
We also opened up GitHub discussions for @oclif/core and the oclif CLI, where you can now post your questions or ideas. We hope you take advantage of them, we love hearing from you!
One last thing: we intend to publicly post our roadmap so you have more visibility into what we're working on. Stay tuned!
All our best,
The oclif teamAnnouncing oclif v2!January 12, 2022 · 5 min readHello and happy new year! It's our great pleasure to announce that we have released oclif v2, which uses the new @oclif/core library! 🎉
oclif v2 includes many changes that improve the experience of both creating and using an oclif CLI.
Going forward, we don't plan to make any updates to oclif v1 and its corresponding libraries, except for critical security fixes. See the compatibility matrix for a list of these libraries. In order to give developers time to migrate from v1 to v2, we're not completely dropping support yet. But at some point in the future we'll archive the v1 repositories and deprecate their versions on npm.
What’s changing?​
Repository Changes​
All repositories under the oclif org now use main as their primary branch and oclif-v1 as the legacy branch. The main  branch corresponds to oclif v2 and the oclif-v1 branch to oclif v1. If you find any repos that don’t have a main branch, you can safely assume that they're not used in oclif v2 and will be deprecated in the future.
Consolidating Tools & Libraries​
The oclif-dev CLI has now been incorporated into oclif. You now no longer need to install a separate package to manage your entire CLI’s lifecycle.
The following libraries have been consolidated under @oclif/core and will be deprecated at some point in the future. Read the migration guide to learn how to update your CLI or plugin to use the new core library.

@oclif/command
@oclif/config
@oclif/error
@oclif/help
@oclif/parser

No more single vs multi command CLIs​
There's only one "type" of oclif v2 CLI, but it can have as few or as many commands as a developer wants. As a result, there’s only one command to generate CLIs, oclif generate, as opposed to the old oclif single and oclif multi commands.
Node > 12​
To ensure oclif CLIs are as secure as possible, all v2 libraries and plugins support only Node 12 or higher as of now. Going forward, they'll support only Node Maintenance or higher, as defined by Node's release schedule here: https://nodejs.org/en/about/releases/.
What’s new?​
New example CLI​
oclif-hello-world is our new example repo. This is also the repo that's used as a template when running oclif generate to create a new CLI. This repo will always be able to be referenced as an example of what an oclif v2 CLI should look like.
Spaced commands​
oclif CLIs can now use spaces, instead of colons, to separate topics and subcommands. To enable this feature, simply add “topicSeparator": " " to the oclif config in your package.json. See an example in our example repo.
// Old commands that use :$ mycli do:something
// New spaced commands$ mycli do something

Note: Spaced commands are backwards compatible. So if you enable spaced commands for your CLI, users will still be able to use : as a separator. This ensures that any existing scripts don't break.

New Help Output​
We’ve revamped the way command help is outputted to the terminal, making it both easier to implement and easier to read. See the difference between the old help output on the left and the new help output on the right in the screenshots below.
oclif v1oclif v2
Notice that there are new sections for flags and global flags, examples are displayed with better spacing, and there is a section at the bottom called Configuration Variables. This Configuration Variables section is not part of the new help by default. But we've added support for custom help sections, which is what the sf CLI uses to create the new section.
Async Command Parsing​
We’ve also improved the performance of new CLIs by rewriting how commands are parsed on initialization. The new parser is asynchronous, which makes CLIs with a lot of commands or installed  plugins much faster.
What’s coming next?​
Part of our charter for the release of oclif v2 includes improving our engagement with the oclif community. We know that over the past couple of years we’ve reduced our involvement, and a lot of issues and PRs have languished in limbo. Hopefully you’ve already seen increased activity and responses from oclif maintainers recently, but if you haven’t, please don’t hesitate to ping us by tagging @admins in oclif repos.
We also want to start interviewing members of the oclif community to acquire feedback and prioritize the features and fixes you deem most important!
Best,
The oclif team

Reference material​
Migration Guide​
This guide explains how to upgrade a CLI or plugin from the old oclif v1 libraries to the new @oclif/core library that oclif v2 uses.
https://github.com/oclif/core/blob/main/MIGRATION.md
Compatibility Matrix​
The following matrix shows how the v1 libraries and plugins relate to the new v2 ones. Use this matrix as a guide to know what to drop and which versions to switch when upgrading your plugins and CLIs to v2.
oclif "v1"oclif "v2"Utility CLIsoclif@<2@oclif/dev-cli@<2oclif@>=2Main packages@oclif/command@oclif/config@oclif/errors@oclif/parser@oclif/plugin-help@oclif/core@>=1Node LTSNode v8-14Node v12+ (at time of writing)TypeScripttypescript@<4typescript@>=4Main plugins@oclif/plugin-autocomplete@<1@oclif/plugin-commands@<2@oclif/plugin-help@<4@oclif/plugin-not-found@<2@oclif/plugin-plugins@<2@oclif/plugin-update@<2plugin-warn-if-update-available@<2plugin-which@<2@oclif/plugin-autocomplete@>=1@oclif/plugin-commands@>=2@oclif/plugin-help@>=4@oclif/plugin-not-found@>=2@oclif/plugin-plugins@>=2@oclif/plugin-update@>=2@oclif/plugin-warn-if-update-available@>=2@oclif/plugin-which@>=2Introducing @oclif/coreMarch 1, 2021 · 3 min readGreetings!
We hope this blog post finds you well.
Introducing...​
We are excited to announce the next iteration of the oclif project today: @oclif/core.
We have learned a lot in the last three years of developing oclif, developing on oclif and supporting millions of command runs a day via Heroku and Salesforce CLIs.
@oclif/core ("Core") simplifies the oclif development experience and introduces highly requested new features.
Core combines the essential oclif packages into one "core" package, aptly named @oclif/core.
Core also introduces:

A default command option
Colon or space command syntax
Async command parsing
Command piping to arguments

With the introduction of default command functionality, Core simplifies the oclif project and removes the notion of single or multi command CLIs. Core CLIs can have 1 or many commands.
Along with Core, we moved the oclif-dev CLI into the oclif CLI creating a single "utility" CLI. This CLI also introduces a new AWS S3 compatible publishing scheme.
What to expect in the near future​
Core is in pre-release beta and being actively developed for new internal Salesforce CLIs.
Much documentation needs to be written in the coming months including migration paths. Migration onto Core should be as painless as possible with many exports remaining entirely unchanged. Look for forthcoming blog posts and documentation on oclif.io.
Early this summer, tentively June 1, we will release Core v1. Core's release will coincide with major bumps to many other oclif plugin packages. See the compatibility matrix below.
At Core's v1 release, the current "main" oclif packages (namely: command, config, errors & parser) will go into maintenance mode until Jan 2022. They will receive only bug and security fixes and they remain compatible with current versions of the oclif and oclif-dev CLIs. Afterwhich, they will be archived.
Companioning Core, the next major release of the oclif CLI (literally oclif@2) will generate Core CLIs.
Going forward​
We are excited to release Core! We invite you to poke around the Core repo. It may appear to be a big change but Core keeps what you already enjoy about oclif while reducing development complexity, project dependencies, package coupling and bundle size and introduces many requested features previously too prickly to weave into the current oclif architecture.
Best,
The oclif team
Reference: Compatibility matrix​
oclif "v1"oclif "Core"Utility CLIsoclif@<2@oclif/dev-cli@<2oclif@>=2Main packages@oclif/core@<2@oclif/config@<2@oclif/errors@<2@oclif/parser@<4@oclif/plugin-help@<4@oclif/core@>=1Node LTSNode v8-14Node v12+TypeScripttypescript@<4typescript@>=4Main plugins@oclif/plugin-autocomplete@<1@oclif/plugin-commands@<2@oclif/plugin-help@<4@oclif/plugin-not-found@<2@oclif/plugin-plugins@<2@oclif/plugin-update@<2plugin-warn-if-update-available@<2plugin-which@<2@oclif/plugin-autocomplete@>=2@oclif/plugin-commands@>=2@oclif/plugin-help@>=4@oclif/plugin-not-found@>=2@oclif/plugin-plugins@>=2@oclif/plugin-update@>=2@oclif/plugin-warn-if-update-available@>=2@oclif/plugin-which@>=2oclif Summer 2020 UpdateAugust 26, 2020 · 2 min readHello oclif developers! We hope you are all doing well.
Earlier this year, we started our planning for oclifconf v2 and, like all conference, had to change course. We opted not to hold a virtual conference, however, we wanted to take some time to highlight a few oclif features shipped this year.
Feature: Help templating​
One of the most requested features, help templating enables oclif developers to customize the help output for their CLI.
Read the announcement.
Feature: Custom error delegation​
This feature both improved how oclif throws and handles errors and allows oclif developers to overwrite or interject in oclif’s error handling.
Read the announcement.
Feature: postrun hooks​
We have added a new lifecycle event postrun. Your CLI can now run a hook after a command has ran.
See our hook documentation.
Feature: Root index command​
Previously, oclif would display CLI help if only the binary name with no command ID was invoked, oclif now supports a "root index" command. If present, a command defined at src/commands/index.ts will be run if no command ID is found.
1 million weekly downloads​
While exact oclif usage metrics are hard to pin down, we use npm download statistics of oclif packages as a rough approximation. Earlier this year, oclif's command package hit 1 million weekly downloads for the first time!
This year has been presented its challenges on everyone. We want to thank you, oclif developers, whom have taken the time to use and improve the oclif project. We look forward to seeing you all - in person - in the future!
All our best,
The oclif teamPretty Printable ErrorsJuly 1, 2020 · One min readOften CLIs are used as handy tools and when things go wrong it’s useful to have additional context. In oclif we have added a couple of additional properties that can show extra context to the users when an error is displayed. The code, ref and suggestions will now be displayed if they are included. This will work with an existing oclif CLI by adding the latest @oclif/errors and @oclif/core to the CLI's package.json dependencies.
For example, using this.error with the additional properties:
class TestError extends Command {  async run() {    this.error("An error has occurred!", {      code: "OCLIF_ERR",      ref: "https://oclif.io/docs/commands#thiserrormessage-string--error-options-code-string-exit-number",      suggestions: ["Use these extra properties to provide additional context"],    })  }}
would result with the following output:
›   Error: An error has occurred!›   Code: OCLIF_ERR›   Try this: Use these extra properties to provide additional context›   Reference: https://oclif.io/docs/commands#thiserrormessage-string--error-options-code-string-exit-number
If these properties are not provided then nothing changes and the CLI will continue to display the single error message output as it did before. Additionally, as part of this exercise we’ve added documentation around Error Handling in oclif which should come in handy if the need arises to extend oclif’s default handling of errors.Customizing Help in oclifMay 5, 2020 · 2 min readOut of the box oclif provides a great help experience for CLIs.
But what if, as an oclif developer, you want to customize some or all of the output?
You can now customize your CLI's help output by implementing the HelpBase abstract class.
Getting started with custom help​
If you have not done so yet, update @oclif/core.
$ yarn add --latest @oclif/core
To get started, first define the filepath to your help class in oclif's config in package.json. This is a relative path to the help class, without a file extension.
For this example, the help class will be created in a file at "[project root]/src/help.ts".
{  // ...  "oclif": {    "helpClass": "./lib/help"    // ...  }  // ...}
From here there are two paths, implement the HelpBase abstract class yourself or overwrite the parts of the default Help class you want to customize (ex: how command usage is displayed). We recommend the latter approach but cover both in the new Help Classes docs.
Separating TOPICS & COMMANDS in the new default Help class​
Previously, topics and child commands were listed in help output under a single list heading called "COMMANDS". But we found this can be slightly confusing. Some topics are commands also (a.k.a. topic-commands) while others are simply organizational namespacing (and when ran just show their help).
The new default Help class splits the list of children into distinct lists of "TOPICS" and "COMMANDS", with the possibility of an item appearing in both if it a topic-command. This makes it clearer what is expected to be ran - "COMMANDS" - and what is providing structure - "TOPICS" - when looking at the help output.
VERSION  plugin-help-example/0.0.0 darwin-x64 node-v12.12.0USAGE  $ plugin-help-example [COMMAND]TOPICS  topic  this is a topic and has child topics or commandsCOMMANDS  hello  describe the command here  help   display help for plugin-help-example
We look forward to seeing what custom help features you implement in your oclif CLIs with this new feature!oclif TSLint to ESLint MigrationDecember 5, 2019 · 3 min readBack in February of this year, plans were announced to deprecate TSLint in favor of ESLint. TSLint's goal has become to work toward a “unified developer experience” by supporting ESLint development going forward.
What has changed in oclif​
To keep inline with the community, oclif has transitioned to ESLint for all our core libraries as well as all our official plugins.
Starting in v1.15.x, oclif will now optionally generate projects with ESLint for both TypeScript and JavaScript CLI’s.
ESLint does require Node to be on stable LTS version, at the time of writing, Node 8.10.x, Node 10.13.x & Node 12.x.x.
How does this affect you​
Existing CLI’s are unchanged, but any newly generated CLI's will only give the option of using ESLint. If you are running tslint in your CLI, we recommend you switch to ESLint as well.
In migrating our projects we took the following steps (for an example of these changes see this pull request).


Install eslint
$ yarn add eslint eslint-config-oclif eslint-config-oclif-typescript --dev


Add eslint related files


$ echo '{  "extends": [    "oclif",    "oclif-typescript"  ],  "rules": {  }}' > .eslintrc


Remove tslint and related packages
$ yarn remove @oclif/tslint tslint


Remove tslint related configuration files
$ rm tslint.json


Change lint script in our package.json from something like:
"lint": "tsc -p test --noEmit && tslint -p test -t stylish"
to
"lint": "eslint . --ext .ts --config .eslintrc"


To preserve the test compile (tsc -p test --noEmit) we also made the following updates to our scripts:
"pretest": "tsc -p test --noEmit"
In some cases we had our posttest duplicating the same steps as our lint script so it’s cleaner to have it reference the lint job directly with:
"posttest": "yarn lint"

Run yarn lint --fix. This attempts to auto-fix any linting violations automatically. In the case an auto-fix isn’t available it should be fixed manually or ignored (see the eslint configuration doc for more information)
Do a search in the codebase for tslint and remove any unnecessary tslint disabling comments, like:

/* tslint:disable:object-literal-sort-keys */
If you are on a version of Node that is not supported by ESLint, you will also need to update your Node engine. ESLint supports Node 8, 10, and 12 so you should upgrade to the most recent Node version compatible with your CLI and also supported by ESLint (see ESLint's Installation and Usage instructions).
When will this take effect​
These changes have taken effect in oclif v1.15.1. When you generate a new CLI or plugin it will now contain configuration for ESLint instead of TSLint.oclif's Current Node SupportOctober 31, 2019 · 3 min readTo maintain a healthy project trajectory, oclif follows and supports Node Active LTS release, currently Node 10 & Node 12. This means ensuring that oclif continues to play nice with coming Active LTS Node versions and other packages in the ecosystem. Moving forward also means leaving older versions behind. Starting in 2020, Node will stop maintaining Node 8 and it is our intent at that time to also follow suit. Let’s take a look at a few ways we will be supporting these changes.
CI Environments​
CLIs created with the oclif cli going forward will be generated with a CircleCI configuration with Node 10 & 12 and an Appveyor configuration using Node 10. We have also added Node latest to CircleCi to be an early warning detection against coming Node changes (Node latest is managed by CircleCI).
We have already updated every oclif repo's CI configs to reflect this.
If your existing CLI uses either Appveyor or CircleCI you can update your config files also, like so:
.circleci/config.yml​
Your CircleCI config should contain a node-latest job, aliased as test. From this, there should be two extensions of this job for the Active LTS Node versions, Node 10 and Node 12.
  node-10:    <<: *node-latest    docker:      - image: node:10  node-12:    <<: *node-latest    docker:      - image: node:12
Notice that these declarations only change the Docker Node images used to run that job.
Additionally, the jobs listed within workflows must also be updated to reflect our changes in configuration:
    jobs:      - node-latest      - node-10      - node-12
appveyor.yml​
For appveyor we are currently only testing the oldest Active LTS Node version, Node 10. Update the nodejs_version proppert in your appveyor.yml file to reflect this.
environment:  nodejs_version: "10"
Deprecating Node 8 & Updating packge.json engines​
In Jan 2020, Node will end its Node 8 maintenance. We will follow suit by setting the package.json engine property in oclif packages to >=10 and bumping the package's major versions.
Depending on how you ship your CLI you may wish to also bump the engines version in your CLI's package.json. You can read more about the implications of the engines property configuration in the npm documentation.
Also consider distributing your CLI with its own Node version.
Packaged Node Version​
When using dev-cli to pack your CLI it will use the Node version as specified in your package.json under the oclif.update.node.version property. This value should reflect an Active LTS Node version (dev-cli does not currently enforce versions).
Supporting the future​
As a community we may discover bumps along the way as we upgrade. If you notice something related to oclif please feel free to open an issue or submit a pull request under the relevant oclif package within the org.
We look forward to using the latest from Node and the community and keeping oclif healthy along the way.oclifconf 2019: A RecapSeptember 16, 2019 · 4 min readIn May, Heroku and Salesforce Open Source organized oclifconf, a conference for developers & product managers building CLI tools on top of the open source oclif framework. The speakers came from various tech companies, such as Adobe, Netlify, and Apollo, who have already built amazing CLI experiences. The topics covered everything from the incredible capabilities oclif has unlocked, to the community-built plugins extending its functionality, and even what the behavior of an adaptive CLI tool might look like.
Below is a listing of all of the talks from the event, along with a short summary. Enjoy!
The future of oclif by Jeff Dickey​

In its relatively short lifetime, oclif has already inspired many developers and companies to adopt its framework as a means for implementing their own command-line tooling. In this talk, Jeff Dickey, an oclif founding team member, recaps the project's history and inspiration. He also looks towards the future and outlines some features and improvements that the tool could adapt. This isn't so much a definitive roadmap of where oclif is headed, but rather, a call to inspiration for developers eager to contribute! And if you are interested in contributing, check out the open issues in the oclif GitHub repo and come say "Hello!" on Spectrum Chat.
Open Source Citizenship by Josh Simmons​

When it comes to open source, it's more than just individuals now. More and more frequently, large corporations are contributing to projects by donating to contributors, sponsoring events, or upstreaming contributions. But keeping open source projects and communities healthy requires more than just money and brainpower. Josh Simmons surveyed multiple open source communities and relays his findings as to what help maintainers and contributors actually need in this talk.
Building an enterprise-grade CLI with oclif by Thomas Dvornik​

Security and performance are all about trust. While oclif is an extremely extensible framework for building CLI tooling, there are additional requirements to fulfill for enterprise businesses to adopt it that might not be necessary for individual developers. Thomas Dvornik outlines what he and his colleagues at Salesforce have implemented as plugins to oclif to satisfy these needs, including encrypted OAuth, plugin signing, lazy loading dependencies, synchronizing weekly releases and deprecations across dozens of repositories, and establishing cross-team coding and documentation standards.
How Adobe I/O built an extensible CLI with oclif by Jesse MacFadyen​

Perhaps oclif's most appealing feature is its support for plugins. In Cordova's case, they've created a sophisticated telemetry system that helps Adobe developers see which commands users are using--and reports on which ones are erroring out. By embedding a feedback system into the tool, users are even able to quickly send their suggestions to a form, without ever leaving the terminal. Jesse MacFadyen demonstrates how oclif's plugin system can work beyond simply executing commands.
Integrating oclif with GraphQL and Apollo by Evans Hauser​

For Evans Hauser and the team at Apollo, oclif is best thought of as "React for the CLI." As a client paired with a strongly-typed API contract to a server, it can deliver structured and consistent commands to retrieve external data. What better mechanism to use for this transfer than GraphQL, a framework which empowers the client to ask precisely for the data it needs, and nothing more?
Adaptive Intent-based CLI State Machines by Shawn Wang​

In designing oclif, Jeff Dickey wrote out 12 CLI factors to keep in mind. In this talk, Shawn Wang outlines a 13th: state. State is hard, because it depends on context, and context depends on understanding what a user intends to do, not what they are asking. Shawn is working towards enabling oclif to better understand the commands a user has entered, so that it can predict and interpret future commands that might be entered next. This would enable CLI tools to not just interpret a users' commands, but to also interpret their intent.\n\nIntroducing `oclif init` commandApril 10, 2024 · 2 min readThanks to the contribution of @joshcanhelp we released a new command for the oclif CLI called oclif init in version 4.8.0
The oclif init command allows you to initialize oclif in an existing project directory by adding the bare minimum requirements: a few pieces of configuration, bin scripts, and a couple of dependencies (@oclif/core and ts-node). This is slightly different from oclif generate, which will create an entirely new oclif project based on our templates.
oclif init will add the following:

bin scripts: bin/run.js, bin/run.cmd, bin/dev.js, and bin/dev.cmd
oclif section to package.json with bin, dirname, commands, and topicSeparator set (See Configuring Your CLI for more)
@oclif/core to dependencies in your package.json (if it's not already there)
ts-node to devDependencies in your package.json (if it's not already there)

Once you've initialized oclif, you can use the bin scripts to execute your CLI. You can also use the other oclif commands like oclif generate command and oclif generate hook to start adding new functionality.

❯ oclif init --helpInitialize a new oclif CLIUSAGE  $ oclif init [--bin <value>] [--module-type ESM|CommonJS] [--package-manager npm|yarn|pnpm] [--topic-separator    colons|spaces] [-d <value>] [-y]FLAGS  -d, --output-dir=<value>        Directory to initialize the CLI in.  -y, --yes                       Use defaults for all prompts. Individual flags will override defaults.      --bin=<value>               Supply answer for prompt: Command bin name the CLI will export      --module-type=<option>      Supply answer for prompt: Select a module type                                  <options: ESM|CommonJS>      --package-manager=<option>  Supply answer for prompt: Select a package manager                                  <options: npm|yarn|pnpm>      --topic-separator=<option>  Supply answer for prompt: Select a topic separator                                  <options: colons|spaces>DESCRIPTION  Initialize a new oclif CLI  This will add the necessary oclif bin files, add oclif config to package.json, and install @oclif/core and ts-node.EXAMPLES  Initialize a new CLI in the current directory    $ oclif init  Initialize a new CLI in a different directory    $ oclif init --output-dir "/path/to/existing/project"  Supply answers for specific prompts    $ oclif init --topic-separator colons --bin mycli
Hope you enjoy the new command! If you come across any issues or have any new ideas for this command, head over to the oclif/oclif repo and open a new issue.
All our best,
The oclif teamoclif Spring 2024 UpdateMarch 29, 2024 · 4 min readHello oclif developers! It's been a while since we last uploaded a blog - and a lot has happened.
We've been focusing on these high-level areas over the past couple of years:

Improving @oclif/core
ESM Support
Improving and revitalizing oclif.io
Re-engaging the oclif community

Improving @oclif/core​
Since we announced @oclif/core over three years ago, we've released two new major versions, each packed with lots of features that we're really excited about.
Here are some of these changes:

Full support for ESM and interoperability with CommonJS (more on this topic below).
Configurable command discovery strategies that give you more control over how commands are loaded at runtime. Check out the docs.
A new preparse hook that allows you to manipulate the provided arguments before they're parsed. Salesforce used this hook to implement a neat --flags-dir feature that translates local files into flags.
A new Performance class that you can use to track performance inside of @oclif/core and your own CLI or plugin. Check out the docs.
A new flag type, Flags.option, that lets you define a flag with a preset list of options. Typescript then uses the options to infer the flag's type.
Flags now have a relationship property that allows you to define more complex relationships between flags. Check out the flags docs for more information.
Flags now have a defaultHelp property that allows you to set the human readable default value in the command help. This property is useful when your flag's parse method returns a complex type, such as an object or a class. Check out the flags docs for more.
Commands now have a hiddenAliases property that allows you to define aliases that you want to hide from the user. The property is super helpful when you're trying to wean users off a deprecated command.
You can now use bun or tsx as dev runtimes (as opposed to node or ts-node).
A command's usage, args, and flags are now shown whenever a user forgets to provide a required arg or flag, or when they provided a non-existent flag.

If you need help migrating to the latest version, head over to core's README which has links to the migration guides. Feel free to open a new discussion if you need more hands-on help from us or the community.
ESM Support​
Version 3 of @oclif/core introduced full support for developing ESM plugins and CLIs. It also offered full support for interoperability between CommonJS and ESM plugins.
Put more simply, you can now migrate your CLI to ESM while keeping individual plugins in CommonJS (or vice versa). The upgrade path is now much simpler for you. You also don't need to worry about any community plugins that have migrated to ESM before you did (such as all the @oclif plugins) or are staunchly sticking with CommonJS for the foreseeable future.
Read more about this topic here.
Improving and Revitalizing oclif.io​
Another area of focus for us has been improving our documentation site, oclif.io.
While improving the quality and accuracy of the documentation was our priority, we also took the time to upgrade to the latest version of docusaurus. This new version gave our site a much-needed facelift, as well as cool new features such as dark mode and announcements.
If you have any feedback or are running into issues, we want to hear about it. Just create an issue in the oclif.io repo.
Re-engaging the oclif Community​
Lastly, our biggest priority at the moment is to re-engage the oclif community. We understand how frustrating it has been over the years to see your issues and pull requests go unacknowledged. We apologize for not prioritizing the community, and are earnestly trying to make sure that every issue and pull request gets the attention it deserves going forward.
We also opened up GitHub discussions for @oclif/core and the oclif CLI, where you can now post your questions or ideas. We hope you take advantage of them, we love hearing from you!
One last thing: we intend to publicly post our roadmap so you have more visibility into what we're working on. Stay tuned!
All our best,
The oclif teamAnnouncing oclif v2!January 12, 2022 · 5 min readHello and happy new year! It's our great pleasure to announce that we have released oclif v2, which uses the new @oclif/core library! 🎉
oclif v2 includes many changes that improve the experience of both creating and using an oclif CLI.
Going forward, we don't plan to make any updates to oclif v1 and its corresponding libraries, except for critical security fixes. See the compatibility matrix for a list of these libraries. In order to give developers time to migrate from v1 to v2, we're not completely dropping support yet. But at some point in the future we'll archive the v1 repositories and deprecate their versions on npm.
What’s changing?​
Repository Changes​
All repositories under the oclif org now use main as their primary branch and oclif-v1 as the legacy branch. The main  branch corresponds to oclif v2 and the oclif-v1 branch to oclif v1. If you find any repos that don’t have a main branch, you can safely assume that they're not used in oclif v2 and will be deprecated in the future.
Consolidating Tools & Libraries​
The oclif-dev CLI has now been incorporated into oclif. You now no longer need to install a separate package to manage your entire CLI’s lifecycle.
The following libraries have been consolidated under @oclif/core and will be deprecated at some point in the future. Read the migration guide to learn how to update your CLI or plugin to use the new core library.

@oclif/command
@oclif/config
@oclif/error
@oclif/help
@oclif/parser

No more single vs multi command CLIs​
There's only one "type" of oclif v2 CLI, but it can have as few or as many commands as a developer wants. As a result, there’s only one command to generate CLIs, oclif generate, as opposed to the old oclif single and oclif multi commands.
Node > 12​
To ensure oclif CLIs are as secure as possible, all v2 libraries and plugins support only Node 12 or higher as of now. Going forward, they'll support only Node Maintenance or higher, as defined by Node's release schedule here: https://nodejs.org/en/about/releases/.
What’s new?​
New example CLI​
oclif-hello-world is our new example repo. This is also the repo that's used as a template when running oclif generate to create a new CLI. This repo will always be able to be referenced as an example of what an oclif v2 CLI should look like.
Spaced commands​
oclif CLIs can now use spaces, instead of colons, to separate topics and subcommands. To enable this feature, simply add “topicSeparator": " " to the oclif config in your package.json. See an example in our example repo.
// Old commands that use :$ mycli do:something
// New spaced commands$ mycli do something

Note: Spaced commands are backwards compatible. So if you enable spaced commands for your CLI, users will still be able to use : as a separator. This ensures that any existing scripts don't break.

New Help Output​
We’ve revamped the way command help is outputted to the terminal, making it both easier to implement and easier to read. See the difference between the old help output on the left and the new help output on the right in the screenshots below.
oclif v1oclif v2
Notice that there are new sections for flags and global flags, examples are displayed with better spacing, and there is a section at the bottom called Configuration Variables. This Configuration Variables section is not part of the new help by default. But we've added support for custom help sections, which is what the sf CLI uses to create the new section.
Async Command Parsing​
We’ve also improved the performance of new CLIs by rewriting how commands are parsed on initialization. The new parser is asynchronous, which makes CLIs with a lot of commands or installed  plugins much faster.
What’s coming next?​
Part of our charter for the release of oclif v2 includes improving our engagement with the oclif community. We know that over the past couple of years we’ve reduced our involvement, and a lot of issues and PRs have languished in limbo. Hopefully you’ve already seen increased activity and responses from oclif maintainers recently, but if you haven’t, please don’t hesitate to ping us by tagging @admins in oclif repos.
We also want to start interviewing members of the oclif community to acquire feedback and prioritize the features and fixes you deem most important!
Best,
The oclif team

Reference material​
Migration Guide​
This guide explains how to upgrade a CLI or plugin from the old oclif v1 libraries to the new @oclif/core library that oclif v2 uses.
https://github.com/oclif/core/blob/main/MIGRATION.md
Compatibility Matrix​
The following matrix shows how the v1 libraries and plugins relate to the new v2 ones. Use this matrix as a guide to know what to drop and which versions to switch when upgrading your plugins and CLIs to v2.
oclif "v1"oclif "v2"Utility CLIsoclif@<2@oclif/dev-cli@<2oclif@>=2Main packages@oclif/command@oclif/config@oclif/errors@oclif/parser@oclif/plugin-help@oclif/core@>=1Node LTSNode v8-14Node v12+ (at time of writing)TypeScripttypescript@<4typescript@>=4Main plugins@oclif/plugin-autocomplete@<1@oclif/plugin-commands@<2@oclif/plugin-help@<4@oclif/plugin-not-found@<2@oclif/plugin-plugins@<2@oclif/plugin-update@<2plugin-warn-if-update-available@<2plugin-which@<2@oclif/plugin-autocomplete@>=1@oclif/plugin-commands@>=2@oclif/plugin-help@>=4@oclif/plugin-not-found@>=2@oclif/plugin-plugins@>=2@oclif/plugin-update@>=2@oclif/plugin-warn-if-update-available@>=2@oclif/plugin-which@>=2Introducing @oclif/coreMarch 1, 2021 · 3 min readGreetings!
We hope this blog post finds you well.
Introducing...​
We are excited to announce the next iteration of the oclif project today: @oclif/core.
We have learned a lot in the last three years of developing oclif, developing on oclif and supporting millions of command runs a day via Heroku and Salesforce CLIs.
@oclif/core ("Core") simplifies the oclif development experience and introduces highly requested new features.
Core combines the essential oclif packages into one "core" package, aptly named @oclif/core.
Core also introduces:

A default command option
Colon or space command syntax
Async command parsing
Command piping to arguments

With the introduction of default command functionality, Core simplifies the oclif project and removes the notion of single or multi command CLIs. Core CLIs can have 1 or many commands.
Along with Core, we moved the oclif-dev CLI into the oclif CLI creating a single "utility" CLI. This CLI also introduces a new AWS S3 compatible publishing scheme.
What to expect in the near future​
Core is in pre-release beta and being actively developed for new internal Salesforce CLIs.
Much documentation needs to be written in the coming months including migration paths. Migration onto Core should be as painless as possible with many exports remaining entirely unchanged. Look for forthcoming blog posts and documentation on oclif.io.
Early this summer, tentively June 1, we will release Core v1. Core's release will coincide with major bumps to many other oclif plugin packages. See the compatibility matrix below.
At Core's v1 release, the current "main" oclif packages (namely: command, config, errors & parser) will go into maintenance mode until Jan 2022. They will receive only bug and security fixes and they remain compatible with current versions of the oclif and oclif-dev CLIs. Afterwhich, they will be archived.
Companioning Core, the next major release of the oclif CLI (literally oclif@2) will generate Core CLIs.
Going forward​
We are excited to release Core! We invite you to poke around the Core repo. It may appear to be a big change but Core keeps what you already enjoy about oclif while reducing development complexity, project dependencies, package coupling and bundle size and introduces many requested features previously too prickly to weave into the current oclif architecture.
Best,
The oclif team
Reference: Compatibility matrix​
oclif "v1"oclif "Core"Utility CLIsoclif@<2@oclif/dev-cli@<2oclif@>=2Main packages@oclif/core@<2@oclif/config@<2@oclif/errors@<2@oclif/parser@<4@oclif/plugin-help@<4@oclif/core@>=1Node LTSNode v8-14Node v12+TypeScripttypescript@<4typescript@>=4Main plugins@oclif/plugin-autocomplete@<1@oclif/plugin-commands@<2@oclif/plugin-help@<4@oclif/plugin-not-found@<2@oclif/plugin-plugins@<2@oclif/plugin-update@<2plugin-warn-if-update-available@<2plugin-which@<2@oclif/plugin-autocomplete@>=2@oclif/plugin-commands@>=2@oclif/plugin-help@>=4@oclif/plugin-not-found@>=2@oclif/plugin-plugins@>=2@oclif/plugin-update@>=2@oclif/plugin-warn-if-update-available@>=2@oclif/plugin-which@>=2oclif Summer 2020 UpdateAugust 26, 2020 · 2 min readHello oclif developers! We hope you are all doing well.
Earlier this year, we started our planning for oclifconf v2 and, like all conference, had to change course. We opted not to hold a virtual conference, however, we wanted to take some time to highlight a few oclif features shipped this year.
Feature: Help templating​
One of the most requested features, help templating enables oclif developers to customize the help output for their CLI.
Read the announcement.
Feature: Custom error delegation​
This feature both improved how oclif throws and handles errors and allows oclif developers to overwrite or interject in oclif’s error handling.
Read the announcement.
Feature: postrun hooks​
We have added a new lifecycle event postrun. Your CLI can now run a hook after a command has ran.
See our hook documentation.
Feature: Root index command​
Previously, oclif would display CLI help if only the binary name with no command ID was invoked, oclif now supports a "root index" command. If present, a command defined at src/commands/index.ts will be run if no command ID is found.
1 million weekly downloads​
While exact oclif usage metrics are hard to pin down, we use npm download statistics of oclif packages as a rough approximation. Earlier this year, oclif's command package hit 1 million weekly downloads for the first time!
This year has been presented its challenges on everyone. We want to thank you, oclif developers, whom have taken the time to use and improve the oclif project. We look forward to seeing you all - in person - in the future!
All our best,
The oclif teamPretty Printable ErrorsJuly 1, 2020 · One min readOften CLIs are used as handy tools and when things go wrong it’s useful to have additional context. In oclif we have added a couple of additional properties that can show extra context to the users when an error is displayed. The code, ref and suggestions will now be displayed if they are included. This will work with an existing oclif CLI by adding the latest @oclif/errors and @oclif/core to the CLI's package.json dependencies.
For example, using this.error with the additional properties:
class TestError extends Command {  async run() {    this.error("An error has occurred!", {      code: "OCLIF_ERR",      ref: "https://oclif.io/docs/commands#thiserrormessage-string--error-options-code-string-exit-number",      suggestions: ["Use these extra properties to provide additional context"],    })  }}
would result with the following output:
›   Error: An error has occurred!›   Code: OCLIF_ERR›   Try this: Use these extra properties to provide additional context›   Reference: https://oclif.io/docs/commands#thiserrormessage-string--error-options-code-string-exit-number
If these properties are not provided then nothing changes and the CLI will continue to display the single error message output as it did before. Additionally, as part of this exercise we’ve added documentation around Error Handling in oclif which should come in handy if the need arises to extend oclif’s default handling of errors.Customizing Help in oclifMay 5, 2020 · 2 min readOut of the box oclif provides a great help experience for CLIs.
But what if, as an oclif developer, you want to customize some or all of the output?
You can now customize your CLI's help output by implementing the HelpBase abstract class.
Getting started with custom help​
If you have not done so yet, update @oclif/core.
$ yarn add --latest @oclif/core
To get started, first define the filepath to your help class in oclif's config in package.json. This is a relative path to the help class, without a file extension.
For this example, the help class will be created in a file at "[project root]/src/help.ts".
{  // ...  "oclif": {    "helpClass": "./lib/help"    // ...  }  // ...}
From here there are two paths, implement the HelpBase abstract class yourself or overwrite the parts of the default Help class you want to customize (ex: how command usage is displayed). We recommend the latter approach but cover both in the new Help Classes docs.
Separating TOPICS & COMMANDS in the new default Help class​
Previously, topics and child commands were listed in help output under a single list heading called "COMMANDS". But we found this can be slightly confusing. Some topics are commands also (a.k.a. topic-commands) while others are simply organizational namespacing (and when ran just show their help).
The new default Help class splits the list of children into distinct lists of "TOPICS" and "COMMANDS", with the possibility of an item appearing in both if it a topic-command. This makes it clearer what is expected to be ran - "COMMANDS" - and what is providing structure - "TOPICS" - when looking at the help output.
VERSION  plugin-help-example/0.0.0 darwin-x64 node-v12.12.0USAGE  $ plugin-help-example [COMMAND]TOPICS  topic  this is a topic and has child topics or commandsCOMMANDS  hello  describe the command here  help   display help for plugin-help-example
We look forward to seeing what custom help features you implement in your oclif CLIs with this new feature!oclif TSLint to ESLint MigrationDecember 5, 2019 · 3 min readBack in February of this year, plans were announced to deprecate TSLint in favor of ESLint. TSLint's goal has become to work toward a “unified developer experience” by supporting ESLint development going forward.
What has changed in oclif​
To keep inline with the community, oclif has transitioned to ESLint for all our core libraries as well as all our official plugins.
Starting in v1.15.x, oclif will now optionally generate projects with ESLint for both TypeScript and JavaScript CLI’s.
ESLint does require Node to be on stable LTS version, at the time of writing, Node 8.10.x, Node 10.13.x & Node 12.x.x.
How does this affect you​
Existing CLI’s are unchanged, but any newly generated CLI's will only give the option of using ESLint. If you are running tslint in your CLI, we recommend you switch to ESLint as well.
In migrating our projects we took the following steps (for an example of these changes see this pull request).


Install eslint
$ yarn add eslint eslint-config-oclif eslint-config-oclif-typescript --dev


Add eslint related files


$ echo '{  "extends": [    "oclif",    "oclif-typescript"  ],  "rules": {  }}' > .eslintrc


Remove tslint and related packages
$ yarn remove @oclif/tslint tslint


Remove tslint related configuration files
$ rm tslint.json


Change lint script in our package.json from something like:
"lint": "tsc -p test --noEmit && tslint -p test -t stylish"
to
"lint": "eslint . --ext .ts --config .eslintrc"


To preserve the test compile (tsc -p test --noEmit) we also made the following updates to our scripts:
"pretest": "tsc -p test --noEmit"
In some cases we had our posttest duplicating the same steps as our lint script so it’s cleaner to have it reference the lint job directly with:
"posttest": "yarn lint"

Run yarn lint --fix. This attempts to auto-fix any linting violations automatically. In the case an auto-fix isn’t available it should be fixed manually or ignored (see the eslint configuration doc for more information)
Do a search in the codebase for tslint and remove any unnecessary tslint disabling comments, like:

/* tslint:disable:object-literal-sort-keys */
If you are on a version of Node that is not supported by ESLint, you will also need to update your Node engine. ESLint supports Node 8, 10, and 12 so you should upgrade to the most recent Node version compatible with your CLI and also supported by ESLint (see ESLint's Installation and Usage instructions).
When will this take effect​
These changes have taken effect in oclif v1.15.1. When you generate a new CLI or plugin it will now contain configuration for ESLint instead of TSLint.oclif's Current Node SupportOctober 31, 2019 · 3 min readTo maintain a healthy project trajectory, oclif follows and supports Node Active LTS release, currently Node 10 & Node 12. This means ensuring that oclif continues to play nice with coming Active LTS Node versions and other packages in the ecosystem. Moving forward also means leaving older versions behind. Starting in 2020, Node will stop maintaining Node 8 and it is our intent at that time to also follow suit. Let’s take a look at a few ways we will be supporting these changes.
CI Environments​
CLIs created with the oclif cli going forward will be generated with a CircleCI configuration with Node 10 & 12 and an Appveyor configuration using Node 10. We have also added Node latest to CircleCi to be an early warning detection against coming Node changes (Node latest is managed by CircleCI).
We have already updated every oclif repo's CI configs to reflect this.
If your existing CLI uses either Appveyor or CircleCI you can update your config files also, like so:
.circleci/config.yml​
Your CircleCI config should contain a node-latest job, aliased as test. From this, there should be two extensions of this job for the Active LTS Node versions, Node 10 and Node 12.
  node-10:    <<: *node-latest    docker:      - image: node:10  node-12:    <<: *node-latest    docker:      - image: node:12
Notice that these declarations only change the Docker Node images used to run that job.
Additionally, the jobs listed within workflows must also be updated to reflect our changes in configuration:
    jobs:      - node-latest      - node-10      - node-12
appveyor.yml​
For appveyor we are currently only testing the oldest Active LTS Node version, Node 10. Update the nodejs_version proppert in your appveyor.yml file to reflect this.
environment:  nodejs_version: "10"
Deprecating Node 8 & Updating packge.json engines​
In Jan 2020, Node will end its Node 8 maintenance. We will follow suit by setting the package.json engine property in oclif packages to >=10 and bumping the package's major versions.
Depending on how you ship your CLI you may wish to also bump the engines version in your CLI's package.json. You can read more about the implications of the engines property configuration in the npm documentation.
Also consider distributing your CLI with its own Node version.
Packaged Node Version​
When using dev-cli to pack your CLI it will use the Node version as specified in your package.json under the oclif.update.node.version property. This value should reflect an Active LTS Node version (dev-cli does not currently enforce versions).
Supporting the future​
As a community we may discover bumps along the way as we upgrade. If you notice something related to oclif please feel free to open an issue or submit a pull request under the relevant oclif package within the org.
We look forward to using the latest from Node and the community and keeping oclif healthy along the way.oclifconf 2019: A RecapSeptember 16, 2019 · 4 min readIn May, Heroku and Salesforce Open Source organized oclifconf, a conference for developers & product managers building CLI tools on top of the open source oclif framework. The speakers came from various tech companies, such as Adobe, Netlify, and Apollo, who have already built amazing CLI experiences. The topics covered everything from the incredible capabilities oclif has unlocked, to the community-built plugins extending its functionality, and even what the behavior of an adaptive CLI tool might look like.
Below is a listing of all of the talks from the event, along with a short summary. Enjoy!
The future of oclif by Jeff Dickey​

In its relatively short lifetime, oclif has already inspired many developers and companies to adopt its framework as a means for implementing their own command-line tooling. In this talk, Jeff Dickey, an oclif founding team member, recaps the project's history and inspiration. He also looks towards the future and outlines some features and improvements that the tool could adapt. This isn't so much a definitive roadmap of where oclif is headed, but rather, a call to inspiration for developers eager to contribute! And if you are interested in contributing, check out the open issues in the oclif GitHub repo and come say "Hello!" on Spectrum Chat.
Open Source Citizenship by Josh Simmons​

When it comes to open source, it's more than just individuals now. More and more frequently, large corporations are contributing to projects by donating to contributors, sponsoring events, or upstreaming contributions. But keeping open source projects and communities healthy requires more than just money and brainpower. Josh Simmons surveyed multiple open source communities and relays his findings as to what help maintainers and contributors actually need in this talk.
Building an enterprise-grade CLI with oclif by Thomas Dvornik​

Security and performance are all about trust. While oclif is an extremely extensible framework for building CLI tooling, there are additional requirements to fulfill for enterprise businesses to adopt it that might not be necessary for individual developers. Thomas Dvornik outlines what he and his colleagues at Salesforce have implemented as plugins to oclif to satisfy these needs, including encrypted OAuth, plugin signing, lazy loading dependencies, synchronizing weekly releases and deprecations across dozens of repositories, and establishing cross-team coding and documentation standards.
How Adobe I/O built an extensible CLI with oclif by Jesse MacFadyen​

Perhaps oclif's most appealing feature is its support for plugins. In Cordova's case, they've created a sophisticated telemetry system that helps Adobe developers see which commands users are using--and reports on which ones are erroring out. By embedding a feedback system into the tool, users are even able to quickly send their suggestions to a form, without ever leaving the terminal. Jesse MacFadyen demonstrates how oclif's plugin system can work beyond simply executing commands.
Integrating oclif with GraphQL and Apollo by Evans Hauser​

For Evans Hauser and the team at Apollo, oclif is best thought of as "React for the CLI." As a client paired with a strongly-typed API contract to a server, it can deliver structured and consistent commands to retrieve external data. What better mechanism to use for this transfer than GraphQL, a framework which empowers the client to ask precisely for the data it needs, and nothing more?
Adaptive Intent-based CLI State Machines by Shawn Wang​

In designing oclif, Jeff Dickey wrote out 12 CLI factors to keep in mind. In this talk, Shawn Wang outlines a 13th: state. State is hard, because it depends on context, and context depends on understanding what a user intends to do, not what they are asking. Shawn is working towards enabling oclif to better understand the commands a user has entered, so that it can predict and interpret future commands that might be entered next. This would enable CLI tools to not just interpret a users' commands, but to also interpret their intent.Older Entries\n\n\n\nGuidesError HandlingOn this pageError Handlingoclif handles intentionally - and unintentionally - thrown errors in two places. First in the Command.catch method and then, finally, in the bin/run.js catch handler where the Error is printed and the CLI exits. This error flow makes it possible for you to control and respond to errors that occur in your CLI as you see fit.
Error Handling in the catch method​
Every Command instance has a catch method that is called when an error occurs throughout the course of a command run. This method handles the edge case of users asking for help or version output, if applicable, otherwise, it re-throws the error. You can extend or overwrite the catch method in your command class.
import {Command, flags} from '@oclif/core'export default class Hello extends Command {  async catch(error) {    // do something or    // re-throw to be handled globally    throw error;  }}
If this type of error handling is being implemented across multiple commands consider using a Custom Base Class for your commands and overriding the catch method.
bin/run.js catch handler​
Every oclif CLI has a ./bin/run.js file that is the entry point of command invocation. Errors that occur in the CLI, including re-thrown errors from a Command, are caught and handled by oclif's handle function, which displays the error to the user.
If you generated your CLI using oclif generate, then you will see an execute function that's responsible for running the CLI and catching any errors. You can, however, implement this yourself if you need to customize the error handling.
Here's the generic bin/run.js that comes with oclif generate:
#!/usr/bin/env nodeimport {execute} from '@oclif/core'await execute({dir: import.meta.url})
To customize error handling, you'll want to use oclif's run function instead of execute:
#!/usr/bin/env nodeimport {run, handle, flush} from '@oclif/core'await run(process.argv.slice(2), import.meta.url)  .catch(async (error) => handle(error))  .finally(async () => flush())
The catch handler can be swapped for any function that receives an error argument. If you chose to implement your own handler here, we still recommend you delegate finally to the handle function for clean-up and exiting logic.
.catch((error) => {  // do any extra work with error  return handle(error);})Edit this pageLast updated on Dec 20, 2024 by Mike Donnalley\n\nGuidesError HandlingOn this pageError Handlingoclif handles intentionally - and unintentionally - thrown errors in two places. First in the Command.catch method and then, finally, in the bin/run.js catch handler where the Error is printed and the CLI exits. This error flow makes it possible for you to control and respond to errors that occur in your CLI as you see fit.
Error Handling in the catch method​
Every Command instance has a catch method that is called when an error occurs throughout the course of a command run. This method handles the edge case of users asking for help or version output, if applicable, otherwise, it re-throws the error. You can extend or overwrite the catch method in your command class.
import {Command, flags} from '@oclif/core'export default class Hello extends Command {  async catch(error) {    // do something or    // re-throw to be handled globally    throw error;  }}
If this type of error handling is being implemented across multiple commands consider using a Custom Base Class for your commands and overriding the catch method.
bin/run.js catch handler​
Every oclif CLI has a ./bin/run.js file that is the entry point of command invocation. Errors that occur in the CLI, including re-thrown errors from a Command, are caught and handled by oclif's handle function, which displays the error to the user.
If you generated your CLI using oclif generate, then you will see an execute function that's responsible for running the CLI and catching any errors. You can, however, implement this yourself if you need to customize the error handling.
Here's the generic bin/run.js that comes with oclif generate:
#!/usr/bin/env nodeimport {execute} from '@oclif/core'await execute({dir: import.meta.url})
To customize error handling, you'll want to use oclif's run function instead of execute:
#!/usr/bin/env nodeimport {run, handle, flush} from '@oclif/core'await run(process.argv.slice(2), import.meta.url)  .catch(async (error) => handle(error))  .finally(async () => flush())
The catch handler can be swapped for any function that receives an error argument. If you chose to implement your own handler here, we still recommend you delegate finally to the handle function for clean-up and exiting logic.
.catch((error) => {  // do any extra work with error  return handle(error);})Edit this pageLast updated on Dec 20, 2024 by Mike DonnalleyPreviousDebuggingNextESMError Handling in the catch methodbin/run.js catch handler\n\n\n\nIntroducing `oclif init` commandApril 10, 2024 · 2 min readThanks to the contribution of @joshcanhelp we released a new command for the oclif CLI called oclif init in version 4.8.0
The oclif init command allows you to initialize oclif in an existing project directory by adding the bare minimum requirements: a few pieces of configuration, bin scripts, and a couple of dependencies (@oclif/core and ts-node). This is slightly different from oclif generate, which will create an entirely new oclif project based on our templates.
oclif init will add the following:

bin scripts: bin/run.js, bin/run.cmd, bin/dev.js, and bin/dev.cmd
oclif section to package.json with bin, dirname, commands, and topicSeparator set (See Configuring Your CLI for more)
@oclif/core to dependencies in your package.json (if it's not already there)
ts-node to devDependencies in your package.json (if it's not already there)

Once you've initialized oclif, you can use the bin scripts to execute your CLI. You can also use the other oclif commands like oclif generate command and oclif generate hook to start adding new functionality.

❯ oclif init --helpInitialize a new oclif CLIUSAGE  $ oclif init [--bin <value>] [--module-type ESM|CommonJS] [--package-manager npm|yarn|pnpm] [--topic-separator    colons|spaces] [-d <value>] [-y]FLAGS  -d, --output-dir=<value>        Directory to initialize the CLI in.  -y, --yes                       Use defaults for all prompts. Individual flags will override defaults.      --bin=<value>               Supply answer for prompt: Command bin name the CLI will export      --module-type=<option>      Supply answer for prompt: Select a module type                                  <options: ESM|CommonJS>      --package-manager=<option>  Supply answer for prompt: Select a package manager                                  <options: npm|yarn|pnpm>      --topic-separator=<option>  Supply answer for prompt: Select a topic separator                                  <options: colons|spaces>DESCRIPTION  Initialize a new oclif CLI  This will add the necessary oclif bin files, add oclif config to package.json, and install @oclif/core and ts-node.EXAMPLES  Initialize a new CLI in the current directory    $ oclif init  Initialize a new CLI in a different directory    $ oclif init --output-dir "/path/to/existing/project"  Supply answers for specific prompts    $ oclif init --topic-separator colons --bin mycli
Hope you enjoy the new command! If you come across any issues or have any new ideas for this command, head over to the oclif/oclif repo and open a new issue.
All our best,
The oclif teamoclif Spring 2024 UpdateMarch 29, 2024 · 4 min readHello oclif developers! It's been a while since we last uploaded a blog - and a lot has happened.
We've been focusing on these high-level areas over the past couple of years:

Improving @oclif/core
ESM Support
Improving and revitalizing oclif.io
Re-engaging the oclif community

Improving @oclif/core​
Since we announced @oclif/core over three years ago, we've released two new major versions, each packed with lots of features that we're really excited about.
Here are some of these changes:

Full support for ESM and interoperability with CommonJS (more on this topic below).
Configurable command discovery strategies that give you more control over how commands are loaded at runtime. Check out the docs.
A new preparse hook that allows you to manipulate the provided arguments before they're parsed. Salesforce used this hook to implement a neat --flags-dir feature that translates local files into flags.
A new Performance class that you can use to track performance inside of @oclif/core and your own CLI or plugin. Check out the docs.
A new flag type, Flags.option, that lets you define a flag with a preset list of options. Typescript then uses the options to infer the flag's type.
Flags now have a relationship property that allows you to define more complex relationships between flags. Check out the flags docs for more information.
Flags now have a defaultHelp property that allows you to set the human readable default value in the command help. This property is useful when your flag's parse method returns a complex type, such as an object or a class. Check out the flags docs for more.
Commands now have a hiddenAliases property that allows you to define aliases that you want to hide from the user. The property is super helpful when you're trying to wean users off a deprecated command.
You can now use bun or tsx as dev runtimes (as opposed to node or ts-node).
A command's usage, args, and flags are now shown whenever a user forgets to provide a required arg or flag, or when they provided a non-existent flag.

If you need help migrating to the latest version, head over to core's README which has links to the migration guides. Feel free to open a new discussion if you need more hands-on help from us or the community.
ESM Support​
Version 3 of @oclif/core introduced full support for developing ESM plugins and CLIs. It also offered full support for interoperability between CommonJS and ESM plugins.
Put more simply, you can now migrate your CLI to ESM while keeping individual plugins in CommonJS (or vice versa). The upgrade path is now much simpler for you. You also don't need to worry about any community plugins that have migrated to ESM before you did (such as all the @oclif plugins) or are staunchly sticking with CommonJS for the foreseeable future.
Read more about this topic here.
Improving and Revitalizing oclif.io​
Another area of focus for us has been improving our documentation site, oclif.io.
While improving the quality and accuracy of the documentation was our priority, we also took the time to upgrade to the latest version of docusaurus. This new version gave our site a much-needed facelift, as well as cool new features such as dark mode and announcements.
If you have any feedback or are running into issues, we want to hear about it. Just create an issue in the oclif.io repo.
Re-engaging the oclif Community​
Lastly, our biggest priority at the moment is to re-engage the oclif community. We understand how frustrating it has been over the years to see your issues and pull requests go unacknowledged. We apologize for not prioritizing the community, and are earnestly trying to make sure that every issue and pull request gets the attention it deserves going forward.
We also opened up GitHub discussions for @oclif/core and the oclif CLI, where you can now post your questions or ideas. We hope you take advantage of them, we love hearing from you!
One last thing: we intend to publicly post our roadmap so you have more visibility into what we're working on. Stay tuned!
All our best,
The oclif teamAnnouncing oclif v2!January 12, 2022 · 5 min readHello and happy new year! It's our great pleasure to announce that we have released oclif v2, which uses the new @oclif/core library! 🎉
oclif v2 includes many changes that improve the experience of both creating and using an oclif CLI.
Going forward, we don't plan to make any updates to oclif v1 and its corresponding libraries, except for critical security fixes. See the compatibility matrix for a list of these libraries. In order to give developers time to migrate from v1 to v2, we're not completely dropping support yet. But at some point in the future we'll archive the v1 repositories and deprecate their versions on npm.
What’s changing?​
Repository Changes​
All repositories under the oclif org now use main as their primary branch and oclif-v1 as the legacy branch. The main  branch corresponds to oclif v2 and the oclif-v1 branch to oclif v1. If you find any repos that don’t have a main branch, you can safely assume that they're not used in oclif v2 and will be deprecated in the future.
Consolidating Tools & Libraries​
The oclif-dev CLI has now been incorporated into oclif. You now no longer need to install a separate package to manage your entire CLI’s lifecycle.
The following libraries have been consolidated under @oclif/core and will be deprecated at some point in the future. Read the migration guide to learn how to update your CLI or plugin to use the new core library.

@oclif/command
@oclif/config
@oclif/error
@oclif/help
@oclif/parser

No more single vs multi command CLIs​
There's only one "type" of oclif v2 CLI, but it can have as few or as many commands as a developer wants. As a result, there’s only one command to generate CLIs, oclif generate, as opposed to the old oclif single and oclif multi commands.
Node > 12​
To ensure oclif CLIs are as secure as possible, all v2 libraries and plugins support only Node 12 or higher as of now. Going forward, they'll support only Node Maintenance or higher, as defined by Node's release schedule here: https://nodejs.org/en/about/releases/.
What’s new?​
New example CLI​
oclif-hello-world is our new example repo. This is also the repo that's used as a template when running oclif generate to create a new CLI. This repo will always be able to be referenced as an example of what an oclif v2 CLI should look like.
Spaced commands​
oclif CLIs can now use spaces, instead of colons, to separate topics and subcommands. To enable this feature, simply add “topicSeparator": " " to the oclif config in your package.json. See an example in our example repo.
// Old commands that use :$ mycli do:something
// New spaced commands$ mycli do something

Note: Spaced commands are backwards compatible. So if you enable spaced commands for your CLI, users will still be able to use : as a separator. This ensures that any existing scripts don't break.

New Help Output​
We’ve revamped the way command help is outputted to the terminal, making it both easier to implement and easier to read. See the difference between the old help output on the left and the new help output on the right in the screenshots below.
oclif v1oclif v2
Notice that there are new sections for flags and global flags, examples are displayed with better spacing, and there is a section at the bottom called Configuration Variables. This Configuration Variables section is not part of the new help by default. But we've added support for custom help sections, which is what the sf CLI uses to create the new section.
Async Command Parsing​
We’ve also improved the performance of new CLIs by rewriting how commands are parsed on initialization. The new parser is asynchronous, which makes CLIs with a lot of commands or installed  plugins much faster.
What’s coming next?​
Part of our charter for the release of oclif v2 includes improving our engagement with the oclif community. We know that over the past couple of years we’ve reduced our involvement, and a lot of issues and PRs have languished in limbo. Hopefully you’ve already seen increased activity and responses from oclif maintainers recently, but if you haven’t, please don’t hesitate to ping us by tagging @admins in oclif repos.
We also want to start interviewing members of the oclif community to acquire feedback and prioritize the features and fixes you deem most important!
Best,
The oclif team

Reference material​
Migration Guide​
This guide explains how to upgrade a CLI or plugin from the old oclif v1 libraries to the new @oclif/core library that oclif v2 uses.
https://github.com/oclif/core/blob/main/MIGRATION.md
Compatibility Matrix​
The following matrix shows how the v1 libraries and plugins relate to the new v2 ones. Use this matrix as a guide to know what to drop and which versions to switch when upgrading your plugins and CLIs to v2.
oclif "v1"oclif "v2"Utility CLIsoclif@<2@oclif/dev-cli@<2oclif@>=2Main packages@oclif/command@oclif/config@oclif/errors@oclif/parser@oclif/plugin-help@oclif/core@>=1Node LTSNode v8-14Node v12+ (at time of writing)TypeScripttypescript@<4typescript@>=4Main plugins@oclif/plugin-autocomplete@<1@oclif/plugin-commands@<2@oclif/plugin-help@<4@oclif/plugin-not-found@<2@oclif/plugin-plugins@<2@oclif/plugin-update@<2plugin-warn-if-update-available@<2plugin-which@<2@oclif/plugin-autocomplete@>=1@oclif/plugin-commands@>=2@oclif/plugin-help@>=4@oclif/plugin-not-found@>=2@oclif/plugin-plugins@>=2@oclif/plugin-update@>=2@oclif/plugin-warn-if-update-available@>=2@oclif/plugin-which@>=2Introducing @oclif/coreMarch 1, 2021 · 3 min readGreetings!
We hope this blog post finds you well.
Introducing...​
We are excited to announce the next iteration of the oclif project today: @oclif/core.
We have learned a lot in the last three years of developing oclif, developing on oclif and supporting millions of command runs a day via Heroku and Salesforce CLIs.
@oclif/core ("Core") simplifies the oclif development experience and introduces highly requested new features.
Core combines the essential oclif packages into one "core" package, aptly named @oclif/core.
Core also introduces:

A default command option
Colon or space command syntax
Async command parsing
Command piping to arguments

With the introduction of default command functionality, Core simplifies the oclif project and removes the notion of single or multi command CLIs. Core CLIs can have 1 or many commands.
Along with Core, we moved the oclif-dev CLI into the oclif CLI creating a single "utility" CLI. This CLI also introduces a new AWS S3 compatible publishing scheme.
What to expect in the near future​
Core is in pre-release beta and being actively developed for new internal Salesforce CLIs.
Much documentation needs to be written in the coming months including migration paths. Migration onto Core should be as painless as possible with many exports remaining entirely unchanged. Look for forthcoming blog posts and documentation on oclif.io.
Early this summer, tentively June 1, we will release Core v1. Core's release will coincide with major bumps to many other oclif plugin packages. See the compatibility matrix below.
At Core's v1 release, the current "main" oclif packages (namely: command, config, errors & parser) will go into maintenance mode until Jan 2022. They will receive only bug and security fixes and they remain compatible with current versions of the oclif and oclif-dev CLIs. Afterwhich, they will be archived.
Companioning Core, the next major release of the oclif CLI (literally oclif@2) will generate Core CLIs.
Going forward​
We are excited to release Core! We invite you to poke around the Core repo. It may appear to be a big change but Core keeps what you already enjoy about oclif while reducing development complexity, project dependencies, package coupling and bundle size and introduces many requested features previously too prickly to weave into the current oclif architecture.
Best,
The oclif team
Reference: Compatibility matrix​
oclif "v1"oclif "Core"Utility CLIsoclif@<2@oclif/dev-cli@<2oclif@>=2Main packages@oclif/core@<2@oclif/config@<2@oclif/errors@<2@oclif/parser@<4@oclif/plugin-help@<4@oclif/core@>=1Node LTSNode v8-14Node v12+TypeScripttypescript@<4typescript@>=4Main plugins@oclif/plugin-autocomplete@<1@oclif/plugin-commands@<2@oclif/plugin-help@<4@oclif/plugin-not-found@<2@oclif/plugin-plugins@<2@oclif/plugin-update@<2plugin-warn-if-update-available@<2plugin-which@<2@oclif/plugin-autocomplete@>=2@oclif/plugin-commands@>=2@oclif/plugin-help@>=4@oclif/plugin-not-found@>=2@oclif/plugin-plugins@>=2@oclif/plugin-update@>=2@oclif/plugin-warn-if-update-available@>=2@oclif/plugin-which@>=2oclif Summer 2020 UpdateAugust 26, 2020 · 2 min readHello oclif developers! We hope you are all doing well.
Earlier this year, we started our planning for oclifconf v2 and, like all conference, had to change course. We opted not to hold a virtual conference, however, we wanted to take some time to highlight a few oclif features shipped this year.
Feature: Help templating​
One of the most requested features, help templating enables oclif developers to customize the help output for their CLI.
Read the announcement.
Feature: Custom error delegation​
This feature both improved how oclif throws and handles errors and allows oclif developers to overwrite or interject in oclif’s error handling.
Read the announcement.
Feature: postrun hooks​
We have added a new lifecycle event postrun. Your CLI can now run a hook after a command has ran.
See our hook documentation.
Feature: Root index command​
Previously, oclif would display CLI help if only the binary name with no command ID was invoked, oclif now supports a "root index" command. If present, a command defined at src/commands/index.ts will be run if no command ID is found.
1 million weekly downloads​
While exact oclif usage metrics are hard to pin down, we use npm download statistics of oclif packages as a rough approximation. Earlier this year, oclif's command package hit 1 million weekly downloads for the first time!
This year has been presented its challenges on everyone. We want to thank you, oclif developers, whom have taken the time to use and improve the oclif project. We look forward to seeing you all - in person - in the future!
All our best,
The oclif teamPretty Printable ErrorsJuly 1, 2020 · One min readOften CLIs are used as handy tools and when things go wrong it’s useful to have additional context. In oclif we have added a couple of additional properties that can show extra context to the users when an error is displayed. The code, ref and suggestions will now be displayed if they are included. This will work with an existing oclif CLI by adding the latest @oclif/errors and @oclif/core to the CLI's package.json dependencies.
For example, using this.error with the additional properties:
class TestError extends Command {  async run() {    this.error("An error has occurred!", {      code: "OCLIF_ERR",      ref: "https://oclif.io/docs/commands#thiserrormessage-string--error-options-code-string-exit-number",      suggestions: ["Use these extra properties to provide additional context"],    })  }}
would result with the following output:
›   Error: An error has occurred!›   Code: OCLIF_ERR›   Try this: Use these extra properties to provide additional context›   Reference: https://oclif.io/docs/commands#thiserrormessage-string--error-options-code-string-exit-number
If these properties are not provided then nothing changes and the CLI will continue to display the single error message output as it did before. Additionally, as part of this exercise we’ve added documentation around Error Handling in oclif which should come in handy if the need arises to extend oclif’s default handling of errors.Customizing Help in oclifMay 5, 2020 · 2 min readOut of the box oclif provides a great help experience for CLIs.
But what if, as an oclif developer, you want to customize some or all of the output?
You can now customize your CLI's help output by implementing the HelpBase abstract class.
Getting started with custom help​
If you have not done so yet, update @oclif/core.
$ yarn add --latest @oclif/core
To get started, first define the filepath to your help class in oclif's config in package.json. This is a relative path to the help class, without a file extension.
For this example, the help class will be created in a file at "[project root]/src/help.ts".
{  // ...  "oclif": {    "helpClass": "./lib/help"    // ...  }  // ...}
From here there are two paths, implement the HelpBase abstract class yourself or overwrite the parts of the default Help class you want to customize (ex: how command usage is displayed). We recommend the latter approach but cover both in the new Help Classes docs.
Separating TOPICS & COMMANDS in the new default Help class​
Previously, topics and child commands were listed in help output under a single list heading called "COMMANDS". But we found this can be slightly confusing. Some topics are commands also (a.k.a. topic-commands) while others are simply organizational namespacing (and when ran just show their help).
The new default Help class splits the list of children into distinct lists of "TOPICS" and "COMMANDS", with the possibility of an item appearing in both if it a topic-command. This makes it clearer what is expected to be ran - "COMMANDS" - and what is providing structure - "TOPICS" - when looking at the help output.
VERSION  plugin-help-example/0.0.0 darwin-x64 node-v12.12.0USAGE  $ plugin-help-example [COMMAND]TOPICS  topic  this is a topic and has child topics or commandsCOMMANDS  hello  describe the command here  help   display help for plugin-help-example
We look forward to seeing what custom help features you implement in your oclif CLIs with this new feature!oclif TSLint to ESLint MigrationDecember 5, 2019 · 3 min readBack in February of this year, plans were announced to deprecate TSLint in favor of ESLint. TSLint's goal has become to work toward a “unified developer experience” by supporting ESLint development going forward.
What has changed in oclif​
To keep inline with the community, oclif has transitioned to ESLint for all our core libraries as well as all our official plugins.
Starting in v1.15.x, oclif will now optionally generate projects with ESLint for both TypeScript and JavaScript CLI’s.
ESLint does require Node to be on stable LTS version, at the time of writing, Node 8.10.x, Node 10.13.x & Node 12.x.x.
How does this affect you​
Existing CLI’s are unchanged, but any newly generated CLI's will only give the option of using ESLint. If you are running tslint in your CLI, we recommend you switch to ESLint as well.
In migrating our projects we took the following steps (for an example of these changes see this pull request).


Install eslint
$ yarn add eslint eslint-config-oclif eslint-config-oclif-typescript --dev


Add eslint related files


$ echo '{  "extends": [    "oclif",    "oclif-typescript"  ],  "rules": {  }}' > .eslintrc


Remove tslint and related packages
$ yarn remove @oclif/tslint tslint


Remove tslint related configuration files
$ rm tslint.json


Change lint script in our package.json from something like:
"lint": "tsc -p test --noEmit && tslint -p test -t stylish"
to
"lint": "eslint . --ext .ts --config .eslintrc"


To preserve the test compile (tsc -p test --noEmit) we also made the following updates to our scripts:
"pretest": "tsc -p test --noEmit"
In some cases we had our posttest duplicating the same steps as our lint script so it’s cleaner to have it reference the lint job directly with:
"posttest": "yarn lint"

Run yarn lint --fix. This attempts to auto-fix any linting violations automatically. In the case an auto-fix isn’t available it should be fixed manually or ignored (see the eslint configuration doc for more information)
Do a search in the codebase for tslint and remove any unnecessary tslint disabling comments, like:

/* tslint:disable:object-literal-sort-keys */
If you are on a version of Node that is not supported by ESLint, you will also need to update your Node engine. ESLint supports Node 8, 10, and 12 so you should upgrade to the most recent Node version compatible with your CLI and also supported by ESLint (see ESLint's Installation and Usage instructions).
When will this take effect​
These changes have taken effect in oclif v1.15.1. When you generate a new CLI or plugin it will now contain configuration for ESLint instead of TSLint.oclif's Current Node SupportOctober 31, 2019 · 3 min readTo maintain a healthy project trajectory, oclif follows and supports Node Active LTS release, currently Node 10 & Node 12. This means ensuring that oclif continues to play nice with coming Active LTS Node versions and other packages in the ecosystem. Moving forward also means leaving older versions behind. Starting in 2020, Node will stop maintaining Node 8 and it is our intent at that time to also follow suit. Let’s take a look at a few ways we will be supporting these changes.
CI Environments​
CLIs created with the oclif cli going forward will be generated with a CircleCI configuration with Node 10 & 12 and an Appveyor configuration using Node 10. We have also added Node latest to CircleCi to be an early warning detection against coming Node changes (Node latest is managed by CircleCI).
We have already updated every oclif repo's CI configs to reflect this.
If your existing CLI uses either Appveyor or CircleCI you can update your config files also, like so:
.circleci/config.yml​
Your CircleCI config should contain a node-latest job, aliased as test. From this, there should be two extensions of this job for the Active LTS Node versions, Node 10 and Node 12.
  node-10:    <<: *node-latest    docker:      - image: node:10  node-12:    <<: *node-latest    docker:      - image: node:12
Notice that these declarations only change the Docker Node images used to run that job.
Additionally, the jobs listed within workflows must also be updated to reflect our changes in configuration:
    jobs:      - node-latest      - node-10      - node-12
appveyor.yml​
For appveyor we are currently only testing the oldest Active LTS Node version, Node 10. Update the nodejs_version proppert in your appveyor.yml file to reflect this.
environment:  nodejs_version: "10"
Deprecating Node 8 & Updating packge.json engines​
In Jan 2020, Node will end its Node 8 maintenance. We will follow suit by setting the package.json engine property in oclif packages to >=10 and bumping the package's major versions.
Depending on how you ship your CLI you may wish to also bump the engines version in your CLI's package.json. You can read more about the implications of the engines property configuration in the npm documentation.
Also consider distributing your CLI with its own Node version.
Packaged Node Version​
When using dev-cli to pack your CLI it will use the Node version as specified in your package.json under the oclif.update.node.version property. This value should reflect an Active LTS Node version (dev-cli does not currently enforce versions).
Supporting the future​
As a community we may discover bumps along the way as we upgrade. If you notice something related to oclif please feel free to open an issue or submit a pull request under the relevant oclif package within the org.
We look forward to using the latest from Node and the community and keeping oclif healthy along the way.oclifconf 2019: A RecapSeptember 16, 2019 · 4 min readIn May, Heroku and Salesforce Open Source organized oclifconf, a conference for developers & product managers building CLI tools on top of the open source oclif framework. The speakers came from various tech companies, such as Adobe, Netlify, and Apollo, who have already built amazing CLI experiences. The topics covered everything from the incredible capabilities oclif has unlocked, to the community-built plugins extending its functionality, and even what the behavior of an adaptive CLI tool might look like.
Below is a listing of all of the talks from the event, along with a short summary. Enjoy!
The future of oclif by Jeff Dickey​

In its relatively short lifetime, oclif has already inspired many developers and companies to adopt its framework as a means for implementing their own command-line tooling. In this talk, Jeff Dickey, an oclif founding team member, recaps the project's history and inspiration. He also looks towards the future and outlines some features and improvements that the tool could adapt. This isn't so much a definitive roadmap of where oclif is headed, but rather, a call to inspiration for developers eager to contribute! And if you are interested in contributing, check out the open issues in the oclif GitHub repo and come say "Hello!" on Spectrum Chat.
Open Source Citizenship by Josh Simmons​

When it comes to open source, it's more than just individuals now. More and more frequently, large corporations are contributing to projects by donating to contributors, sponsoring events, or upstreaming contributions. But keeping open source projects and communities healthy requires more than just money and brainpower. Josh Simmons surveyed multiple open source communities and relays his findings as to what help maintainers and contributors actually need in this talk.
Building an enterprise-grade CLI with oclif by Thomas Dvornik​

Security and performance are all about trust. While oclif is an extremely extensible framework for building CLI tooling, there are additional requirements to fulfill for enterprise businesses to adopt it that might not be necessary for individual developers. Thomas Dvornik outlines what he and his colleagues at Salesforce have implemented as plugins to oclif to satisfy these needs, including encrypted OAuth, plugin signing, lazy loading dependencies, synchronizing weekly releases and deprecations across dozens of repositories, and establishing cross-team coding and documentation standards.
How Adobe I/O built an extensible CLI with oclif by Jesse MacFadyen​

Perhaps oclif's most appealing feature is its support for plugins. In Cordova's case, they've created a sophisticated telemetry system that helps Adobe developers see which commands users are using--and reports on which ones are erroring out. By embedding a feedback system into the tool, users are even able to quickly send their suggestions to a form, without ever leaving the terminal. Jesse MacFadyen demonstrates how oclif's plugin system can work beyond simply executing commands.
Integrating oclif with GraphQL and Apollo by Evans Hauser​

For Evans Hauser and the team at Apollo, oclif is best thought of as "React for the CLI." As a client paired with a strongly-typed API contract to a server, it can deliver structured and consistent commands to retrieve external data. What better mechanism to use for this transfer than GraphQL, a framework which empowers the client to ask precisely for the data it needs, and nothing more?
Adaptive Intent-based CLI State Machines by Shawn Wang​

In designing oclif, Jeff Dickey wrote out 12 CLI factors to keep in mind. In this talk, Shawn Wang outlines a 13th: state. State is hard, because it depends on context, and context depends on understanding what a user intends to do, not what they are asking. Shawn is working towards enabling oclif to better understand the commands a user has entered, so that it can predict and interpret future commands that might be entered next. This would enable CLI tools to not just interpret a users' commands, but to also interpret their intent.\n\nIntroducing `oclif init` commandApril 10, 2024 · 2 min readThanks to the contribution of @joshcanhelp we released a new command for the oclif CLI called oclif init in version 4.8.0
The oclif init command allows you to initialize oclif in an existing project directory by adding the bare minimum requirements: a few pieces of configuration, bin scripts, and a couple of dependencies (@oclif/core and ts-node). This is slightly different from oclif generate, which will create an entirely new oclif project based on our templates.
oclif init will add the following:

bin scripts: bin/run.js, bin/run.cmd, bin/dev.js, and bin/dev.cmd
oclif section to package.json with bin, dirname, commands, and topicSeparator set (See Configuring Your CLI for more)
@oclif/core to dependencies in your package.json (if it's not already there)
ts-node to devDependencies in your package.json (if it's not already there)

Once you've initialized oclif, you can use the bin scripts to execute your CLI. You can also use the other oclif commands like oclif generate command and oclif generate hook to start adding new functionality.

❯ oclif init --helpInitialize a new oclif CLIUSAGE  $ oclif init [--bin <value>] [--module-type ESM|CommonJS] [--package-manager npm|yarn|pnpm] [--topic-separator    colons|spaces] [-d <value>] [-y]FLAGS  -d, --output-dir=<value>        Directory to initialize the CLI in.  -y, --yes                       Use defaults for all prompts. Individual flags will override defaults.      --bin=<value>               Supply answer for prompt: Command bin name the CLI will export      --module-type=<option>      Supply answer for prompt: Select a module type                                  <options: ESM|CommonJS>      --package-manager=<option>  Supply answer for prompt: Select a package manager                                  <options: npm|yarn|pnpm>      --topic-separator=<option>  Supply answer for prompt: Select a topic separator                                  <options: colons|spaces>DESCRIPTION  Initialize a new oclif CLI  This will add the necessary oclif bin files, add oclif config to package.json, and install @oclif/core and ts-node.EXAMPLES  Initialize a new CLI in the current directory    $ oclif init  Initialize a new CLI in a different directory    $ oclif init --output-dir "/path/to/existing/project"  Supply answers for specific prompts    $ oclif init --topic-separator colons --bin mycli
Hope you enjoy the new command! If you come across any issues or have any new ideas for this command, head over to the oclif/oclif repo and open a new issue.
All our best,
The oclif teamoclif Spring 2024 UpdateMarch 29, 2024 · 4 min readHello oclif developers! It's been a while since we last uploaded a blog - and a lot has happened.
We've been focusing on these high-level areas over the past couple of years:

Improving @oclif/core
ESM Support
Improving and revitalizing oclif.io
Re-engaging the oclif community

Improving @oclif/core​
Since we announced @oclif/core over three years ago, we've released two new major versions, each packed with lots of features that we're really excited about.
Here are some of these changes:

Full support for ESM and interoperability with CommonJS (more on this topic below).
Configurable command discovery strategies that give you more control over how commands are loaded at runtime. Check out the docs.
A new preparse hook that allows you to manipulate the provided arguments before they're parsed. Salesforce used this hook to implement a neat --flags-dir feature that translates local files into flags.
A new Performance class that you can use to track performance inside of @oclif/core and your own CLI or plugin. Check out the docs.
A new flag type, Flags.option, that lets you define a flag with a preset list of options. Typescript then uses the options to infer the flag's type.
Flags now have a relationship property that allows you to define more complex relationships between flags. Check out the flags docs for more information.
Flags now have a defaultHelp property that allows you to set the human readable default value in the command help. This property is useful when your flag's parse method returns a complex type, such as an object or a class. Check out the flags docs for more.
Commands now have a hiddenAliases property that allows you to define aliases that you want to hide from the user. The property is super helpful when you're trying to wean users off a deprecated command.
You can now use bun or tsx as dev runtimes (as opposed to node or ts-node).
A command's usage, args, and flags are now shown whenever a user forgets to provide a required arg or flag, or when they provided a non-existent flag.

If you need help migrating to the latest version, head over to core's README which has links to the migration guides. Feel free to open a new discussion if you need more hands-on help from us or the community.
ESM Support​
Version 3 of @oclif/core introduced full support for developing ESM plugins and CLIs. It also offered full support for interoperability between CommonJS and ESM plugins.
Put more simply, you can now migrate your CLI to ESM while keeping individual plugins in CommonJS (or vice versa). The upgrade path is now much simpler for you. You also don't need to worry about any community plugins that have migrated to ESM before you did (such as all the @oclif plugins) or are staunchly sticking with CommonJS for the foreseeable future.
Read more about this topic here.
Improving and Revitalizing oclif.io​
Another area of focus for us has been improving our documentation site, oclif.io.
While improving the quality and accuracy of the documentation was our priority, we also took the time to upgrade to the latest version of docusaurus. This new version gave our site a much-needed facelift, as well as cool new features such as dark mode and announcements.
If you have any feedback or are running into issues, we want to hear about it. Just create an issue in the oclif.io repo.
Re-engaging the oclif Community​
Lastly, our biggest priority at the moment is to re-engage the oclif community. We understand how frustrating it has been over the years to see your issues and pull requests go unacknowledged. We apologize for not prioritizing the community, and are earnestly trying to make sure that every issue and pull request gets the attention it deserves going forward.
We also opened up GitHub discussions for @oclif/core and the oclif CLI, where you can now post your questions or ideas. We hope you take advantage of them, we love hearing from you!
One last thing: we intend to publicly post our roadmap so you have more visibility into what we're working on. Stay tuned!
All our best,
The oclif teamAnnouncing oclif v2!January 12, 2022 · 5 min readHello and happy new year! It's our great pleasure to announce that we have released oclif v2, which uses the new @oclif/core library! 🎉
oclif v2 includes many changes that improve the experience of both creating and using an oclif CLI.
Going forward, we don't plan to make any updates to oclif v1 and its corresponding libraries, except for critical security fixes. See the compatibility matrix for a list of these libraries. In order to give developers time to migrate from v1 to v2, we're not completely dropping support yet. But at some point in the future we'll archive the v1 repositories and deprecate their versions on npm.
What’s changing?​
Repository Changes​
All repositories under the oclif org now use main as their primary branch and oclif-v1 as the legacy branch. The main  branch corresponds to oclif v2 and the oclif-v1 branch to oclif v1. If you find any repos that don’t have a main branch, you can safely assume that they're not used in oclif v2 and will be deprecated in the future.
Consolidating Tools & Libraries​
The oclif-dev CLI has now been incorporated into oclif. You now no longer need to install a separate package to manage your entire CLI’s lifecycle.
The following libraries have been consolidated under @oclif/core and will be deprecated at some point in the future. Read the migration guide to learn how to update your CLI or plugin to use the new core library.

@oclif/command
@oclif/config
@oclif/error
@oclif/help
@oclif/parser

No more single vs multi command CLIs​
There's only one "type" of oclif v2 CLI, but it can have as few or as many commands as a developer wants. As a result, there’s only one command to generate CLIs, oclif generate, as opposed to the old oclif single and oclif multi commands.
Node > 12​
To ensure oclif CLIs are as secure as possible, all v2 libraries and plugins support only Node 12 or higher as of now. Going forward, they'll support only Node Maintenance or higher, as defined by Node's release schedule here: https://nodejs.org/en/about/releases/.
What’s new?​
New example CLI​
oclif-hello-world is our new example repo. This is also the repo that's used as a template when running oclif generate to create a new CLI. This repo will always be able to be referenced as an example of what an oclif v2 CLI should look like.
Spaced commands​
oclif CLIs can now use spaces, instead of colons, to separate topics and subcommands. To enable this feature, simply add “topicSeparator": " " to the oclif config in your package.json. See an example in our example repo.
// Old commands that use :$ mycli do:something
// New spaced commands$ mycli do something

Note: Spaced commands are backwards compatible. So if you enable spaced commands for your CLI, users will still be able to use : as a separator. This ensures that any existing scripts don't break.

New Help Output​
We’ve revamped the way command help is outputted to the terminal, making it both easier to implement and easier to read. See the difference between the old help output on the left and the new help output on the right in the screenshots below.
oclif v1oclif v2
Notice that there are new sections for flags and global flags, examples are displayed with better spacing, and there is a section at the bottom called Configuration Variables. This Configuration Variables section is not part of the new help by default. But we've added support for custom help sections, which is what the sf CLI uses to create the new section.
Async Command Parsing​
We’ve also improved the performance of new CLIs by rewriting how commands are parsed on initialization. The new parser is asynchronous, which makes CLIs with a lot of commands or installed  plugins much faster.
What’s coming next?​
Part of our charter for the release of oclif v2 includes improving our engagement with the oclif community. We know that over the past couple of years we’ve reduced our involvement, and a lot of issues and PRs have languished in limbo. Hopefully you’ve already seen increased activity and responses from oclif maintainers recently, but if you haven’t, please don’t hesitate to ping us by tagging @admins in oclif repos.
We also want to start interviewing members of the oclif community to acquire feedback and prioritize the features and fixes you deem most important!
Best,
The oclif team

Reference material​
Migration Guide​
This guide explains how to upgrade a CLI or plugin from the old oclif v1 libraries to the new @oclif/core library that oclif v2 uses.
https://github.com/oclif/core/blob/main/MIGRATION.md
Compatibility Matrix​
The following matrix shows how the v1 libraries and plugins relate to the new v2 ones. Use this matrix as a guide to know what to drop and which versions to switch when upgrading your plugins and CLIs to v2.
oclif "v1"oclif "v2"Utility CLIsoclif@<2@oclif/dev-cli@<2oclif@>=2Main packages@oclif/command@oclif/config@oclif/errors@oclif/parser@oclif/plugin-help@oclif/core@>=1Node LTSNode v8-14Node v12+ (at time of writing)TypeScripttypescript@<4typescript@>=4Main plugins@oclif/plugin-autocomplete@<1@oclif/plugin-commands@<2@oclif/plugin-help@<4@oclif/plugin-not-found@<2@oclif/plugin-plugins@<2@oclif/plugin-update@<2plugin-warn-if-update-available@<2plugin-which@<2@oclif/plugin-autocomplete@>=1@oclif/plugin-commands@>=2@oclif/plugin-help@>=4@oclif/plugin-not-found@>=2@oclif/plugin-plugins@>=2@oclif/plugin-update@>=2@oclif/plugin-warn-if-update-available@>=2@oclif/plugin-which@>=2Introducing @oclif/coreMarch 1, 2021 · 3 min readGreetings!
We hope this blog post finds you well.
Introducing...​
We are excited to announce the next iteration of the oclif project today: @oclif/core.
We have learned a lot in the last three years of developing oclif, developing on oclif and supporting millions of command runs a day via Heroku and Salesforce CLIs.
@oclif/core ("Core") simplifies the oclif development experience and introduces highly requested new features.
Core combines the essential oclif packages into one "core" package, aptly named @oclif/core.
Core also introduces:

A default command option
Colon or space command syntax
Async command parsing
Command piping to arguments

With the introduction of default command functionality, Core simplifies the oclif project and removes the notion of single or multi command CLIs. Core CLIs can have 1 or many commands.
Along with Core, we moved the oclif-dev CLI into the oclif CLI creating a single "utility" CLI. This CLI also introduces a new AWS S3 compatible publishing scheme.
What to expect in the near future​
Core is in pre-release beta and being actively developed for new internal Salesforce CLIs.
Much documentation needs to be written in the coming months including migration paths. Migration onto Core should be as painless as possible with many exports remaining entirely unchanged. Look for forthcoming blog posts and documentation on oclif.io.
Early this summer, tentively June 1, we will release Core v1. Core's release will coincide with major bumps to many other oclif plugin packages. See the compatibility matrix below.
At Core's v1 release, the current "main" oclif packages (namely: command, config, errors & parser) will go into maintenance mode until Jan 2022. They will receive only bug and security fixes and they remain compatible with current versions of the oclif and oclif-dev CLIs. Afterwhich, they will be archived.
Companioning Core, the next major release of the oclif CLI (literally oclif@2) will generate Core CLIs.
Going forward​
We are excited to release Core! We invite you to poke around the Core repo. It may appear to be a big change but Core keeps what you already enjoy about oclif while reducing development complexity, project dependencies, package coupling and bundle size and introduces many requested features previously too prickly to weave into the current oclif architecture.
Best,
The oclif team
Reference: Compatibility matrix​
oclif "v1"oclif "Core"Utility CLIsoclif@<2@oclif/dev-cli@<2oclif@>=2Main packages@oclif/core@<2@oclif/config@<2@oclif/errors@<2@oclif/parser@<4@oclif/plugin-help@<4@oclif/core@>=1Node LTSNode v8-14Node v12+TypeScripttypescript@<4typescript@>=4Main plugins@oclif/plugin-autocomplete@<1@oclif/plugin-commands@<2@oclif/plugin-help@<4@oclif/plugin-not-found@<2@oclif/plugin-plugins@<2@oclif/plugin-update@<2plugin-warn-if-update-available@<2plugin-which@<2@oclif/plugin-autocomplete@>=2@oclif/plugin-commands@>=2@oclif/plugin-help@>=4@oclif/plugin-not-found@>=2@oclif/plugin-plugins@>=2@oclif/plugin-update@>=2@oclif/plugin-warn-if-update-available@>=2@oclif/plugin-which@>=2oclif Summer 2020 UpdateAugust 26, 2020 · 2 min readHello oclif developers! We hope you are all doing well.
Earlier this year, we started our planning for oclifconf v2 and, like all conference, had to change course. We opted not to hold a virtual conference, however, we wanted to take some time to highlight a few oclif features shipped this year.
Feature: Help templating​
One of the most requested features, help templating enables oclif developers to customize the help output for their CLI.
Read the announcement.
Feature: Custom error delegation​
This feature both improved how oclif throws and handles errors and allows oclif developers to overwrite or interject in oclif’s error handling.
Read the announcement.
Feature: postrun hooks​
We have added a new lifecycle event postrun. Your CLI can now run a hook after a command has ran.
See our hook documentation.
Feature: Root index command​
Previously, oclif would display CLI help if only the binary name with no command ID was invoked, oclif now supports a "root index" command. If present, a command defined at src/commands/index.ts will be run if no command ID is found.
1 million weekly downloads​
While exact oclif usage metrics are hard to pin down, we use npm download statistics of oclif packages as a rough approximation. Earlier this year, oclif's command package hit 1 million weekly downloads for the first time!
This year has been presented its challenges on everyone. We want to thank you, oclif developers, whom have taken the time to use and improve the oclif project. We look forward to seeing you all - in person - in the future!
All our best,
The oclif teamPretty Printable ErrorsJuly 1, 2020 · One min readOften CLIs are used as handy tools and when things go wrong it’s useful to have additional context. In oclif we have added a couple of additional properties that can show extra context to the users when an error is displayed. The code, ref and suggestions will now be displayed if they are included. This will work with an existing oclif CLI by adding the latest @oclif/errors and @oclif/core to the CLI's package.json dependencies.
For example, using this.error with the additional properties:
class TestError extends Command {  async run() {    this.error("An error has occurred!", {      code: "OCLIF_ERR",      ref: "https://oclif.io/docs/commands#thiserrormessage-string--error-options-code-string-exit-number",      suggestions: ["Use these extra properties to provide additional context"],    })  }}
would result with the following output:
›   Error: An error has occurred!›   Code: OCLIF_ERR›   Try this: Use these extra properties to provide additional context›   Reference: https://oclif.io/docs/commands#thiserrormessage-string--error-options-code-string-exit-number
If these properties are not provided then nothing changes and the CLI will continue to display the single error message output as it did before. Additionally, as part of this exercise we’ve added documentation around Error Handling in oclif which should come in handy if the need arises to extend oclif’s default handling of errors.Customizing Help in oclifMay 5, 2020 · 2 min readOut of the box oclif provides a great help experience for CLIs.
But what if, as an oclif developer, you want to customize some or all of the output?
You can now customize your CLI's help output by implementing the HelpBase abstract class.
Getting started with custom help​
If you have not done so yet, update @oclif/core.
$ yarn add --latest @oclif/core
To get started, first define the filepath to your help class in oclif's config in package.json. This is a relative path to the help class, without a file extension.
For this example, the help class will be created in a file at "[project root]/src/help.ts".
{  // ...  "oclif": {    "helpClass": "./lib/help"    // ...  }  // ...}
From here there are two paths, implement the HelpBase abstract class yourself or overwrite the parts of the default Help class you want to customize (ex: how command usage is displayed). We recommend the latter approach but cover both in the new Help Classes docs.
Separating TOPICS & COMMANDS in the new default Help class​
Previously, topics and child commands were listed in help output under a single list heading called "COMMANDS". But we found this can be slightly confusing. Some topics are commands also (a.k.a. topic-commands) while others are simply organizational namespacing (and when ran just show their help).
The new default Help class splits the list of children into distinct lists of "TOPICS" and "COMMANDS", with the possibility of an item appearing in both if it a topic-command. This makes it clearer what is expected to be ran - "COMMANDS" - and what is providing structure - "TOPICS" - when looking at the help output.
VERSION  plugin-help-example/0.0.0 darwin-x64 node-v12.12.0USAGE  $ plugin-help-example [COMMAND]TOPICS  topic  this is a topic and has child topics or commandsCOMMANDS  hello  describe the command here  help   display help for plugin-help-example
We look forward to seeing what custom help features you implement in your oclif CLIs with this new feature!oclif TSLint to ESLint MigrationDecember 5, 2019 · 3 min readBack in February of this year, plans were announced to deprecate TSLint in favor of ESLint. TSLint's goal has become to work toward a “unified developer experience” by supporting ESLint development going forward.
What has changed in oclif​
To keep inline with the community, oclif has transitioned to ESLint for all our core libraries as well as all our official plugins.
Starting in v1.15.x, oclif will now optionally generate projects with ESLint for both TypeScript and JavaScript CLI’s.
ESLint does require Node to be on stable LTS version, at the time of writing, Node 8.10.x, Node 10.13.x & Node 12.x.x.
How does this affect you​
Existing CLI’s are unchanged, but any newly generated CLI's will only give the option of using ESLint. If you are running tslint in your CLI, we recommend you switch to ESLint as well.
In migrating our projects we took the following steps (for an example of these changes see this pull request).


Install eslint
$ yarn add eslint eslint-config-oclif eslint-config-oclif-typescript --dev


Add eslint related files


$ echo '{  "extends": [    "oclif",    "oclif-typescript"  ],  "rules": {  }}' > .eslintrc


Remove tslint and related packages
$ yarn remove @oclif/tslint tslint


Remove tslint related configuration files
$ rm tslint.json


Change lint script in our package.json from something like:
"lint": "tsc -p test --noEmit && tslint -p test -t stylish"
to
"lint": "eslint . --ext .ts --config .eslintrc"


To preserve the test compile (tsc -p test --noEmit) we also made the following updates to our scripts:
"pretest": "tsc -p test --noEmit"
In some cases we had our posttest duplicating the same steps as our lint script so it’s cleaner to have it reference the lint job directly with:
"posttest": "yarn lint"

Run yarn lint --fix. This attempts to auto-fix any linting violations automatically. In the case an auto-fix isn’t available it should be fixed manually or ignored (see the eslint configuration doc for more information)
Do a search in the codebase for tslint and remove any unnecessary tslint disabling comments, like:

/* tslint:disable:object-literal-sort-keys */
If you are on a version of Node that is not supported by ESLint, you will also need to update your Node engine. ESLint supports Node 8, 10, and 12 so you should upgrade to the most recent Node version compatible with your CLI and also supported by ESLint (see ESLint's Installation and Usage instructions).
When will this take effect​
These changes have taken effect in oclif v1.15.1. When you generate a new CLI or plugin it will now contain configuration for ESLint instead of TSLint.oclif's Current Node SupportOctober 31, 2019 · 3 min readTo maintain a healthy project trajectory, oclif follows and supports Node Active LTS release, currently Node 10 & Node 12. This means ensuring that oclif continues to play nice with coming Active LTS Node versions and other packages in the ecosystem. Moving forward also means leaving older versions behind. Starting in 2020, Node will stop maintaining Node 8 and it is our intent at that time to also follow suit. Let’s take a look at a few ways we will be supporting these changes.
CI Environments​
CLIs created with the oclif cli going forward will be generated with a CircleCI configuration with Node 10 & 12 and an Appveyor configuration using Node 10. We have also added Node latest to CircleCi to be an early warning detection against coming Node changes (Node latest is managed by CircleCI).
We have already updated every oclif repo's CI configs to reflect this.
If your existing CLI uses either Appveyor or CircleCI you can update your config files also, like so:
.circleci/config.yml​
Your CircleCI config should contain a node-latest job, aliased as test. From this, there should be two extensions of this job for the Active LTS Node versions, Node 10 and Node 12.
  node-10:    <<: *node-latest    docker:      - image: node:10  node-12:    <<: *node-latest    docker:      - image: node:12
Notice that these declarations only change the Docker Node images used to run that job.
Additionally, the jobs listed within workflows must also be updated to reflect our changes in configuration:
    jobs:      - node-latest      - node-10      - node-12
appveyor.yml​
For appveyor we are currently only testing the oldest Active LTS Node version, Node 10. Update the nodejs_version proppert in your appveyor.yml file to reflect this.
environment:  nodejs_version: "10"
Deprecating Node 8 & Updating packge.json engines​
In Jan 2020, Node will end its Node 8 maintenance. We will follow suit by setting the package.json engine property in oclif packages to >=10 and bumping the package's major versions.
Depending on how you ship your CLI you may wish to also bump the engines version in your CLI's package.json. You can read more about the implications of the engines property configuration in the npm documentation.
Also consider distributing your CLI with its own Node version.
Packaged Node Version​
When using dev-cli to pack your CLI it will use the Node version as specified in your package.json under the oclif.update.node.version property. This value should reflect an Active LTS Node version (dev-cli does not currently enforce versions).
Supporting the future​
As a community we may discover bumps along the way as we upgrade. If you notice something related to oclif please feel free to open an issue or submit a pull request under the relevant oclif package within the org.
We look forward to using the latest from Node and the community and keeping oclif healthy along the way.oclifconf 2019: A RecapSeptember 16, 2019 · 4 min readIn May, Heroku and Salesforce Open Source organized oclifconf, a conference for developers & product managers building CLI tools on top of the open source oclif framework. The speakers came from various tech companies, such as Adobe, Netlify, and Apollo, who have already built amazing CLI experiences. The topics covered everything from the incredible capabilities oclif has unlocked, to the community-built plugins extending its functionality, and even what the behavior of an adaptive CLI tool might look like.
Below is a listing of all of the talks from the event, along with a short summary. Enjoy!
The future of oclif by Jeff Dickey​

In its relatively short lifetime, oclif has already inspired many developers and companies to adopt its framework as a means for implementing their own command-line tooling. In this talk, Jeff Dickey, an oclif founding team member, recaps the project's history and inspiration. He also looks towards the future and outlines some features and improvements that the tool could adapt. This isn't so much a definitive roadmap of where oclif is headed, but rather, a call to inspiration for developers eager to contribute! And if you are interested in contributing, check out the open issues in the oclif GitHub repo and come say "Hello!" on Spectrum Chat.
Open Source Citizenship by Josh Simmons​

When it comes to open source, it's more than just individuals now. More and more frequently, large corporations are contributing to projects by donating to contributors, sponsoring events, or upstreaming contributions. But keeping open source projects and communities healthy requires more than just money and brainpower. Josh Simmons surveyed multiple open source communities and relays his findings as to what help maintainers and contributors actually need in this talk.
Building an enterprise-grade CLI with oclif by Thomas Dvornik​

Security and performance are all about trust. While oclif is an extremely extensible framework for building CLI tooling, there are additional requirements to fulfill for enterprise businesses to adopt it that might not be necessary for individual developers. Thomas Dvornik outlines what he and his colleagues at Salesforce have implemented as plugins to oclif to satisfy these needs, including encrypted OAuth, plugin signing, lazy loading dependencies, synchronizing weekly releases and deprecations across dozens of repositories, and establishing cross-team coding and documentation standards.
How Adobe I/O built an extensible CLI with oclif by Jesse MacFadyen​

Perhaps oclif's most appealing feature is its support for plugins. In Cordova's case, they've created a sophisticated telemetry system that helps Adobe developers see which commands users are using--and reports on which ones are erroring out. By embedding a feedback system into the tool, users are even able to quickly send their suggestions to a form, without ever leaving the terminal. Jesse MacFadyen demonstrates how oclif's plugin system can work beyond simply executing commands.
Integrating oclif with GraphQL and Apollo by Evans Hauser​

For Evans Hauser and the team at Apollo, oclif is best thought of as "React for the CLI." As a client paired with a strongly-typed API contract to a server, it can deliver structured and consistent commands to retrieve external data. What better mechanism to use for this transfer than GraphQL, a framework which empowers the client to ask precisely for the data it needs, and nothing more?
Adaptive Intent-based CLI State Machines by Shawn Wang​

In designing oclif, Jeff Dickey wrote out 12 CLI factors to keep in mind. In this talk, Shawn Wang outlines a 13th: state. State is hard, because it depends on context, and context depends on understanding what a user intends to do, not what they are asking. Shawn is working towards enabling oclif to better understand the commands a user has entered, so that it can predict and interpret future commands that might be entered next. This would enable CLI tools to not just interpret a users' commands, but to also interpret their intent.Older Entries\n\n\n\nIntroducing `oclif init` commandApril 10, 2024 · 2 min readThanks to the contribution of @joshcanhelp we released a new command for the oclif CLI called oclif init in version 4.8.0
The oclif init command allows you to initialize oclif in an existing project directory by adding the bare minimum requirements: a few pieces of configuration, bin scripts, and a couple of dependencies (@oclif/core and ts-node). This is slightly different from oclif generate, which will create an entirely new oclif project based on our templates.
oclif init will add the following:

bin scripts: bin/run.js, bin/run.cmd, bin/dev.js, and bin/dev.cmd
oclif section to package.json with bin, dirname, commands, and topicSeparator set (See Configuring Your CLI for more)
@oclif/core to dependencies in your package.json (if it's not already there)
ts-node to devDependencies in your package.json (if it's not already there)

Once you've initialized oclif, you can use the bin scripts to execute your CLI. You can also use the other oclif commands like oclif generate command and oclif generate hook to start adding new functionality.

❯ oclif init --helpInitialize a new oclif CLIUSAGE  $ oclif init [--bin <value>] [--module-type ESM|CommonJS] [--package-manager npm|yarn|pnpm] [--topic-separator    colons|spaces] [-d <value>] [-y]FLAGS  -d, --output-dir=<value>        Directory to initialize the CLI in.  -y, --yes                       Use defaults for all prompts. Individual flags will override defaults.      --bin=<value>               Supply answer for prompt: Command bin name the CLI will export      --module-type=<option>      Supply answer for prompt: Select a module type                                  <options: ESM|CommonJS>      --package-manager=<option>  Supply answer for prompt: Select a package manager                                  <options: npm|yarn|pnpm>      --topic-separator=<option>  Supply answer for prompt: Select a topic separator                                  <options: colons|spaces>DESCRIPTION  Initialize a new oclif CLI  This will add the necessary oclif bin files, add oclif config to package.json, and install @oclif/core and ts-node.EXAMPLES  Initialize a new CLI in the current directory    $ oclif init  Initialize a new CLI in a different directory    $ oclif init --output-dir "/path/to/existing/project"  Supply answers for specific prompts    $ oclif init --topic-separator colons --bin mycli
Hope you enjoy the new command! If you come across any issues or have any new ideas for this command, head over to the oclif/oclif repo and open a new issue.
All our best,
The oclif teamoclif Spring 2024 UpdateMarch 29, 2024 · 4 min readHello oclif developers! It's been a while since we last uploaded a blog - and a lot has happened.
We've been focusing on these high-level areas over the past couple of years:

Improving @oclif/core
ESM Support
Improving and revitalizing oclif.io
Re-engaging the oclif community

Improving @oclif/core​
Since we announced @oclif/core over three years ago, we've released two new major versions, each packed with lots of features that we're really excited about.
Here are some of these changes:

Full support for ESM and interoperability with CommonJS (more on this topic below).
Configurable command discovery strategies that give you more control over how commands are loaded at runtime. Check out the docs.
A new preparse hook that allows you to manipulate the provided arguments before they're parsed. Salesforce used this hook to implement a neat --flags-dir feature that translates local files into flags.
A new Performance class that you can use to track performance inside of @oclif/core and your own CLI or plugin. Check out the docs.
A new flag type, Flags.option, that lets you define a flag with a preset list of options. Typescript then uses the options to infer the flag's type.
Flags now have a relationship property that allows you to define more complex relationships between flags. Check out the flags docs for more information.
Flags now have a defaultHelp property that allows you to set the human readable default value in the command help. This property is useful when your flag's parse method returns a complex type, such as an object or a class. Check out the flags docs for more.
Commands now have a hiddenAliases property that allows you to define aliases that you want to hide from the user. The property is super helpful when you're trying to wean users off a deprecated command.
You can now use bun or tsx as dev runtimes (as opposed to node or ts-node).
A command's usage, args, and flags are now shown whenever a user forgets to provide a required arg or flag, or when they provided a non-existent flag.

If you need help migrating to the latest version, head over to core's README which has links to the migration guides. Feel free to open a new discussion if you need more hands-on help from us or the community.
ESM Support​
Version 3 of @oclif/core introduced full support for developing ESM plugins and CLIs. It also offered full support for interoperability between CommonJS and ESM plugins.
Put more simply, you can now migrate your CLI to ESM while keeping individual plugins in CommonJS (or vice versa). The upgrade path is now much simpler for you. You also don't need to worry about any community plugins that have migrated to ESM before you did (such as all the @oclif plugins) or are staunchly sticking with CommonJS for the foreseeable future.
Read more about this topic here.
Improving and Revitalizing oclif.io​
Another area of focus for us has been improving our documentation site, oclif.io.
While improving the quality and accuracy of the documentation was our priority, we also took the time to upgrade to the latest version of docusaurus. This new version gave our site a much-needed facelift, as well as cool new features such as dark mode and announcements.
If you have any feedback or are running into issues, we want to hear about it. Just create an issue in the oclif.io repo.
Re-engaging the oclif Community​
Lastly, our biggest priority at the moment is to re-engage the oclif community. We understand how frustrating it has been over the years to see your issues and pull requests go unacknowledged. We apologize for not prioritizing the community, and are earnestly trying to make sure that every issue and pull request gets the attention it deserves going forward.
We also opened up GitHub discussions for @oclif/core and the oclif CLI, where you can now post your questions or ideas. We hope you take advantage of them, we love hearing from you!
One last thing: we intend to publicly post our roadmap so you have more visibility into what we're working on. Stay tuned!
All our best,
The oclif teamAnnouncing oclif v2!January 12, 2022 · 5 min readHello and happy new year! It's our great pleasure to announce that we have released oclif v2, which uses the new @oclif/core library! 🎉
oclif v2 includes many changes that improve the experience of both creating and using an oclif CLI.
Going forward, we don't plan to make any updates to oclif v1 and its corresponding libraries, except for critical security fixes. See the compatibility matrix for a list of these libraries. In order to give developers time to migrate from v1 to v2, we're not completely dropping support yet. But at some point in the future we'll archive the v1 repositories and deprecate their versions on npm.
What’s changing?​
Repository Changes​
All repositories under the oclif org now use main as their primary branch and oclif-v1 as the legacy branch. The main  branch corresponds to oclif v2 and the oclif-v1 branch to oclif v1. If you find any repos that don’t have a main branch, you can safely assume that they're not used in oclif v2 and will be deprecated in the future.
Consolidating Tools & Libraries​
The oclif-dev CLI has now been incorporated into oclif. You now no longer need to install a separate package to manage your entire CLI’s lifecycle.
The following libraries have been consolidated under @oclif/core and will be deprecated at some point in the future. Read the migration guide to learn how to update your CLI or plugin to use the new core library.

@oclif/command
@oclif/config
@oclif/error
@oclif/help
@oclif/parser

No more single vs multi command CLIs​
There's only one "type" of oclif v2 CLI, but it can have as few or as many commands as a developer wants. As a result, there’s only one command to generate CLIs, oclif generate, as opposed to the old oclif single and oclif multi commands.
Node > 12​
To ensure oclif CLIs are as secure as possible, all v2 libraries and plugins support only Node 12 or higher as of now. Going forward, they'll support only Node Maintenance or higher, as defined by Node's release schedule here: https://nodejs.org/en/about/releases/.
What’s new?​
New example CLI​
oclif-hello-world is our new example repo. This is also the repo that's used as a template when running oclif generate to create a new CLI. This repo will always be able to be referenced as an example of what an oclif v2 CLI should look like.
Spaced commands​
oclif CLIs can now use spaces, instead of colons, to separate topics and subcommands. To enable this feature, simply add “topicSeparator": " " to the oclif config in your package.json. See an example in our example repo.
// Old commands that use :$ mycli do:something
// New spaced commands$ mycli do something

Note: Spaced commands are backwards compatible. So if you enable spaced commands for your CLI, users will still be able to use : as a separator. This ensures that any existing scripts don't break.

New Help Output​
We’ve revamped the way command help is outputted to the terminal, making it both easier to implement and easier to read. See the difference between the old help output on the left and the new help output on the right in the screenshots below.
oclif v1oclif v2
Notice that there are new sections for flags and global flags, examples are displayed with better spacing, and there is a section at the bottom called Configuration Variables. This Configuration Variables section is not part of the new help by default. But we've added support for custom help sections, which is what the sf CLI uses to create the new section.
Async Command Parsing​
We’ve also improved the performance of new CLIs by rewriting how commands are parsed on initialization. The new parser is asynchronous, which makes CLIs with a lot of commands or installed  plugins much faster.
What’s coming next?​
Part of our charter for the release of oclif v2 includes improving our engagement with the oclif community. We know that over the past couple of years we’ve reduced our involvement, and a lot of issues and PRs have languished in limbo. Hopefully you’ve already seen increased activity and responses from oclif maintainers recently, but if you haven’t, please don’t hesitate to ping us by tagging @admins in oclif repos.
We also want to start interviewing members of the oclif community to acquire feedback and prioritize the features and fixes you deem most important!
Best,
The oclif team

Reference material​
Migration Guide​
This guide explains how to upgrade a CLI or plugin from the old oclif v1 libraries to the new @oclif/core library that oclif v2 uses.
https://github.com/oclif/core/blob/main/MIGRATION.md
Compatibility Matrix​
The following matrix shows how the v1 libraries and plugins relate to the new v2 ones. Use this matrix as a guide to know what to drop and which versions to switch when upgrading your plugins and CLIs to v2.
oclif "v1"oclif "v2"Utility CLIsoclif@<2@oclif/dev-cli@<2oclif@>=2Main packages@oclif/command@oclif/config@oclif/errors@oclif/parser@oclif/plugin-help@oclif/core@>=1Node LTSNode v8-14Node v12+ (at time of writing)TypeScripttypescript@<4typescript@>=4Main plugins@oclif/plugin-autocomplete@<1@oclif/plugin-commands@<2@oclif/plugin-help@<4@oclif/plugin-not-found@<2@oclif/plugin-plugins@<2@oclif/plugin-update@<2plugin-warn-if-update-available@<2plugin-which@<2@oclif/plugin-autocomplete@>=1@oclif/plugin-commands@>=2@oclif/plugin-help@>=4@oclif/plugin-not-found@>=2@oclif/plugin-plugins@>=2@oclif/plugin-update@>=2@oclif/plugin-warn-if-update-available@>=2@oclif/plugin-which@>=2Introducing @oclif/coreMarch 1, 2021 · 3 min readGreetings!
We hope this blog post finds you well.
Introducing...​
We are excited to announce the next iteration of the oclif project today: @oclif/core.
We have learned a lot in the last three years of developing oclif, developing on oclif and supporting millions of command runs a day via Heroku and Salesforce CLIs.
@oclif/core ("Core") simplifies the oclif development experience and introduces highly requested new features.
Core combines the essential oclif packages into one "core" package, aptly named @oclif/core.
Core also introduces:

A default command option
Colon or space command syntax
Async command parsing
Command piping to arguments

With the introduction of default command functionality, Core simplifies the oclif project and removes the notion of single or multi command CLIs. Core CLIs can have 1 or many commands.
Along with Core, we moved the oclif-dev CLI into the oclif CLI creating a single "utility" CLI. This CLI also introduces a new AWS S3 compatible publishing scheme.
What to expect in the near future​
Core is in pre-release beta and being actively developed for new internal Salesforce CLIs.
Much documentation needs to be written in the coming months including migration paths. Migration onto Core should be as painless as possible with many exports remaining entirely unchanged. Look for forthcoming blog posts and documentation on oclif.io.
Early this summer, tentively June 1, we will release Core v1. Core's release will coincide with major bumps to many other oclif plugin packages. See the compatibility matrix below.
At Core's v1 release, the current "main" oclif packages (namely: command, config, errors & parser) will go into maintenance mode until Jan 2022. They will receive only bug and security fixes and they remain compatible with current versions of the oclif and oclif-dev CLIs. Afterwhich, they will be archived.
Companioning Core, the next major release of the oclif CLI (literally oclif@2) will generate Core CLIs.
Going forward​
We are excited to release Core! We invite you to poke around the Core repo. It may appear to be a big change but Core keeps what you already enjoy about oclif while reducing development complexity, project dependencies, package coupling and bundle size and introduces many requested features previously too prickly to weave into the current oclif architecture.
Best,
The oclif team
Reference: Compatibility matrix​
oclif "v1"oclif "Core"Utility CLIsoclif@<2@oclif/dev-cli@<2oclif@>=2Main packages@oclif/core@<2@oclif/config@<2@oclif/errors@<2@oclif/parser@<4@oclif/plugin-help@<4@oclif/core@>=1Node LTSNode v8-14Node v12+TypeScripttypescript@<4typescript@>=4Main plugins@oclif/plugin-autocomplete@<1@oclif/plugin-commands@<2@oclif/plugin-help@<4@oclif/plugin-not-found@<2@oclif/plugin-plugins@<2@oclif/plugin-update@<2plugin-warn-if-update-available@<2plugin-which@<2@oclif/plugin-autocomplete@>=2@oclif/plugin-commands@>=2@oclif/plugin-help@>=4@oclif/plugin-not-found@>=2@oclif/plugin-plugins@>=2@oclif/plugin-update@>=2@oclif/plugin-warn-if-update-available@>=2@oclif/plugin-which@>=2oclif Summer 2020 UpdateAugust 26, 2020 · 2 min readHello oclif developers! We hope you are all doing well.
Earlier this year, we started our planning for oclifconf v2 and, like all conference, had to change course. We opted not to hold a virtual conference, however, we wanted to take some time to highlight a few oclif features shipped this year.
Feature: Help templating​
One of the most requested features, help templating enables oclif developers to customize the help output for their CLI.
Read the announcement.
Feature: Custom error delegation​
This feature both improved how oclif throws and handles errors and allows oclif developers to overwrite or interject in oclif’s error handling.
Read the announcement.
Feature: postrun hooks​
We have added a new lifecycle event postrun. Your CLI can now run a hook after a command has ran.
See our hook documentation.
Feature: Root index command​
Previously, oclif would display CLI help if only the binary name with no command ID was invoked, oclif now supports a "root index" command. If present, a command defined at src/commands/index.ts will be run if no command ID is found.
1 million weekly downloads​
While exact oclif usage metrics are hard to pin down, we use npm download statistics of oclif packages as a rough approximation. Earlier this year, oclif's command package hit 1 million weekly downloads for the first time!
This year has been presented its challenges on everyone. We want to thank you, oclif developers, whom have taken the time to use and improve the oclif project. We look forward to seeing you all - in person - in the future!
All our best,
The oclif teamPretty Printable ErrorsJuly 1, 2020 · One min readOften CLIs are used as handy tools and when things go wrong it’s useful to have additional context. In oclif we have added a couple of additional properties that can show extra context to the users when an error is displayed. The code, ref and suggestions will now be displayed if they are included. This will work with an existing oclif CLI by adding the latest @oclif/errors and @oclif/core to the CLI's package.json dependencies.
For example, using this.error with the additional properties:
class TestError extends Command {  async run() {    this.error("An error has occurred!", {      code: "OCLIF_ERR",      ref: "https://oclif.io/docs/commands#thiserrormessage-string--error-options-code-string-exit-number",      suggestions: ["Use these extra properties to provide additional context"],    })  }}
would result with the following output:
›   Error: An error has occurred!›   Code: OCLIF_ERR›   Try this: Use these extra properties to provide additional context›   Reference: https://oclif.io/docs/commands#thiserrormessage-string--error-options-code-string-exit-number
If these properties are not provided then nothing changes and the CLI will continue to display the single error message output as it did before. Additionally, as part of this exercise we’ve added documentation around Error Handling in oclif which should come in handy if the need arises to extend oclif’s default handling of errors.Customizing Help in oclifMay 5, 2020 · 2 min readOut of the box oclif provides a great help experience for CLIs.
But what if, as an oclif developer, you want to customize some or all of the output?
You can now customize your CLI's help output by implementing the HelpBase abstract class.
Getting started with custom help​
If you have not done so yet, update @oclif/core.
$ yarn add --latest @oclif/core
To get started, first define the filepath to your help class in oclif's config in package.json. This is a relative path to the help class, without a file extension.
For this example, the help class will be created in a file at "[project root]/src/help.ts".
{  // ...  "oclif": {    "helpClass": "./lib/help"    // ...  }  // ...}
From here there are two paths, implement the HelpBase abstract class yourself or overwrite the parts of the default Help class you want to customize (ex: how command usage is displayed). We recommend the latter approach but cover both in the new Help Classes docs.
Separating TOPICS & COMMANDS in the new default Help class​
Previously, topics and child commands were listed in help output under a single list heading called "COMMANDS". But we found this can be slightly confusing. Some topics are commands also (a.k.a. topic-commands) while others are simply organizational namespacing (and when ran just show their help).
The new default Help class splits the list of children into distinct lists of "TOPICS" and "COMMANDS", with the possibility of an item appearing in both if it a topic-command. This makes it clearer what is expected to be ran - "COMMANDS" - and what is providing structure - "TOPICS" - when looking at the help output.
VERSION  plugin-help-example/0.0.0 darwin-x64 node-v12.12.0USAGE  $ plugin-help-example [COMMAND]TOPICS  topic  this is a topic and has child topics or commandsCOMMANDS  hello  describe the command here  help   display help for plugin-help-example
We look forward to seeing what custom help features you implement in your oclif CLIs with this new feature!oclif TSLint to ESLint MigrationDecember 5, 2019 · 3 min readBack in February of this year, plans were announced to deprecate TSLint in favor of ESLint. TSLint's goal has become to work toward a “unified developer experience” by supporting ESLint development going forward.
What has changed in oclif​
To keep inline with the community, oclif has transitioned to ESLint for all our core libraries as well as all our official plugins.
Starting in v1.15.x, oclif will now optionally generate projects with ESLint for both TypeScript and JavaScript CLI’s.
ESLint does require Node to be on stable LTS version, at the time of writing, Node 8.10.x, Node 10.13.x & Node 12.x.x.
How does this affect you​
Existing CLI’s are unchanged, but any newly generated CLI's will only give the option of using ESLint. If you are running tslint in your CLI, we recommend you switch to ESLint as well.
In migrating our projects we took the following steps (for an example of these changes see this pull request).


Install eslint
$ yarn add eslint eslint-config-oclif eslint-config-oclif-typescript --dev


Add eslint related files


$ echo '{  "extends": [    "oclif",    "oclif-typescript"  ],  "rules": {  }}' > .eslintrc


Remove tslint and related packages
$ yarn remove @oclif/tslint tslint


Remove tslint related configuration files
$ rm tslint.json


Change lint script in our package.json from something like:
"lint": "tsc -p test --noEmit && tslint -p test -t stylish"
to
"lint": "eslint . --ext .ts --config .eslintrc"


To preserve the test compile (tsc -p test --noEmit) we also made the following updates to our scripts:
"pretest": "tsc -p test --noEmit"
In some cases we had our posttest duplicating the same steps as our lint script so it’s cleaner to have it reference the lint job directly with:
"posttest": "yarn lint"

Run yarn lint --fix. This attempts to auto-fix any linting violations automatically. In the case an auto-fix isn’t available it should be fixed manually or ignored (see the eslint configuration doc for more information)
Do a search in the codebase for tslint and remove any unnecessary tslint disabling comments, like:

/* tslint:disable:object-literal-sort-keys */
If you are on a version of Node that is not supported by ESLint, you will also need to update your Node engine. ESLint supports Node 8, 10, and 12 so you should upgrade to the most recent Node version compatible with your CLI and also supported by ESLint (see ESLint's Installation and Usage instructions).
When will this take effect​
These changes have taken effect in oclif v1.15.1. When you generate a new CLI or plugin it will now contain configuration for ESLint instead of TSLint.oclif's Current Node SupportOctober 31, 2019 · 3 min readTo maintain a healthy project trajectory, oclif follows and supports Node Active LTS release, currently Node 10 & Node 12. This means ensuring that oclif continues to play nice with coming Active LTS Node versions and other packages in the ecosystem. Moving forward also means leaving older versions behind. Starting in 2020, Node will stop maintaining Node 8 and it is our intent at that time to also follow suit. Let’s take a look at a few ways we will be supporting these changes.
CI Environments​
CLIs created with the oclif cli going forward will be generated with a CircleCI configuration with Node 10 & 12 and an Appveyor configuration using Node 10. We have also added Node latest to CircleCi to be an early warning detection against coming Node changes (Node latest is managed by CircleCI).
We have already updated every oclif repo's CI configs to reflect this.
If your existing CLI uses either Appveyor or CircleCI you can update your config files also, like so:
.circleci/config.yml​
Your CircleCI config should contain a node-latest job, aliased as test. From this, there should be two extensions of this job for the Active LTS Node versions, Node 10 and Node 12.
  node-10:    <<: *node-latest    docker:      - image: node:10  node-12:    <<: *node-latest    docker:      - image: node:12
Notice that these declarations only change the Docker Node images used to run that job.
Additionally, the jobs listed within workflows must also be updated to reflect our changes in configuration:
    jobs:      - node-latest      - node-10      - node-12
appveyor.yml​
For appveyor we are currently only testing the oldest Active LTS Node version, Node 10. Update the nodejs_version proppert in your appveyor.yml file to reflect this.
environment:  nodejs_version: "10"
Deprecating Node 8 & Updating packge.json engines​
In Jan 2020, Node will end its Node 8 maintenance. We will follow suit by setting the package.json engine property in oclif packages to >=10 and bumping the package's major versions.
Depending on how you ship your CLI you may wish to also bump the engines version in your CLI's package.json. You can read more about the implications of the engines property configuration in the npm documentation.
Also consider distributing your CLI with its own Node version.
Packaged Node Version​
When using dev-cli to pack your CLI it will use the Node version as specified in your package.json under the oclif.update.node.version property. This value should reflect an Active LTS Node version (dev-cli does not currently enforce versions).
Supporting the future​
As a community we may discover bumps along the way as we upgrade. If you notice something related to oclif please feel free to open an issue or submit a pull request under the relevant oclif package within the org.
We look forward to using the latest from Node and the community and keeping oclif healthy along the way.oclifconf 2019: A RecapSeptember 16, 2019 · 4 min readIn May, Heroku and Salesforce Open Source organized oclifconf, a conference for developers & product managers building CLI tools on top of the open source oclif framework. The speakers came from various tech companies, such as Adobe, Netlify, and Apollo, who have already built amazing CLI experiences. The topics covered everything from the incredible capabilities oclif has unlocked, to the community-built plugins extending its functionality, and even what the behavior of an adaptive CLI tool might look like.
Below is a listing of all of the talks from the event, along with a short summary. Enjoy!
The future of oclif by Jeff Dickey​

In its relatively short lifetime, oclif has already inspired many developers and companies to adopt its framework as a means for implementing their own command-line tooling. In this talk, Jeff Dickey, an oclif founding team member, recaps the project's history and inspiration. He also looks towards the future and outlines some features and improvements that the tool could adapt. This isn't so much a definitive roadmap of where oclif is headed, but rather, a call to inspiration for developers eager to contribute! And if you are interested in contributing, check out the open issues in the oclif GitHub repo and come say "Hello!" on Spectrum Chat.
Open Source Citizenship by Josh Simmons​

When it comes to open source, it's more than just individuals now. More and more frequently, large corporations are contributing to projects by donating to contributors, sponsoring events, or upstreaming contributions. But keeping open source projects and communities healthy requires more than just money and brainpower. Josh Simmons surveyed multiple open source communities and relays his findings as to what help maintainers and contributors actually need in this talk.
Building an enterprise-grade CLI with oclif by Thomas Dvornik​

Security and performance are all about trust. While oclif is an extremely extensible framework for building CLI tooling, there are additional requirements to fulfill for enterprise businesses to adopt it that might not be necessary for individual developers. Thomas Dvornik outlines what he and his colleagues at Salesforce have implemented as plugins to oclif to satisfy these needs, including encrypted OAuth, plugin signing, lazy loading dependencies, synchronizing weekly releases and deprecations across dozens of repositories, and establishing cross-team coding and documentation standards.
How Adobe I/O built an extensible CLI with oclif by Jesse MacFadyen​

Perhaps oclif's most appealing feature is its support for plugins. In Cordova's case, they've created a sophisticated telemetry system that helps Adobe developers see which commands users are using--and reports on which ones are erroring out. By embedding a feedback system into the tool, users are even able to quickly send their suggestions to a form, without ever leaving the terminal. Jesse MacFadyen demonstrates how oclif's plugin system can work beyond simply executing commands.
Integrating oclif with GraphQL and Apollo by Evans Hauser​

For Evans Hauser and the team at Apollo, oclif is best thought of as "React for the CLI." As a client paired with a strongly-typed API contract to a server, it can deliver structured and consistent commands to retrieve external data. What better mechanism to use for this transfer than GraphQL, a framework which empowers the client to ask precisely for the data it needs, and nothing more?
Adaptive Intent-based CLI State Machines by Shawn Wang​

In designing oclif, Jeff Dickey wrote out 12 CLI factors to keep in mind. In this talk, Shawn Wang outlines a 13th: state. State is hard, because it depends on context, and context depends on understanding what a user intends to do, not what they are asking. Shawn is working towards enabling oclif to better understand the commands a user has entered, so that it can predict and interpret future commands that might be entered next. This would enable CLI tools to not just interpret a users' commands, but to also interpret their intent.\n\nIntroducing `oclif init` commandApril 10, 2024 · 2 min readThanks to the contribution of @joshcanhelp we released a new command for the oclif CLI called oclif init in version 4.8.0
The oclif init command allows you to initialize oclif in an existing project directory by adding the bare minimum requirements: a few pieces of configuration, bin scripts, and a couple of dependencies (@oclif/core and ts-node). This is slightly different from oclif generate, which will create an entirely new oclif project based on our templates.
oclif init will add the following:

bin scripts: bin/run.js, bin/run.cmd, bin/dev.js, and bin/dev.cmd
oclif section to package.json with bin, dirname, commands, and topicSeparator set (See Configuring Your CLI for more)
@oclif/core to dependencies in your package.json (if it's not already there)
ts-node to devDependencies in your package.json (if it's not already there)

Once you've initialized oclif, you can use the bin scripts to execute your CLI. You can also use the other oclif commands like oclif generate command and oclif generate hook to start adding new functionality.

❯ oclif init --helpInitialize a new oclif CLIUSAGE  $ oclif init [--bin <value>] [--module-type ESM|CommonJS] [--package-manager npm|yarn|pnpm] [--topic-separator    colons|spaces] [-d <value>] [-y]FLAGS  -d, --output-dir=<value>        Directory to initialize the CLI in.  -y, --yes                       Use defaults for all prompts. Individual flags will override defaults.      --bin=<value>               Supply answer for prompt: Command bin name the CLI will export      --module-type=<option>      Supply answer for prompt: Select a module type                                  <options: ESM|CommonJS>      --package-manager=<option>  Supply answer for prompt: Select a package manager                                  <options: npm|yarn|pnpm>      --topic-separator=<option>  Supply answer for prompt: Select a topic separator                                  <options: colons|spaces>DESCRIPTION  Initialize a new oclif CLI  This will add the necessary oclif bin files, add oclif config to package.json, and install @oclif/core and ts-node.EXAMPLES  Initialize a new CLI in the current directory    $ oclif init  Initialize a new CLI in a different directory    $ oclif init --output-dir "/path/to/existing/project"  Supply answers for specific prompts    $ oclif init --topic-separator colons --bin mycli
Hope you enjoy the new command! If you come across any issues or have any new ideas for this command, head over to the oclif/oclif repo and open a new issue.
All our best,
The oclif teamoclif Spring 2024 UpdateMarch 29, 2024 · 4 min readHello oclif developers! It's been a while since we last uploaded a blog - and a lot has happened.
We've been focusing on these high-level areas over the past couple of years:

Improving @oclif/core
ESM Support
Improving and revitalizing oclif.io
Re-engaging the oclif community

Improving @oclif/core​
Since we announced @oclif/core over three years ago, we've released two new major versions, each packed with lots of features that we're really excited about.
Here are some of these changes:

Full support for ESM and interoperability with CommonJS (more on this topic below).
Configurable command discovery strategies that give you more control over how commands are loaded at runtime. Check out the docs.
A new preparse hook that allows you to manipulate the provided arguments before they're parsed. Salesforce used this hook to implement a neat --flags-dir feature that translates local files into flags.
A new Performance class that you can use to track performance inside of @oclif/core and your own CLI or plugin. Check out the docs.
A new flag type, Flags.option, that lets you define a flag with a preset list of options. Typescript then uses the options to infer the flag's type.
Flags now have a relationship property that allows you to define more complex relationships between flags. Check out the flags docs for more information.
Flags now have a defaultHelp property that allows you to set the human readable default value in the command help. This property is useful when your flag's parse method returns a complex type, such as an object or a class. Check out the flags docs for more.
Commands now have a hiddenAliases property that allows you to define aliases that you want to hide from the user. The property is super helpful when you're trying to wean users off a deprecated command.
You can now use bun or tsx as dev runtimes (as opposed to node or ts-node).
A command's usage, args, and flags are now shown whenever a user forgets to provide a required arg or flag, or when they provided a non-existent flag.

If you need help migrating to the latest version, head over to core's README which has links to the migration guides. Feel free to open a new discussion if you need more hands-on help from us or the community.
ESM Support​
Version 3 of @oclif/core introduced full support for developing ESM plugins and CLIs. It also offered full support for interoperability between CommonJS and ESM plugins.
Put more simply, you can now migrate your CLI to ESM while keeping individual plugins in CommonJS (or vice versa). The upgrade path is now much simpler for you. You also don't need to worry about any community plugins that have migrated to ESM before you did (such as all the @oclif plugins) or are staunchly sticking with CommonJS for the foreseeable future.
Read more about this topic here.
Improving and Revitalizing oclif.io​
Another area of focus for us has been improving our documentation site, oclif.io.
While improving the quality and accuracy of the documentation was our priority, we also took the time to upgrade to the latest version of docusaurus. This new version gave our site a much-needed facelift, as well as cool new features such as dark mode and announcements.
If you have any feedback or are running into issues, we want to hear about it. Just create an issue in the oclif.io repo.
Re-engaging the oclif Community​
Lastly, our biggest priority at the moment is to re-engage the oclif community. We understand how frustrating it has been over the years to see your issues and pull requests go unacknowledged. We apologize for not prioritizing the community, and are earnestly trying to make sure that every issue and pull request gets the attention it deserves going forward.
We also opened up GitHub discussions for @oclif/core and the oclif CLI, where you can now post your questions or ideas. We hope you take advantage of them, we love hearing from you!
One last thing: we intend to publicly post our roadmap so you have more visibility into what we're working on. Stay tuned!
All our best,
The oclif teamAnnouncing oclif v2!January 12, 2022 · 5 min readHello and happy new year! It's our great pleasure to announce that we have released oclif v2, which uses the new @oclif/core library! 🎉
oclif v2 includes many changes that improve the experience of both creating and using an oclif CLI.
Going forward, we don't plan to make any updates to oclif v1 and its corresponding libraries, except for critical security fixes. See the compatibility matrix for a list of these libraries. In order to give developers time to migrate from v1 to v2, we're not completely dropping support yet. But at some point in the future we'll archive the v1 repositories and deprecate their versions on npm.
What’s changing?​
Repository Changes​
All repositories under the oclif org now use main as their primary branch and oclif-v1 as the legacy branch. The main  branch corresponds to oclif v2 and the oclif-v1 branch to oclif v1. If you find any repos that don’t have a main branch, you can safely assume that they're not used in oclif v2 and will be deprecated in the future.
Consolidating Tools & Libraries​
The oclif-dev CLI has now been incorporated into oclif. You now no longer need to install a separate package to manage your entire CLI’s lifecycle.
The following libraries have been consolidated under @oclif/core and will be deprecated at some point in the future. Read the migration guide to learn how to update your CLI or plugin to use the new core library.

@oclif/command
@oclif/config
@oclif/error
@oclif/help
@oclif/parser

No more single vs multi command CLIs​
There's only one "type" of oclif v2 CLI, but it can have as few or as many commands as a developer wants. As a result, there’s only one command to generate CLIs, oclif generate, as opposed to the old oclif single and oclif multi commands.
Node > 12​
To ensure oclif CLIs are as secure as possible, all v2 libraries and plugins support only Node 12 or higher as of now. Going forward, they'll support only Node Maintenance or higher, as defined by Node's release schedule here: https://nodejs.org/en/about/releases/.
What’s new?​
New example CLI​
oclif-hello-world is our new example repo. This is also the repo that's used as a template when running oclif generate to create a new CLI. This repo will always be able to be referenced as an example of what an oclif v2 CLI should look like.
Spaced commands​
oclif CLIs can now use spaces, instead of colons, to separate topics and subcommands. To enable this feature, simply add “topicSeparator": " " to the oclif config in your package.json. See an example in our example repo.
// Old commands that use :$ mycli do:something
// New spaced commands$ mycli do something

Note: Spaced commands are backwards compatible. So if you enable spaced commands for your CLI, users will still be able to use : as a separator. This ensures that any existing scripts don't break.

New Help Output​
We’ve revamped the way command help is outputted to the terminal, making it both easier to implement and easier to read. See the difference between the old help output on the left and the new help output on the right in the screenshots below.
oclif v1oclif v2
Notice that there are new sections for flags and global flags, examples are displayed with better spacing, and there is a section at the bottom called Configuration Variables. This Configuration Variables section is not part of the new help by default. But we've added support for custom help sections, which is what the sf CLI uses to create the new section.
Async Command Parsing​
We’ve also improved the performance of new CLIs by rewriting how commands are parsed on initialization. The new parser is asynchronous, which makes CLIs with a lot of commands or installed  plugins much faster.
What’s coming next?​
Part of our charter for the release of oclif v2 includes improving our engagement with the oclif community. We know that over the past couple of years we’ve reduced our involvement, and a lot of issues and PRs have languished in limbo. Hopefully you’ve already seen increased activity and responses from oclif maintainers recently, but if you haven’t, please don’t hesitate to ping us by tagging @admins in oclif repos.
We also want to start interviewing members of the oclif community to acquire feedback and prioritize the features and fixes you deem most important!
Best,
The oclif team

Reference material​
Migration Guide​
This guide explains how to upgrade a CLI or plugin from the old oclif v1 libraries to the new @oclif/core library that oclif v2 uses.
https://github.com/oclif/core/blob/main/MIGRATION.md
Compatibility Matrix​
The following matrix shows how the v1 libraries and plugins relate to the new v2 ones. Use this matrix as a guide to know what to drop and which versions to switch when upgrading your plugins and CLIs to v2.
oclif "v1"oclif "v2"Utility CLIsoclif@<2@oclif/dev-cli@<2oclif@>=2Main packages@oclif/command@oclif/config@oclif/errors@oclif/parser@oclif/plugin-help@oclif/core@>=1Node LTSNode v8-14Node v12+ (at time of writing)TypeScripttypescript@<4typescript@>=4Main plugins@oclif/plugin-autocomplete@<1@oclif/plugin-commands@<2@oclif/plugin-help@<4@oclif/plugin-not-found@<2@oclif/plugin-plugins@<2@oclif/plugin-update@<2plugin-warn-if-update-available@<2plugin-which@<2@oclif/plugin-autocomplete@>=1@oclif/plugin-commands@>=2@oclif/plugin-help@>=4@oclif/plugin-not-found@>=2@oclif/plugin-plugins@>=2@oclif/plugin-update@>=2@oclif/plugin-warn-if-update-available@>=2@oclif/plugin-which@>=2Introducing @oclif/coreMarch 1, 2021 · 3 min readGreetings!
We hope this blog post finds you well.
Introducing...​
We are excited to announce the next iteration of the oclif project today: @oclif/core.
We have learned a lot in the last three years of developing oclif, developing on oclif and supporting millions of command runs a day via Heroku and Salesforce CLIs.
@oclif/core ("Core") simplifies the oclif development experience and introduces highly requested new features.
Core combines the essential oclif packages into one "core" package, aptly named @oclif/core.
Core also introduces:

A default command option
Colon or space command syntax
Async command parsing
Command piping to arguments

With the introduction of default command functionality, Core simplifies the oclif project and removes the notion of single or multi command CLIs. Core CLIs can have 1 or many commands.
Along with Core, we moved the oclif-dev CLI into the oclif CLI creating a single "utility" CLI. This CLI also introduces a new AWS S3 compatible publishing scheme.
What to expect in the near future​
Core is in pre-release beta and being actively developed for new internal Salesforce CLIs.
Much documentation needs to be written in the coming months including migration paths. Migration onto Core should be as painless as possible with many exports remaining entirely unchanged. Look for forthcoming blog posts and documentation on oclif.io.
Early this summer, tentively June 1, we will release Core v1. Core's release will coincide with major bumps to many other oclif plugin packages. See the compatibility matrix below.
At Core's v1 release, the current "main" oclif packages (namely: command, config, errors & parser) will go into maintenance mode until Jan 2022. They will receive only bug and security fixes and they remain compatible with current versions of the oclif and oclif-dev CLIs. Afterwhich, they will be archived.
Companioning Core, the next major release of the oclif CLI (literally oclif@2) will generate Core CLIs.
Going forward​
We are excited to release Core! We invite you to poke around the Core repo. It may appear to be a big change but Core keeps what you already enjoy about oclif while reducing development complexity, project dependencies, package coupling and bundle size and introduces many requested features previously too prickly to weave into the current oclif architecture.
Best,
The oclif team
Reference: Compatibility matrix​
oclif "v1"oclif "Core"Utility CLIsoclif@<2@oclif/dev-cli@<2oclif@>=2Main packages@oclif/core@<2@oclif/config@<2@oclif/errors@<2@oclif/parser@<4@oclif/plugin-help@<4@oclif/core@>=1Node LTSNode v8-14Node v12+TypeScripttypescript@<4typescript@>=4Main plugins@oclif/plugin-autocomplete@<1@oclif/plugin-commands@<2@oclif/plugin-help@<4@oclif/plugin-not-found@<2@oclif/plugin-plugins@<2@oclif/plugin-update@<2plugin-warn-if-update-available@<2plugin-which@<2@oclif/plugin-autocomplete@>=2@oclif/plugin-commands@>=2@oclif/plugin-help@>=4@oclif/plugin-not-found@>=2@oclif/plugin-plugins@>=2@oclif/plugin-update@>=2@oclif/plugin-warn-if-update-available@>=2@oclif/plugin-which@>=2oclif Summer 2020 UpdateAugust 26, 2020 · 2 min readHello oclif developers! We hope you are all doing well.
Earlier this year, we started our planning for oclifconf v2 and, like all conference, had to change course. We opted not to hold a virtual conference, however, we wanted to take some time to highlight a few oclif features shipped this year.
Feature: Help templating​
One of the most requested features, help templating enables oclif developers to customize the help output for their CLI.
Read the announcement.
Feature: Custom error delegation​
This feature both improved how oclif throws and handles errors and allows oclif developers to overwrite or interject in oclif’s error handling.
Read the announcement.
Feature: postrun hooks​
We have added a new lifecycle event postrun. Your CLI can now run a hook after a command has ran.
See our hook documentation.
Feature: Root index command​
Previously, oclif would display CLI help if only the binary name with no command ID was invoked, oclif now supports a "root index" command. If present, a command defined at src/commands/index.ts will be run if no command ID is found.
1 million weekly downloads​
While exact oclif usage metrics are hard to pin down, we use npm download statistics of oclif packages as a rough approximation. Earlier this year, oclif's command package hit 1 million weekly downloads for the first time!
This year has been presented its challenges on everyone. We want to thank you, oclif developers, whom have taken the time to use and improve the oclif project. We look forward to seeing you all - in person - in the future!
All our best,
The oclif teamPretty Printable ErrorsJuly 1, 2020 · One min readOften CLIs are used as handy tools and when things go wrong it’s useful to have additional context. In oclif we have added a couple of additional properties that can show extra context to the users when an error is displayed. The code, ref and suggestions will now be displayed if they are included. This will work with an existing oclif CLI by adding the latest @oclif/errors and @oclif/core to the CLI's package.json dependencies.
For example, using this.error with the additional properties:
class TestError extends Command {  async run() {    this.error("An error has occurred!", {      code: "OCLIF_ERR",      ref: "https://oclif.io/docs/commands#thiserrormessage-string--error-options-code-string-exit-number",      suggestions: ["Use these extra properties to provide additional context"],    })  }}
would result with the following output:
›   Error: An error has occurred!›   Code: OCLIF_ERR›   Try this: Use these extra properties to provide additional context›   Reference: https://oclif.io/docs/commands#thiserrormessage-string--error-options-code-string-exit-number
If these properties are not provided then nothing changes and the CLI will continue to display the single error message output as it did before. Additionally, as part of this exercise we’ve added documentation around Error Handling in oclif which should come in handy if the need arises to extend oclif’s default handling of errors.Customizing Help in oclifMay 5, 2020 · 2 min readOut of the box oclif provides a great help experience for CLIs.
But what if, as an oclif developer, you want to customize some or all of the output?
You can now customize your CLI's help output by implementing the HelpBase abstract class.
Getting started with custom help​
If you have not done so yet, update @oclif/core.
$ yarn add --latest @oclif/core
To get started, first define the filepath to your help class in oclif's config in package.json. This is a relative path to the help class, without a file extension.
For this example, the help class will be created in a file at "[project root]/src/help.ts".
{  // ...  "oclif": {    "helpClass": "./lib/help"    // ...  }  // ...}
From here there are two paths, implement the HelpBase abstract class yourself or overwrite the parts of the default Help class you want to customize (ex: how command usage is displayed). We recommend the latter approach but cover both in the new Help Classes docs.
Separating TOPICS & COMMANDS in the new default Help class​
Previously, topics and child commands were listed in help output under a single list heading called "COMMANDS". But we found this can be slightly confusing. Some topics are commands also (a.k.a. topic-commands) while others are simply organizational namespacing (and when ran just show their help).
The new default Help class splits the list of children into distinct lists of "TOPICS" and "COMMANDS", with the possibility of an item appearing in both if it a topic-command. This makes it clearer what is expected to be ran - "COMMANDS" - and what is providing structure - "TOPICS" - when looking at the help output.
VERSION  plugin-help-example/0.0.0 darwin-x64 node-v12.12.0USAGE  $ plugin-help-example [COMMAND]TOPICS  topic  this is a topic and has child topics or commandsCOMMANDS  hello  describe the command here  help   display help for plugin-help-example
We look forward to seeing what custom help features you implement in your oclif CLIs with this new feature!oclif TSLint to ESLint MigrationDecember 5, 2019 · 3 min readBack in February of this year, plans were announced to deprecate TSLint in favor of ESLint. TSLint's goal has become to work toward a “unified developer experience” by supporting ESLint development going forward.
What has changed in oclif​
To keep inline with the community, oclif has transitioned to ESLint for all our core libraries as well as all our official plugins.
Starting in v1.15.x, oclif will now optionally generate projects with ESLint for both TypeScript and JavaScript CLI’s.
ESLint does require Node to be on stable LTS version, at the time of writing, Node 8.10.x, Node 10.13.x & Node 12.x.x.
How does this affect you​
Existing CLI’s are unchanged, but any newly generated CLI's will only give the option of using ESLint. If you are running tslint in your CLI, we recommend you switch to ESLint as well.
In migrating our projects we took the following steps (for an example of these changes see this pull request).


Install eslint
$ yarn add eslint eslint-config-oclif eslint-config-oclif-typescript --dev


Add eslint related files


$ echo '{  "extends": [    "oclif",    "oclif-typescript"  ],  "rules": {  }}' > .eslintrc


Remove tslint and related packages
$ yarn remove @oclif/tslint tslint


Remove tslint related configuration files
$ rm tslint.json


Change lint script in our package.json from something like:
"lint": "tsc -p test --noEmit && tslint -p test -t stylish"
to
"lint": "eslint . --ext .ts --config .eslintrc"


To preserve the test compile (tsc -p test --noEmit) we also made the following updates to our scripts:
"pretest": "tsc -p test --noEmit"
In some cases we had our posttest duplicating the same steps as our lint script so it’s cleaner to have it reference the lint job directly with:
"posttest": "yarn lint"

Run yarn lint --fix. This attempts to auto-fix any linting violations automatically. In the case an auto-fix isn’t available it should be fixed manually or ignored (see the eslint configuration doc for more information)
Do a search in the codebase for tslint and remove any unnecessary tslint disabling comments, like:

/* tslint:disable:object-literal-sort-keys */
If you are on a version of Node that is not supported by ESLint, you will also need to update your Node engine. ESLint supports Node 8, 10, and 12 so you should upgrade to the most recent Node version compatible with your CLI and also supported by ESLint (see ESLint's Installation and Usage instructions).
When will this take effect​
These changes have taken effect in oclif v1.15.1. When you generate a new CLI or plugin it will now contain configuration for ESLint instead of TSLint.oclif's Current Node SupportOctober 31, 2019 · 3 min readTo maintain a healthy project trajectory, oclif follows and supports Node Active LTS release, currently Node 10 & Node 12. This means ensuring that oclif continues to play nice with coming Active LTS Node versions and other packages in the ecosystem. Moving forward also means leaving older versions behind. Starting in 2020, Node will stop maintaining Node 8 and it is our intent at that time to also follow suit. Let’s take a look at a few ways we will be supporting these changes.
CI Environments​
CLIs created with the oclif cli going forward will be generated with a CircleCI configuration with Node 10 & 12 and an Appveyor configuration using Node 10. We have also added Node latest to CircleCi to be an early warning detection against coming Node changes (Node latest is managed by CircleCI).
We have already updated every oclif repo's CI configs to reflect this.
If your existing CLI uses either Appveyor or CircleCI you can update your config files also, like so:
.circleci/config.yml​
Your CircleCI config should contain a node-latest job, aliased as test. From this, there should be two extensions of this job for the Active LTS Node versions, Node 10 and Node 12.
  node-10:    <<: *node-latest    docker:      - image: node:10  node-12:    <<: *node-latest    docker:      - image: node:12
Notice that these declarations only change the Docker Node images used to run that job.
Additionally, the jobs listed within workflows must also be updated to reflect our changes in configuration:
    jobs:      - node-latest      - node-10      - node-12
appveyor.yml​
For appveyor we are currently only testing the oldest Active LTS Node version, Node 10. Update the nodejs_version proppert in your appveyor.yml file to reflect this.
environment:  nodejs_version: "10"
Deprecating Node 8 & Updating packge.json engines​
In Jan 2020, Node will end its Node 8 maintenance. We will follow suit by setting the package.json engine property in oclif packages to >=10 and bumping the package's major versions.
Depending on how you ship your CLI you may wish to also bump the engines version in your CLI's package.json. You can read more about the implications of the engines property configuration in the npm documentation.
Also consider distributing your CLI with its own Node version.
Packaged Node Version​
When using dev-cli to pack your CLI it will use the Node version as specified in your package.json under the oclif.update.node.version property. This value should reflect an Active LTS Node version (dev-cli does not currently enforce versions).
Supporting the future​
As a community we may discover bumps along the way as we upgrade. If you notice something related to oclif please feel free to open an issue or submit a pull request under the relevant oclif package within the org.
We look forward to using the latest from Node and the community and keeping oclif healthy along the way.oclifconf 2019: A RecapSeptember 16, 2019 · 4 min readIn May, Heroku and Salesforce Open Source organized oclifconf, a conference for developers & product managers building CLI tools on top of the open source oclif framework. The speakers came from various tech companies, such as Adobe, Netlify, and Apollo, who have already built amazing CLI experiences. The topics covered everything from the incredible capabilities oclif has unlocked, to the community-built plugins extending its functionality, and even what the behavior of an adaptive CLI tool might look like.
Below is a listing of all of the talks from the event, along with a short summary. Enjoy!
The future of oclif by Jeff Dickey​

In its relatively short lifetime, oclif has already inspired many developers and companies to adopt its framework as a means for implementing their own command-line tooling. In this talk, Jeff Dickey, an oclif founding team member, recaps the project's history and inspiration. He also looks towards the future and outlines some features and improvements that the tool could adapt. This isn't so much a definitive roadmap of where oclif is headed, but rather, a call to inspiration for developers eager to contribute! And if you are interested in contributing, check out the open issues in the oclif GitHub repo and come say "Hello!" on Spectrum Chat.
Open Source Citizenship by Josh Simmons​

When it comes to open source, it's more than just individuals now. More and more frequently, large corporations are contributing to projects by donating to contributors, sponsoring events, or upstreaming contributions. But keeping open source projects and communities healthy requires more than just money and brainpower. Josh Simmons surveyed multiple open source communities and relays his findings as to what help maintainers and contributors actually need in this talk.
Building an enterprise-grade CLI with oclif by Thomas Dvornik​

Security and performance are all about trust. While oclif is an extremely extensible framework for building CLI tooling, there are additional requirements to fulfill for enterprise businesses to adopt it that might not be necessary for individual developers. Thomas Dvornik outlines what he and his colleagues at Salesforce have implemented as plugins to oclif to satisfy these needs, including encrypted OAuth, plugin signing, lazy loading dependencies, synchronizing weekly releases and deprecations across dozens of repositories, and establishing cross-team coding and documentation standards.
How Adobe I/O built an extensible CLI with oclif by Jesse MacFadyen​

Perhaps oclif's most appealing feature is its support for plugins. In Cordova's case, they've created a sophisticated telemetry system that helps Adobe developers see which commands users are using--and reports on which ones are erroring out. By embedding a feedback system into the tool, users are even able to quickly send their suggestions to a form, without ever leaving the terminal. Jesse MacFadyen demonstrates how oclif's plugin system can work beyond simply executing commands.
Integrating oclif with GraphQL and Apollo by Evans Hauser​

For Evans Hauser and the team at Apollo, oclif is best thought of as "React for the CLI." As a client paired with a strongly-typed API contract to a server, it can deliver structured and consistent commands to retrieve external data. What better mechanism to use for this transfer than GraphQL, a framework which empowers the client to ask precisely for the data it needs, and nothing more?
Adaptive Intent-based CLI State Machines by Shawn Wang​

In designing oclif, Jeff Dickey wrote out 12 CLI factors to keep in mind. In this talk, Shawn Wang outlines a 13th: state. State is hard, because it depends on context, and context depends on understanding what a user intends to do, not what they are asking. Shawn is working towards enabling oclif to better understand the commands a user has entered, so that it can predict and interpret future commands that might be entered next. This would enable CLI tools to not just interpret a users' commands, but to also interpret their intent.Older Entries\n\n\n\nIntroducing `oclif init` commandApril 10, 2024 · 2 min readThanks to the contribution of @joshcanhelp we released a new command for the oclif CLI called oclif init in version 4.8.0
The oclif init command allows you to initialize oclif in an existing project directory by adding the bare minimum requirements: a few pieces of configuration, bin scripts, and a couple of dependencies (@oclif/core and ts-node). This is slightly different from oclif generate, which will create an entirely new oclif project based on our templates.
oclif init will add the following:

bin scripts: bin/run.js, bin/run.cmd, bin/dev.js, and bin/dev.cmd
oclif section to package.json with bin, dirname, commands, and topicSeparator set (See Configuring Your CLI for more)
@oclif/core to dependencies in your package.json (if it's not already there)
ts-node to devDependencies in your package.json (if it's not already there)

Once you've initialized oclif, you can use the bin scripts to execute your CLI. You can also use the other oclif commands like oclif generate command and oclif generate hook to start adding new functionality.

❯ oclif init --helpInitialize a new oclif CLIUSAGE  $ oclif init [--bin <value>] [--module-type ESM|CommonJS] [--package-manager npm|yarn|pnpm] [--topic-separator    colons|spaces] [-d <value>] [-y]FLAGS  -d, --output-dir=<value>        Directory to initialize the CLI in.  -y, --yes                       Use defaults for all prompts. Individual flags will override defaults.      --bin=<value>               Supply answer for prompt: Command bin name the CLI will export      --module-type=<option>      Supply answer for prompt: Select a module type                                  <options: ESM|CommonJS>      --package-manager=<option>  Supply answer for prompt: Select a package manager                                  <options: npm|yarn|pnpm>      --topic-separator=<option>  Supply answer for prompt: Select a topic separator                                  <options: colons|spaces>DESCRIPTION  Initialize a new oclif CLI  This will add the necessary oclif bin files, add oclif config to package.json, and install @oclif/core and ts-node.EXAMPLES  Initialize a new CLI in the current directory    $ oclif init  Initialize a new CLI in a different directory    $ oclif init --output-dir "/path/to/existing/project"  Supply answers for specific prompts    $ oclif init --topic-separator colons --bin mycli
Hope you enjoy the new command! If you come across any issues or have any new ideas for this command, head over to the oclif/oclif repo and open a new issue.
All our best,
The oclif teamoclif Spring 2024 UpdateMarch 29, 2024 · 4 min readHello oclif developers! It's been a while since we last uploaded a blog - and a lot has happened.
We've been focusing on these high-level areas over the past couple of years:

Improving @oclif/core
ESM Support
Improving and revitalizing oclif.io
Re-engaging the oclif community

Improving @oclif/core​
Since we announced @oclif/core over three years ago, we've released two new major versions, each packed with lots of features that we're really excited about.
Here are some of these changes:

Full support for ESM and interoperability with CommonJS (more on this topic below).
Configurable command discovery strategies that give you more control over how commands are loaded at runtime. Check out the docs.
A new preparse hook that allows you to manipulate the provided arguments before they're parsed. Salesforce used this hook to implement a neat --flags-dir feature that translates local files into flags.
A new Performance class that you can use to track performance inside of @oclif/core and your own CLI or plugin. Check out the docs.
A new flag type, Flags.option, that lets you define a flag with a preset list of options. Typescript then uses the options to infer the flag's type.
Flags now have a relationship property that allows you to define more complex relationships between flags. Check out the flags docs for more information.
Flags now have a defaultHelp property that allows you to set the human readable default value in the command help. This property is useful when your flag's parse method returns a complex type, such as an object or a class. Check out the flags docs for more.
Commands now have a hiddenAliases property that allows you to define aliases that you want to hide from the user. The property is super helpful when you're trying to wean users off a deprecated command.
You can now use bun or tsx as dev runtimes (as opposed to node or ts-node).
A command's usage, args, and flags are now shown whenever a user forgets to provide a required arg or flag, or when they provided a non-existent flag.

If you need help migrating to the latest version, head over to core's README which has links to the migration guides. Feel free to open a new discussion if you need more hands-on help from us or the community.
ESM Support​
Version 3 of @oclif/core introduced full support for developing ESM plugins and CLIs. It also offered full support for interoperability between CommonJS and ESM plugins.
Put more simply, you can now migrate your CLI to ESM while keeping individual plugins in CommonJS (or vice versa). The upgrade path is now much simpler for you. You also don't need to worry about any community plugins that have migrated to ESM before you did (such as all the @oclif plugins) or are staunchly sticking with CommonJS for the foreseeable future.
Read more about this topic here.
Improving and Revitalizing oclif.io​
Another area of focus for us has been improving our documentation site, oclif.io.
While improving the quality and accuracy of the documentation was our priority, we also took the time to upgrade to the latest version of docusaurus. This new version gave our site a much-needed facelift, as well as cool new features such as dark mode and announcements.
If you have any feedback or are running into issues, we want to hear about it. Just create an issue in the oclif.io repo.
Re-engaging the oclif Community​
Lastly, our biggest priority at the moment is to re-engage the oclif community. We understand how frustrating it has been over the years to see your issues and pull requests go unacknowledged. We apologize for not prioritizing the community, and are earnestly trying to make sure that every issue and pull request gets the attention it deserves going forward.
We also opened up GitHub discussions for @oclif/core and the oclif CLI, where you can now post your questions or ideas. We hope you take advantage of them, we love hearing from you!
One last thing: we intend to publicly post our roadmap so you have more visibility into what we're working on. Stay tuned!
All our best,
The oclif teamAnnouncing oclif v2!January 12, 2022 · 5 min readHello and happy new year! It's our great pleasure to announce that we have released oclif v2, which uses the new @oclif/core library! 🎉
oclif v2 includes many changes that improve the experience of both creating and using an oclif CLI.
Going forward, we don't plan to make any updates to oclif v1 and its corresponding libraries, except for critical security fixes. See the compatibility matrix for a list of these libraries. In order to give developers time to migrate from v1 to v2, we're not completely dropping support yet. But at some point in the future we'll archive the v1 repositories and deprecate their versions on npm.
What’s changing?​
Repository Changes​
All repositories under the oclif org now use main as their primary branch and oclif-v1 as the legacy branch. The main  branch corresponds to oclif v2 and the oclif-v1 branch to oclif v1. If you find any repos that don’t have a main branch, you can safely assume that they're not used in oclif v2 and will be deprecated in the future.
Consolidating Tools & Libraries​
The oclif-dev CLI has now been incorporated into oclif. You now no longer need to install a separate package to manage your entire CLI’s lifecycle.
The following libraries have been consolidated under @oclif/core and will be deprecated at some point in the future. Read the migration guide to learn how to update your CLI or plugin to use the new core library.

@oclif/command
@oclif/config
@oclif/error
@oclif/help
@oclif/parser

No more single vs multi command CLIs​
There's only one "type" of oclif v2 CLI, but it can have as few or as many commands as a developer wants. As a result, there’s only one command to generate CLIs, oclif generate, as opposed to the old oclif single and oclif multi commands.
Node > 12​
To ensure oclif CLIs are as secure as possible, all v2 libraries and plugins support only Node 12 or higher as of now. Going forward, they'll support only Node Maintenance or higher, as defined by Node's release schedule here: https://nodejs.org/en/about/releases/.
What’s new?​
New example CLI​
oclif-hello-world is our new example repo. This is also the repo that's used as a template when running oclif generate to create a new CLI. This repo will always be able to be referenced as an example of what an oclif v2 CLI should look like.
Spaced commands​
oclif CLIs can now use spaces, instead of colons, to separate topics and subcommands. To enable this feature, simply add “topicSeparator": " " to the oclif config in your package.json. See an example in our example repo.
// Old commands that use :$ mycli do:something
// New spaced commands$ mycli do something

Note: Spaced commands are backwards compatible. So if you enable spaced commands for your CLI, users will still be able to use : as a separator. This ensures that any existing scripts don't break.

New Help Output​
We’ve revamped the way command help is outputted to the terminal, making it both easier to implement and easier to read. See the difference between the old help output on the left and the new help output on the right in the screenshots below.
oclif v1oclif v2
Notice that there are new sections for flags and global flags, examples are displayed with better spacing, and there is a section at the bottom called Configuration Variables. This Configuration Variables section is not part of the new help by default. But we've added support for custom help sections, which is what the sf CLI uses to create the new section.
Async Command Parsing​
We’ve also improved the performance of new CLIs by rewriting how commands are parsed on initialization. The new parser is asynchronous, which makes CLIs with a lot of commands or installed  plugins much faster.
What’s coming next?​
Part of our charter for the release of oclif v2 includes improving our engagement with the oclif community. We know that over the past couple of years we’ve reduced our involvement, and a lot of issues and PRs have languished in limbo. Hopefully you’ve already seen increased activity and responses from oclif maintainers recently, but if you haven’t, please don’t hesitate to ping us by tagging @admins in oclif repos.
We also want to start interviewing members of the oclif community to acquire feedback and prioritize the features and fixes you deem most important!
Best,
The oclif team

Reference material​
Migration Guide​
This guide explains how to upgrade a CLI or plugin from the old oclif v1 libraries to the new @oclif/core library that oclif v2 uses.
https://github.com/oclif/core/blob/main/MIGRATION.md
Compatibility Matrix​
The following matrix shows how the v1 libraries and plugins relate to the new v2 ones. Use this matrix as a guide to know what to drop and which versions to switch when upgrading your plugins and CLIs to v2.
oclif "v1"oclif "v2"Utility CLIsoclif@<2@oclif/dev-cli@<2oclif@>=2Main packages@oclif/command@oclif/config@oclif/errors@oclif/parser@oclif/plugin-help@oclif/core@>=1Node LTSNode v8-14Node v12+ (at time of writing)TypeScripttypescript@<4typescript@>=4Main plugins@oclif/plugin-autocomplete@<1@oclif/plugin-commands@<2@oclif/plugin-help@<4@oclif/plugin-not-found@<2@oclif/plugin-plugins@<2@oclif/plugin-update@<2plugin-warn-if-update-available@<2plugin-which@<2@oclif/plugin-autocomplete@>=1@oclif/plugin-commands@>=2@oclif/plugin-help@>=4@oclif/plugin-not-found@>=2@oclif/plugin-plugins@>=2@oclif/plugin-update@>=2@oclif/plugin-warn-if-update-available@>=2@oclif/plugin-which@>=2Introducing @oclif/coreMarch 1, 2021 · 3 min readGreetings!
We hope this blog post finds you well.
Introducing...​
We are excited to announce the next iteration of the oclif project today: @oclif/core.
We have learned a lot in the last three years of developing oclif, developing on oclif and supporting millions of command runs a day via Heroku and Salesforce CLIs.
@oclif/core ("Core") simplifies the oclif development experience and introduces highly requested new features.
Core combines the essential oclif packages into one "core" package, aptly named @oclif/core.
Core also introduces:

A default command option
Colon or space command syntax
Async command parsing
Command piping to arguments

With the introduction of default command functionality, Core simplifies the oclif project and removes the notion of single or multi command CLIs. Core CLIs can have 1 or many commands.
Along with Core, we moved the oclif-dev CLI into the oclif CLI creating a single "utility" CLI. This CLI also introduces a new AWS S3 compatible publishing scheme.
What to expect in the near future​
Core is in pre-release beta and being actively developed for new internal Salesforce CLIs.
Much documentation needs to be written in the coming months including migration paths. Migration onto Core should be as painless as possible with many exports remaining entirely unchanged. Look for forthcoming blog posts and documentation on oclif.io.
Early this summer, tentively June 1, we will release Core v1. Core's release will coincide with major bumps to many other oclif plugin packages. See the compatibility matrix below.
At Core's v1 release, the current "main" oclif packages (namely: command, config, errors & parser) will go into maintenance mode until Jan 2022. They will receive only bug and security fixes and they remain compatible with current versions of the oclif and oclif-dev CLIs. Afterwhich, they will be archived.
Companioning Core, the next major release of the oclif CLI (literally oclif@2) will generate Core CLIs.
Going forward​
We are excited to release Core! We invite you to poke around the Core repo. It may appear to be a big change but Core keeps what you already enjoy about oclif while reducing development complexity, project dependencies, package coupling and bundle size and introduces many requested features previously too prickly to weave into the current oclif architecture.
Best,
The oclif team
Reference: Compatibility matrix​
oclif "v1"oclif "Core"Utility CLIsoclif@<2@oclif/dev-cli@<2oclif@>=2Main packages@oclif/core@<2@oclif/config@<2@oclif/errors@<2@oclif/parser@<4@oclif/plugin-help@<4@oclif/core@>=1Node LTSNode v8-14Node v12+TypeScripttypescript@<4typescript@>=4Main plugins@oclif/plugin-autocomplete@<1@oclif/plugin-commands@<2@oclif/plugin-help@<4@oclif/plugin-not-found@<2@oclif/plugin-plugins@<2@oclif/plugin-update@<2plugin-warn-if-update-available@<2plugin-which@<2@oclif/plugin-autocomplete@>=2@oclif/plugin-commands@>=2@oclif/plugin-help@>=4@oclif/plugin-not-found@>=2@oclif/plugin-plugins@>=2@oclif/plugin-update@>=2@oclif/plugin-warn-if-update-available@>=2@oclif/plugin-which@>=2oclif Summer 2020 UpdateAugust 26, 2020 · 2 min readHello oclif developers! We hope you are all doing well.
Earlier this year, we started our planning for oclifconf v2 and, like all conference, had to change course. We opted not to hold a virtual conference, however, we wanted to take some time to highlight a few oclif features shipped this year.
Feature: Help templating​
One of the most requested features, help templating enables oclif developers to customize the help output for their CLI.
Read the announcement.
Feature: Custom error delegation​
This feature both improved how oclif throws and handles errors and allows oclif developers to overwrite or interject in oclif’s error handling.
Read the announcement.
Feature: postrun hooks​
We have added a new lifecycle event postrun. Your CLI can now run a hook after a command has ran.
See our hook documentation.
Feature: Root index command​
Previously, oclif would display CLI help if only the binary name with no command ID was invoked, oclif now supports a "root index" command. If present, a command defined at src/commands/index.ts will be run if no command ID is found.
1 million weekly downloads​
While exact oclif usage metrics are hard to pin down, we use npm download statistics of oclif packages as a rough approximation. Earlier this year, oclif's command package hit 1 million weekly downloads for the first time!
This year has been presented its challenges on everyone. We want to thank you, oclif developers, whom have taken the time to use and improve the oclif project. We look forward to seeing you all - in person - in the future!
All our best,
The oclif teamPretty Printable ErrorsJuly 1, 2020 · One min readOften CLIs are used as handy tools and when things go wrong it’s useful to have additional context. In oclif we have added a couple of additional properties that can show extra context to the users when an error is displayed. The code, ref and suggestions will now be displayed if they are included. This will work with an existing oclif CLI by adding the latest @oclif/errors and @oclif/core to the CLI's package.json dependencies.
For example, using this.error with the additional properties:
class TestError extends Command {  async run() {    this.error("An error has occurred!", {      code: "OCLIF_ERR",      ref: "https://oclif.io/docs/commands#thiserrormessage-string--error-options-code-string-exit-number",      suggestions: ["Use these extra properties to provide additional context"],    })  }}
would result with the following output:
›   Error: An error has occurred!›   Code: OCLIF_ERR›   Try this: Use these extra properties to provide additional context›   Reference: https://oclif.io/docs/commands#thiserrormessage-string--error-options-code-string-exit-number
If these properties are not provided then nothing changes and the CLI will continue to display the single error message output as it did before. Additionally, as part of this exercise we’ve added documentation around Error Handling in oclif which should come in handy if the need arises to extend oclif’s default handling of errors.Customizing Help in oclifMay 5, 2020 · 2 min readOut of the box oclif provides a great help experience for CLIs.
But what if, as an oclif developer, you want to customize some or all of the output?
You can now customize your CLI's help output by implementing the HelpBase abstract class.
Getting started with custom help​
If you have not done so yet, update @oclif/core.
$ yarn add --latest @oclif/core
To get started, first define the filepath to your help class in oclif's config in package.json. This is a relative path to the help class, without a file extension.
For this example, the help class will be created in a file at "[project root]/src/help.ts".
{  // ...  "oclif": {    "helpClass": "./lib/help"    // ...  }  // ...}
From here there are two paths, implement the HelpBase abstract class yourself or overwrite the parts of the default Help class you want to customize (ex: how command usage is displayed). We recommend the latter approach but cover both in the new Help Classes docs.
Separating TOPICS & COMMANDS in the new default Help class​
Previously, topics and child commands were listed in help output under a single list heading called "COMMANDS". But we found this can be slightly confusing. Some topics are commands also (a.k.a. topic-commands) while others are simply organizational namespacing (and when ran just show their help).
The new default Help class splits the list of children into distinct lists of "TOPICS" and "COMMANDS", with the possibility of an item appearing in both if it a topic-command. This makes it clearer what is expected to be ran - "COMMANDS" - and what is providing structure - "TOPICS" - when looking at the help output.
VERSION  plugin-help-example/0.0.0 darwin-x64 node-v12.12.0USAGE  $ plugin-help-example [COMMAND]TOPICS  topic  this is a topic and has child topics or commandsCOMMANDS  hello  describe the command here  help   display help for plugin-help-example
We look forward to seeing what custom help features you implement in your oclif CLIs with this new feature!oclif TSLint to ESLint MigrationDecember 5, 2019 · 3 min readBack in February of this year, plans were announced to deprecate TSLint in favor of ESLint. TSLint's goal has become to work toward a “unified developer experience” by supporting ESLint development going forward.
What has changed in oclif​
To keep inline with the community, oclif has transitioned to ESLint for all our core libraries as well as all our official plugins.
Starting in v1.15.x, oclif will now optionally generate projects with ESLint for both TypeScript and JavaScript CLI’s.
ESLint does require Node to be on stable LTS version, at the time of writing, Node 8.10.x, Node 10.13.x & Node 12.x.x.
How does this affect you​
Existing CLI’s are unchanged, but any newly generated CLI's will only give the option of using ESLint. If you are running tslint in your CLI, we recommend you switch to ESLint as well.
In migrating our projects we took the following steps (for an example of these changes see this pull request).


Install eslint
$ yarn add eslint eslint-config-oclif eslint-config-oclif-typescript --dev


Add eslint related files


$ echo '{  "extends": [    "oclif",    "oclif-typescript"  ],  "rules": {  }}' > .eslintrc


Remove tslint and related packages
$ yarn remove @oclif/tslint tslint


Remove tslint related configuration files
$ rm tslint.json


Change lint script in our package.json from something like:
"lint": "tsc -p test --noEmit && tslint -p test -t stylish"
to
"lint": "eslint . --ext .ts --config .eslintrc"


To preserve the test compile (tsc -p test --noEmit) we also made the following updates to our scripts:
"pretest": "tsc -p test --noEmit"
In some cases we had our posttest duplicating the same steps as our lint script so it’s cleaner to have it reference the lint job directly with:
"posttest": "yarn lint"

Run yarn lint --fix. This attempts to auto-fix any linting violations automatically. In the case an auto-fix isn’t available it should be fixed manually or ignored (see the eslint configuration doc for more information)
Do a search in the codebase for tslint and remove any unnecessary tslint disabling comments, like:

/* tslint:disable:object-literal-sort-keys */
If you are on a version of Node that is not supported by ESLint, you will also need to update your Node engine. ESLint supports Node 8, 10, and 12 so you should upgrade to the most recent Node version compatible with your CLI and also supported by ESLint (see ESLint's Installation and Usage instructions).
When will this take effect​
These changes have taken effect in oclif v1.15.1. When you generate a new CLI or plugin it will now contain configuration for ESLint instead of TSLint.oclif's Current Node SupportOctober 31, 2019 · 3 min readTo maintain a healthy project trajectory, oclif follows and supports Node Active LTS release, currently Node 10 & Node 12. This means ensuring that oclif continues to play nice with coming Active LTS Node versions and other packages in the ecosystem. Moving forward also means leaving older versions behind. Starting in 2020, Node will stop maintaining Node 8 and it is our intent at that time to also follow suit. Let’s take a look at a few ways we will be supporting these changes.
CI Environments​
CLIs created with the oclif cli going forward will be generated with a CircleCI configuration with Node 10 & 12 and an Appveyor configuration using Node 10. We have also added Node latest to CircleCi to be an early warning detection against coming Node changes (Node latest is managed by CircleCI).
We have already updated every oclif repo's CI configs to reflect this.
If your existing CLI uses either Appveyor or CircleCI you can update your config files also, like so:
.circleci/config.yml​
Your CircleCI config should contain a node-latest job, aliased as test. From this, there should be two extensions of this job for the Active LTS Node versions, Node 10 and Node 12.
  node-10:    <<: *node-latest    docker:      - image: node:10  node-12:    <<: *node-latest    docker:      - image: node:12
Notice that these declarations only change the Docker Node images used to run that job.
Additionally, the jobs listed within workflows must also be updated to reflect our changes in configuration:
    jobs:      - node-latest      - node-10      - node-12
appveyor.yml​
For appveyor we are currently only testing the oldest Active LTS Node version, Node 10. Update the nodejs_version proppert in your appveyor.yml file to reflect this.
environment:  nodejs_version: "10"
Deprecating Node 8 & Updating packge.json engines​
In Jan 2020, Node will end its Node 8 maintenance. We will follow suit by setting the package.json engine property in oclif packages to >=10 and bumping the package's major versions.
Depending on how you ship your CLI you may wish to also bump the engines version in your CLI's package.json. You can read more about the implications of the engines property configuration in the npm documentation.
Also consider distributing your CLI with its own Node version.
Packaged Node Version​
When using dev-cli to pack your CLI it will use the Node version as specified in your package.json under the oclif.update.node.version property. This value should reflect an Active LTS Node version (dev-cli does not currently enforce versions).
Supporting the future​
As a community we may discover bumps along the way as we upgrade. If you notice something related to oclif please feel free to open an issue or submit a pull request under the relevant oclif package within the org.
We look forward to using the latest from Node and the community and keeping oclif healthy along the way.oclifconf 2019: A RecapSeptember 16, 2019 · 4 min readIn May, Heroku and Salesforce Open Source organized oclifconf, a conference for developers & product managers building CLI tools on top of the open source oclif framework. The speakers came from various tech companies, such as Adobe, Netlify, and Apollo, who have already built amazing CLI experiences. The topics covered everything from the incredible capabilities oclif has unlocked, to the community-built plugins extending its functionality, and even what the behavior of an adaptive CLI tool might look like.
Below is a listing of all of the talks from the event, along with a short summary. Enjoy!
The future of oclif by Jeff Dickey​

In its relatively short lifetime, oclif has already inspired many developers and companies to adopt its framework as a means for implementing their own command-line tooling. In this talk, Jeff Dickey, an oclif founding team member, recaps the project's history and inspiration. He also looks towards the future and outlines some features and improvements that the tool could adapt. This isn't so much a definitive roadmap of where oclif is headed, but rather, a call to inspiration for developers eager to contribute! And if you are interested in contributing, check out the open issues in the oclif GitHub repo and come say "Hello!" on Spectrum Chat.
Open Source Citizenship by Josh Simmons​

When it comes to open source, it's more than just individuals now. More and more frequently, large corporations are contributing to projects by donating to contributors, sponsoring events, or upstreaming contributions. But keeping open source projects and communities healthy requires more than just money and brainpower. Josh Simmons surveyed multiple open source communities and relays his findings as to what help maintainers and contributors actually need in this talk.
Building an enterprise-grade CLI with oclif by Thomas Dvornik​

Security and performance are all about trust. While oclif is an extremely extensible framework for building CLI tooling, there are additional requirements to fulfill for enterprise businesses to adopt it that might not be necessary for individual developers. Thomas Dvornik outlines what he and his colleagues at Salesforce have implemented as plugins to oclif to satisfy these needs, including encrypted OAuth, plugin signing, lazy loading dependencies, synchronizing weekly releases and deprecations across dozens of repositories, and establishing cross-team coding and documentation standards.
How Adobe I/O built an extensible CLI with oclif by Jesse MacFadyen​

Perhaps oclif's most appealing feature is its support for plugins. In Cordova's case, they've created a sophisticated telemetry system that helps Adobe developers see which commands users are using--and reports on which ones are erroring out. By embedding a feedback system into the tool, users are even able to quickly send their suggestions to a form, without ever leaving the terminal. Jesse MacFadyen demonstrates how oclif's plugin system can work beyond simply executing commands.
Integrating oclif with GraphQL and Apollo by Evans Hauser​

For Evans Hauser and the team at Apollo, oclif is best thought of as "React for the CLI." As a client paired with a strongly-typed API contract to a server, it can deliver structured and consistent commands to retrieve external data. What better mechanism to use for this transfer than GraphQL, a framework which empowers the client to ask precisely for the data it needs, and nothing more?
Adaptive Intent-based CLI State Machines by Shawn Wang​

In designing oclif, Jeff Dickey wrote out 12 CLI factors to keep in mind. In this talk, Shawn Wang outlines a 13th: state. State is hard, because it depends on context, and context depends on understanding what a user intends to do, not what they are asking. Shawn is working towards enabling oclif to better understand the commands a user has entered, so that it can predict and interpret future commands that might be entered next. This would enable CLI tools to not just interpret a users' commands, but to also interpret their intent.\n\nIntroducing `oclif init` commandApril 10, 2024 · 2 min readThanks to the contribution of @joshcanhelp we released a new command for the oclif CLI called oclif init in version 4.8.0
The oclif init command allows you to initialize oclif in an existing project directory by adding the bare minimum requirements: a few pieces of configuration, bin scripts, and a couple of dependencies (@oclif/core and ts-node). This is slightly different from oclif generate, which will create an entirely new oclif project based on our templates.
oclif init will add the following:

bin scripts: bin/run.js, bin/run.cmd, bin/dev.js, and bin/dev.cmd
oclif section to package.json with bin, dirname, commands, and topicSeparator set (See Configuring Your CLI for more)
@oclif/core to dependencies in your package.json (if it's not already there)
ts-node to devDependencies in your package.json (if it's not already there)

Once you've initialized oclif, you can use the bin scripts to execute your CLI. You can also use the other oclif commands like oclif generate command and oclif generate hook to start adding new functionality.

❯ oclif init --helpInitialize a new oclif CLIUSAGE  $ oclif init [--bin <value>] [--module-type ESM|CommonJS] [--package-manager npm|yarn|pnpm] [--topic-separator    colons|spaces] [-d <value>] [-y]FLAGS  -d, --output-dir=<value>        Directory to initialize the CLI in.  -y, --yes                       Use defaults for all prompts. Individual flags will override defaults.      --bin=<value>               Supply answer for prompt: Command bin name the CLI will export      --module-type=<option>      Supply answer for prompt: Select a module type                                  <options: ESM|CommonJS>      --package-manager=<option>  Supply answer for prompt: Select a package manager                                  <options: npm|yarn|pnpm>      --topic-separator=<option>  Supply answer for prompt: Select a topic separator                                  <options: colons|spaces>DESCRIPTION  Initialize a new oclif CLI  This will add the necessary oclif bin files, add oclif config to package.json, and install @oclif/core and ts-node.EXAMPLES  Initialize a new CLI in the current directory    $ oclif init  Initialize a new CLI in a different directory    $ oclif init --output-dir "/path/to/existing/project"  Supply answers for specific prompts    $ oclif init --topic-separator colons --bin mycli
Hope you enjoy the new command! If you come across any issues or have any new ideas for this command, head over to the oclif/oclif repo and open a new issue.
All our best,
The oclif teamoclif Spring 2024 UpdateMarch 29, 2024 · 4 min readHello oclif developers! It's been a while since we last uploaded a blog - and a lot has happened.
We've been focusing on these high-level areas over the past couple of years:

Improving @oclif/core
ESM Support
Improving and revitalizing oclif.io
Re-engaging the oclif community

Improving @oclif/core​
Since we announced @oclif/core over three years ago, we've released two new major versions, each packed with lots of features that we're really excited about.
Here are some of these changes:

Full support for ESM and interoperability with CommonJS (more on this topic below).
Configurable command discovery strategies that give you more control over how commands are loaded at runtime. Check out the docs.
A new preparse hook that allows you to manipulate the provided arguments before they're parsed. Salesforce used this hook to implement a neat --flags-dir feature that translates local files into flags.
A new Performance class that you can use to track performance inside of @oclif/core and your own CLI or plugin. Check out the docs.
A new flag type, Flags.option, that lets you define a flag with a preset list of options. Typescript then uses the options to infer the flag's type.
Flags now have a relationship property that allows you to define more complex relationships between flags. Check out the flags docs for more information.
Flags now have a defaultHelp property that allows you to set the human readable default value in the command help. This property is useful when your flag's parse method returns a complex type, such as an object or a class. Check out the flags docs for more.
Commands now have a hiddenAliases property that allows you to define aliases that you want to hide from the user. The property is super helpful when you're trying to wean users off a deprecated command.
You can now use bun or tsx as dev runtimes (as opposed to node or ts-node).
A command's usage, args, and flags are now shown whenever a user forgets to provide a required arg or flag, or when they provided a non-existent flag.

If you need help migrating to the latest version, head over to core's README which has links to the migration guides. Feel free to open a new discussion if you need more hands-on help from us or the community.
ESM Support​
Version 3 of @oclif/core introduced full support for developing ESM plugins and CLIs. It also offered full support for interoperability between CommonJS and ESM plugins.
Put more simply, you can now migrate your CLI to ESM while keeping individual plugins in CommonJS (or vice versa). The upgrade path is now much simpler for you. You also don't need to worry about any community plugins that have migrated to ESM before you did (such as all the @oclif plugins) or are staunchly sticking with CommonJS for the foreseeable future.
Read more about this topic here.
Improving and Revitalizing oclif.io​
Another area of focus for us has been improving our documentation site, oclif.io.
While improving the quality and accuracy of the documentation was our priority, we also took the time to upgrade to the latest version of docusaurus. This new version gave our site a much-needed facelift, as well as cool new features such as dark mode and announcements.
If you have any feedback or are running into issues, we want to hear about it. Just create an issue in the oclif.io repo.
Re-engaging the oclif Community​
Lastly, our biggest priority at the moment is to re-engage the oclif community. We understand how frustrating it has been over the years to see your issues and pull requests go unacknowledged. We apologize for not prioritizing the community, and are earnestly trying to make sure that every issue and pull request gets the attention it deserves going forward.
We also opened up GitHub discussions for @oclif/core and the oclif CLI, where you can now post your questions or ideas. We hope you take advantage of them, we love hearing from you!
One last thing: we intend to publicly post our roadmap so you have more visibility into what we're working on. Stay tuned!
All our best,
The oclif teamAnnouncing oclif v2!January 12, 2022 · 5 min readHello and happy new year! It's our great pleasure to announce that we have released oclif v2, which uses the new @oclif/core library! 🎉
oclif v2 includes many changes that improve the experience of both creating and using an oclif CLI.
Going forward, we don't plan to make any updates to oclif v1 and its corresponding libraries, except for critical security fixes. See the compatibility matrix for a list of these libraries. In order to give developers time to migrate from v1 to v2, we're not completely dropping support yet. But at some point in the future we'll archive the v1 repositories and deprecate their versions on npm.
What’s changing?​
Repository Changes​
All repositories under the oclif org now use main as their primary branch and oclif-v1 as the legacy branch. The main  branch corresponds to oclif v2 and the oclif-v1 branch to oclif v1. If you find any repos that don’t have a main branch, you can safely assume that they're not used in oclif v2 and will be deprecated in the future.
Consolidating Tools & Libraries​
The oclif-dev CLI has now been incorporated into oclif. You now no longer need to install a separate package to manage your entire CLI’s lifecycle.
The following libraries have been consolidated under @oclif/core and will be deprecated at some point in the future. Read the migration guide to learn how to update your CLI or plugin to use the new core library.

@oclif/command
@oclif/config
@oclif/error
@oclif/help
@oclif/parser

No more single vs multi command CLIs​
There's only one "type" of oclif v2 CLI, but it can have as few or as many commands as a developer wants. As a result, there’s only one command to generate CLIs, oclif generate, as opposed to the old oclif single and oclif multi commands.
Node > 12​
To ensure oclif CLIs are as secure as possible, all v2 libraries and plugins support only Node 12 or higher as of now. Going forward, they'll support only Node Maintenance or higher, as defined by Node's release schedule here: https://nodejs.org/en/about/releases/.
What’s new?​
New example CLI​
oclif-hello-world is our new example repo. This is also the repo that's used as a template when running oclif generate to create a new CLI. This repo will always be able to be referenced as an example of what an oclif v2 CLI should look like.
Spaced commands​
oclif CLIs can now use spaces, instead of colons, to separate topics and subcommands. To enable this feature, simply add “topicSeparator": " " to the oclif config in your package.json. See an example in our example repo.
// Old commands that use :$ mycli do:something
// New spaced commands$ mycli do something

Note: Spaced commands are backwards compatible. So if you enable spaced commands for your CLI, users will still be able to use : as a separator. This ensures that any existing scripts don't break.

New Help Output​
We’ve revamped the way command help is outputted to the terminal, making it both easier to implement and easier to read. See the difference between the old help output on the left and the new help output on the right in the screenshots below.
oclif v1oclif v2
Notice that there are new sections for flags and global flags, examples are displayed with better spacing, and there is a section at the bottom called Configuration Variables. This Configuration Variables section is not part of the new help by default. But we've added support for custom help sections, which is what the sf CLI uses to create the new section.
Async Command Parsing​
We’ve also improved the performance of new CLIs by rewriting how commands are parsed on initialization. The new parser is asynchronous, which makes CLIs with a lot of commands or installed  plugins much faster.
What’s coming next?​
Part of our charter for the release of oclif v2 includes improving our engagement with the oclif community. We know that over the past couple of years we’ve reduced our involvement, and a lot of issues and PRs have languished in limbo. Hopefully you’ve already seen increased activity and responses from oclif maintainers recently, but if you haven’t, please don’t hesitate to ping us by tagging @admins in oclif repos.
We also want to start interviewing members of the oclif community to acquire feedback and prioritize the features and fixes you deem most important!
Best,
The oclif team

Reference material​
Migration Guide​
This guide explains how to upgrade a CLI or plugin from the old oclif v1 libraries to the new @oclif/core library that oclif v2 uses.
https://github.com/oclif/core/blob/main/MIGRATION.md
Compatibility Matrix​
The following matrix shows how the v1 libraries and plugins relate to the new v2 ones. Use this matrix as a guide to know what to drop and which versions to switch when upgrading your plugins and CLIs to v2.
oclif "v1"oclif "v2"Utility CLIsoclif@<2@oclif/dev-cli@<2oclif@>=2Main packages@oclif/command@oclif/config@oclif/errors@oclif/parser@oclif/plugin-help@oclif/core@>=1Node LTSNode v8-14Node v12+ (at time of writing)TypeScripttypescript@<4typescript@>=4Main plugins@oclif/plugin-autocomplete@<1@oclif/plugin-commands@<2@oclif/plugin-help@<4@oclif/plugin-not-found@<2@oclif/plugin-plugins@<2@oclif/plugin-update@<2plugin-warn-if-update-available@<2plugin-which@<2@oclif/plugin-autocomplete@>=1@oclif/plugin-commands@>=2@oclif/plugin-help@>=4@oclif/plugin-not-found@>=2@oclif/plugin-plugins@>=2@oclif/plugin-update@>=2@oclif/plugin-warn-if-update-available@>=2@oclif/plugin-which@>=2Introducing @oclif/coreMarch 1, 2021 · 3 min readGreetings!
We hope this blog post finds you well.
Introducing...​
We are excited to announce the next iteration of the oclif project today: @oclif/core.
We have learned a lot in the last three years of developing oclif, developing on oclif and supporting millions of command runs a day via Heroku and Salesforce CLIs.
@oclif/core ("Core") simplifies the oclif development experience and introduces highly requested new features.
Core combines the essential oclif packages into one "core" package, aptly named @oclif/core.
Core also introduces:

A default command option
Colon or space command syntax
Async command parsing
Command piping to arguments

With the introduction of default command functionality, Core simplifies the oclif project and removes the notion of single or multi command CLIs. Core CLIs can have 1 or many commands.
Along with Core, we moved the oclif-dev CLI into the oclif CLI creating a single "utility" CLI. This CLI also introduces a new AWS S3 compatible publishing scheme.
What to expect in the near future​
Core is in pre-release beta and being actively developed for new internal Salesforce CLIs.
Much documentation needs to be written in the coming months including migration paths. Migration onto Core should be as painless as possible with many exports remaining entirely unchanged. Look for forthcoming blog posts and documentation on oclif.io.
Early this summer, tentively June 1, we will release Core v1. Core's release will coincide with major bumps to many other oclif plugin packages. See the compatibility matrix below.
At Core's v1 release, the current "main" oclif packages (namely: command, config, errors & parser) will go into maintenance mode until Jan 2022. They will receive only bug and security fixes and they remain compatible with current versions of the oclif and oclif-dev CLIs. Afterwhich, they will be archived.
Companioning Core, the next major release of the oclif CLI (literally oclif@2) will generate Core CLIs.
Going forward​
We are excited to release Core! We invite you to poke around the Core repo. It may appear to be a big change but Core keeps what you already enjoy about oclif while reducing development complexity, project dependencies, package coupling and bundle size and introduces many requested features previously too prickly to weave into the current oclif architecture.
Best,
The oclif team
Reference: Compatibility matrix​
oclif "v1"oclif "Core"Utility CLIsoclif@<2@oclif/dev-cli@<2oclif@>=2Main packages@oclif/core@<2@oclif/config@<2@oclif/errors@<2@oclif/parser@<4@oclif/plugin-help@<4@oclif/core@>=1Node LTSNode v8-14Node v12+TypeScripttypescript@<4typescript@>=4Main plugins@oclif/plugin-autocomplete@<1@oclif/plugin-commands@<2@oclif/plugin-help@<4@oclif/plugin-not-found@<2@oclif/plugin-plugins@<2@oclif/plugin-update@<2plugin-warn-if-update-available@<2plugin-which@<2@oclif/plugin-autocomplete@>=2@oclif/plugin-commands@>=2@oclif/plugin-help@>=4@oclif/plugin-not-found@>=2@oclif/plugin-plugins@>=2@oclif/plugin-update@>=2@oclif/plugin-warn-if-update-available@>=2@oclif/plugin-which@>=2oclif Summer 2020 UpdateAugust 26, 2020 · 2 min readHello oclif developers! We hope you are all doing well.
Earlier this year, we started our planning for oclifconf v2 and, like all conference, had to change course. We opted not to hold a virtual conference, however, we wanted to take some time to highlight a few oclif features shipped this year.
Feature: Help templating​
One of the most requested features, help templating enables oclif developers to customize the help output for their CLI.
Read the announcement.
Feature: Custom error delegation​
This feature both improved how oclif throws and handles errors and allows oclif developers to overwrite or interject in oclif’s error handling.
Read the announcement.
Feature: postrun hooks​
We have added a new lifecycle event postrun. Your CLI can now run a hook after a command has ran.
See our hook documentation.
Feature: Root index command​
Previously, oclif would display CLI help if only the binary name with no command ID was invoked, oclif now supports a "root index" command. If present, a command defined at src/commands/index.ts will be run if no command ID is found.
1 million weekly downloads​
While exact oclif usage metrics are hard to pin down, we use npm download statistics of oclif packages as a rough approximation. Earlier this year, oclif's command package hit 1 million weekly downloads for the first time!
This year has been presented its challenges on everyone. We want to thank you, oclif developers, whom have taken the time to use and improve the oclif project. We look forward to seeing you all - in person - in the future!
All our best,
The oclif teamPretty Printable ErrorsJuly 1, 2020 · One min readOften CLIs are used as handy tools and when things go wrong it’s useful to have additional context. In oclif we have added a couple of additional properties that can show extra context to the users when an error is displayed. The code, ref and suggestions will now be displayed if they are included. This will work with an existing oclif CLI by adding the latest @oclif/errors and @oclif/core to the CLI's package.json dependencies.
For example, using this.error with the additional properties:
class TestError extends Command {  async run() {    this.error("An error has occurred!", {      code: "OCLIF_ERR",      ref: "https://oclif.io/docs/commands#thiserrormessage-string--error-options-code-string-exit-number",      suggestions: ["Use these extra properties to provide additional context"],    })  }}
would result with the following output:
›   Error: An error has occurred!›   Code: OCLIF_ERR›   Try this: Use these extra properties to provide additional context›   Reference: https://oclif.io/docs/commands#thiserrormessage-string--error-options-code-string-exit-number
If these properties are not provided then nothing changes and the CLI will continue to display the single error message output as it did before. Additionally, as part of this exercise we’ve added documentation around Error Handling in oclif which should come in handy if the need arises to extend oclif’s default handling of errors.Customizing Help in oclifMay 5, 2020 · 2 min readOut of the box oclif provides a great help experience for CLIs.
But what if, as an oclif developer, you want to customize some or all of the output?
You can now customize your CLI's help output by implementing the HelpBase abstract class.
Getting started with custom help​
If you have not done so yet, update @oclif/core.
$ yarn add --latest @oclif/core
To get started, first define the filepath to your help class in oclif's config in package.json. This is a relative path to the help class, without a file extension.
For this example, the help class will be created in a file at "[project root]/src/help.ts".
{  // ...  "oclif": {    "helpClass": "./lib/help"    // ...  }  // ...}
From here there are two paths, implement the HelpBase abstract class yourself or overwrite the parts of the default Help class you want to customize (ex: how command usage is displayed). We recommend the latter approach but cover both in the new Help Classes docs.
Separating TOPICS & COMMANDS in the new default Help class​
Previously, topics and child commands were listed in help output under a single list heading called "COMMANDS". But we found this can be slightly confusing. Some topics are commands also (a.k.a. topic-commands) while others are simply organizational namespacing (and when ran just show their help).
The new default Help class splits the list of children into distinct lists of "TOPICS" and "COMMANDS", with the possibility of an item appearing in both if it a topic-command. This makes it clearer what is expected to be ran - "COMMANDS" - and what is providing structure - "TOPICS" - when looking at the help output.
VERSION  plugin-help-example/0.0.0 darwin-x64 node-v12.12.0USAGE  $ plugin-help-example [COMMAND]TOPICS  topic  this is a topic and has child topics or commandsCOMMANDS  hello  describe the command here  help   display help for plugin-help-example
We look forward to seeing what custom help features you implement in your oclif CLIs with this new feature!oclif TSLint to ESLint MigrationDecember 5, 2019 · 3 min readBack in February of this year, plans were announced to deprecate TSLint in favor of ESLint. TSLint's goal has become to work toward a “unified developer experience” by supporting ESLint development going forward.
What has changed in oclif​
To keep inline with the community, oclif has transitioned to ESLint for all our core libraries as well as all our official plugins.
Starting in v1.15.x, oclif will now optionally generate projects with ESLint for both TypeScript and JavaScript CLI’s.
ESLint does require Node to be on stable LTS version, at the time of writing, Node 8.10.x, Node 10.13.x & Node 12.x.x.
How does this affect you​
Existing CLI’s are unchanged, but any newly generated CLI's will only give the option of using ESLint. If you are running tslint in your CLI, we recommend you switch to ESLint as well.
In migrating our projects we took the following steps (for an example of these changes see this pull request).


Install eslint
$ yarn add eslint eslint-config-oclif eslint-config-oclif-typescript --dev


Add eslint related files


$ echo '{  "extends": [    "oclif",    "oclif-typescript"  ],  "rules": {  }}' > .eslintrc


Remove tslint and related packages
$ yarn remove @oclif/tslint tslint


Remove tslint related configuration files
$ rm tslint.json


Change lint script in our package.json from something like:
"lint": "tsc -p test --noEmit && tslint -p test -t stylish"
to
"lint": "eslint . --ext .ts --config .eslintrc"


To preserve the test compile (tsc -p test --noEmit) we also made the following updates to our scripts:
"pretest": "tsc -p test --noEmit"
In some cases we had our posttest duplicating the same steps as our lint script so it’s cleaner to have it reference the lint job directly with:
"posttest": "yarn lint"

Run yarn lint --fix. This attempts to auto-fix any linting violations automatically. In the case an auto-fix isn’t available it should be fixed manually or ignored (see the eslint configuration doc for more information)
Do a search in the codebase for tslint and remove any unnecessary tslint disabling comments, like:

/* tslint:disable:object-literal-sort-keys */
If you are on a version of Node that is not supported by ESLint, you will also need to update your Node engine. ESLint supports Node 8, 10, and 12 so you should upgrade to the most recent Node version compatible with your CLI and also supported by ESLint (see ESLint's Installation and Usage instructions).
When will this take effect​
These changes have taken effect in oclif v1.15.1. When you generate a new CLI or plugin it will now contain configuration for ESLint instead of TSLint.oclif's Current Node SupportOctober 31, 2019 · 3 min readTo maintain a healthy project trajectory, oclif follows and supports Node Active LTS release, currently Node 10 & Node 12. This means ensuring that oclif continues to play nice with coming Active LTS Node versions and other packages in the ecosystem. Moving forward also means leaving older versions behind. Starting in 2020, Node will stop maintaining Node 8 and it is our intent at that time to also follow suit. Let’s take a look at a few ways we will be supporting these changes.
CI Environments​
CLIs created with the oclif cli going forward will be generated with a CircleCI configuration with Node 10 & 12 and an Appveyor configuration using Node 10. We have also added Node latest to CircleCi to be an early warning detection against coming Node changes (Node latest is managed by CircleCI).
We have already updated every oclif repo's CI configs to reflect this.
If your existing CLI uses either Appveyor or CircleCI you can update your config files also, like so:
.circleci/config.yml​
Your CircleCI config should contain a node-latest job, aliased as test. From this, there should be two extensions of this job for the Active LTS Node versions, Node 10 and Node 12.
  node-10:    <<: *node-latest    docker:      - image: node:10  node-12:    <<: *node-latest    docker:      - image: node:12
Notice that these declarations only change the Docker Node images used to run that job.
Additionally, the jobs listed within workflows must also be updated to reflect our changes in configuration:
    jobs:      - node-latest      - node-10      - node-12
appveyor.yml​
For appveyor we are currently only testing the oldest Active LTS Node version, Node 10. Update the nodejs_version proppert in your appveyor.yml file to reflect this.
environment:  nodejs_version: "10"
Deprecating Node 8 & Updating packge.json engines​
In Jan 2020, Node will end its Node 8 maintenance. We will follow suit by setting the package.json engine property in oclif packages to >=10 and bumping the package's major versions.
Depending on how you ship your CLI you may wish to also bump the engines version in your CLI's package.json. You can read more about the implications of the engines property configuration in the npm documentation.
Also consider distributing your CLI with its own Node version.
Packaged Node Version​
When using dev-cli to pack your CLI it will use the Node version as specified in your package.json under the oclif.update.node.version property. This value should reflect an Active LTS Node version (dev-cli does not currently enforce versions).
Supporting the future​
As a community we may discover bumps along the way as we upgrade. If you notice something related to oclif please feel free to open an issue or submit a pull request under the relevant oclif package within the org.
We look forward to using the latest from Node and the community and keeping oclif healthy along the way.oclifconf 2019: A RecapSeptember 16, 2019 · 4 min readIn May, Heroku and Salesforce Open Source organized oclifconf, a conference for developers & product managers building CLI tools on top of the open source oclif framework. The speakers came from various tech companies, such as Adobe, Netlify, and Apollo, who have already built amazing CLI experiences. The topics covered everything from the incredible capabilities oclif has unlocked, to the community-built plugins extending its functionality, and even what the behavior of an adaptive CLI tool might look like.
Below is a listing of all of the talks from the event, along with a short summary. Enjoy!
The future of oclif by Jeff Dickey​

In its relatively short lifetime, oclif has already inspired many developers and companies to adopt its framework as a means for implementing their own command-line tooling. In this talk, Jeff Dickey, an oclif founding team member, recaps the project's history and inspiration. He also looks towards the future and outlines some features and improvements that the tool could adapt. This isn't so much a definitive roadmap of where oclif is headed, but rather, a call to inspiration for developers eager to contribute! And if you are interested in contributing, check out the open issues in the oclif GitHub repo and come say "Hello!" on Spectrum Chat.
Open Source Citizenship by Josh Simmons​

When it comes to open source, it's more than just individuals now. More and more frequently, large corporations are contributing to projects by donating to contributors, sponsoring events, or upstreaming contributions. But keeping open source projects and communities healthy requires more than just money and brainpower. Josh Simmons surveyed multiple open source communities and relays his findings as to what help maintainers and contributors actually need in this talk.
Building an enterprise-grade CLI with oclif by Thomas Dvornik​

Security and performance are all about trust. While oclif is an extremely extensible framework for building CLI tooling, there are additional requirements to fulfill for enterprise businesses to adopt it that might not be necessary for individual developers. Thomas Dvornik outlines what he and his colleagues at Salesforce have implemented as plugins to oclif to satisfy these needs, including encrypted OAuth, plugin signing, lazy loading dependencies, synchronizing weekly releases and deprecations across dozens of repositories, and establishing cross-team coding and documentation standards.
How Adobe I/O built an extensible CLI with oclif by Jesse MacFadyen​

Perhaps oclif's most appealing feature is its support for plugins. In Cordova's case, they've created a sophisticated telemetry system that helps Adobe developers see which commands users are using--and reports on which ones are erroring out. By embedding a feedback system into the tool, users are even able to quickly send their suggestions to a form, without ever leaving the terminal. Jesse MacFadyen demonstrates how oclif's plugin system can work beyond simply executing commands.
Integrating oclif with GraphQL and Apollo by Evans Hauser​

For Evans Hauser and the team at Apollo, oclif is best thought of as "React for the CLI." As a client paired with a strongly-typed API contract to a server, it can deliver structured and consistent commands to retrieve external data. What better mechanism to use for this transfer than GraphQL, a framework which empowers the client to ask precisely for the data it needs, and nothing more?
Adaptive Intent-based CLI State Machines by Shawn Wang​

In designing oclif, Jeff Dickey wrote out 12 CLI factors to keep in mind. In this talk, Shawn Wang outlines a 13th: state. State is hard, because it depends on context, and context depends on understanding what a user intends to do, not what they are asking. Shawn is working towards enabling oclif to better understand the commands a user has entered, so that it can predict and interpret future commands that might be entered next. This would enable CLI tools to not just interpret a users' commands, but to also interpret their intent.Older Entries\n\n\n\nIntroducing `oclif init` commandApril 10, 2024 · 2 min readThanks to the contribution of @joshcanhelp we released a new command for the oclif CLI called oclif init in version 4.8.0
The oclif init command allows you to initialize oclif in an existing project directory by adding the bare minimum requirements: a few pieces of configuration, bin scripts, and a couple of dependencies (@oclif/core and ts-node). This is slightly different from oclif generate, which will create an entirely new oclif project based on our templates.
oclif init will add the following:

bin scripts: bin/run.js, bin/run.cmd, bin/dev.js, and bin/dev.cmd
oclif section to package.json with bin, dirname, commands, and topicSeparator set (See Configuring Your CLI for more)
@oclif/core to dependencies in your package.json (if it's not already there)
ts-node to devDependencies in your package.json (if it's not already there)

Once you've initialized oclif, you can use the bin scripts to execute your CLI. You can also use the other oclif commands like oclif generate command and oclif generate hook to start adding new functionality.

❯ oclif init --helpInitialize a new oclif CLIUSAGE  $ oclif init [--bin <value>] [--module-type ESM|CommonJS] [--package-manager npm|yarn|pnpm] [--topic-separator    colons|spaces] [-d <value>] [-y]FLAGS  -d, --output-dir=<value>        Directory to initialize the CLI in.  -y, --yes                       Use defaults for all prompts. Individual flags will override defaults.      --bin=<value>               Supply answer for prompt: Command bin name the CLI will export      --module-type=<option>      Supply answer for prompt: Select a module type                                  <options: ESM|CommonJS>      --package-manager=<option>  Supply answer for prompt: Select a package manager                                  <options: npm|yarn|pnpm>      --topic-separator=<option>  Supply answer for prompt: Select a topic separator                                  <options: colons|spaces>DESCRIPTION  Initialize a new oclif CLI  This will add the necessary oclif bin files, add oclif config to package.json, and install @oclif/core and ts-node.EXAMPLES  Initialize a new CLI in the current directory    $ oclif init  Initialize a new CLI in a different directory    $ oclif init --output-dir "/path/to/existing/project"  Supply answers for specific prompts    $ oclif init --topic-separator colons --bin mycli
Hope you enjoy the new command! If you come across any issues or have any new ideas for this command, head over to the oclif/oclif repo and open a new issue.
All our best,
The oclif teamoclif Spring 2024 UpdateMarch 29, 2024 · 4 min readHello oclif developers! It's been a while since we last uploaded a blog - and a lot has happened.
We've been focusing on these high-level areas over the past couple of years:

Improving @oclif/core
ESM Support
Improving and revitalizing oclif.io
Re-engaging the oclif community

Improving @oclif/core​
Since we announced @oclif/core over three years ago, we've released two new major versions, each packed with lots of features that we're really excited about.
Here are some of these changes:

Full support for ESM and interoperability with CommonJS (more on this topic below).
Configurable command discovery strategies that give you more control over how commands are loaded at runtime. Check out the docs.
A new preparse hook that allows you to manipulate the provided arguments before they're parsed. Salesforce used this hook to implement a neat --flags-dir feature that translates local files into flags.
A new Performance class that you can use to track performance inside of @oclif/core and your own CLI or plugin. Check out the docs.
A new flag type, Flags.option, that lets you define a flag with a preset list of options. Typescript then uses the options to infer the flag's type.
Flags now have a relationship property that allows you to define more complex relationships between flags. Check out the flags docs for more information.
Flags now have a defaultHelp property that allows you to set the human readable default value in the command help. This property is useful when your flag's parse method returns a complex type, such as an object or a class. Check out the flags docs for more.
Commands now have a hiddenAliases property that allows you to define aliases that you want to hide from the user. The property is super helpful when you're trying to wean users off a deprecated command.
You can now use bun or tsx as dev runtimes (as opposed to node or ts-node).
A command's usage, args, and flags are now shown whenever a user forgets to provide a required arg or flag, or when they provided a non-existent flag.

If you need help migrating to the latest version, head over to core's README which has links to the migration guides. Feel free to open a new discussion if you need more hands-on help from us or the community.
ESM Support​
Version 3 of @oclif/core introduced full support for developing ESM plugins and CLIs. It also offered full support for interoperability between CommonJS and ESM plugins.
Put more simply, you can now migrate your CLI to ESM while keeping individual plugins in CommonJS (or vice versa). The upgrade path is now much simpler for you. You also don't need to worry about any community plugins that have migrated to ESM before you did (such as all the @oclif plugins) or are staunchly sticking with CommonJS for the foreseeable future.
Read more about this topic here.
Improving and Revitalizing oclif.io​
Another area of focus for us has been improving our documentation site, oclif.io.
While improving the quality and accuracy of the documentation was our priority, we also took the time to upgrade to the latest version of docusaurus. This new version gave our site a much-needed facelift, as well as cool new features such as dark mode and announcements.
If you have any feedback or are running into issues, we want to hear about it. Just create an issue in the oclif.io repo.
Re-engaging the oclif Community​
Lastly, our biggest priority at the moment is to re-engage the oclif community. We understand how frustrating it has been over the years to see your issues and pull requests go unacknowledged. We apologize for not prioritizing the community, and are earnestly trying to make sure that every issue and pull request gets the attention it deserves going forward.
We also opened up GitHub discussions for @oclif/core and the oclif CLI, where you can now post your questions or ideas. We hope you take advantage of them, we love hearing from you!
One last thing: we intend to publicly post our roadmap so you have more visibility into what we're working on. Stay tuned!
All our best,
The oclif teamAnnouncing oclif v2!January 12, 2022 · 5 min readHello and happy new year! It's our great pleasure to announce that we have released oclif v2, which uses the new @oclif/core library! 🎉
oclif v2 includes many changes that improve the experience of both creating and using an oclif CLI.
Going forward, we don't plan to make any updates to oclif v1 and its corresponding libraries, except for critical security fixes. See the compatibility matrix for a list of these libraries. In order to give developers time to migrate from v1 to v2, we're not completely dropping support yet. But at some point in the future we'll archive the v1 repositories and deprecate their versions on npm.
What’s changing?​
Repository Changes​
All repositories under the oclif org now use main as their primary branch and oclif-v1 as the legacy branch. The main  branch corresponds to oclif v2 and the oclif-v1 branch to oclif v1. If you find any repos that don’t have a main branch, you can safely assume that they're not used in oclif v2 and will be deprecated in the future.
Consolidating Tools & Libraries​
The oclif-dev CLI has now been incorporated into oclif. You now no longer need to install a separate package to manage your entire CLI’s lifecycle.
The following libraries have been consolidated under @oclif/core and will be deprecated at some point in the future. Read the migration guide to learn how to update your CLI or plugin to use the new core library.

@oclif/command
@oclif/config
@oclif/error
@oclif/help
@oclif/parser

No more single vs multi command CLIs​
There's only one "type" of oclif v2 CLI, but it can have as few or as many commands as a developer wants. As a result, there’s only one command to generate CLIs, oclif generate, as opposed to the old oclif single and oclif multi commands.
Node > 12​
To ensure oclif CLIs are as secure as possible, all v2 libraries and plugins support only Node 12 or higher as of now. Going forward, they'll support only Node Maintenance or higher, as defined by Node's release schedule here: https://nodejs.org/en/about/releases/.
What’s new?​
New example CLI​
oclif-hello-world is our new example repo. This is also the repo that's used as a template when running oclif generate to create a new CLI. This repo will always be able to be referenced as an example of what an oclif v2 CLI should look like.
Spaced commands​
oclif CLIs can now use spaces, instead of colons, to separate topics and subcommands. To enable this feature, simply add “topicSeparator": " " to the oclif config in your package.json. See an example in our example repo.
// Old commands that use :$ mycli do:something
// New spaced commands$ mycli do something

Note: Spaced commands are backwards compatible. So if you enable spaced commands for your CLI, users will still be able to use : as a separator. This ensures that any existing scripts don't break.

New Help Output​
We’ve revamped the way command help is outputted to the terminal, making it both easier to implement and easier to read. See the difference between the old help output on the left and the new help output on the right in the screenshots below.
oclif v1oclif v2
Notice that there are new sections for flags and global flags, examples are displayed with better spacing, and there is a section at the bottom called Configuration Variables. This Configuration Variables section is not part of the new help by default. But we've added support for custom help sections, which is what the sf CLI uses to create the new section.
Async Command Parsing​
We’ve also improved the performance of new CLIs by rewriting how commands are parsed on initialization. The new parser is asynchronous, which makes CLIs with a lot of commands or installed  plugins much faster.
What’s coming next?​
Part of our charter for the release of oclif v2 includes improving our engagement with the oclif community. We know that over the past couple of years we’ve reduced our involvement, and a lot of issues and PRs have languished in limbo. Hopefully you’ve already seen increased activity and responses from oclif maintainers recently, but if you haven’t, please don’t hesitate to ping us by tagging @admins in oclif repos.
We also want to start interviewing members of the oclif community to acquire feedback and prioritize the features and fixes you deem most important!
Best,
The oclif team

Reference material​
Migration Guide​
This guide explains how to upgrade a CLI or plugin from the old oclif v1 libraries to the new @oclif/core library that oclif v2 uses.
https://github.com/oclif/core/blob/main/MIGRATION.md
Compatibility Matrix​
The following matrix shows how the v1 libraries and plugins relate to the new v2 ones. Use this matrix as a guide to know what to drop and which versions to switch when upgrading your plugins and CLIs to v2.
oclif "v1"oclif "v2"Utility CLIsoclif@<2@oclif/dev-cli@<2oclif@>=2Main packages@oclif/command@oclif/config@oclif/errors@oclif/parser@oclif/plugin-help@oclif/core@>=1Node LTSNode v8-14Node v12+ (at time of writing)TypeScripttypescript@<4typescript@>=4Main plugins@oclif/plugin-autocomplete@<1@oclif/plugin-commands@<2@oclif/plugin-help@<4@oclif/plugin-not-found@<2@oclif/plugin-plugins@<2@oclif/plugin-update@<2plugin-warn-if-update-available@<2plugin-which@<2@oclif/plugin-autocomplete@>=1@oclif/plugin-commands@>=2@oclif/plugin-help@>=4@oclif/plugin-not-found@>=2@oclif/plugin-plugins@>=2@oclif/plugin-update@>=2@oclif/plugin-warn-if-update-available@>=2@oclif/plugin-which@>=2Introducing @oclif/coreMarch 1, 2021 · 3 min readGreetings!
We hope this blog post finds you well.
Introducing...​
We are excited to announce the next iteration of the oclif project today: @oclif/core.
We have learned a lot in the last three years of developing oclif, developing on oclif and supporting millions of command runs a day via Heroku and Salesforce CLIs.
@oclif/core ("Core") simplifies the oclif development experience and introduces highly requested new features.
Core combines the essential oclif packages into one "core" package, aptly named @oclif/core.
Core also introduces:

A default command option
Colon or space command syntax
Async command parsing
Command piping to arguments

With the introduction of default command functionality, Core simplifies the oclif project and removes the notion of single or multi command CLIs. Core CLIs can have 1 or many commands.
Along with Core, we moved the oclif-dev CLI into the oclif CLI creating a single "utility" CLI. This CLI also introduces a new AWS S3 compatible publishing scheme.
What to expect in the near future​
Core is in pre-release beta and being actively developed for new internal Salesforce CLIs.
Much documentation needs to be written in the coming months including migration paths. Migration onto Core should be as painless as possible with many exports remaining entirely unchanged. Look for forthcoming blog posts and documentation on oclif.io.
Early this summer, tentively June 1, we will release Core v1. Core's release will coincide with major bumps to many other oclif plugin packages. See the compatibility matrix below.
At Core's v1 release, the current "main" oclif packages (namely: command, config, errors & parser) will go into maintenance mode until Jan 2022. They will receive only bug and security fixes and they remain compatible with current versions of the oclif and oclif-dev CLIs. Afterwhich, they will be archived.
Companioning Core, the next major release of the oclif CLI (literally oclif@2) will generate Core CLIs.
Going forward​
We are excited to release Core! We invite you to poke around the Core repo. It may appear to be a big change but Core keeps what you already enjoy about oclif while reducing development complexity, project dependencies, package coupling and bundle size and introduces many requested features previously too prickly to weave into the current oclif architecture.
Best,
The oclif team
Reference: Compatibility matrix​
oclif "v1"oclif "Core"Utility CLIsoclif@<2@oclif/dev-cli@<2oclif@>=2Main packages@oclif/core@<2@oclif/config@<2@oclif/errors@<2@oclif/parser@<4@oclif/plugin-help@<4@oclif/core@>=1Node LTSNode v8-14Node v12+TypeScripttypescript@<4typescript@>=4Main plugins@oclif/plugin-autocomplete@<1@oclif/plugin-commands@<2@oclif/plugin-help@<4@oclif/plugin-not-found@<2@oclif/plugin-plugins@<2@oclif/plugin-update@<2plugin-warn-if-update-available@<2plugin-which@<2@oclif/plugin-autocomplete@>=2@oclif/plugin-commands@>=2@oclif/plugin-help@>=4@oclif/plugin-not-found@>=2@oclif/plugin-plugins@>=2@oclif/plugin-update@>=2@oclif/plugin-warn-if-update-available@>=2@oclif/plugin-which@>=2oclif Summer 2020 UpdateAugust 26, 2020 · 2 min readHello oclif developers! We hope you are all doing well.
Earlier this year, we started our planning for oclifconf v2 and, like all conference, had to change course. We opted not to hold a virtual conference, however, we wanted to take some time to highlight a few oclif features shipped this year.
Feature: Help templating​
One of the most requested features, help templating enables oclif developers to customize the help output for their CLI.
Read the announcement.
Feature: Custom error delegation​
This feature both improved how oclif throws and handles errors and allows oclif developers to overwrite or interject in oclif’s error handling.
Read the announcement.
Feature: postrun hooks​
We have added a new lifecycle event postrun. Your CLI can now run a hook after a command has ran.
See our hook documentation.
Feature: Root index command​
Previously, oclif would display CLI help if only the binary name with no command ID was invoked, oclif now supports a "root index" command. If present, a command defined at src/commands/index.ts will be run if no command ID is found.
1 million weekly downloads​
While exact oclif usage metrics are hard to pin down, we use npm download statistics of oclif packages as a rough approximation. Earlier this year, oclif's command package hit 1 million weekly downloads for the first time!
This year has been presented its challenges on everyone. We want to thank you, oclif developers, whom have taken the time to use and improve the oclif project. We look forward to seeing you all - in person - in the future!
All our best,
The oclif teamPretty Printable ErrorsJuly 1, 2020 · One min readOften CLIs are used as handy tools and when things go wrong it’s useful to have additional context. In oclif we have added a couple of additional properties that can show extra context to the users when an error is displayed. The code, ref and suggestions will now be displayed if they are included. This will work with an existing oclif CLI by adding the latest @oclif/errors and @oclif/core to the CLI's package.json dependencies.
For example, using this.error with the additional properties:
class TestError extends Command {  async run() {    this.error("An error has occurred!", {      code: "OCLIF_ERR",      ref: "https://oclif.io/docs/commands#thiserrormessage-string--error-options-code-string-exit-number",      suggestions: ["Use these extra properties to provide additional context"],    })  }}
would result with the following output:
›   Error: An error has occurred!›   Code: OCLIF_ERR›   Try this: Use these extra properties to provide additional context›   Reference: https://oclif.io/docs/commands#thiserrormessage-string--error-options-code-string-exit-number
If these properties are not provided then nothing changes and the CLI will continue to display the single error message output as it did before. Additionally, as part of this exercise we’ve added documentation around Error Handling in oclif which should come in handy if the need arises to extend oclif’s default handling of errors.Customizing Help in oclifMay 5, 2020 · 2 min readOut of the box oclif provides a great help experience for CLIs.
But what if, as an oclif developer, you want to customize some or all of the output?
You can now customize your CLI's help output by implementing the HelpBase abstract class.
Getting started with custom help​
If you have not done so yet, update @oclif/core.
$ yarn add --latest @oclif/core
To get started, first define the filepath to your help class in oclif's config in package.json. This is a relative path to the help class, without a file extension.
For this example, the help class will be created in a file at "[project root]/src/help.ts".
{  // ...  "oclif": {    "helpClass": "./lib/help"    // ...  }  // ...}
From here there are two paths, implement the HelpBase abstract class yourself or overwrite the parts of the default Help class you want to customize (ex: how command usage is displayed). We recommend the latter approach but cover both in the new Help Classes docs.
Separating TOPICS & COMMANDS in the new default Help class​
Previously, topics and child commands were listed in help output under a single list heading called "COMMANDS". But we found this can be slightly confusing. Some topics are commands also (a.k.a. topic-commands) while others are simply organizational namespacing (and when ran just show their help).
The new default Help class splits the list of children into distinct lists of "TOPICS" and "COMMANDS", with the possibility of an item appearing in both if it a topic-command. This makes it clearer what is expected to be ran - "COMMANDS" - and what is providing structure - "TOPICS" - when looking at the help output.
VERSION  plugin-help-example/0.0.0 darwin-x64 node-v12.12.0USAGE  $ plugin-help-example [COMMAND]TOPICS  topic  this is a topic and has child topics or commandsCOMMANDS  hello  describe the command here  help   display help for plugin-help-example
We look forward to seeing what custom help features you implement in your oclif CLIs with this new feature!oclif TSLint to ESLint MigrationDecember 5, 2019 · 3 min readBack in February of this year, plans were announced to deprecate TSLint in favor of ESLint. TSLint's goal has become to work toward a “unified developer experience” by supporting ESLint development going forward.
What has changed in oclif​
To keep inline with the community, oclif has transitioned to ESLint for all our core libraries as well as all our official plugins.
Starting in v1.15.x, oclif will now optionally generate projects with ESLint for both TypeScript and JavaScript CLI’s.
ESLint does require Node to be on stable LTS version, at the time of writing, Node 8.10.x, Node 10.13.x & Node 12.x.x.
How does this affect you​
Existing CLI’s are unchanged, but any newly generated CLI's will only give the option of using ESLint. If you are running tslint in your CLI, we recommend you switch to ESLint as well.
In migrating our projects we took the following steps (for an example of these changes see this pull request).


Install eslint
$ yarn add eslint eslint-config-oclif eslint-config-oclif-typescript --dev


Add eslint related files


$ echo '{  "extends": [    "oclif",    "oclif-typescript"  ],  "rules": {  }}' > .eslintrc


Remove tslint and related packages
$ yarn remove @oclif/tslint tslint


Remove tslint related configuration files
$ rm tslint.json


Change lint script in our package.json from something like:
"lint": "tsc -p test --noEmit && tslint -p test -t stylish"
to
"lint": "eslint . --ext .ts --config .eslintrc"


To preserve the test compile (tsc -p test --noEmit) we also made the following updates to our scripts:
"pretest": "tsc -p test --noEmit"
In some cases we had our posttest duplicating the same steps as our lint script so it’s cleaner to have it reference the lint job directly with:
"posttest": "yarn lint"

Run yarn lint --fix. This attempts to auto-fix any linting violations automatically. In the case an auto-fix isn’t available it should be fixed manually or ignored (see the eslint configuration doc for more information)
Do a search in the codebase for tslint and remove any unnecessary tslint disabling comments, like:

/* tslint:disable:object-literal-sort-keys */
If you are on a version of Node that is not supported by ESLint, you will also need to update your Node engine. ESLint supports Node 8, 10, and 12 so you should upgrade to the most recent Node version compatible with your CLI and also supported by ESLint (see ESLint's Installation and Usage instructions).
When will this take effect​
These changes have taken effect in oclif v1.15.1. When you generate a new CLI or plugin it will now contain configuration for ESLint instead of TSLint.oclif's Current Node SupportOctober 31, 2019 · 3 min readTo maintain a healthy project trajectory, oclif follows and supports Node Active LTS release, currently Node 10 & Node 12. This means ensuring that oclif continues to play nice with coming Active LTS Node versions and other packages in the ecosystem. Moving forward also means leaving older versions behind. Starting in 2020, Node will stop maintaining Node 8 and it is our intent at that time to also follow suit. Let’s take a look at a few ways we will be supporting these changes.
CI Environments​
CLIs created with the oclif cli going forward will be generated with a CircleCI configuration with Node 10 & 12 and an Appveyor configuration using Node 10. We have also added Node latest to CircleCi to be an early warning detection against coming Node changes (Node latest is managed by CircleCI).
We have already updated every oclif repo's CI configs to reflect this.
If your existing CLI uses either Appveyor or CircleCI you can update your config files also, like so:
.circleci/config.yml​
Your CircleCI config should contain a node-latest job, aliased as test. From this, there should be two extensions of this job for the Active LTS Node versions, Node 10 and Node 12.
  node-10:    <<: *node-latest    docker:      - image: node:10  node-12:    <<: *node-latest    docker:      - image: node:12
Notice that these declarations only change the Docker Node images used to run that job.
Additionally, the jobs listed within workflows must also be updated to reflect our changes in configuration:
    jobs:      - node-latest      - node-10      - node-12
appveyor.yml​
For appveyor we are currently only testing the oldest Active LTS Node version, Node 10. Update the nodejs_version proppert in your appveyor.yml file to reflect this.
environment:  nodejs_version: "10"
Deprecating Node 8 & Updating packge.json engines​
In Jan 2020, Node will end its Node 8 maintenance. We will follow suit by setting the package.json engine property in oclif packages to >=10 and bumping the package's major versions.
Depending on how you ship your CLI you may wish to also bump the engines version in your CLI's package.json. You can read more about the implications of the engines property configuration in the npm documentation.
Also consider distributing your CLI with its own Node version.
Packaged Node Version​
When using dev-cli to pack your CLI it will use the Node version as specified in your package.json under the oclif.update.node.version property. This value should reflect an Active LTS Node version (dev-cli does not currently enforce versions).
Supporting the future​
As a community we may discover bumps along the way as we upgrade. If you notice something related to oclif please feel free to open an issue or submit a pull request under the relevant oclif package within the org.
We look forward to using the latest from Node and the community and keeping oclif healthy along the way.oclifconf 2019: A RecapSeptember 16, 2019 · 4 min readIn May, Heroku and Salesforce Open Source organized oclifconf, a conference for developers & product managers building CLI tools on top of the open source oclif framework. The speakers came from various tech companies, such as Adobe, Netlify, and Apollo, who have already built amazing CLI experiences. The topics covered everything from the incredible capabilities oclif has unlocked, to the community-built plugins extending its functionality, and even what the behavior of an adaptive CLI tool might look like.
Below is a listing of all of the talks from the event, along with a short summary. Enjoy!
The future of oclif by Jeff Dickey​

In its relatively short lifetime, oclif has already inspired many developers and companies to adopt its framework as a means for implementing their own command-line tooling. In this talk, Jeff Dickey, an oclif founding team member, recaps the project's history and inspiration. He also looks towards the future and outlines some features and improvements that the tool could adapt. This isn't so much a definitive roadmap of where oclif is headed, but rather, a call to inspiration for developers eager to contribute! And if you are interested in contributing, check out the open issues in the oclif GitHub repo and come say "Hello!" on Spectrum Chat.
Open Source Citizenship by Josh Simmons​

When it comes to open source, it's more than just individuals now. More and more frequently, large corporations are contributing to projects by donating to contributors, sponsoring events, or upstreaming contributions. But keeping open source projects and communities healthy requires more than just money and brainpower. Josh Simmons surveyed multiple open source communities and relays his findings as to what help maintainers and contributors actually need in this talk.
Building an enterprise-grade CLI with oclif by Thomas Dvornik​

Security and performance are all about trust. While oclif is an extremely extensible framework for building CLI tooling, there are additional requirements to fulfill for enterprise businesses to adopt it that might not be necessary for individual developers. Thomas Dvornik outlines what he and his colleagues at Salesforce have implemented as plugins to oclif to satisfy these needs, including encrypted OAuth, plugin signing, lazy loading dependencies, synchronizing weekly releases and deprecations across dozens of repositories, and establishing cross-team coding and documentation standards.
How Adobe I/O built an extensible CLI with oclif by Jesse MacFadyen​

Perhaps oclif's most appealing feature is its support for plugins. In Cordova's case, they've created a sophisticated telemetry system that helps Adobe developers see which commands users are using--and reports on which ones are erroring out. By embedding a feedback system into the tool, users are even able to quickly send their suggestions to a form, without ever leaving the terminal. Jesse MacFadyen demonstrates how oclif's plugin system can work beyond simply executing commands.
Integrating oclif with GraphQL and Apollo by Evans Hauser​

For Evans Hauser and the team at Apollo, oclif is best thought of as "React for the CLI." As a client paired with a strongly-typed API contract to a server, it can deliver structured and consistent commands to retrieve external data. What better mechanism to use for this transfer than GraphQL, a framework which empowers the client to ask precisely for the data it needs, and nothing more?
Adaptive Intent-based CLI State Machines by Shawn Wang​

In designing oclif, Jeff Dickey wrote out 12 CLI factors to keep in mind. In this talk, Shawn Wang outlines a 13th: state. State is hard, because it depends on context, and context depends on understanding what a user intends to do, not what they are asking. Shawn is working towards enabling oclif to better understand the commands a user has entered, so that it can predict and interpret future commands that might be entered next. This would enable CLI tools to not just interpret a users' commands, but to also interpret their intent.\n\nIntroducing `oclif init` commandApril 10, 2024 · 2 min readThanks to the contribution of @joshcanhelp we released a new command for the oclif CLI called oclif init in version 4.8.0
The oclif init command allows you to initialize oclif in an existing project directory by adding the bare minimum requirements: a few pieces of configuration, bin scripts, and a couple of dependencies (@oclif/core and ts-node). This is slightly different from oclif generate, which will create an entirely new oclif project based on our templates.
oclif init will add the following:

bin scripts: bin/run.js, bin/run.cmd, bin/dev.js, and bin/dev.cmd
oclif section to package.json with bin, dirname, commands, and topicSeparator set (See Configuring Your CLI for more)
@oclif/core to dependencies in your package.json (if it's not already there)
ts-node to devDependencies in your package.json (if it's not already there)

Once you've initialized oclif, you can use the bin scripts to execute your CLI. You can also use the other oclif commands like oclif generate command and oclif generate hook to start adding new functionality.

❯ oclif init --helpInitialize a new oclif CLIUSAGE  $ oclif init [--bin <value>] [--module-type ESM|CommonJS] [--package-manager npm|yarn|pnpm] [--topic-separator    colons|spaces] [-d <value>] [-y]FLAGS  -d, --output-dir=<value>        Directory to initialize the CLI in.  -y, --yes                       Use defaults for all prompts. Individual flags will override defaults.      --bin=<value>               Supply answer for prompt: Command bin name the CLI will export      --module-type=<option>      Supply answer for prompt: Select a module type                                  <options: ESM|CommonJS>      --package-manager=<option>  Supply answer for prompt: Select a package manager                                  <options: npm|yarn|pnpm>      --topic-separator=<option>  Supply answer for prompt: Select a topic separator                                  <options: colons|spaces>DESCRIPTION  Initialize a new oclif CLI  This will add the necessary oclif bin files, add oclif config to package.json, and install @oclif/core and ts-node.EXAMPLES  Initialize a new CLI in the current directory    $ oclif init  Initialize a new CLI in a different directory    $ oclif init --output-dir "/path/to/existing/project"  Supply answers for specific prompts    $ oclif init --topic-separator colons --bin mycli
Hope you enjoy the new command! If you come across any issues or have any new ideas for this command, head over to the oclif/oclif repo and open a new issue.
All our best,
The oclif teamoclif Spring 2024 UpdateMarch 29, 2024 · 4 min readHello oclif developers! It's been a while since we last uploaded a blog - and a lot has happened.
We've been focusing on these high-level areas over the past couple of years:

Improving @oclif/core
ESM Support
Improving and revitalizing oclif.io
Re-engaging the oclif community

Improving @oclif/core​
Since we announced @oclif/core over three years ago, we've released two new major versions, each packed with lots of features that we're really excited about.
Here are some of these changes:

Full support for ESM and interoperability with CommonJS (more on this topic below).
Configurable command discovery strategies that give you more control over how commands are loaded at runtime. Check out the docs.
A new preparse hook that allows you to manipulate the provided arguments before they're parsed. Salesforce used this hook to implement a neat --flags-dir feature that translates local files into flags.
A new Performance class that you can use to track performance inside of @oclif/core and your own CLI or plugin. Check out the docs.
A new flag type, Flags.option, that lets you define a flag with a preset list of options. Typescript then uses the options to infer the flag's type.
Flags now have a relationship property that allows you to define more complex relationships between flags. Check out the flags docs for more information.
Flags now have a defaultHelp property that allows you to set the human readable default value in the command help. This property is useful when your flag's parse method returns a complex type, such as an object or a class. Check out the flags docs for more.
Commands now have a hiddenAliases property that allows you to define aliases that you want to hide from the user. The property is super helpful when you're trying to wean users off a deprecated command.
You can now use bun or tsx as dev runtimes (as opposed to node or ts-node).
A command's usage, args, and flags are now shown whenever a user forgets to provide a required arg or flag, or when they provided a non-existent flag.

If you need help migrating to the latest version, head over to core's README which has links to the migration guides. Feel free to open a new discussion if you need more hands-on help from us or the community.
ESM Support​
Version 3 of @oclif/core introduced full support for developing ESM plugins and CLIs. It also offered full support for interoperability between CommonJS and ESM plugins.
Put more simply, you can now migrate your CLI to ESM while keeping individual plugins in CommonJS (or vice versa). The upgrade path is now much simpler for you. You also don't need to worry about any community plugins that have migrated to ESM before you did (such as all the @oclif plugins) or are staunchly sticking with CommonJS for the foreseeable future.
Read more about this topic here.
Improving and Revitalizing oclif.io​
Another area of focus for us has been improving our documentation site, oclif.io.
While improving the quality and accuracy of the documentation was our priority, we also took the time to upgrade to the latest version of docusaurus. This new version gave our site a much-needed facelift, as well as cool new features such as dark mode and announcements.
If you have any feedback or are running into issues, we want to hear about it. Just create an issue in the oclif.io repo.
Re-engaging the oclif Community​
Lastly, our biggest priority at the moment is to re-engage the oclif community. We understand how frustrating it has been over the years to see your issues and pull requests go unacknowledged. We apologize for not prioritizing the community, and are earnestly trying to make sure that every issue and pull request gets the attention it deserves going forward.
We also opened up GitHub discussions for @oclif/core and the oclif CLI, where you can now post your questions or ideas. We hope you take advantage of them, we love hearing from you!
One last thing: we intend to publicly post our roadmap so you have more visibility into what we're working on. Stay tuned!
All our best,
The oclif teamAnnouncing oclif v2!January 12, 2022 · 5 min readHello and happy new year! It's our great pleasure to announce that we have released oclif v2, which uses the new @oclif/core library! 🎉
oclif v2 includes many changes that improve the experience of both creating and using an oclif CLI.
Going forward, we don't plan to make any updates to oclif v1 and its corresponding libraries, except for critical security fixes. See the compatibility matrix for a list of these libraries. In order to give developers time to migrate from v1 to v2, we're not completely dropping support yet. But at some point in the future we'll archive the v1 repositories and deprecate their versions on npm.
What’s changing?​
Repository Changes​
All repositories under the oclif org now use main as their primary branch and oclif-v1 as the legacy branch. The main  branch corresponds to oclif v2 and the oclif-v1 branch to oclif v1. If you find any repos that don’t have a main branch, you can safely assume that they're not used in oclif v2 and will be deprecated in the future.
Consolidating Tools & Libraries​
The oclif-dev CLI has now been incorporated into oclif. You now no longer need to install a separate package to manage your entire CLI’s lifecycle.
The following libraries have been consolidated under @oclif/core and will be deprecated at some point in the future. Read the migration guide to learn how to update your CLI or plugin to use the new core library.

@oclif/command
@oclif/config
@oclif/error
@oclif/help
@oclif/parser

No more single vs multi command CLIs​
There's only one "type" of oclif v2 CLI, but it can have as few or as many commands as a developer wants. As a result, there’s only one command to generate CLIs, oclif generate, as opposed to the old oclif single and oclif multi commands.
Node > 12​
To ensure oclif CLIs are as secure as possible, all v2 libraries and plugins support only Node 12 or higher as of now. Going forward, they'll support only Node Maintenance or higher, as defined by Node's release schedule here: https://nodejs.org/en/about/releases/.
What’s new?​
New example CLI​
oclif-hello-world is our new example repo. This is also the repo that's used as a template when running oclif generate to create a new CLI. This repo will always be able to be referenced as an example of what an oclif v2 CLI should look like.
Spaced commands​
oclif CLIs can now use spaces, instead of colons, to separate topics and subcommands. To enable this feature, simply add “topicSeparator": " " to the oclif config in your package.json. See an example in our example repo.
// Old commands that use :$ mycli do:something
// New spaced commands$ mycli do something

Note: Spaced commands are backwards compatible. So if you enable spaced commands for your CLI, users will still be able to use : as a separator. This ensures that any existing scripts don't break.

New Help Output​
We’ve revamped the way command help is outputted to the terminal, making it both easier to implement and easier to read. See the difference between the old help output on the left and the new help output on the right in the screenshots below.
oclif v1oclif v2
Notice that there are new sections for flags and global flags, examples are displayed with better spacing, and there is a section at the bottom called Configuration Variables. This Configuration Variables section is not part of the new help by default. But we've added support for custom help sections, which is what the sf CLI uses to create the new section.
Async Command Parsing​
We’ve also improved the performance of new CLIs by rewriting how commands are parsed on initialization. The new parser is asynchronous, which makes CLIs with a lot of commands or installed  plugins much faster.
What’s coming next?​
Part of our charter for the release of oclif v2 includes improving our engagement with the oclif community. We know that over the past couple of years we’ve reduced our involvement, and a lot of issues and PRs have languished in limbo. Hopefully you’ve already seen increased activity and responses from oclif maintainers recently, but if you haven’t, please don’t hesitate to ping us by tagging @admins in oclif repos.
We also want to start interviewing members of the oclif community to acquire feedback and prioritize the features and fixes you deem most important!
Best,
The oclif team

Reference material​
Migration Guide​
This guide explains how to upgrade a CLI or plugin from the old oclif v1 libraries to the new @oclif/core library that oclif v2 uses.
https://github.com/oclif/core/blob/main/MIGRATION.md
Compatibility Matrix​
The following matrix shows how the v1 libraries and plugins relate to the new v2 ones. Use this matrix as a guide to know what to drop and which versions to switch when upgrading your plugins and CLIs to v2.
oclif "v1"oclif "v2"Utility CLIsoclif@<2@oclif/dev-cli@<2oclif@>=2Main packages@oclif/command@oclif/config@oclif/errors@oclif/parser@oclif/plugin-help@oclif/core@>=1Node LTSNode v8-14Node v12+ (at time of writing)TypeScripttypescript@<4typescript@>=4Main plugins@oclif/plugin-autocomplete@<1@oclif/plugin-commands@<2@oclif/plugin-help@<4@oclif/plugin-not-found@<2@oclif/plugin-plugins@<2@oclif/plugin-update@<2plugin-warn-if-update-available@<2plugin-which@<2@oclif/plugin-autocomplete@>=1@oclif/plugin-commands@>=2@oclif/plugin-help@>=4@oclif/plugin-not-found@>=2@oclif/plugin-plugins@>=2@oclif/plugin-update@>=2@oclif/plugin-warn-if-update-available@>=2@oclif/plugin-which@>=2Introducing @oclif/coreMarch 1, 2021 · 3 min readGreetings!
We hope this blog post finds you well.
Introducing...​
We are excited to announce the next iteration of the oclif project today: @oclif/core.
We have learned a lot in the last three years of developing oclif, developing on oclif and supporting millions of command runs a day via Heroku and Salesforce CLIs.
@oclif/core ("Core") simplifies the oclif development experience and introduces highly requested new features.
Core combines the essential oclif packages into one "core" package, aptly named @oclif/core.
Core also introduces:

A default command option
Colon or space command syntax
Async command parsing
Command piping to arguments

With the introduction of default command functionality, Core simplifies the oclif project and removes the notion of single or multi command CLIs. Core CLIs can have 1 or many commands.
Along with Core, we moved the oclif-dev CLI into the oclif CLI creating a single "utility" CLI. This CLI also introduces a new AWS S3 compatible publishing scheme.
What to expect in the near future​
Core is in pre-release beta and being actively developed for new internal Salesforce CLIs.
Much documentation needs to be written in the coming months including migration paths. Migration onto Core should be as painless as possible with many exports remaining entirely unchanged. Look for forthcoming blog posts and documentation on oclif.io.
Early this summer, tentively June 1, we will release Core v1. Core's release will coincide with major bumps to many other oclif plugin packages. See the compatibility matrix below.
At Core's v1 release, the current "main" oclif packages (namely: command, config, errors & parser) will go into maintenance mode until Jan 2022. They will receive only bug and security fixes and they remain compatible with current versions of the oclif and oclif-dev CLIs. Afterwhich, they will be archived.
Companioning Core, the next major release of the oclif CLI (literally oclif@2) will generate Core CLIs.
Going forward​
We are excited to release Core! We invite you to poke around the Core repo. It may appear to be a big change but Core keeps what you already enjoy about oclif while reducing development complexity, project dependencies, package coupling and bundle size and introduces many requested features previously too prickly to weave into the current oclif architecture.
Best,
The oclif team
Reference: Compatibility matrix​
oclif "v1"oclif "Core"Utility CLIsoclif@<2@oclif/dev-cli@<2oclif@>=2Main packages@oclif/core@<2@oclif/config@<2@oclif/errors@<2@oclif/parser@<4@oclif/plugin-help@<4@oclif/core@>=1Node LTSNode v8-14Node v12+TypeScripttypescript@<4typescript@>=4Main plugins@oclif/plugin-autocomplete@<1@oclif/plugin-commands@<2@oclif/plugin-help@<4@oclif/plugin-not-found@<2@oclif/plugin-plugins@<2@oclif/plugin-update@<2plugin-warn-if-update-available@<2plugin-which@<2@oclif/plugin-autocomplete@>=2@oclif/plugin-commands@>=2@oclif/plugin-help@>=4@oclif/plugin-not-found@>=2@oclif/plugin-plugins@>=2@oclif/plugin-update@>=2@oclif/plugin-warn-if-update-available@>=2@oclif/plugin-which@>=2oclif Summer 2020 UpdateAugust 26, 2020 · 2 min readHello oclif developers! We hope you are all doing well.
Earlier this year, we started our planning for oclifconf v2 and, like all conference, had to change course. We opted not to hold a virtual conference, however, we wanted to take some time to highlight a few oclif features shipped this year.
Feature: Help templating​
One of the most requested features, help templating enables oclif developers to customize the help output for their CLI.
Read the announcement.
Feature: Custom error delegation​
This feature both improved how oclif throws and handles errors and allows oclif developers to overwrite or interject in oclif’s error handling.
Read the announcement.
Feature: postrun hooks​
We have added a new lifecycle event postrun. Your CLI can now run a hook after a command has ran.
See our hook documentation.
Feature: Root index command​
Previously, oclif would display CLI help if only the binary name with no command ID was invoked, oclif now supports a "root index" command. If present, a command defined at src/commands/index.ts will be run if no command ID is found.
1 million weekly downloads​
While exact oclif usage metrics are hard to pin down, we use npm download statistics of oclif packages as a rough approximation. Earlier this year, oclif's command package hit 1 million weekly downloads for the first time!
This year has been presented its challenges on everyone. We want to thank you, oclif developers, whom have taken the time to use and improve the oclif project. We look forward to seeing you all - in person - in the future!
All our best,
The oclif teamPretty Printable ErrorsJuly 1, 2020 · One min readOften CLIs are used as handy tools and when things go wrong it’s useful to have additional context. In oclif we have added a couple of additional properties that can show extra context to the users when an error is displayed. The code, ref and suggestions will now be displayed if they are included. This will work with an existing oclif CLI by adding the latest @oclif/errors and @oclif/core to the CLI's package.json dependencies.
For example, using this.error with the additional properties:
class TestError extends Command {  async run() {    this.error("An error has occurred!", {      code: "OCLIF_ERR",      ref: "https://oclif.io/docs/commands#thiserrormessage-string--error-options-code-string-exit-number",      suggestions: ["Use these extra properties to provide additional context"],    })  }}
would result with the following output:
›   Error: An error has occurred!›   Code: OCLIF_ERR›   Try this: Use these extra properties to provide additional context›   Reference: https://oclif.io/docs/commands#thiserrormessage-string--error-options-code-string-exit-number
If these properties are not provided then nothing changes and the CLI will continue to display the single error message output as it did before. Additionally, as part of this exercise we’ve added documentation around Error Handling in oclif which should come in handy if the need arises to extend oclif’s default handling of errors.Customizing Help in oclifMay 5, 2020 · 2 min readOut of the box oclif provides a great help experience for CLIs.
But what if, as an oclif developer, you want to customize some or all of the output?
You can now customize your CLI's help output by implementing the HelpBase abstract class.
Getting started with custom help​
If you have not done so yet, update @oclif/core.
$ yarn add --latest @oclif/core
To get started, first define the filepath to your help class in oclif's config in package.json. This is a relative path to the help class, without a file extension.
For this example, the help class will be created in a file at "[project root]/src/help.ts".
{  // ...  "oclif": {    "helpClass": "./lib/help"    // ...  }  // ...}
From here there are two paths, implement the HelpBase abstract class yourself or overwrite the parts of the default Help class you want to customize (ex: how command usage is displayed). We recommend the latter approach but cover both in the new Help Classes docs.
Separating TOPICS & COMMANDS in the new default Help class​
Previously, topics and child commands were listed in help output under a single list heading called "COMMANDS". But we found this can be slightly confusing. Some topics are commands also (a.k.a. topic-commands) while others are simply organizational namespacing (and when ran just show their help).
The new default Help class splits the list of children into distinct lists of "TOPICS" and "COMMANDS", with the possibility of an item appearing in both if it a topic-command. This makes it clearer what is expected to be ran - "COMMANDS" - and what is providing structure - "TOPICS" - when looking at the help output.
VERSION  plugin-help-example/0.0.0 darwin-x64 node-v12.12.0USAGE  $ plugin-help-example [COMMAND]TOPICS  topic  this is a topic and has child topics or commandsCOMMANDS  hello  describe the command here  help   display help for plugin-help-example
We look forward to seeing what custom help features you implement in your oclif CLIs with this new feature!oclif TSLint to ESLint MigrationDecember 5, 2019 · 3 min readBack in February of this year, plans were announced to deprecate TSLint in favor of ESLint. TSLint's goal has become to work toward a “unified developer experience” by supporting ESLint development going forward.
What has changed in oclif​
To keep inline with the community, oclif has transitioned to ESLint for all our core libraries as well as all our official plugins.
Starting in v1.15.x, oclif will now optionally generate projects with ESLint for both TypeScript and JavaScript CLI’s.
ESLint does require Node to be on stable LTS version, at the time of writing, Node 8.10.x, Node 10.13.x & Node 12.x.x.
How does this affect you​
Existing CLI’s are unchanged, but any newly generated CLI's will only give the option of using ESLint. If you are running tslint in your CLI, we recommend you switch to ESLint as well.
In migrating our projects we took the following steps (for an example of these changes see this pull request).


Install eslint
$ yarn add eslint eslint-config-oclif eslint-config-oclif-typescript --dev


Add eslint related files


$ echo '{  "extends": [    "oclif",    "oclif-typescript"  ],  "rules": {  }}' > .eslintrc


Remove tslint and related packages
$ yarn remove @oclif/tslint tslint


Remove tslint related configuration files
$ rm tslint.json


Change lint script in our package.json from something like:
"lint": "tsc -p test --noEmit && tslint -p test -t stylish"
to
"lint": "eslint . --ext .ts --config .eslintrc"


To preserve the test compile (tsc -p test --noEmit) we also made the following updates to our scripts:
"pretest": "tsc -p test --noEmit"
In some cases we had our posttest duplicating the same steps as our lint script so it’s cleaner to have it reference the lint job directly with:
"posttest": "yarn lint"

Run yarn lint --fix. This attempts to auto-fix any linting violations automatically. In the case an auto-fix isn’t available it should be fixed manually or ignored (see the eslint configuration doc for more information)
Do a search in the codebase for tslint and remove any unnecessary tslint disabling comments, like:

/* tslint:disable:object-literal-sort-keys */
If you are on a version of Node that is not supported by ESLint, you will also need to update your Node engine. ESLint supports Node 8, 10, and 12 so you should upgrade to the most recent Node version compatible with your CLI and also supported by ESLint (see ESLint's Installation and Usage instructions).
When will this take effect​
These changes have taken effect in oclif v1.15.1. When you generate a new CLI or plugin it will now contain configuration for ESLint instead of TSLint.oclif's Current Node SupportOctober 31, 2019 · 3 min readTo maintain a healthy project trajectory, oclif follows and supports Node Active LTS release, currently Node 10 & Node 12. This means ensuring that oclif continues to play nice with coming Active LTS Node versions and other packages in the ecosystem. Moving forward also means leaving older versions behind. Starting in 2020, Node will stop maintaining Node 8 and it is our intent at that time to also follow suit. Let’s take a look at a few ways we will be supporting these changes.
CI Environments​
CLIs created with the oclif cli going forward will be generated with a CircleCI configuration with Node 10 & 12 and an Appveyor configuration using Node 10. We have also added Node latest to CircleCi to be an early warning detection against coming Node changes (Node latest is managed by CircleCI).
We have already updated every oclif repo's CI configs to reflect this.
If your existing CLI uses either Appveyor or CircleCI you can update your config files also, like so:
.circleci/config.yml​
Your CircleCI config should contain a node-latest job, aliased as test. From this, there should be two extensions of this job for the Active LTS Node versions, Node 10 and Node 12.
  node-10:    <<: *node-latest    docker:      - image: node:10  node-12:    <<: *node-latest    docker:      - image: node:12
Notice that these declarations only change the Docker Node images used to run that job.
Additionally, the jobs listed within workflows must also be updated to reflect our changes in configuration:
    jobs:      - node-latest      - node-10      - node-12
appveyor.yml​
For appveyor we are currently only testing the oldest Active LTS Node version, Node 10. Update the nodejs_version proppert in your appveyor.yml file to reflect this.
environment:  nodejs_version: "10"
Deprecating Node 8 & Updating packge.json engines​
In Jan 2020, Node will end its Node 8 maintenance. We will follow suit by setting the package.json engine property in oclif packages to >=10 and bumping the package's major versions.
Depending on how you ship your CLI you may wish to also bump the engines version in your CLI's package.json. You can read more about the implications of the engines property configuration in the npm documentation.
Also consider distributing your CLI with its own Node version.
Packaged Node Version​
When using dev-cli to pack your CLI it will use the Node version as specified in your package.json under the oclif.update.node.version property. This value should reflect an Active LTS Node version (dev-cli does not currently enforce versions).
Supporting the future​
As a community we may discover bumps along the way as we upgrade. If you notice something related to oclif please feel free to open an issue or submit a pull request under the relevant oclif package within the org.
We look forward to using the latest from Node and the community and keeping oclif healthy along the way.oclifconf 2019: A RecapSeptember 16, 2019 · 4 min readIn May, Heroku and Salesforce Open Source organized oclifconf, a conference for developers & product managers building CLI tools on top of the open source oclif framework. The speakers came from various tech companies, such as Adobe, Netlify, and Apollo, who have already built amazing CLI experiences. The topics covered everything from the incredible capabilities oclif has unlocked, to the community-built plugins extending its functionality, and even what the behavior of an adaptive CLI tool might look like.
Below is a listing of all of the talks from the event, along with a short summary. Enjoy!
The future of oclif by Jeff Dickey​

In its relatively short lifetime, oclif has already inspired many developers and companies to adopt its framework as a means for implementing their own command-line tooling. In this talk, Jeff Dickey, an oclif founding team member, recaps the project's history and inspiration. He also looks towards the future and outlines some features and improvements that the tool could adapt. This isn't so much a definitive roadmap of where oclif is headed, but rather, a call to inspiration for developers eager to contribute! And if you are interested in contributing, check out the open issues in the oclif GitHub repo and come say "Hello!" on Spectrum Chat.
Open Source Citizenship by Josh Simmons​

When it comes to open source, it's more than just individuals now. More and more frequently, large corporations are contributing to projects by donating to contributors, sponsoring events, or upstreaming contributions. But keeping open source projects and communities healthy requires more than just money and brainpower. Josh Simmons surveyed multiple open source communities and relays his findings as to what help maintainers and contributors actually need in this talk.
Building an enterprise-grade CLI with oclif by Thomas Dvornik​

Security and performance are all about trust. While oclif is an extremely extensible framework for building CLI tooling, there are additional requirements to fulfill for enterprise businesses to adopt it that might not be necessary for individual developers. Thomas Dvornik outlines what he and his colleagues at Salesforce have implemented as plugins to oclif to satisfy these needs, including encrypted OAuth, plugin signing, lazy loading dependencies, synchronizing weekly releases and deprecations across dozens of repositories, and establishing cross-team coding and documentation standards.
How Adobe I/O built an extensible CLI with oclif by Jesse MacFadyen​

Perhaps oclif's most appealing feature is its support for plugins. In Cordova's case, they've created a sophisticated telemetry system that helps Adobe developers see which commands users are using--and reports on which ones are erroring out. By embedding a feedback system into the tool, users are even able to quickly send their suggestions to a form, without ever leaving the terminal. Jesse MacFadyen demonstrates how oclif's plugin system can work beyond simply executing commands.
Integrating oclif with GraphQL and Apollo by Evans Hauser​

For Evans Hauser and the team at Apollo, oclif is best thought of as "React for the CLI." As a client paired with a strongly-typed API contract to a server, it can deliver structured and consistent commands to retrieve external data. What better mechanism to use for this transfer than GraphQL, a framework which empowers the client to ask precisely for the data it needs, and nothing more?
Adaptive Intent-based CLI State Machines by Shawn Wang​

In designing oclif, Jeff Dickey wrote out 12 CLI factors to keep in mind. In this talk, Shawn Wang outlines a 13th: state. State is hard, because it depends on context, and context depends on understanding what a user intends to do, not what they are asking. Shawn is working towards enabling oclif to better understand the commands a user has entered, so that it can predict and interpret future commands that might be entered next. This would enable CLI tools to not just interpret a users' commands, but to also interpret their intent.Older Entries\n\n\n\nIntroducing `oclif init` commandApril 10, 2024 · 2 min readThanks to the contribution of @joshcanhelp we released a new command for the oclif CLI called oclif init in version 4.8.0
The oclif init command allows you to initialize oclif in an existing project directory by adding the bare minimum requirements: a few pieces of configuration, bin scripts, and a couple of dependencies (@oclif/core and ts-node). This is slightly different from oclif generate, which will create an entirely new oclif project based on our templates.
oclif init will add the following:

bin scripts: bin/run.js, bin/run.cmd, bin/dev.js, and bin/dev.cmd
oclif section to package.json with bin, dirname, commands, and topicSeparator set (See Configuring Your CLI for more)
@oclif/core to dependencies in your package.json (if it's not already there)
ts-node to devDependencies in your package.json (if it's not already there)

Once you've initialized oclif, you can use the bin scripts to execute your CLI. You can also use the other oclif commands like oclif generate command and oclif generate hook to start adding new functionality.

❯ oclif init --helpInitialize a new oclif CLIUSAGE  $ oclif init [--bin <value>] [--module-type ESM|CommonJS] [--package-manager npm|yarn|pnpm] [--topic-separator    colons|spaces] [-d <value>] [-y]FLAGS  -d, --output-dir=<value>        Directory to initialize the CLI in.  -y, --yes                       Use defaults for all prompts. Individual flags will override defaults.      --bin=<value>               Supply answer for prompt: Command bin name the CLI will export      --module-type=<option>      Supply answer for prompt: Select a module type                                  <options: ESM|CommonJS>      --package-manager=<option>  Supply answer for prompt: Select a package manager                                  <options: npm|yarn|pnpm>      --topic-separator=<option>  Supply answer for prompt: Select a topic separator                                  <options: colons|spaces>DESCRIPTION  Initialize a new oclif CLI  This will add the necessary oclif bin files, add oclif config to package.json, and install @oclif/core and ts-node.EXAMPLES  Initialize a new CLI in the current directory    $ oclif init  Initialize a new CLI in a different directory    $ oclif init --output-dir "/path/to/existing/project"  Supply answers for specific prompts    $ oclif init --topic-separator colons --bin mycli
Hope you enjoy the new command! If you come across any issues or have any new ideas for this command, head over to the oclif/oclif repo and open a new issue.
All our best,
The oclif teamoclif Spring 2024 UpdateMarch 29, 2024 · 4 min readHello oclif developers! It's been a while since we last uploaded a blog - and a lot has happened.
We've been focusing on these high-level areas over the past couple of years:

Improving @oclif/core
ESM Support
Improving and revitalizing oclif.io
Re-engaging the oclif community

Improving @oclif/core​
Since we announced @oclif/core over three years ago, we've released two new major versions, each packed with lots of features that we're really excited about.
Here are some of these changes:

Full support for ESM and interoperability with CommonJS (more on this topic below).
Configurable command discovery strategies that give you more control over how commands are loaded at runtime. Check out the docs.
A new preparse hook that allows you to manipulate the provided arguments before they're parsed. Salesforce used this hook to implement a neat --flags-dir feature that translates local files into flags.
A new Performance class that you can use to track performance inside of @oclif/core and your own CLI or plugin. Check out the docs.
A new flag type, Flags.option, that lets you define a flag with a preset list of options. Typescript then uses the options to infer the flag's type.
Flags now have a relationship property that allows you to define more complex relationships between flags. Check out the flags docs for more information.
Flags now have a defaultHelp property that allows you to set the human readable default value in the command help. This property is useful when your flag's parse method returns a complex type, such as an object or a class. Check out the flags docs for more.
Commands now have a hiddenAliases property that allows you to define aliases that you want to hide from the user. The property is super helpful when you're trying to wean users off a deprecated command.
You can now use bun or tsx as dev runtimes (as opposed to node or ts-node).
A command's usage, args, and flags are now shown whenever a user forgets to provide a required arg or flag, or when they provided a non-existent flag.

If you need help migrating to the latest version, head over to core's README which has links to the migration guides. Feel free to open a new discussion if you need more hands-on help from us or the community.
ESM Support​
Version 3 of @oclif/core introduced full support for developing ESM plugins and CLIs. It also offered full support for interoperability between CommonJS and ESM plugins.
Put more simply, you can now migrate your CLI to ESM while keeping individual plugins in CommonJS (or vice versa). The upgrade path is now much simpler for you. You also don't need to worry about any community plugins that have migrated to ESM before you did (such as all the @oclif plugins) or are staunchly sticking with CommonJS for the foreseeable future.
Read more about this topic here.
Improving and Revitalizing oclif.io​
Another area of focus for us has been improving our documentation site, oclif.io.
While improving the quality and accuracy of the documentation was our priority, we also took the time to upgrade to the latest version of docusaurus. This new version gave our site a much-needed facelift, as well as cool new features such as dark mode and announcements.
If you have any feedback or are running into issues, we want to hear about it. Just create an issue in the oclif.io repo.
Re-engaging the oclif Community​
Lastly, our biggest priority at the moment is to re-engage the oclif community. We understand how frustrating it has been over the years to see your issues and pull requests go unacknowledged. We apologize for not prioritizing the community, and are earnestly trying to make sure that every issue and pull request gets the attention it deserves going forward.
We also opened up GitHub discussions for @oclif/core and the oclif CLI, where you can now post your questions or ideas. We hope you take advantage of them, we love hearing from you!
One last thing: we intend to publicly post our roadmap so you have more visibility into what we're working on. Stay tuned!
All our best,
The oclif teamAnnouncing oclif v2!January 12, 2022 · 5 min readHello and happy new year! It's our great pleasure to announce that we have released oclif v2, which uses the new @oclif/core library! 🎉
oclif v2 includes many changes that improve the experience of both creating and using an oclif CLI.
Going forward, we don't plan to make any updates to oclif v1 and its corresponding libraries, except for critical security fixes. See the compatibility matrix for a list of these libraries. In order to give developers time to migrate from v1 to v2, we're not completely dropping support yet. But at some point in the future we'll archive the v1 repositories and deprecate their versions on npm.
What’s changing?​
Repository Changes​
All repositories under the oclif org now use main as their primary branch and oclif-v1 as the legacy branch. The main  branch corresponds to oclif v2 and the oclif-v1 branch to oclif v1. If you find any repos that don’t have a main branch, you can safely assume that they're not used in oclif v2 and will be deprecated in the future.
Consolidating Tools & Libraries​
The oclif-dev CLI has now been incorporated into oclif. You now no longer need to install a separate package to manage your entire CLI’s lifecycle.
The following libraries have been consolidated under @oclif/core and will be deprecated at some point in the future. Read the migration guide to learn how to update your CLI or plugin to use the new core library.

@oclif/command
@oclif/config
@oclif/error
@oclif/help
@oclif/parser

No more single vs multi command CLIs​
There's only one "type" of oclif v2 CLI, but it can have as few or as many commands as a developer wants. As a result, there’s only one command to generate CLIs, oclif generate, as opposed to the old oclif single and oclif multi commands.
Node > 12​
To ensure oclif CLIs are as secure as possible, all v2 libraries and plugins support only Node 12 or higher as of now. Going forward, they'll support only Node Maintenance or higher, as defined by Node's release schedule here: https://nodejs.org/en/about/releases/.
What’s new?​
New example CLI​
oclif-hello-world is our new example repo. This is also the repo that's used as a template when running oclif generate to create a new CLI. This repo will always be able to be referenced as an example of what an oclif v2 CLI should look like.
Spaced commands​
oclif CLIs can now use spaces, instead of colons, to separate topics and subcommands. To enable this feature, simply add “topicSeparator": " " to the oclif config in your package.json. See an example in our example repo.
// Old commands that use :$ mycli do:something
// New spaced commands$ mycli do something

Note: Spaced commands are backwards compatible. So if you enable spaced commands for your CLI, users will still be able to use : as a separator. This ensures that any existing scripts don't break.

New Help Output​
We’ve revamped the way command help is outputted to the terminal, making it both easier to implement and easier to read. See the difference between the old help output on the left and the new help output on the right in the screenshots below.
oclif v1oclif v2
Notice that there are new sections for flags and global flags, examples are displayed with better spacing, and there is a section at the bottom called Configuration Variables. This Configuration Variables section is not part of the new help by default. But we've added support for custom help sections, which is what the sf CLI uses to create the new section.
Async Command Parsing​
We’ve also improved the performance of new CLIs by rewriting how commands are parsed on initialization. The new parser is asynchronous, which makes CLIs with a lot of commands or installed  plugins much faster.
What’s coming next?​
Part of our charter for the release of oclif v2 includes improving our engagement with the oclif community. We know that over the past couple of years we’ve reduced our involvement, and a lot of issues and PRs have languished in limbo. Hopefully you’ve already seen increased activity and responses from oclif maintainers recently, but if you haven’t, please don’t hesitate to ping us by tagging @admins in oclif repos.
We also want to start interviewing members of the oclif community to acquire feedback and prioritize the features and fixes you deem most important!
Best,
The oclif team

Reference material​
Migration Guide​
This guide explains how to upgrade a CLI or plugin from the old oclif v1 libraries to the new @oclif/core library that oclif v2 uses.
https://github.com/oclif/core/blob/main/MIGRATION.md
Compatibility Matrix​
The following matrix shows how the v1 libraries and plugins relate to the new v2 ones. Use this matrix as a guide to know what to drop and which versions to switch when upgrading your plugins and CLIs to v2.
oclif "v1"oclif "v2"Utility CLIsoclif@<2@oclif/dev-cli@<2oclif@>=2Main packages@oclif/command@oclif/config@oclif/errors@oclif/parser@oclif/plugin-help@oclif/core@>=1Node LTSNode v8-14Node v12+ (at time of writing)TypeScripttypescript@<4typescript@>=4Main plugins@oclif/plugin-autocomplete@<1@oclif/plugin-commands@<2@oclif/plugin-help@<4@oclif/plugin-not-found@<2@oclif/plugin-plugins@<2@oclif/plugin-update@<2plugin-warn-if-update-available@<2plugin-which@<2@oclif/plugin-autocomplete@>=1@oclif/plugin-commands@>=2@oclif/plugin-help@>=4@oclif/plugin-not-found@>=2@oclif/plugin-plugins@>=2@oclif/plugin-update@>=2@oclif/plugin-warn-if-update-available@>=2@oclif/plugin-which@>=2Introducing @oclif/coreMarch 1, 2021 · 3 min readGreetings!
We hope this blog post finds you well.
Introducing...​
We are excited to announce the next iteration of the oclif project today: @oclif/core.
We have learned a lot in the last three years of developing oclif, developing on oclif and supporting millions of command runs a day via Heroku and Salesforce CLIs.
@oclif/core ("Core") simplifies the oclif development experience and introduces highly requested new features.
Core combines the essential oclif packages into one "core" package, aptly named @oclif/core.
Core also introduces:

A default command option
Colon or space command syntax
Async command parsing
Command piping to arguments

With the introduction of default command functionality, Core simplifies the oclif project and removes the notion of single or multi command CLIs. Core CLIs can have 1 or many commands.
Along with Core, we moved the oclif-dev CLI into the oclif CLI creating a single "utility" CLI. This CLI also introduces a new AWS S3 compatible publishing scheme.
What to expect in the near future​
Core is in pre-release beta and being actively developed for new internal Salesforce CLIs.
Much documentation needs to be written in the coming months including migration paths. Migration onto Core should be as painless as possible with many exports remaining entirely unchanged. Look for forthcoming blog posts and documentation on oclif.io.
Early this summer, tentively June 1, we will release Core v1. Core's release will coincide with major bumps to many other oclif plugin packages. See the compatibility matrix below.
At Core's v1 release, the current "main" oclif packages (namely: command, config, errors & parser) will go into maintenance mode until Jan 2022. They will receive only bug and security fixes and they remain compatible with current versions of the oclif and oclif-dev CLIs. Afterwhich, they will be archived.
Companioning Core, the next major release of the oclif CLI (literally oclif@2) will generate Core CLIs.
Going forward​
We are excited to release Core! We invite you to poke around the Core repo. It may appear to be a big change but Core keeps what you already enjoy about oclif while reducing development complexity, project dependencies, package coupling and bundle size and introduces many requested features previously too prickly to weave into the current oclif architecture.
Best,
The oclif team
Reference: Compatibility matrix​
oclif "v1"oclif "Core"Utility CLIsoclif@<2@oclif/dev-cli@<2oclif@>=2Main packages@oclif/core@<2@oclif/config@<2@oclif/errors@<2@oclif/parser@<4@oclif/plugin-help@<4@oclif/core@>=1Node LTSNode v8-14Node v12+TypeScripttypescript@<4typescript@>=4Main plugins@oclif/plugin-autocomplete@<1@oclif/plugin-commands@<2@oclif/plugin-help@<4@oclif/plugin-not-found@<2@oclif/plugin-plugins@<2@oclif/plugin-update@<2plugin-warn-if-update-available@<2plugin-which@<2@oclif/plugin-autocomplete@>=2@oclif/plugin-commands@>=2@oclif/plugin-help@>=4@oclif/plugin-not-found@>=2@oclif/plugin-plugins@>=2@oclif/plugin-update@>=2@oclif/plugin-warn-if-update-available@>=2@oclif/plugin-which@>=2oclif Summer 2020 UpdateAugust 26, 2020 · 2 min readHello oclif developers! We hope you are all doing well.
Earlier this year, we started our planning for oclifconf v2 and, like all conference, had to change course. We opted not to hold a virtual conference, however, we wanted to take some time to highlight a few oclif features shipped this year.
Feature: Help templating​
One of the most requested features, help templating enables oclif developers to customize the help output for their CLI.
Read the announcement.
Feature: Custom error delegation​
This feature both improved how oclif throws and handles errors and allows oclif developers to overwrite or interject in oclif’s error handling.
Read the announcement.
Feature: postrun hooks​
We have added a new lifecycle event postrun. Your CLI can now run a hook after a command has ran.
See our hook documentation.
Feature: Root index command​
Previously, oclif would display CLI help if only the binary name with no command ID was invoked, oclif now supports a "root index" command. If present, a command defined at src/commands/index.ts will be run if no command ID is found.
1 million weekly downloads​
While exact oclif usage metrics are hard to pin down, we use npm download statistics of oclif packages as a rough approximation. Earlier this year, oclif's command package hit 1 million weekly downloads for the first time!
This year has been presented its challenges on everyone. We want to thank you, oclif developers, whom have taken the time to use and improve the oclif project. We look forward to seeing you all - in person - in the future!
All our best,
The oclif teamPretty Printable ErrorsJuly 1, 2020 · One min readOften CLIs are used as handy tools and when things go wrong it’s useful to have additional context. In oclif we have added a couple of additional properties that can show extra context to the users when an error is displayed. The code, ref and suggestions will now be displayed if they are included. This will work with an existing oclif CLI by adding the latest @oclif/errors and @oclif/core to the CLI's package.json dependencies.
For example, using this.error with the additional properties:
class TestError extends Command {  async run() {    this.error("An error has occurred!", {      code: "OCLIF_ERR",      ref: "https://oclif.io/docs/commands#thiserrormessage-string--error-options-code-string-exit-number",      suggestions: ["Use these extra properties to provide additional context"],    })  }}
would result with the following output:
›   Error: An error has occurred!›   Code: OCLIF_ERR›   Try this: Use these extra properties to provide additional context›   Reference: https://oclif.io/docs/commands#thiserrormessage-string--error-options-code-string-exit-number
If these properties are not provided then nothing changes and the CLI will continue to display the single error message output as it did before. Additionally, as part of this exercise we’ve added documentation around Error Handling in oclif which should come in handy if the need arises to extend oclif’s default handling of errors.Customizing Help in oclifMay 5, 2020 · 2 min readOut of the box oclif provides a great help experience for CLIs.
But what if, as an oclif developer, you want to customize some or all of the output?
You can now customize your CLI's help output by implementing the HelpBase abstract class.
Getting started with custom help​
If you have not done so yet, update @oclif/core.
$ yarn add --latest @oclif/core
To get started, first define the filepath to your help class in oclif's config in package.json. This is a relative path to the help class, without a file extension.
For this example, the help class will be created in a file at "[project root]/src/help.ts".
{  // ...  "oclif": {    "helpClass": "./lib/help"    // ...  }  // ...}
From here there are two paths, implement the HelpBase abstract class yourself or overwrite the parts of the default Help class you want to customize (ex: how command usage is displayed). We recommend the latter approach but cover both in the new Help Classes docs.
Separating TOPICS & COMMANDS in the new default Help class​
Previously, topics and child commands were listed in help output under a single list heading called "COMMANDS". But we found this can be slightly confusing. Some topics are commands also (a.k.a. topic-commands) while others are simply organizational namespacing (and when ran just show their help).
The new default Help class splits the list of children into distinct lists of "TOPICS" and "COMMANDS", with the possibility of an item appearing in both if it a topic-command. This makes it clearer what is expected to be ran - "COMMANDS" - and what is providing structure - "TOPICS" - when looking at the help output.
VERSION  plugin-help-example/0.0.0 darwin-x64 node-v12.12.0USAGE  $ plugin-help-example [COMMAND]TOPICS  topic  this is a topic and has child topics or commandsCOMMANDS  hello  describe the command here  help   display help for plugin-help-example
We look forward to seeing what custom help features you implement in your oclif CLIs with this new feature!oclif TSLint to ESLint MigrationDecember 5, 2019 · 3 min readBack in February of this year, plans were announced to deprecate TSLint in favor of ESLint. TSLint's goal has become to work toward a “unified developer experience” by supporting ESLint development going forward.
What has changed in oclif​
To keep inline with the community, oclif has transitioned to ESLint for all our core libraries as well as all our official plugins.
Starting in v1.15.x, oclif will now optionally generate projects with ESLint for both TypeScript and JavaScript CLI’s.
ESLint does require Node to be on stable LTS version, at the time of writing, Node 8.10.x, Node 10.13.x & Node 12.x.x.
How does this affect you​
Existing CLI’s are unchanged, but any newly generated CLI's will only give the option of using ESLint. If you are running tslint in your CLI, we recommend you switch to ESLint as well.
In migrating our projects we took the following steps (for an example of these changes see this pull request).


Install eslint
$ yarn add eslint eslint-config-oclif eslint-config-oclif-typescript --dev


Add eslint related files


$ echo '{  "extends": [    "oclif",    "oclif-typescript"  ],  "rules": {  }}' > .eslintrc


Remove tslint and related packages
$ yarn remove @oclif/tslint tslint


Remove tslint related configuration files
$ rm tslint.json


Change lint script in our package.json from something like:
"lint": "tsc -p test --noEmit && tslint -p test -t stylish"
to
"lint": "eslint . --ext .ts --config .eslintrc"


To preserve the test compile (tsc -p test --noEmit) we also made the following updates to our scripts:
"pretest": "tsc -p test --noEmit"
In some cases we had our posttest duplicating the same steps as our lint script so it’s cleaner to have it reference the lint job directly with:
"posttest": "yarn lint"

Run yarn lint --fix. This attempts to auto-fix any linting violations automatically. In the case an auto-fix isn’t available it should be fixed manually or ignored (see the eslint configuration doc for more information)
Do a search in the codebase for tslint and remove any unnecessary tslint disabling comments, like:

/* tslint:disable:object-literal-sort-keys */
If you are on a version of Node that is not supported by ESLint, you will also need to update your Node engine. ESLint supports Node 8, 10, and 12 so you should upgrade to the most recent Node version compatible with your CLI and also supported by ESLint (see ESLint's Installation and Usage instructions).
When will this take effect​
These changes have taken effect in oclif v1.15.1. When you generate a new CLI or plugin it will now contain configuration for ESLint instead of TSLint.oclif's Current Node SupportOctober 31, 2019 · 3 min readTo maintain a healthy project trajectory, oclif follows and supports Node Active LTS release, currently Node 10 & Node 12. This means ensuring that oclif continues to play nice with coming Active LTS Node versions and other packages in the ecosystem. Moving forward also means leaving older versions behind. Starting in 2020, Node will stop maintaining Node 8 and it is our intent at that time to also follow suit. Let’s take a look at a few ways we will be supporting these changes.
CI Environments​
CLIs created with the oclif cli going forward will be generated with a CircleCI configuration with Node 10 & 12 and an Appveyor configuration using Node 10. We have also added Node latest to CircleCi to be an early warning detection against coming Node changes (Node latest is managed by CircleCI).
We have already updated every oclif repo's CI configs to reflect this.
If your existing CLI uses either Appveyor or CircleCI you can update your config files also, like so:
.circleci/config.yml​
Your CircleCI config should contain a node-latest job, aliased as test. From this, there should be two extensions of this job for the Active LTS Node versions, Node 10 and Node 12.
  node-10:    <<: *node-latest    docker:      - image: node:10  node-12:    <<: *node-latest    docker:      - image: node:12
Notice that these declarations only change the Docker Node images used to run that job.
Additionally, the jobs listed within workflows must also be updated to reflect our changes in configuration:
    jobs:      - node-latest      - node-10      - node-12
appveyor.yml​
For appveyor we are currently only testing the oldest Active LTS Node version, Node 10. Update the nodejs_version proppert in your appveyor.yml file to reflect this.
environment:  nodejs_version: "10"
Deprecating Node 8 & Updating packge.json engines​
In Jan 2020, Node will end its Node 8 maintenance. We will follow suit by setting the package.json engine property in oclif packages to >=10 and bumping the package's major versions.
Depending on how you ship your CLI you may wish to also bump the engines version in your CLI's package.json. You can read more about the implications of the engines property configuration in the npm documentation.
Also consider distributing your CLI with its own Node version.
Packaged Node Version​
When using dev-cli to pack your CLI it will use the Node version as specified in your package.json under the oclif.update.node.version property. This value should reflect an Active LTS Node version (dev-cli does not currently enforce versions).
Supporting the future​
As a community we may discover bumps along the way as we upgrade. If you notice something related to oclif please feel free to open an issue or submit a pull request under the relevant oclif package within the org.
We look forward to using the latest from Node and the community and keeping oclif healthy along the way.oclifconf 2019: A RecapSeptember 16, 2019 · 4 min readIn May, Heroku and Salesforce Open Source organized oclifconf, a conference for developers & product managers building CLI tools on top of the open source oclif framework. The speakers came from various tech companies, such as Adobe, Netlify, and Apollo, who have already built amazing CLI experiences. The topics covered everything from the incredible capabilities oclif has unlocked, to the community-built plugins extending its functionality, and even what the behavior of an adaptive CLI tool might look like.
Below is a listing of all of the talks from the event, along with a short summary. Enjoy!
The future of oclif by Jeff Dickey​

In its relatively short lifetime, oclif has already inspired many developers and companies to adopt its framework as a means for implementing their own command-line tooling. In this talk, Jeff Dickey, an oclif founding team member, recaps the project's history and inspiration. He also looks towards the future and outlines some features and improvements that the tool could adapt. This isn't so much a definitive roadmap of where oclif is headed, but rather, a call to inspiration for developers eager to contribute! And if you are interested in contributing, check out the open issues in the oclif GitHub repo and come say "Hello!" on Spectrum Chat.
Open Source Citizenship by Josh Simmons​

When it comes to open source, it's more than just individuals now. More and more frequently, large corporations are contributing to projects by donating to contributors, sponsoring events, or upstreaming contributions. But keeping open source projects and communities healthy requires more than just money and brainpower. Josh Simmons surveyed multiple open source communities and relays his findings as to what help maintainers and contributors actually need in this talk.
Building an enterprise-grade CLI with oclif by Thomas Dvornik​

Security and performance are all about trust. While oclif is an extremely extensible framework for building CLI tooling, there are additional requirements to fulfill for enterprise businesses to adopt it that might not be necessary for individual developers. Thomas Dvornik outlines what he and his colleagues at Salesforce have implemented as plugins to oclif to satisfy these needs, including encrypted OAuth, plugin signing, lazy loading dependencies, synchronizing weekly releases and deprecations across dozens of repositories, and establishing cross-team coding and documentation standards.
How Adobe I/O built an extensible CLI with oclif by Jesse MacFadyen​

Perhaps oclif's most appealing feature is its support for plugins. In Cordova's case, they've created a sophisticated telemetry system that helps Adobe developers see which commands users are using--and reports on which ones are erroring out. By embedding a feedback system into the tool, users are even able to quickly send their suggestions to a form, without ever leaving the terminal. Jesse MacFadyen demonstrates how oclif's plugin system can work beyond simply executing commands.
Integrating oclif with GraphQL and Apollo by Evans Hauser​

For Evans Hauser and the team at Apollo, oclif is best thought of as "React for the CLI." As a client paired with a strongly-typed API contract to a server, it can deliver structured and consistent commands to retrieve external data. What better mechanism to use for this transfer than GraphQL, a framework which empowers the client to ask precisely for the data it needs, and nothing more?
Adaptive Intent-based CLI State Machines by Shawn Wang​

In designing oclif, Jeff Dickey wrote out 12 CLI factors to keep in mind. In this talk, Shawn Wang outlines a 13th: state. State is hard, because it depends on context, and context depends on understanding what a user intends to do, not what they are asking. Shawn is working towards enabling oclif to better understand the commands a user has entered, so that it can predict and interpret future commands that might be entered next. This would enable CLI tools to not just interpret a users' commands, but to also interpret their intent.\n\nIntroducing `oclif init` commandApril 10, 2024 · 2 min readThanks to the contribution of @joshcanhelp we released a new command for the oclif CLI called oclif init in version 4.8.0
The oclif init command allows you to initialize oclif in an existing project directory by adding the bare minimum requirements: a few pieces of configuration, bin scripts, and a couple of dependencies (@oclif/core and ts-node). This is slightly different from oclif generate, which will create an entirely new oclif project based on our templates.
oclif init will add the following:

bin scripts: bin/run.js, bin/run.cmd, bin/dev.js, and bin/dev.cmd
oclif section to package.json with bin, dirname, commands, and topicSeparator set (See Configuring Your CLI for more)
@oclif/core to dependencies in your package.json (if it's not already there)
ts-node to devDependencies in your package.json (if it's not already there)

Once you've initialized oclif, you can use the bin scripts to execute your CLI. You can also use the other oclif commands like oclif generate command and oclif generate hook to start adding new functionality.

❯ oclif init --helpInitialize a new oclif CLIUSAGE  $ oclif init [--bin <value>] [--module-type ESM|CommonJS] [--package-manager npm|yarn|pnpm] [--topic-separator    colons|spaces] [-d <value>] [-y]FLAGS  -d, --output-dir=<value>        Directory to initialize the CLI in.  -y, --yes                       Use defaults for all prompts. Individual flags will override defaults.      --bin=<value>               Supply answer for prompt: Command bin name the CLI will export      --module-type=<option>      Supply answer for prompt: Select a module type                                  <options: ESM|CommonJS>      --package-manager=<option>  Supply answer for prompt: Select a package manager                                  <options: npm|yarn|pnpm>      --topic-separator=<option>  Supply answer for prompt: Select a topic separator                                  <options: colons|spaces>DESCRIPTION  Initialize a new oclif CLI  This will add the necessary oclif bin files, add oclif config to package.json, and install @oclif/core and ts-node.EXAMPLES  Initialize a new CLI in the current directory    $ oclif init  Initialize a new CLI in a different directory    $ oclif init --output-dir "/path/to/existing/project"  Supply answers for specific prompts    $ oclif init --topic-separator colons --bin mycli
Hope you enjoy the new command! If you come across any issues or have any new ideas for this command, head over to the oclif/oclif repo and open a new issue.
All our best,
The oclif teamoclif Spring 2024 UpdateMarch 29, 2024 · 4 min readHello oclif developers! It's been a while since we last uploaded a blog - and a lot has happened.
We've been focusing on these high-level areas over the past couple of years:

Improving @oclif/core
ESM Support
Improving and revitalizing oclif.io
Re-engaging the oclif community

Improving @oclif/core​
Since we announced @oclif/core over three years ago, we've released two new major versions, each packed with lots of features that we're really excited about.
Here are some of these changes:

Full support for ESM and interoperability with CommonJS (more on this topic below).
Configurable command discovery strategies that give you more control over how commands are loaded at runtime. Check out the docs.
A new preparse hook that allows you to manipulate the provided arguments before they're parsed. Salesforce used this hook to implement a neat --flags-dir feature that translates local files into flags.
A new Performance class that you can use to track performance inside of @oclif/core and your own CLI or plugin. Check out the docs.
A new flag type, Flags.option, that lets you define a flag with a preset list of options. Typescript then uses the options to infer the flag's type.
Flags now have a relationship property that allows you to define more complex relationships between flags. Check out the flags docs for more information.
Flags now have a defaultHelp property that allows you to set the human readable default value in the command help. This property is useful when your flag's parse method returns a complex type, such as an object or a class. Check out the flags docs for more.
Commands now have a hiddenAliases property that allows you to define aliases that you want to hide from the user. The property is super helpful when you're trying to wean users off a deprecated command.
You can now use bun or tsx as dev runtimes (as opposed to node or ts-node).
A command's usage, args, and flags are now shown whenever a user forgets to provide a required arg or flag, or when they provided a non-existent flag.

If you need help migrating to the latest version, head over to core's README which has links to the migration guides. Feel free to open a new discussion if you need more hands-on help from us or the community.
ESM Support​
Version 3 of @oclif/core introduced full support for developing ESM plugins and CLIs. It also offered full support for interoperability between CommonJS and ESM plugins.
Put more simply, you can now migrate your CLI to ESM while keeping individual plugins in CommonJS (or vice versa). The upgrade path is now much simpler for you. You also don't need to worry about any community plugins that have migrated to ESM before you did (such as all the @oclif plugins) or are staunchly sticking with CommonJS for the foreseeable future.
Read more about this topic here.
Improving and Revitalizing oclif.io​
Another area of focus for us has been improving our documentation site, oclif.io.
While improving the quality and accuracy of the documentation was our priority, we also took the time to upgrade to the latest version of docusaurus. This new version gave our site a much-needed facelift, as well as cool new features such as dark mode and announcements.
If you have any feedback or are running into issues, we want to hear about it. Just create an issue in the oclif.io repo.
Re-engaging the oclif Community​
Lastly, our biggest priority at the moment is to re-engage the oclif community. We understand how frustrating it has been over the years to see your issues and pull requests go unacknowledged. We apologize for not prioritizing the community, and are earnestly trying to make sure that every issue and pull request gets the attention it deserves going forward.
We also opened up GitHub discussions for @oclif/core and the oclif CLI, where you can now post your questions or ideas. We hope you take advantage of them, we love hearing from you!
One last thing: we intend to publicly post our roadmap so you have more visibility into what we're working on. Stay tuned!
All our best,
The oclif teamAnnouncing oclif v2!January 12, 2022 · 5 min readHello and happy new year! It's our great pleasure to announce that we have released oclif v2, which uses the new @oclif/core library! 🎉
oclif v2 includes many changes that improve the experience of both creating and using an oclif CLI.
Going forward, we don't plan to make any updates to oclif v1 and its corresponding libraries, except for critical security fixes. See the compatibility matrix for a list of these libraries. In order to give developers time to migrate from v1 to v2, we're not completely dropping support yet. But at some point in the future we'll archive the v1 repositories and deprecate their versions on npm.
What’s changing?​
Repository Changes​
All repositories under the oclif org now use main as their primary branch and oclif-v1 as the legacy branch. The main  branch corresponds to oclif v2 and the oclif-v1 branch to oclif v1. If you find any repos that don’t have a main branch, you can safely assume that they're not used in oclif v2 and will be deprecated in the future.
Consolidating Tools & Libraries​
The oclif-dev CLI has now been incorporated into oclif. You now no longer need to install a separate package to manage your entire CLI’s lifecycle.
The following libraries have been consolidated under @oclif/core and will be deprecated at some point in the future. Read the migration guide to learn how to update your CLI or plugin to use the new core library.

@oclif/command
@oclif/config
@oclif/error
@oclif/help
@oclif/parser

No more single vs multi command CLIs​
There's only one "type" of oclif v2 CLI, but it can have as few or as many commands as a developer wants. As a result, there’s only one command to generate CLIs, oclif generate, as opposed to the old oclif single and oclif multi commands.
Node > 12​
To ensure oclif CLIs are as secure as possible, all v2 libraries and plugins support only Node 12 or higher as of now. Going forward, they'll support only Node Maintenance or higher, as defined by Node's release schedule here: https://nodejs.org/en/about/releases/.
What’s new?​
New example CLI​
oclif-hello-world is our new example repo. This is also the repo that's used as a template when running oclif generate to create a new CLI. This repo will always be able to be referenced as an example of what an oclif v2 CLI should look like.
Spaced commands​
oclif CLIs can now use spaces, instead of colons, to separate topics and subcommands. To enable this feature, simply add “topicSeparator": " " to the oclif config in your package.json. See an example in our example repo.
// Old commands that use :$ mycli do:something
// New spaced commands$ mycli do something

Note: Spaced commands are backwards compatible. So if you enable spaced commands for your CLI, users will still be able to use : as a separator. This ensures that any existing scripts don't break.

New Help Output​
We’ve revamped the way command help is outputted to the terminal, making it both easier to implement and easier to read. See the difference between the old help output on the left and the new help output on the right in the screenshots below.
oclif v1oclif v2
Notice that there are new sections for flags and global flags, examples are displayed with better spacing, and there is a section at the bottom called Configuration Variables. This Configuration Variables section is not part of the new help by default. But we've added support for custom help sections, which is what the sf CLI uses to create the new section.
Async Command Parsing​
We’ve also improved the performance of new CLIs by rewriting how commands are parsed on initialization. The new parser is asynchronous, which makes CLIs with a lot of commands or installed  plugins much faster.
What’s coming next?​
Part of our charter for the release of oclif v2 includes improving our engagement with the oclif community. We know that over the past couple of years we’ve reduced our involvement, and a lot of issues and PRs have languished in limbo. Hopefully you’ve already seen increased activity and responses from oclif maintainers recently, but if you haven’t, please don’t hesitate to ping us by tagging @admins in oclif repos.
We also want to start interviewing members of the oclif community to acquire feedback and prioritize the features and fixes you deem most important!
Best,
The oclif team

Reference material​
Migration Guide​
This guide explains how to upgrade a CLI or plugin from the old oclif v1 libraries to the new @oclif/core library that oclif v2 uses.
https://github.com/oclif/core/blob/main/MIGRATION.md
Compatibility Matrix​
The following matrix shows how the v1 libraries and plugins relate to the new v2 ones. Use this matrix as a guide to know what to drop and which versions to switch when upgrading your plugins and CLIs to v2.
oclif "v1"oclif "v2"Utility CLIsoclif@<2@oclif/dev-cli@<2oclif@>=2Main packages@oclif/command@oclif/config@oclif/errors@oclif/parser@oclif/plugin-help@oclif/core@>=1Node LTSNode v8-14Node v12+ (at time of writing)TypeScripttypescript@<4typescript@>=4Main plugins@oclif/plugin-autocomplete@<1@oclif/plugin-commands@<2@oclif/plugin-help@<4@oclif/plugin-not-found@<2@oclif/plugin-plugins@<2@oclif/plugin-update@<2plugin-warn-if-update-available@<2plugin-which@<2@oclif/plugin-autocomplete@>=1@oclif/plugin-commands@>=2@oclif/plugin-help@>=4@oclif/plugin-not-found@>=2@oclif/plugin-plugins@>=2@oclif/plugin-update@>=2@oclif/plugin-warn-if-update-available@>=2@oclif/plugin-which@>=2Introducing @oclif/coreMarch 1, 2021 · 3 min readGreetings!
We hope this blog post finds you well.
Introducing...​
We are excited to announce the next iteration of the oclif project today: @oclif/core.
We have learned a lot in the last three years of developing oclif, developing on oclif and supporting millions of command runs a day via Heroku and Salesforce CLIs.
@oclif/core ("Core") simplifies the oclif development experience and introduces highly requested new features.
Core combines the essential oclif packages into one "core" package, aptly named @oclif/core.
Core also introduces:

A default command option
Colon or space command syntax
Async command parsing
Command piping to arguments

With the introduction of default command functionality, Core simplifies the oclif project and removes the notion of single or multi command CLIs. Core CLIs can have 1 or many commands.
Along with Core, we moved the oclif-dev CLI into the oclif CLI creating a single "utility" CLI. This CLI also introduces a new AWS S3 compatible publishing scheme.
What to expect in the near future​
Core is in pre-release beta and being actively developed for new internal Salesforce CLIs.
Much documentation needs to be written in the coming months including migration paths. Migration onto Core should be as painless as possible with many exports remaining entirely unchanged. Look for forthcoming blog posts and documentation on oclif.io.
Early this summer, tentively June 1, we will release Core v1. Core's release will coincide with major bumps to many other oclif plugin packages. See the compatibility matrix below.
At Core's v1 release, the current "main" oclif packages (namely: command, config, errors & parser) will go into maintenance mode until Jan 2022. They will receive only bug and security fixes and they remain compatible with current versions of the oclif and oclif-dev CLIs. Afterwhich, they will be archived.
Companioning Core, the next major release of the oclif CLI (literally oclif@2) will generate Core CLIs.
Going forward​
We are excited to release Core! We invite you to poke around the Core repo. It may appear to be a big change but Core keeps what you already enjoy about oclif while reducing development complexity, project dependencies, package coupling and bundle size and introduces many requested features previously too prickly to weave into the current oclif architecture.
Best,
The oclif team
Reference: Compatibility matrix​
oclif "v1"oclif "Core"Utility CLIsoclif@<2@oclif/dev-cli@<2oclif@>=2Main packages@oclif/core@<2@oclif/config@<2@oclif/errors@<2@oclif/parser@<4@oclif/plugin-help@<4@oclif/core@>=1Node LTSNode v8-14Node v12+TypeScripttypescript@<4typescript@>=4Main plugins@oclif/plugin-autocomplete@<1@oclif/plugin-commands@<2@oclif/plugin-help@<4@oclif/plugin-not-found@<2@oclif/plugin-plugins@<2@oclif/plugin-update@<2plugin-warn-if-update-available@<2plugin-which@<2@oclif/plugin-autocomplete@>=2@oclif/plugin-commands@>=2@oclif/plugin-help@>=4@oclif/plugin-not-found@>=2@oclif/plugin-plugins@>=2@oclif/plugin-update@>=2@oclif/plugin-warn-if-update-available@>=2@oclif/plugin-which@>=2oclif Summer 2020 UpdateAugust 26, 2020 · 2 min readHello oclif developers! We hope you are all doing well.
Earlier this year, we started our planning for oclifconf v2 and, like all conference, had to change course. We opted not to hold a virtual conference, however, we wanted to take some time to highlight a few oclif features shipped this year.
Feature: Help templating​
One of the most requested features, help templating enables oclif developers to customize the help output for their CLI.
Read the announcement.
Feature: Custom error delegation​
This feature both improved how oclif throws and handles errors and allows oclif developers to overwrite or interject in oclif’s error handling.
Read the announcement.
Feature: postrun hooks​
We have added a new lifecycle event postrun. Your CLI can now run a hook after a command has ran.
See our hook documentation.
Feature: Root index command​
Previously, oclif would display CLI help if only the binary name with no command ID was invoked, oclif now supports a "root index" command. If present, a command defined at src/commands/index.ts will be run if no command ID is found.
1 million weekly downloads​
While exact oclif usage metrics are hard to pin down, we use npm download statistics of oclif packages as a rough approximation. Earlier this year, oclif's command package hit 1 million weekly downloads for the first time!
This year has been presented its challenges on everyone. We want to thank you, oclif developers, whom have taken the time to use and improve the oclif project. We look forward to seeing you all - in person - in the future!
All our best,
The oclif teamPretty Printable ErrorsJuly 1, 2020 · One min readOften CLIs are used as handy tools and when things go wrong it’s useful to have additional context. In oclif we have added a couple of additional properties that can show extra context to the users when an error is displayed. The code, ref and suggestions will now be displayed if they are included. This will work with an existing oclif CLI by adding the latest @oclif/errors and @oclif/core to the CLI's package.json dependencies.
For example, using this.error with the additional properties:
class TestError extends Command {  async run() {    this.error("An error has occurred!", {      code: "OCLIF_ERR",      ref: "https://oclif.io/docs/commands#thiserrormessage-string--error-options-code-string-exit-number",      suggestions: ["Use these extra properties to provide additional context"],    })  }}
would result with the following output:
›   Error: An error has occurred!›   Code: OCLIF_ERR›   Try this: Use these extra properties to provide additional context›   Reference: https://oclif.io/docs/commands#thiserrormessage-string--error-options-code-string-exit-number
If these properties are not provided then nothing changes and the CLI will continue to display the single error message output as it did before. Additionally, as part of this exercise we’ve added documentation around Error Handling in oclif which should come in handy if the need arises to extend oclif’s default handling of errors.Customizing Help in oclifMay 5, 2020 · 2 min readOut of the box oclif provides a great help experience for CLIs.
But what if, as an oclif developer, you want to customize some or all of the output?
You can now customize your CLI's help output by implementing the HelpBase abstract class.
Getting started with custom help​
If you have not done so yet, update @oclif/core.
$ yarn add --latest @oclif/core
To get started, first define the filepath to your help class in oclif's config in package.json. This is a relative path to the help class, without a file extension.
For this example, the help class will be created in a file at "[project root]/src/help.ts".
{  // ...  "oclif": {    "helpClass": "./lib/help"    // ...  }  // ...}
From here there are two paths, implement the HelpBase abstract class yourself or overwrite the parts of the default Help class you want to customize (ex: how command usage is displayed). We recommend the latter approach but cover both in the new Help Classes docs.
Separating TOPICS & COMMANDS in the new default Help class​
Previously, topics and child commands were listed in help output under a single list heading called "COMMANDS". But we found this can be slightly confusing. Some topics are commands also (a.k.a. topic-commands) while others are simply organizational namespacing (and when ran just show their help).
The new default Help class splits the list of children into distinct lists of "TOPICS" and "COMMANDS", with the possibility of an item appearing in both if it a topic-command. This makes it clearer what is expected to be ran - "COMMANDS" - and what is providing structure - "TOPICS" - when looking at the help output.
VERSION  plugin-help-example/0.0.0 darwin-x64 node-v12.12.0USAGE  $ plugin-help-example [COMMAND]TOPICS  topic  this is a topic and has child topics or commandsCOMMANDS  hello  describe the command here  help   display help for plugin-help-example
We look forward to seeing what custom help features you implement in your oclif CLIs with this new feature!oclif TSLint to ESLint MigrationDecember 5, 2019 · 3 min readBack in February of this year, plans were announced to deprecate TSLint in favor of ESLint. TSLint's goal has become to work toward a “unified developer experience” by supporting ESLint development going forward.
What has changed in oclif​
To keep inline with the community, oclif has transitioned to ESLint for all our core libraries as well as all our official plugins.
Starting in v1.15.x, oclif will now optionally generate projects with ESLint for both TypeScript and JavaScript CLI’s.
ESLint does require Node to be on stable LTS version, at the time of writing, Node 8.10.x, Node 10.13.x & Node 12.x.x.
How does this affect you​
Existing CLI’s are unchanged, but any newly generated CLI's will only give the option of using ESLint. If you are running tslint in your CLI, we recommend you switch to ESLint as well.
In migrating our projects we took the following steps (for an example of these changes see this pull request).


Install eslint
$ yarn add eslint eslint-config-oclif eslint-config-oclif-typescript --dev


Add eslint related files


$ echo '{  "extends": [    "oclif",    "oclif-typescript"  ],  "rules": {  }}' > .eslintrc


Remove tslint and related packages
$ yarn remove @oclif/tslint tslint


Remove tslint related configuration files
$ rm tslint.json


Change lint script in our package.json from something like:
"lint": "tsc -p test --noEmit && tslint -p test -t stylish"
to
"lint": "eslint . --ext .ts --config .eslintrc"


To preserve the test compile (tsc -p test --noEmit) we also made the following updates to our scripts:
"pretest": "tsc -p test --noEmit"
In some cases we had our posttest duplicating the same steps as our lint script so it’s cleaner to have it reference the lint job directly with:
"posttest": "yarn lint"

Run yarn lint --fix. This attempts to auto-fix any linting violations automatically. In the case an auto-fix isn’t available it should be fixed manually or ignored (see the eslint configuration doc for more information)
Do a search in the codebase for tslint and remove any unnecessary tslint disabling comments, like:

/* tslint:disable:object-literal-sort-keys */
If you are on a version of Node that is not supported by ESLint, you will also need to update your Node engine. ESLint supports Node 8, 10, and 12 so you should upgrade to the most recent Node version compatible with your CLI and also supported by ESLint (see ESLint's Installation and Usage instructions).
When will this take effect​
These changes have taken effect in oclif v1.15.1. When you generate a new CLI or plugin it will now contain configuration for ESLint instead of TSLint.oclif's Current Node SupportOctober 31, 2019 · 3 min readTo maintain a healthy project trajectory, oclif follows and supports Node Active LTS release, currently Node 10 & Node 12. This means ensuring that oclif continues to play nice with coming Active LTS Node versions and other packages in the ecosystem. Moving forward also means leaving older versions behind. Starting in 2020, Node will stop maintaining Node 8 and it is our intent at that time to also follow suit. Let’s take a look at a few ways we will be supporting these changes.
CI Environments​
CLIs created with the oclif cli going forward will be generated with a CircleCI configuration with Node 10 & 12 and an Appveyor configuration using Node 10. We have also added Node latest to CircleCi to be an early warning detection against coming Node changes (Node latest is managed by CircleCI).
We have already updated every oclif repo's CI configs to reflect this.
If your existing CLI uses either Appveyor or CircleCI you can update your config files also, like so:
.circleci/config.yml​
Your CircleCI config should contain a node-latest job, aliased as test. From this, there should be two extensions of this job for the Active LTS Node versions, Node 10 and Node 12.
  node-10:    <<: *node-latest    docker:      - image: node:10  node-12:    <<: *node-latest    docker:      - image: node:12
Notice that these declarations only change the Docker Node images used to run that job.
Additionally, the jobs listed within workflows must also be updated to reflect our changes in configuration:
    jobs:      - node-latest      - node-10      - node-12
appveyor.yml​
For appveyor we are currently only testing the oldest Active LTS Node version, Node 10. Update the nodejs_version proppert in your appveyor.yml file to reflect this.
environment:  nodejs_version: "10"
Deprecating Node 8 & Updating packge.json engines​
In Jan 2020, Node will end its Node 8 maintenance. We will follow suit by setting the package.json engine property in oclif packages to >=10 and bumping the package's major versions.
Depending on how you ship your CLI you may wish to also bump the engines version in your CLI's package.json. You can read more about the implications of the engines property configuration in the npm documentation.
Also consider distributing your CLI with its own Node version.
Packaged Node Version​
When using dev-cli to pack your CLI it will use the Node version as specified in your package.json under the oclif.update.node.version property. This value should reflect an Active LTS Node version (dev-cli does not currently enforce versions).
Supporting the future​
As a community we may discover bumps along the way as we upgrade. If you notice something related to oclif please feel free to open an issue or submit a pull request under the relevant oclif package within the org.
We look forward to using the latest from Node and the community and keeping oclif healthy along the way.oclifconf 2019: A RecapSeptember 16, 2019 · 4 min readIn May, Heroku and Salesforce Open Source organized oclifconf, a conference for developers & product managers building CLI tools on top of the open source oclif framework. The speakers came from various tech companies, such as Adobe, Netlify, and Apollo, who have already built amazing CLI experiences. The topics covered everything from the incredible capabilities oclif has unlocked, to the community-built plugins extending its functionality, and even what the behavior of an adaptive CLI tool might look like.
Below is a listing of all of the talks from the event, along with a short summary. Enjoy!
The future of oclif by Jeff Dickey​

In its relatively short lifetime, oclif has already inspired many developers and companies to adopt its framework as a means for implementing their own command-line tooling. In this talk, Jeff Dickey, an oclif founding team member, recaps the project's history and inspiration. He also looks towards the future and outlines some features and improvements that the tool could adapt. This isn't so much a definitive roadmap of where oclif is headed, but rather, a call to inspiration for developers eager to contribute! And if you are interested in contributing, check out the open issues in the oclif GitHub repo and come say "Hello!" on Spectrum Chat.
Open Source Citizenship by Josh Simmons​

When it comes to open source, it's more than just individuals now. More and more frequently, large corporations are contributing to projects by donating to contributors, sponsoring events, or upstreaming contributions. But keeping open source projects and communities healthy requires more than just money and brainpower. Josh Simmons surveyed multiple open source communities and relays his findings as to what help maintainers and contributors actually need in this talk.
Building an enterprise-grade CLI with oclif by Thomas Dvornik​

Security and performance are all about trust. While oclif is an extremely extensible framework for building CLI tooling, there are additional requirements to fulfill for enterprise businesses to adopt it that might not be necessary for individual developers. Thomas Dvornik outlines what he and his colleagues at Salesforce have implemented as plugins to oclif to satisfy these needs, including encrypted OAuth, plugin signing, lazy loading dependencies, synchronizing weekly releases and deprecations across dozens of repositories, and establishing cross-team coding and documentation standards.
How Adobe I/O built an extensible CLI with oclif by Jesse MacFadyen​

Perhaps oclif's most appealing feature is its support for plugins. In Cordova's case, they've created a sophisticated telemetry system that helps Adobe developers see which commands users are using--and reports on which ones are erroring out. By embedding a feedback system into the tool, users are even able to quickly send their suggestions to a form, without ever leaving the terminal. Jesse MacFadyen demonstrates how oclif's plugin system can work beyond simply executing commands.
Integrating oclif with GraphQL and Apollo by Evans Hauser​

For Evans Hauser and the team at Apollo, oclif is best thought of as "React for the CLI." As a client paired with a strongly-typed API contract to a server, it can deliver structured and consistent commands to retrieve external data. What better mechanism to use for this transfer than GraphQL, a framework which empowers the client to ask precisely for the data it needs, and nothing more?
Adaptive Intent-based CLI State Machines by Shawn Wang​

In designing oclif, Jeff Dickey wrote out 12 CLI factors to keep in mind. In this talk, Shawn Wang outlines a 13th: state. State is hard, because it depends on context, and context depends on understanding what a user intends to do, not what they are asking. Shawn is working towards enabling oclif to better understand the commands a user has entered, so that it can predict and interpret future commands that might be entered next. This would enable CLI tools to not just interpret a users' commands, but to also interpret their intent.Older Entries\n\n\n\nIntroducing `oclif init` commandApril 10, 2024 · 2 min readThanks to the contribution of @joshcanhelp we released a new command for the oclif CLI called oclif init in version 4.8.0
The oclif init command allows you to initialize oclif in an existing project directory by adding the bare minimum requirements: a few pieces of configuration, bin scripts, and a couple of dependencies (@oclif/core and ts-node). This is slightly different from oclif generate, which will create an entirely new oclif project based on our templates.
oclif init will add the following:

bin scripts: bin/run.js, bin/run.cmd, bin/dev.js, and bin/dev.cmd
oclif section to package.json with bin, dirname, commands, and topicSeparator set (See Configuring Your CLI for more)
@oclif/core to dependencies in your package.json (if it's not already there)
ts-node to devDependencies in your package.json (if it's not already there)

Once you've initialized oclif, you can use the bin scripts to execute your CLI. You can also use the other oclif commands like oclif generate command and oclif generate hook to start adding new functionality.

❯ oclif init --helpInitialize a new oclif CLIUSAGE  $ oclif init [--bin <value>] [--module-type ESM|CommonJS] [--package-manager npm|yarn|pnpm] [--topic-separator    colons|spaces] [-d <value>] [-y]FLAGS  -d, --output-dir=<value>        Directory to initialize the CLI in.  -y, --yes                       Use defaults for all prompts. Individual flags will override defaults.      --bin=<value>               Supply answer for prompt: Command bin name the CLI will export      --module-type=<option>      Supply answer for prompt: Select a module type                                  <options: ESM|CommonJS>      --package-manager=<option>  Supply answer for prompt: Select a package manager                                  <options: npm|yarn|pnpm>      --topic-separator=<option>  Supply answer for prompt: Select a topic separator                                  <options: colons|spaces>DESCRIPTION  Initialize a new oclif CLI  This will add the necessary oclif bin files, add oclif config to package.json, and install @oclif/core and ts-node.EXAMPLES  Initialize a new CLI in the current directory    $ oclif init  Initialize a new CLI in a different directory    $ oclif init --output-dir "/path/to/existing/project"  Supply answers for specific prompts    $ oclif init --topic-separator colons --bin mycli
Hope you enjoy the new command! If you come across any issues or have any new ideas for this command, head over to the oclif/oclif repo and open a new issue.
All our best,
The oclif teamoclif Spring 2024 UpdateMarch 29, 2024 · 4 min readHello oclif developers! It's been a while since we last uploaded a blog - and a lot has happened.
We've been focusing on these high-level areas over the past couple of years:

Improving @oclif/core
ESM Support
Improving and revitalizing oclif.io
Re-engaging the oclif community

Improving @oclif/core​
Since we announced @oclif/core over three years ago, we've released two new major versions, each packed with lots of features that we're really excited about.
Here are some of these changes:

Full support for ESM and interoperability with CommonJS (more on this topic below).
Configurable command discovery strategies that give you more control over how commands are loaded at runtime. Check out the docs.
A new preparse hook that allows you to manipulate the provided arguments before they're parsed. Salesforce used this hook to implement a neat --flags-dir feature that translates local files into flags.
A new Performance class that you can use to track performance inside of @oclif/core and your own CLI or plugin. Check out the docs.
A new flag type, Flags.option, that lets you define a flag with a preset list of options. Typescript then uses the options to infer the flag's type.
Flags now have a relationship property that allows you to define more complex relationships between flags. Check out the flags docs for more information.
Flags now have a defaultHelp property that allows you to set the human readable default value in the command help. This property is useful when your flag's parse method returns a complex type, such as an object or a class. Check out the flags docs for more.
Commands now have a hiddenAliases property that allows you to define aliases that you want to hide from the user. The property is super helpful when you're trying to wean users off a deprecated command.
You can now use bun or tsx as dev runtimes (as opposed to node or ts-node).
A command's usage, args, and flags are now shown whenever a user forgets to provide a required arg or flag, or when they provided a non-existent flag.

If you need help migrating to the latest version, head over to core's README which has links to the migration guides. Feel free to open a new discussion if you need more hands-on help from us or the community.
ESM Support​
Version 3 of @oclif/core introduced full support for developing ESM plugins and CLIs. It also offered full support for interoperability between CommonJS and ESM plugins.
Put more simply, you can now migrate your CLI to ESM while keeping individual plugins in CommonJS (or vice versa). The upgrade path is now much simpler for you. You also don't need to worry about any community plugins that have migrated to ESM before you did (such as all the @oclif plugins) or are staunchly sticking with CommonJS for the foreseeable future.
Read more about this topic here.
Improving and Revitalizing oclif.io​
Another area of focus for us has been improving our documentation site, oclif.io.
While improving the quality and accuracy of the documentation was our priority, we also took the time to upgrade to the latest version of docusaurus. This new version gave our site a much-needed facelift, as well as cool new features such as dark mode and announcements.
If you have any feedback or are running into issues, we want to hear about it. Just create an issue in the oclif.io repo.
Re-engaging the oclif Community​
Lastly, our biggest priority at the moment is to re-engage the oclif community. We understand how frustrating it has been over the years to see your issues and pull requests go unacknowledged. We apologize for not prioritizing the community, and are earnestly trying to make sure that every issue and pull request gets the attention it deserves going forward.
We also opened up GitHub discussions for @oclif/core and the oclif CLI, where you can now post your questions or ideas. We hope you take advantage of them, we love hearing from you!
One last thing: we intend to publicly post our roadmap so you have more visibility into what we're working on. Stay tuned!
All our best,
The oclif teamAnnouncing oclif v2!January 12, 2022 · 5 min readHello and happy new year! It's our great pleasure to announce that we have released oclif v2, which uses the new @oclif/core library! 🎉
oclif v2 includes many changes that improve the experience of both creating and using an oclif CLI.
Going forward, we don't plan to make any updates to oclif v1 and its corresponding libraries, except for critical security fixes. See the compatibility matrix for a list of these libraries. In order to give developers time to migrate from v1 to v2, we're not completely dropping support yet. But at some point in the future we'll archive the v1 repositories and deprecate their versions on npm.
What’s changing?​
Repository Changes​
All repositories under the oclif org now use main as their primary branch and oclif-v1 as the legacy branch. The main  branch corresponds to oclif v2 and the oclif-v1 branch to oclif v1. If you find any repos that don’t have a main branch, you can safely assume that they're not used in oclif v2 and will be deprecated in the future.
Consolidating Tools & Libraries​
The oclif-dev CLI has now been incorporated into oclif. You now no longer need to install a separate package to manage your entire CLI’s lifecycle.
The following libraries have been consolidated under @oclif/core and will be deprecated at some point in the future. Read the migration guide to learn how to update your CLI or plugin to use the new core library.

@oclif/command
@oclif/config
@oclif/error
@oclif/help
@oclif/parser

No more single vs multi command CLIs​
There's only one "type" of oclif v2 CLI, but it can have as few or as many commands as a developer wants. As a result, there’s only one command to generate CLIs, oclif generate, as opposed to the old oclif single and oclif multi commands.
Node > 12​
To ensure oclif CLIs are as secure as possible, all v2 libraries and plugins support only Node 12 or higher as of now. Going forward, they'll support only Node Maintenance or higher, as defined by Node's release schedule here: https://nodejs.org/en/about/releases/.
What’s new?​
New example CLI​
oclif-hello-world is our new example repo. This is also the repo that's used as a template when running oclif generate to create a new CLI. This repo will always be able to be referenced as an example of what an oclif v2 CLI should look like.
Spaced commands​
oclif CLIs can now use spaces, instead of colons, to separate topics and subcommands. To enable this feature, simply add “topicSeparator": " " to the oclif config in your package.json. See an example in our example repo.
// Old commands that use :$ mycli do:something
// New spaced commands$ mycli do something

Note: Spaced commands are backwards compatible. So if you enable spaced commands for your CLI, users will still be able to use : as a separator. This ensures that any existing scripts don't break.

New Help Output​
We’ve revamped the way command help is outputted to the terminal, making it both easier to implement and easier to read. See the difference between the old help output on the left and the new help output on the right in the screenshots below.
oclif v1oclif v2
Notice that there are new sections for flags and global flags, examples are displayed with better spacing, and there is a section at the bottom called Configuration Variables. This Configuration Variables section is not part of the new help by default. But we've added support for custom help sections, which is what the sf CLI uses to create the new section.
Async Command Parsing​
We’ve also improved the performance of new CLIs by rewriting how commands are parsed on initialization. The new parser is asynchronous, which makes CLIs with a lot of commands or installed  plugins much faster.
What’s coming next?​
Part of our charter for the release of oclif v2 includes improving our engagement with the oclif community. We know that over the past couple of years we’ve reduced our involvement, and a lot of issues and PRs have languished in limbo. Hopefully you’ve already seen increased activity and responses from oclif maintainers recently, but if you haven’t, please don’t hesitate to ping us by tagging @admins in oclif repos.
We also want to start interviewing members of the oclif community to acquire feedback and prioritize the features and fixes you deem most important!
Best,
The oclif team

Reference material​
Migration Guide​
This guide explains how to upgrade a CLI or plugin from the old oclif v1 libraries to the new @oclif/core library that oclif v2 uses.
https://github.com/oclif/core/blob/main/MIGRATION.md
Compatibility Matrix​
The following matrix shows how the v1 libraries and plugins relate to the new v2 ones. Use this matrix as a guide to know what to drop and which versions to switch when upgrading your plugins and CLIs to v2.
oclif "v1"oclif "v2"Utility CLIsoclif@<2@oclif/dev-cli@<2oclif@>=2Main packages@oclif/command@oclif/config@oclif/errors@oclif/parser@oclif/plugin-help@oclif/core@>=1Node LTSNode v8-14Node v12+ (at time of writing)TypeScripttypescript@<4typescript@>=4Main plugins@oclif/plugin-autocomplete@<1@oclif/plugin-commands@<2@oclif/plugin-help@<4@oclif/plugin-not-found@<2@oclif/plugin-plugins@<2@oclif/plugin-update@<2plugin-warn-if-update-available@<2plugin-which@<2@oclif/plugin-autocomplete@>=1@oclif/plugin-commands@>=2@oclif/plugin-help@>=4@oclif/plugin-not-found@>=2@oclif/plugin-plugins@>=2@oclif/plugin-update@>=2@oclif/plugin-warn-if-update-available@>=2@oclif/plugin-which@>=2Introducing @oclif/coreMarch 1, 2021 · 3 min readGreetings!
We hope this blog post finds you well.
Introducing...​
We are excited to announce the next iteration of the oclif project today: @oclif/core.
We have learned a lot in the last three years of developing oclif, developing on oclif and supporting millions of command runs a day via Heroku and Salesforce CLIs.
@oclif/core ("Core") simplifies the oclif development experience and introduces highly requested new features.
Core combines the essential oclif packages into one "core" package, aptly named @oclif/core.
Core also introduces:

A default command option
Colon or space command syntax
Async command parsing
Command piping to arguments

With the introduction of default command functionality, Core simplifies the oclif project and removes the notion of single or multi command CLIs. Core CLIs can have 1 or many commands.
Along with Core, we moved the oclif-dev CLI into the oclif CLI creating a single "utility" CLI. This CLI also introduces a new AWS S3 compatible publishing scheme.
What to expect in the near future​
Core is in pre-release beta and being actively developed for new internal Salesforce CLIs.
Much documentation needs to be written in the coming months including migration paths. Migration onto Core should be as painless as possible with many exports remaining entirely unchanged. Look for forthcoming blog posts and documentation on oclif.io.
Early this summer, tentively June 1, we will release Core v1. Core's release will coincide with major bumps to many other oclif plugin packages. See the compatibility matrix below.
At Core's v1 release, the current "main" oclif packages (namely: command, config, errors & parser) will go into maintenance mode until Jan 2022. They will receive only bug and security fixes and they remain compatible with current versions of the oclif and oclif-dev CLIs. Afterwhich, they will be archived.
Companioning Core, the next major release of the oclif CLI (literally oclif@2) will generate Core CLIs.
Going forward​
We are excited to release Core! We invite you to poke around the Core repo. It may appear to be a big change but Core keeps what you already enjoy about oclif while reducing development complexity, project dependencies, package coupling and bundle size and introduces many requested features previously too prickly to weave into the current oclif architecture.
Best,
The oclif team
Reference: Compatibility matrix​
oclif "v1"oclif "Core"Utility CLIsoclif@<2@oclif/dev-cli@<2oclif@>=2Main packages@oclif/core@<2@oclif/config@<2@oclif/errors@<2@oclif/parser@<4@oclif/plugin-help@<4@oclif/core@>=1Node LTSNode v8-14Node v12+TypeScripttypescript@<4typescript@>=4Main plugins@oclif/plugin-autocomplete@<1@oclif/plugin-commands@<2@oclif/plugin-help@<4@oclif/plugin-not-found@<2@oclif/plugin-plugins@<2@oclif/plugin-update@<2plugin-warn-if-update-available@<2plugin-which@<2@oclif/plugin-autocomplete@>=2@oclif/plugin-commands@>=2@oclif/plugin-help@>=4@oclif/plugin-not-found@>=2@oclif/plugin-plugins@>=2@oclif/plugin-update@>=2@oclif/plugin-warn-if-update-available@>=2@oclif/plugin-which@>=2oclif Summer 2020 UpdateAugust 26, 2020 · 2 min readHello oclif developers! We hope you are all doing well.
Earlier this year, we started our planning for oclifconf v2 and, like all conference, had to change course. We opted not to hold a virtual conference, however, we wanted to take some time to highlight a few oclif features shipped this year.
Feature: Help templating​
One of the most requested features, help templating enables oclif developers to customize the help output for their CLI.
Read the announcement.
Feature: Custom error delegation​
This feature both improved how oclif throws and handles errors and allows oclif developers to overwrite or interject in oclif’s error handling.
Read the announcement.
Feature: postrun hooks​
We have added a new lifecycle event postrun. Your CLI can now run a hook after a command has ran.
See our hook documentation.
Feature: Root index command​
Previously, oclif would display CLI help if only the binary name with no command ID was invoked, oclif now supports a "root index" command. If present, a command defined at src/commands/index.ts will be run if no command ID is found.
1 million weekly downloads​
While exact oclif usage metrics are hard to pin down, we use npm download statistics of oclif packages as a rough approximation. Earlier this year, oclif's command package hit 1 million weekly downloads for the first time!
This year has been presented its challenges on everyone. We want to thank you, oclif developers, whom have taken the time to use and improve the oclif project. We look forward to seeing you all - in person - in the future!
All our best,
The oclif teamPretty Printable ErrorsJuly 1, 2020 · One min readOften CLIs are used as handy tools and when things go wrong it’s useful to have additional context. In oclif we have added a couple of additional properties that can show extra context to the users when an error is displayed. The code, ref and suggestions will now be displayed if they are included. This will work with an existing oclif CLI by adding the latest @oclif/errors and @oclif/core to the CLI's package.json dependencies.
For example, using this.error with the additional properties:
class TestError extends Command {  async run() {    this.error("An error has occurred!", {      code: "OCLIF_ERR",      ref: "https://oclif.io/docs/commands#thiserrormessage-string--error-options-code-string-exit-number",      suggestions: ["Use these extra properties to provide additional context"],    })  }}
would result with the following output:
›   Error: An error has occurred!›   Code: OCLIF_ERR›   Try this: Use these extra properties to provide additional context›   Reference: https://oclif.io/docs/commands#thiserrormessage-string--error-options-code-string-exit-number
If these properties are not provided then nothing changes and the CLI will continue to display the single error message output as it did before. Additionally, as part of this exercise we’ve added documentation around Error Handling in oclif which should come in handy if the need arises to extend oclif’s default handling of errors.Customizing Help in oclifMay 5, 2020 · 2 min readOut of the box oclif provides a great help experience for CLIs.
But what if, as an oclif developer, you want to customize some or all of the output?
You can now customize your CLI's help output by implementing the HelpBase abstract class.
Getting started with custom help​
If you have not done so yet, update @oclif/core.
$ yarn add --latest @oclif/core
To get started, first define the filepath to your help class in oclif's config in package.json. This is a relative path to the help class, without a file extension.
For this example, the help class will be created in a file at "[project root]/src/help.ts".
{  // ...  "oclif": {    "helpClass": "./lib/help"    // ...  }  // ...}
From here there are two paths, implement the HelpBase abstract class yourself or overwrite the parts of the default Help class you want to customize (ex: how command usage is displayed). We recommend the latter approach but cover both in the new Help Classes docs.
Separating TOPICS & COMMANDS in the new default Help class​
Previously, topics and child commands were listed in help output under a single list heading called "COMMANDS". But we found this can be slightly confusing. Some topics are commands also (a.k.a. topic-commands) while others are simply organizational namespacing (and when ran just show their help).
The new default Help class splits the list of children into distinct lists of "TOPICS" and "COMMANDS", with the possibility of an item appearing in both if it a topic-command. This makes it clearer what is expected to be ran - "COMMANDS" - and what is providing structure - "TOPICS" - when looking at the help output.
VERSION  plugin-help-example/0.0.0 darwin-x64 node-v12.12.0USAGE  $ plugin-help-example [COMMAND]TOPICS  topic  this is a topic and has child topics or commandsCOMMANDS  hello  describe the command here  help   display help for plugin-help-example
We look forward to seeing what custom help features you implement in your oclif CLIs with this new feature!oclif TSLint to ESLint MigrationDecember 5, 2019 · 3 min readBack in February of this year, plans were announced to deprecate TSLint in favor of ESLint. TSLint's goal has become to work toward a “unified developer experience” by supporting ESLint development going forward.
What has changed in oclif​
To keep inline with the community, oclif has transitioned to ESLint for all our core libraries as well as all our official plugins.
Starting in v1.15.x, oclif will now optionally generate projects with ESLint for both TypeScript and JavaScript CLI’s.
ESLint does require Node to be on stable LTS version, at the time of writing, Node 8.10.x, Node 10.13.x & Node 12.x.x.
How does this affect you​
Existing CLI’s are unchanged, but any newly generated CLI's will only give the option of using ESLint. If you are running tslint in your CLI, we recommend you switch to ESLint as well.
In migrating our projects we took the following steps (for an example of these changes see this pull request).


Install eslint
$ yarn add eslint eslint-config-oclif eslint-config-oclif-typescript --dev


Add eslint related files


$ echo '{  "extends": [    "oclif",    "oclif-typescript"  ],  "rules": {  }}' > .eslintrc


Remove tslint and related packages
$ yarn remove @oclif/tslint tslint


Remove tslint related configuration files
$ rm tslint.json


Change lint script in our package.json from something like:
"lint": "tsc -p test --noEmit && tslint -p test -t stylish"
to
"lint": "eslint . --ext .ts --config .eslintrc"


To preserve the test compile (tsc -p test --noEmit) we also made the following updates to our scripts:
"pretest": "tsc -p test --noEmit"
In some cases we had our posttest duplicating the same steps as our lint script so it’s cleaner to have it reference the lint job directly with:
"posttest": "yarn lint"

Run yarn lint --fix. This attempts to auto-fix any linting violations automatically. In the case an auto-fix isn’t available it should be fixed manually or ignored (see the eslint configuration doc for more information)
Do a search in the codebase for tslint and remove any unnecessary tslint disabling comments, like:

/* tslint:disable:object-literal-sort-keys */
If you are on a version of Node that is not supported by ESLint, you will also need to update your Node engine. ESLint supports Node 8, 10, and 12 so you should upgrade to the most recent Node version compatible with your CLI and also supported by ESLint (see ESLint's Installation and Usage instructions).
When will this take effect​
These changes have taken effect in oclif v1.15.1. When you generate a new CLI or plugin it will now contain configuration for ESLint instead of TSLint.oclif's Current Node SupportOctober 31, 2019 · 3 min readTo maintain a healthy project trajectory, oclif follows and supports Node Active LTS release, currently Node 10 & Node 12. This means ensuring that oclif continues to play nice with coming Active LTS Node versions and other packages in the ecosystem. Moving forward also means leaving older versions behind. Starting in 2020, Node will stop maintaining Node 8 and it is our intent at that time to also follow suit. Let’s take a look at a few ways we will be supporting these changes.
CI Environments​
CLIs created with the oclif cli going forward will be generated with a CircleCI configuration with Node 10 & 12 and an Appveyor configuration using Node 10. We have also added Node latest to CircleCi to be an early warning detection against coming Node changes (Node latest is managed by CircleCI).
We have already updated every oclif repo's CI configs to reflect this.
If your existing CLI uses either Appveyor or CircleCI you can update your config files also, like so:
.circleci/config.yml​
Your CircleCI config should contain a node-latest job, aliased as test. From this, there should be two extensions of this job for the Active LTS Node versions, Node 10 and Node 12.
  node-10:    <<: *node-latest    docker:      - image: node:10  node-12:    <<: *node-latest    docker:      - image: node:12
Notice that these declarations only change the Docker Node images used to run that job.
Additionally, the jobs listed within workflows must also be updated to reflect our changes in configuration:
    jobs:      - node-latest      - node-10      - node-12
appveyor.yml​
For appveyor we are currently only testing the oldest Active LTS Node version, Node 10. Update the nodejs_version proppert in your appveyor.yml file to reflect this.
environment:  nodejs_version: "10"
Deprecating Node 8 & Updating packge.json engines​
In Jan 2020, Node will end its Node 8 maintenance. We will follow suit by setting the package.json engine property in oclif packages to >=10 and bumping the package's major versions.
Depending on how you ship your CLI you may wish to also bump the engines version in your CLI's package.json. You can read more about the implications of the engines property configuration in the npm documentation.
Also consider distributing your CLI with its own Node version.
Packaged Node Version​
When using dev-cli to pack your CLI it will use the Node version as specified in your package.json under the oclif.update.node.version property. This value should reflect an Active LTS Node version (dev-cli does not currently enforce versions).
Supporting the future​
As a community we may discover bumps along the way as we upgrade. If you notice something related to oclif please feel free to open an issue or submit a pull request under the relevant oclif package within the org.
We look forward to using the latest from Node and the community and keeping oclif healthy along the way.oclifconf 2019: A RecapSeptember 16, 2019 · 4 min readIn May, Heroku and Salesforce Open Source organized oclifconf, a conference for developers & product managers building CLI tools on top of the open source oclif framework. The speakers came from various tech companies, such as Adobe, Netlify, and Apollo, who have already built amazing CLI experiences. The topics covered everything from the incredible capabilities oclif has unlocked, to the community-built plugins extending its functionality, and even what the behavior of an adaptive CLI tool might look like.
Below is a listing of all of the talks from the event, along with a short summary. Enjoy!
The future of oclif by Jeff Dickey​

In its relatively short lifetime, oclif has already inspired many developers and companies to adopt its framework as a means for implementing their own command-line tooling. In this talk, Jeff Dickey, an oclif founding team member, recaps the project's history and inspiration. He also looks towards the future and outlines some features and improvements that the tool could adapt. This isn't so much a definitive roadmap of where oclif is headed, but rather, a call to inspiration for developers eager to contribute! And if you are interested in contributing, check out the open issues in the oclif GitHub repo and come say "Hello!" on Spectrum Chat.
Open Source Citizenship by Josh Simmons​

When it comes to open source, it's more than just individuals now. More and more frequently, large corporations are contributing to projects by donating to contributors, sponsoring events, or upstreaming contributions. But keeping open source projects and communities healthy requires more than just money and brainpower. Josh Simmons surveyed multiple open source communities and relays his findings as to what help maintainers and contributors actually need in this talk.
Building an enterprise-grade CLI with oclif by Thomas Dvornik​

Security and performance are all about trust. While oclif is an extremely extensible framework for building CLI tooling, there are additional requirements to fulfill for enterprise businesses to adopt it that might not be necessary for individual developers. Thomas Dvornik outlines what he and his colleagues at Salesforce have implemented as plugins to oclif to satisfy these needs, including encrypted OAuth, plugin signing, lazy loading dependencies, synchronizing weekly releases and deprecations across dozens of repositories, and establishing cross-team coding and documentation standards.
How Adobe I/O built an extensible CLI with oclif by Jesse MacFadyen​

Perhaps oclif's most appealing feature is its support for plugins. In Cordova's case, they've created a sophisticated telemetry system that helps Adobe developers see which commands users are using--and reports on which ones are erroring out. By embedding a feedback system into the tool, users are even able to quickly send their suggestions to a form, without ever leaving the terminal. Jesse MacFadyen demonstrates how oclif's plugin system can work beyond simply executing commands.
Integrating oclif with GraphQL and Apollo by Evans Hauser​

For Evans Hauser and the team at Apollo, oclif is best thought of as "React for the CLI." As a client paired with a strongly-typed API contract to a server, it can deliver structured and consistent commands to retrieve external data. What better mechanism to use for this transfer than GraphQL, a framework which empowers the client to ask precisely for the data it needs, and nothing more?
Adaptive Intent-based CLI State Machines by Shawn Wang​

In designing oclif, Jeff Dickey wrote out 12 CLI factors to keep in mind. In this talk, Shawn Wang outlines a 13th: state. State is hard, because it depends on context, and context depends on understanding what a user intends to do, not what they are asking. Shawn is working towards enabling oclif to better understand the commands a user has entered, so that it can predict and interpret future commands that might be entered next. This would enable CLI tools to not just interpret a users' commands, but to also interpret their intent.\n\nIntroducing `oclif init` commandApril 10, 2024 · 2 min readThanks to the contribution of @joshcanhelp we released a new command for the oclif CLI called oclif init in version 4.8.0
The oclif init command allows you to initialize oclif in an existing project directory by adding the bare minimum requirements: a few pieces of configuration, bin scripts, and a couple of dependencies (@oclif/core and ts-node). This is slightly different from oclif generate, which will create an entirely new oclif project based on our templates.
oclif init will add the following:

bin scripts: bin/run.js, bin/run.cmd, bin/dev.js, and bin/dev.cmd
oclif section to package.json with bin, dirname, commands, and topicSeparator set (See Configuring Your CLI for more)
@oclif/core to dependencies in your package.json (if it's not already there)
ts-node to devDependencies in your package.json (if it's not already there)

Once you've initialized oclif, you can use the bin scripts to execute your CLI. You can also use the other oclif commands like oclif generate command and oclif generate hook to start adding new functionality.

❯ oclif init --helpInitialize a new oclif CLIUSAGE  $ oclif init [--bin <value>] [--module-type ESM|CommonJS] [--package-manager npm|yarn|pnpm] [--topic-separator    colons|spaces] [-d <value>] [-y]FLAGS  -d, --output-dir=<value>        Directory to initialize the CLI in.  -y, --yes                       Use defaults for all prompts. Individual flags will override defaults.      --bin=<value>               Supply answer for prompt: Command bin name the CLI will export      --module-type=<option>      Supply answer for prompt: Select a module type                                  <options: ESM|CommonJS>      --package-manager=<option>  Supply answer for prompt: Select a package manager                                  <options: npm|yarn|pnpm>      --topic-separator=<option>  Supply answer for prompt: Select a topic separator                                  <options: colons|spaces>DESCRIPTION  Initialize a new oclif CLI  This will add the necessary oclif bin files, add oclif config to package.json, and install @oclif/core and ts-node.EXAMPLES  Initialize a new CLI in the current directory    $ oclif init  Initialize a new CLI in a different directory    $ oclif init --output-dir "/path/to/existing/project"  Supply answers for specific prompts    $ oclif init --topic-separator colons --bin mycli
Hope you enjoy the new command! If you come across any issues or have any new ideas for this command, head over to the oclif/oclif repo and open a new issue.
All our best,
The oclif teamoclif Spring 2024 UpdateMarch 29, 2024 · 4 min readHello oclif developers! It's been a while since we last uploaded a blog - and a lot has happened.
We've been focusing on these high-level areas over the past couple of years:

Improving @oclif/core
ESM Support
Improving and revitalizing oclif.io
Re-engaging the oclif community

Improving @oclif/core​
Since we announced @oclif/core over three years ago, we've released two new major versions, each packed with lots of features that we're really excited about.
Here are some of these changes:

Full support for ESM and interoperability with CommonJS (more on this topic below).
Configurable command discovery strategies that give you more control over how commands are loaded at runtime. Check out the docs.
A new preparse hook that allows you to manipulate the provided arguments before they're parsed. Salesforce used this hook to implement a neat --flags-dir feature that translates local files into flags.
A new Performance class that you can use to track performance inside of @oclif/core and your own CLI or plugin. Check out the docs.
A new flag type, Flags.option, that lets you define a flag with a preset list of options. Typescript then uses the options to infer the flag's type.
Flags now have a relationship property that allows you to define more complex relationships between flags. Check out the flags docs for more information.
Flags now have a defaultHelp property that allows you to set the human readable default value in the command help. This property is useful when your flag's parse method returns a complex type, such as an object or a class. Check out the flags docs for more.
Commands now have a hiddenAliases property that allows you to define aliases that you want to hide from the user. The property is super helpful when you're trying to wean users off a deprecated command.
You can now use bun or tsx as dev runtimes (as opposed to node or ts-node).
A command's usage, args, and flags are now shown whenever a user forgets to provide a required arg or flag, or when they provided a non-existent flag.

If you need help migrating to the latest version, head over to core's README which has links to the migration guides. Feel free to open a new discussion if you need more hands-on help from us or the community.
ESM Support​
Version 3 of @oclif/core introduced full support for developing ESM plugins and CLIs. It also offered full support for interoperability between CommonJS and ESM plugins.
Put more simply, you can now migrate your CLI to ESM while keeping individual plugins in CommonJS (or vice versa). The upgrade path is now much simpler for you. You also don't need to worry about any community plugins that have migrated to ESM before you did (such as all the @oclif plugins) or are staunchly sticking with CommonJS for the foreseeable future.
Read more about this topic here.
Improving and Revitalizing oclif.io​
Another area of focus for us has been improving our documentation site, oclif.io.
While improving the quality and accuracy of the documentation was our priority, we also took the time to upgrade to the latest version of docusaurus. This new version gave our site a much-needed facelift, as well as cool new features such as dark mode and announcements.
If you have any feedback or are running into issues, we want to hear about it. Just create an issue in the oclif.io repo.
Re-engaging the oclif Community​
Lastly, our biggest priority at the moment is to re-engage the oclif community. We understand how frustrating it has been over the years to see your issues and pull requests go unacknowledged. We apologize for not prioritizing the community, and are earnestly trying to make sure that every issue and pull request gets the attention it deserves going forward.
We also opened up GitHub discussions for @oclif/core and the oclif CLI, where you can now post your questions or ideas. We hope you take advantage of them, we love hearing from you!
One last thing: we intend to publicly post our roadmap so you have more visibility into what we're working on. Stay tuned!
All our best,
The oclif teamAnnouncing oclif v2!January 12, 2022 · 5 min readHello and happy new year! It's our great pleasure to announce that we have released oclif v2, which uses the new @oclif/core library! 🎉
oclif v2 includes many changes that improve the experience of both creating and using an oclif CLI.
Going forward, we don't plan to make any updates to oclif v1 and its corresponding libraries, except for critical security fixes. See the compatibility matrix for a list of these libraries. In order to give developers time to migrate from v1 to v2, we're not completely dropping support yet. But at some point in the future we'll archive the v1 repositories and deprecate their versions on npm.
What’s changing?​
Repository Changes​
All repositories under the oclif org now use main as their primary branch and oclif-v1 as the legacy branch. The main  branch corresponds to oclif v2 and the oclif-v1 branch to oclif v1. If you find any repos that don’t have a main branch, you can safely assume that they're not used in oclif v2 and will be deprecated in the future.
Consolidating Tools & Libraries​
The oclif-dev CLI has now been incorporated into oclif. You now no longer need to install a separate package to manage your entire CLI’s lifecycle.
The following libraries have been consolidated under @oclif/core and will be deprecated at some point in the future. Read the migration guide to learn how to update your CLI or plugin to use the new core library.

@oclif/command
@oclif/config
@oclif/error
@oclif/help
@oclif/parser

No more single vs multi command CLIs​
There's only one "type" of oclif v2 CLI, but it can have as few or as many commands as a developer wants. As a result, there’s only one command to generate CLIs, oclif generate, as opposed to the old oclif single and oclif multi commands.
Node > 12​
To ensure oclif CLIs are as secure as possible, all v2 libraries and plugins support only Node 12 or higher as of now. Going forward, they'll support only Node Maintenance or higher, as defined by Node's release schedule here: https://nodejs.org/en/about/releases/.
What’s new?​
New example CLI​
oclif-hello-world is our new example repo. This is also the repo that's used as a template when running oclif generate to create a new CLI. This repo will always be able to be referenced as an example of what an oclif v2 CLI should look like.
Spaced commands​
oclif CLIs can now use spaces, instead of colons, to separate topics and subcommands. To enable this feature, simply add “topicSeparator": " " to the oclif config in your package.json. See an example in our example repo.
// Old commands that use :$ mycli do:something
// New spaced commands$ mycli do something

Note: Spaced commands are backwards compatible. So if you enable spaced commands for your CLI, users will still be able to use : as a separator. This ensures that any existing scripts don't break.

New Help Output​
We’ve revamped the way command help is outputted to the terminal, making it both easier to implement and easier to read. See the difference between the old help output on the left and the new help output on the right in the screenshots below.
oclif v1oclif v2
Notice that there are new sections for flags and global flags, examples are displayed with better spacing, and there is a section at the bottom called Configuration Variables. This Configuration Variables section is not part of the new help by default. But we've added support for custom help sections, which is what the sf CLI uses to create the new section.
Async Command Parsing​
We’ve also improved the performance of new CLIs by rewriting how commands are parsed on initialization. The new parser is asynchronous, which makes CLIs with a lot of commands or installed  plugins much faster.
What’s coming next?​
Part of our charter for the release of oclif v2 includes improving our engagement with the oclif community. We know that over the past couple of years we’ve reduced our involvement, and a lot of issues and PRs have languished in limbo. Hopefully you’ve already seen increased activity and responses from oclif maintainers recently, but if you haven’t, please don’t hesitate to ping us by tagging @admins in oclif repos.
We also want to start interviewing members of the oclif community to acquire feedback and prioritize the features and fixes you deem most important!
Best,
The oclif team

Reference material​
Migration Guide​
This guide explains how to upgrade a CLI or plugin from the old oclif v1 libraries to the new @oclif/core library that oclif v2 uses.
https://github.com/oclif/core/blob/main/MIGRATION.md
Compatibility Matrix​
The following matrix shows how the v1 libraries and plugins relate to the new v2 ones. Use this matrix as a guide to know what to drop and which versions to switch when upgrading your plugins and CLIs to v2.
oclif "v1"oclif "v2"Utility CLIsoclif@<2@oclif/dev-cli@<2oclif@>=2Main packages@oclif/command@oclif/config@oclif/errors@oclif/parser@oclif/plugin-help@oclif/core@>=1Node LTSNode v8-14Node v12+ (at time of writing)TypeScripttypescript@<4typescript@>=4Main plugins@oclif/plugin-autocomplete@<1@oclif/plugin-commands@<2@oclif/plugin-help@<4@oclif/plugin-not-found@<2@oclif/plugin-plugins@<2@oclif/plugin-update@<2plugin-warn-if-update-available@<2plugin-which@<2@oclif/plugin-autocomplete@>=1@oclif/plugin-commands@>=2@oclif/plugin-help@>=4@oclif/plugin-not-found@>=2@oclif/plugin-plugins@>=2@oclif/plugin-update@>=2@oclif/plugin-warn-if-update-available@>=2@oclif/plugin-which@>=2Introducing @oclif/coreMarch 1, 2021 · 3 min readGreetings!
We hope this blog post finds you well.
Introducing...​
We are excited to announce the next iteration of the oclif project today: @oclif/core.
We have learned a lot in the last three years of developing oclif, developing on oclif and supporting millions of command runs a day via Heroku and Salesforce CLIs.
@oclif/core ("Core") simplifies the oclif development experience and introduces highly requested new features.
Core combines the essential oclif packages into one "core" package, aptly named @oclif/core.
Core also introduces:

A default command option
Colon or space command syntax
Async command parsing
Command piping to arguments

With the introduction of default command functionality, Core simplifies the oclif project and removes the notion of single or multi command CLIs. Core CLIs can have 1 or many commands.
Along with Core, we moved the oclif-dev CLI into the oclif CLI creating a single "utility" CLI. This CLI also introduces a new AWS S3 compatible publishing scheme.
What to expect in the near future​
Core is in pre-release beta and being actively developed for new internal Salesforce CLIs.
Much documentation needs to be written in the coming months including migration paths. Migration onto Core should be as painless as possible with many exports remaining entirely unchanged. Look for forthcoming blog posts and documentation on oclif.io.
Early this summer, tentively June 1, we will release Core v1. Core's release will coincide with major bumps to many other oclif plugin packages. See the compatibility matrix below.
At Core's v1 release, the current "main" oclif packages (namely: command, config, errors & parser) will go into maintenance mode until Jan 2022. They will receive only bug and security fixes and they remain compatible with current versions of the oclif and oclif-dev CLIs. Afterwhich, they will be archived.
Companioning Core, the next major release of the oclif CLI (literally oclif@2) will generate Core CLIs.
Going forward​
We are excited to release Core! We invite you to poke around the Core repo. It may appear to be a big change but Core keeps what you already enjoy about oclif while reducing development complexity, project dependencies, package coupling and bundle size and introduces many requested features previously too prickly to weave into the current oclif architecture.
Best,
The oclif team
Reference: Compatibility matrix​
oclif "v1"oclif "Core"Utility CLIsoclif@<2@oclif/dev-cli@<2oclif@>=2Main packages@oclif/core@<2@oclif/config@<2@oclif/errors@<2@oclif/parser@<4@oclif/plugin-help@<4@oclif/core@>=1Node LTSNode v8-14Node v12+TypeScripttypescript@<4typescript@>=4Main plugins@oclif/plugin-autocomplete@<1@oclif/plugin-commands@<2@oclif/plugin-help@<4@oclif/plugin-not-found@<2@oclif/plugin-plugins@<2@oclif/plugin-update@<2plugin-warn-if-update-available@<2plugin-which@<2@oclif/plugin-autocomplete@>=2@oclif/plugin-commands@>=2@oclif/plugin-help@>=4@oclif/plugin-not-found@>=2@oclif/plugin-plugins@>=2@oclif/plugin-update@>=2@oclif/plugin-warn-if-update-available@>=2@oclif/plugin-which@>=2oclif Summer 2020 UpdateAugust 26, 2020 · 2 min readHello oclif developers! We hope you are all doing well.
Earlier this year, we started our planning for oclifconf v2 and, like all conference, had to change course. We opted not to hold a virtual conference, however, we wanted to take some time to highlight a few oclif features shipped this year.
Feature: Help templating​
One of the most requested features, help templating enables oclif developers to customize the help output for their CLI.
Read the announcement.
Feature: Custom error delegation​
This feature both improved how oclif throws and handles errors and allows oclif developers to overwrite or interject in oclif’s error handling.
Read the announcement.
Feature: postrun hooks​
We have added a new lifecycle event postrun. Your CLI can now run a hook after a command has ran.
See our hook documentation.
Feature: Root index command​
Previously, oclif would display CLI help if only the binary name with no command ID was invoked, oclif now supports a "root index" command. If present, a command defined at src/commands/index.ts will be run if no command ID is found.
1 million weekly downloads​
While exact oclif usage metrics are hard to pin down, we use npm download statistics of oclif packages as a rough approximation. Earlier this year, oclif's command package hit 1 million weekly downloads for the first time!
This year has been presented its challenges on everyone. We want to thank you, oclif developers, whom have taken the time to use and improve the oclif project. We look forward to seeing you all - in person - in the future!
All our best,
The oclif teamPretty Printable ErrorsJuly 1, 2020 · One min readOften CLIs are used as handy tools and when things go wrong it’s useful to have additional context. In oclif we have added a couple of additional properties that can show extra context to the users when an error is displayed. The code, ref and suggestions will now be displayed if they are included. This will work with an existing oclif CLI by adding the latest @oclif/errors and @oclif/core to the CLI's package.json dependencies.
For example, using this.error with the additional properties:
class TestError extends Command {  async run() {    this.error("An error has occurred!", {      code: "OCLIF_ERR",      ref: "https://oclif.io/docs/commands#thiserrormessage-string--error-options-code-string-exit-number",      suggestions: ["Use these extra properties to provide additional context"],    })  }}
would result with the following output:
›   Error: An error has occurred!›   Code: OCLIF_ERR›   Try this: Use these extra properties to provide additional context›   Reference: https://oclif.io/docs/commands#thiserrormessage-string--error-options-code-string-exit-number
If these properties are not provided then nothing changes and the CLI will continue to display the single error message output as it did before. Additionally, as part of this exercise we’ve added documentation around Error Handling in oclif which should come in handy if the need arises to extend oclif’s default handling of errors.Customizing Help in oclifMay 5, 2020 · 2 min readOut of the box oclif provides a great help experience for CLIs.
But what if, as an oclif developer, you want to customize some or all of the output?
You can now customize your CLI's help output by implementing the HelpBase abstract class.
Getting started with custom help​
If you have not done so yet, update @oclif/core.
$ yarn add --latest @oclif/core
To get started, first define the filepath to your help class in oclif's config in package.json. This is a relative path to the help class, without a file extension.
For this example, the help class will be created in a file at "[project root]/src/help.ts".
{  // ...  "oclif": {    "helpClass": "./lib/help"    // ...  }  // ...}
From here there are two paths, implement the HelpBase abstract class yourself or overwrite the parts of the default Help class you want to customize (ex: how command usage is displayed). We recommend the latter approach but cover both in the new Help Classes docs.
Separating TOPICS & COMMANDS in the new default Help class​
Previously, topics and child commands were listed in help output under a single list heading called "COMMANDS". But we found this can be slightly confusing. Some topics are commands also (a.k.a. topic-commands) while others are simply organizational namespacing (and when ran just show their help).
The new default Help class splits the list of children into distinct lists of "TOPICS" and "COMMANDS", with the possibility of an item appearing in both if it a topic-command. This makes it clearer what is expected to be ran - "COMMANDS" - and what is providing structure - "TOPICS" - when looking at the help output.
VERSION  plugin-help-example/0.0.0 darwin-x64 node-v12.12.0USAGE  $ plugin-help-example [COMMAND]TOPICS  topic  this is a topic and has child topics or commandsCOMMANDS  hello  describe the command here  help   display help for plugin-help-example
We look forward to seeing what custom help features you implement in your oclif CLIs with this new feature!oclif TSLint to ESLint MigrationDecember 5, 2019 · 3 min readBack in February of this year, plans were announced to deprecate TSLint in favor of ESLint. TSLint's goal has become to work toward a “unified developer experience” by supporting ESLint development going forward.
What has changed in oclif​
To keep inline with the community, oclif has transitioned to ESLint for all our core libraries as well as all our official plugins.
Starting in v1.15.x, oclif will now optionally generate projects with ESLint for both TypeScript and JavaScript CLI’s.
ESLint does require Node to be on stable LTS version, at the time of writing, Node 8.10.x, Node 10.13.x & Node 12.x.x.
How does this affect you​
Existing CLI’s are unchanged, but any newly generated CLI's will only give the option of using ESLint. If you are running tslint in your CLI, we recommend you switch to ESLint as well.
In migrating our projects we took the following steps (for an example of these changes see this pull request).


Install eslint
$ yarn add eslint eslint-config-oclif eslint-config-oclif-typescript --dev


Add eslint related files


$ echo '{  "extends": [    "oclif",    "oclif-typescript"  ],  "rules": {  }}' > .eslintrc


Remove tslint and related packages
$ yarn remove @oclif/tslint tslint


Remove tslint related configuration files
$ rm tslint.json


Change lint script in our package.json from something like:
"lint": "tsc -p test --noEmit && tslint -p test -t stylish"
to
"lint": "eslint . --ext .ts --config .eslintrc"


To preserve the test compile (tsc -p test --noEmit) we also made the following updates to our scripts:
"pretest": "tsc -p test --noEmit"
In some cases we had our posttest duplicating the same steps as our lint script so it’s cleaner to have it reference the lint job directly with:
"posttest": "yarn lint"

Run yarn lint --fix. This attempts to auto-fix any linting violations automatically. In the case an auto-fix isn’t available it should be fixed manually or ignored (see the eslint configuration doc for more information)
Do a search in the codebase for tslint and remove any unnecessary tslint disabling comments, like:

/* tslint:disable:object-literal-sort-keys */
If you are on a version of Node that is not supported by ESLint, you will also need to update your Node engine. ESLint supports Node 8, 10, and 12 so you should upgrade to the most recent Node version compatible with your CLI and also supported by ESLint (see ESLint's Installation and Usage instructions).
When will this take effect​
These changes have taken effect in oclif v1.15.1. When you generate a new CLI or plugin it will now contain configuration for ESLint instead of TSLint.oclif's Current Node SupportOctober 31, 2019 · 3 min readTo maintain a healthy project trajectory, oclif follows and supports Node Active LTS release, currently Node 10 & Node 12. This means ensuring that oclif continues to play nice with coming Active LTS Node versions and other packages in the ecosystem. Moving forward also means leaving older versions behind. Starting in 2020, Node will stop maintaining Node 8 and it is our intent at that time to also follow suit. Let’s take a look at a few ways we will be supporting these changes.
CI Environments​
CLIs created with the oclif cli going forward will be generated with a CircleCI configuration with Node 10 & 12 and an Appveyor configuration using Node 10. We have also added Node latest to CircleCi to be an early warning detection against coming Node changes (Node latest is managed by CircleCI).
We have already updated every oclif repo's CI configs to reflect this.
If your existing CLI uses either Appveyor or CircleCI you can update your config files also, like so:
.circleci/config.yml​
Your CircleCI config should contain a node-latest job, aliased as test. From this, there should be two extensions of this job for the Active LTS Node versions, Node 10 and Node 12.
  node-10:    <<: *node-latest    docker:      - image: node:10  node-12:    <<: *node-latest    docker:      - image: node:12
Notice that these declarations only change the Docker Node images used to run that job.
Additionally, the jobs listed within workflows must also be updated to reflect our changes in configuration:
    jobs:      - node-latest      - node-10      - node-12
appveyor.yml​
For appveyor we are currently only testing the oldest Active LTS Node version, Node 10. Update the nodejs_version proppert in your appveyor.yml file to reflect this.
environment:  nodejs_version: "10"
Deprecating Node 8 & Updating packge.json engines​
In Jan 2020, Node will end its Node 8 maintenance. We will follow suit by setting the package.json engine property in oclif packages to >=10 and bumping the package's major versions.
Depending on how you ship your CLI you may wish to also bump the engines version in your CLI's package.json. You can read more about the implications of the engines property configuration in the npm documentation.
Also consider distributing your CLI with its own Node version.
Packaged Node Version​
When using dev-cli to pack your CLI it will use the Node version as specified in your package.json under the oclif.update.node.version property. This value should reflect an Active LTS Node version (dev-cli does not currently enforce versions).
Supporting the future​
As a community we may discover bumps along the way as we upgrade. If you notice something related to oclif please feel free to open an issue or submit a pull request under the relevant oclif package within the org.
We look forward to using the latest from Node and the community and keeping oclif healthy along the way.oclifconf 2019: A RecapSeptember 16, 2019 · 4 min readIn May, Heroku and Salesforce Open Source organized oclifconf, a conference for developers & product managers building CLI tools on top of the open source oclif framework. The speakers came from various tech companies, such as Adobe, Netlify, and Apollo, who have already built amazing CLI experiences. The topics covered everything from the incredible capabilities oclif has unlocked, to the community-built plugins extending its functionality, and even what the behavior of an adaptive CLI tool might look like.
Below is a listing of all of the talks from the event, along with a short summary. Enjoy!
The future of oclif by Jeff Dickey​

In its relatively short lifetime, oclif has already inspired many developers and companies to adopt its framework as a means for implementing their own command-line tooling. In this talk, Jeff Dickey, an oclif founding team member, recaps the project's history and inspiration. He also looks towards the future and outlines some features and improvements that the tool could adapt. This isn't so much a definitive roadmap of where oclif is headed, but rather, a call to inspiration for developers eager to contribute! And if you are interested in contributing, check out the open issues in the oclif GitHub repo and come say "Hello!" on Spectrum Chat.
Open Source Citizenship by Josh Simmons​

When it comes to open source, it's more than just individuals now. More and more frequently, large corporations are contributing to projects by donating to contributors, sponsoring events, or upstreaming contributions. But keeping open source projects and communities healthy requires more than just money and brainpower. Josh Simmons surveyed multiple open source communities and relays his findings as to what help maintainers and contributors actually need in this talk.
Building an enterprise-grade CLI with oclif by Thomas Dvornik​

Security and performance are all about trust. While oclif is an extremely extensible framework for building CLI tooling, there are additional requirements to fulfill for enterprise businesses to adopt it that might not be necessary for individual developers. Thomas Dvornik outlines what he and his colleagues at Salesforce have implemented as plugins to oclif to satisfy these needs, including encrypted OAuth, plugin signing, lazy loading dependencies, synchronizing weekly releases and deprecations across dozens of repositories, and establishing cross-team coding and documentation standards.
How Adobe I/O built an extensible CLI with oclif by Jesse MacFadyen​

Perhaps oclif's most appealing feature is its support for plugins. In Cordova's case, they've created a sophisticated telemetry system that helps Adobe developers see which commands users are using--and reports on which ones are erroring out. By embedding a feedback system into the tool, users are even able to quickly send their suggestions to a form, without ever leaving the terminal. Jesse MacFadyen demonstrates how oclif's plugin system can work beyond simply executing commands.
Integrating oclif with GraphQL and Apollo by Evans Hauser​

For Evans Hauser and the team at Apollo, oclif is best thought of as "React for the CLI." As a client paired with a strongly-typed API contract to a server, it can deliver structured and consistent commands to retrieve external data. What better mechanism to use for this transfer than GraphQL, a framework which empowers the client to ask precisely for the data it needs, and nothing more?
Adaptive Intent-based CLI State Machines by Shawn Wang​

In designing oclif, Jeff Dickey wrote out 12 CLI factors to keep in mind. In this talk, Shawn Wang outlines a 13th: state. State is hard, because it depends on context, and context depends on understanding what a user intends to do, not what they are asking. Shawn is working towards enabling oclif to better understand the commands a user has entered, so that it can predict and interpret future commands that might be entered next. This would enable CLI tools to not just interpret a users' commands, but to also interpret their intent.Older Entries\n\n\n\nIntroducing `oclif init` commandApril 10, 2024 · 2 min readThanks to the contribution of @joshcanhelp we released a new command for the oclif CLI called oclif init in version 4.8.0
The oclif init command allows you to initialize oclif in an existing project directory by adding the bare minimum requirements: a few pieces of configuration, bin scripts, and a couple of dependencies (@oclif/core and ts-node). This is slightly different from oclif generate, which will create an entirely new oclif project based on our templates.
oclif init will add the following:

bin scripts: bin/run.js, bin/run.cmd, bin/dev.js, and bin/dev.cmd
oclif section to package.json with bin, dirname, commands, and topicSeparator set (See Configuring Your CLI for more)
@oclif/core to dependencies in your package.json (if it's not already there)
ts-node to devDependencies in your package.json (if it's not already there)

Once you've initialized oclif, you can use the bin scripts to execute your CLI. You can also use the other oclif commands like oclif generate command and oclif generate hook to start adding new functionality.

❯ oclif init --helpInitialize a new oclif CLIUSAGE  $ oclif init [--bin <value>] [--module-type ESM|CommonJS] [--package-manager npm|yarn|pnpm] [--topic-separator    colons|spaces] [-d <value>] [-y]FLAGS  -d, --output-dir=<value>        Directory to initialize the CLI in.  -y, --yes                       Use defaults for all prompts. Individual flags will override defaults.      --bin=<value>               Supply answer for prompt: Command bin name the CLI will export      --module-type=<option>      Supply answer for prompt: Select a module type                                  <options: ESM|CommonJS>      --package-manager=<option>  Supply answer for prompt: Select a package manager                                  <options: npm|yarn|pnpm>      --topic-separator=<option>  Supply answer for prompt: Select a topic separator                                  <options: colons|spaces>DESCRIPTION  Initialize a new oclif CLI  This will add the necessary oclif bin files, add oclif config to package.json, and install @oclif/core and ts-node.EXAMPLES  Initialize a new CLI in the current directory    $ oclif init  Initialize a new CLI in a different directory    $ oclif init --output-dir "/path/to/existing/project"  Supply answers for specific prompts    $ oclif init --topic-separator colons --bin mycli
Hope you enjoy the new command! If you come across any issues or have any new ideas for this command, head over to the oclif/oclif repo and open a new issue.
All our best,
The oclif teamoclif Spring 2024 UpdateMarch 29, 2024 · 4 min readHello oclif developers! It's been a while since we last uploaded a blog - and a lot has happened.
We've been focusing on these high-level areas over the past couple of years:

Improving @oclif/core
ESM Support
Improving and revitalizing oclif.io
Re-engaging the oclif community

Improving @oclif/core​
Since we announced @oclif/core over three years ago, we've released two new major versions, each packed with lots of features that we're really excited about.
Here are some of these changes:

Full support for ESM and interoperability with CommonJS (more on this topic below).
Configurable command discovery strategies that give you more control over how commands are loaded at runtime. Check out the docs.
A new preparse hook that allows you to manipulate the provided arguments before they're parsed. Salesforce used this hook to implement a neat --flags-dir feature that translates local files into flags.
A new Performance class that you can use to track performance inside of @oclif/core and your own CLI or plugin. Check out the docs.
A new flag type, Flags.option, that lets you define a flag with a preset list of options. Typescript then uses the options to infer the flag's type.
Flags now have a relationship property that allows you to define more complex relationships between flags. Check out the flags docs for more information.
Flags now have a defaultHelp property that allows you to set the human readable default value in the command help. This property is useful when your flag's parse method returns a complex type, such as an object or a class. Check out the flags docs for more.
Commands now have a hiddenAliases property that allows you to define aliases that you want to hide from the user. The property is super helpful when you're trying to wean users off a deprecated command.
You can now use bun or tsx as dev runtimes (as opposed to node or ts-node).
A command's usage, args, and flags are now shown whenever a user forgets to provide a required arg or flag, or when they provided a non-existent flag.

If you need help migrating to the latest version, head over to core's README which has links to the migration guides. Feel free to open a new discussion if you need more hands-on help from us or the community.
ESM Support​
Version 3 of @oclif/core introduced full support for developing ESM plugins and CLIs. It also offered full support for interoperability between CommonJS and ESM plugins.
Put more simply, you can now migrate your CLI to ESM while keeping individual plugins in CommonJS (or vice versa). The upgrade path is now much simpler for you. You also don't need to worry about any community plugins that have migrated to ESM before you did (such as all the @oclif plugins) or are staunchly sticking with CommonJS for the foreseeable future.
Read more about this topic here.
Improving and Revitalizing oclif.io​
Another area of focus for us has been improving our documentation site, oclif.io.
While improving the quality and accuracy of the documentation was our priority, we also took the time to upgrade to the latest version of docusaurus. This new version gave our site a much-needed facelift, as well as cool new features such as dark mode and announcements.
If you have any feedback or are running into issues, we want to hear about it. Just create an issue in the oclif.io repo.
Re-engaging the oclif Community​
Lastly, our biggest priority at the moment is to re-engage the oclif community. We understand how frustrating it has been over the years to see your issues and pull requests go unacknowledged. We apologize for not prioritizing the community, and are earnestly trying to make sure that every issue and pull request gets the attention it deserves going forward.
We also opened up GitHub discussions for @oclif/core and the oclif CLI, where you can now post your questions or ideas. We hope you take advantage of them, we love hearing from you!
One last thing: we intend to publicly post our roadmap so you have more visibility into what we're working on. Stay tuned!
All our best,
The oclif teamAnnouncing oclif v2!January 12, 2022 · 5 min readHello and happy new year! It's our great pleasure to announce that we have released oclif v2, which uses the new @oclif/core library! 🎉
oclif v2 includes many changes that improve the experience of both creating and using an oclif CLI.
Going forward, we don't plan to make any updates to oclif v1 and its corresponding libraries, except for critical security fixes. See the compatibility matrix for a list of these libraries. In order to give developers time to migrate from v1 to v2, we're not completely dropping support yet. But at some point in the future we'll archive the v1 repositories and deprecate their versions on npm.
What’s changing?​
Repository Changes​
All repositories under the oclif org now use main as their primary branch and oclif-v1 as the legacy branch. The main  branch corresponds to oclif v2 and the oclif-v1 branch to oclif v1. If you find any repos that don’t have a main branch, you can safely assume that they're not used in oclif v2 and will be deprecated in the future.
Consolidating Tools & Libraries​
The oclif-dev CLI has now been incorporated into oclif. You now no longer need to install a separate package to manage your entire CLI’s lifecycle.
The following libraries have been consolidated under @oclif/core and will be deprecated at some point in the future. Read the migration guide to learn how to update your CLI or plugin to use the new core library.

@oclif/command
@oclif/config
@oclif/error
@oclif/help
@oclif/parser

No more single vs multi command CLIs​
There's only one "type" of oclif v2 CLI, but it can have as few or as many commands as a developer wants. As a result, there’s only one command to generate CLIs, oclif generate, as opposed to the old oclif single and oclif multi commands.
Node > 12​
To ensure oclif CLIs are as secure as possible, all v2 libraries and plugins support only Node 12 or higher as of now. Going forward, they'll support only Node Maintenance or higher, as defined by Node's release schedule here: https://nodejs.org/en/about/releases/.
What’s new?​
New example CLI​
oclif-hello-world is our new example repo. This is also the repo that's used as a template when running oclif generate to create a new CLI. This repo will always be able to be referenced as an example of what an oclif v2 CLI should look like.
Spaced commands​
oclif CLIs can now use spaces, instead of colons, to separate topics and subcommands. To enable this feature, simply add “topicSeparator": " " to the oclif config in your package.json. See an example in our example repo.
// Old commands that use :$ mycli do:something
// New spaced commands$ mycli do something

Note: Spaced commands are backwards compatible. So if you enable spaced commands for your CLI, users will still be able to use : as a separator. This ensures that any existing scripts don't break.

New Help Output​
We’ve revamped the way command help is outputted to the terminal, making it both easier to implement and easier to read. See the difference between the old help output on the left and the new help output on the right in the screenshots below.
oclif v1oclif v2
Notice that there are new sections for flags and global flags, examples are displayed with better spacing, and there is a section at the bottom called Configuration Variables. This Configuration Variables section is not part of the new help by default. But we've added support for custom help sections, which is what the sf CLI uses to create the new section.
Async Command Parsing​
We’ve also improved the performance of new CLIs by rewriting how commands are parsed on initialization. The new parser is asynchronous, which makes CLIs with a lot of commands or installed  plugins much faster.
What’s coming next?​
Part of our charter for the release of oclif v2 includes improving our engagement with the oclif community. We know that over the past couple of years we’ve reduced our involvement, and a lot of issues and PRs have languished in limbo. Hopefully you’ve already seen increased activity and responses from oclif maintainers recently, but if you haven’t, please don’t hesitate to ping us by tagging @admins in oclif repos.
We also want to start interviewing members of the oclif community to acquire feedback and prioritize the features and fixes you deem most important!
Best,
The oclif team

Reference material​
Migration Guide​
This guide explains how to upgrade a CLI or plugin from the old oclif v1 libraries to the new @oclif/core library that oclif v2 uses.
https://github.com/oclif/core/blob/main/MIGRATION.md
Compatibility Matrix​
The following matrix shows how the v1 libraries and plugins relate to the new v2 ones. Use this matrix as a guide to know what to drop and which versions to switch when upgrading your plugins and CLIs to v2.
oclif "v1"oclif "v2"Utility CLIsoclif@<2@oclif/dev-cli@<2oclif@>=2Main packages@oclif/command@oclif/config@oclif/errors@oclif/parser@oclif/plugin-help@oclif/core@>=1Node LTSNode v8-14Node v12+ (at time of writing)TypeScripttypescript@<4typescript@>=4Main plugins@oclif/plugin-autocomplete@<1@oclif/plugin-commands@<2@oclif/plugin-help@<4@oclif/plugin-not-found@<2@oclif/plugin-plugins@<2@oclif/plugin-update@<2plugin-warn-if-update-available@<2plugin-which@<2@oclif/plugin-autocomplete@>=1@oclif/plugin-commands@>=2@oclif/plugin-help@>=4@oclif/plugin-not-found@>=2@oclif/plugin-plugins@>=2@oclif/plugin-update@>=2@oclif/plugin-warn-if-update-available@>=2@oclif/plugin-which@>=2Introducing @oclif/coreMarch 1, 2021 · 3 min readGreetings!
We hope this blog post finds you well.
Introducing...​
We are excited to announce the next iteration of the oclif project today: @oclif/core.
We have learned a lot in the last three years of developing oclif, developing on oclif and supporting millions of command runs a day via Heroku and Salesforce CLIs.
@oclif/core ("Core") simplifies the oclif development experience and introduces highly requested new features.
Core combines the essential oclif packages into one "core" package, aptly named @oclif/core.
Core also introduces:

A default command option
Colon or space command syntax
Async command parsing
Command piping to arguments

With the introduction of default command functionality, Core simplifies the oclif project and removes the notion of single or multi command CLIs. Core CLIs can have 1 or many commands.
Along with Core, we moved the oclif-dev CLI into the oclif CLI creating a single "utility" CLI. This CLI also introduces a new AWS S3 compatible publishing scheme.
What to expect in the near future​
Core is in pre-release beta and being actively developed for new internal Salesforce CLIs.
Much documentation needs to be written in the coming months including migration paths. Migration onto Core should be as painless as possible with many exports remaining entirely unchanged. Look for forthcoming blog posts and documentation on oclif.io.
Early this summer, tentively June 1, we will release Core v1. Core's release will coincide with major bumps to many other oclif plugin packages. See the compatibility matrix below.
At Core's v1 release, the current "main" oclif packages (namely: command, config, errors & parser) will go into maintenance mode until Jan 2022. They will receive only bug and security fixes and they remain compatible with current versions of the oclif and oclif-dev CLIs. Afterwhich, they will be archived.
Companioning Core, the next major release of the oclif CLI (literally oclif@2) will generate Core CLIs.
Going forward​
We are excited to release Core! We invite you to poke around the Core repo. It may appear to be a big change but Core keeps what you already enjoy about oclif while reducing development complexity, project dependencies, package coupling and bundle size and introduces many requested features previously too prickly to weave into the current oclif architecture.
Best,
The oclif team
Reference: Compatibility matrix​
oclif "v1"oclif "Core"Utility CLIsoclif@<2@oclif/dev-cli@<2oclif@>=2Main packages@oclif/core@<2@oclif/config@<2@oclif/errors@<2@oclif/parser@<4@oclif/plugin-help@<4@oclif/core@>=1Node LTSNode v8-14Node v12+TypeScripttypescript@<4typescript@>=4Main plugins@oclif/plugin-autocomplete@<1@oclif/plugin-commands@<2@oclif/plugin-help@<4@oclif/plugin-not-found@<2@oclif/plugin-plugins@<2@oclif/plugin-update@<2plugin-warn-if-update-available@<2plugin-which@<2@oclif/plugin-autocomplete@>=2@oclif/plugin-commands@>=2@oclif/plugin-help@>=4@oclif/plugin-not-found@>=2@oclif/plugin-plugins@>=2@oclif/plugin-update@>=2@oclif/plugin-warn-if-update-available@>=2@oclif/plugin-which@>=2oclif Summer 2020 UpdateAugust 26, 2020 · 2 min readHello oclif developers! We hope you are all doing well.
Earlier this year, we started our planning for oclifconf v2 and, like all conference, had to change course. We opted not to hold a virtual conference, however, we wanted to take some time to highlight a few oclif features shipped this year.
Feature: Help templating​
One of the most requested features, help templating enables oclif developers to customize the help output for their CLI.
Read the announcement.
Feature: Custom error delegation​
This feature both improved how oclif throws and handles errors and allows oclif developers to overwrite or interject in oclif’s error handling.
Read the announcement.
Feature: postrun hooks​
We have added a new lifecycle event postrun. Your CLI can now run a hook after a command has ran.
See our hook documentation.
Feature: Root index command​
Previously, oclif would display CLI help if only the binary name with no command ID was invoked, oclif now supports a "root index" command. If present, a command defined at src/commands/index.ts will be run if no command ID is found.
1 million weekly downloads​
While exact oclif usage metrics are hard to pin down, we use npm download statistics of oclif packages as a rough approximation. Earlier this year, oclif's command package hit 1 million weekly downloads for the first time!
This year has been presented its challenges on everyone. We want to thank you, oclif developers, whom have taken the time to use and improve the oclif project. We look forward to seeing you all - in person - in the future!
All our best,
The oclif teamPretty Printable ErrorsJuly 1, 2020 · One min readOften CLIs are used as handy tools and when things go wrong it’s useful to have additional context. In oclif we have added a couple of additional properties that can show extra context to the users when an error is displayed. The code, ref and suggestions will now be displayed if they are included. This will work with an existing oclif CLI by adding the latest @oclif/errors and @oclif/core to the CLI's package.json dependencies.
For example, using this.error with the additional properties:
class TestError extends Command {  async run() {    this.error("An error has occurred!", {      code: "OCLIF_ERR",      ref: "https://oclif.io/docs/commands#thiserrormessage-string--error-options-code-string-exit-number",      suggestions: ["Use these extra properties to provide additional context"],    })  }}
would result with the following output:
›   Error: An error has occurred!›   Code: OCLIF_ERR›   Try this: Use these extra properties to provide additional context›   Reference: https://oclif.io/docs/commands#thiserrormessage-string--error-options-code-string-exit-number
If these properties are not provided then nothing changes and the CLI will continue to display the single error message output as it did before. Additionally, as part of this exercise we’ve added documentation around Error Handling in oclif which should come in handy if the need arises to extend oclif’s default handling of errors.Customizing Help in oclifMay 5, 2020 · 2 min readOut of the box oclif provides a great help experience for CLIs.
But what if, as an oclif developer, you want to customize some or all of the output?
You can now customize your CLI's help output by implementing the HelpBase abstract class.
Getting started with custom help​
If you have not done so yet, update @oclif/core.
$ yarn add --latest @oclif/core
To get started, first define the filepath to your help class in oclif's config in package.json. This is a relative path to the help class, without a file extension.
For this example, the help class will be created in a file at "[project root]/src/help.ts".
{  // ...  "oclif": {    "helpClass": "./lib/help"    // ...  }  // ...}
From here there are two paths, implement the HelpBase abstract class yourself or overwrite the parts of the default Help class you want to customize (ex: how command usage is displayed). We recommend the latter approach but cover both in the new Help Classes docs.
Separating TOPICS & COMMANDS in the new default Help class​
Previously, topics and child commands were listed in help output under a single list heading called "COMMANDS". But we found this can be slightly confusing. Some topics are commands also (a.k.a. topic-commands) while others are simply organizational namespacing (and when ran just show their help).
The new default Help class splits the list of children into distinct lists of "TOPICS" and "COMMANDS", with the possibility of an item appearing in both if it a topic-command. This makes it clearer what is expected to be ran - "COMMANDS" - and what is providing structure - "TOPICS" - when looking at the help output.
VERSION  plugin-help-example/0.0.0 darwin-x64 node-v12.12.0USAGE  $ plugin-help-example [COMMAND]TOPICS  topic  this is a topic and has child topics or commandsCOMMANDS  hello  describe the command here  help   display help for plugin-help-example
We look forward to seeing what custom help features you implement in your oclif CLIs with this new feature!oclif TSLint to ESLint MigrationDecember 5, 2019 · 3 min readBack in February of this year, plans were announced to deprecate TSLint in favor of ESLint. TSLint's goal has become to work toward a “unified developer experience” by supporting ESLint development going forward.
What has changed in oclif​
To keep inline with the community, oclif has transitioned to ESLint for all our core libraries as well as all our official plugins.
Starting in v1.15.x, oclif will now optionally generate projects with ESLint for both TypeScript and JavaScript CLI’s.
ESLint does require Node to be on stable LTS version, at the time of writing, Node 8.10.x, Node 10.13.x & Node 12.x.x.
How does this affect you​
Existing CLI’s are unchanged, but any newly generated CLI's will only give the option of using ESLint. If you are running tslint in your CLI, we recommend you switch to ESLint as well.
In migrating our projects we took the following steps (for an example of these changes see this pull request).


Install eslint
$ yarn add eslint eslint-config-oclif eslint-config-oclif-typescript --dev


Add eslint related files


$ echo '{  "extends": [    "oclif",    "oclif-typescript"  ],  "rules": {  }}' > .eslintrc


Remove tslint and related packages
$ yarn remove @oclif/tslint tslint


Remove tslint related configuration files
$ rm tslint.json


Change lint script in our package.json from something like:
"lint": "tsc -p test --noEmit && tslint -p test -t stylish"
to
"lint": "eslint . --ext .ts --config .eslintrc"


To preserve the test compile (tsc -p test --noEmit) we also made the following updates to our scripts:
"pretest": "tsc -p test --noEmit"
In some cases we had our posttest duplicating the same steps as our lint script so it’s cleaner to have it reference the lint job directly with:
"posttest": "yarn lint"

Run yarn lint --fix. This attempts to auto-fix any linting violations automatically. In the case an auto-fix isn’t available it should be fixed manually or ignored (see the eslint configuration doc for more information)
Do a search in the codebase for tslint and remove any unnecessary tslint disabling comments, like:

/* tslint:disable:object-literal-sort-keys */
If you are on a version of Node that is not supported by ESLint, you will also need to update your Node engine. ESLint supports Node 8, 10, and 12 so you should upgrade to the most recent Node version compatible with your CLI and also supported by ESLint (see ESLint's Installation and Usage instructions).
When will this take effect​
These changes have taken effect in oclif v1.15.1. When you generate a new CLI or plugin it will now contain configuration for ESLint instead of TSLint.oclif's Current Node SupportOctober 31, 2019 · 3 min readTo maintain a healthy project trajectory, oclif follows and supports Node Active LTS release, currently Node 10 & Node 12. This means ensuring that oclif continues to play nice with coming Active LTS Node versions and other packages in the ecosystem. Moving forward also means leaving older versions behind. Starting in 2020, Node will stop maintaining Node 8 and it is our intent at that time to also follow suit. Let’s take a look at a few ways we will be supporting these changes.
CI Environments​
CLIs created with the oclif cli going forward will be generated with a CircleCI configuration with Node 10 & 12 and an Appveyor configuration using Node 10. We have also added Node latest to CircleCi to be an early warning detection against coming Node changes (Node latest is managed by CircleCI).
We have already updated every oclif repo's CI configs to reflect this.
If your existing CLI uses either Appveyor or CircleCI you can update your config files also, like so:
.circleci/config.yml​
Your CircleCI config should contain a node-latest job, aliased as test. From this, there should be two extensions of this job for the Active LTS Node versions, Node 10 and Node 12.
  node-10:    <<: *node-latest    docker:      - image: node:10  node-12:    <<: *node-latest    docker:      - image: node:12
Notice that these declarations only change the Docker Node images used to run that job.
Additionally, the jobs listed within workflows must also be updated to reflect our changes in configuration:
    jobs:      - node-latest      - node-10      - node-12
appveyor.yml​
For appveyor we are currently only testing the oldest Active LTS Node version, Node 10. Update the nodejs_version proppert in your appveyor.yml file to reflect this.
environment:  nodejs_version: "10"
Deprecating Node 8 & Updating packge.json engines​
In Jan 2020, Node will end its Node 8 maintenance. We will follow suit by setting the package.json engine property in oclif packages to >=10 and bumping the package's major versions.
Depending on how you ship your CLI you may wish to also bump the engines version in your CLI's package.json. You can read more about the implications of the engines property configuration in the npm documentation.
Also consider distributing your CLI with its own Node version.
Packaged Node Version​
When using dev-cli to pack your CLI it will use the Node version as specified in your package.json under the oclif.update.node.version property. This value should reflect an Active LTS Node version (dev-cli does not currently enforce versions).
Supporting the future​
As a community we may discover bumps along the way as we upgrade. If you notice something related to oclif please feel free to open an issue or submit a pull request under the relevant oclif package within the org.
We look forward to using the latest from Node and the community and keeping oclif healthy along the way.oclifconf 2019: A RecapSeptember 16, 2019 · 4 min readIn May, Heroku and Salesforce Open Source organized oclifconf, a conference for developers & product managers building CLI tools on top of the open source oclif framework. The speakers came from various tech companies, such as Adobe, Netlify, and Apollo, who have already built amazing CLI experiences. The topics covered everything from the incredible capabilities oclif has unlocked, to the community-built plugins extending its functionality, and even what the behavior of an adaptive CLI tool might look like.
Below is a listing of all of the talks from the event, along with a short summary. Enjoy!
The future of oclif by Jeff Dickey​

In its relatively short lifetime, oclif has already inspired many developers and companies to adopt its framework as a means for implementing their own command-line tooling. In this talk, Jeff Dickey, an oclif founding team member, recaps the project's history and inspiration. He also looks towards the future and outlines some features and improvements that the tool could adapt. This isn't so much a definitive roadmap of where oclif is headed, but rather, a call to inspiration for developers eager to contribute! And if you are interested in contributing, check out the open issues in the oclif GitHub repo and come say "Hello!" on Spectrum Chat.
Open Source Citizenship by Josh Simmons​

When it comes to open source, it's more than just individuals now. More and more frequently, large corporations are contributing to projects by donating to contributors, sponsoring events, or upstreaming contributions. But keeping open source projects and communities healthy requires more than just money and brainpower. Josh Simmons surveyed multiple open source communities and relays his findings as to what help maintainers and contributors actually need in this talk.
Building an enterprise-grade CLI with oclif by Thomas Dvornik​

Security and performance are all about trust. While oclif is an extremely extensible framework for building CLI tooling, there are additional requirements to fulfill for enterprise businesses to adopt it that might not be necessary for individual developers. Thomas Dvornik outlines what he and his colleagues at Salesforce have implemented as plugins to oclif to satisfy these needs, including encrypted OAuth, plugin signing, lazy loading dependencies, synchronizing weekly releases and deprecations across dozens of repositories, and establishing cross-team coding and documentation standards.
How Adobe I/O built an extensible CLI with oclif by Jesse MacFadyen​

Perhaps oclif's most appealing feature is its support for plugins. In Cordova's case, they've created a sophisticated telemetry system that helps Adobe developers see which commands users are using--and reports on which ones are erroring out. By embedding a feedback system into the tool, users are even able to quickly send their suggestions to a form, without ever leaving the terminal. Jesse MacFadyen demonstrates how oclif's plugin system can work beyond simply executing commands.
Integrating oclif with GraphQL and Apollo by Evans Hauser​

For Evans Hauser and the team at Apollo, oclif is best thought of as "React for the CLI." As a client paired with a strongly-typed API contract to a server, it can deliver structured and consistent commands to retrieve external data. What better mechanism to use for this transfer than GraphQL, a framework which empowers the client to ask precisely for the data it needs, and nothing more?
Adaptive Intent-based CLI State Machines by Shawn Wang​

In designing oclif, Jeff Dickey wrote out 12 CLI factors to keep in mind. In this talk, Shawn Wang outlines a 13th: state. State is hard, because it depends on context, and context depends on understanding what a user intends to do, not what they are asking. Shawn is working towards enabling oclif to better understand the commands a user has entered, so that it can predict and interpret future commands that might be entered next. This would enable CLI tools to not just interpret a users' commands, but to also interpret their intent.\n\nIntroducing `oclif init` commandApril 10, 2024 · 2 min readThanks to the contribution of @joshcanhelp we released a new command for the oclif CLI called oclif init in version 4.8.0
The oclif init command allows you to initialize oclif in an existing project directory by adding the bare minimum requirements: a few pieces of configuration, bin scripts, and a couple of dependencies (@oclif/core and ts-node). This is slightly different from oclif generate, which will create an entirely new oclif project based on our templates.
oclif init will add the following:

bin scripts: bin/run.js, bin/run.cmd, bin/dev.js, and bin/dev.cmd
oclif section to package.json with bin, dirname, commands, and topicSeparator set (See Configuring Your CLI for more)
@oclif/core to dependencies in your package.json (if it's not already there)
ts-node to devDependencies in your package.json (if it's not already there)

Once you've initialized oclif, you can use the bin scripts to execute your CLI. You can also use the other oclif commands like oclif generate command and oclif generate hook to start adding new functionality.

❯ oclif init --helpInitialize a new oclif CLIUSAGE  $ oclif init [--bin <value>] [--module-type ESM|CommonJS] [--package-manager npm|yarn|pnpm] [--topic-separator    colons|spaces] [-d <value>] [-y]FLAGS  -d, --output-dir=<value>        Directory to initialize the CLI in.  -y, --yes                       Use defaults for all prompts. Individual flags will override defaults.      --bin=<value>               Supply answer for prompt: Command bin name the CLI will export      --module-type=<option>      Supply answer for prompt: Select a module type                                  <options: ESM|CommonJS>      --package-manager=<option>  Supply answer for prompt: Select a package manager                                  <options: npm|yarn|pnpm>      --topic-separator=<option>  Supply answer for prompt: Select a topic separator                                  <options: colons|spaces>DESCRIPTION  Initialize a new oclif CLI  This will add the necessary oclif bin files, add oclif config to package.json, and install @oclif/core and ts-node.EXAMPLES  Initialize a new CLI in the current directory    $ oclif init  Initialize a new CLI in a different directory    $ oclif init --output-dir "/path/to/existing/project"  Supply answers for specific prompts    $ oclif init --topic-separator colons --bin mycli
Hope you enjoy the new command! If you come across any issues or have any new ideas for this command, head over to the oclif/oclif repo and open a new issue.
All our best,
The oclif teamoclif Spring 2024 UpdateMarch 29, 2024 · 4 min readHello oclif developers! It's been a while since we last uploaded a blog - and a lot has happened.
We've been focusing on these high-level areas over the past couple of years:

Improving @oclif/core
ESM Support
Improving and revitalizing oclif.io
Re-engaging the oclif community

Improving @oclif/core​
Since we announced @oclif/core over three years ago, we've released two new major versions, each packed with lots of features that we're really excited about.
Here are some of these changes:

Full support for ESM and interoperability with CommonJS (more on this topic below).
Configurable command discovery strategies that give you more control over how commands are loaded at runtime. Check out the docs.
A new preparse hook that allows you to manipulate the provided arguments before they're parsed. Salesforce used this hook to implement a neat --flags-dir feature that translates local files into flags.
A new Performance class that you can use to track performance inside of @oclif/core and your own CLI or plugin. Check out the docs.
A new flag type, Flags.option, that lets you define a flag with a preset list of options. Typescript then uses the options to infer the flag's type.
Flags now have a relationship property that allows you to define more complex relationships between flags. Check out the flags docs for more information.
Flags now have a defaultHelp property that allows you to set the human readable default value in the command help. This property is useful when your flag's parse method returns a complex type, such as an object or a class. Check out the flags docs for more.
Commands now have a hiddenAliases property that allows you to define aliases that you want to hide from the user. The property is super helpful when you're trying to wean users off a deprecated command.
You can now use bun or tsx as dev runtimes (as opposed to node or ts-node).
A command's usage, args, and flags are now shown whenever a user forgets to provide a required arg or flag, or when they provided a non-existent flag.

If you need help migrating to the latest version, head over to core's README which has links to the migration guides. Feel free to open a new discussion if you need more hands-on help from us or the community.
ESM Support​
Version 3 of @oclif/core introduced full support for developing ESM plugins and CLIs. It also offered full support for interoperability between CommonJS and ESM plugins.
Put more simply, you can now migrate your CLI to ESM while keeping individual plugins in CommonJS (or vice versa). The upgrade path is now much simpler for you. You also don't need to worry about any community plugins that have migrated to ESM before you did (such as all the @oclif plugins) or are staunchly sticking with CommonJS for the foreseeable future.
Read more about this topic here.
Improving and Revitalizing oclif.io​
Another area of focus for us has been improving our documentation site, oclif.io.
While improving the quality and accuracy of the documentation was our priority, we also took the time to upgrade to the latest version of docusaurus. This new version gave our site a much-needed facelift, as well as cool new features such as dark mode and announcements.
If you have any feedback or are running into issues, we want to hear about it. Just create an issue in the oclif.io repo.
Re-engaging the oclif Community​
Lastly, our biggest priority at the moment is to re-engage the oclif community. We understand how frustrating it has been over the years to see your issues and pull requests go unacknowledged. We apologize for not prioritizing the community, and are earnestly trying to make sure that every issue and pull request gets the attention it deserves going forward.
We also opened up GitHub discussions for @oclif/core and the oclif CLI, where you can now post your questions or ideas. We hope you take advantage of them, we love hearing from you!
One last thing: we intend to publicly post our roadmap so you have more visibility into what we're working on. Stay tuned!
All our best,
The oclif teamAnnouncing oclif v2!January 12, 2022 · 5 min readHello and happy new year! It's our great pleasure to announce that we have released oclif v2, which uses the new @oclif/core library! 🎉
oclif v2 includes many changes that improve the experience of both creating and using an oclif CLI.
Going forward, we don't plan to make any updates to oclif v1 and its corresponding libraries, except for critical security fixes. See the compatibility matrix for a list of these libraries. In order to give developers time to migrate from v1 to v2, we're not completely dropping support yet. But at some point in the future we'll archive the v1 repositories and deprecate their versions on npm.
What’s changing?​
Repository Changes​
All repositories under the oclif org now use main as their primary branch and oclif-v1 as the legacy branch. The main  branch corresponds to oclif v2 and the oclif-v1 branch to oclif v1. If you find any repos that don’t have a main branch, you can safely assume that they're not used in oclif v2 and will be deprecated in the future.
Consolidating Tools & Libraries​
The oclif-dev CLI has now been incorporated into oclif. You now no longer need to install a separate package to manage your entire CLI’s lifecycle.
The following libraries have been consolidated under @oclif/core and will be deprecated at some point in the future. Read the migration guide to learn how to update your CLI or plugin to use the new core library.

@oclif/command
@oclif/config
@oclif/error
@oclif/help
@oclif/parser

No more single vs multi command CLIs​
There's only one "type" of oclif v2 CLI, but it can have as few or as many commands as a developer wants. As a result, there’s only one command to generate CLIs, oclif generate, as opposed to the old oclif single and oclif multi commands.
Node > 12​
To ensure oclif CLIs are as secure as possible, all v2 libraries and plugins support only Node 12 or higher as of now. Going forward, they'll support only Node Maintenance or higher, as defined by Node's release schedule here: https://nodejs.org/en/about/releases/.
What’s new?​
New example CLI​
oclif-hello-world is our new example repo. This is also the repo that's used as a template when running oclif generate to create a new CLI. This repo will always be able to be referenced as an example of what an oclif v2 CLI should look like.
Spaced commands​
oclif CLIs can now use spaces, instead of colons, to separate topics and subcommands. To enable this feature, simply add “topicSeparator": " " to the oclif config in your package.json. See an example in our example repo.
// Old commands that use :$ mycli do:something
// New spaced commands$ mycli do something

Note: Spaced commands are backwards compatible. So if you enable spaced commands for your CLI, users will still be able to use : as a separator. This ensures that any existing scripts don't break.

New Help Output​
We’ve revamped the way command help is outputted to the terminal, making it both easier to implement and easier to read. See the difference between the old help output on the left and the new help output on the right in the screenshots below.
oclif v1oclif v2
Notice that there are new sections for flags and global flags, examples are displayed with better spacing, and there is a section at the bottom called Configuration Variables. This Configuration Variables section is not part of the new help by default. But we've added support for custom help sections, which is what the sf CLI uses to create the new section.
Async Command Parsing​
We’ve also improved the performance of new CLIs by rewriting how commands are parsed on initialization. The new parser is asynchronous, which makes CLIs with a lot of commands or installed  plugins much faster.
What’s coming next?​
Part of our charter for the release of oclif v2 includes improving our engagement with the oclif community. We know that over the past couple of years we’ve reduced our involvement, and a lot of issues and PRs have languished in limbo. Hopefully you’ve already seen increased activity and responses from oclif maintainers recently, but if you haven’t, please don’t hesitate to ping us by tagging @admins in oclif repos.
We also want to start interviewing members of the oclif community to acquire feedback and prioritize the features and fixes you deem most important!
Best,
The oclif team

Reference material​
Migration Guide​
This guide explains how to upgrade a CLI or plugin from the old oclif v1 libraries to the new @oclif/core library that oclif v2 uses.
https://github.com/oclif/core/blob/main/MIGRATION.md
Compatibility Matrix​
The following matrix shows how the v1 libraries and plugins relate to the new v2 ones. Use this matrix as a guide to know what to drop and which versions to switch when upgrading your plugins and CLIs to v2.
oclif "v1"oclif "v2"Utility CLIsoclif@<2@oclif/dev-cli@<2oclif@>=2Main packages@oclif/command@oclif/config@oclif/errors@oclif/parser@oclif/plugin-help@oclif/core@>=1Node LTSNode v8-14Node v12+ (at time of writing)TypeScripttypescript@<4typescript@>=4Main plugins@oclif/plugin-autocomplete@<1@oclif/plugin-commands@<2@oclif/plugin-help@<4@oclif/plugin-not-found@<2@oclif/plugin-plugins@<2@oclif/plugin-update@<2plugin-warn-if-update-available@<2plugin-which@<2@oclif/plugin-autocomplete@>=1@oclif/plugin-commands@>=2@oclif/plugin-help@>=4@oclif/plugin-not-found@>=2@oclif/plugin-plugins@>=2@oclif/plugin-update@>=2@oclif/plugin-warn-if-update-available@>=2@oclif/plugin-which@>=2Introducing @oclif/coreMarch 1, 2021 · 3 min readGreetings!
We hope this blog post finds you well.
Introducing...​
We are excited to announce the next iteration of the oclif project today: @oclif/core.
We have learned a lot in the last three years of developing oclif, developing on oclif and supporting millions of command runs a day via Heroku and Salesforce CLIs.
@oclif/core ("Core") simplifies the oclif development experience and introduces highly requested new features.
Core combines the essential oclif packages into one "core" package, aptly named @oclif/core.
Core also introduces:

A default command option
Colon or space command syntax
Async command parsing
Command piping to arguments

With the introduction of default command functionality, Core simplifies the oclif project and removes the notion of single or multi command CLIs. Core CLIs can have 1 or many commands.
Along with Core, we moved the oclif-dev CLI into the oclif CLI creating a single "utility" CLI. This CLI also introduces a new AWS S3 compatible publishing scheme.
What to expect in the near future​
Core is in pre-release beta and being actively developed for new internal Salesforce CLIs.
Much documentation needs to be written in the coming months including migration paths. Migration onto Core should be as painless as possible with many exports remaining entirely unchanged. Look for forthcoming blog posts and documentation on oclif.io.
Early this summer, tentively June 1, we will release Core v1. Core's release will coincide with major bumps to many other oclif plugin packages. See the compatibility matrix below.
At Core's v1 release, the current "main" oclif packages (namely: command, config, errors & parser) will go into maintenance mode until Jan 2022. They will receive only bug and security fixes and they remain compatible with current versions of the oclif and oclif-dev CLIs. Afterwhich, they will be archived.
Companioning Core, the next major release of the oclif CLI (literally oclif@2) will generate Core CLIs.
Going forward​
We are excited to release Core! We invite you to poke around the Core repo. It may appear to be a big change but Core keeps what you already enjoy about oclif while reducing development complexity, project dependencies, package coupling and bundle size and introduces many requested features previously too prickly to weave into the current oclif architecture.
Best,
The oclif team
Reference: Compatibility matrix​
oclif "v1"oclif "Core"Utility CLIsoclif@<2@oclif/dev-cli@<2oclif@>=2Main packages@oclif/core@<2@oclif/config@<2@oclif/errors@<2@oclif/parser@<4@oclif/plugin-help@<4@oclif/core@>=1Node LTSNode v8-14Node v12+TypeScripttypescript@<4typescript@>=4Main plugins@oclif/plugin-autocomplete@<1@oclif/plugin-commands@<2@oclif/plugin-help@<4@oclif/plugin-not-found@<2@oclif/plugin-plugins@<2@oclif/plugin-update@<2plugin-warn-if-update-available@<2plugin-which@<2@oclif/plugin-autocomplete@>=2@oclif/plugin-commands@>=2@oclif/plugin-help@>=4@oclif/plugin-not-found@>=2@oclif/plugin-plugins@>=2@oclif/plugin-update@>=2@oclif/plugin-warn-if-update-available@>=2@oclif/plugin-which@>=2oclif Summer 2020 UpdateAugust 26, 2020 · 2 min readHello oclif developers! We hope you are all doing well.
Earlier this year, we started our planning for oclifconf v2 and, like all conference, had to change course. We opted not to hold a virtual conference, however, we wanted to take some time to highlight a few oclif features shipped this year.
Feature: Help templating​
One of the most requested features, help templating enables oclif developers to customize the help output for their CLI.
Read the announcement.
Feature: Custom error delegation​
This feature both improved how oclif throws and handles errors and allows oclif developers to overwrite or interject in oclif’s error handling.
Read the announcement.
Feature: postrun hooks​
We have added a new lifecycle event postrun. Your CLI can now run a hook after a command has ran.
See our hook documentation.
Feature: Root index command​
Previously, oclif would display CLI help if only the binary name with no command ID was invoked, oclif now supports a "root index" command. If present, a command defined at src/commands/index.ts will be run if no command ID is found.
1 million weekly downloads​
While exact oclif usage metrics are hard to pin down, we use npm download statistics of oclif packages as a rough approximation. Earlier this year, oclif's command package hit 1 million weekly downloads for the first time!
This year has been presented its challenges on everyone. We want to thank you, oclif developers, whom have taken the time to use and improve the oclif project. We look forward to seeing you all - in person - in the future!
All our best,
The oclif teamPretty Printable ErrorsJuly 1, 2020 · One min readOften CLIs are used as handy tools and when things go wrong it’s useful to have additional context. In oclif we have added a couple of additional properties that can show extra context to the users when an error is displayed. The code, ref and suggestions will now be displayed if they are included. This will work with an existing oclif CLI by adding the latest @oclif/errors and @oclif/core to the CLI's package.json dependencies.
For example, using this.error with the additional properties:
class TestError extends Command {  async run() {    this.error("An error has occurred!", {      code: "OCLIF_ERR",      ref: "https://oclif.io/docs/commands#thiserrormessage-string--error-options-code-string-exit-number",      suggestions: ["Use these extra properties to provide additional context"],    })  }}
would result with the following output:
›   Error: An error has occurred!›   Code: OCLIF_ERR›   Try this: Use these extra properties to provide additional context›   Reference: https://oclif.io/docs/commands#thiserrormessage-string--error-options-code-string-exit-number
If these properties are not provided then nothing changes and the CLI will continue to display the single error message output as it did before. Additionally, as part of this exercise we’ve added documentation around Error Handling in oclif which should come in handy if the need arises to extend oclif’s default handling of errors.Customizing Help in oclifMay 5, 2020 · 2 min readOut of the box oclif provides a great help experience for CLIs.
But what if, as an oclif developer, you want to customize some or all of the output?
You can now customize your CLI's help output by implementing the HelpBase abstract class.
Getting started with custom help​
If you have not done so yet, update @oclif/core.
$ yarn add --latest @oclif/core
To get started, first define the filepath to your help class in oclif's config in package.json. This is a relative path to the help class, without a file extension.
For this example, the help class will be created in a file at "[project root]/src/help.ts".
{  // ...  "oclif": {    "helpClass": "./lib/help"    // ...  }  // ...}
From here there are two paths, implement the HelpBase abstract class yourself or overwrite the parts of the default Help class you want to customize (ex: how command usage is displayed). We recommend the latter approach but cover both in the new Help Classes docs.
Separating TOPICS & COMMANDS in the new default Help class​
Previously, topics and child commands were listed in help output under a single list heading called "COMMANDS". But we found this can be slightly confusing. Some topics are commands also (a.k.a. topic-commands) while others are simply organizational namespacing (and when ran just show their help).
The new default Help class splits the list of children into distinct lists of "TOPICS" and "COMMANDS", with the possibility of an item appearing in both if it a topic-command. This makes it clearer what is expected to be ran - "COMMANDS" - and what is providing structure - "TOPICS" - when looking at the help output.
VERSION  plugin-help-example/0.0.0 darwin-x64 node-v12.12.0USAGE  $ plugin-help-example [COMMAND]TOPICS  topic  this is a topic and has child topics or commandsCOMMANDS  hello  describe the command here  help   display help for plugin-help-example
We look forward to seeing what custom help features you implement in your oclif CLIs with this new feature!oclif TSLint to ESLint MigrationDecember 5, 2019 · 3 min readBack in February of this year, plans were announced to deprecate TSLint in favor of ESLint. TSLint's goal has become to work toward a “unified developer experience” by supporting ESLint development going forward.
What has changed in oclif​
To keep inline with the community, oclif has transitioned to ESLint for all our core libraries as well as all our official plugins.
Starting in v1.15.x, oclif will now optionally generate projects with ESLint for both TypeScript and JavaScript CLI’s.
ESLint does require Node to be on stable LTS version, at the time of writing, Node 8.10.x, Node 10.13.x & Node 12.x.x.
How does this affect you​
Existing CLI’s are unchanged, but any newly generated CLI's will only give the option of using ESLint. If you are running tslint in your CLI, we recommend you switch to ESLint as well.
In migrating our projects we took the following steps (for an example of these changes see this pull request).


Install eslint
$ yarn add eslint eslint-config-oclif eslint-config-oclif-typescript --dev


Add eslint related files


$ echo '{  "extends": [    "oclif",    "oclif-typescript"  ],  "rules": {  }}' > .eslintrc


Remove tslint and related packages
$ yarn remove @oclif/tslint tslint


Remove tslint related configuration files
$ rm tslint.json


Change lint script in our package.json from something like:
"lint": "tsc -p test --noEmit && tslint -p test -t stylish"
to
"lint": "eslint . --ext .ts --config .eslintrc"


To preserve the test compile (tsc -p test --noEmit) we also made the following updates to our scripts:
"pretest": "tsc -p test --noEmit"
In some cases we had our posttest duplicating the same steps as our lint script so it’s cleaner to have it reference the lint job directly with:
"posttest": "yarn lint"

Run yarn lint --fix. This attempts to auto-fix any linting violations automatically. In the case an auto-fix isn’t available it should be fixed manually or ignored (see the eslint configuration doc for more information)
Do a search in the codebase for tslint and remove any unnecessary tslint disabling comments, like:

/* tslint:disable:object-literal-sort-keys */
If you are on a version of Node that is not supported by ESLint, you will also need to update your Node engine. ESLint supports Node 8, 10, and 12 so you should upgrade to the most recent Node version compatible with your CLI and also supported by ESLint (see ESLint's Installation and Usage instructions).
When will this take effect​
These changes have taken effect in oclif v1.15.1. When you generate a new CLI or plugin it will now contain configuration for ESLint instead of TSLint.oclif's Current Node SupportOctober 31, 2019 · 3 min readTo maintain a healthy project trajectory, oclif follows and supports Node Active LTS release, currently Node 10 & Node 12. This means ensuring that oclif continues to play nice with coming Active LTS Node versions and other packages in the ecosystem. Moving forward also means leaving older versions behind. Starting in 2020, Node will stop maintaining Node 8 and it is our intent at that time to also follow suit. Let’s take a look at a few ways we will be supporting these changes.
CI Environments​
CLIs created with the oclif cli going forward will be generated with a CircleCI configuration with Node 10 & 12 and an Appveyor configuration using Node 10. We have also added Node latest to CircleCi to be an early warning detection against coming Node changes (Node latest is managed by CircleCI).
We have already updated every oclif repo's CI configs to reflect this.
If your existing CLI uses either Appveyor or CircleCI you can update your config files also, like so:
.circleci/config.yml​
Your CircleCI config should contain a node-latest job, aliased as test. From this, there should be two extensions of this job for the Active LTS Node versions, Node 10 and Node 12.
  node-10:    <<: *node-latest    docker:      - image: node:10  node-12:    <<: *node-latest    docker:      - image: node:12
Notice that these declarations only change the Docker Node images used to run that job.
Additionally, the jobs listed within workflows must also be updated to reflect our changes in configuration:
    jobs:      - node-latest      - node-10      - node-12
appveyor.yml​
For appveyor we are currently only testing the oldest Active LTS Node version, Node 10. Update the nodejs_version proppert in your appveyor.yml file to reflect this.
environment:  nodejs_version: "10"
Deprecating Node 8 & Updating packge.json engines​
In Jan 2020, Node will end its Node 8 maintenance. We will follow suit by setting the package.json engine property in oclif packages to >=10 and bumping the package's major versions.
Depending on how you ship your CLI you may wish to also bump the engines version in your CLI's package.json. You can read more about the implications of the engines property configuration in the npm documentation.
Also consider distributing your CLI with its own Node version.
Packaged Node Version​
When using dev-cli to pack your CLI it will use the Node version as specified in your package.json under the oclif.update.node.version property. This value should reflect an Active LTS Node version (dev-cli does not currently enforce versions).
Supporting the future​
As a community we may discover bumps along the way as we upgrade. If you notice something related to oclif please feel free to open an issue or submit a pull request under the relevant oclif package within the org.
We look forward to using the latest from Node and the community and keeping oclif healthy along the way.oclifconf 2019: A RecapSeptember 16, 2019 · 4 min readIn May, Heroku and Salesforce Open Source organized oclifconf, a conference for developers & product managers building CLI tools on top of the open source oclif framework. The speakers came from various tech companies, such as Adobe, Netlify, and Apollo, who have already built amazing CLI experiences. The topics covered everything from the incredible capabilities oclif has unlocked, to the community-built plugins extending its functionality, and even what the behavior of an adaptive CLI tool might look like.
Below is a listing of all of the talks from the event, along with a short summary. Enjoy!
The future of oclif by Jeff Dickey​

In its relatively short lifetime, oclif has already inspired many developers and companies to adopt its framework as a means for implementing their own command-line tooling. In this talk, Jeff Dickey, an oclif founding team member, recaps the project's history and inspiration. He also looks towards the future and outlines some features and improvements that the tool could adapt. This isn't so much a definitive roadmap of where oclif is headed, but rather, a call to inspiration for developers eager to contribute! And if you are interested in contributing, check out the open issues in the oclif GitHub repo and come say "Hello!" on Spectrum Chat.
Open Source Citizenship by Josh Simmons​

When it comes to open source, it's more than just individuals now. More and more frequently, large corporations are contributing to projects by donating to contributors, sponsoring events, or upstreaming contributions. But keeping open source projects and communities healthy requires more than just money and brainpower. Josh Simmons surveyed multiple open source communities and relays his findings as to what help maintainers and contributors actually need in this talk.
Building an enterprise-grade CLI with oclif by Thomas Dvornik​

Security and performance are all about trust. While oclif is an extremely extensible framework for building CLI tooling, there are additional requirements to fulfill for enterprise businesses to adopt it that might not be necessary for individual developers. Thomas Dvornik outlines what he and his colleagues at Salesforce have implemented as plugins to oclif to satisfy these needs, including encrypted OAuth, plugin signing, lazy loading dependencies, synchronizing weekly releases and deprecations across dozens of repositories, and establishing cross-team coding and documentation standards.
How Adobe I/O built an extensible CLI with oclif by Jesse MacFadyen​

Perhaps oclif's most appealing feature is its support for plugins. In Cordova's case, they've created a sophisticated telemetry system that helps Adobe developers see which commands users are using--and reports on which ones are erroring out. By embedding a feedback system into the tool, users are even able to quickly send their suggestions to a form, without ever leaving the terminal. Jesse MacFadyen demonstrates how oclif's plugin system can work beyond simply executing commands.
Integrating oclif with GraphQL and Apollo by Evans Hauser​

For Evans Hauser and the team at Apollo, oclif is best thought of as "React for the CLI." As a client paired with a strongly-typed API contract to a server, it can deliver structured and consistent commands to retrieve external data. What better mechanism to use for this transfer than GraphQL, a framework which empowers the client to ask precisely for the data it needs, and nothing more?
Adaptive Intent-based CLI State Machines by Shawn Wang​

In designing oclif, Jeff Dickey wrote out 12 CLI factors to keep in mind. In this talk, Shawn Wang outlines a 13th: state. State is hard, because it depends on context, and context depends on understanding what a user intends to do, not what they are asking. Shawn is working towards enabling oclif to better understand the commands a user has entered, so that it can predict and interpret future commands that might be entered next. This would enable CLI tools to not just interpret a users' commands, but to also interpret their intent.Older Entries\n\n\n\nIntroducing `oclif init` commandApril 10, 2024 · 2 min readThanks to the contribution of @joshcanhelp we released a new command for the oclif CLI called oclif init in version 4.8.0
The oclif init command allows you to initialize oclif in an existing project directory by adding the bare minimum requirements: a few pieces of configuration, bin scripts, and a couple of dependencies (@oclif/core and ts-node). This is slightly different from oclif generate, which will create an entirely new oclif project based on our templates.
oclif init will add the following:

bin scripts: bin/run.js, bin/run.cmd, bin/dev.js, and bin/dev.cmd
oclif section to package.json with bin, dirname, commands, and topicSeparator set (See Configuring Your CLI for more)
@oclif/core to dependencies in your package.json (if it's not already there)
ts-node to devDependencies in your package.json (if it's not already there)

Once you've initialized oclif, you can use the bin scripts to execute your CLI. You can also use the other oclif commands like oclif generate command and oclif generate hook to start adding new functionality.

❯ oclif init --helpInitialize a new oclif CLIUSAGE  $ oclif init [--bin <value>] [--module-type ESM|CommonJS] [--package-manager npm|yarn|pnpm] [--topic-separator    colons|spaces] [-d <value>] [-y]FLAGS  -d, --output-dir=<value>        Directory to initialize the CLI in.  -y, --yes                       Use defaults for all prompts. Individual flags will override defaults.      --bin=<value>               Supply answer for prompt: Command bin name the CLI will export      --module-type=<option>      Supply answer for prompt: Select a module type                                  <options: ESM|CommonJS>      --package-manager=<option>  Supply answer for prompt: Select a package manager                                  <options: npm|yarn|pnpm>      --topic-separator=<option>  Supply answer for prompt: Select a topic separator                                  <options: colons|spaces>DESCRIPTION  Initialize a new oclif CLI  This will add the necessary oclif bin files, add oclif config to package.json, and install @oclif/core and ts-node.EXAMPLES  Initialize a new CLI in the current directory    $ oclif init  Initialize a new CLI in a different directory    $ oclif init --output-dir "/path/to/existing/project"  Supply answers for specific prompts    $ oclif init --topic-separator colons --bin mycli
Hope you enjoy the new command! If you come across any issues or have any new ideas for this command, head over to the oclif/oclif repo and open a new issue.
All our best,
The oclif teamoclif Spring 2024 UpdateMarch 29, 2024 · 4 min readHello oclif developers! It's been a while since we last uploaded a blog - and a lot has happened.
We've been focusing on these high-level areas over the past couple of years:

Improving @oclif/core
ESM Support
Improving and revitalizing oclif.io
Re-engaging the oclif community

Improving @oclif/core​
Since we announced @oclif/core over three years ago, we've released two new major versions, each packed with lots of features that we're really excited about.
Here are some of these changes:

Full support for ESM and interoperability with CommonJS (more on this topic below).
Configurable command discovery strategies that give you more control over how commands are loaded at runtime. Check out the docs.
A new preparse hook that allows you to manipulate the provided arguments before they're parsed. Salesforce used this hook to implement a neat --flags-dir feature that translates local files into flags.
A new Performance class that you can use to track performance inside of @oclif/core and your own CLI or plugin. Check out the docs.
A new flag type, Flags.option, that lets you define a flag with a preset list of options. Typescript then uses the options to infer the flag's type.
Flags now have a relationship property that allows you to define more complex relationships between flags. Check out the flags docs for more information.
Flags now have a defaultHelp property that allows you to set the human readable default value in the command help. This property is useful when your flag's parse method returns a complex type, such as an object or a class. Check out the flags docs for more.
Commands now have a hiddenAliases property that allows you to define aliases that you want to hide from the user. The property is super helpful when you're trying to wean users off a deprecated command.
You can now use bun or tsx as dev runtimes (as opposed to node or ts-node).
A command's usage, args, and flags are now shown whenever a user forgets to provide a required arg or flag, or when they provided a non-existent flag.

If you need help migrating to the latest version, head over to core's README which has links to the migration guides. Feel free to open a new discussion if you need more hands-on help from us or the community.
ESM Support​
Version 3 of @oclif/core introduced full support for developing ESM plugins and CLIs. It also offered full support for interoperability between CommonJS and ESM plugins.
Put more simply, you can now migrate your CLI to ESM while keeping individual plugins in CommonJS (or vice versa). The upgrade path is now much simpler for you. You also don't need to worry about any community plugins that have migrated to ESM before you did (such as all the @oclif plugins) or are staunchly sticking with CommonJS for the foreseeable future.
Read more about this topic here.
Improving and Revitalizing oclif.io​
Another area of focus for us has been improving our documentation site, oclif.io.
While improving the quality and accuracy of the documentation was our priority, we also took the time to upgrade to the latest version of docusaurus. This new version gave our site a much-needed facelift, as well as cool new features such as dark mode and announcements.
If you have any feedback or are running into issues, we want to hear about it. Just create an issue in the oclif.io repo.
Re-engaging the oclif Community​
Lastly, our biggest priority at the moment is to re-engage the oclif community. We understand how frustrating it has been over the years to see your issues and pull requests go unacknowledged. We apologize for not prioritizing the community, and are earnestly trying to make sure that every issue and pull request gets the attention it deserves going forward.
We also opened up GitHub discussions for @oclif/core and the oclif CLI, where you can now post your questions or ideas. We hope you take advantage of them, we love hearing from you!
One last thing: we intend to publicly post our roadmap so you have more visibility into what we're working on. Stay tuned!
All our best,
The oclif teamAnnouncing oclif v2!January 12, 2022 · 5 min readHello and happy new year! It's our great pleasure to announce that we have released oclif v2, which uses the new @oclif/core library! 🎉
oclif v2 includes many changes that improve the experience of both creating and using an oclif CLI.
Going forward, we don't plan to make any updates to oclif v1 and its corresponding libraries, except for critical security fixes. See the compatibility matrix for a list of these libraries. In order to give developers time to migrate from v1 to v2, we're not completely dropping support yet. But at some point in the future we'll archive the v1 repositories and deprecate their versions on npm.
What’s changing?​
Repository Changes​
All repositories under the oclif org now use main as their primary branch and oclif-v1 as the legacy branch. The main  branch corresponds to oclif v2 and the oclif-v1 branch to oclif v1. If you find any repos that don’t have a main branch, you can safely assume that they're not used in oclif v2 and will be deprecated in the future.
Consolidating Tools & Libraries​
The oclif-dev CLI has now been incorporated into oclif. You now no longer need to install a separate package to manage your entire CLI’s lifecycle.
The following libraries have been consolidated under @oclif/core and will be deprecated at some point in the future. Read the migration guide to learn how to update your CLI or plugin to use the new core library.

@oclif/command
@oclif/config
@oclif/error
@oclif/help
@oclif/parser

No more single vs multi command CLIs​
There's only one "type" of oclif v2 CLI, but it can have as few or as many commands as a developer wants. As a result, there’s only one command to generate CLIs, oclif generate, as opposed to the old oclif single and oclif multi commands.
Node > 12​
To ensure oclif CLIs are as secure as possible, all v2 libraries and plugins support only Node 12 or higher as of now. Going forward, they'll support only Node Maintenance or higher, as defined by Node's release schedule here: https://nodejs.org/en/about/releases/.
What’s new?​
New example CLI​
oclif-hello-world is our new example repo. This is also the repo that's used as a template when running oclif generate to create a new CLI. This repo will always be able to be referenced as an example of what an oclif v2 CLI should look like.
Spaced commands​
oclif CLIs can now use spaces, instead of colons, to separate topics and subcommands. To enable this feature, simply add “topicSeparator": " " to the oclif config in your package.json. See an example in our example repo.
// Old commands that use :$ mycli do:something
// New spaced commands$ mycli do something

Note: Spaced commands are backwards compatible. So if you enable spaced commands for your CLI, users will still be able to use : as a separator. This ensures that any existing scripts don't break.

New Help Output​
We’ve revamped the way command help is outputted to the terminal, making it both easier to implement and easier to read. See the difference between the old help output on the left and the new help output on the right in the screenshots below.
oclif v1oclif v2
Notice that there are new sections for flags and global flags, examples are displayed with better spacing, and there is a section at the bottom called Configuration Variables. This Configuration Variables section is not part of the new help by default. But we've added support for custom help sections, which is what the sf CLI uses to create the new section.
Async Command Parsing​
We’ve also improved the performance of new CLIs by rewriting how commands are parsed on initialization. The new parser is asynchronous, which makes CLIs with a lot of commands or installed  plugins much faster.
What’s coming next?​
Part of our charter for the release of oclif v2 includes improving our engagement with the oclif community. We know that over the past couple of years we’ve reduced our involvement, and a lot of issues and PRs have languished in limbo. Hopefully you’ve already seen increased activity and responses from oclif maintainers recently, but if you haven’t, please don’t hesitate to ping us by tagging @admins in oclif repos.
We also want to start interviewing members of the oclif community to acquire feedback and prioritize the features and fixes you deem most important!
Best,
The oclif team

Reference material​
Migration Guide​
This guide explains how to upgrade a CLI or plugin from the old oclif v1 libraries to the new @oclif/core library that oclif v2 uses.
https://github.com/oclif/core/blob/main/MIGRATION.md
Compatibility Matrix​
The following matrix shows how the v1 libraries and plugins relate to the new v2 ones. Use this matrix as a guide to know what to drop and which versions to switch when upgrading your plugins and CLIs to v2.
oclif "v1"oclif "v2"Utility CLIsoclif@<2@oclif/dev-cli@<2oclif@>=2Main packages@oclif/command@oclif/config@oclif/errors@oclif/parser@oclif/plugin-help@oclif/core@>=1Node LTSNode v8-14Node v12+ (at time of writing)TypeScripttypescript@<4typescript@>=4Main plugins@oclif/plugin-autocomplete@<1@oclif/plugin-commands@<2@oclif/plugin-help@<4@oclif/plugin-not-found@<2@oclif/plugin-plugins@<2@oclif/plugin-update@<2plugin-warn-if-update-available@<2plugin-which@<2@oclif/plugin-autocomplete@>=1@oclif/plugin-commands@>=2@oclif/plugin-help@>=4@oclif/plugin-not-found@>=2@oclif/plugin-plugins@>=2@oclif/plugin-update@>=2@oclif/plugin-warn-if-update-available@>=2@oclif/plugin-which@>=2Introducing @oclif/coreMarch 1, 2021 · 3 min readGreetings!
We hope this blog post finds you well.
Introducing...​
We are excited to announce the next iteration of the oclif project today: @oclif/core.
We have learned a lot in the last three years of developing oclif, developing on oclif and supporting millions of command runs a day via Heroku and Salesforce CLIs.
@oclif/core ("Core") simplifies the oclif development experience and introduces highly requested new features.
Core combines the essential oclif packages into one "core" package, aptly named @oclif/core.
Core also introduces:

A default command option
Colon or space command syntax
Async command parsing
Command piping to arguments

With the introduction of default command functionality, Core simplifies the oclif project and removes the notion of single or multi command CLIs. Core CLIs can have 1 or many commands.
Along with Core, we moved the oclif-dev CLI into the oclif CLI creating a single "utility" CLI. This CLI also introduces a new AWS S3 compatible publishing scheme.
What to expect in the near future​
Core is in pre-release beta and being actively developed for new internal Salesforce CLIs.
Much documentation needs to be written in the coming months including migration paths. Migration onto Core should be as painless as possible with many exports remaining entirely unchanged. Look for forthcoming blog posts and documentation on oclif.io.
Early this summer, tentively June 1, we will release Core v1. Core's release will coincide with major bumps to many other oclif plugin packages. See the compatibility matrix below.
At Core's v1 release, the current "main" oclif packages (namely: command, config, errors & parser) will go into maintenance mode until Jan 2022. They will receive only bug and security fixes and they remain compatible with current versions of the oclif and oclif-dev CLIs. Afterwhich, they will be archived.
Companioning Core, the next major release of the oclif CLI (literally oclif@2) will generate Core CLIs.
Going forward​
We are excited to release Core! We invite you to poke around the Core repo. It may appear to be a big change but Core keeps what you already enjoy about oclif while reducing development complexity, project dependencies, package coupling and bundle size and introduces many requested features previously too prickly to weave into the current oclif architecture.
Best,
The oclif team
Reference: Compatibility matrix​
oclif "v1"oclif "Core"Utility CLIsoclif@<2@oclif/dev-cli@<2oclif@>=2Main packages@oclif/core@<2@oclif/config@<2@oclif/errors@<2@oclif/parser@<4@oclif/plugin-help@<4@oclif/core@>=1Node LTSNode v8-14Node v12+TypeScripttypescript@<4typescript@>=4Main plugins@oclif/plugin-autocomplete@<1@oclif/plugin-commands@<2@oclif/plugin-help@<4@oclif/plugin-not-found@<2@oclif/plugin-plugins@<2@oclif/plugin-update@<2plugin-warn-if-update-available@<2plugin-which@<2@oclif/plugin-autocomplete@>=2@oclif/plugin-commands@>=2@oclif/plugin-help@>=4@oclif/plugin-not-found@>=2@oclif/plugin-plugins@>=2@oclif/plugin-update@>=2@oclif/plugin-warn-if-update-available@>=2@oclif/plugin-which@>=2oclif Summer 2020 UpdateAugust 26, 2020 · 2 min readHello oclif developers! We hope you are all doing well.
Earlier this year, we started our planning for oclifconf v2 and, like all conference, had to change course. We opted not to hold a virtual conference, however, we wanted to take some time to highlight a few oclif features shipped this year.
Feature: Help templating​
One of the most requested features, help templating enables oclif developers to customize the help output for their CLI.
Read the announcement.
Feature: Custom error delegation​
This feature both improved how oclif throws and handles errors and allows oclif developers to overwrite or interject in oclif’s error handling.
Read the announcement.
Feature: postrun hooks​
We have added a new lifecycle event postrun. Your CLI can now run a hook after a command has ran.
See our hook documentation.
Feature: Root index command​
Previously, oclif would display CLI help if only the binary name with no command ID was invoked, oclif now supports a "root index" command. If present, a command defined at src/commands/index.ts will be run if no command ID is found.
1 million weekly downloads​
While exact oclif usage metrics are hard to pin down, we use npm download statistics of oclif packages as a rough approximation. Earlier this year, oclif's command package hit 1 million weekly downloads for the first time!
This year has been presented its challenges on everyone. We want to thank you, oclif developers, whom have taken the time to use and improve the oclif project. We look forward to seeing you all - in person - in the future!
All our best,
The oclif teamPretty Printable ErrorsJuly 1, 2020 · One min readOften CLIs are used as handy tools and when things go wrong it’s useful to have additional context. In oclif we have added a couple of additional properties that can show extra context to the users when an error is displayed. The code, ref and suggestions will now be displayed if they are included. This will work with an existing oclif CLI by adding the latest @oclif/errors and @oclif/core to the CLI's package.json dependencies.
For example, using this.error with the additional properties:
class TestError extends Command {  async run() {    this.error("An error has occurred!", {      code: "OCLIF_ERR",      ref: "https://oclif.io/docs/commands#thiserrormessage-string--error-options-code-string-exit-number",      suggestions: ["Use these extra properties to provide additional context"],    })  }}
would result with the following output:
›   Error: An error has occurred!›   Code: OCLIF_ERR›   Try this: Use these extra properties to provide additional context›   Reference: https://oclif.io/docs/commands#thiserrormessage-string--error-options-code-string-exit-number
If these properties are not provided then nothing changes and the CLI will continue to display the single error message output as it did before. Additionally, as part of this exercise we’ve added documentation around Error Handling in oclif which should come in handy if the need arises to extend oclif’s default handling of errors.Customizing Help in oclifMay 5, 2020 · 2 min readOut of the box oclif provides a great help experience for CLIs.
But what if, as an oclif developer, you want to customize some or all of the output?
You can now customize your CLI's help output by implementing the HelpBase abstract class.
Getting started with custom help​
If you have not done so yet, update @oclif/core.
$ yarn add --latest @oclif/core
To get started, first define the filepath to your help class in oclif's config in package.json. This is a relative path to the help class, without a file extension.
For this example, the help class will be created in a file at "[project root]/src/help.ts".
{  // ...  "oclif": {    "helpClass": "./lib/help"    // ...  }  // ...}
From here there are two paths, implement the HelpBase abstract class yourself or overwrite the parts of the default Help class you want to customize (ex: how command usage is displayed). We recommend the latter approach but cover both in the new Help Classes docs.
Separating TOPICS & COMMANDS in the new default Help class​
Previously, topics and child commands were listed in help output under a single list heading called "COMMANDS". But we found this can be slightly confusing. Some topics are commands also (a.k.a. topic-commands) while others are simply organizational namespacing (and when ran just show their help).
The new default Help class splits the list of children into distinct lists of "TOPICS" and "COMMANDS", with the possibility of an item appearing in both if it a topic-command. This makes it clearer what is expected to be ran - "COMMANDS" - and what is providing structure - "TOPICS" - when looking at the help output.
VERSION  plugin-help-example/0.0.0 darwin-x64 node-v12.12.0USAGE  $ plugin-help-example [COMMAND]TOPICS  topic  this is a topic and has child topics or commandsCOMMANDS  hello  describe the command here  help   display help for plugin-help-example
We look forward to seeing what custom help features you implement in your oclif CLIs with this new feature!oclif TSLint to ESLint MigrationDecember 5, 2019 · 3 min readBack in February of this year, plans were announced to deprecate TSLint in favor of ESLint. TSLint's goal has become to work toward a “unified developer experience” by supporting ESLint development going forward.
What has changed in oclif​
To keep inline with the community, oclif has transitioned to ESLint for all our core libraries as well as all our official plugins.
Starting in v1.15.x, oclif will now optionally generate projects with ESLint for both TypeScript and JavaScript CLI’s.
ESLint does require Node to be on stable LTS version, at the time of writing, Node 8.10.x, Node 10.13.x & Node 12.x.x.
How does this affect you​
Existing CLI’s are unchanged, but any newly generated CLI's will only give the option of using ESLint. If you are running tslint in your CLI, we recommend you switch to ESLint as well.
In migrating our projects we took the following steps (for an example of these changes see this pull request).


Install eslint
$ yarn add eslint eslint-config-oclif eslint-config-oclif-typescript --dev


Add eslint related files


$ echo '{  "extends": [    "oclif",    "oclif-typescript"  ],  "rules": {  }}' > .eslintrc


Remove tslint and related packages
$ yarn remove @oclif/tslint tslint


Remove tslint related configuration files
$ rm tslint.json


Change lint script in our package.json from something like:
"lint": "tsc -p test --noEmit && tslint -p test -t stylish"
to
"lint": "eslint . --ext .ts --config .eslintrc"


To preserve the test compile (tsc -p test --noEmit) we also made the following updates to our scripts:
"pretest": "tsc -p test --noEmit"
In some cases we had our posttest duplicating the same steps as our lint script so it’s cleaner to have it reference the lint job directly with:
"posttest": "yarn lint"

Run yarn lint --fix. This attempts to auto-fix any linting violations automatically. In the case an auto-fix isn’t available it should be fixed manually or ignored (see the eslint configuration doc for more information)
Do a search in the codebase for tslint and remove any unnecessary tslint disabling comments, like:

/* tslint:disable:object-literal-sort-keys */
If you are on a version of Node that is not supported by ESLint, you will also need to update your Node engine. ESLint supports Node 8, 10, and 12 so you should upgrade to the most recent Node version compatible with your CLI and also supported by ESLint (see ESLint's Installation and Usage instructions).
When will this take effect​
These changes have taken effect in oclif v1.15.1. When you generate a new CLI or plugin it will now contain configuration for ESLint instead of TSLint.oclif's Current Node SupportOctober 31, 2019 · 3 min readTo maintain a healthy project trajectory, oclif follows and supports Node Active LTS release, currently Node 10 & Node 12. This means ensuring that oclif continues to play nice with coming Active LTS Node versions and other packages in the ecosystem. Moving forward also means leaving older versions behind. Starting in 2020, Node will stop maintaining Node 8 and it is our intent at that time to also follow suit. Let’s take a look at a few ways we will be supporting these changes.
CI Environments​
CLIs created with the oclif cli going forward will be generated with a CircleCI configuration with Node 10 & 12 and an Appveyor configuration using Node 10. We have also added Node latest to CircleCi to be an early warning detection against coming Node changes (Node latest is managed by CircleCI).
We have already updated every oclif repo's CI configs to reflect this.
If your existing CLI uses either Appveyor or CircleCI you can update your config files also, like so:
.circleci/config.yml​
Your CircleCI config should contain a node-latest job, aliased as test. From this, there should be two extensions of this job for the Active LTS Node versions, Node 10 and Node 12.
  node-10:    <<: *node-latest    docker:      - image: node:10  node-12:    <<: *node-latest    docker:      - image: node:12
Notice that these declarations only change the Docker Node images used to run that job.
Additionally, the jobs listed within workflows must also be updated to reflect our changes in configuration:
    jobs:      - node-latest      - node-10      - node-12
appveyor.yml​
For appveyor we are currently only testing the oldest Active LTS Node version, Node 10. Update the nodejs_version proppert in your appveyor.yml file to reflect this.
environment:  nodejs_version: "10"
Deprecating Node 8 & Updating packge.json engines​
In Jan 2020, Node will end its Node 8 maintenance. We will follow suit by setting the package.json engine property in oclif packages to >=10 and bumping the package's major versions.
Depending on how you ship your CLI you may wish to also bump the engines version in your CLI's package.json. You can read more about the implications of the engines property configuration in the npm documentation.
Also consider distributing your CLI with its own Node version.
Packaged Node Version​
When using dev-cli to pack your CLI it will use the Node version as specified in your package.json under the oclif.update.node.version property. This value should reflect an Active LTS Node version (dev-cli does not currently enforce versions).
Supporting the future​
As a community we may discover bumps along the way as we upgrade. If you notice something related to oclif please feel free to open an issue or submit a pull request under the relevant oclif package within the org.
We look forward to using the latest from Node and the community and keeping oclif healthy along the way.oclifconf 2019: A RecapSeptember 16, 2019 · 4 min readIn May, Heroku and Salesforce Open Source organized oclifconf, a conference for developers & product managers building CLI tools on top of the open source oclif framework. The speakers came from various tech companies, such as Adobe, Netlify, and Apollo, who have already built amazing CLI experiences. The topics covered everything from the incredible capabilities oclif has unlocked, to the community-built plugins extending its functionality, and even what the behavior of an adaptive CLI tool might look like.
Below is a listing of all of the talks from the event, along with a short summary. Enjoy!
The future of oclif by Jeff Dickey​

In its relatively short lifetime, oclif has already inspired many developers and companies to adopt its framework as a means for implementing their own command-line tooling. In this talk, Jeff Dickey, an oclif founding team member, recaps the project's history and inspiration. He also looks towards the future and outlines some features and improvements that the tool could adapt. This isn't so much a definitive roadmap of where oclif is headed, but rather, a call to inspiration for developers eager to contribute! And if you are interested in contributing, check out the open issues in the oclif GitHub repo and come say "Hello!" on Spectrum Chat.
Open Source Citizenship by Josh Simmons​

When it comes to open source, it's more than just individuals now. More and more frequently, large corporations are contributing to projects by donating to contributors, sponsoring events, or upstreaming contributions. But keeping open source projects and communities healthy requires more than just money and brainpower. Josh Simmons surveyed multiple open source communities and relays his findings as to what help maintainers and contributors actually need in this talk.
Building an enterprise-grade CLI with oclif by Thomas Dvornik​

Security and performance are all about trust. While oclif is an extremely extensible framework for building CLI tooling, there are additional requirements to fulfill for enterprise businesses to adopt it that might not be necessary for individual developers. Thomas Dvornik outlines what he and his colleagues at Salesforce have implemented as plugins to oclif to satisfy these needs, including encrypted OAuth, plugin signing, lazy loading dependencies, synchronizing weekly releases and deprecations across dozens of repositories, and establishing cross-team coding and documentation standards.
How Adobe I/O built an extensible CLI with oclif by Jesse MacFadyen​

Perhaps oclif's most appealing feature is its support for plugins. In Cordova's case, they've created a sophisticated telemetry system that helps Adobe developers see which commands users are using--and reports on which ones are erroring out. By embedding a feedback system into the tool, users are even able to quickly send their suggestions to a form, without ever leaving the terminal. Jesse MacFadyen demonstrates how oclif's plugin system can work beyond simply executing commands.
Integrating oclif with GraphQL and Apollo by Evans Hauser​

For Evans Hauser and the team at Apollo, oclif is best thought of as "React for the CLI." As a client paired with a strongly-typed API contract to a server, it can deliver structured and consistent commands to retrieve external data. What better mechanism to use for this transfer than GraphQL, a framework which empowers the client to ask precisely for the data it needs, and nothing more?
Adaptive Intent-based CLI State Machines by Shawn Wang​

In designing oclif, Jeff Dickey wrote out 12 CLI factors to keep in mind. In this talk, Shawn Wang outlines a 13th: state. State is hard, because it depends on context, and context depends on understanding what a user intends to do, not what they are asking. Shawn is working towards enabling oclif to better understand the commands a user has entered, so that it can predict and interpret future commands that might be entered next. This would enable CLI tools to not just interpret a users' commands, but to also interpret their intent.\n\nIntroducing `oclif init` commandApril 10, 2024 · 2 min readThanks to the contribution of @joshcanhelp we released a new command for the oclif CLI called oclif init in version 4.8.0
The oclif init command allows you to initialize oclif in an existing project directory by adding the bare minimum requirements: a few pieces of configuration, bin scripts, and a couple of dependencies (@oclif/core and ts-node). This is slightly different from oclif generate, which will create an entirely new oclif project based on our templates.
oclif init will add the following:

bin scripts: bin/run.js, bin/run.cmd, bin/dev.js, and bin/dev.cmd
oclif section to package.json with bin, dirname, commands, and topicSeparator set (See Configuring Your CLI for more)
@oclif/core to dependencies in your package.json (if it's not already there)
ts-node to devDependencies in your package.json (if it's not already there)

Once you've initialized oclif, you can use the bin scripts to execute your CLI. You can also use the other oclif commands like oclif generate command and oclif generate hook to start adding new functionality.

❯ oclif init --helpInitialize a new oclif CLIUSAGE  $ oclif init [--bin <value>] [--module-type ESM|CommonJS] [--package-manager npm|yarn|pnpm] [--topic-separator    colons|spaces] [-d <value>] [-y]FLAGS  -d, --output-dir=<value>        Directory to initialize the CLI in.  -y, --yes                       Use defaults for all prompts. Individual flags will override defaults.      --bin=<value>               Supply answer for prompt: Command bin name the CLI will export      --module-type=<option>      Supply answer for prompt: Select a module type                                  <options: ESM|CommonJS>      --package-manager=<option>  Supply answer for prompt: Select a package manager                                  <options: npm|yarn|pnpm>      --topic-separator=<option>  Supply answer for prompt: Select a topic separator                                  <options: colons|spaces>DESCRIPTION  Initialize a new oclif CLI  This will add the necessary oclif bin files, add oclif config to package.json, and install @oclif/core and ts-node.EXAMPLES  Initialize a new CLI in the current directory    $ oclif init  Initialize a new CLI in a different directory    $ oclif init --output-dir "/path/to/existing/project"  Supply answers for specific prompts    $ oclif init --topic-separator colons --bin mycli
Hope you enjoy the new command! If you come across any issues or have any new ideas for this command, head over to the oclif/oclif repo and open a new issue.
All our best,
The oclif teamoclif Spring 2024 UpdateMarch 29, 2024 · 4 min readHello oclif developers! It's been a while since we last uploaded a blog - and a lot has happened.
We've been focusing on these high-level areas over the past couple of years:

Improving @oclif/core
ESM Support
Improving and revitalizing oclif.io
Re-engaging the oclif community

Improving @oclif/core​
Since we announced @oclif/core over three years ago, we've released two new major versions, each packed with lots of features that we're really excited about.
Here are some of these changes:

Full support for ESM and interoperability with CommonJS (more on this topic below).
Configurable command discovery strategies that give you more control over how commands are loaded at runtime. Check out the docs.
A new preparse hook that allows you to manipulate the provided arguments before they're parsed. Salesforce used this hook to implement a neat --flags-dir feature that translates local files into flags.
A new Performance class that you can use to track performance inside of @oclif/core and your own CLI or plugin. Check out the docs.
A new flag type, Flags.option, that lets you define a flag with a preset list of options. Typescript then uses the options to infer the flag's type.
Flags now have a relationship property that allows you to define more complex relationships between flags. Check out the flags docs for more information.
Flags now have a defaultHelp property that allows you to set the human readable default value in the command help. This property is useful when your flag's parse method returns a complex type, such as an object or a class. Check out the flags docs for more.
Commands now have a hiddenAliases property that allows you to define aliases that you want to hide from the user. The property is super helpful when you're trying to wean users off a deprecated command.
You can now use bun or tsx as dev runtimes (as opposed to node or ts-node).
A command's usage, args, and flags are now shown whenever a user forgets to provide a required arg or flag, or when they provided a non-existent flag.

If you need help migrating to the latest version, head over to core's README which has links to the migration guides. Feel free to open a new discussion if you need more hands-on help from us or the community.
ESM Support​
Version 3 of @oclif/core introduced full support for developing ESM plugins and CLIs. It also offered full support for interoperability between CommonJS and ESM plugins.
Put more simply, you can now migrate your CLI to ESM while keeping individual plugins in CommonJS (or vice versa). The upgrade path is now much simpler for you. You also don't need to worry about any community plugins that have migrated to ESM before you did (such as all the @oclif plugins) or are staunchly sticking with CommonJS for the foreseeable future.
Read more about this topic here.
Improving and Revitalizing oclif.io​
Another area of focus for us has been improving our documentation site, oclif.io.
While improving the quality and accuracy of the documentation was our priority, we also took the time to upgrade to the latest version of docusaurus. This new version gave our site a much-needed facelift, as well as cool new features such as dark mode and announcements.
If you have any feedback or are running into issues, we want to hear about it. Just create an issue in the oclif.io repo.
Re-engaging the oclif Community​
Lastly, our biggest priority at the moment is to re-engage the oclif community. We understand how frustrating it has been over the years to see your issues and pull requests go unacknowledged. We apologize for not prioritizing the community, and are earnestly trying to make sure that every issue and pull request gets the attention it deserves going forward.
We also opened up GitHub discussions for @oclif/core and the oclif CLI, where you can now post your questions or ideas. We hope you take advantage of them, we love hearing from you!
One last thing: we intend to publicly post our roadmap so you have more visibility into what we're working on. Stay tuned!
All our best,
The oclif teamAnnouncing oclif v2!January 12, 2022 · 5 min readHello and happy new year! It's our great pleasure to announce that we have released oclif v2, which uses the new @oclif/core library! 🎉
oclif v2 includes many changes that improve the experience of both creating and using an oclif CLI.
Going forward, we don't plan to make any updates to oclif v1 and its corresponding libraries, except for critical security fixes. See the compatibility matrix for a list of these libraries. In order to give developers time to migrate from v1 to v2, we're not completely dropping support yet. But at some point in the future we'll archive the v1 repositories and deprecate their versions on npm.
What’s changing?​
Repository Changes​
All repositories under the oclif org now use main as their primary branch and oclif-v1 as the legacy branch. The main  branch corresponds to oclif v2 and the oclif-v1 branch to oclif v1. If you find any repos that don’t have a main branch, you can safely assume that they're not used in oclif v2 and will be deprecated in the future.
Consolidating Tools & Libraries​
The oclif-dev CLI has now been incorporated into oclif. You now no longer need to install a separate package to manage your entire CLI’s lifecycle.
The following libraries have been consolidated under @oclif/core and will be deprecated at some point in the future. Read the migration guide to learn how to update your CLI or plugin to use the new core library.

@oclif/command
@oclif/config
@oclif/error
@oclif/help
@oclif/parser

No more single vs multi command CLIs​
There's only one "type" of oclif v2 CLI, but it can have as few or as many commands as a developer wants. As a result, there’s only one command to generate CLIs, oclif generate, as opposed to the old oclif single and oclif multi commands.
Node > 12​
To ensure oclif CLIs are as secure as possible, all v2 libraries and plugins support only Node 12 or higher as of now. Going forward, they'll support only Node Maintenance or higher, as defined by Node's release schedule here: https://nodejs.org/en/about/releases/.
What’s new?​
New example CLI​
oclif-hello-world is our new example repo. This is also the repo that's used as a template when running oclif generate to create a new CLI. This repo will always be able to be referenced as an example of what an oclif v2 CLI should look like.
Spaced commands​
oclif CLIs can now use spaces, instead of colons, to separate topics and subcommands. To enable this feature, simply add “topicSeparator": " " to the oclif config in your package.json. See an example in our example repo.
// Old commands that use :$ mycli do:something
// New spaced commands$ mycli do something

Note: Spaced commands are backwards compatible. So if you enable spaced commands for your CLI, users will still be able to use : as a separator. This ensures that any existing scripts don't break.

New Help Output​
We’ve revamped the way command help is outputted to the terminal, making it both easier to implement and easier to read. See the difference between the old help output on the left and the new help output on the right in the screenshots below.
oclif v1oclif v2
Notice that there are new sections for flags and global flags, examples are displayed with better spacing, and there is a section at the bottom called Configuration Variables. This Configuration Variables section is not part of the new help by default. But we've added support for custom help sections, which is what the sf CLI uses to create the new section.
Async Command Parsing​
We’ve also improved the performance of new CLIs by rewriting how commands are parsed on initialization. The new parser is asynchronous, which makes CLIs with a lot of commands or installed  plugins much faster.
What’s coming next?​
Part of our charter for the release of oclif v2 includes improving our engagement with the oclif community. We know that over the past couple of years we’ve reduced our involvement, and a lot of issues and PRs have languished in limbo. Hopefully you’ve already seen increased activity and responses from oclif maintainers recently, but if you haven’t, please don’t hesitate to ping us by tagging @admins in oclif repos.
We also want to start interviewing members of the oclif community to acquire feedback and prioritize the features and fixes you deem most important!
Best,
The oclif team

Reference material​
Migration Guide​
This guide explains how to upgrade a CLI or plugin from the old oclif v1 libraries to the new @oclif/core library that oclif v2 uses.
https://github.com/oclif/core/blob/main/MIGRATION.md
Compatibility Matrix​
The following matrix shows how the v1 libraries and plugins relate to the new v2 ones. Use this matrix as a guide to know what to drop and which versions to switch when upgrading your plugins and CLIs to v2.
oclif "v1"oclif "v2"Utility CLIsoclif@<2@oclif/dev-cli@<2oclif@>=2Main packages@oclif/command@oclif/config@oclif/errors@oclif/parser@oclif/plugin-help@oclif/core@>=1Node LTSNode v8-14Node v12+ (at time of writing)TypeScripttypescript@<4typescript@>=4Main plugins@oclif/plugin-autocomplete@<1@oclif/plugin-commands@<2@oclif/plugin-help@<4@oclif/plugin-not-found@<2@oclif/plugin-plugins@<2@oclif/plugin-update@<2plugin-warn-if-update-available@<2plugin-which@<2@oclif/plugin-autocomplete@>=1@oclif/plugin-commands@>=2@oclif/plugin-help@>=4@oclif/plugin-not-found@>=2@oclif/plugin-plugins@>=2@oclif/plugin-update@>=2@oclif/plugin-warn-if-update-available@>=2@oclif/plugin-which@>=2Introducing @oclif/coreMarch 1, 2021 · 3 min readGreetings!
We hope this blog post finds you well.
Introducing...​
We are excited to announce the next iteration of the oclif project today: @oclif/core.
We have learned a lot in the last three years of developing oclif, developing on oclif and supporting millions of command runs a day via Heroku and Salesforce CLIs.
@oclif/core ("Core") simplifies the oclif development experience and introduces highly requested new features.
Core combines the essential oclif packages into one "core" package, aptly named @oclif/core.
Core also introduces:

A default command option
Colon or space command syntax
Async command parsing
Command piping to arguments

With the introduction of default command functionality, Core simplifies the oclif project and removes the notion of single or multi command CLIs. Core CLIs can have 1 or many commands.
Along with Core, we moved the oclif-dev CLI into the oclif CLI creating a single "utility" CLI. This CLI also introduces a new AWS S3 compatible publishing scheme.
What to expect in the near future​
Core is in pre-release beta and being actively developed for new internal Salesforce CLIs.
Much documentation needs to be written in the coming months including migration paths. Migration onto Core should be as painless as possible with many exports remaining entirely unchanged. Look for forthcoming blog posts and documentation on oclif.io.
Early this summer, tentively June 1, we will release Core v1. Core's release will coincide with major bumps to many other oclif plugin packages. See the compatibility matrix below.
At Core's v1 release, the current "main" oclif packages (namely: command, config, errors & parser) will go into maintenance mode until Jan 2022. They will receive only bug and security fixes and they remain compatible with current versions of the oclif and oclif-dev CLIs. Afterwhich, they will be archived.
Companioning Core, the next major release of the oclif CLI (literally oclif@2) will generate Core CLIs.
Going forward​
We are excited to release Core! We invite you to poke around the Core repo. It may appear to be a big change but Core keeps what you already enjoy about oclif while reducing development complexity, project dependencies, package coupling and bundle size and introduces many requested features previously too prickly to weave into the current oclif architecture.
Best,
The oclif team
Reference: Compatibility matrix​
oclif "v1"oclif "Core"Utility CLIsoclif@<2@oclif/dev-cli@<2oclif@>=2Main packages@oclif/core@<2@oclif/config@<2@oclif/errors@<2@oclif/parser@<4@oclif/plugin-help@<4@oclif/core@>=1Node LTSNode v8-14Node v12+TypeScripttypescript@<4typescript@>=4Main plugins@oclif/plugin-autocomplete@<1@oclif/plugin-commands@<2@oclif/plugin-help@<4@oclif/plugin-not-found@<2@oclif/plugin-plugins@<2@oclif/plugin-update@<2plugin-warn-if-update-available@<2plugin-which@<2@oclif/plugin-autocomplete@>=2@oclif/plugin-commands@>=2@oclif/plugin-help@>=4@oclif/plugin-not-found@>=2@oclif/plugin-plugins@>=2@oclif/plugin-update@>=2@oclif/plugin-warn-if-update-available@>=2@oclif/plugin-which@>=2oclif Summer 2020 UpdateAugust 26, 2020 · 2 min readHello oclif developers! We hope you are all doing well.
Earlier this year, we started our planning for oclifconf v2 and, like all conference, had to change course. We opted not to hold a virtual conference, however, we wanted to take some time to highlight a few oclif features shipped this year.
Feature: Help templating​
One of the most requested features, help templating enables oclif developers to customize the help output for their CLI.
Read the announcement.
Feature: Custom error delegation​
This feature both improved how oclif throws and handles errors and allows oclif developers to overwrite or interject in oclif’s error handling.
Read the announcement.
Feature: postrun hooks​
We have added a new lifecycle event postrun. Your CLI can now run a hook after a command has ran.
See our hook documentation.
Feature: Root index command​
Previously, oclif would display CLI help if only the binary name with no command ID was invoked, oclif now supports a "root index" command. If present, a command defined at src/commands/index.ts will be run if no command ID is found.
1 million weekly downloads​
While exact oclif usage metrics are hard to pin down, we use npm download statistics of oclif packages as a rough approximation. Earlier this year, oclif's command package hit 1 million weekly downloads for the first time!
This year has been presented its challenges on everyone. We want to thank you, oclif developers, whom have taken the time to use and improve the oclif project. We look forward to seeing you all - in person - in the future!
All our best,
The oclif teamPretty Printable ErrorsJuly 1, 2020 · One min readOften CLIs are used as handy tools and when things go wrong it’s useful to have additional context. In oclif we have added a couple of additional properties that can show extra context to the users when an error is displayed. The code, ref and suggestions will now be displayed if they are included. This will work with an existing oclif CLI by adding the latest @oclif/errors and @oclif/core to the CLI's package.json dependencies.
For example, using this.error with the additional properties:
class TestError extends Command {  async run() {    this.error("An error has occurred!", {      code: "OCLIF_ERR",      ref: "https://oclif.io/docs/commands#thiserrormessage-string--error-options-code-string-exit-number",      suggestions: ["Use these extra properties to provide additional context"],    })  }}
would result with the following output:
›   Error: An error has occurred!›   Code: OCLIF_ERR›   Try this: Use these extra properties to provide additional context›   Reference: https://oclif.io/docs/commands#thiserrormessage-string--error-options-code-string-exit-number
If these properties are not provided then nothing changes and the CLI will continue to display the single error message output as it did before. Additionally, as part of this exercise we’ve added documentation around Error Handling in oclif which should come in handy if the need arises to extend oclif’s default handling of errors.Customizing Help in oclifMay 5, 2020 · 2 min readOut of the box oclif provides a great help experience for CLIs.
But what if, as an oclif developer, you want to customize some or all of the output?
You can now customize your CLI's help output by implementing the HelpBase abstract class.
Getting started with custom help​
If you have not done so yet, update @oclif/core.
$ yarn add --latest @oclif/core
To get started, first define the filepath to your help class in oclif's config in package.json. This is a relative path to the help class, without a file extension.
For this example, the help class will be created in a file at "[project root]/src/help.ts".
{  // ...  "oclif": {    "helpClass": "./lib/help"    // ...  }  // ...}
From here there are two paths, implement the HelpBase abstract class yourself or overwrite the parts of the default Help class you want to customize (ex: how command usage is displayed). We recommend the latter approach but cover both in the new Help Classes docs.
Separating TOPICS & COMMANDS in the new default Help class​
Previously, topics and child commands were listed in help output under a single list heading called "COMMANDS". But we found this can be slightly confusing. Some topics are commands also (a.k.a. topic-commands) while others are simply organizational namespacing (and when ran just show their help).
The new default Help class splits the list of children into distinct lists of "TOPICS" and "COMMANDS", with the possibility of an item appearing in both if it a topic-command. This makes it clearer what is expected to be ran - "COMMANDS" - and what is providing structure - "TOPICS" - when looking at the help output.
VERSION  plugin-help-example/0.0.0 darwin-x64 node-v12.12.0USAGE  $ plugin-help-example [COMMAND]TOPICS  topic  this is a topic and has child topics or commandsCOMMANDS  hello  describe the command here  help   display help for plugin-help-example
We look forward to seeing what custom help features you implement in your oclif CLIs with this new feature!oclif TSLint to ESLint MigrationDecember 5, 2019 · 3 min readBack in February of this year, plans were announced to deprecate TSLint in favor of ESLint. TSLint's goal has become to work toward a “unified developer experience” by supporting ESLint development going forward.
What has changed in oclif​
To keep inline with the community, oclif has transitioned to ESLint for all our core libraries as well as all our official plugins.
Starting in v1.15.x, oclif will now optionally generate projects with ESLint for both TypeScript and JavaScript CLI’s.
ESLint does require Node to be on stable LTS version, at the time of writing, Node 8.10.x, Node 10.13.x & Node 12.x.x.
How does this affect you​
Existing CLI’s are unchanged, but any newly generated CLI's will only give the option of using ESLint. If you are running tslint in your CLI, we recommend you switch to ESLint as well.
In migrating our projects we took the following steps (for an example of these changes see this pull request).


Install eslint
$ yarn add eslint eslint-config-oclif eslint-config-oclif-typescript --dev


Add eslint related files


$ echo '{  "extends": [    "oclif",    "oclif-typescript"  ],  "rules": {  }}' > .eslintrc


Remove tslint and related packages
$ yarn remove @oclif/tslint tslint


Remove tslint related configuration files
$ rm tslint.json


Change lint script in our package.json from something like:
"lint": "tsc -p test --noEmit && tslint -p test -t stylish"
to
"lint": "eslint . --ext .ts --config .eslintrc"


To preserve the test compile (tsc -p test --noEmit) we also made the following updates to our scripts:
"pretest": "tsc -p test --noEmit"
In some cases we had our posttest duplicating the same steps as our lint script so it’s cleaner to have it reference the lint job directly with:
"posttest": "yarn lint"

Run yarn lint --fix. This attempts to auto-fix any linting violations automatically. In the case an auto-fix isn’t available it should be fixed manually or ignored (see the eslint configuration doc for more information)
Do a search in the codebase for tslint and remove any unnecessary tslint disabling comments, like:

/* tslint:disable:object-literal-sort-keys */
If you are on a version of Node that is not supported by ESLint, you will also need to update your Node engine. ESLint supports Node 8, 10, and 12 so you should upgrade to the most recent Node version compatible with your CLI and also supported by ESLint (see ESLint's Installation and Usage instructions).
When will this take effect​
These changes have taken effect in oclif v1.15.1. When you generate a new CLI or plugin it will now contain configuration for ESLint instead of TSLint.oclif's Current Node SupportOctober 31, 2019 · 3 min readTo maintain a healthy project trajectory, oclif follows and supports Node Active LTS release, currently Node 10 & Node 12. This means ensuring that oclif continues to play nice with coming Active LTS Node versions and other packages in the ecosystem. Moving forward also means leaving older versions behind. Starting in 2020, Node will stop maintaining Node 8 and it is our intent at that time to also follow suit. Let’s take a look at a few ways we will be supporting these changes.
CI Environments​
CLIs created with the oclif cli going forward will be generated with a CircleCI configuration with Node 10 & 12 and an Appveyor configuration using Node 10. We have also added Node latest to CircleCi to be an early warning detection against coming Node changes (Node latest is managed by CircleCI).
We have already updated every oclif repo's CI configs to reflect this.
If your existing CLI uses either Appveyor or CircleCI you can update your config files also, like so:
.circleci/config.yml​
Your CircleCI config should contain a node-latest job, aliased as test. From this, there should be two extensions of this job for the Active LTS Node versions, Node 10 and Node 12.
  node-10:    <<: *node-latest    docker:      - image: node:10  node-12:    <<: *node-latest    docker:      - image: node:12
Notice that these declarations only change the Docker Node images used to run that job.
Additionally, the jobs listed within workflows must also be updated to reflect our changes in configuration:
    jobs:      - node-latest      - node-10      - node-12
appveyor.yml​
For appveyor we are currently only testing the oldest Active LTS Node version, Node 10. Update the nodejs_version proppert in your appveyor.yml file to reflect this.
environment:  nodejs_version: "10"
Deprecating Node 8 & Updating packge.json engines​
In Jan 2020, Node will end its Node 8 maintenance. We will follow suit by setting the package.json engine property in oclif packages to >=10 and bumping the package's major versions.
Depending on how you ship your CLI you may wish to also bump the engines version in your CLI's package.json. You can read more about the implications of the engines property configuration in the npm documentation.
Also consider distributing your CLI with its own Node version.
Packaged Node Version​
When using dev-cli to pack your CLI it will use the Node version as specified in your package.json under the oclif.update.node.version property. This value should reflect an Active LTS Node version (dev-cli does not currently enforce versions).
Supporting the future​
As a community we may discover bumps along the way as we upgrade. If you notice something related to oclif please feel free to open an issue or submit a pull request under the relevant oclif package within the org.
We look forward to using the latest from Node and the community and keeping oclif healthy along the way.oclifconf 2019: A RecapSeptember 16, 2019 · 4 min readIn May, Heroku and Salesforce Open Source organized oclifconf, a conference for developers & product managers building CLI tools on top of the open source oclif framework. The speakers came from various tech companies, such as Adobe, Netlify, and Apollo, who have already built amazing CLI experiences. The topics covered everything from the incredible capabilities oclif has unlocked, to the community-built plugins extending its functionality, and even what the behavior of an adaptive CLI tool might look like.
Below is a listing of all of the talks from the event, along with a short summary. Enjoy!
The future of oclif by Jeff Dickey​

In its relatively short lifetime, oclif has already inspired many developers and companies to adopt its framework as a means for implementing their own command-line tooling. In this talk, Jeff Dickey, an oclif founding team member, recaps the project's history and inspiration. He also looks towards the future and outlines some features and improvements that the tool could adapt. This isn't so much a definitive roadmap of where oclif is headed, but rather, a call to inspiration for developers eager to contribute! And if you are interested in contributing, check out the open issues in the oclif GitHub repo and come say "Hello!" on Spectrum Chat.
Open Source Citizenship by Josh Simmons​

When it comes to open source, it's more than just individuals now. More and more frequently, large corporations are contributing to projects by donating to contributors, sponsoring events, or upstreaming contributions. But keeping open source projects and communities healthy requires more than just money and brainpower. Josh Simmons surveyed multiple open source communities and relays his findings as to what help maintainers and contributors actually need in this talk.
Building an enterprise-grade CLI with oclif by Thomas Dvornik​

Security and performance are all about trust. While oclif is an extremely extensible framework for building CLI tooling, there are additional requirements to fulfill for enterprise businesses to adopt it that might not be necessary for individual developers. Thomas Dvornik outlines what he and his colleagues at Salesforce have implemented as plugins to oclif to satisfy these needs, including encrypted OAuth, plugin signing, lazy loading dependencies, synchronizing weekly releases and deprecations across dozens of repositories, and establishing cross-team coding and documentation standards.
How Adobe I/O built an extensible CLI with oclif by Jesse MacFadyen​

Perhaps oclif's most appealing feature is its support for plugins. In Cordova's case, they've created a sophisticated telemetry system that helps Adobe developers see which commands users are using--and reports on which ones are erroring out. By embedding a feedback system into the tool, users are even able to quickly send their suggestions to a form, without ever leaving the terminal. Jesse MacFadyen demonstrates how oclif's plugin system can work beyond simply executing commands.
Integrating oclif with GraphQL and Apollo by Evans Hauser​

For Evans Hauser and the team at Apollo, oclif is best thought of as "React for the CLI." As a client paired with a strongly-typed API contract to a server, it can deliver structured and consistent commands to retrieve external data. What better mechanism to use for this transfer than GraphQL, a framework which empowers the client to ask precisely for the data it needs, and nothing more?
Adaptive Intent-based CLI State Machines by Shawn Wang​

In designing oclif, Jeff Dickey wrote out 12 CLI factors to keep in mind. In this talk, Shawn Wang outlines a 13th: state. State is hard, because it depends on context, and context depends on understanding what a user intends to do, not what they are asking. Shawn is working towards enabling oclif to better understand the commands a user has entered, so that it can predict and interpret future commands that might be entered next. This would enable CLI tools to not just interpret a users' commands, but to also interpret their intent.Older Entries\n\n\n\nIntroducing `oclif init` commandApril 10, 2024 · 2 min readThanks to the contribution of @joshcanhelp we released a new command for the oclif CLI called oclif init in version 4.8.0
The oclif init command allows you to initialize oclif in an existing project directory by adding the bare minimum requirements: a few pieces of configuration, bin scripts, and a couple of dependencies (@oclif/core and ts-node). This is slightly different from oclif generate, which will create an entirely new oclif project based on our templates.
oclif init will add the following:

bin scripts: bin/run.js, bin/run.cmd, bin/dev.js, and bin/dev.cmd
oclif section to package.json with bin, dirname, commands, and topicSeparator set (See Configuring Your CLI for more)
@oclif/core to dependencies in your package.json (if it's not already there)
ts-node to devDependencies in your package.json (if it's not already there)

Once you've initialized oclif, you can use the bin scripts to execute your CLI. You can also use the other oclif commands like oclif generate command and oclif generate hook to start adding new functionality.

❯ oclif init --helpInitialize a new oclif CLIUSAGE  $ oclif init [--bin <value>] [--module-type ESM|CommonJS] [--package-manager npm|yarn|pnpm] [--topic-separator    colons|spaces] [-d <value>] [-y]FLAGS  -d, --output-dir=<value>        Directory to initialize the CLI in.  -y, --yes                       Use defaults for all prompts. Individual flags will override defaults.      --bin=<value>               Supply answer for prompt: Command bin name the CLI will export      --module-type=<option>      Supply answer for prompt: Select a module type                                  <options: ESM|CommonJS>      --package-manager=<option>  Supply answer for prompt: Select a package manager                                  <options: npm|yarn|pnpm>      --topic-separator=<option>  Supply answer for prompt: Select a topic separator                                  <options: colons|spaces>DESCRIPTION  Initialize a new oclif CLI  This will add the necessary oclif bin files, add oclif config to package.json, and install @oclif/core and ts-node.EXAMPLES  Initialize a new CLI in the current directory    $ oclif init  Initialize a new CLI in a different directory    $ oclif init --output-dir "/path/to/existing/project"  Supply answers for specific prompts    $ oclif init --topic-separator colons --bin mycli
Hope you enjoy the new command! If you come across any issues or have any new ideas for this command, head over to the oclif/oclif repo and open a new issue.
All our best,
The oclif teamoclif Spring 2024 UpdateMarch 29, 2024 · 4 min readHello oclif developers! It's been a while since we last uploaded a blog - and a lot has happened.
We've been focusing on these high-level areas over the past couple of years:

Improving @oclif/core
ESM Support
Improving and revitalizing oclif.io
Re-engaging the oclif community

Improving @oclif/core​
Since we announced @oclif/core over three years ago, we've released two new major versions, each packed with lots of features that we're really excited about.
Here are some of these changes:

Full support for ESM and interoperability with CommonJS (more on this topic below).
Configurable command discovery strategies that give you more control over how commands are loaded at runtime. Check out the docs.
A new preparse hook that allows you to manipulate the provided arguments before they're parsed. Salesforce used this hook to implement a neat --flags-dir feature that translates local files into flags.
A new Performance class that you can use to track performance inside of @oclif/core and your own CLI or plugin. Check out the docs.
A new flag type, Flags.option, that lets you define a flag with a preset list of options. Typescript then uses the options to infer the flag's type.
Flags now have a relationship property that allows you to define more complex relationships between flags. Check out the flags docs for more information.
Flags now have a defaultHelp property that allows you to set the human readable default value in the command help. This property is useful when your flag's parse method returns a complex type, such as an object or a class. Check out the flags docs for more.
Commands now have a hiddenAliases property that allows you to define aliases that you want to hide from the user. The property is super helpful when you're trying to wean users off a deprecated command.
You can now use bun or tsx as dev runtimes (as opposed to node or ts-node).
A command's usage, args, and flags are now shown whenever a user forgets to provide a required arg or flag, or when they provided a non-existent flag.

If you need help migrating to the latest version, head over to core's README which has links to the migration guides. Feel free to open a new discussion if you need more hands-on help from us or the community.
ESM Support​
Version 3 of @oclif/core introduced full support for developing ESM plugins and CLIs. It also offered full support for interoperability between CommonJS and ESM plugins.
Put more simply, you can now migrate your CLI to ESM while keeping individual plugins in CommonJS (or vice versa). The upgrade path is now much simpler for you. You also don't need to worry about any community plugins that have migrated to ESM before you did (such as all the @oclif plugins) or are staunchly sticking with CommonJS for the foreseeable future.
Read more about this topic here.
Improving and Revitalizing oclif.io​
Another area of focus for us has been improving our documentation site, oclif.io.
While improving the quality and accuracy of the documentation was our priority, we also took the time to upgrade to the latest version of docusaurus. This new version gave our site a much-needed facelift, as well as cool new features such as dark mode and announcements.
If you have any feedback or are running into issues, we want to hear about it. Just create an issue in the oclif.io repo.
Re-engaging the oclif Community​
Lastly, our biggest priority at the moment is to re-engage the oclif community. We understand how frustrating it has been over the years to see your issues and pull requests go unacknowledged. We apologize for not prioritizing the community, and are earnestly trying to make sure that every issue and pull request gets the attention it deserves going forward.
We also opened up GitHub discussions for @oclif/core and the oclif CLI, where you can now post your questions or ideas. We hope you take advantage of them, we love hearing from you!
One last thing: we intend to publicly post our roadmap so you have more visibility into what we're working on. Stay tuned!
All our best,
The oclif teamAnnouncing oclif v2!January 12, 2022 · 5 min readHello and happy new year! It's our great pleasure to announce that we have released oclif v2, which uses the new @oclif/core library! 🎉
oclif v2 includes many changes that improve the experience of both creating and using an oclif CLI.
Going forward, we don't plan to make any updates to oclif v1 and its corresponding libraries, except for critical security fixes. See the compatibility matrix for a list of these libraries. In order to give developers time to migrate from v1 to v2, we're not completely dropping support yet. But at some point in the future we'll archive the v1 repositories and deprecate their versions on npm.
What’s changing?​
Repository Changes​
All repositories under the oclif org now use main as their primary branch and oclif-v1 as the legacy branch. The main  branch corresponds to oclif v2 and the oclif-v1 branch to oclif v1. If you find any repos that don’t have a main branch, you can safely assume that they're not used in oclif v2 and will be deprecated in the future.
Consolidating Tools & Libraries​
The oclif-dev CLI has now been incorporated into oclif. You now no longer need to install a separate package to manage your entire CLI’s lifecycle.
The following libraries have been consolidated under @oclif/core and will be deprecated at some point in the future. Read the migration guide to learn how to update your CLI or plugin to use the new core library.

@oclif/command
@oclif/config
@oclif/error
@oclif/help
@oclif/parser

No more single vs multi command CLIs​
There's only one "type" of oclif v2 CLI, but it can have as few or as many commands as a developer wants. As a result, there’s only one command to generate CLIs, oclif generate, as opposed to the old oclif single and oclif multi commands.
Node > 12​
To ensure oclif CLIs are as secure as possible, all v2 libraries and plugins support only Node 12 or higher as of now. Going forward, they'll support only Node Maintenance or higher, as defined by Node's release schedule here: https://nodejs.org/en/about/releases/.
What’s new?​
New example CLI​
oclif-hello-world is our new example repo. This is also the repo that's used as a template when running oclif generate to create a new CLI. This repo will always be able to be referenced as an example of what an oclif v2 CLI should look like.
Spaced commands​
oclif CLIs can now use spaces, instead of colons, to separate topics and subcommands. To enable this feature, simply add “topicSeparator": " " to the oclif config in your package.json. See an example in our example repo.
// Old commands that use :$ mycli do:something
// New spaced commands$ mycli do something

Note: Spaced commands are backwards compatible. So if you enable spaced commands for your CLI, users will still be able to use : as a separator. This ensures that any existing scripts don't break.

New Help Output​
We’ve revamped the way command help is outputted to the terminal, making it both easier to implement and easier to read. See the difference between the old help output on the left and the new help output on the right in the screenshots below.
oclif v1oclif v2
Notice that there are new sections for flags and global flags, examples are displayed with better spacing, and there is a section at the bottom called Configuration Variables. This Configuration Variables section is not part of the new help by default. But we've added support for custom help sections, which is what the sf CLI uses to create the new section.
Async Command Parsing​
We’ve also improved the performance of new CLIs by rewriting how commands are parsed on initialization. The new parser is asynchronous, which makes CLIs with a lot of commands or installed  plugins much faster.
What’s coming next?​
Part of our charter for the release of oclif v2 includes improving our engagement with the oclif community. We know that over the past couple of years we’ve reduced our involvement, and a lot of issues and PRs have languished in limbo. Hopefully you’ve already seen increased activity and responses from oclif maintainers recently, but if you haven’t, please don’t hesitate to ping us by tagging @admins in oclif repos.
We also want to start interviewing members of the oclif community to acquire feedback and prioritize the features and fixes you deem most important!
Best,
The oclif team

Reference material​
Migration Guide​
This guide explains how to upgrade a CLI or plugin from the old oclif v1 libraries to the new @oclif/core library that oclif v2 uses.
https://github.com/oclif/core/blob/main/MIGRATION.md
Compatibility Matrix​
The following matrix shows how the v1 libraries and plugins relate to the new v2 ones. Use this matrix as a guide to know what to drop and which versions to switch when upgrading your plugins and CLIs to v2.
oclif "v1"oclif "v2"Utility CLIsoclif@<2@oclif/dev-cli@<2oclif@>=2Main packages@oclif/command@oclif/config@oclif/errors@oclif/parser@oclif/plugin-help@oclif/core@>=1Node LTSNode v8-14Node v12+ (at time of writing)TypeScripttypescript@<4typescript@>=4Main plugins@oclif/plugin-autocomplete@<1@oclif/plugin-commands@<2@oclif/plugin-help@<4@oclif/plugin-not-found@<2@oclif/plugin-plugins@<2@oclif/plugin-update@<2plugin-warn-if-update-available@<2plugin-which@<2@oclif/plugin-autocomplete@>=1@oclif/plugin-commands@>=2@oclif/plugin-help@>=4@oclif/plugin-not-found@>=2@oclif/plugin-plugins@>=2@oclif/plugin-update@>=2@oclif/plugin-warn-if-update-available@>=2@oclif/plugin-which@>=2Introducing @oclif/coreMarch 1, 2021 · 3 min readGreetings!
We hope this blog post finds you well.
Introducing...​
We are excited to announce the next iteration of the oclif project today: @oclif/core.
We have learned a lot in the last three years of developing oclif, developing on oclif and supporting millions of command runs a day via Heroku and Salesforce CLIs.
@oclif/core ("Core") simplifies the oclif development experience and introduces highly requested new features.
Core combines the essential oclif packages into one "core" package, aptly named @oclif/core.
Core also introduces:

A default command option
Colon or space command syntax
Async command parsing
Command piping to arguments

With the introduction of default command functionality, Core simplifies the oclif project and removes the notion of single or multi command CLIs. Core CLIs can have 1 or many commands.
Along with Core, we moved the oclif-dev CLI into the oclif CLI creating a single "utility" CLI. This CLI also introduces a new AWS S3 compatible publishing scheme.
What to expect in the near future​
Core is in pre-release beta and being actively developed for new internal Salesforce CLIs.
Much documentation needs to be written in the coming months including migration paths. Migration onto Core should be as painless as possible with many exports remaining entirely unchanged. Look for forthcoming blog posts and documentation on oclif.io.
Early this summer, tentively June 1, we will release Core v1. Core's release will coincide with major bumps to many other oclif plugin packages. See the compatibility matrix below.
At Core's v1 release, the current "main" oclif packages (namely: command, config, errors & parser) will go into maintenance mode until Jan 2022. They will receive only bug and security fixes and they remain compatible with current versions of the oclif and oclif-dev CLIs. Afterwhich, they will be archived.
Companioning Core, the next major release of the oclif CLI (literally oclif@2) will generate Core CLIs.
Going forward​
We are excited to release Core! We invite you to poke around the Core repo. It may appear to be a big change but Core keeps what you already enjoy about oclif while reducing development complexity, project dependencies, package coupling and bundle size and introduces many requested features previously too prickly to weave into the current oclif architecture.
Best,
The oclif team
Reference: Compatibility matrix​
oclif "v1"oclif "Core"Utility CLIsoclif@<2@oclif/dev-cli@<2oclif@>=2Main packages@oclif/core@<2@oclif/config@<2@oclif/errors@<2@oclif/parser@<4@oclif/plugin-help@<4@oclif/core@>=1Node LTSNode v8-14Node v12+TypeScripttypescript@<4typescript@>=4Main plugins@oclif/plugin-autocomplete@<1@oclif/plugin-commands@<2@oclif/plugin-help@<4@oclif/plugin-not-found@<2@oclif/plugin-plugins@<2@oclif/plugin-update@<2plugin-warn-if-update-available@<2plugin-which@<2@oclif/plugin-autocomplete@>=2@oclif/plugin-commands@>=2@oclif/plugin-help@>=4@oclif/plugin-not-found@>=2@oclif/plugin-plugins@>=2@oclif/plugin-update@>=2@oclif/plugin-warn-if-update-available@>=2@oclif/plugin-which@>=2oclif Summer 2020 UpdateAugust 26, 2020 · 2 min readHello oclif developers! We hope you are all doing well.
Earlier this year, we started our planning for oclifconf v2 and, like all conference, had to change course. We opted not to hold a virtual conference, however, we wanted to take some time to highlight a few oclif features shipped this year.
Feature: Help templating​
One of the most requested features, help templating enables oclif developers to customize the help output for their CLI.
Read the announcement.
Feature: Custom error delegation​
This feature both improved how oclif throws and handles errors and allows oclif developers to overwrite or interject in oclif’s error handling.
Read the announcement.
Feature: postrun hooks​
We have added a new lifecycle event postrun. Your CLI can now run a hook after a command has ran.
See our hook documentation.
Feature: Root index command​
Previously, oclif would display CLI help if only the binary name with no command ID was invoked, oclif now supports a "root index" command. If present, a command defined at src/commands/index.ts will be run if no command ID is found.
1 million weekly downloads​
While exact oclif usage metrics are hard to pin down, we use npm download statistics of oclif packages as a rough approximation. Earlier this year, oclif's command package hit 1 million weekly downloads for the first time!
This year has been presented its challenges on everyone. We want to thank you, oclif developers, whom have taken the time to use and improve the oclif project. We look forward to seeing you all - in person - in the future!
All our best,
The oclif teamPretty Printable ErrorsJuly 1, 2020 · One min readOften CLIs are used as handy tools and when things go wrong it’s useful to have additional context. In oclif we have added a couple of additional properties that can show extra context to the users when an error is displayed. The code, ref and suggestions will now be displayed if they are included. This will work with an existing oclif CLI by adding the latest @oclif/errors and @oclif/core to the CLI's package.json dependencies.
For example, using this.error with the additional properties:
class TestError extends Command {  async run() {    this.error("An error has occurred!", {      code: "OCLIF_ERR",      ref: "https://oclif.io/docs/commands#thiserrormessage-string--error-options-code-string-exit-number",      suggestions: ["Use these extra properties to provide additional context"],    })  }}
would result with the following output:
›   Error: An error has occurred!›   Code: OCLIF_ERR›   Try this: Use these extra properties to provide additional context›   Reference: https://oclif.io/docs/commands#thiserrormessage-string--error-options-code-string-exit-number
If these properties are not provided then nothing changes and the CLI will continue to display the single error message output as it did before. Additionally, as part of this exercise we’ve added documentation around Error Handling in oclif which should come in handy if the need arises to extend oclif’s default handling of errors.Customizing Help in oclifMay 5, 2020 · 2 min readOut of the box oclif provides a great help experience for CLIs.
But what if, as an oclif developer, you want to customize some or all of the output?
You can now customize your CLI's help output by implementing the HelpBase abstract class.
Getting started with custom help​
If you have not done so yet, update @oclif/core.
$ yarn add --latest @oclif/core
To get started, first define the filepath to your help class in oclif's config in package.json. This is a relative path to the help class, without a file extension.
For this example, the help class will be created in a file at "[project root]/src/help.ts".
{  // ...  "oclif": {    "helpClass": "./lib/help"    // ...  }  // ...}
From here there are two paths, implement the HelpBase abstract class yourself or overwrite the parts of the default Help class you want to customize (ex: how command usage is displayed). We recommend the latter approach but cover both in the new Help Classes docs.
Separating TOPICS & COMMANDS in the new default Help class​
Previously, topics and child commands were listed in help output under a single list heading called "COMMANDS". But we found this can be slightly confusing. Some topics are commands also (a.k.a. topic-commands) while others are simply organizational namespacing (and when ran just show their help).
The new default Help class splits the list of children into distinct lists of "TOPICS" and "COMMANDS", with the possibility of an item appearing in both if it a topic-command. This makes it clearer what is expected to be ran - "COMMANDS" - and what is providing structure - "TOPICS" - when looking at the help output.
VERSION  plugin-help-example/0.0.0 darwin-x64 node-v12.12.0USAGE  $ plugin-help-example [COMMAND]TOPICS  topic  this is a topic and has child topics or commandsCOMMANDS  hello  describe the command here  help   display help for plugin-help-example
We look forward to seeing what custom help features you implement in your oclif CLIs with this new feature!oclif TSLint to ESLint MigrationDecember 5, 2019 · 3 min readBack in February of this year, plans were announced to deprecate TSLint in favor of ESLint. TSLint's goal has become to work toward a “unified developer experience” by supporting ESLint development going forward.
What has changed in oclif​
To keep inline with the community, oclif has transitioned to ESLint for all our core libraries as well as all our official plugins.
Starting in v1.15.x, oclif will now optionally generate projects with ESLint for both TypeScript and JavaScript CLI’s.
ESLint does require Node to be on stable LTS version, at the time of writing, Node 8.10.x, Node 10.13.x & Node 12.x.x.
How does this affect you​
Existing CLI’s are unchanged, but any newly generated CLI's will only give the option of using ESLint. If you are running tslint in your CLI, we recommend you switch to ESLint as well.
In migrating our projects we took the following steps (for an example of these changes see this pull request).


Install eslint
$ yarn add eslint eslint-config-oclif eslint-config-oclif-typescript --dev


Add eslint related files


$ echo '{  "extends": [    "oclif",    "oclif-typescript"  ],  "rules": {  }}' > .eslintrc


Remove tslint and related packages
$ yarn remove @oclif/tslint tslint


Remove tslint related configuration files
$ rm tslint.json


Change lint script in our package.json from something like:
"lint": "tsc -p test --noEmit && tslint -p test -t stylish"
to
"lint": "eslint . --ext .ts --config .eslintrc"


To preserve the test compile (tsc -p test --noEmit) we also made the following updates to our scripts:
"pretest": "tsc -p test --noEmit"
In some cases we had our posttest duplicating the same steps as our lint script so it’s cleaner to have it reference the lint job directly with:
"posttest": "yarn lint"

Run yarn lint --fix. This attempts to auto-fix any linting violations automatically. In the case an auto-fix isn’t available it should be fixed manually or ignored (see the eslint configuration doc for more information)
Do a search in the codebase for tslint and remove any unnecessary tslint disabling comments, like:

/* tslint:disable:object-literal-sort-keys */
If you are on a version of Node that is not supported by ESLint, you will also need to update your Node engine. ESLint supports Node 8, 10, and 12 so you should upgrade to the most recent Node version compatible with your CLI and also supported by ESLint (see ESLint's Installation and Usage instructions).
When will this take effect​
These changes have taken effect in oclif v1.15.1. When you generate a new CLI or plugin it will now contain configuration for ESLint instead of TSLint.oclif's Current Node SupportOctober 31, 2019 · 3 min readTo maintain a healthy project trajectory, oclif follows and supports Node Active LTS release, currently Node 10 & Node 12. This means ensuring that oclif continues to play nice with coming Active LTS Node versions and other packages in the ecosystem. Moving forward also means leaving older versions behind. Starting in 2020, Node will stop maintaining Node 8 and it is our intent at that time to also follow suit. Let’s take a look at a few ways we will be supporting these changes.
CI Environments​
CLIs created with the oclif cli going forward will be generated with a CircleCI configuration with Node 10 & 12 and an Appveyor configuration using Node 10. We have also added Node latest to CircleCi to be an early warning detection against coming Node changes (Node latest is managed by CircleCI).
We have already updated every oclif repo's CI configs to reflect this.
If your existing CLI uses either Appveyor or CircleCI you can update your config files also, like so:
.circleci/config.yml​
Your CircleCI config should contain a node-latest job, aliased as test. From this, there should be two extensions of this job for the Active LTS Node versions, Node 10 and Node 12.
  node-10:    <<: *node-latest    docker:      - image: node:10  node-12:    <<: *node-latest    docker:      - image: node:12
Notice that these declarations only change the Docker Node images used to run that job.
Additionally, the jobs listed within workflows must also be updated to reflect our changes in configuration:
    jobs:      - node-latest      - node-10      - node-12
appveyor.yml​
For appveyor we are currently only testing the oldest Active LTS Node version, Node 10. Update the nodejs_version proppert in your appveyor.yml file to reflect this.
environment:  nodejs_version: "10"
Deprecating Node 8 & Updating packge.json engines​
In Jan 2020, Node will end its Node 8 maintenance. We will follow suit by setting the package.json engine property in oclif packages to >=10 and bumping the package's major versions.
Depending on how you ship your CLI you may wish to also bump the engines version in your CLI's package.json. You can read more about the implications of the engines property configuration in the npm documentation.
Also consider distributing your CLI with its own Node version.
Packaged Node Version​
When using dev-cli to pack your CLI it will use the Node version as specified in your package.json under the oclif.update.node.version property. This value should reflect an Active LTS Node version (dev-cli does not currently enforce versions).
Supporting the future​
As a community we may discover bumps along the way as we upgrade. If you notice something related to oclif please feel free to open an issue or submit a pull request under the relevant oclif package within the org.
We look forward to using the latest from Node and the community and keeping oclif healthy along the way.oclifconf 2019: A RecapSeptember 16, 2019 · 4 min readIn May, Heroku and Salesforce Open Source organized oclifconf, a conference for developers & product managers building CLI tools on top of the open source oclif framework. The speakers came from various tech companies, such as Adobe, Netlify, and Apollo, who have already built amazing CLI experiences. The topics covered everything from the incredible capabilities oclif has unlocked, to the community-built plugins extending its functionality, and even what the behavior of an adaptive CLI tool might look like.
Below is a listing of all of the talks from the event, along with a short summary. Enjoy!
The future of oclif by Jeff Dickey​

In its relatively short lifetime, oclif has already inspired many developers and companies to adopt its framework as a means for implementing their own command-line tooling. In this talk, Jeff Dickey, an oclif founding team member, recaps the project's history and inspiration. He also looks towards the future and outlines some features and improvements that the tool could adapt. This isn't so much a definitive roadmap of where oclif is headed, but rather, a call to inspiration for developers eager to contribute! And if you are interested in contributing, check out the open issues in the oclif GitHub repo and come say "Hello!" on Spectrum Chat.
Open Source Citizenship by Josh Simmons​

When it comes to open source, it's more than just individuals now. More and more frequently, large corporations are contributing to projects by donating to contributors, sponsoring events, or upstreaming contributions. But keeping open source projects and communities healthy requires more than just money and brainpower. Josh Simmons surveyed multiple open source communities and relays his findings as to what help maintainers and contributors actually need in this talk.
Building an enterprise-grade CLI with oclif by Thomas Dvornik​

Security and performance are all about trust. While oclif is an extremely extensible framework for building CLI tooling, there are additional requirements to fulfill for enterprise businesses to adopt it that might not be necessary for individual developers. Thomas Dvornik outlines what he and his colleagues at Salesforce have implemented as plugins to oclif to satisfy these needs, including encrypted OAuth, plugin signing, lazy loading dependencies, synchronizing weekly releases and deprecations across dozens of repositories, and establishing cross-team coding and documentation standards.
How Adobe I/O built an extensible CLI with oclif by Jesse MacFadyen​

Perhaps oclif's most appealing feature is its support for plugins. In Cordova's case, they've created a sophisticated telemetry system that helps Adobe developers see which commands users are using--and reports on which ones are erroring out. By embedding a feedback system into the tool, users are even able to quickly send their suggestions to a form, without ever leaving the terminal. Jesse MacFadyen demonstrates how oclif's plugin system can work beyond simply executing commands.
Integrating oclif with GraphQL and Apollo by Evans Hauser​

For Evans Hauser and the team at Apollo, oclif is best thought of as "React for the CLI." As a client paired with a strongly-typed API contract to a server, it can deliver structured and consistent commands to retrieve external data. What better mechanism to use for this transfer than GraphQL, a framework which empowers the client to ask precisely for the data it needs, and nothing more?
Adaptive Intent-based CLI State Machines by Shawn Wang​

In designing oclif, Jeff Dickey wrote out 12 CLI factors to keep in mind. In this talk, Shawn Wang outlines a 13th: state. State is hard, because it depends on context, and context depends on understanding what a user intends to do, not what they are asking. Shawn is working towards enabling oclif to better understand the commands a user has entered, so that it can predict and interpret future commands that might be entered next. This would enable CLI tools to not just interpret a users' commands, but to also interpret their intent.\n\nIntroducing `oclif init` commandApril 10, 2024 · 2 min readThanks to the contribution of @joshcanhelp we released a new command for the oclif CLI called oclif init in version 4.8.0
The oclif init command allows you to initialize oclif in an existing project directory by adding the bare minimum requirements: a few pieces of configuration, bin scripts, and a couple of dependencies (@oclif/core and ts-node). This is slightly different from oclif generate, which will create an entirely new oclif project based on our templates.
oclif init will add the following:

bin scripts: bin/run.js, bin/run.cmd, bin/dev.js, and bin/dev.cmd
oclif section to package.json with bin, dirname, commands, and topicSeparator set (See Configuring Your CLI for more)
@oclif/core to dependencies in your package.json (if it's not already there)
ts-node to devDependencies in your package.json (if it's not already there)

Once you've initialized oclif, you can use the bin scripts to execute your CLI. You can also use the other oclif commands like oclif generate command and oclif generate hook to start adding new functionality.

❯ oclif init --helpInitialize a new oclif CLIUSAGE  $ oclif init [--bin <value>] [--module-type ESM|CommonJS] [--package-manager npm|yarn|pnpm] [--topic-separator    colons|spaces] [-d <value>] [-y]FLAGS  -d, --output-dir=<value>        Directory to initialize the CLI in.  -y, --yes                       Use defaults for all prompts. Individual flags will override defaults.      --bin=<value>               Supply answer for prompt: Command bin name the CLI will export      --module-type=<option>      Supply answer for prompt: Select a module type                                  <options: ESM|CommonJS>      --package-manager=<option>  Supply answer for prompt: Select a package manager                                  <options: npm|yarn|pnpm>      --topic-separator=<option>  Supply answer for prompt: Select a topic separator                                  <options: colons|spaces>DESCRIPTION  Initialize a new oclif CLI  This will add the necessary oclif bin files, add oclif config to package.json, and install @oclif/core and ts-node.EXAMPLES  Initialize a new CLI in the current directory    $ oclif init  Initialize a new CLI in a different directory    $ oclif init --output-dir "/path/to/existing/project"  Supply answers for specific prompts    $ oclif init --topic-separator colons --bin mycli
Hope you enjoy the new command! If you come across any issues or have any new ideas for this command, head over to the oclif/oclif repo and open a new issue.
All our best,
The oclif teamoclif Spring 2024 UpdateMarch 29, 2024 · 4 min readHello oclif developers! It's been a while since we last uploaded a blog - and a lot has happened.
We've been focusing on these high-level areas over the past couple of years:

Improving @oclif/core
ESM Support
Improving and revitalizing oclif.io
Re-engaging the oclif community

Improving @oclif/core​
Since we announced @oclif/core over three years ago, we've released two new major versions, each packed with lots of features that we're really excited about.
Here are some of these changes:

Full support for ESM and interoperability with CommonJS (more on this topic below).
Configurable command discovery strategies that give you more control over how commands are loaded at runtime. Check out the docs.
A new preparse hook that allows you to manipulate the provided arguments before they're parsed. Salesforce used this hook to implement a neat --flags-dir feature that translates local files into flags.
A new Performance class that you can use to track performance inside of @oclif/core and your own CLI or plugin. Check out the docs.
A new flag type, Flags.option, that lets you define a flag with a preset list of options. Typescript then uses the options to infer the flag's type.
Flags now have a relationship property that allows you to define more complex relationships between flags. Check out the flags docs for more information.
Flags now have a defaultHelp property that allows you to set the human readable default value in the command help. This property is useful when your flag's parse method returns a complex type, such as an object or a class. Check out the flags docs for more.
Commands now have a hiddenAliases property that allows you to define aliases that you want to hide from the user. The property is super helpful when you're trying to wean users off a deprecated command.
You can now use bun or tsx as dev runtimes (as opposed to node or ts-node).
A command's usage, args, and flags are now shown whenever a user forgets to provide a required arg or flag, or when they provided a non-existent flag.

If you need help migrating to the latest version, head over to core's README which has links to the migration guides. Feel free to open a new discussion if you need more hands-on help from us or the community.
ESM Support​
Version 3 of @oclif/core introduced full support for developing ESM plugins and CLIs. It also offered full support for interoperability between CommonJS and ESM plugins.
Put more simply, you can now migrate your CLI to ESM while keeping individual plugins in CommonJS (or vice versa). The upgrade path is now much simpler for you. You also don't need to worry about any community plugins that have migrated to ESM before you did (such as all the @oclif plugins) or are staunchly sticking with CommonJS for the foreseeable future.
Read more about this topic here.
Improving and Revitalizing oclif.io​
Another area of focus for us has been improving our documentation site, oclif.io.
While improving the quality and accuracy of the documentation was our priority, we also took the time to upgrade to the latest version of docusaurus. This new version gave our site a much-needed facelift, as well as cool new features such as dark mode and announcements.
If you have any feedback or are running into issues, we want to hear about it. Just create an issue in the oclif.io repo.
Re-engaging the oclif Community​
Lastly, our biggest priority at the moment is to re-engage the oclif community. We understand how frustrating it has been over the years to see your issues and pull requests go unacknowledged. We apologize for not prioritizing the community, and are earnestly trying to make sure that every issue and pull request gets the attention it deserves going forward.
We also opened up GitHub discussions for @oclif/core and the oclif CLI, where you can now post your questions or ideas. We hope you take advantage of them, we love hearing from you!
One last thing: we intend to publicly post our roadmap so you have more visibility into what we're working on. Stay tuned!
All our best,
The oclif teamAnnouncing oclif v2!January 12, 2022 · 5 min readHello and happy new year! It's our great pleasure to announce that we have released oclif v2, which uses the new @oclif/core library! 🎉
oclif v2 includes many changes that improve the experience of both creating and using an oclif CLI.
Going forward, we don't plan to make any updates to oclif v1 and its corresponding libraries, except for critical security fixes. See the compatibility matrix for a list of these libraries. In order to give developers time to migrate from v1 to v2, we're not completely dropping support yet. But at some point in the future we'll archive the v1 repositories and deprecate their versions on npm.
What’s changing?​
Repository Changes​
All repositories under the oclif org now use main as their primary branch and oclif-v1 as the legacy branch. The main  branch corresponds to oclif v2 and the oclif-v1 branch to oclif v1. If you find any repos that don’t have a main branch, you can safely assume that they're not used in oclif v2 and will be deprecated in the future.
Consolidating Tools & Libraries​
The oclif-dev CLI has now been incorporated into oclif. You now no longer need to install a separate package to manage your entire CLI’s lifecycle.
The following libraries have been consolidated under @oclif/core and will be deprecated at some point in the future. Read the migration guide to learn how to update your CLI or plugin to use the new core library.

@oclif/command
@oclif/config
@oclif/error
@oclif/help
@oclif/parser

No more single vs multi command CLIs​
There's only one "type" of oclif v2 CLI, but it can have as few or as many commands as a developer wants. As a result, there’s only one command to generate CLIs, oclif generate, as opposed to the old oclif single and oclif multi commands.
Node > 12​
To ensure oclif CLIs are as secure as possible, all v2 libraries and plugins support only Node 12 or higher as of now. Going forward, they'll support only Node Maintenance or higher, as defined by Node's release schedule here: https://nodejs.org/en/about/releases/.
What’s new?​
New example CLI​
oclif-hello-world is our new example repo. This is also the repo that's used as a template when running oclif generate to create a new CLI. This repo will always be able to be referenced as an example of what an oclif v2 CLI should look like.
Spaced commands​
oclif CLIs can now use spaces, instead of colons, to separate topics and subcommands. To enable this feature, simply add “topicSeparator": " " to the oclif config in your package.json. See an example in our example repo.
// Old commands that use :$ mycli do:something
// New spaced commands$ mycli do something

Note: Spaced commands are backwards compatible. So if you enable spaced commands for your CLI, users will still be able to use : as a separator. This ensures that any existing scripts don't break.

New Help Output​
We’ve revamped the way command help is outputted to the terminal, making it both easier to implement and easier to read. See the difference between the old help output on the left and the new help output on the right in the screenshots below.
oclif v1oclif v2
Notice that there are new sections for flags and global flags, examples are displayed with better spacing, and there is a section at the bottom called Configuration Variables. This Configuration Variables section is not part of the new help by default. But we've added support for custom help sections, which is what the sf CLI uses to create the new section.
Async Command Parsing​
We’ve also improved the performance of new CLIs by rewriting how commands are parsed on initialization. The new parser is asynchronous, which makes CLIs with a lot of commands or installed  plugins much faster.
What’s coming next?​
Part of our charter for the release of oclif v2 includes improving our engagement with the oclif community. We know that over the past couple of years we’ve reduced our involvement, and a lot of issues and PRs have languished in limbo. Hopefully you’ve already seen increased activity and responses from oclif maintainers recently, but if you haven’t, please don’t hesitate to ping us by tagging @admins in oclif repos.
We also want to start interviewing members of the oclif community to acquire feedback and prioritize the features and fixes you deem most important!
Best,
The oclif team

Reference material​
Migration Guide​
This guide explains how to upgrade a CLI or plugin from the old oclif v1 libraries to the new @oclif/core library that oclif v2 uses.
https://github.com/oclif/core/blob/main/MIGRATION.md
Compatibility Matrix​
The following matrix shows how the v1 libraries and plugins relate to the new v2 ones. Use this matrix as a guide to know what to drop and which versions to switch when upgrading your plugins and CLIs to v2.
oclif "v1"oclif "v2"Utility CLIsoclif@<2@oclif/dev-cli@<2oclif@>=2Main packages@oclif/command@oclif/config@oclif/errors@oclif/parser@oclif/plugin-help@oclif/core@>=1Node LTSNode v8-14Node v12+ (at time of writing)TypeScripttypescript@<4typescript@>=4Main plugins@oclif/plugin-autocomplete@<1@oclif/plugin-commands@<2@oclif/plugin-help@<4@oclif/plugin-not-found@<2@oclif/plugin-plugins@<2@oclif/plugin-update@<2plugin-warn-if-update-available@<2plugin-which@<2@oclif/plugin-autocomplete@>=1@oclif/plugin-commands@>=2@oclif/plugin-help@>=4@oclif/plugin-not-found@>=2@oclif/plugin-plugins@>=2@oclif/plugin-update@>=2@oclif/plugin-warn-if-update-available@>=2@oclif/plugin-which@>=2Introducing @oclif/coreMarch 1, 2021 · 3 min readGreetings!
We hope this blog post finds you well.
Introducing...​
We are excited to announce the next iteration of the oclif project today: @oclif/core.
We have learned a lot in the last three years of developing oclif, developing on oclif and supporting millions of command runs a day via Heroku and Salesforce CLIs.
@oclif/core ("Core") simplifies the oclif development experience and introduces highly requested new features.
Core combines the essential oclif packages into one "core" package, aptly named @oclif/core.
Core also introduces:

A default command option
Colon or space command syntax
Async command parsing
Command piping to arguments

With the introduction of default command functionality, Core simplifies the oclif project and removes the notion of single or multi command CLIs. Core CLIs can have 1 or many commands.
Along with Core, we moved the oclif-dev CLI into the oclif CLI creating a single "utility" CLI. This CLI also introduces a new AWS S3 compatible publishing scheme.
What to expect in the near future​
Core is in pre-release beta and being actively developed for new internal Salesforce CLIs.
Much documentation needs to be written in the coming months including migration paths. Migration onto Core should be as painless as possible with many exports remaining entirely unchanged. Look for forthcoming blog posts and documentation on oclif.io.
Early this summer, tentively June 1, we will release Core v1. Core's release will coincide with major bumps to many other oclif plugin packages. See the compatibility matrix below.
At Core's v1 release, the current "main" oclif packages (namely: command, config, errors & parser) will go into maintenance mode until Jan 2022. They will receive only bug and security fixes and they remain compatible with current versions of the oclif and oclif-dev CLIs. Afterwhich, they will be archived.
Companioning Core, the next major release of the oclif CLI (literally oclif@2) will generate Core CLIs.
Going forward​
We are excited to release Core! We invite you to poke around the Core repo. It may appear to be a big change but Core keeps what you already enjoy about oclif while reducing development complexity, project dependencies, package coupling and bundle size and introduces many requested features previously too prickly to weave into the current oclif architecture.
Best,
The oclif team
Reference: Compatibility matrix​
oclif "v1"oclif "Core"Utility CLIsoclif@<2@oclif/dev-cli@<2oclif@>=2Main packages@oclif/core@<2@oclif/config@<2@oclif/errors@<2@oclif/parser@<4@oclif/plugin-help@<4@oclif/core@>=1Node LTSNode v8-14Node v12+TypeScripttypescript@<4typescript@>=4Main plugins@oclif/plugin-autocomplete@<1@oclif/plugin-commands@<2@oclif/plugin-help@<4@oclif/plugin-not-found@<2@oclif/plugin-plugins@<2@oclif/plugin-update@<2plugin-warn-if-update-available@<2plugin-which@<2@oclif/plugin-autocomplete@>=2@oclif/plugin-commands@>=2@oclif/plugin-help@>=4@oclif/plugin-not-found@>=2@oclif/plugin-plugins@>=2@oclif/plugin-update@>=2@oclif/plugin-warn-if-update-available@>=2@oclif/plugin-which@>=2oclif Summer 2020 UpdateAugust 26, 2020 · 2 min readHello oclif developers! We hope you are all doing well.
Earlier this year, we started our planning for oclifconf v2 and, like all conference, had to change course. We opted not to hold a virtual conference, however, we wanted to take some time to highlight a few oclif features shipped this year.
Feature: Help templating​
One of the most requested features, help templating enables oclif developers to customize the help output for their CLI.
Read the announcement.
Feature: Custom error delegation​
This feature both improved how oclif throws and handles errors and allows oclif developers to overwrite or interject in oclif’s error handling.
Read the announcement.
Feature: postrun hooks​
We have added a new lifecycle event postrun. Your CLI can now run a hook after a command has ran.
See our hook documentation.
Feature: Root index command​
Previously, oclif would display CLI help if only the binary name with no command ID was invoked, oclif now supports a "root index" command. If present, a command defined at src/commands/index.ts will be run if no command ID is found.
1 million weekly downloads​
While exact oclif usage metrics are hard to pin down, we use npm download statistics of oclif packages as a rough approximation. Earlier this year, oclif's command package hit 1 million weekly downloads for the first time!
This year has been presented its challenges on everyone. We want to thank you, oclif developers, whom have taken the time to use and improve the oclif project. We look forward to seeing you all - in person - in the future!
All our best,
The oclif teamPretty Printable ErrorsJuly 1, 2020 · One min readOften CLIs are used as handy tools and when things go wrong it’s useful to have additional context. In oclif we have added a couple of additional properties that can show extra context to the users when an error is displayed. The code, ref and suggestions will now be displayed if they are included. This will work with an existing oclif CLI by adding the latest @oclif/errors and @oclif/core to the CLI's package.json dependencies.
For example, using this.error with the additional properties:
class TestError extends Command {  async run() {    this.error("An error has occurred!", {      code: "OCLIF_ERR",      ref: "https://oclif.io/docs/commands#thiserrormessage-string--error-options-code-string-exit-number",      suggestions: ["Use these extra properties to provide additional context"],    })  }}
would result with the following output:
›   Error: An error has occurred!›   Code: OCLIF_ERR›   Try this: Use these extra properties to provide additional context›   Reference: https://oclif.io/docs/commands#thiserrormessage-string--error-options-code-string-exit-number
If these properties are not provided then nothing changes and the CLI will continue to display the single error message output as it did before. Additionally, as part of this exercise we’ve added documentation around Error Handling in oclif which should come in handy if the need arises to extend oclif’s default handling of errors.Customizing Help in oclifMay 5, 2020 · 2 min readOut of the box oclif provides a great help experience for CLIs.
But what if, as an oclif developer, you want to customize some or all of the output?
You can now customize your CLI's help output by implementing the HelpBase abstract class.
Getting started with custom help​
If you have not done so yet, update @oclif/core.
$ yarn add --latest @oclif/core
To get started, first define the filepath to your help class in oclif's config in package.json. This is a relative path to the help class, without a file extension.
For this example, the help class will be created in a file at "[project root]/src/help.ts".
{  // ...  "oclif": {    "helpClass": "./lib/help"    // ...  }  // ...}
From here there are two paths, implement the HelpBase abstract class yourself or overwrite the parts of the default Help class you want to customize (ex: how command usage is displayed). We recommend the latter approach but cover both in the new Help Classes docs.
Separating TOPICS & COMMANDS in the new default Help class​
Previously, topics and child commands were listed in help output under a single list heading called "COMMANDS". But we found this can be slightly confusing. Some topics are commands also (a.k.a. topic-commands) while others are simply organizational namespacing (and when ran just show their help).
The new default Help class splits the list of children into distinct lists of "TOPICS" and "COMMANDS", with the possibility of an item appearing in both if it a topic-command. This makes it clearer what is expected to be ran - "COMMANDS" - and what is providing structure - "TOPICS" - when looking at the help output.
VERSION  plugin-help-example/0.0.0 darwin-x64 node-v12.12.0USAGE  $ plugin-help-example [COMMAND]TOPICS  topic  this is a topic and has child topics or commandsCOMMANDS  hello  describe the command here  help   display help for plugin-help-example
We look forward to seeing what custom help features you implement in your oclif CLIs with this new feature!oclif TSLint to ESLint MigrationDecember 5, 2019 · 3 min readBack in February of this year, plans were announced to deprecate TSLint in favor of ESLint. TSLint's goal has become to work toward a “unified developer experience” by supporting ESLint development going forward.
What has changed in oclif​
To keep inline with the community, oclif has transitioned to ESLint for all our core libraries as well as all our official plugins.
Starting in v1.15.x, oclif will now optionally generate projects with ESLint for both TypeScript and JavaScript CLI’s.
ESLint does require Node to be on stable LTS version, at the time of writing, Node 8.10.x, Node 10.13.x & Node 12.x.x.
How does this affect you​
Existing CLI’s are unchanged, but any newly generated CLI's will only give the option of using ESLint. If you are running tslint in your CLI, we recommend you switch to ESLint as well.
In migrating our projects we took the following steps (for an example of these changes see this pull request).


Install eslint
$ yarn add eslint eslint-config-oclif eslint-config-oclif-typescript --dev


Add eslint related files


$ echo '{  "extends": [    "oclif",    "oclif-typescript"  ],  "rules": {  }}' > .eslintrc


Remove tslint and related packages
$ yarn remove @oclif/tslint tslint


Remove tslint related configuration files
$ rm tslint.json


Change lint script in our package.json from something like:
"lint": "tsc -p test --noEmit && tslint -p test -t stylish"
to
"lint": "eslint . --ext .ts --config .eslintrc"


To preserve the test compile (tsc -p test --noEmit) we also made the following updates to our scripts:
"pretest": "tsc -p test --noEmit"
In some cases we had our posttest duplicating the same steps as our lint script so it’s cleaner to have it reference the lint job directly with:
"posttest": "yarn lint"

Run yarn lint --fix. This attempts to auto-fix any linting violations automatically. In the case an auto-fix isn’t available it should be fixed manually or ignored (see the eslint configuration doc for more information)
Do a search in the codebase for tslint and remove any unnecessary tslint disabling comments, like:

/* tslint:disable:object-literal-sort-keys */
If you are on a version of Node that is not supported by ESLint, you will also need to update your Node engine. ESLint supports Node 8, 10, and 12 so you should upgrade to the most recent Node version compatible with your CLI and also supported by ESLint (see ESLint's Installation and Usage instructions).
When will this take effect​
These changes have taken effect in oclif v1.15.1. When you generate a new CLI or plugin it will now contain configuration for ESLint instead of TSLint.oclif's Current Node SupportOctober 31, 2019 · 3 min readTo maintain a healthy project trajectory, oclif follows and supports Node Active LTS release, currently Node 10 & Node 12. This means ensuring that oclif continues to play nice with coming Active LTS Node versions and other packages in the ecosystem. Moving forward also means leaving older versions behind. Starting in 2020, Node will stop maintaining Node 8 and it is our intent at that time to also follow suit. Let’s take a look at a few ways we will be supporting these changes.
CI Environments​
CLIs created with the oclif cli going forward will be generated with a CircleCI configuration with Node 10 & 12 and an Appveyor configuration using Node 10. We have also added Node latest to CircleCi to be an early warning detection against coming Node changes (Node latest is managed by CircleCI).
We have already updated every oclif repo's CI configs to reflect this.
If your existing CLI uses either Appveyor or CircleCI you can update your config files also, like so:
.circleci/config.yml​
Your CircleCI config should contain a node-latest job, aliased as test. From this, there should be two extensions of this job for the Active LTS Node versions, Node 10 and Node 12.
  node-10:    <<: *node-latest    docker:      - image: node:10  node-12:    <<: *node-latest    docker:      - image: node:12
Notice that these declarations only change the Docker Node images used to run that job.
Additionally, the jobs listed within workflows must also be updated to reflect our changes in configuration:
    jobs:      - node-latest      - node-10      - node-12
appveyor.yml​
For appveyor we are currently only testing the oldest Active LTS Node version, Node 10. Update the nodejs_version proppert in your appveyor.yml file to reflect this.
environment:  nodejs_version: "10"
Deprecating Node 8 & Updating packge.json engines​
In Jan 2020, Node will end its Node 8 maintenance. We will follow suit by setting the package.json engine property in oclif packages to >=10 and bumping the package's major versions.
Depending on how you ship your CLI you may wish to also bump the engines version in your CLI's package.json. You can read more about the implications of the engines property configuration in the npm documentation.
Also consider distributing your CLI with its own Node version.
Packaged Node Version​
When using dev-cli to pack your CLI it will use the Node version as specified in your package.json under the oclif.update.node.version property. This value should reflect an Active LTS Node version (dev-cli does not currently enforce versions).
Supporting the future​
As a community we may discover bumps along the way as we upgrade. If you notice something related to oclif please feel free to open an issue or submit a pull request under the relevant oclif package within the org.
We look forward to using the latest from Node and the community and keeping oclif healthy along the way.oclifconf 2019: A RecapSeptember 16, 2019 · 4 min readIn May, Heroku and Salesforce Open Source organized oclifconf, a conference for developers & product managers building CLI tools on top of the open source oclif framework. The speakers came from various tech companies, such as Adobe, Netlify, and Apollo, who have already built amazing CLI experiences. The topics covered everything from the incredible capabilities oclif has unlocked, to the community-built plugins extending its functionality, and even what the behavior of an adaptive CLI tool might look like.
Below is a listing of all of the talks from the event, along with a short summary. Enjoy!
The future of oclif by Jeff Dickey​

In its relatively short lifetime, oclif has already inspired many developers and companies to adopt its framework as a means for implementing their own command-line tooling. In this talk, Jeff Dickey, an oclif founding team member, recaps the project's history and inspiration. He also looks towards the future and outlines some features and improvements that the tool could adapt. This isn't so much a definitive roadmap of where oclif is headed, but rather, a call to inspiration for developers eager to contribute! And if you are interested in contributing, check out the open issues in the oclif GitHub repo and come say "Hello!" on Spectrum Chat.
Open Source Citizenship by Josh Simmons​

When it comes to open source, it's more than just individuals now. More and more frequently, large corporations are contributing to projects by donating to contributors, sponsoring events, or upstreaming contributions. But keeping open source projects and communities healthy requires more than just money and brainpower. Josh Simmons surveyed multiple open source communities and relays his findings as to what help maintainers and contributors actually need in this talk.
Building an enterprise-grade CLI with oclif by Thomas Dvornik​

Security and performance are all about trust. While oclif is an extremely extensible framework for building CLI tooling, there are additional requirements to fulfill for enterprise businesses to adopt it that might not be necessary for individual developers. Thomas Dvornik outlines what he and his colleagues at Salesforce have implemented as plugins to oclif to satisfy these needs, including encrypted OAuth, plugin signing, lazy loading dependencies, synchronizing weekly releases and deprecations across dozens of repositories, and establishing cross-team coding and documentation standards.
How Adobe I/O built an extensible CLI with oclif by Jesse MacFadyen​

Perhaps oclif's most appealing feature is its support for plugins. In Cordova's case, they've created a sophisticated telemetry system that helps Adobe developers see which commands users are using--and reports on which ones are erroring out. By embedding a feedback system into the tool, users are even able to quickly send their suggestions to a form, without ever leaving the terminal. Jesse MacFadyen demonstrates how oclif's plugin system can work beyond simply executing commands.
Integrating oclif with GraphQL and Apollo by Evans Hauser​

For Evans Hauser and the team at Apollo, oclif is best thought of as "React for the CLI." As a client paired with a strongly-typed API contract to a server, it can deliver structured and consistent commands to retrieve external data. What better mechanism to use for this transfer than GraphQL, a framework which empowers the client to ask precisely for the data it needs, and nothing more?
Adaptive Intent-based CLI State Machines by Shawn Wang​

In designing oclif, Jeff Dickey wrote out 12 CLI factors to keep in mind. In this talk, Shawn Wang outlines a 13th: state. State is hard, because it depends on context, and context depends on understanding what a user intends to do, not what they are asking. Shawn is working towards enabling oclif to better understand the commands a user has entered, so that it can predict and interpret future commands that might be entered next. This would enable CLI tools to not just interpret a users' commands, but to also interpret their intent.Older Entries\n\n\n\nGuidesReleaseOn this pageReleaseThere are 2 main strategies for releasing oclif CLIs: npm and standalone tarballs. You can publish to one or both.
npm​
Just use npm publish like any other npm project. This includes a run.cmd script that will automatically be used for Windows users.
$ npm version (major|minor|patch) # bumps version, updates README, adds git tag$ npm publish$ npm install -g mynewcli$ mynewcli# OR$ npx mynewcli
You'll need to register with npm and have verified your email address in order to publish.
This workflow can be improved slightly by running npm version major|minor|patch before publishing which will create a git tag and bump the version automatically.
Standalone tarballs​
Build standalone tarballs with oclif pack tarballs from the root of your CLI. These include the node binary so the user does not have to already have node installed to use the CLI. It won't put this node binary on the PATH so the binary will not conflict with any node installation on the machine.
To publish, you can copy the files from ./dist or use oclif upload tarballs to copy the files to S3. You'll need to set oclif.update.s3.bucket in package.json to a valid S3 bucket and have credentials set in AWS_ACCESS_KEY_ID and AWS_SECRET_ACCESS_KEY environment vars.
After you've uploaded the tarballs to S3, you can promote the tarballs to a release channel within S3 using oclif promote. This allows you to quickly promote and demote a specific version between release channels. For example, the Salesforce CLI has separate stable and stable-rc channels that are updated weekly.
Brew​
Your formula can be distributed through Brew. The main caveat is you must set the CLIENT_HOME variable when you ship, otherwise it will break the update cycle. An example of this can be found in the heroku cli formula. By exporting a variable of the form CLI_NAME_OCLIF_CLIENT_HOME (where CLI_NAME is the name of your CLI), you force the update mechanism to look at the brew install location instead of the default (which is $XDG_DATA_HOME/.local/share/package_name/client).
Autoupdater​
These tarballs as well as the installers below can be made autoupdatable by adding the @oclif/plugin-update plugin. Just add this plugin and the CLI will autoupdate in the background or when mycli update is run.
If you don't want to use S3, you can still run oclif pack and it will build tarballs. To get the updater to work, set oclif.update.s3.host in package.json to a host that has the files built in ./dist from oclif pack. This host does not need to be an S3 host. To customize the URL paths, see the S3 templates in @oclif/core.
Autoupdate Channels​
You can have separate channels for releases that work like Google Chrome Channels (such as beta, dev, canary). To create a channel, just change the version in package.json from 1.0.0 to 1.0.0-beta (where "beta" is any string you like). Then when you pack with oclif pack, it will create beta tarballs. The user can change their channel with mycli update beta and will receive all the future releases on that channel.
In the Heroku CLI, we have it automatically build and release the beta channel on every commit to the master branch. Then we have it build and release stable channel whenever a git tag is created in our CI.
Windows installer​
Build a windows installer with oclif pack win. It will build into ./dist/win. This can be uploaded to S3 with oclif upload win and promoted within S3 with oclif promote --win.
oclif pack win depends on having 7zip and nsis installed. If you're in a mac or unix environment and don't have them, you can use homebrew to install them.
brew install nsisbrew install p7zip
Signing the installer​
To produce a signed installer you need to set the scoped <CLI>_WINDOWS_SIGNING_PASS env var (e.g. MY_CLI_WINDOWS_SIGNING_PASS) and set windows.name and windows.keypath in your package.json:
{  "oclif": {    "windows": {      "name": "My CLI",      "keypath": "path/to/private.key"    }  }}
Refer to Microsoft's documentation on how to acquire a verified digital signature for your CLI.
macOS installer​
Build a macOS .pkg installer with oclif pack macos. It will build into ./dist/macos. This can be uploaded to S3 with oclif upload macos and promoted within S3 with oclif promote --macos. You need to set the macOS identifier at oclif.macos.identifier in package.json (we use "com.heroku.cli" and "com.salesforce.cli" as the identifiers for the Heroku CLI and the Salesforce CLI, respectively).
Uploading to S3​
The upload command defaults to using the ACL setting public-read unless another policy is specified under oclif.update.s3.acl in package.json. However, when creating new S3 buckets, AWS's default recommendation can result in an access error (Code: AccessControlListNotSupported) when trying to upload with the public-read setting.
To address this, consider updating the oclif section of your package.json with the desired ACL setting. The example below demonstrates how to set the acl to bucket-owner-full-control:
{  "oclif": {    "bin": "myOclifApp",    "dirname": "myOclifApp-cli-data",    "update": {      "s3": {        "host": "https://s3.console.aws.amazon.com/",        "bucket": "myOclifApp-cli",        "acl": "bucket-owner-full-control"      }    },    "macos": {      "identifier": "com.myOclifApp.cli"    }  }}
Amazon has a userguide here for help how to configure Bucket Policy settings.
Signing the installer​
To be able to sign an "installer signing identity" has to be available on the build machine (read more on certificates here).
Make sure such a certificate is created in developer.apple.com and that the certificate is downloaded and installed in the KeyChain of the build machine.
The certificate name has to be specified in the oclif.macos.sign in package.json.
Example:
    "macos": {      "identifier": "com.myOclifApp",      "sign": "\"3rd Party Mac Developer Installer: myOclifCompany (R2315646)\""    },
Pay attention to the escaped quotation marks, the certificate name is passed on as an argument to the pkgbuild command so without quotation marks it might break.
For the Heroku CLI the certificate name is "Developer ID Installer: Heroku INC". And optionally set the keychain with OSX_KEYCHAIN.
Installed certificates on the build machine can be viewed in the Keychain Access app.
Ubuntu/Debian packages​
Build a deb package with oclif pack deb. Set the MYCLI_DEB_KEY to a gpg key id to create the gpg files. This will include all the files needed for an apt repository in ./dist/deb. They can be uploaded to S3 with oclif upload deb and promoted within S3 using oclif promote --deb.
Once it's published to S3, users can install with the following:
$ wget -qO- https://mys3bucket.s3.amazonaws.com/apt/release.key | apt-key add - # you will need to upload this file manually$ sudo echo "deb https://mys3bucket.s3.amazonaws.com/apt ./" > /etc/apt/sources.list.d/mycli.list$ sudo apt update$ sudo apt install -y mycli
This can be placed in a script for users to install with curl https://pathto/myscript | sh.
These will not autoupdate as Ubuntu already has a reliable way for users to update their package.
Snapcraft​
Snap is a great way to distribute Linux CLIs and comes built into Ubuntu 16+. The Heroku CLI's snapcraft.yml file can be easily modified to work with any oclif CLI.Edit this pageLast updated on Dec 20, 2024 by Mike Donnalley\n\nGuidesReleaseOn this pageReleaseThere are 2 main strategies for releasing oclif CLIs: npm and standalone tarballs. You can publish to one or both.
npm​
Just use npm publish like any other npm project. This includes a run.cmd script that will automatically be used for Windows users.
$ npm version (major|minor|patch) # bumps version, updates README, adds git tag$ npm publish$ npm install -g mynewcli$ mynewcli# OR$ npx mynewcli
You'll need to register with npm and have verified your email address in order to publish.
This workflow can be improved slightly by running npm version major|minor|patch before publishing which will create a git tag and bump the version automatically.
Standalone tarballs​
Build standalone tarballs with oclif pack tarballs from the root of your CLI. These include the node binary so the user does not have to already have node installed to use the CLI. It won't put this node binary on the PATH so the binary will not conflict with any node installation on the machine.
To publish, you can copy the files from ./dist or use oclif upload tarballs to copy the files to S3. You'll need to set oclif.update.s3.bucket in package.json to a valid S3 bucket and have credentials set in AWS_ACCESS_KEY_ID and AWS_SECRET_ACCESS_KEY environment vars.
After you've uploaded the tarballs to S3, you can promote the tarballs to a release channel within S3 using oclif promote. This allows you to quickly promote and demote a specific version between release channels. For example, the Salesforce CLI has separate stable and stable-rc channels that are updated weekly.
Brew​
Your formula can be distributed through Brew. The main caveat is you must set the CLIENT_HOME variable when you ship, otherwise it will break the update cycle. An example of this can be found in the heroku cli formula. By exporting a variable of the form CLI_NAME_OCLIF_CLIENT_HOME (where CLI_NAME is the name of your CLI), you force the update mechanism to look at the brew install location instead of the default (which is $XDG_DATA_HOME/.local/share/package_name/client).
Autoupdater​
These tarballs as well as the installers below can be made autoupdatable by adding the @oclif/plugin-update plugin. Just add this plugin and the CLI will autoupdate in the background or when mycli update is run.
If you don't want to use S3, you can still run oclif pack and it will build tarballs. To get the updater to work, set oclif.update.s3.host in package.json to a host that has the files built in ./dist from oclif pack. This host does not need to be an S3 host. To customize the URL paths, see the S3 templates in @oclif/core.
Autoupdate Channels​
You can have separate channels for releases that work like Google Chrome Channels (such as beta, dev, canary). To create a channel, just change the version in package.json from 1.0.0 to 1.0.0-beta (where "beta" is any string you like). Then when you pack with oclif pack, it will create beta tarballs. The user can change their channel with mycli update beta and will receive all the future releases on that channel.
In the Heroku CLI, we have it automatically build and release the beta channel on every commit to the master branch. Then we have it build and release stable channel whenever a git tag is created in our CI.
Windows installer​
Build a windows installer with oclif pack win. It will build into ./dist/win. This can be uploaded to S3 with oclif upload win and promoted within S3 with oclif promote --win.
oclif pack win depends on having 7zip and nsis installed. If you're in a mac or unix environment and don't have them, you can use homebrew to install them.
brew install nsisbrew install p7zip
Signing the installer​
To produce a signed installer you need to set the scoped <CLI>_WINDOWS_SIGNING_PASS env var (e.g. MY_CLI_WINDOWS_SIGNING_PASS) and set windows.name and windows.keypath in your package.json:
{  "oclif": {    "windows": {      "name": "My CLI",      "keypath": "path/to/private.key"    }  }}
Refer to Microsoft's documentation on how to acquire a verified digital signature for your CLI.
macOS installer​
Build a macOS .pkg installer with oclif pack macos. It will build into ./dist/macos. This can be uploaded to S3 with oclif upload macos and promoted within S3 with oclif promote --macos. You need to set the macOS identifier at oclif.macos.identifier in package.json (we use "com.heroku.cli" and "com.salesforce.cli" as the identifiers for the Heroku CLI and the Salesforce CLI, respectively).
Uploading to S3​
The upload command defaults to using the ACL setting public-read unless another policy is specified under oclif.update.s3.acl in package.json. However, when creating new S3 buckets, AWS's default recommendation can result in an access error (Code: AccessControlListNotSupported) when trying to upload with the public-read setting.
To address this, consider updating the oclif section of your package.json with the desired ACL setting. The example below demonstrates how to set the acl to bucket-owner-full-control:
{  "oclif": {    "bin": "myOclifApp",    "dirname": "myOclifApp-cli-data",    "update": {      "s3": {        "host": "https://s3.console.aws.amazon.com/",        "bucket": "myOclifApp-cli",        "acl": "bucket-owner-full-control"      }    },    "macos": {      "identifier": "com.myOclifApp.cli"    }  }}
Amazon has a userguide here for help how to configure Bucket Policy settings.
Signing the installer​
To be able to sign an "installer signing identity" has to be available on the build machine (read more on certificates here).
Make sure such a certificate is created in developer.apple.com and that the certificate is downloaded and installed in the KeyChain of the build machine.
The certificate name has to be specified in the oclif.macos.sign in package.json.
Example:
    "macos": {      "identifier": "com.myOclifApp",      "sign": "\"3rd Party Mac Developer Installer: myOclifCompany (R2315646)\""    },
Pay attention to the escaped quotation marks, the certificate name is passed on as an argument to the pkgbuild command so without quotation marks it might break.
For the Heroku CLI the certificate name is "Developer ID Installer: Heroku INC". And optionally set the keychain with OSX_KEYCHAIN.
Installed certificates on the build machine can be viewed in the Keychain Access app.
Ubuntu/Debian packages​
Build a deb package with oclif pack deb. Set the MYCLI_DEB_KEY to a gpg key id to create the gpg files. This will include all the files needed for an apt repository in ./dist/deb. They can be uploaded to S3 with oclif upload deb and promoted within S3 using oclif promote --deb.
Once it's published to S3, users can install with the following:
$ wget -qO- https://mys3bucket.s3.amazonaws.com/apt/release.key | apt-key add - # you will need to upload this file manually$ sudo echo "deb https://mys3bucket.s3.amazonaws.com/apt ./" > /etc/apt/sources.list.d/mycli.list$ sudo apt update$ sudo apt install -y mycli
This can be placed in a script for users to install with curl https://pathto/myscript | sh.
These will not autoupdate as Ubuntu already has a reliable way for users to update their package.
Snapcraft​
Snap is a great way to distribute Linux CLIs and comes built into Ubuntu 16+. The Heroku CLI's snapcraft.yml file can be easily modified to work with any oclif CLI.Edit this pageLast updated on Dec 20, 2024 by Mike DonnalleyPreviousNSIS Installer CustomizationNextRunning Commands ProgrammaticallynpmStandalone tarballsBrewAutoupdaterAutoupdate ChannelsWindows installerSigning the installermacOS installerUploading to S3Signing the installerUbuntu/Debian packagesSnapcraft\n\n\n\nIntroducing `oclif init` commandApril 10, 2024 · 2 min readThanks to the contribution of @joshcanhelp we released a new command for the oclif CLI called oclif init in version 4.8.0
The oclif init command allows you to initialize oclif in an existing project directory by adding the bare minimum requirements: a few pieces of configuration, bin scripts, and a couple of dependencies (@oclif/core and ts-node). This is slightly different from oclif generate, which will create an entirely new oclif project based on our templates.
oclif init will add the following:

bin scripts: bin/run.js, bin/run.cmd, bin/dev.js, and bin/dev.cmd
oclif section to package.json with bin, dirname, commands, and topicSeparator set (See Configuring Your CLI for more)
@oclif/core to dependencies in your package.json (if it's not already there)
ts-node to devDependencies in your package.json (if it's not already there)

Once you've initialized oclif, you can use the bin scripts to execute your CLI. You can also use the other oclif commands like oclif generate command and oclif generate hook to start adding new functionality.

❯ oclif init --helpInitialize a new oclif CLIUSAGE  $ oclif init [--bin <value>] [--module-type ESM|CommonJS] [--package-manager npm|yarn|pnpm] [--topic-separator    colons|spaces] [-d <value>] [-y]FLAGS  -d, --output-dir=<value>        Directory to initialize the CLI in.  -y, --yes                       Use defaults for all prompts. Individual flags will override defaults.      --bin=<value>               Supply answer for prompt: Command bin name the CLI will export      --module-type=<option>      Supply answer for prompt: Select a module type                                  <options: ESM|CommonJS>      --package-manager=<option>  Supply answer for prompt: Select a package manager                                  <options: npm|yarn|pnpm>      --topic-separator=<option>  Supply answer for prompt: Select a topic separator                                  <options: colons|spaces>DESCRIPTION  Initialize a new oclif CLI  This will add the necessary oclif bin files, add oclif config to package.json, and install @oclif/core and ts-node.EXAMPLES  Initialize a new CLI in the current directory    $ oclif init  Initialize a new CLI in a different directory    $ oclif init --output-dir "/path/to/existing/project"  Supply answers for specific prompts    $ oclif init --topic-separator colons --bin mycli
Hope you enjoy the new command! If you come across any issues or have any new ideas for this command, head over to the oclif/oclif repo and open a new issue.
All our best,
The oclif teamoclif Spring 2024 UpdateMarch 29, 2024 · 4 min readHello oclif developers! It's been a while since we last uploaded a blog - and a lot has happened.
We've been focusing on these high-level areas over the past couple of years:

Improving @oclif/core
ESM Support
Improving and revitalizing oclif.io
Re-engaging the oclif community

Improving @oclif/core​
Since we announced @oclif/core over three years ago, we've released two new major versions, each packed with lots of features that we're really excited about.
Here are some of these changes:

Full support for ESM and interoperability with CommonJS (more on this topic below).
Configurable command discovery strategies that give you more control over how commands are loaded at runtime. Check out the docs.
A new preparse hook that allows you to manipulate the provided arguments before they're parsed. Salesforce used this hook to implement a neat --flags-dir feature that translates local files into flags.
A new Performance class that you can use to track performance inside of @oclif/core and your own CLI or plugin. Check out the docs.
A new flag type, Flags.option, that lets you define a flag with a preset list of options. Typescript then uses the options to infer the flag's type.
Flags now have a relationship property that allows you to define more complex relationships between flags. Check out the flags docs for more information.
Flags now have a defaultHelp property that allows you to set the human readable default value in the command help. This property is useful when your flag's parse method returns a complex type, such as an object or a class. Check out the flags docs for more.
Commands now have a hiddenAliases property that allows you to define aliases that you want to hide from the user. The property is super helpful when you're trying to wean users off a deprecated command.
You can now use bun or tsx as dev runtimes (as opposed to node or ts-node).
A command's usage, args, and flags are now shown whenever a user forgets to provide a required arg or flag, or when they provided a non-existent flag.

If you need help migrating to the latest version, head over to core's README which has links to the migration guides. Feel free to open a new discussion if you need more hands-on help from us or the community.
ESM Support​
Version 3 of @oclif/core introduced full support for developing ESM plugins and CLIs. It also offered full support for interoperability between CommonJS and ESM plugins.
Put more simply, you can now migrate your CLI to ESM while keeping individual plugins in CommonJS (or vice versa). The upgrade path is now much simpler for you. You also don't need to worry about any community plugins that have migrated to ESM before you did (such as all the @oclif plugins) or are staunchly sticking with CommonJS for the foreseeable future.
Read more about this topic here.
Improving and Revitalizing oclif.io​
Another area of focus for us has been improving our documentation site, oclif.io.
While improving the quality and accuracy of the documentation was our priority, we also took the time to upgrade to the latest version of docusaurus. This new version gave our site a much-needed facelift, as well as cool new features such as dark mode and announcements.
If you have any feedback or are running into issues, we want to hear about it. Just create an issue in the oclif.io repo.
Re-engaging the oclif Community​
Lastly, our biggest priority at the moment is to re-engage the oclif community. We understand how frustrating it has been over the years to see your issues and pull requests go unacknowledged. We apologize for not prioritizing the community, and are earnestly trying to make sure that every issue and pull request gets the attention it deserves going forward.
We also opened up GitHub discussions for @oclif/core and the oclif CLI, where you can now post your questions or ideas. We hope you take advantage of them, we love hearing from you!
One last thing: we intend to publicly post our roadmap so you have more visibility into what we're working on. Stay tuned!
All our best,
The oclif teamAnnouncing oclif v2!January 12, 2022 · 5 min readHello and happy new year! It's our great pleasure to announce that we have released oclif v2, which uses the new @oclif/core library! 🎉
oclif v2 includes many changes that improve the experience of both creating and using an oclif CLI.
Going forward, we don't plan to make any updates to oclif v1 and its corresponding libraries, except for critical security fixes. See the compatibility matrix for a list of these libraries. In order to give developers time to migrate from v1 to v2, we're not completely dropping support yet. But at some point in the future we'll archive the v1 repositories and deprecate their versions on npm.
What’s changing?​
Repository Changes​
All repositories under the oclif org now use main as their primary branch and oclif-v1 as the legacy branch. The main  branch corresponds to oclif v2 and the oclif-v1 branch to oclif v1. If you find any repos that don’t have a main branch, you can safely assume that they're not used in oclif v2 and will be deprecated in the future.
Consolidating Tools & Libraries​
The oclif-dev CLI has now been incorporated into oclif. You now no longer need to install a separate package to manage your entire CLI’s lifecycle.
The following libraries have been consolidated under @oclif/core and will be deprecated at some point in the future. Read the migration guide to learn how to update your CLI or plugin to use the new core library.

@oclif/command
@oclif/config
@oclif/error
@oclif/help
@oclif/parser

No more single vs multi command CLIs​
There's only one "type" of oclif v2 CLI, but it can have as few or as many commands as a developer wants. As a result, there’s only one command to generate CLIs, oclif generate, as opposed to the old oclif single and oclif multi commands.
Node > 12​
To ensure oclif CLIs are as secure as possible, all v2 libraries and plugins support only Node 12 or higher as of now. Going forward, they'll support only Node Maintenance or higher, as defined by Node's release schedule here: https://nodejs.org/en/about/releases/.
What’s new?​
New example CLI​
oclif-hello-world is our new example repo. This is also the repo that's used as a template when running oclif generate to create a new CLI. This repo will always be able to be referenced as an example of what an oclif v2 CLI should look like.
Spaced commands​
oclif CLIs can now use spaces, instead of colons, to separate topics and subcommands. To enable this feature, simply add “topicSeparator": " " to the oclif config in your package.json. See an example in our example repo.
// Old commands that use :$ mycli do:something
// New spaced commands$ mycli do something

Note: Spaced commands are backwards compatible. So if you enable spaced commands for your CLI, users will still be able to use : as a separator. This ensures that any existing scripts don't break.

New Help Output​
We’ve revamped the way command help is outputted to the terminal, making it both easier to implement and easier to read. See the difference between the old help output on the left and the new help output on the right in the screenshots below.
oclif v1oclif v2
Notice that there are new sections for flags and global flags, examples are displayed with better spacing, and there is a section at the bottom called Configuration Variables. This Configuration Variables section is not part of the new help by default. But we've added support for custom help sections, which is what the sf CLI uses to create the new section.
Async Command Parsing​
We’ve also improved the performance of new CLIs by rewriting how commands are parsed on initialization. The new parser is asynchronous, which makes CLIs with a lot of commands or installed  plugins much faster.
What’s coming next?​
Part of our charter for the release of oclif v2 includes improving our engagement with the oclif community. We know that over the past couple of years we’ve reduced our involvement, and a lot of issues and PRs have languished in limbo. Hopefully you’ve already seen increased activity and responses from oclif maintainers recently, but if you haven’t, please don’t hesitate to ping us by tagging @admins in oclif repos.
We also want to start interviewing members of the oclif community to acquire feedback and prioritize the features and fixes you deem most important!
Best,
The oclif team

Reference material​
Migration Guide​
This guide explains how to upgrade a CLI or plugin from the old oclif v1 libraries to the new @oclif/core library that oclif v2 uses.
https://github.com/oclif/core/blob/main/MIGRATION.md
Compatibility Matrix​
The following matrix shows how the v1 libraries and plugins relate to the new v2 ones. Use this matrix as a guide to know what to drop and which versions to switch when upgrading your plugins and CLIs to v2.
oclif "v1"oclif "v2"Utility CLIsoclif@<2@oclif/dev-cli@<2oclif@>=2Main packages@oclif/command@oclif/config@oclif/errors@oclif/parser@oclif/plugin-help@oclif/core@>=1Node LTSNode v8-14Node v12+ (at time of writing)TypeScripttypescript@<4typescript@>=4Main plugins@oclif/plugin-autocomplete@<1@oclif/plugin-commands@<2@oclif/plugin-help@<4@oclif/plugin-not-found@<2@oclif/plugin-plugins@<2@oclif/plugin-update@<2plugin-warn-if-update-available@<2plugin-which@<2@oclif/plugin-autocomplete@>=1@oclif/plugin-commands@>=2@oclif/plugin-help@>=4@oclif/plugin-not-found@>=2@oclif/plugin-plugins@>=2@oclif/plugin-update@>=2@oclif/plugin-warn-if-update-available@>=2@oclif/plugin-which@>=2Introducing @oclif/coreMarch 1, 2021 · 3 min readGreetings!
We hope this blog post finds you well.
Introducing...​
We are excited to announce the next iteration of the oclif project today: @oclif/core.
We have learned a lot in the last three years of developing oclif, developing on oclif and supporting millions of command runs a day via Heroku and Salesforce CLIs.
@oclif/core ("Core") simplifies the oclif development experience and introduces highly requested new features.
Core combines the essential oclif packages into one "core" package, aptly named @oclif/core.
Core also introduces:

A default command option
Colon or space command syntax
Async command parsing
Command piping to arguments

With the introduction of default command functionality, Core simplifies the oclif project and removes the notion of single or multi command CLIs. Core CLIs can have 1 or many commands.
Along with Core, we moved the oclif-dev CLI into the oclif CLI creating a single "utility" CLI. This CLI also introduces a new AWS S3 compatible publishing scheme.
What to expect in the near future​
Core is in pre-release beta and being actively developed for new internal Salesforce CLIs.
Much documentation needs to be written in the coming months including migration paths. Migration onto Core should be as painless as possible with many exports remaining entirely unchanged. Look for forthcoming blog posts and documentation on oclif.io.
Early this summer, tentively June 1, we will release Core v1. Core's release will coincide with major bumps to many other oclif plugin packages. See the compatibility matrix below.
At Core's v1 release, the current "main" oclif packages (namely: command, config, errors & parser) will go into maintenance mode until Jan 2022. They will receive only bug and security fixes and they remain compatible with current versions of the oclif and oclif-dev CLIs. Afterwhich, they will be archived.
Companioning Core, the next major release of the oclif CLI (literally oclif@2) will generate Core CLIs.
Going forward​
We are excited to release Core! We invite you to poke around the Core repo. It may appear to be a big change but Core keeps what you already enjoy about oclif while reducing development complexity, project dependencies, package coupling and bundle size and introduces many requested features previously too prickly to weave into the current oclif architecture.
Best,
The oclif team
Reference: Compatibility matrix​
oclif "v1"oclif "Core"Utility CLIsoclif@<2@oclif/dev-cli@<2oclif@>=2Main packages@oclif/core@<2@oclif/config@<2@oclif/errors@<2@oclif/parser@<4@oclif/plugin-help@<4@oclif/core@>=1Node LTSNode v8-14Node v12+TypeScripttypescript@<4typescript@>=4Main plugins@oclif/plugin-autocomplete@<1@oclif/plugin-commands@<2@oclif/plugin-help@<4@oclif/plugin-not-found@<2@oclif/plugin-plugins@<2@oclif/plugin-update@<2plugin-warn-if-update-available@<2plugin-which@<2@oclif/plugin-autocomplete@>=2@oclif/plugin-commands@>=2@oclif/plugin-help@>=4@oclif/plugin-not-found@>=2@oclif/plugin-plugins@>=2@oclif/plugin-update@>=2@oclif/plugin-warn-if-update-available@>=2@oclif/plugin-which@>=2oclif Summer 2020 UpdateAugust 26, 2020 · 2 min readHello oclif developers! We hope you are all doing well.
Earlier this year, we started our planning for oclifconf v2 and, like all conference, had to change course. We opted not to hold a virtual conference, however, we wanted to take some time to highlight a few oclif features shipped this year.
Feature: Help templating​
One of the most requested features, help templating enables oclif developers to customize the help output for their CLI.
Read the announcement.
Feature: Custom error delegation​
This feature both improved how oclif throws and handles errors and allows oclif developers to overwrite or interject in oclif’s error handling.
Read the announcement.
Feature: postrun hooks​
We have added a new lifecycle event postrun. Your CLI can now run a hook after a command has ran.
See our hook documentation.
Feature: Root index command​
Previously, oclif would display CLI help if only the binary name with no command ID was invoked, oclif now supports a "root index" command. If present, a command defined at src/commands/index.ts will be run if no command ID is found.
1 million weekly downloads​
While exact oclif usage metrics are hard to pin down, we use npm download statistics of oclif packages as a rough approximation. Earlier this year, oclif's command package hit 1 million weekly downloads for the first time!
This year has been presented its challenges on everyone. We want to thank you, oclif developers, whom have taken the time to use and improve the oclif project. We look forward to seeing you all - in person - in the future!
All our best,
The oclif teamPretty Printable ErrorsJuly 1, 2020 · One min readOften CLIs are used as handy tools and when things go wrong it’s useful to have additional context. In oclif we have added a couple of additional properties that can show extra context to the users when an error is displayed. The code, ref and suggestions will now be displayed if they are included. This will work with an existing oclif CLI by adding the latest @oclif/errors and @oclif/core to the CLI's package.json dependencies.
For example, using this.error with the additional properties:
class TestError extends Command {  async run() {    this.error("An error has occurred!", {      code: "OCLIF_ERR",      ref: "https://oclif.io/docs/commands#thiserrormessage-string--error-options-code-string-exit-number",      suggestions: ["Use these extra properties to provide additional context"],    })  }}
would result with the following output:
›   Error: An error has occurred!›   Code: OCLIF_ERR›   Try this: Use these extra properties to provide additional context›   Reference: https://oclif.io/docs/commands#thiserrormessage-string--error-options-code-string-exit-number
If these properties are not provided then nothing changes and the CLI will continue to display the single error message output as it did before. Additionally, as part of this exercise we’ve added documentation around Error Handling in oclif which should come in handy if the need arises to extend oclif’s default handling of errors.Customizing Help in oclifMay 5, 2020 · 2 min readOut of the box oclif provides a great help experience for CLIs.
But what if, as an oclif developer, you want to customize some or all of the output?
You can now customize your CLI's help output by implementing the HelpBase abstract class.
Getting started with custom help​
If you have not done so yet, update @oclif/core.
$ yarn add --latest @oclif/core
To get started, first define the filepath to your help class in oclif's config in package.json. This is a relative path to the help class, without a file extension.
For this example, the help class will be created in a file at "[project root]/src/help.ts".
{  // ...  "oclif": {    "helpClass": "./lib/help"    // ...  }  // ...}
From here there are two paths, implement the HelpBase abstract class yourself or overwrite the parts of the default Help class you want to customize (ex: how command usage is displayed). We recommend the latter approach but cover both in the new Help Classes docs.
Separating TOPICS & COMMANDS in the new default Help class​
Previously, topics and child commands were listed in help output under a single list heading called "COMMANDS". But we found this can be slightly confusing. Some topics are commands also (a.k.a. topic-commands) while others are simply organizational namespacing (and when ran just show their help).
The new default Help class splits the list of children into distinct lists of "TOPICS" and "COMMANDS", with the possibility of an item appearing in both if it a topic-command. This makes it clearer what is expected to be ran - "COMMANDS" - and what is providing structure - "TOPICS" - when looking at the help output.
VERSION  plugin-help-example/0.0.0 darwin-x64 node-v12.12.0USAGE  $ plugin-help-example [COMMAND]TOPICS  topic  this is a topic and has child topics or commandsCOMMANDS  hello  describe the command here  help   display help for plugin-help-example
We look forward to seeing what custom help features you implement in your oclif CLIs with this new feature!oclif TSLint to ESLint MigrationDecember 5, 2019 · 3 min readBack in February of this year, plans were announced to deprecate TSLint in favor of ESLint. TSLint's goal has become to work toward a “unified developer experience” by supporting ESLint development going forward.
What has changed in oclif​
To keep inline with the community, oclif has transitioned to ESLint for all our core libraries as well as all our official plugins.
Starting in v1.15.x, oclif will now optionally generate projects with ESLint for both TypeScript and JavaScript CLI’s.
ESLint does require Node to be on stable LTS version, at the time of writing, Node 8.10.x, Node 10.13.x & Node 12.x.x.
How does this affect you​
Existing CLI’s are unchanged, but any newly generated CLI's will only give the option of using ESLint. If you are running tslint in your CLI, we recommend you switch to ESLint as well.
In migrating our projects we took the following steps (for an example of these changes see this pull request).


Install eslint
$ yarn add eslint eslint-config-oclif eslint-config-oclif-typescript --dev


Add eslint related files


$ echo '{  "extends": [    "oclif",    "oclif-typescript"  ],  "rules": {  }}' > .eslintrc


Remove tslint and related packages
$ yarn remove @oclif/tslint tslint


Remove tslint related configuration files
$ rm tslint.json


Change lint script in our package.json from something like:
"lint": "tsc -p test --noEmit && tslint -p test -t stylish"
to
"lint": "eslint . --ext .ts --config .eslintrc"


To preserve the test compile (tsc -p test --noEmit) we also made the following updates to our scripts:
"pretest": "tsc -p test --noEmit"
In some cases we had our posttest duplicating the same steps as our lint script so it’s cleaner to have it reference the lint job directly with:
"posttest": "yarn lint"

Run yarn lint --fix. This attempts to auto-fix any linting violations automatically. In the case an auto-fix isn’t available it should be fixed manually or ignored (see the eslint configuration doc for more information)
Do a search in the codebase for tslint and remove any unnecessary tslint disabling comments, like:

/* tslint:disable:object-literal-sort-keys */
If you are on a version of Node that is not supported by ESLint, you will also need to update your Node engine. ESLint supports Node 8, 10, and 12 so you should upgrade to the most recent Node version compatible with your CLI and also supported by ESLint (see ESLint's Installation and Usage instructions).
When will this take effect​
These changes have taken effect in oclif v1.15.1. When you generate a new CLI or plugin it will now contain configuration for ESLint instead of TSLint.oclif's Current Node SupportOctober 31, 2019 · 3 min readTo maintain a healthy project trajectory, oclif follows and supports Node Active LTS release, currently Node 10 & Node 12. This means ensuring that oclif continues to play nice with coming Active LTS Node versions and other packages in the ecosystem. Moving forward also means leaving older versions behind. Starting in 2020, Node will stop maintaining Node 8 and it is our intent at that time to also follow suit. Let’s take a look at a few ways we will be supporting these changes.
CI Environments​
CLIs created with the oclif cli going forward will be generated with a CircleCI configuration with Node 10 & 12 and an Appveyor configuration using Node 10. We have also added Node latest to CircleCi to be an early warning detection against coming Node changes (Node latest is managed by CircleCI).
We have already updated every oclif repo's CI configs to reflect this.
If your existing CLI uses either Appveyor or CircleCI you can update your config files also, like so:
.circleci/config.yml​
Your CircleCI config should contain a node-latest job, aliased as test. From this, there should be two extensions of this job for the Active LTS Node versions, Node 10 and Node 12.
  node-10:    <<: *node-latest    docker:      - image: node:10  node-12:    <<: *node-latest    docker:      - image: node:12
Notice that these declarations only change the Docker Node images used to run that job.
Additionally, the jobs listed within workflows must also be updated to reflect our changes in configuration:
    jobs:      - node-latest      - node-10      - node-12
appveyor.yml​
For appveyor we are currently only testing the oldest Active LTS Node version, Node 10. Update the nodejs_version proppert in your appveyor.yml file to reflect this.
environment:  nodejs_version: "10"
Deprecating Node 8 & Updating packge.json engines​
In Jan 2020, Node will end its Node 8 maintenance. We will follow suit by setting the package.json engine property in oclif packages to >=10 and bumping the package's major versions.
Depending on how you ship your CLI you may wish to also bump the engines version in your CLI's package.json. You can read more about the implications of the engines property configuration in the npm documentation.
Also consider distributing your CLI with its own Node version.
Packaged Node Version​
When using dev-cli to pack your CLI it will use the Node version as specified in your package.json under the oclif.update.node.version property. This value should reflect an Active LTS Node version (dev-cli does not currently enforce versions).
Supporting the future​
As a community we may discover bumps along the way as we upgrade. If you notice something related to oclif please feel free to open an issue or submit a pull request under the relevant oclif package within the org.
We look forward to using the latest from Node and the community and keeping oclif healthy along the way.oclifconf 2019: A RecapSeptember 16, 2019 · 4 min readIn May, Heroku and Salesforce Open Source organized oclifconf, a conference for developers & product managers building CLI tools on top of the open source oclif framework. The speakers came from various tech companies, such as Adobe, Netlify, and Apollo, who have already built amazing CLI experiences. The topics covered everything from the incredible capabilities oclif has unlocked, to the community-built plugins extending its functionality, and even what the behavior of an adaptive CLI tool might look like.
Below is a listing of all of the talks from the event, along with a short summary. Enjoy!
The future of oclif by Jeff Dickey​

In its relatively short lifetime, oclif has already inspired many developers and companies to adopt its framework as a means for implementing their own command-line tooling. In this talk, Jeff Dickey, an oclif founding team member, recaps the project's history and inspiration. He also looks towards the future and outlines some features and improvements that the tool could adapt. This isn't so much a definitive roadmap of where oclif is headed, but rather, a call to inspiration for developers eager to contribute! And if you are interested in contributing, check out the open issues in the oclif GitHub repo and come say "Hello!" on Spectrum Chat.
Open Source Citizenship by Josh Simmons​

When it comes to open source, it's more than just individuals now. More and more frequently, large corporations are contributing to projects by donating to contributors, sponsoring events, or upstreaming contributions. But keeping open source projects and communities healthy requires more than just money and brainpower. Josh Simmons surveyed multiple open source communities and relays his findings as to what help maintainers and contributors actually need in this talk.
Building an enterprise-grade CLI with oclif by Thomas Dvornik​

Security and performance are all about trust. While oclif is an extremely extensible framework for building CLI tooling, there are additional requirements to fulfill for enterprise businesses to adopt it that might not be necessary for individual developers. Thomas Dvornik outlines what he and his colleagues at Salesforce have implemented as plugins to oclif to satisfy these needs, including encrypted OAuth, plugin signing, lazy loading dependencies, synchronizing weekly releases and deprecations across dozens of repositories, and establishing cross-team coding and documentation standards.
How Adobe I/O built an extensible CLI with oclif by Jesse MacFadyen​

Perhaps oclif's most appealing feature is its support for plugins. In Cordova's case, they've created a sophisticated telemetry system that helps Adobe developers see which commands users are using--and reports on which ones are erroring out. By embedding a feedback system into the tool, users are even able to quickly send their suggestions to a form, without ever leaving the terminal. Jesse MacFadyen demonstrates how oclif's plugin system can work beyond simply executing commands.
Integrating oclif with GraphQL and Apollo by Evans Hauser​

For Evans Hauser and the team at Apollo, oclif is best thought of as "React for the CLI." As a client paired with a strongly-typed API contract to a server, it can deliver structured and consistent commands to retrieve external data. What better mechanism to use for this transfer than GraphQL, a framework which empowers the client to ask precisely for the data it needs, and nothing more?
Adaptive Intent-based CLI State Machines by Shawn Wang​

In designing oclif, Jeff Dickey wrote out 12 CLI factors to keep in mind. In this talk, Shawn Wang outlines a 13th: state. State is hard, because it depends on context, and context depends on understanding what a user intends to do, not what they are asking. Shawn is working towards enabling oclif to better understand the commands a user has entered, so that it can predict and interpret future commands that might be entered next. This would enable CLI tools to not just interpret a users' commands, but to also interpret their intent.\n\nIntroducing `oclif init` commandApril 10, 2024 · 2 min readThanks to the contribution of @joshcanhelp we released a new command for the oclif CLI called oclif init in version 4.8.0
The oclif init command allows you to initialize oclif in an existing project directory by adding the bare minimum requirements: a few pieces of configuration, bin scripts, and a couple of dependencies (@oclif/core and ts-node). This is slightly different from oclif generate, which will create an entirely new oclif project based on our templates.
oclif init will add the following:

bin scripts: bin/run.js, bin/run.cmd, bin/dev.js, and bin/dev.cmd
oclif section to package.json with bin, dirname, commands, and topicSeparator set (See Configuring Your CLI for more)
@oclif/core to dependencies in your package.json (if it's not already there)
ts-node to devDependencies in your package.json (if it's not already there)

Once you've initialized oclif, you can use the bin scripts to execute your CLI. You can also use the other oclif commands like oclif generate command and oclif generate hook to start adding new functionality.

❯ oclif init --helpInitialize a new oclif CLIUSAGE  $ oclif init [--bin <value>] [--module-type ESM|CommonJS] [--package-manager npm|yarn|pnpm] [--topic-separator    colons|spaces] [-d <value>] [-y]FLAGS  -d, --output-dir=<value>        Directory to initialize the CLI in.  -y, --yes                       Use defaults for all prompts. Individual flags will override defaults.      --bin=<value>               Supply answer for prompt: Command bin name the CLI will export      --module-type=<option>      Supply answer for prompt: Select a module type                                  <options: ESM|CommonJS>      --package-manager=<option>  Supply answer for prompt: Select a package manager                                  <options: npm|yarn|pnpm>      --topic-separator=<option>  Supply answer for prompt: Select a topic separator                                  <options: colons|spaces>DESCRIPTION  Initialize a new oclif CLI  This will add the necessary oclif bin files, add oclif config to package.json, and install @oclif/core and ts-node.EXAMPLES  Initialize a new CLI in the current directory    $ oclif init  Initialize a new CLI in a different directory    $ oclif init --output-dir "/path/to/existing/project"  Supply answers for specific prompts    $ oclif init --topic-separator colons --bin mycli
Hope you enjoy the new command! If you come across any issues or have any new ideas for this command, head over to the oclif/oclif repo and open a new issue.
All our best,
The oclif teamoclif Spring 2024 UpdateMarch 29, 2024 · 4 min readHello oclif developers! It's been a while since we last uploaded a blog - and a lot has happened.
We've been focusing on these high-level areas over the past couple of years:

Improving @oclif/core
ESM Support
Improving and revitalizing oclif.io
Re-engaging the oclif community

Improving @oclif/core​
Since we announced @oclif/core over three years ago, we've released two new major versions, each packed with lots of features that we're really excited about.
Here are some of these changes:

Full support for ESM and interoperability with CommonJS (more on this topic below).
Configurable command discovery strategies that give you more control over how commands are loaded at runtime. Check out the docs.
A new preparse hook that allows you to manipulate the provided arguments before they're parsed. Salesforce used this hook to implement a neat --flags-dir feature that translates local files into flags.
A new Performance class that you can use to track performance inside of @oclif/core and your own CLI or plugin. Check out the docs.
A new flag type, Flags.option, that lets you define a flag with a preset list of options. Typescript then uses the options to infer the flag's type.
Flags now have a relationship property that allows you to define more complex relationships between flags. Check out the flags docs for more information.
Flags now have a defaultHelp property that allows you to set the human readable default value in the command help. This property is useful when your flag's parse method returns a complex type, such as an object or a class. Check out the flags docs for more.
Commands now have a hiddenAliases property that allows you to define aliases that you want to hide from the user. The property is super helpful when you're trying to wean users off a deprecated command.
You can now use bun or tsx as dev runtimes (as opposed to node or ts-node).
A command's usage, args, and flags are now shown whenever a user forgets to provide a required arg or flag, or when they provided a non-existent flag.

If you need help migrating to the latest version, head over to core's README which has links to the migration guides. Feel free to open a new discussion if you need more hands-on help from us or the community.
ESM Support​
Version 3 of @oclif/core introduced full support for developing ESM plugins and CLIs. It also offered full support for interoperability between CommonJS and ESM plugins.
Put more simply, you can now migrate your CLI to ESM while keeping individual plugins in CommonJS (or vice versa). The upgrade path is now much simpler for you. You also don't need to worry about any community plugins that have migrated to ESM before you did (such as all the @oclif plugins) or are staunchly sticking with CommonJS for the foreseeable future.
Read more about this topic here.
Improving and Revitalizing oclif.io​
Another area of focus for us has been improving our documentation site, oclif.io.
While improving the quality and accuracy of the documentation was our priority, we also took the time to upgrade to the latest version of docusaurus. This new version gave our site a much-needed facelift, as well as cool new features such as dark mode and announcements.
If you have any feedback or are running into issues, we want to hear about it. Just create an issue in the oclif.io repo.
Re-engaging the oclif Community​
Lastly, our biggest priority at the moment is to re-engage the oclif community. We understand how frustrating it has been over the years to see your issues and pull requests go unacknowledged. We apologize for not prioritizing the community, and are earnestly trying to make sure that every issue and pull request gets the attention it deserves going forward.
We also opened up GitHub discussions for @oclif/core and the oclif CLI, where you can now post your questions or ideas. We hope you take advantage of them, we love hearing from you!
One last thing: we intend to publicly post our roadmap so you have more visibility into what we're working on. Stay tuned!
All our best,
The oclif teamAnnouncing oclif v2!January 12, 2022 · 5 min readHello and happy new year! It's our great pleasure to announce that we have released oclif v2, which uses the new @oclif/core library! 🎉
oclif v2 includes many changes that improve the experience of both creating and using an oclif CLI.
Going forward, we don't plan to make any updates to oclif v1 and its corresponding libraries, except for critical security fixes. See the compatibility matrix for a list of these libraries. In order to give developers time to migrate from v1 to v2, we're not completely dropping support yet. But at some point in the future we'll archive the v1 repositories and deprecate their versions on npm.
What’s changing?​
Repository Changes​
All repositories under the oclif org now use main as their primary branch and oclif-v1 as the legacy branch. The main  branch corresponds to oclif v2 and the oclif-v1 branch to oclif v1. If you find any repos that don’t have a main branch, you can safely assume that they're not used in oclif v2 and will be deprecated in the future.
Consolidating Tools & Libraries​
The oclif-dev CLI has now been incorporated into oclif. You now no longer need to install a separate package to manage your entire CLI’s lifecycle.
The following libraries have been consolidated under @oclif/core and will be deprecated at some point in the future. Read the migration guide to learn how to update your CLI or plugin to use the new core library.

@oclif/command
@oclif/config
@oclif/error
@oclif/help
@oclif/parser

No more single vs multi command CLIs​
There's only one "type" of oclif v2 CLI, but it can have as few or as many commands as a developer wants. As a result, there’s only one command to generate CLIs, oclif generate, as opposed to the old oclif single and oclif multi commands.
Node > 12​
To ensure oclif CLIs are as secure as possible, all v2 libraries and plugins support only Node 12 or higher as of now. Going forward, they'll support only Node Maintenance or higher, as defined by Node's release schedule here: https://nodejs.org/en/about/releases/.
What’s new?​
New example CLI​
oclif-hello-world is our new example repo. This is also the repo that's used as a template when running oclif generate to create a new CLI. This repo will always be able to be referenced as an example of what an oclif v2 CLI should look like.
Spaced commands​
oclif CLIs can now use spaces, instead of colons, to separate topics and subcommands. To enable this feature, simply add “topicSeparator": " " to the oclif config in your package.json. See an example in our example repo.
// Old commands that use :$ mycli do:something
// New spaced commands$ mycli do something

Note: Spaced commands are backwards compatible. So if you enable spaced commands for your CLI, users will still be able to use : as a separator. This ensures that any existing scripts don't break.

New Help Output​
We’ve revamped the way command help is outputted to the terminal, making it both easier to implement and easier to read. See the difference between the old help output on the left and the new help output on the right in the screenshots below.
oclif v1oclif v2
Notice that there are new sections for flags and global flags, examples are displayed with better spacing, and there is a section at the bottom called Configuration Variables. This Configuration Variables section is not part of the new help by default. But we've added support for custom help sections, which is what the sf CLI uses to create the new section.
Async Command Parsing​
We’ve also improved the performance of new CLIs by rewriting how commands are parsed on initialization. The new parser is asynchronous, which makes CLIs with a lot of commands or installed  plugins much faster.
What’s coming next?​
Part of our charter for the release of oclif v2 includes improving our engagement with the oclif community. We know that over the past couple of years we’ve reduced our involvement, and a lot of issues and PRs have languished in limbo. Hopefully you’ve already seen increased activity and responses from oclif maintainers recently, but if you haven’t, please don’t hesitate to ping us by tagging @admins in oclif repos.
We also want to start interviewing members of the oclif community to acquire feedback and prioritize the features and fixes you deem most important!
Best,
The oclif team

Reference material​
Migration Guide​
This guide explains how to upgrade a CLI or plugin from the old oclif v1 libraries to the new @oclif/core library that oclif v2 uses.
https://github.com/oclif/core/blob/main/MIGRATION.md
Compatibility Matrix​
The following matrix shows how the v1 libraries and plugins relate to the new v2 ones. Use this matrix as a guide to know what to drop and which versions to switch when upgrading your plugins and CLIs to v2.
oclif "v1"oclif "v2"Utility CLIsoclif@<2@oclif/dev-cli@<2oclif@>=2Main packages@oclif/command@oclif/config@oclif/errors@oclif/parser@oclif/plugin-help@oclif/core@>=1Node LTSNode v8-14Node v12+ (at time of writing)TypeScripttypescript@<4typescript@>=4Main plugins@oclif/plugin-autocomplete@<1@oclif/plugin-commands@<2@oclif/plugin-help@<4@oclif/plugin-not-found@<2@oclif/plugin-plugins@<2@oclif/plugin-update@<2plugin-warn-if-update-available@<2plugin-which@<2@oclif/plugin-autocomplete@>=1@oclif/plugin-commands@>=2@oclif/plugin-help@>=4@oclif/plugin-not-found@>=2@oclif/plugin-plugins@>=2@oclif/plugin-update@>=2@oclif/plugin-warn-if-update-available@>=2@oclif/plugin-which@>=2Introducing @oclif/coreMarch 1, 2021 · 3 min readGreetings!
We hope this blog post finds you well.
Introducing...​
We are excited to announce the next iteration of the oclif project today: @oclif/core.
We have learned a lot in the last three years of developing oclif, developing on oclif and supporting millions of command runs a day via Heroku and Salesforce CLIs.
@oclif/core ("Core") simplifies the oclif development experience and introduces highly requested new features.
Core combines the essential oclif packages into one "core" package, aptly named @oclif/core.
Core also introduces:

A default command option
Colon or space command syntax
Async command parsing
Command piping to arguments

With the introduction of default command functionality, Core simplifies the oclif project and removes the notion of single or multi command CLIs. Core CLIs can have 1 or many commands.
Along with Core, we moved the oclif-dev CLI into the oclif CLI creating a single "utility" CLI. This CLI also introduces a new AWS S3 compatible publishing scheme.
What to expect in the near future​
Core is in pre-release beta and being actively developed for new internal Salesforce CLIs.
Much documentation needs to be written in the coming months including migration paths. Migration onto Core should be as painless as possible with many exports remaining entirely unchanged. Look for forthcoming blog posts and documentation on oclif.io.
Early this summer, tentively June 1, we will release Core v1. Core's release will coincide with major bumps to many other oclif plugin packages. See the compatibility matrix below.
At Core's v1 release, the current "main" oclif packages (namely: command, config, errors & parser) will go into maintenance mode until Jan 2022. They will receive only bug and security fixes and they remain compatible with current versions of the oclif and oclif-dev CLIs. Afterwhich, they will be archived.
Companioning Core, the next major release of the oclif CLI (literally oclif@2) will generate Core CLIs.
Going forward​
We are excited to release Core! We invite you to poke around the Core repo. It may appear to be a big change but Core keeps what you already enjoy about oclif while reducing development complexity, project dependencies, package coupling and bundle size and introduces many requested features previously too prickly to weave into the current oclif architecture.
Best,
The oclif team
Reference: Compatibility matrix​
oclif "v1"oclif "Core"Utility CLIsoclif@<2@oclif/dev-cli@<2oclif@>=2Main packages@oclif/core@<2@oclif/config@<2@oclif/errors@<2@oclif/parser@<4@oclif/plugin-help@<4@oclif/core@>=1Node LTSNode v8-14Node v12+TypeScripttypescript@<4typescript@>=4Main plugins@oclif/plugin-autocomplete@<1@oclif/plugin-commands@<2@oclif/plugin-help@<4@oclif/plugin-not-found@<2@oclif/plugin-plugins@<2@oclif/plugin-update@<2plugin-warn-if-update-available@<2plugin-which@<2@oclif/plugin-autocomplete@>=2@oclif/plugin-commands@>=2@oclif/plugin-help@>=4@oclif/plugin-not-found@>=2@oclif/plugin-plugins@>=2@oclif/plugin-update@>=2@oclif/plugin-warn-if-update-available@>=2@oclif/plugin-which@>=2oclif Summer 2020 UpdateAugust 26, 2020 · 2 min readHello oclif developers! We hope you are all doing well.
Earlier this year, we started our planning for oclifconf v2 and, like all conference, had to change course. We opted not to hold a virtual conference, however, we wanted to take some time to highlight a few oclif features shipped this year.
Feature: Help templating​
One of the most requested features, help templating enables oclif developers to customize the help output for their CLI.
Read the announcement.
Feature: Custom error delegation​
This feature both improved how oclif throws and handles errors and allows oclif developers to overwrite or interject in oclif’s error handling.
Read the announcement.
Feature: postrun hooks​
We have added a new lifecycle event postrun. Your CLI can now run a hook after a command has ran.
See our hook documentation.
Feature: Root index command​
Previously, oclif would display CLI help if only the binary name with no command ID was invoked, oclif now supports a "root index" command. If present, a command defined at src/commands/index.ts will be run if no command ID is found.
1 million weekly downloads​
While exact oclif usage metrics are hard to pin down, we use npm download statistics of oclif packages as a rough approximation. Earlier this year, oclif's command package hit 1 million weekly downloads for the first time!
This year has been presented its challenges on everyone. We want to thank you, oclif developers, whom have taken the time to use and improve the oclif project. We look forward to seeing you all - in person - in the future!
All our best,
The oclif teamPretty Printable ErrorsJuly 1, 2020 · One min readOften CLIs are used as handy tools and when things go wrong it’s useful to have additional context. In oclif we have added a couple of additional properties that can show extra context to the users when an error is displayed. The code, ref and suggestions will now be displayed if they are included. This will work with an existing oclif CLI by adding the latest @oclif/errors and @oclif/core to the CLI's package.json dependencies.
For example, using this.error with the additional properties:
class TestError extends Command {  async run() {    this.error("An error has occurred!", {      code: "OCLIF_ERR",      ref: "https://oclif.io/docs/commands#thiserrormessage-string--error-options-code-string-exit-number",      suggestions: ["Use these extra properties to provide additional context"],    })  }}
would result with the following output:
›   Error: An error has occurred!›   Code: OCLIF_ERR›   Try this: Use these extra properties to provide additional context›   Reference: https://oclif.io/docs/commands#thiserrormessage-string--error-options-code-string-exit-number
If these properties are not provided then nothing changes and the CLI will continue to display the single error message output as it did before. Additionally, as part of this exercise we’ve added documentation around Error Handling in oclif which should come in handy if the need arises to extend oclif’s default handling of errors.Customizing Help in oclifMay 5, 2020 · 2 min readOut of the box oclif provides a great help experience for CLIs.
But what if, as an oclif developer, you want to customize some or all of the output?
You can now customize your CLI's help output by implementing the HelpBase abstract class.
Getting started with custom help​
If you have not done so yet, update @oclif/core.
$ yarn add --latest @oclif/core
To get started, first define the filepath to your help class in oclif's config in package.json. This is a relative path to the help class, without a file extension.
For this example, the help class will be created in a file at "[project root]/src/help.ts".
{  // ...  "oclif": {    "helpClass": "./lib/help"    // ...  }  // ...}
From here there are two paths, implement the HelpBase abstract class yourself or overwrite the parts of the default Help class you want to customize (ex: how command usage is displayed). We recommend the latter approach but cover both in the new Help Classes docs.
Separating TOPICS & COMMANDS in the new default Help class​
Previously, topics and child commands were listed in help output under a single list heading called "COMMANDS". But we found this can be slightly confusing. Some topics are commands also (a.k.a. topic-commands) while others are simply organizational namespacing (and when ran just show their help).
The new default Help class splits the list of children into distinct lists of "TOPICS" and "COMMANDS", with the possibility of an item appearing in both if it a topic-command. This makes it clearer what is expected to be ran - "COMMANDS" - and what is providing structure - "TOPICS" - when looking at the help output.
VERSION  plugin-help-example/0.0.0 darwin-x64 node-v12.12.0USAGE  $ plugin-help-example [COMMAND]TOPICS  topic  this is a topic and has child topics or commandsCOMMANDS  hello  describe the command here  help   display help for plugin-help-example
We look forward to seeing what custom help features you implement in your oclif CLIs with this new feature!oclif TSLint to ESLint MigrationDecember 5, 2019 · 3 min readBack in February of this year, plans were announced to deprecate TSLint in favor of ESLint. TSLint's goal has become to work toward a “unified developer experience” by supporting ESLint development going forward.
What has changed in oclif​
To keep inline with the community, oclif has transitioned to ESLint for all our core libraries as well as all our official plugins.
Starting in v1.15.x, oclif will now optionally generate projects with ESLint for both TypeScript and JavaScript CLI’s.
ESLint does require Node to be on stable LTS version, at the time of writing, Node 8.10.x, Node 10.13.x & Node 12.x.x.
How does this affect you​
Existing CLI’s are unchanged, but any newly generated CLI's will only give the option of using ESLint. If you are running tslint in your CLI, we recommend you switch to ESLint as well.
In migrating our projects we took the following steps (for an example of these changes see this pull request).


Install eslint
$ yarn add eslint eslint-config-oclif eslint-config-oclif-typescript --dev


Add eslint related files


$ echo '{  "extends": [    "oclif",    "oclif-typescript"  ],  "rules": {  }}' > .eslintrc


Remove tslint and related packages
$ yarn remove @oclif/tslint tslint


Remove tslint related configuration files
$ rm tslint.json


Change lint script in our package.json from something like:
"lint": "tsc -p test --noEmit && tslint -p test -t stylish"
to
"lint": "eslint . --ext .ts --config .eslintrc"


To preserve the test compile (tsc -p test --noEmit) we also made the following updates to our scripts:
"pretest": "tsc -p test --noEmit"
In some cases we had our posttest duplicating the same steps as our lint script so it’s cleaner to have it reference the lint job directly with:
"posttest": "yarn lint"

Run yarn lint --fix. This attempts to auto-fix any linting violations automatically. In the case an auto-fix isn’t available it should be fixed manually or ignored (see the eslint configuration doc for more information)
Do a search in the codebase for tslint and remove any unnecessary tslint disabling comments, like:

/* tslint:disable:object-literal-sort-keys */
If you are on a version of Node that is not supported by ESLint, you will also need to update your Node engine. ESLint supports Node 8, 10, and 12 so you should upgrade to the most recent Node version compatible with your CLI and also supported by ESLint (see ESLint's Installation and Usage instructions).
When will this take effect​
These changes have taken effect in oclif v1.15.1. When you generate a new CLI or plugin it will now contain configuration for ESLint instead of TSLint.oclif's Current Node SupportOctober 31, 2019 · 3 min readTo maintain a healthy project trajectory, oclif follows and supports Node Active LTS release, currently Node 10 & Node 12. This means ensuring that oclif continues to play nice with coming Active LTS Node versions and other packages in the ecosystem. Moving forward also means leaving older versions behind. Starting in 2020, Node will stop maintaining Node 8 and it is our intent at that time to also follow suit. Let’s take a look at a few ways we will be supporting these changes.
CI Environments​
CLIs created with the oclif cli going forward will be generated with a CircleCI configuration with Node 10 & 12 and an Appveyor configuration using Node 10. We have also added Node latest to CircleCi to be an early warning detection against coming Node changes (Node latest is managed by CircleCI).
We have already updated every oclif repo's CI configs to reflect this.
If your existing CLI uses either Appveyor or CircleCI you can update your config files also, like so:
.circleci/config.yml​
Your CircleCI config should contain a node-latest job, aliased as test. From this, there should be two extensions of this job for the Active LTS Node versions, Node 10 and Node 12.
  node-10:    <<: *node-latest    docker:      - image: node:10  node-12:    <<: *node-latest    docker:      - image: node:12
Notice that these declarations only change the Docker Node images used to run that job.
Additionally, the jobs listed within workflows must also be updated to reflect our changes in configuration:
    jobs:      - node-latest      - node-10      - node-12
appveyor.yml​
For appveyor we are currently only testing the oldest Active LTS Node version, Node 10. Update the nodejs_version proppert in your appveyor.yml file to reflect this.
environment:  nodejs_version: "10"
Deprecating Node 8 & Updating packge.json engines​
In Jan 2020, Node will end its Node 8 maintenance. We will follow suit by setting the package.json engine property in oclif packages to >=10 and bumping the package's major versions.
Depending on how you ship your CLI you may wish to also bump the engines version in your CLI's package.json. You can read more about the implications of the engines property configuration in the npm documentation.
Also consider distributing your CLI with its own Node version.
Packaged Node Version​
When using dev-cli to pack your CLI it will use the Node version as specified in your package.json under the oclif.update.node.version property. This value should reflect an Active LTS Node version (dev-cli does not currently enforce versions).
Supporting the future​
As a community we may discover bumps along the way as we upgrade. If you notice something related to oclif please feel free to open an issue or submit a pull request under the relevant oclif package within the org.
We look forward to using the latest from Node and the community and keeping oclif healthy along the way.oclifconf 2019: A RecapSeptember 16, 2019 · 4 min readIn May, Heroku and Salesforce Open Source organized oclifconf, a conference for developers & product managers building CLI tools on top of the open source oclif framework. The speakers came from various tech companies, such as Adobe, Netlify, and Apollo, who have already built amazing CLI experiences. The topics covered everything from the incredible capabilities oclif has unlocked, to the community-built plugins extending its functionality, and even what the behavior of an adaptive CLI tool might look like.
Below is a listing of all of the talks from the event, along with a short summary. Enjoy!
The future of oclif by Jeff Dickey​

In its relatively short lifetime, oclif has already inspired many developers and companies to adopt its framework as a means for implementing their own command-line tooling. In this talk, Jeff Dickey, an oclif founding team member, recaps the project's history and inspiration. He also looks towards the future and outlines some features and improvements that the tool could adapt. This isn't so much a definitive roadmap of where oclif is headed, but rather, a call to inspiration for developers eager to contribute! And if you are interested in contributing, check out the open issues in the oclif GitHub repo and come say "Hello!" on Spectrum Chat.
Open Source Citizenship by Josh Simmons​

When it comes to open source, it's more than just individuals now. More and more frequently, large corporations are contributing to projects by donating to contributors, sponsoring events, or upstreaming contributions. But keeping open source projects and communities healthy requires more than just money and brainpower. Josh Simmons surveyed multiple open source communities and relays his findings as to what help maintainers and contributors actually need in this talk.
Building an enterprise-grade CLI with oclif by Thomas Dvornik​

Security and performance are all about trust. While oclif is an extremely extensible framework for building CLI tooling, there are additional requirements to fulfill for enterprise businesses to adopt it that might not be necessary for individual developers. Thomas Dvornik outlines what he and his colleagues at Salesforce have implemented as plugins to oclif to satisfy these needs, including encrypted OAuth, plugin signing, lazy loading dependencies, synchronizing weekly releases and deprecations across dozens of repositories, and establishing cross-team coding and documentation standards.
How Adobe I/O built an extensible CLI with oclif by Jesse MacFadyen​

Perhaps oclif's most appealing feature is its support for plugins. In Cordova's case, they've created a sophisticated telemetry system that helps Adobe developers see which commands users are using--and reports on which ones are erroring out. By embedding a feedback system into the tool, users are even able to quickly send their suggestions to a form, without ever leaving the terminal. Jesse MacFadyen demonstrates how oclif's plugin system can work beyond simply executing commands.
Integrating oclif with GraphQL and Apollo by Evans Hauser​

For Evans Hauser and the team at Apollo, oclif is best thought of as "React for the CLI." As a client paired with a strongly-typed API contract to a server, it can deliver structured and consistent commands to retrieve external data. What better mechanism to use for this transfer than GraphQL, a framework which empowers the client to ask precisely for the data it needs, and nothing more?
Adaptive Intent-based CLI State Machines by Shawn Wang​

In designing oclif, Jeff Dickey wrote out 12 CLI factors to keep in mind. In this talk, Shawn Wang outlines a 13th: state. State is hard, because it depends on context, and context depends on understanding what a user intends to do, not what they are asking. Shawn is working towards enabling oclif to better understand the commands a user has entered, so that it can predict and interpret future commands that might be entered next. This would enable CLI tools to not just interpret a users' commands, but to also interpret their intent.Older Entries\n\n\n\nIntroducing `oclif init` commandApril 10, 2024 · 2 min readThanks to the contribution of @joshcanhelp we released a new command for the oclif CLI called oclif init in version 4.8.0
The oclif init command allows you to initialize oclif in an existing project directory by adding the bare minimum requirements: a few pieces of configuration, bin scripts, and a couple of dependencies (@oclif/core and ts-node). This is slightly different from oclif generate, which will create an entirely new oclif project based on our templates.
oclif init will add the following:

bin scripts: bin/run.js, bin/run.cmd, bin/dev.js, and bin/dev.cmd
oclif section to package.json with bin, dirname, commands, and topicSeparator set (See Configuring Your CLI for more)
@oclif/core to dependencies in your package.json (if it's not already there)
ts-node to devDependencies in your package.json (if it's not already there)

Once you've initialized oclif, you can use the bin scripts to execute your CLI. You can also use the other oclif commands like oclif generate command and oclif generate hook to start adding new functionality.

❯ oclif init --helpInitialize a new oclif CLIUSAGE  $ oclif init [--bin <value>] [--module-type ESM|CommonJS] [--package-manager npm|yarn|pnpm] [--topic-separator    colons|spaces] [-d <value>] [-y]FLAGS  -d, --output-dir=<value>        Directory to initialize the CLI in.  -y, --yes                       Use defaults for all prompts. Individual flags will override defaults.      --bin=<value>               Supply answer for prompt: Command bin name the CLI will export      --module-type=<option>      Supply answer for prompt: Select a module type                                  <options: ESM|CommonJS>      --package-manager=<option>  Supply answer for prompt: Select a package manager                                  <options: npm|yarn|pnpm>      --topic-separator=<option>  Supply answer for prompt: Select a topic separator                                  <options: colons|spaces>DESCRIPTION  Initialize a new oclif CLI  This will add the necessary oclif bin files, add oclif config to package.json, and install @oclif/core and ts-node.EXAMPLES  Initialize a new CLI in the current directory    $ oclif init  Initialize a new CLI in a different directory    $ oclif init --output-dir "/path/to/existing/project"  Supply answers for specific prompts    $ oclif init --topic-separator colons --bin mycli
Hope you enjoy the new command! If you come across any issues or have any new ideas for this command, head over to the oclif/oclif repo and open a new issue.
All our best,
The oclif teamoclif Spring 2024 UpdateMarch 29, 2024 · 4 min readHello oclif developers! It's been a while since we last uploaded a blog - and a lot has happened.
We've been focusing on these high-level areas over the past couple of years:

Improving @oclif/core
ESM Support
Improving and revitalizing oclif.io
Re-engaging the oclif community

Improving @oclif/core​
Since we announced @oclif/core over three years ago, we've released two new major versions, each packed with lots of features that we're really excited about.
Here are some of these changes:

Full support for ESM and interoperability with CommonJS (more on this topic below).
Configurable command discovery strategies that give you more control over how commands are loaded at runtime. Check out the docs.
A new preparse hook that allows you to manipulate the provided arguments before they're parsed. Salesforce used this hook to implement a neat --flags-dir feature that translates local files into flags.
A new Performance class that you can use to track performance inside of @oclif/core and your own CLI or plugin. Check out the docs.
A new flag type, Flags.option, that lets you define a flag with a preset list of options. Typescript then uses the options to infer the flag's type.
Flags now have a relationship property that allows you to define more complex relationships between flags. Check out the flags docs for more information.
Flags now have a defaultHelp property that allows you to set the human readable default value in the command help. This property is useful when your flag's parse method returns a complex type, such as an object or a class. Check out the flags docs for more.
Commands now have a hiddenAliases property that allows you to define aliases that you want to hide from the user. The property is super helpful when you're trying to wean users off a deprecated command.
You can now use bun or tsx as dev runtimes (as opposed to node or ts-node).
A command's usage, args, and flags are now shown whenever a user forgets to provide a required arg or flag, or when they provided a non-existent flag.

If you need help migrating to the latest version, head over to core's README which has links to the migration guides. Feel free to open a new discussion if you need more hands-on help from us or the community.
ESM Support​
Version 3 of @oclif/core introduced full support for developing ESM plugins and CLIs. It also offered full support for interoperability between CommonJS and ESM plugins.
Put more simply, you can now migrate your CLI to ESM while keeping individual plugins in CommonJS (or vice versa). The upgrade path is now much simpler for you. You also don't need to worry about any community plugins that have migrated to ESM before you did (such as all the @oclif plugins) or are staunchly sticking with CommonJS for the foreseeable future.
Read more about this topic here.
Improving and Revitalizing oclif.io​
Another area of focus for us has been improving our documentation site, oclif.io.
While improving the quality and accuracy of the documentation was our priority, we also took the time to upgrade to the latest version of docusaurus. This new version gave our site a much-needed facelift, as well as cool new features such as dark mode and announcements.
If you have any feedback or are running into issues, we want to hear about it. Just create an issue in the oclif.io repo.
Re-engaging the oclif Community​
Lastly, our biggest priority at the moment is to re-engage the oclif community. We understand how frustrating it has been over the years to see your issues and pull requests go unacknowledged. We apologize for not prioritizing the community, and are earnestly trying to make sure that every issue and pull request gets the attention it deserves going forward.
We also opened up GitHub discussions for @oclif/core and the oclif CLI, where you can now post your questions or ideas. We hope you take advantage of them, we love hearing from you!
One last thing: we intend to publicly post our roadmap so you have more visibility into what we're working on. Stay tuned!
All our best,
The oclif teamAnnouncing oclif v2!January 12, 2022 · 5 min readHello and happy new year! It's our great pleasure to announce that we have released oclif v2, which uses the new @oclif/core library! 🎉
oclif v2 includes many changes that improve the experience of both creating and using an oclif CLI.
Going forward, we don't plan to make any updates to oclif v1 and its corresponding libraries, except for critical security fixes. See the compatibility matrix for a list of these libraries. In order to give developers time to migrate from v1 to v2, we're not completely dropping support yet. But at some point in the future we'll archive the v1 repositories and deprecate their versions on npm.
What’s changing?​
Repository Changes​
All repositories under the oclif org now use main as their primary branch and oclif-v1 as the legacy branch. The main  branch corresponds to oclif v2 and the oclif-v1 branch to oclif v1. If you find any repos that don’t have a main branch, you can safely assume that they're not used in oclif v2 and will be deprecated in the future.
Consolidating Tools & Libraries​
The oclif-dev CLI has now been incorporated into oclif. You now no longer need to install a separate package to manage your entire CLI’s lifecycle.
The following libraries have been consolidated under @oclif/core and will be deprecated at some point in the future. Read the migration guide to learn how to update your CLI or plugin to use the new core library.

@oclif/command
@oclif/config
@oclif/error
@oclif/help
@oclif/parser

No more single vs multi command CLIs​
There's only one "type" of oclif v2 CLI, but it can have as few or as many commands as a developer wants. As a result, there’s only one command to generate CLIs, oclif generate, as opposed to the old oclif single and oclif multi commands.
Node > 12​
To ensure oclif CLIs are as secure as possible, all v2 libraries and plugins support only Node 12 or higher as of now. Going forward, they'll support only Node Maintenance or higher, as defined by Node's release schedule here: https://nodejs.org/en/about/releases/.
What’s new?​
New example CLI​
oclif-hello-world is our new example repo. This is also the repo that's used as a template when running oclif generate to create a new CLI. This repo will always be able to be referenced as an example of what an oclif v2 CLI should look like.
Spaced commands​
oclif CLIs can now use spaces, instead of colons, to separate topics and subcommands. To enable this feature, simply add “topicSeparator": " " to the oclif config in your package.json. See an example in our example repo.
// Old commands that use :$ mycli do:something
// New spaced commands$ mycli do something

Note: Spaced commands are backwards compatible. So if you enable spaced commands for your CLI, users will still be able to use : as a separator. This ensures that any existing scripts don't break.

New Help Output​
We’ve revamped the way command help is outputted to the terminal, making it both easier to implement and easier to read. See the difference between the old help output on the left and the new help output on the right in the screenshots below.
oclif v1oclif v2
Notice that there are new sections for flags and global flags, examples are displayed with better spacing, and there is a section at the bottom called Configuration Variables. This Configuration Variables section is not part of the new help by default. But we've added support for custom help sections, which is what the sf CLI uses to create the new section.
Async Command Parsing​
We’ve also improved the performance of new CLIs by rewriting how commands are parsed on initialization. The new parser is asynchronous, which makes CLIs with a lot of commands or installed  plugins much faster.
What’s coming next?​
Part of our charter for the release of oclif v2 includes improving our engagement with the oclif community. We know that over the past couple of years we’ve reduced our involvement, and a lot of issues and PRs have languished in limbo. Hopefully you’ve already seen increased activity and responses from oclif maintainers recently, but if you haven’t, please don’t hesitate to ping us by tagging @admins in oclif repos.
We also want to start interviewing members of the oclif community to acquire feedback and prioritize the features and fixes you deem most important!
Best,
The oclif team

Reference material​
Migration Guide​
This guide explains how to upgrade a CLI or plugin from the old oclif v1 libraries to the new @oclif/core library that oclif v2 uses.
https://github.com/oclif/core/blob/main/MIGRATION.md
Compatibility Matrix​
The following matrix shows how the v1 libraries and plugins relate to the new v2 ones. Use this matrix as a guide to know what to drop and which versions to switch when upgrading your plugins and CLIs to v2.
oclif "v1"oclif "v2"Utility CLIsoclif@<2@oclif/dev-cli@<2oclif@>=2Main packages@oclif/command@oclif/config@oclif/errors@oclif/parser@oclif/plugin-help@oclif/core@>=1Node LTSNode v8-14Node v12+ (at time of writing)TypeScripttypescript@<4typescript@>=4Main plugins@oclif/plugin-autocomplete@<1@oclif/plugin-commands@<2@oclif/plugin-help@<4@oclif/plugin-not-found@<2@oclif/plugin-plugins@<2@oclif/plugin-update@<2plugin-warn-if-update-available@<2plugin-which@<2@oclif/plugin-autocomplete@>=1@oclif/plugin-commands@>=2@oclif/plugin-help@>=4@oclif/plugin-not-found@>=2@oclif/plugin-plugins@>=2@oclif/plugin-update@>=2@oclif/plugin-warn-if-update-available@>=2@oclif/plugin-which@>=2Introducing @oclif/coreMarch 1, 2021 · 3 min readGreetings!
We hope this blog post finds you well.
Introducing...​
We are excited to announce the next iteration of the oclif project today: @oclif/core.
We have learned a lot in the last three years of developing oclif, developing on oclif and supporting millions of command runs a day via Heroku and Salesforce CLIs.
@oclif/core ("Core") simplifies the oclif development experience and introduces highly requested new features.
Core combines the essential oclif packages into one "core" package, aptly named @oclif/core.
Core also introduces:

A default command option
Colon or space command syntax
Async command parsing
Command piping to arguments

With the introduction of default command functionality, Core simplifies the oclif project and removes the notion of single or multi command CLIs. Core CLIs can have 1 or many commands.
Along with Core, we moved the oclif-dev CLI into the oclif CLI creating a single "utility" CLI. This CLI also introduces a new AWS S3 compatible publishing scheme.
What to expect in the near future​
Core is in pre-release beta and being actively developed for new internal Salesforce CLIs.
Much documentation needs to be written in the coming months including migration paths. Migration onto Core should be as painless as possible with many exports remaining entirely unchanged. Look for forthcoming blog posts and documentation on oclif.io.
Early this summer, tentively June 1, we will release Core v1. Core's release will coincide with major bumps to many other oclif plugin packages. See the compatibility matrix below.
At Core's v1 release, the current "main" oclif packages (namely: command, config, errors & parser) will go into maintenance mode until Jan 2022. They will receive only bug and security fixes and they remain compatible with current versions of the oclif and oclif-dev CLIs. Afterwhich, they will be archived.
Companioning Core, the next major release of the oclif CLI (literally oclif@2) will generate Core CLIs.
Going forward​
We are excited to release Core! We invite you to poke around the Core repo. It may appear to be a big change but Core keeps what you already enjoy about oclif while reducing development complexity, project dependencies, package coupling and bundle size and introduces many requested features previously too prickly to weave into the current oclif architecture.
Best,
The oclif team
Reference: Compatibility matrix​
oclif "v1"oclif "Core"Utility CLIsoclif@<2@oclif/dev-cli@<2oclif@>=2Main packages@oclif/core@<2@oclif/config@<2@oclif/errors@<2@oclif/parser@<4@oclif/plugin-help@<4@oclif/core@>=1Node LTSNode v8-14Node v12+TypeScripttypescript@<4typescript@>=4Main plugins@oclif/plugin-autocomplete@<1@oclif/plugin-commands@<2@oclif/plugin-help@<4@oclif/plugin-not-found@<2@oclif/plugin-plugins@<2@oclif/plugin-update@<2plugin-warn-if-update-available@<2plugin-which@<2@oclif/plugin-autocomplete@>=2@oclif/plugin-commands@>=2@oclif/plugin-help@>=4@oclif/plugin-not-found@>=2@oclif/plugin-plugins@>=2@oclif/plugin-update@>=2@oclif/plugin-warn-if-update-available@>=2@oclif/plugin-which@>=2oclif Summer 2020 UpdateAugust 26, 2020 · 2 min readHello oclif developers! We hope you are all doing well.
Earlier this year, we started our planning for oclifconf v2 and, like all conference, had to change course. We opted not to hold a virtual conference, however, we wanted to take some time to highlight a few oclif features shipped this year.
Feature: Help templating​
One of the most requested features, help templating enables oclif developers to customize the help output for their CLI.
Read the announcement.
Feature: Custom error delegation​
This feature both improved how oclif throws and handles errors and allows oclif developers to overwrite or interject in oclif’s error handling.
Read the announcement.
Feature: postrun hooks​
We have added a new lifecycle event postrun. Your CLI can now run a hook after a command has ran.
See our hook documentation.
Feature: Root index command​
Previously, oclif would display CLI help if only the binary name with no command ID was invoked, oclif now supports a "root index" command. If present, a command defined at src/commands/index.ts will be run if no command ID is found.
1 million weekly downloads​
While exact oclif usage metrics are hard to pin down, we use npm download statistics of oclif packages as a rough approximation. Earlier this year, oclif's command package hit 1 million weekly downloads for the first time!
This year has been presented its challenges on everyone. We want to thank you, oclif developers, whom have taken the time to use and improve the oclif project. We look forward to seeing you all - in person - in the future!
All our best,
The oclif teamPretty Printable ErrorsJuly 1, 2020 · One min readOften CLIs are used as handy tools and when things go wrong it’s useful to have additional context. In oclif we have added a couple of additional properties that can show extra context to the users when an error is displayed. The code, ref and suggestions will now be displayed if they are included. This will work with an existing oclif CLI by adding the latest @oclif/errors and @oclif/core to the CLI's package.json dependencies.
For example, using this.error with the additional properties:
class TestError extends Command {  async run() {    this.error("An error has occurred!", {      code: "OCLIF_ERR",      ref: "https://oclif.io/docs/commands#thiserrormessage-string--error-options-code-string-exit-number",      suggestions: ["Use these extra properties to provide additional context"],    })  }}
would result with the following output:
›   Error: An error has occurred!›   Code: OCLIF_ERR›   Try this: Use these extra properties to provide additional context›   Reference: https://oclif.io/docs/commands#thiserrormessage-string--error-options-code-string-exit-number
If these properties are not provided then nothing changes and the CLI will continue to display the single error message output as it did before. Additionally, as part of this exercise we’ve added documentation around Error Handling in oclif which should come in handy if the need arises to extend oclif’s default handling of errors.Customizing Help in oclifMay 5, 2020 · 2 min readOut of the box oclif provides a great help experience for CLIs.
But what if, as an oclif developer, you want to customize some or all of the output?
You can now customize your CLI's help output by implementing the HelpBase abstract class.
Getting started with custom help​
If you have not done so yet, update @oclif/core.
$ yarn add --latest @oclif/core
To get started, first define the filepath to your help class in oclif's config in package.json. This is a relative path to the help class, without a file extension.
For this example, the help class will be created in a file at "[project root]/src/help.ts".
{  // ...  "oclif": {    "helpClass": "./lib/help"    // ...  }  // ...}
From here there are two paths, implement the HelpBase abstract class yourself or overwrite the parts of the default Help class you want to customize (ex: how command usage is displayed). We recommend the latter approach but cover both in the new Help Classes docs.
Separating TOPICS & COMMANDS in the new default Help class​
Previously, topics and child commands were listed in help output under a single list heading called "COMMANDS". But we found this can be slightly confusing. Some topics are commands also (a.k.a. topic-commands) while others are simply organizational namespacing (and when ran just show their help).
The new default Help class splits the list of children into distinct lists of "TOPICS" and "COMMANDS", with the possibility of an item appearing in both if it a topic-command. This makes it clearer what is expected to be ran - "COMMANDS" - and what is providing structure - "TOPICS" - when looking at the help output.
VERSION  plugin-help-example/0.0.0 darwin-x64 node-v12.12.0USAGE  $ plugin-help-example [COMMAND]TOPICS  topic  this is a topic and has child topics or commandsCOMMANDS  hello  describe the command here  help   display help for plugin-help-example
We look forward to seeing what custom help features you implement in your oclif CLIs with this new feature!oclif TSLint to ESLint MigrationDecember 5, 2019 · 3 min readBack in February of this year, plans were announced to deprecate TSLint in favor of ESLint. TSLint's goal has become to work toward a “unified developer experience” by supporting ESLint development going forward.
What has changed in oclif​
To keep inline with the community, oclif has transitioned to ESLint for all our core libraries as well as all our official plugins.
Starting in v1.15.x, oclif will now optionally generate projects with ESLint for both TypeScript and JavaScript CLI’s.
ESLint does require Node to be on stable LTS version, at the time of writing, Node 8.10.x, Node 10.13.x & Node 12.x.x.
How does this affect you​
Existing CLI’s are unchanged, but any newly generated CLI's will only give the option of using ESLint. If you are running tslint in your CLI, we recommend you switch to ESLint as well.
In migrating our projects we took the following steps (for an example of these changes see this pull request).


Install eslint
$ yarn add eslint eslint-config-oclif eslint-config-oclif-typescript --dev


Add eslint related files


$ echo '{  "extends": [    "oclif",    "oclif-typescript"  ],  "rules": {  }}' > .eslintrc


Remove tslint and related packages
$ yarn remove @oclif/tslint tslint


Remove tslint related configuration files
$ rm tslint.json


Change lint script in our package.json from something like:
"lint": "tsc -p test --noEmit && tslint -p test -t stylish"
to
"lint": "eslint . --ext .ts --config .eslintrc"


To preserve the test compile (tsc -p test --noEmit) we also made the following updates to our scripts:
"pretest": "tsc -p test --noEmit"
In some cases we had our posttest duplicating the same steps as our lint script so it’s cleaner to have it reference the lint job directly with:
"posttest": "yarn lint"

Run yarn lint --fix. This attempts to auto-fix any linting violations automatically. In the case an auto-fix isn’t available it should be fixed manually or ignored (see the eslint configuration doc for more information)
Do a search in the codebase for tslint and remove any unnecessary tslint disabling comments, like:

/* tslint:disable:object-literal-sort-keys */
If you are on a version of Node that is not supported by ESLint, you will also need to update your Node engine. ESLint supports Node 8, 10, and 12 so you should upgrade to the most recent Node version compatible with your CLI and also supported by ESLint (see ESLint's Installation and Usage instructions).
When will this take effect​
These changes have taken effect in oclif v1.15.1. When you generate a new CLI or plugin it will now contain configuration for ESLint instead of TSLint.oclif's Current Node SupportOctober 31, 2019 · 3 min readTo maintain a healthy project trajectory, oclif follows and supports Node Active LTS release, currently Node 10 & Node 12. This means ensuring that oclif continues to play nice with coming Active LTS Node versions and other packages in the ecosystem. Moving forward also means leaving older versions behind. Starting in 2020, Node will stop maintaining Node 8 and it is our intent at that time to also follow suit. Let’s take a look at a few ways we will be supporting these changes.
CI Environments​
CLIs created with the oclif cli going forward will be generated with a CircleCI configuration with Node 10 & 12 and an Appveyor configuration using Node 10. We have also added Node latest to CircleCi to be an early warning detection against coming Node changes (Node latest is managed by CircleCI).
We have already updated every oclif repo's CI configs to reflect this.
If your existing CLI uses either Appveyor or CircleCI you can update your config files also, like so:
.circleci/config.yml​
Your CircleCI config should contain a node-latest job, aliased as test. From this, there should be two extensions of this job for the Active LTS Node versions, Node 10 and Node 12.
  node-10:    <<: *node-latest    docker:      - image: node:10  node-12:    <<: *node-latest    docker:      - image: node:12
Notice that these declarations only change the Docker Node images used to run that job.
Additionally, the jobs listed within workflows must also be updated to reflect our changes in configuration:
    jobs:      - node-latest      - node-10      - node-12
appveyor.yml​
For appveyor we are currently only testing the oldest Active LTS Node version, Node 10. Update the nodejs_version proppert in your appveyor.yml file to reflect this.
environment:  nodejs_version: "10"
Deprecating Node 8 & Updating packge.json engines​
In Jan 2020, Node will end its Node 8 maintenance. We will follow suit by setting the package.json engine property in oclif packages to >=10 and bumping the package's major versions.
Depending on how you ship your CLI you may wish to also bump the engines version in your CLI's package.json. You can read more about the implications of the engines property configuration in the npm documentation.
Also consider distributing your CLI with its own Node version.
Packaged Node Version​
When using dev-cli to pack your CLI it will use the Node version as specified in your package.json under the oclif.update.node.version property. This value should reflect an Active LTS Node version (dev-cli does not currently enforce versions).
Supporting the future​
As a community we may discover bumps along the way as we upgrade. If you notice something related to oclif please feel free to open an issue or submit a pull request under the relevant oclif package within the org.
We look forward to using the latest from Node and the community and keeping oclif healthy along the way.oclifconf 2019: A RecapSeptember 16, 2019 · 4 min readIn May, Heroku and Salesforce Open Source organized oclifconf, a conference for developers & product managers building CLI tools on top of the open source oclif framework. The speakers came from various tech companies, such as Adobe, Netlify, and Apollo, who have already built amazing CLI experiences. The topics covered everything from the incredible capabilities oclif has unlocked, to the community-built plugins extending its functionality, and even what the behavior of an adaptive CLI tool might look like.
Below is a listing of all of the talks from the event, along with a short summary. Enjoy!
The future of oclif by Jeff Dickey​

In its relatively short lifetime, oclif has already inspired many developers and companies to adopt its framework as a means for implementing their own command-line tooling. In this talk, Jeff Dickey, an oclif founding team member, recaps the project's history and inspiration. He also looks towards the future and outlines some features and improvements that the tool could adapt. This isn't so much a definitive roadmap of where oclif is headed, but rather, a call to inspiration for developers eager to contribute! And if you are interested in contributing, check out the open issues in the oclif GitHub repo and come say "Hello!" on Spectrum Chat.
Open Source Citizenship by Josh Simmons​

When it comes to open source, it's more than just individuals now. More and more frequently, large corporations are contributing to projects by donating to contributors, sponsoring events, or upstreaming contributions. But keeping open source projects and communities healthy requires more than just money and brainpower. Josh Simmons surveyed multiple open source communities and relays his findings as to what help maintainers and contributors actually need in this talk.
Building an enterprise-grade CLI with oclif by Thomas Dvornik​

Security and performance are all about trust. While oclif is an extremely extensible framework for building CLI tooling, there are additional requirements to fulfill for enterprise businesses to adopt it that might not be necessary for individual developers. Thomas Dvornik outlines what he and his colleagues at Salesforce have implemented as plugins to oclif to satisfy these needs, including encrypted OAuth, plugin signing, lazy loading dependencies, synchronizing weekly releases and deprecations across dozens of repositories, and establishing cross-team coding and documentation standards.
How Adobe I/O built an extensible CLI with oclif by Jesse MacFadyen​

Perhaps oclif's most appealing feature is its support for plugins. In Cordova's case, they've created a sophisticated telemetry system that helps Adobe developers see which commands users are using--and reports on which ones are erroring out. By embedding a feedback system into the tool, users are even able to quickly send their suggestions to a form, without ever leaving the terminal. Jesse MacFadyen demonstrates how oclif's plugin system can work beyond simply executing commands.
Integrating oclif with GraphQL and Apollo by Evans Hauser​

For Evans Hauser and the team at Apollo, oclif is best thought of as "React for the CLI." As a client paired with a strongly-typed API contract to a server, it can deliver structured and consistent commands to retrieve external data. What better mechanism to use for this transfer than GraphQL, a framework which empowers the client to ask precisely for the data it needs, and nothing more?
Adaptive Intent-based CLI State Machines by Shawn Wang​

In designing oclif, Jeff Dickey wrote out 12 CLI factors to keep in mind. In this talk, Shawn Wang outlines a 13th: state. State is hard, because it depends on context, and context depends on understanding what a user intends to do, not what they are asking. Shawn is working towards enabling oclif to better understand the commands a user has entered, so that it can predict and interpret future commands that might be entered next. This would enable CLI tools to not just interpret a users' commands, but to also interpret their intent.\n\nIntroducing `oclif init` commandApril 10, 2024 · 2 min readThanks to the contribution of @joshcanhelp we released a new command for the oclif CLI called oclif init in version 4.8.0
The oclif init command allows you to initialize oclif in an existing project directory by adding the bare minimum requirements: a few pieces of configuration, bin scripts, and a couple of dependencies (@oclif/core and ts-node). This is slightly different from oclif generate, which will create an entirely new oclif project based on our templates.
oclif init will add the following:

bin scripts: bin/run.js, bin/run.cmd, bin/dev.js, and bin/dev.cmd
oclif section to package.json with bin, dirname, commands, and topicSeparator set (See Configuring Your CLI for more)
@oclif/core to dependencies in your package.json (if it's not already there)
ts-node to devDependencies in your package.json (if it's not already there)

Once you've initialized oclif, you can use the bin scripts to execute your CLI. You can also use the other oclif commands like oclif generate command and oclif generate hook to start adding new functionality.

❯ oclif init --helpInitialize a new oclif CLIUSAGE  $ oclif init [--bin <value>] [--module-type ESM|CommonJS] [--package-manager npm|yarn|pnpm] [--topic-separator    colons|spaces] [-d <value>] [-y]FLAGS  -d, --output-dir=<value>        Directory to initialize the CLI in.  -y, --yes                       Use defaults for all prompts. Individual flags will override defaults.      --bin=<value>               Supply answer for prompt: Command bin name the CLI will export      --module-type=<option>      Supply answer for prompt: Select a module type                                  <options: ESM|CommonJS>      --package-manager=<option>  Supply answer for prompt: Select a package manager                                  <options: npm|yarn|pnpm>      --topic-separator=<option>  Supply answer for prompt: Select a topic separator                                  <options: colons|spaces>DESCRIPTION  Initialize a new oclif CLI  This will add the necessary oclif bin files, add oclif config to package.json, and install @oclif/core and ts-node.EXAMPLES  Initialize a new CLI in the current directory    $ oclif init  Initialize a new CLI in a different directory    $ oclif init --output-dir "/path/to/existing/project"  Supply answers for specific prompts    $ oclif init --topic-separator colons --bin mycli
Hope you enjoy the new command! If you come across any issues or have any new ideas for this command, head over to the oclif/oclif repo and open a new issue.
All our best,
The oclif teamoclif Spring 2024 UpdateMarch 29, 2024 · 4 min readHello oclif developers! It's been a while since we last uploaded a blog - and a lot has happened.
We've been focusing on these high-level areas over the past couple of years:

Improving @oclif/core
ESM Support
Improving and revitalizing oclif.io
Re-engaging the oclif community

Improving @oclif/core​
Since we announced @oclif/core over three years ago, we've released two new major versions, each packed with lots of features that we're really excited about.
Here are some of these changes:

Full support for ESM and interoperability with CommonJS (more on this topic below).
Configurable command discovery strategies that give you more control over how commands are loaded at runtime. Check out the docs.
A new preparse hook that allows you to manipulate the provided arguments before they're parsed. Salesforce used this hook to implement a neat --flags-dir feature that translates local files into flags.
A new Performance class that you can use to track performance inside of @oclif/core and your own CLI or plugin. Check out the docs.
A new flag type, Flags.option, that lets you define a flag with a preset list of options. Typescript then uses the options to infer the flag's type.
Flags now have a relationship property that allows you to define more complex relationships between flags. Check out the flags docs for more information.
Flags now have a defaultHelp property that allows you to set the human readable default value in the command help. This property is useful when your flag's parse method returns a complex type, such as an object or a class. Check out the flags docs for more.
Commands now have a hiddenAliases property that allows you to define aliases that you want to hide from the user. The property is super helpful when you're trying to wean users off a deprecated command.
You can now use bun or tsx as dev runtimes (as opposed to node or ts-node).
A command's usage, args, and flags are now shown whenever a user forgets to provide a required arg or flag, or when they provided a non-existent flag.

If you need help migrating to the latest version, head over to core's README which has links to the migration guides. Feel free to open a new discussion if you need more hands-on help from us or the community.
ESM Support​
Version 3 of @oclif/core introduced full support for developing ESM plugins and CLIs. It also offered full support for interoperability between CommonJS and ESM plugins.
Put more simply, you can now migrate your CLI to ESM while keeping individual plugins in CommonJS (or vice versa). The upgrade path is now much simpler for you. You also don't need to worry about any community plugins that have migrated to ESM before you did (such as all the @oclif plugins) or are staunchly sticking with CommonJS for the foreseeable future.
Read more about this topic here.
Improving and Revitalizing oclif.io​
Another area of focus for us has been improving our documentation site, oclif.io.
While improving the quality and accuracy of the documentation was our priority, we also took the time to upgrade to the latest version of docusaurus. This new version gave our site a much-needed facelift, as well as cool new features such as dark mode and announcements.
If you have any feedback or are running into issues, we want to hear about it. Just create an issue in the oclif.io repo.
Re-engaging the oclif Community​
Lastly, our biggest priority at the moment is to re-engage the oclif community. We understand how frustrating it has been over the years to see your issues and pull requests go unacknowledged. We apologize for not prioritizing the community, and are earnestly trying to make sure that every issue and pull request gets the attention it deserves going forward.
We also opened up GitHub discussions for @oclif/core and the oclif CLI, where you can now post your questions or ideas. We hope you take advantage of them, we love hearing from you!
One last thing: we intend to publicly post our roadmap so you have more visibility into what we're working on. Stay tuned!
All our best,
The oclif teamAnnouncing oclif v2!January 12, 2022 · 5 min readHello and happy new year! It's our great pleasure to announce that we have released oclif v2, which uses the new @oclif/core library! 🎉
oclif v2 includes many changes that improve the experience of both creating and using an oclif CLI.
Going forward, we don't plan to make any updates to oclif v1 and its corresponding libraries, except for critical security fixes. See the compatibility matrix for a list of these libraries. In order to give developers time to migrate from v1 to v2, we're not completely dropping support yet. But at some point in the future we'll archive the v1 repositories and deprecate their versions on npm.
What’s changing?​
Repository Changes​
All repositories under the oclif org now use main as their primary branch and oclif-v1 as the legacy branch. The main  branch corresponds to oclif v2 and the oclif-v1 branch to oclif v1. If you find any repos that don’t have a main branch, you can safely assume that they're not used in oclif v2 and will be deprecated in the future.
Consolidating Tools & Libraries​
The oclif-dev CLI has now been incorporated into oclif. You now no longer need to install a separate package to manage your entire CLI’s lifecycle.
The following libraries have been consolidated under @oclif/core and will be deprecated at some point in the future. Read the migration guide to learn how to update your CLI or plugin to use the new core library.

@oclif/command
@oclif/config
@oclif/error
@oclif/help
@oclif/parser

No more single vs multi command CLIs​
There's only one "type" of oclif v2 CLI, but it can have as few or as many commands as a developer wants. As a result, there’s only one command to generate CLIs, oclif generate, as opposed to the old oclif single and oclif multi commands.
Node > 12​
To ensure oclif CLIs are as secure as possible, all v2 libraries and plugins support only Node 12 or higher as of now. Going forward, they'll support only Node Maintenance or higher, as defined by Node's release schedule here: https://nodejs.org/en/about/releases/.
What’s new?​
New example CLI​
oclif-hello-world is our new example repo. This is also the repo that's used as a template when running oclif generate to create a new CLI. This repo will always be able to be referenced as an example of what an oclif v2 CLI should look like.
Spaced commands​
oclif CLIs can now use spaces, instead of colons, to separate topics and subcommands. To enable this feature, simply add “topicSeparator": " " to the oclif config in your package.json. See an example in our example repo.
// Old commands that use :$ mycli do:something
// New spaced commands$ mycli do something

Note: Spaced commands are backwards compatible. So if you enable spaced commands for your CLI, users will still be able to use : as a separator. This ensures that any existing scripts don't break.

New Help Output​
We’ve revamped the way command help is outputted to the terminal, making it both easier to implement and easier to read. See the difference between the old help output on the left and the new help output on the right in the screenshots below.
oclif v1oclif v2
Notice that there are new sections for flags and global flags, examples are displayed with better spacing, and there is a section at the bottom called Configuration Variables. This Configuration Variables section is not part of the new help by default. But we've added support for custom help sections, which is what the sf CLI uses to create the new section.
Async Command Parsing​
We’ve also improved the performance of new CLIs by rewriting how commands are parsed on initialization. The new parser is asynchronous, which makes CLIs with a lot of commands or installed  plugins much faster.
What’s coming next?​
Part of our charter for the release of oclif v2 includes improving our engagement with the oclif community. We know that over the past couple of years we’ve reduced our involvement, and a lot of issues and PRs have languished in limbo. Hopefully you’ve already seen increased activity and responses from oclif maintainers recently, but if you haven’t, please don’t hesitate to ping us by tagging @admins in oclif repos.
We also want to start interviewing members of the oclif community to acquire feedback and prioritize the features and fixes you deem most important!
Best,
The oclif team

Reference material​
Migration Guide​
This guide explains how to upgrade a CLI or plugin from the old oclif v1 libraries to the new @oclif/core library that oclif v2 uses.
https://github.com/oclif/core/blob/main/MIGRATION.md
Compatibility Matrix​
The following matrix shows how the v1 libraries and plugins relate to the new v2 ones. Use this matrix as a guide to know what to drop and which versions to switch when upgrading your plugins and CLIs to v2.
oclif "v1"oclif "v2"Utility CLIsoclif@<2@oclif/dev-cli@<2oclif@>=2Main packages@oclif/command@oclif/config@oclif/errors@oclif/parser@oclif/plugin-help@oclif/core@>=1Node LTSNode v8-14Node v12+ (at time of writing)TypeScripttypescript@<4typescript@>=4Main plugins@oclif/plugin-autocomplete@<1@oclif/plugin-commands@<2@oclif/plugin-help@<4@oclif/plugin-not-found@<2@oclif/plugin-plugins@<2@oclif/plugin-update@<2plugin-warn-if-update-available@<2plugin-which@<2@oclif/plugin-autocomplete@>=1@oclif/plugin-commands@>=2@oclif/plugin-help@>=4@oclif/plugin-not-found@>=2@oclif/plugin-plugins@>=2@oclif/plugin-update@>=2@oclif/plugin-warn-if-update-available@>=2@oclif/plugin-which@>=2Introducing @oclif/coreMarch 1, 2021 · 3 min readGreetings!
We hope this blog post finds you well.
Introducing...​
We are excited to announce the next iteration of the oclif project today: @oclif/core.
We have learned a lot in the last three years of developing oclif, developing on oclif and supporting millions of command runs a day via Heroku and Salesforce CLIs.
@oclif/core ("Core") simplifies the oclif development experience and introduces highly requested new features.
Core combines the essential oclif packages into one "core" package, aptly named @oclif/core.
Core also introduces:

A default command option
Colon or space command syntax
Async command parsing
Command piping to arguments

With the introduction of default command functionality, Core simplifies the oclif project and removes the notion of single or multi command CLIs. Core CLIs can have 1 or many commands.
Along with Core, we moved the oclif-dev CLI into the oclif CLI creating a single "utility" CLI. This CLI also introduces a new AWS S3 compatible publishing scheme.
What to expect in the near future​
Core is in pre-release beta and being actively developed for new internal Salesforce CLIs.
Much documentation needs to be written in the coming months including migration paths. Migration onto Core should be as painless as possible with many exports remaining entirely unchanged. Look for forthcoming blog posts and documentation on oclif.io.
Early this summer, tentively June 1, we will release Core v1. Core's release will coincide with major bumps to many other oclif plugin packages. See the compatibility matrix below.
At Core's v1 release, the current "main" oclif packages (namely: command, config, errors & parser) will go into maintenance mode until Jan 2022. They will receive only bug and security fixes and they remain compatible with current versions of the oclif and oclif-dev CLIs. Afterwhich, they will be archived.
Companioning Core, the next major release of the oclif CLI (literally oclif@2) will generate Core CLIs.
Going forward​
We are excited to release Core! We invite you to poke around the Core repo. It may appear to be a big change but Core keeps what you already enjoy about oclif while reducing development complexity, project dependencies, package coupling and bundle size and introduces many requested features previously too prickly to weave into the current oclif architecture.
Best,
The oclif team
Reference: Compatibility matrix​
oclif "v1"oclif "Core"Utility CLIsoclif@<2@oclif/dev-cli@<2oclif@>=2Main packages@oclif/core@<2@oclif/config@<2@oclif/errors@<2@oclif/parser@<4@oclif/plugin-help@<4@oclif/core@>=1Node LTSNode v8-14Node v12+TypeScripttypescript@<4typescript@>=4Main plugins@oclif/plugin-autocomplete@<1@oclif/plugin-commands@<2@oclif/plugin-help@<4@oclif/plugin-not-found@<2@oclif/plugin-plugins@<2@oclif/plugin-update@<2plugin-warn-if-update-available@<2plugin-which@<2@oclif/plugin-autocomplete@>=2@oclif/plugin-commands@>=2@oclif/plugin-help@>=4@oclif/plugin-not-found@>=2@oclif/plugin-plugins@>=2@oclif/plugin-update@>=2@oclif/plugin-warn-if-update-available@>=2@oclif/plugin-which@>=2oclif Summer 2020 UpdateAugust 26, 2020 · 2 min readHello oclif developers! We hope you are all doing well.
Earlier this year, we started our planning for oclifconf v2 and, like all conference, had to change course. We opted not to hold a virtual conference, however, we wanted to take some time to highlight a few oclif features shipped this year.
Feature: Help templating​
One of the most requested features, help templating enables oclif developers to customize the help output for their CLI.
Read the announcement.
Feature: Custom error delegation​
This feature both improved how oclif throws and handles errors and allows oclif developers to overwrite or interject in oclif’s error handling.
Read the announcement.
Feature: postrun hooks​
We have added a new lifecycle event postrun. Your CLI can now run a hook after a command has ran.
See our hook documentation.
Feature: Root index command​
Previously, oclif would display CLI help if only the binary name with no command ID was invoked, oclif now supports a "root index" command. If present, a command defined at src/commands/index.ts will be run if no command ID is found.
1 million weekly downloads​
While exact oclif usage metrics are hard to pin down, we use npm download statistics of oclif packages as a rough approximation. Earlier this year, oclif's command package hit 1 million weekly downloads for the first time!
This year has been presented its challenges on everyone. We want to thank you, oclif developers, whom have taken the time to use and improve the oclif project. We look forward to seeing you all - in person - in the future!
All our best,
The oclif teamPretty Printable ErrorsJuly 1, 2020 · One min readOften CLIs are used as handy tools and when things go wrong it’s useful to have additional context. In oclif we have added a couple of additional properties that can show extra context to the users when an error is displayed. The code, ref and suggestions will now be displayed if they are included. This will work with an existing oclif CLI by adding the latest @oclif/errors and @oclif/core to the CLI's package.json dependencies.
For example, using this.error with the additional properties:
class TestError extends Command {  async run() {    this.error("An error has occurred!", {      code: "OCLIF_ERR",      ref: "https://oclif.io/docs/commands#thiserrormessage-string--error-options-code-string-exit-number",      suggestions: ["Use these extra properties to provide additional context"],    })  }}
would result with the following output:
›   Error: An error has occurred!›   Code: OCLIF_ERR›   Try this: Use these extra properties to provide additional context›   Reference: https://oclif.io/docs/commands#thiserrormessage-string--error-options-code-string-exit-number
If these properties are not provided then nothing changes and the CLI will continue to display the single error message output as it did before. Additionally, as part of this exercise we’ve added documentation around Error Handling in oclif which should come in handy if the need arises to extend oclif’s default handling of errors.Customizing Help in oclifMay 5, 2020 · 2 min readOut of the box oclif provides a great help experience for CLIs.
But what if, as an oclif developer, you want to customize some or all of the output?
You can now customize your CLI's help output by implementing the HelpBase abstract class.
Getting started with custom help​
If you have not done so yet, update @oclif/core.
$ yarn add --latest @oclif/core
To get started, first define the filepath to your help class in oclif's config in package.json. This is a relative path to the help class, without a file extension.
For this example, the help class will be created in a file at "[project root]/src/help.ts".
{  // ...  "oclif": {    "helpClass": "./lib/help"    // ...  }  // ...}
From here there are two paths, implement the HelpBase abstract class yourself or overwrite the parts of the default Help class you want to customize (ex: how command usage is displayed). We recommend the latter approach but cover both in the new Help Classes docs.
Separating TOPICS & COMMANDS in the new default Help class​
Previously, topics and child commands were listed in help output under a single list heading called "COMMANDS". But we found this can be slightly confusing. Some topics are commands also (a.k.a. topic-commands) while others are simply organizational namespacing (and when ran just show their help).
The new default Help class splits the list of children into distinct lists of "TOPICS" and "COMMANDS", with the possibility of an item appearing in both if it a topic-command. This makes it clearer what is expected to be ran - "COMMANDS" - and what is providing structure - "TOPICS" - when looking at the help output.
VERSION  plugin-help-example/0.0.0 darwin-x64 node-v12.12.0USAGE  $ plugin-help-example [COMMAND]TOPICS  topic  this is a topic and has child topics or commandsCOMMANDS  hello  describe the command here  help   display help for plugin-help-example
We look forward to seeing what custom help features you implement in your oclif CLIs with this new feature!oclif TSLint to ESLint MigrationDecember 5, 2019 · 3 min readBack in February of this year, plans were announced to deprecate TSLint in favor of ESLint. TSLint's goal has become to work toward a “unified developer experience” by supporting ESLint development going forward.
What has changed in oclif​
To keep inline with the community, oclif has transitioned to ESLint for all our core libraries as well as all our official plugins.
Starting in v1.15.x, oclif will now optionally generate projects with ESLint for both TypeScript and JavaScript CLI’s.
ESLint does require Node to be on stable LTS version, at the time of writing, Node 8.10.x, Node 10.13.x & Node 12.x.x.
How does this affect you​
Existing CLI’s are unchanged, but any newly generated CLI's will only give the option of using ESLint. If you are running tslint in your CLI, we recommend you switch to ESLint as well.
In migrating our projects we took the following steps (for an example of these changes see this pull request).


Install eslint
$ yarn add eslint eslint-config-oclif eslint-config-oclif-typescript --dev


Add eslint related files


$ echo '{  "extends": [    "oclif",    "oclif-typescript"  ],  "rules": {  }}' > .eslintrc


Remove tslint and related packages
$ yarn remove @oclif/tslint tslint


Remove tslint related configuration files
$ rm tslint.json


Change lint script in our package.json from something like:
"lint": "tsc -p test --noEmit && tslint -p test -t stylish"
to
"lint": "eslint . --ext .ts --config .eslintrc"


To preserve the test compile (tsc -p test --noEmit) we also made the following updates to our scripts:
"pretest": "tsc -p test --noEmit"
In some cases we had our posttest duplicating the same steps as our lint script so it’s cleaner to have it reference the lint job directly with:
"posttest": "yarn lint"

Run yarn lint --fix. This attempts to auto-fix any linting violations automatically. In the case an auto-fix isn’t available it should be fixed manually or ignored (see the eslint configuration doc for more information)
Do a search in the codebase for tslint and remove any unnecessary tslint disabling comments, like:

/* tslint:disable:object-literal-sort-keys */
If you are on a version of Node that is not supported by ESLint, you will also need to update your Node engine. ESLint supports Node 8, 10, and 12 so you should upgrade to the most recent Node version compatible with your CLI and also supported by ESLint (see ESLint's Installation and Usage instructions).
When will this take effect​
These changes have taken effect in oclif v1.15.1. When you generate a new CLI or plugin it will now contain configuration for ESLint instead of TSLint.oclif's Current Node SupportOctober 31, 2019 · 3 min readTo maintain a healthy project trajectory, oclif follows and supports Node Active LTS release, currently Node 10 & Node 12. This means ensuring that oclif continues to play nice with coming Active LTS Node versions and other packages in the ecosystem. Moving forward also means leaving older versions behind. Starting in 2020, Node will stop maintaining Node 8 and it is our intent at that time to also follow suit. Let’s take a look at a few ways we will be supporting these changes.
CI Environments​
CLIs created with the oclif cli going forward will be generated with a CircleCI configuration with Node 10 & 12 and an Appveyor configuration using Node 10. We have also added Node latest to CircleCi to be an early warning detection against coming Node changes (Node latest is managed by CircleCI).
We have already updated every oclif repo's CI configs to reflect this.
If your existing CLI uses either Appveyor or CircleCI you can update your config files also, like so:
.circleci/config.yml​
Your CircleCI config should contain a node-latest job, aliased as test. From this, there should be two extensions of this job for the Active LTS Node versions, Node 10 and Node 12.
  node-10:    <<: *node-latest    docker:      - image: node:10  node-12:    <<: *node-latest    docker:      - image: node:12
Notice that these declarations only change the Docker Node images used to run that job.
Additionally, the jobs listed within workflows must also be updated to reflect our changes in configuration:
    jobs:      - node-latest      - node-10      - node-12
appveyor.yml​
For appveyor we are currently only testing the oldest Active LTS Node version, Node 10. Update the nodejs_version proppert in your appveyor.yml file to reflect this.
environment:  nodejs_version: "10"
Deprecating Node 8 & Updating packge.json engines​
In Jan 2020, Node will end its Node 8 maintenance. We will follow suit by setting the package.json engine property in oclif packages to >=10 and bumping the package's major versions.
Depending on how you ship your CLI you may wish to also bump the engines version in your CLI's package.json. You can read more about the implications of the engines property configuration in the npm documentation.
Also consider distributing your CLI with its own Node version.
Packaged Node Version​
When using dev-cli to pack your CLI it will use the Node version as specified in your package.json under the oclif.update.node.version property. This value should reflect an Active LTS Node version (dev-cli does not currently enforce versions).
Supporting the future​
As a community we may discover bumps along the way as we upgrade. If you notice something related to oclif please feel free to open an issue or submit a pull request under the relevant oclif package within the org.
We look forward to using the latest from Node and the community and keeping oclif healthy along the way.oclifconf 2019: A RecapSeptember 16, 2019 · 4 min readIn May, Heroku and Salesforce Open Source organized oclifconf, a conference for developers & product managers building CLI tools on top of the open source oclif framework. The speakers came from various tech companies, such as Adobe, Netlify, and Apollo, who have already built amazing CLI experiences. The topics covered everything from the incredible capabilities oclif has unlocked, to the community-built plugins extending its functionality, and even what the behavior of an adaptive CLI tool might look like.
Below is a listing of all of the talks from the event, along with a short summary. Enjoy!
The future of oclif by Jeff Dickey​

In its relatively short lifetime, oclif has already inspired many developers and companies to adopt its framework as a means for implementing their own command-line tooling. In this talk, Jeff Dickey, an oclif founding team member, recaps the project's history and inspiration. He also looks towards the future and outlines some features and improvements that the tool could adapt. This isn't so much a definitive roadmap of where oclif is headed, but rather, a call to inspiration for developers eager to contribute! And if you are interested in contributing, check out the open issues in the oclif GitHub repo and come say "Hello!" on Spectrum Chat.
Open Source Citizenship by Josh Simmons​

When it comes to open source, it's more than just individuals now. More and more frequently, large corporations are contributing to projects by donating to contributors, sponsoring events, or upstreaming contributions. But keeping open source projects and communities healthy requires more than just money and brainpower. Josh Simmons surveyed multiple open source communities and relays his findings as to what help maintainers and contributors actually need in this talk.
Building an enterprise-grade CLI with oclif by Thomas Dvornik​

Security and performance are all about trust. While oclif is an extremely extensible framework for building CLI tooling, there are additional requirements to fulfill for enterprise businesses to adopt it that might not be necessary for individual developers. Thomas Dvornik outlines what he and his colleagues at Salesforce have implemented as plugins to oclif to satisfy these needs, including encrypted OAuth, plugin signing, lazy loading dependencies, synchronizing weekly releases and deprecations across dozens of repositories, and establishing cross-team coding and documentation standards.
How Adobe I/O built an extensible CLI with oclif by Jesse MacFadyen​

Perhaps oclif's most appealing feature is its support for plugins. In Cordova's case, they've created a sophisticated telemetry system that helps Adobe developers see which commands users are using--and reports on which ones are erroring out. By embedding a feedback system into the tool, users are even able to quickly send their suggestions to a form, without ever leaving the terminal. Jesse MacFadyen demonstrates how oclif's plugin system can work beyond simply executing commands.
Integrating oclif with GraphQL and Apollo by Evans Hauser​

For Evans Hauser and the team at Apollo, oclif is best thought of as "React for the CLI." As a client paired with a strongly-typed API contract to a server, it can deliver structured and consistent commands to retrieve external data. What better mechanism to use for this transfer than GraphQL, a framework which empowers the client to ask precisely for the data it needs, and nothing more?
Adaptive Intent-based CLI State Machines by Shawn Wang​

In designing oclif, Jeff Dickey wrote out 12 CLI factors to keep in mind. In this talk, Shawn Wang outlines a 13th: state. State is hard, because it depends on context, and context depends on understanding what a user intends to do, not what they are asking. Shawn is working towards enabling oclif to better understand the commands a user has entered, so that it can predict and interpret future commands that might be entered next. This would enable CLI tools to not just interpret a users' commands, but to also interpret their intent.Older Entries\n\n\n\nIntroducing `oclif init` commandApril 10, 2024 · 2 min readThanks to the contribution of @joshcanhelp we released a new command for the oclif CLI called oclif init in version 4.8.0
The oclif init command allows you to initialize oclif in an existing project directory by adding the bare minimum requirements: a few pieces of configuration, bin scripts, and a couple of dependencies (@oclif/core and ts-node). This is slightly different from oclif generate, which will create an entirely new oclif project based on our templates.
oclif init will add the following:

bin scripts: bin/run.js, bin/run.cmd, bin/dev.js, and bin/dev.cmd
oclif section to package.json with bin, dirname, commands, and topicSeparator set (See Configuring Your CLI for more)
@oclif/core to dependencies in your package.json (if it's not already there)
ts-node to devDependencies in your package.json (if it's not already there)

Once you've initialized oclif, you can use the bin scripts to execute your CLI. You can also use the other oclif commands like oclif generate command and oclif generate hook to start adding new functionality.

❯ oclif init --helpInitialize a new oclif CLIUSAGE  $ oclif init [--bin <value>] [--module-type ESM|CommonJS] [--package-manager npm|yarn|pnpm] [--topic-separator    colons|spaces] [-d <value>] [-y]FLAGS  -d, --output-dir=<value>        Directory to initialize the CLI in.  -y, --yes                       Use defaults for all prompts. Individual flags will override defaults.      --bin=<value>               Supply answer for prompt: Command bin name the CLI will export      --module-type=<option>      Supply answer for prompt: Select a module type                                  <options: ESM|CommonJS>      --package-manager=<option>  Supply answer for prompt: Select a package manager                                  <options: npm|yarn|pnpm>      --topic-separator=<option>  Supply answer for prompt: Select a topic separator                                  <options: colons|spaces>DESCRIPTION  Initialize a new oclif CLI  This will add the necessary oclif bin files, add oclif config to package.json, and install @oclif/core and ts-node.EXAMPLES  Initialize a new CLI in the current directory    $ oclif init  Initialize a new CLI in a different directory    $ oclif init --output-dir "/path/to/existing/project"  Supply answers for specific prompts    $ oclif init --topic-separator colons --bin mycli
Hope you enjoy the new command! If you come across any issues or have any new ideas for this command, head over to the oclif/oclif repo and open a new issue.
All our best,
The oclif teamoclif Spring 2024 UpdateMarch 29, 2024 · 4 min readHello oclif developers! It's been a while since we last uploaded a blog - and a lot has happened.
We've been focusing on these high-level areas over the past couple of years:

Improving @oclif/core
ESM Support
Improving and revitalizing oclif.io
Re-engaging the oclif community

Improving @oclif/core​
Since we announced @oclif/core over three years ago, we've released two new major versions, each packed with lots of features that we're really excited about.
Here are some of these changes:

Full support for ESM and interoperability with CommonJS (more on this topic below).
Configurable command discovery strategies that give you more control over how commands are loaded at runtime. Check out the docs.
A new preparse hook that allows you to manipulate the provided arguments before they're parsed. Salesforce used this hook to implement a neat --flags-dir feature that translates local files into flags.
A new Performance class that you can use to track performance inside of @oclif/core and your own CLI or plugin. Check out the docs.
A new flag type, Flags.option, that lets you define a flag with a preset list of options. Typescript then uses the options to infer the flag's type.
Flags now have a relationship property that allows you to define more complex relationships between flags. Check out the flags docs for more information.
Flags now have a defaultHelp property that allows you to set the human readable default value in the command help. This property is useful when your flag's parse method returns a complex type, such as an object or a class. Check out the flags docs for more.
Commands now have a hiddenAliases property that allows you to define aliases that you want to hide from the user. The property is super helpful when you're trying to wean users off a deprecated command.
You can now use bun or tsx as dev runtimes (as opposed to node or ts-node).
A command's usage, args, and flags are now shown whenever a user forgets to provide a required arg or flag, or when they provided a non-existent flag.

If you need help migrating to the latest version, head over to core's README which has links to the migration guides. Feel free to open a new discussion if you need more hands-on help from us or the community.
ESM Support​
Version 3 of @oclif/core introduced full support for developing ESM plugins and CLIs. It also offered full support for interoperability between CommonJS and ESM plugins.
Put more simply, you can now migrate your CLI to ESM while keeping individual plugins in CommonJS (or vice versa). The upgrade path is now much simpler for you. You also don't need to worry about any community plugins that have migrated to ESM before you did (such as all the @oclif plugins) or are staunchly sticking with CommonJS for the foreseeable future.
Read more about this topic here.
Improving and Revitalizing oclif.io​
Another area of focus for us has been improving our documentation site, oclif.io.
While improving the quality and accuracy of the documentation was our priority, we also took the time to upgrade to the latest version of docusaurus. This new version gave our site a much-needed facelift, as well as cool new features such as dark mode and announcements.
If you have any feedback or are running into issues, we want to hear about it. Just create an issue in the oclif.io repo.
Re-engaging the oclif Community​
Lastly, our biggest priority at the moment is to re-engage the oclif community. We understand how frustrating it has been over the years to see your issues and pull requests go unacknowledged. We apologize for not prioritizing the community, and are earnestly trying to make sure that every issue and pull request gets the attention it deserves going forward.
We also opened up GitHub discussions for @oclif/core and the oclif CLI, where you can now post your questions or ideas. We hope you take advantage of them, we love hearing from you!
One last thing: we intend to publicly post our roadmap so you have more visibility into what we're working on. Stay tuned!
All our best,
The oclif teamAnnouncing oclif v2!January 12, 2022 · 5 min readHello and happy new year! It's our great pleasure to announce that we have released oclif v2, which uses the new @oclif/core library! 🎉
oclif v2 includes many changes that improve the experience of both creating and using an oclif CLI.
Going forward, we don't plan to make any updates to oclif v1 and its corresponding libraries, except for critical security fixes. See the compatibility matrix for a list of these libraries. In order to give developers time to migrate from v1 to v2, we're not completely dropping support yet. But at some point in the future we'll archive the v1 repositories and deprecate their versions on npm.
What’s changing?​
Repository Changes​
All repositories under the oclif org now use main as their primary branch and oclif-v1 as the legacy branch. The main  branch corresponds to oclif v2 and the oclif-v1 branch to oclif v1. If you find any repos that don’t have a main branch, you can safely assume that they're not used in oclif v2 and will be deprecated in the future.
Consolidating Tools & Libraries​
The oclif-dev CLI has now been incorporated into oclif. You now no longer need to install a separate package to manage your entire CLI’s lifecycle.
The following libraries have been consolidated under @oclif/core and will be deprecated at some point in the future. Read the migration guide to learn how to update your CLI or plugin to use the new core library.

@oclif/command
@oclif/config
@oclif/error
@oclif/help
@oclif/parser

No more single vs multi command CLIs​
There's only one "type" of oclif v2 CLI, but it can have as few or as many commands as a developer wants. As a result, there’s only one command to generate CLIs, oclif generate, as opposed to the old oclif single and oclif multi commands.
Node > 12​
To ensure oclif CLIs are as secure as possible, all v2 libraries and plugins support only Node 12 or higher as of now. Going forward, they'll support only Node Maintenance or higher, as defined by Node's release schedule here: https://nodejs.org/en/about/releases/.
What’s new?​
New example CLI​
oclif-hello-world is our new example repo. This is also the repo that's used as a template when running oclif generate to create a new CLI. This repo will always be able to be referenced as an example of what an oclif v2 CLI should look like.
Spaced commands​
oclif CLIs can now use spaces, instead of colons, to separate topics and subcommands. To enable this feature, simply add “topicSeparator": " " to the oclif config in your package.json. See an example in our example repo.
// Old commands that use :$ mycli do:something
// New spaced commands$ mycli do something

Note: Spaced commands are backwards compatible. So if you enable spaced commands for your CLI, users will still be able to use : as a separator. This ensures that any existing scripts don't break.

New Help Output​
We’ve revamped the way command help is outputted to the terminal, making it both easier to implement and easier to read. See the difference between the old help output on the left and the new help output on the right in the screenshots below.
oclif v1oclif v2
Notice that there are new sections for flags and global flags, examples are displayed with better spacing, and there is a section at the bottom called Configuration Variables. This Configuration Variables section is not part of the new help by default. But we've added support for custom help sections, which is what the sf CLI uses to create the new section.
Async Command Parsing​
We’ve also improved the performance of new CLIs by rewriting how commands are parsed on initialization. The new parser is asynchronous, which makes CLIs with a lot of commands or installed  plugins much faster.
What’s coming next?​
Part of our charter for the release of oclif v2 includes improving our engagement with the oclif community. We know that over the past couple of years we’ve reduced our involvement, and a lot of issues and PRs have languished in limbo. Hopefully you’ve already seen increased activity and responses from oclif maintainers recently, but if you haven’t, please don’t hesitate to ping us by tagging @admins in oclif repos.
We also want to start interviewing members of the oclif community to acquire feedback and prioritize the features and fixes you deem most important!
Best,
The oclif team

Reference material​
Migration Guide​
This guide explains how to upgrade a CLI or plugin from the old oclif v1 libraries to the new @oclif/core library that oclif v2 uses.
https://github.com/oclif/core/blob/main/MIGRATION.md
Compatibility Matrix​
The following matrix shows how the v1 libraries and plugins relate to the new v2 ones. Use this matrix as a guide to know what to drop and which versions to switch when upgrading your plugins and CLIs to v2.
oclif "v1"oclif "v2"Utility CLIsoclif@<2@oclif/dev-cli@<2oclif@>=2Main packages@oclif/command@oclif/config@oclif/errors@oclif/parser@oclif/plugin-help@oclif/core@>=1Node LTSNode v8-14Node v12+ (at time of writing)TypeScripttypescript@<4typescript@>=4Main plugins@oclif/plugin-autocomplete@<1@oclif/plugin-commands@<2@oclif/plugin-help@<4@oclif/plugin-not-found@<2@oclif/plugin-plugins@<2@oclif/plugin-update@<2plugin-warn-if-update-available@<2plugin-which@<2@oclif/plugin-autocomplete@>=1@oclif/plugin-commands@>=2@oclif/plugin-help@>=4@oclif/plugin-not-found@>=2@oclif/plugin-plugins@>=2@oclif/plugin-update@>=2@oclif/plugin-warn-if-update-available@>=2@oclif/plugin-which@>=2Introducing @oclif/coreMarch 1, 2021 · 3 min readGreetings!
We hope this blog post finds you well.
Introducing...​
We are excited to announce the next iteration of the oclif project today: @oclif/core.
We have learned a lot in the last three years of developing oclif, developing on oclif and supporting millions of command runs a day via Heroku and Salesforce CLIs.
@oclif/core ("Core") simplifies the oclif development experience and introduces highly requested new features.
Core combines the essential oclif packages into one "core" package, aptly named @oclif/core.
Core also introduces:

A default command option
Colon or space command syntax
Async command parsing
Command piping to arguments

With the introduction of default command functionality, Core simplifies the oclif project and removes the notion of single or multi command CLIs. Core CLIs can have 1 or many commands.
Along with Core, we moved the oclif-dev CLI into the oclif CLI creating a single "utility" CLI. This CLI also introduces a new AWS S3 compatible publishing scheme.
What to expect in the near future​
Core is in pre-release beta and being actively developed for new internal Salesforce CLIs.
Much documentation needs to be written in the coming months including migration paths. Migration onto Core should be as painless as possible with many exports remaining entirely unchanged. Look for forthcoming blog posts and documentation on oclif.io.
Early this summer, tentively June 1, we will release Core v1. Core's release will coincide with major bumps to many other oclif plugin packages. See the compatibility matrix below.
At Core's v1 release, the current "main" oclif packages (namely: command, config, errors & parser) will go into maintenance mode until Jan 2022. They will receive only bug and security fixes and they remain compatible with current versions of the oclif and oclif-dev CLIs. Afterwhich, they will be archived.
Companioning Core, the next major release of the oclif CLI (literally oclif@2) will generate Core CLIs.
Going forward​
We are excited to release Core! We invite you to poke around the Core repo. It may appear to be a big change but Core keeps what you already enjoy about oclif while reducing development complexity, project dependencies, package coupling and bundle size and introduces many requested features previously too prickly to weave into the current oclif architecture.
Best,
The oclif team
Reference: Compatibility matrix​
oclif "v1"oclif "Core"Utility CLIsoclif@<2@oclif/dev-cli@<2oclif@>=2Main packages@oclif/core@<2@oclif/config@<2@oclif/errors@<2@oclif/parser@<4@oclif/plugin-help@<4@oclif/core@>=1Node LTSNode v8-14Node v12+TypeScripttypescript@<4typescript@>=4Main plugins@oclif/plugin-autocomplete@<1@oclif/plugin-commands@<2@oclif/plugin-help@<4@oclif/plugin-not-found@<2@oclif/plugin-plugins@<2@oclif/plugin-update@<2plugin-warn-if-update-available@<2plugin-which@<2@oclif/plugin-autocomplete@>=2@oclif/plugin-commands@>=2@oclif/plugin-help@>=4@oclif/plugin-not-found@>=2@oclif/plugin-plugins@>=2@oclif/plugin-update@>=2@oclif/plugin-warn-if-update-available@>=2@oclif/plugin-which@>=2oclif Summer 2020 UpdateAugust 26, 2020 · 2 min readHello oclif developers! We hope you are all doing well.
Earlier this year, we started our planning for oclifconf v2 and, like all conference, had to change course. We opted not to hold a virtual conference, however, we wanted to take some time to highlight a few oclif features shipped this year.
Feature: Help templating​
One of the most requested features, help templating enables oclif developers to customize the help output for their CLI.
Read the announcement.
Feature: Custom error delegation​
This feature both improved how oclif throws and handles errors and allows oclif developers to overwrite or interject in oclif’s error handling.
Read the announcement.
Feature: postrun hooks​
We have added a new lifecycle event postrun. Your CLI can now run a hook after a command has ran.
See our hook documentation.
Feature: Root index command​
Previously, oclif would display CLI help if only the binary name with no command ID was invoked, oclif now supports a "root index" command. If present, a command defined at src/commands/index.ts will be run if no command ID is found.
1 million weekly downloads​
While exact oclif usage metrics are hard to pin down, we use npm download statistics of oclif packages as a rough approximation. Earlier this year, oclif's command package hit 1 million weekly downloads for the first time!
This year has been presented its challenges on everyone. We want to thank you, oclif developers, whom have taken the time to use and improve the oclif project. We look forward to seeing you all - in person - in the future!
All our best,
The oclif teamPretty Printable ErrorsJuly 1, 2020 · One min readOften CLIs are used as handy tools and when things go wrong it’s useful to have additional context. In oclif we have added a couple of additional properties that can show extra context to the users when an error is displayed. The code, ref and suggestions will now be displayed if they are included. This will work with an existing oclif CLI by adding the latest @oclif/errors and @oclif/core to the CLI's package.json dependencies.
For example, using this.error with the additional properties:
class TestError extends Command {  async run() {    this.error("An error has occurred!", {      code: "OCLIF_ERR",      ref: "https://oclif.io/docs/commands#thiserrormessage-string--error-options-code-string-exit-number",      suggestions: ["Use these extra properties to provide additional context"],    })  }}
would result with the following output:
›   Error: An error has occurred!›   Code: OCLIF_ERR›   Try this: Use these extra properties to provide additional context›   Reference: https://oclif.io/docs/commands#thiserrormessage-string--error-options-code-string-exit-number
If these properties are not provided then nothing changes and the CLI will continue to display the single error message output as it did before. Additionally, as part of this exercise we’ve added documentation around Error Handling in oclif which should come in handy if the need arises to extend oclif’s default handling of errors.Customizing Help in oclifMay 5, 2020 · 2 min readOut of the box oclif provides a great help experience for CLIs.
But what if, as an oclif developer, you want to customize some or all of the output?
You can now customize your CLI's help output by implementing the HelpBase abstract class.
Getting started with custom help​
If you have not done so yet, update @oclif/core.
$ yarn add --latest @oclif/core
To get started, first define the filepath to your help class in oclif's config in package.json. This is a relative path to the help class, without a file extension.
For this example, the help class will be created in a file at "[project root]/src/help.ts".
{  // ...  "oclif": {    "helpClass": "./lib/help"    // ...  }  // ...}
From here there are two paths, implement the HelpBase abstract class yourself or overwrite the parts of the default Help class you want to customize (ex: how command usage is displayed). We recommend the latter approach but cover both in the new Help Classes docs.
Separating TOPICS & COMMANDS in the new default Help class​
Previously, topics and child commands were listed in help output under a single list heading called "COMMANDS". But we found this can be slightly confusing. Some topics are commands also (a.k.a. topic-commands) while others are simply organizational namespacing (and when ran just show their help).
The new default Help class splits the list of children into distinct lists of "TOPICS" and "COMMANDS", with the possibility of an item appearing in both if it a topic-command. This makes it clearer what is expected to be ran - "COMMANDS" - and what is providing structure - "TOPICS" - when looking at the help output.
VERSION  plugin-help-example/0.0.0 darwin-x64 node-v12.12.0USAGE  $ plugin-help-example [COMMAND]TOPICS  topic  this is a topic and has child topics or commandsCOMMANDS  hello  describe the command here  help   display help for plugin-help-example
We look forward to seeing what custom help features you implement in your oclif CLIs with this new feature!oclif TSLint to ESLint MigrationDecember 5, 2019 · 3 min readBack in February of this year, plans were announced to deprecate TSLint in favor of ESLint. TSLint's goal has become to work toward a “unified developer experience” by supporting ESLint development going forward.
What has changed in oclif​
To keep inline with the community, oclif has transitioned to ESLint for all our core libraries as well as all our official plugins.
Starting in v1.15.x, oclif will now optionally generate projects with ESLint for both TypeScript and JavaScript CLI’s.
ESLint does require Node to be on stable LTS version, at the time of writing, Node 8.10.x, Node 10.13.x & Node 12.x.x.
How does this affect you​
Existing CLI’s are unchanged, but any newly generated CLI's will only give the option of using ESLint. If you are running tslint in your CLI, we recommend you switch to ESLint as well.
In migrating our projects we took the following steps (for an example of these changes see this pull request).


Install eslint
$ yarn add eslint eslint-config-oclif eslint-config-oclif-typescript --dev


Add eslint related files


$ echo '{  "extends": [    "oclif",    "oclif-typescript"  ],  "rules": {  }}' > .eslintrc


Remove tslint and related packages
$ yarn remove @oclif/tslint tslint


Remove tslint related configuration files
$ rm tslint.json


Change lint script in our package.json from something like:
"lint": "tsc -p test --noEmit && tslint -p test -t stylish"
to
"lint": "eslint . --ext .ts --config .eslintrc"


To preserve the test compile (tsc -p test --noEmit) we also made the following updates to our scripts:
"pretest": "tsc -p test --noEmit"
In some cases we had our posttest duplicating the same steps as our lint script so it’s cleaner to have it reference the lint job directly with:
"posttest": "yarn lint"

Run yarn lint --fix. This attempts to auto-fix any linting violations automatically. In the case an auto-fix isn’t available it should be fixed manually or ignored (see the eslint configuration doc for more information)
Do a search in the codebase for tslint and remove any unnecessary tslint disabling comments, like:

/* tslint:disable:object-literal-sort-keys */
If you are on a version of Node that is not supported by ESLint, you will also need to update your Node engine. ESLint supports Node 8, 10, and 12 so you should upgrade to the most recent Node version compatible with your CLI and also supported by ESLint (see ESLint's Installation and Usage instructions).
When will this take effect​
These changes have taken effect in oclif v1.15.1. When you generate a new CLI or plugin it will now contain configuration for ESLint instead of TSLint.oclif's Current Node SupportOctober 31, 2019 · 3 min readTo maintain a healthy project trajectory, oclif follows and supports Node Active LTS release, currently Node 10 & Node 12. This means ensuring that oclif continues to play nice with coming Active LTS Node versions and other packages in the ecosystem. Moving forward also means leaving older versions behind. Starting in 2020, Node will stop maintaining Node 8 and it is our intent at that time to also follow suit. Let’s take a look at a few ways we will be supporting these changes.
CI Environments​
CLIs created with the oclif cli going forward will be generated with a CircleCI configuration with Node 10 & 12 and an Appveyor configuration using Node 10. We have also added Node latest to CircleCi to be an early warning detection against coming Node changes (Node latest is managed by CircleCI).
We have already updated every oclif repo's CI configs to reflect this.
If your existing CLI uses either Appveyor or CircleCI you can update your config files also, like so:
.circleci/config.yml​
Your CircleCI config should contain a node-latest job, aliased as test. From this, there should be two extensions of this job for the Active LTS Node versions, Node 10 and Node 12.
  node-10:    <<: *node-latest    docker:      - image: node:10  node-12:    <<: *node-latest    docker:      - image: node:12
Notice that these declarations only change the Docker Node images used to run that job.
Additionally, the jobs listed within workflows must also be updated to reflect our changes in configuration:
    jobs:      - node-latest      - node-10      - node-12
appveyor.yml​
For appveyor we are currently only testing the oldest Active LTS Node version, Node 10. Update the nodejs_version proppert in your appveyor.yml file to reflect this.
environment:  nodejs_version: "10"
Deprecating Node 8 & Updating packge.json engines​
In Jan 2020, Node will end its Node 8 maintenance. We will follow suit by setting the package.json engine property in oclif packages to >=10 and bumping the package's major versions.
Depending on how you ship your CLI you may wish to also bump the engines version in your CLI's package.json. You can read more about the implications of the engines property configuration in the npm documentation.
Also consider distributing your CLI with its own Node version.
Packaged Node Version​
When using dev-cli to pack your CLI it will use the Node version as specified in your package.json under the oclif.update.node.version property. This value should reflect an Active LTS Node version (dev-cli does not currently enforce versions).
Supporting the future​
As a community we may discover bumps along the way as we upgrade. If you notice something related to oclif please feel free to open an issue or submit a pull request under the relevant oclif package within the org.
We look forward to using the latest from Node and the community and keeping oclif healthy along the way.oclifconf 2019: A RecapSeptember 16, 2019 · 4 min readIn May, Heroku and Salesforce Open Source organized oclifconf, a conference for developers & product managers building CLI tools on top of the open source oclif framework. The speakers came from various tech companies, such as Adobe, Netlify, and Apollo, who have already built amazing CLI experiences. The topics covered everything from the incredible capabilities oclif has unlocked, to the community-built plugins extending its functionality, and even what the behavior of an adaptive CLI tool might look like.
Below is a listing of all of the talks from the event, along with a short summary. Enjoy!
The future of oclif by Jeff Dickey​

In its relatively short lifetime, oclif has already inspired many developers and companies to adopt its framework as a means for implementing their own command-line tooling. In this talk, Jeff Dickey, an oclif founding team member, recaps the project's history and inspiration. He also looks towards the future and outlines some features and improvements that the tool could adapt. This isn't so much a definitive roadmap of where oclif is headed, but rather, a call to inspiration for developers eager to contribute! And if you are interested in contributing, check out the open issues in the oclif GitHub repo and come say "Hello!" on Spectrum Chat.
Open Source Citizenship by Josh Simmons​

When it comes to open source, it's more than just individuals now. More and more frequently, large corporations are contributing to projects by donating to contributors, sponsoring events, or upstreaming contributions. But keeping open source projects and communities healthy requires more than just money and brainpower. Josh Simmons surveyed multiple open source communities and relays his findings as to what help maintainers and contributors actually need in this talk.
Building an enterprise-grade CLI with oclif by Thomas Dvornik​

Security and performance are all about trust. While oclif is an extremely extensible framework for building CLI tooling, there are additional requirements to fulfill for enterprise businesses to adopt it that might not be necessary for individual developers. Thomas Dvornik outlines what he and his colleagues at Salesforce have implemented as plugins to oclif to satisfy these needs, including encrypted OAuth, plugin signing, lazy loading dependencies, synchronizing weekly releases and deprecations across dozens of repositories, and establishing cross-team coding and documentation standards.
How Adobe I/O built an extensible CLI with oclif by Jesse MacFadyen​

Perhaps oclif's most appealing feature is its support for plugins. In Cordova's case, they've created a sophisticated telemetry system that helps Adobe developers see which commands users are using--and reports on which ones are erroring out. By embedding a feedback system into the tool, users are even able to quickly send their suggestions to a form, without ever leaving the terminal. Jesse MacFadyen demonstrates how oclif's plugin system can work beyond simply executing commands.
Integrating oclif with GraphQL and Apollo by Evans Hauser​

For Evans Hauser and the team at Apollo, oclif is best thought of as "React for the CLI." As a client paired with a strongly-typed API contract to a server, it can deliver structured and consistent commands to retrieve external data. What better mechanism to use for this transfer than GraphQL, a framework which empowers the client to ask precisely for the data it needs, and nothing more?
Adaptive Intent-based CLI State Machines by Shawn Wang​

In designing oclif, Jeff Dickey wrote out 12 CLI factors to keep in mind. In this talk, Shawn Wang outlines a 13th: state. State is hard, because it depends on context, and context depends on understanding what a user intends to do, not what they are asking. Shawn is working towards enabling oclif to better understand the commands a user has entered, so that it can predict and interpret future commands that might be entered next. This would enable CLI tools to not just interpret a users' commands, but to also interpret their intent.\n\nIntroducing `oclif init` commandApril 10, 2024 · 2 min readThanks to the contribution of @joshcanhelp we released a new command for the oclif CLI called oclif init in version 4.8.0
The oclif init command allows you to initialize oclif in an existing project directory by adding the bare minimum requirements: a few pieces of configuration, bin scripts, and a couple of dependencies (@oclif/core and ts-node). This is slightly different from oclif generate, which will create an entirely new oclif project based on our templates.
oclif init will add the following:

bin scripts: bin/run.js, bin/run.cmd, bin/dev.js, and bin/dev.cmd
oclif section to package.json with bin, dirname, commands, and topicSeparator set (See Configuring Your CLI for more)
@oclif/core to dependencies in your package.json (if it's not already there)
ts-node to devDependencies in your package.json (if it's not already there)

Once you've initialized oclif, you can use the bin scripts to execute your CLI. You can also use the other oclif commands like oclif generate command and oclif generate hook to start adding new functionality.

❯ oclif init --helpInitialize a new oclif CLIUSAGE  $ oclif init [--bin <value>] [--module-type ESM|CommonJS] [--package-manager npm|yarn|pnpm] [--topic-separator    colons|spaces] [-d <value>] [-y]FLAGS  -d, --output-dir=<value>        Directory to initialize the CLI in.  -y, --yes                       Use defaults for all prompts. Individual flags will override defaults.      --bin=<value>               Supply answer for prompt: Command bin name the CLI will export      --module-type=<option>      Supply answer for prompt: Select a module type                                  <options: ESM|CommonJS>      --package-manager=<option>  Supply answer for prompt: Select a package manager                                  <options: npm|yarn|pnpm>      --topic-separator=<option>  Supply answer for prompt: Select a topic separator                                  <options: colons|spaces>DESCRIPTION  Initialize a new oclif CLI  This will add the necessary oclif bin files, add oclif config to package.json, and install @oclif/core and ts-node.EXAMPLES  Initialize a new CLI in the current directory    $ oclif init  Initialize a new CLI in a different directory    $ oclif init --output-dir "/path/to/existing/project"  Supply answers for specific prompts    $ oclif init --topic-separator colons --bin mycli
Hope you enjoy the new command! If you come across any issues or have any new ideas for this command, head over to the oclif/oclif repo and open a new issue.
All our best,
The oclif teamoclif Spring 2024 UpdateMarch 29, 2024 · 4 min readHello oclif developers! It's been a while since we last uploaded a blog - and a lot has happened.
We've been focusing on these high-level areas over the past couple of years:

Improving @oclif/core
ESM Support
Improving and revitalizing oclif.io
Re-engaging the oclif community

Improving @oclif/core​
Since we announced @oclif/core over three years ago, we've released two new major versions, each packed with lots of features that we're really excited about.
Here are some of these changes:

Full support for ESM and interoperability with CommonJS (more on this topic below).
Configurable command discovery strategies that give you more control over how commands are loaded at runtime. Check out the docs.
A new preparse hook that allows you to manipulate the provided arguments before they're parsed. Salesforce used this hook to implement a neat --flags-dir feature that translates local files into flags.
A new Performance class that you can use to track performance inside of @oclif/core and your own CLI or plugin. Check out the docs.
A new flag type, Flags.option, that lets you define a flag with a preset list of options. Typescript then uses the options to infer the flag's type.
Flags now have a relationship property that allows you to define more complex relationships between flags. Check out the flags docs for more information.
Flags now have a defaultHelp property that allows you to set the human readable default value in the command help. This property is useful when your flag's parse method returns a complex type, such as an object or a class. Check out the flags docs for more.
Commands now have a hiddenAliases property that allows you to define aliases that you want to hide from the user. The property is super helpful when you're trying to wean users off a deprecated command.
You can now use bun or tsx as dev runtimes (as opposed to node or ts-node).
A command's usage, args, and flags are now shown whenever a user forgets to provide a required arg or flag, or when they provided a non-existent flag.

If you need help migrating to the latest version, head over to core's README which has links to the migration guides. Feel free to open a new discussion if you need more hands-on help from us or the community.
ESM Support​
Version 3 of @oclif/core introduced full support for developing ESM plugins and CLIs. It also offered full support for interoperability between CommonJS and ESM plugins.
Put more simply, you can now migrate your CLI to ESM while keeping individual plugins in CommonJS (or vice versa). The upgrade path is now much simpler for you. You also don't need to worry about any community plugins that have migrated to ESM before you did (such as all the @oclif plugins) or are staunchly sticking with CommonJS for the foreseeable future.
Read more about this topic here.
Improving and Revitalizing oclif.io​
Another area of focus for us has been improving our documentation site, oclif.io.
While improving the quality and accuracy of the documentation was our priority, we also took the time to upgrade to the latest version of docusaurus. This new version gave our site a much-needed facelift, as well as cool new features such as dark mode and announcements.
If you have any feedback or are running into issues, we want to hear about it. Just create an issue in the oclif.io repo.
Re-engaging the oclif Community​
Lastly, our biggest priority at the moment is to re-engage the oclif community. We understand how frustrating it has been over the years to see your issues and pull requests go unacknowledged. We apologize for not prioritizing the community, and are earnestly trying to make sure that every issue and pull request gets the attention it deserves going forward.
We also opened up GitHub discussions for @oclif/core and the oclif CLI, where you can now post your questions or ideas. We hope you take advantage of them, we love hearing from you!
One last thing: we intend to publicly post our roadmap so you have more visibility into what we're working on. Stay tuned!
All our best,
The oclif teamAnnouncing oclif v2!January 12, 2022 · 5 min readHello and happy new year! It's our great pleasure to announce that we have released oclif v2, which uses the new @oclif/core library! 🎉
oclif v2 includes many changes that improve the experience of both creating and using an oclif CLI.
Going forward, we don't plan to make any updates to oclif v1 and its corresponding libraries, except for critical security fixes. See the compatibility matrix for a list of these libraries. In order to give developers time to migrate from v1 to v2, we're not completely dropping support yet. But at some point in the future we'll archive the v1 repositories and deprecate their versions on npm.
What’s changing?​
Repository Changes​
All repositories under the oclif org now use main as their primary branch and oclif-v1 as the legacy branch. The main  branch corresponds to oclif v2 and the oclif-v1 branch to oclif v1. If you find any repos that don’t have a main branch, you can safely assume that they're not used in oclif v2 and will be deprecated in the future.
Consolidating Tools & Libraries​
The oclif-dev CLI has now been incorporated into oclif. You now no longer need to install a separate package to manage your entire CLI’s lifecycle.
The following libraries have been consolidated under @oclif/core and will be deprecated at some point in the future. Read the migration guide to learn how to update your CLI or plugin to use the new core library.

@oclif/command
@oclif/config
@oclif/error
@oclif/help
@oclif/parser

No more single vs multi command CLIs​
There's only one "type" of oclif v2 CLI, but it can have as few or as many commands as a developer wants. As a result, there’s only one command to generate CLIs, oclif generate, as opposed to the old oclif single and oclif multi commands.
Node > 12​
To ensure oclif CLIs are as secure as possible, all v2 libraries and plugins support only Node 12 or higher as of now. Going forward, they'll support only Node Maintenance or higher, as defined by Node's release schedule here: https://nodejs.org/en/about/releases/.
What’s new?​
New example CLI​
oclif-hello-world is our new example repo. This is also the repo that's used as a template when running oclif generate to create a new CLI. This repo will always be able to be referenced as an example of what an oclif v2 CLI should look like.
Spaced commands​
oclif CLIs can now use spaces, instead of colons, to separate topics and subcommands. To enable this feature, simply add “topicSeparator": " " to the oclif config in your package.json. See an example in our example repo.
// Old commands that use :$ mycli do:something
// New spaced commands$ mycli do something

Note: Spaced commands are backwards compatible. So if you enable spaced commands for your CLI, users will still be able to use : as a separator. This ensures that any existing scripts don't break.

New Help Output​
We’ve revamped the way command help is outputted to the terminal, making it both easier to implement and easier to read. See the difference between the old help output on the left and the new help output on the right in the screenshots below.
oclif v1oclif v2
Notice that there are new sections for flags and global flags, examples are displayed with better spacing, and there is a section at the bottom called Configuration Variables. This Configuration Variables section is not part of the new help by default. But we've added support for custom help sections, which is what the sf CLI uses to create the new section.
Async Command Parsing​
We’ve also improved the performance of new CLIs by rewriting how commands are parsed on initialization. The new parser is asynchronous, which makes CLIs with a lot of commands or installed  plugins much faster.
What’s coming next?​
Part of our charter for the release of oclif v2 includes improving our engagement with the oclif community. We know that over the past couple of years we’ve reduced our involvement, and a lot of issues and PRs have languished in limbo. Hopefully you’ve already seen increased activity and responses from oclif maintainers recently, but if you haven’t, please don’t hesitate to ping us by tagging @admins in oclif repos.
We also want to start interviewing members of the oclif community to acquire feedback and prioritize the features and fixes you deem most important!
Best,
The oclif team

Reference material​
Migration Guide​
This guide explains how to upgrade a CLI or plugin from the old oclif v1 libraries to the new @oclif/core library that oclif v2 uses.
https://github.com/oclif/core/blob/main/MIGRATION.md
Compatibility Matrix​
The following matrix shows how the v1 libraries and plugins relate to the new v2 ones. Use this matrix as a guide to know what to drop and which versions to switch when upgrading your plugins and CLIs to v2.
oclif "v1"oclif "v2"Utility CLIsoclif@<2@oclif/dev-cli@<2oclif@>=2Main packages@oclif/command@oclif/config@oclif/errors@oclif/parser@oclif/plugin-help@oclif/core@>=1Node LTSNode v8-14Node v12+ (at time of writing)TypeScripttypescript@<4typescript@>=4Main plugins@oclif/plugin-autocomplete@<1@oclif/plugin-commands@<2@oclif/plugin-help@<4@oclif/plugin-not-found@<2@oclif/plugin-plugins@<2@oclif/plugin-update@<2plugin-warn-if-update-available@<2plugin-which@<2@oclif/plugin-autocomplete@>=1@oclif/plugin-commands@>=2@oclif/plugin-help@>=4@oclif/plugin-not-found@>=2@oclif/plugin-plugins@>=2@oclif/plugin-update@>=2@oclif/plugin-warn-if-update-available@>=2@oclif/plugin-which@>=2Introducing @oclif/coreMarch 1, 2021 · 3 min readGreetings!
We hope this blog post finds you well.
Introducing...​
We are excited to announce the next iteration of the oclif project today: @oclif/core.
We have learned a lot in the last three years of developing oclif, developing on oclif and supporting millions of command runs a day via Heroku and Salesforce CLIs.
@oclif/core ("Core") simplifies the oclif development experience and introduces highly requested new features.
Core combines the essential oclif packages into one "core" package, aptly named @oclif/core.
Core also introduces:

A default command option
Colon or space command syntax
Async command parsing
Command piping to arguments

With the introduction of default command functionality, Core simplifies the oclif project and removes the notion of single or multi command CLIs. Core CLIs can have 1 or many commands.
Along with Core, we moved the oclif-dev CLI into the oclif CLI creating a single "utility" CLI. This CLI also introduces a new AWS S3 compatible publishing scheme.
What to expect in the near future​
Core is in pre-release beta and being actively developed for new internal Salesforce CLIs.
Much documentation needs to be written in the coming months including migration paths. Migration onto Core should be as painless as possible with many exports remaining entirely unchanged. Look for forthcoming blog posts and documentation on oclif.io.
Early this summer, tentively June 1, we will release Core v1. Core's release will coincide with major bumps to many other oclif plugin packages. See the compatibility matrix below.
At Core's v1 release, the current "main" oclif packages (namely: command, config, errors & parser) will go into maintenance mode until Jan 2022. They will receive only bug and security fixes and they remain compatible with current versions of the oclif and oclif-dev CLIs. Afterwhich, they will be archived.
Companioning Core, the next major release of the oclif CLI (literally oclif@2) will generate Core CLIs.
Going forward​
We are excited to release Core! We invite you to poke around the Core repo. It may appear to be a big change but Core keeps what you already enjoy about oclif while reducing development complexity, project dependencies, package coupling and bundle size and introduces many requested features previously too prickly to weave into the current oclif architecture.
Best,
The oclif team
Reference: Compatibility matrix​
oclif "v1"oclif "Core"Utility CLIsoclif@<2@oclif/dev-cli@<2oclif@>=2Main packages@oclif/core@<2@oclif/config@<2@oclif/errors@<2@oclif/parser@<4@oclif/plugin-help@<4@oclif/core@>=1Node LTSNode v8-14Node v12+TypeScripttypescript@<4typescript@>=4Main plugins@oclif/plugin-autocomplete@<1@oclif/plugin-commands@<2@oclif/plugin-help@<4@oclif/plugin-not-found@<2@oclif/plugin-plugins@<2@oclif/plugin-update@<2plugin-warn-if-update-available@<2plugin-which@<2@oclif/plugin-autocomplete@>=2@oclif/plugin-commands@>=2@oclif/plugin-help@>=4@oclif/plugin-not-found@>=2@oclif/plugin-plugins@>=2@oclif/plugin-update@>=2@oclif/plugin-warn-if-update-available@>=2@oclif/plugin-which@>=2oclif Summer 2020 UpdateAugust 26, 2020 · 2 min readHello oclif developers! We hope you are all doing well.
Earlier this year, we started our planning for oclifconf v2 and, like all conference, had to change course. We opted not to hold a virtual conference, however, we wanted to take some time to highlight a few oclif features shipped this year.
Feature: Help templating​
One of the most requested features, help templating enables oclif developers to customize the help output for their CLI.
Read the announcement.
Feature: Custom error delegation​
This feature both improved how oclif throws and handles errors and allows oclif developers to overwrite or interject in oclif’s error handling.
Read the announcement.
Feature: postrun hooks​
We have added a new lifecycle event postrun. Your CLI can now run a hook after a command has ran.
See our hook documentation.
Feature: Root index command​
Previously, oclif would display CLI help if only the binary name with no command ID was invoked, oclif now supports a "root index" command. If present, a command defined at src/commands/index.ts will be run if no command ID is found.
1 million weekly downloads​
While exact oclif usage metrics are hard to pin down, we use npm download statistics of oclif packages as a rough approximation. Earlier this year, oclif's command package hit 1 million weekly downloads for the first time!
This year has been presented its challenges on everyone. We want to thank you, oclif developers, whom have taken the time to use and improve the oclif project. We look forward to seeing you all - in person - in the future!
All our best,
The oclif teamPretty Printable ErrorsJuly 1, 2020 · One min readOften CLIs are used as handy tools and when things go wrong it’s useful to have additional context. In oclif we have added a couple of additional properties that can show extra context to the users when an error is displayed. The code, ref and suggestions will now be displayed if they are included. This will work with an existing oclif CLI by adding the latest @oclif/errors and @oclif/core to the CLI's package.json dependencies.
For example, using this.error with the additional properties:
class TestError extends Command {  async run() {    this.error("An error has occurred!", {      code: "OCLIF_ERR",      ref: "https://oclif.io/docs/commands#thiserrormessage-string--error-options-code-string-exit-number",      suggestions: ["Use these extra properties to provide additional context"],    })  }}
would result with the following output:
›   Error: An error has occurred!›   Code: OCLIF_ERR›   Try this: Use these extra properties to provide additional context›   Reference: https://oclif.io/docs/commands#thiserrormessage-string--error-options-code-string-exit-number
If these properties are not provided then nothing changes and the CLI will continue to display the single error message output as it did before. Additionally, as part of this exercise we’ve added documentation around Error Handling in oclif which should come in handy if the need arises to extend oclif’s default handling of errors.Customizing Help in oclifMay 5, 2020 · 2 min readOut of the box oclif provides a great help experience for CLIs.
But what if, as an oclif developer, you want to customize some or all of the output?
You can now customize your CLI's help output by implementing the HelpBase abstract class.
Getting started with custom help​
If you have not done so yet, update @oclif/core.
$ yarn add --latest @oclif/core
To get started, first define the filepath to your help class in oclif's config in package.json. This is a relative path to the help class, without a file extension.
For this example, the help class will be created in a file at "[project root]/src/help.ts".
{  // ...  "oclif": {    "helpClass": "./lib/help"    // ...  }  // ...}
From here there are two paths, implement the HelpBase abstract class yourself or overwrite the parts of the default Help class you want to customize (ex: how command usage is displayed). We recommend the latter approach but cover both in the new Help Classes docs.
Separating TOPICS & COMMANDS in the new default Help class​
Previously, topics and child commands were listed in help output under a single list heading called "COMMANDS". But we found this can be slightly confusing. Some topics are commands also (a.k.a. topic-commands) while others are simply organizational namespacing (and when ran just show their help).
The new default Help class splits the list of children into distinct lists of "TOPICS" and "COMMANDS", with the possibility of an item appearing in both if it a topic-command. This makes it clearer what is expected to be ran - "COMMANDS" - and what is providing structure - "TOPICS" - when looking at the help output.
VERSION  plugin-help-example/0.0.0 darwin-x64 node-v12.12.0USAGE  $ plugin-help-example [COMMAND]TOPICS  topic  this is a topic and has child topics or commandsCOMMANDS  hello  describe the command here  help   display help for plugin-help-example
We look forward to seeing what custom help features you implement in your oclif CLIs with this new feature!oclif TSLint to ESLint MigrationDecember 5, 2019 · 3 min readBack in February of this year, plans were announced to deprecate TSLint in favor of ESLint. TSLint's goal has become to work toward a “unified developer experience” by supporting ESLint development going forward.
What has changed in oclif​
To keep inline with the community, oclif has transitioned to ESLint for all our core libraries as well as all our official plugins.
Starting in v1.15.x, oclif will now optionally generate projects with ESLint for both TypeScript and JavaScript CLI’s.
ESLint does require Node to be on stable LTS version, at the time of writing, Node 8.10.x, Node 10.13.x & Node 12.x.x.
How does this affect you​
Existing CLI’s are unchanged, but any newly generated CLI's will only give the option of using ESLint. If you are running tslint in your CLI, we recommend you switch to ESLint as well.
In migrating our projects we took the following steps (for an example of these changes see this pull request).


Install eslint
$ yarn add eslint eslint-config-oclif eslint-config-oclif-typescript --dev


Add eslint related files


$ echo '{  "extends": [    "oclif",    "oclif-typescript"  ],  "rules": {  }}' > .eslintrc


Remove tslint and related packages
$ yarn remove @oclif/tslint tslint


Remove tslint related configuration files
$ rm tslint.json


Change lint script in our package.json from something like:
"lint": "tsc -p test --noEmit && tslint -p test -t stylish"
to
"lint": "eslint . --ext .ts --config .eslintrc"


To preserve the test compile (tsc -p test --noEmit) we also made the following updates to our scripts:
"pretest": "tsc -p test --noEmit"
In some cases we had our posttest duplicating the same steps as our lint script so it’s cleaner to have it reference the lint job directly with:
"posttest": "yarn lint"

Run yarn lint --fix. This attempts to auto-fix any linting violations automatically. In the case an auto-fix isn’t available it should be fixed manually or ignored (see the eslint configuration doc for more information)
Do a search in the codebase for tslint and remove any unnecessary tslint disabling comments, like:

/* tslint:disable:object-literal-sort-keys */
If you are on a version of Node that is not supported by ESLint, you will also need to update your Node engine. ESLint supports Node 8, 10, and 12 so you should upgrade to the most recent Node version compatible with your CLI and also supported by ESLint (see ESLint's Installation and Usage instructions).
When will this take effect​
These changes have taken effect in oclif v1.15.1. When you generate a new CLI or plugin it will now contain configuration for ESLint instead of TSLint.oclif's Current Node SupportOctober 31, 2019 · 3 min readTo maintain a healthy project trajectory, oclif follows and supports Node Active LTS release, currently Node 10 & Node 12. This means ensuring that oclif continues to play nice with coming Active LTS Node versions and other packages in the ecosystem. Moving forward also means leaving older versions behind. Starting in 2020, Node will stop maintaining Node 8 and it is our intent at that time to also follow suit. Let’s take a look at a few ways we will be supporting these changes.
CI Environments​
CLIs created with the oclif cli going forward will be generated with a CircleCI configuration with Node 10 & 12 and an Appveyor configuration using Node 10. We have also added Node latest to CircleCi to be an early warning detection against coming Node changes (Node latest is managed by CircleCI).
We have already updated every oclif repo's CI configs to reflect this.
If your existing CLI uses either Appveyor or CircleCI you can update your config files also, like so:
.circleci/config.yml​
Your CircleCI config should contain a node-latest job, aliased as test. From this, there should be two extensions of this job for the Active LTS Node versions, Node 10 and Node 12.
  node-10:    <<: *node-latest    docker:      - image: node:10  node-12:    <<: *node-latest    docker:      - image: node:12
Notice that these declarations only change the Docker Node images used to run that job.
Additionally, the jobs listed within workflows must also be updated to reflect our changes in configuration:
    jobs:      - node-latest      - node-10      - node-12
appveyor.yml​
For appveyor we are currently only testing the oldest Active LTS Node version, Node 10. Update the nodejs_version proppert in your appveyor.yml file to reflect this.
environment:  nodejs_version: "10"
Deprecating Node 8 & Updating packge.json engines​
In Jan 2020, Node will end its Node 8 maintenance. We will follow suit by setting the package.json engine property in oclif packages to >=10 and bumping the package's major versions.
Depending on how you ship your CLI you may wish to also bump the engines version in your CLI's package.json. You can read more about the implications of the engines property configuration in the npm documentation.
Also consider distributing your CLI with its own Node version.
Packaged Node Version​
When using dev-cli to pack your CLI it will use the Node version as specified in your package.json under the oclif.update.node.version property. This value should reflect an Active LTS Node version (dev-cli does not currently enforce versions).
Supporting the future​
As a community we may discover bumps along the way as we upgrade. If you notice something related to oclif please feel free to open an issue or submit a pull request under the relevant oclif package within the org.
We look forward to using the latest from Node and the community and keeping oclif healthy along the way.oclifconf 2019: A RecapSeptember 16, 2019 · 4 min readIn May, Heroku and Salesforce Open Source organized oclifconf, a conference for developers & product managers building CLI tools on top of the open source oclif framework. The speakers came from various tech companies, such as Adobe, Netlify, and Apollo, who have already built amazing CLI experiences. The topics covered everything from the incredible capabilities oclif has unlocked, to the community-built plugins extending its functionality, and even what the behavior of an adaptive CLI tool might look like.
Below is a listing of all of the talks from the event, along with a short summary. Enjoy!
The future of oclif by Jeff Dickey​

In its relatively short lifetime, oclif has already inspired many developers and companies to adopt its framework as a means for implementing their own command-line tooling. In this talk, Jeff Dickey, an oclif founding team member, recaps the project's history and inspiration. He also looks towards the future and outlines some features and improvements that the tool could adapt. This isn't so much a definitive roadmap of where oclif is headed, but rather, a call to inspiration for developers eager to contribute! And if you are interested in contributing, check out the open issues in the oclif GitHub repo and come say "Hello!" on Spectrum Chat.
Open Source Citizenship by Josh Simmons​

When it comes to open source, it's more than just individuals now. More and more frequently, large corporations are contributing to projects by donating to contributors, sponsoring events, or upstreaming contributions. But keeping open source projects and communities healthy requires more than just money and brainpower. Josh Simmons surveyed multiple open source communities and relays his findings as to what help maintainers and contributors actually need in this talk.
Building an enterprise-grade CLI with oclif by Thomas Dvornik​

Security and performance are all about trust. While oclif is an extremely extensible framework for building CLI tooling, there are additional requirements to fulfill for enterprise businesses to adopt it that might not be necessary for individual developers. Thomas Dvornik outlines what he and his colleagues at Salesforce have implemented as plugins to oclif to satisfy these needs, including encrypted OAuth, plugin signing, lazy loading dependencies, synchronizing weekly releases and deprecations across dozens of repositories, and establishing cross-team coding and documentation standards.
How Adobe I/O built an extensible CLI with oclif by Jesse MacFadyen​

Perhaps oclif's most appealing feature is its support for plugins. In Cordova's case, they've created a sophisticated telemetry system that helps Adobe developers see which commands users are using--and reports on which ones are erroring out. By embedding a feedback system into the tool, users are even able to quickly send their suggestions to a form, without ever leaving the terminal. Jesse MacFadyen demonstrates how oclif's plugin system can work beyond simply executing commands.
Integrating oclif with GraphQL and Apollo by Evans Hauser​

For Evans Hauser and the team at Apollo, oclif is best thought of as "React for the CLI." As a client paired with a strongly-typed API contract to a server, it can deliver structured and consistent commands to retrieve external data. What better mechanism to use for this transfer than GraphQL, a framework which empowers the client to ask precisely for the data it needs, and nothing more?
Adaptive Intent-based CLI State Machines by Shawn Wang​

In designing oclif, Jeff Dickey wrote out 12 CLI factors to keep in mind. In this talk, Shawn Wang outlines a 13th: state. State is hard, because it depends on context, and context depends on understanding what a user intends to do, not what they are asking. Shawn is working towards enabling oclif to better understand the commands a user has entered, so that it can predict and interpret future commands that might be entered next. This would enable CLI tools to not just interpret a users' commands, but to also interpret their intent.Older Entries\n\n\n\nIntroducing `oclif init` commandApril 10, 2024 · 2 min readThanks to the contribution of @joshcanhelp we released a new command for the oclif CLI called oclif init in version 4.8.0
The oclif init command allows you to initialize oclif in an existing project directory by adding the bare minimum requirements: a few pieces of configuration, bin scripts, and a couple of dependencies (@oclif/core and ts-node). This is slightly different from oclif generate, which will create an entirely new oclif project based on our templates.
oclif init will add the following:

bin scripts: bin/run.js, bin/run.cmd, bin/dev.js, and bin/dev.cmd
oclif section to package.json with bin, dirname, commands, and topicSeparator set (See Configuring Your CLI for more)
@oclif/core to dependencies in your package.json (if it's not already there)
ts-node to devDependencies in your package.json (if it's not already there)

Once you've initialized oclif, you can use the bin scripts to execute your CLI. You can also use the other oclif commands like oclif generate command and oclif generate hook to start adding new functionality.

❯ oclif init --helpInitialize a new oclif CLIUSAGE  $ oclif init [--bin <value>] [--module-type ESM|CommonJS] [--package-manager npm|yarn|pnpm] [--topic-separator    colons|spaces] [-d <value>] [-y]FLAGS  -d, --output-dir=<value>        Directory to initialize the CLI in.  -y, --yes                       Use defaults for all prompts. Individual flags will override defaults.      --bin=<value>               Supply answer for prompt: Command bin name the CLI will export      --module-type=<option>      Supply answer for prompt: Select a module type                                  <options: ESM|CommonJS>      --package-manager=<option>  Supply answer for prompt: Select a package manager                                  <options: npm|yarn|pnpm>      --topic-separator=<option>  Supply answer for prompt: Select a topic separator                                  <options: colons|spaces>DESCRIPTION  Initialize a new oclif CLI  This will add the necessary oclif bin files, add oclif config to package.json, and install @oclif/core and ts-node.EXAMPLES  Initialize a new CLI in the current directory    $ oclif init  Initialize a new CLI in a different directory    $ oclif init --output-dir "/path/to/existing/project"  Supply answers for specific prompts    $ oclif init --topic-separator colons --bin mycli
Hope you enjoy the new command! If you come across any issues or have any new ideas for this command, head over to the oclif/oclif repo and open a new issue.
All our best,
The oclif teamoclif Spring 2024 UpdateMarch 29, 2024 · 4 min readHello oclif developers! It's been a while since we last uploaded a blog - and a lot has happened.
We've been focusing on these high-level areas over the past couple of years:

Improving @oclif/core
ESM Support
Improving and revitalizing oclif.io
Re-engaging the oclif community

Improving @oclif/core​
Since we announced @oclif/core over three years ago, we've released two new major versions, each packed with lots of features that we're really excited about.
Here are some of these changes:

Full support for ESM and interoperability with CommonJS (more on this topic below).
Configurable command discovery strategies that give you more control over how commands are loaded at runtime. Check out the docs.
A new preparse hook that allows you to manipulate the provided arguments before they're parsed. Salesforce used this hook to implement a neat --flags-dir feature that translates local files into flags.
A new Performance class that you can use to track performance inside of @oclif/core and your own CLI or plugin. Check out the docs.
A new flag type, Flags.option, that lets you define a flag with a preset list of options. Typescript then uses the options to infer the flag's type.
Flags now have a relationship property that allows you to define more complex relationships between flags. Check out the flags docs for more information.
Flags now have a defaultHelp property that allows you to set the human readable default value in the command help. This property is useful when your flag's parse method returns a complex type, such as an object or a class. Check out the flags docs for more.
Commands now have a hiddenAliases property that allows you to define aliases that you want to hide from the user. The property is super helpful when you're trying to wean users off a deprecated command.
You can now use bun or tsx as dev runtimes (as opposed to node or ts-node).
A command's usage, args, and flags are now shown whenever a user forgets to provide a required arg or flag, or when they provided a non-existent flag.

If you need help migrating to the latest version, head over to core's README which has links to the migration guides. Feel free to open a new discussion if you need more hands-on help from us or the community.
ESM Support​
Version 3 of @oclif/core introduced full support for developing ESM plugins and CLIs. It also offered full support for interoperability between CommonJS and ESM plugins.
Put more simply, you can now migrate your CLI to ESM while keeping individual plugins in CommonJS (or vice versa). The upgrade path is now much simpler for you. You also don't need to worry about any community plugins that have migrated to ESM before you did (such as all the @oclif plugins) or are staunchly sticking with CommonJS for the foreseeable future.
Read more about this topic here.
Improving and Revitalizing oclif.io​
Another area of focus for us has been improving our documentation site, oclif.io.
While improving the quality and accuracy of the documentation was our priority, we also took the time to upgrade to the latest version of docusaurus. This new version gave our site a much-needed facelift, as well as cool new features such as dark mode and announcements.
If you have any feedback or are running into issues, we want to hear about it. Just create an issue in the oclif.io repo.
Re-engaging the oclif Community​
Lastly, our biggest priority at the moment is to re-engage the oclif community. We understand how frustrating it has been over the years to see your issues and pull requests go unacknowledged. We apologize for not prioritizing the community, and are earnestly trying to make sure that every issue and pull request gets the attention it deserves going forward.
We also opened up GitHub discussions for @oclif/core and the oclif CLI, where you can now post your questions or ideas. We hope you take advantage of them, we love hearing from you!
One last thing: we intend to publicly post our roadmap so you have more visibility into what we're working on. Stay tuned!
All our best,
The oclif teamAnnouncing oclif v2!January 12, 2022 · 5 min readHello and happy new year! It's our great pleasure to announce that we have released oclif v2, which uses the new @oclif/core library! 🎉
oclif v2 includes many changes that improve the experience of both creating and using an oclif CLI.
Going forward, we don't plan to make any updates to oclif v1 and its corresponding libraries, except for critical security fixes. See the compatibility matrix for a list of these libraries. In order to give developers time to migrate from v1 to v2, we're not completely dropping support yet. But at some point in the future we'll archive the v1 repositories and deprecate their versions on npm.
What’s changing?​
Repository Changes​
All repositories under the oclif org now use main as their primary branch and oclif-v1 as the legacy branch. The main  branch corresponds to oclif v2 and the oclif-v1 branch to oclif v1. If you find any repos that don’t have a main branch, you can safely assume that they're not used in oclif v2 and will be deprecated in the future.
Consolidating Tools & Libraries​
The oclif-dev CLI has now been incorporated into oclif. You now no longer need to install a separate package to manage your entire CLI’s lifecycle.
The following libraries have been consolidated under @oclif/core and will be deprecated at some point in the future. Read the migration guide to learn how to update your CLI or plugin to use the new core library.

@oclif/command
@oclif/config
@oclif/error
@oclif/help
@oclif/parser

No more single vs multi command CLIs​
There's only one "type" of oclif v2 CLI, but it can have as few or as many commands as a developer wants. As a result, there’s only one command to generate CLIs, oclif generate, as opposed to the old oclif single and oclif multi commands.
Node > 12​
To ensure oclif CLIs are as secure as possible, all v2 libraries and plugins support only Node 12 or higher as of now. Going forward, they'll support only Node Maintenance or higher, as defined by Node's release schedule here: https://nodejs.org/en/about/releases/.
What’s new?​
New example CLI​
oclif-hello-world is our new example repo. This is also the repo that's used as a template when running oclif generate to create a new CLI. This repo will always be able to be referenced as an example of what an oclif v2 CLI should look like.
Spaced commands​
oclif CLIs can now use spaces, instead of colons, to separate topics and subcommands. To enable this feature, simply add “topicSeparator": " " to the oclif config in your package.json. See an example in our example repo.
// Old commands that use :$ mycli do:something
// New spaced commands$ mycli do something

Note: Spaced commands are backwards compatible. So if you enable spaced commands for your CLI, users will still be able to use : as a separator. This ensures that any existing scripts don't break.

New Help Output​
We’ve revamped the way command help is outputted to the terminal, making it both easier to implement and easier to read. See the difference between the old help output on the left and the new help output on the right in the screenshots below.
oclif v1oclif v2
Notice that there are new sections for flags and global flags, examples are displayed with better spacing, and there is a section at the bottom called Configuration Variables. This Configuration Variables section is not part of the new help by default. But we've added support for custom help sections, which is what the sf CLI uses to create the new section.
Async Command Parsing​
We’ve also improved the performance of new CLIs by rewriting how commands are parsed on initialization. The new parser is asynchronous, which makes CLIs with a lot of commands or installed  plugins much faster.
What’s coming next?​
Part of our charter for the release of oclif v2 includes improving our engagement with the oclif community. We know that over the past couple of years we’ve reduced our involvement, and a lot of issues and PRs have languished in limbo. Hopefully you’ve already seen increased activity and responses from oclif maintainers recently, but if you haven’t, please don’t hesitate to ping us by tagging @admins in oclif repos.
We also want to start interviewing members of the oclif community to acquire feedback and prioritize the features and fixes you deem most important!
Best,
The oclif team

Reference material​
Migration Guide​
This guide explains how to upgrade a CLI or plugin from the old oclif v1 libraries to the new @oclif/core library that oclif v2 uses.
https://github.com/oclif/core/blob/main/MIGRATION.md
Compatibility Matrix​
The following matrix shows how the v1 libraries and plugins relate to the new v2 ones. Use this matrix as a guide to know what to drop and which versions to switch when upgrading your plugins and CLIs to v2.
oclif "v1"oclif "v2"Utility CLIsoclif@<2@oclif/dev-cli@<2oclif@>=2Main packages@oclif/command@oclif/config@oclif/errors@oclif/parser@oclif/plugin-help@oclif/core@>=1Node LTSNode v8-14Node v12+ (at time of writing)TypeScripttypescript@<4typescript@>=4Main plugins@oclif/plugin-autocomplete@<1@oclif/plugin-commands@<2@oclif/plugin-help@<4@oclif/plugin-not-found@<2@oclif/plugin-plugins@<2@oclif/plugin-update@<2plugin-warn-if-update-available@<2plugin-which@<2@oclif/plugin-autocomplete@>=1@oclif/plugin-commands@>=2@oclif/plugin-help@>=4@oclif/plugin-not-found@>=2@oclif/plugin-plugins@>=2@oclif/plugin-update@>=2@oclif/plugin-warn-if-update-available@>=2@oclif/plugin-which@>=2Introducing @oclif/coreMarch 1, 2021 · 3 min readGreetings!
We hope this blog post finds you well.
Introducing...​
We are excited to announce the next iteration of the oclif project today: @oclif/core.
We have learned a lot in the last three years of developing oclif, developing on oclif and supporting millions of command runs a day via Heroku and Salesforce CLIs.
@oclif/core ("Core") simplifies the oclif development experience and introduces highly requested new features.
Core combines the essential oclif packages into one "core" package, aptly named @oclif/core.
Core also introduces:

A default command option
Colon or space command syntax
Async command parsing
Command piping to arguments

With the introduction of default command functionality, Core simplifies the oclif project and removes the notion of single or multi command CLIs. Core CLIs can have 1 or many commands.
Along with Core, we moved the oclif-dev CLI into the oclif CLI creating a single "utility" CLI. This CLI also introduces a new AWS S3 compatible publishing scheme.
What to expect in the near future​
Core is in pre-release beta and being actively developed for new internal Salesforce CLIs.
Much documentation needs to be written in the coming months including migration paths. Migration onto Core should be as painless as possible with many exports remaining entirely unchanged. Look for forthcoming blog posts and documentation on oclif.io.
Early this summer, tentively June 1, we will release Core v1. Core's release will coincide with major bumps to many other oclif plugin packages. See the compatibility matrix below.
At Core's v1 release, the current "main" oclif packages (namely: command, config, errors & parser) will go into maintenance mode until Jan 2022. They will receive only bug and security fixes and they remain compatible with current versions of the oclif and oclif-dev CLIs. Afterwhich, they will be archived.
Companioning Core, the next major release of the oclif CLI (literally oclif@2) will generate Core CLIs.
Going forward​
We are excited to release Core! We invite you to poke around the Core repo. It may appear to be a big change but Core keeps what you already enjoy about oclif while reducing development complexity, project dependencies, package coupling and bundle size and introduces many requested features previously too prickly to weave into the current oclif architecture.
Best,
The oclif team
Reference: Compatibility matrix​
oclif "v1"oclif "Core"Utility CLIsoclif@<2@oclif/dev-cli@<2oclif@>=2Main packages@oclif/core@<2@oclif/config@<2@oclif/errors@<2@oclif/parser@<4@oclif/plugin-help@<4@oclif/core@>=1Node LTSNode v8-14Node v12+TypeScripttypescript@<4typescript@>=4Main plugins@oclif/plugin-autocomplete@<1@oclif/plugin-commands@<2@oclif/plugin-help@<4@oclif/plugin-not-found@<2@oclif/plugin-plugins@<2@oclif/plugin-update@<2plugin-warn-if-update-available@<2plugin-which@<2@oclif/plugin-autocomplete@>=2@oclif/plugin-commands@>=2@oclif/plugin-help@>=4@oclif/plugin-not-found@>=2@oclif/plugin-plugins@>=2@oclif/plugin-update@>=2@oclif/plugin-warn-if-update-available@>=2@oclif/plugin-which@>=2oclif Summer 2020 UpdateAugust 26, 2020 · 2 min readHello oclif developers! We hope you are all doing well.
Earlier this year, we started our planning for oclifconf v2 and, like all conference, had to change course. We opted not to hold a virtual conference, however, we wanted to take some time to highlight a few oclif features shipped this year.
Feature: Help templating​
One of the most requested features, help templating enables oclif developers to customize the help output for their CLI.
Read the announcement.
Feature: Custom error delegation​
This feature both improved how oclif throws and handles errors and allows oclif developers to overwrite or interject in oclif’s error handling.
Read the announcement.
Feature: postrun hooks​
We have added a new lifecycle event postrun. Your CLI can now run a hook after a command has ran.
See our hook documentation.
Feature: Root index command​
Previously, oclif would display CLI help if only the binary name with no command ID was invoked, oclif now supports a "root index" command. If present, a command defined at src/commands/index.ts will be run if no command ID is found.
1 million weekly downloads​
While exact oclif usage metrics are hard to pin down, we use npm download statistics of oclif packages as a rough approximation. Earlier this year, oclif's command package hit 1 million weekly downloads for the first time!
This year has been presented its challenges on everyone. We want to thank you, oclif developers, whom have taken the time to use and improve the oclif project. We look forward to seeing you all - in person - in the future!
All our best,
The oclif teamPretty Printable ErrorsJuly 1, 2020 · One min readOften CLIs are used as handy tools and when things go wrong it’s useful to have additional context. In oclif we have added a couple of additional properties that can show extra context to the users when an error is displayed. The code, ref and suggestions will now be displayed if they are included. This will work with an existing oclif CLI by adding the latest @oclif/errors and @oclif/core to the CLI's package.json dependencies.
For example, using this.error with the additional properties:
class TestError extends Command {  async run() {    this.error("An error has occurred!", {      code: "OCLIF_ERR",      ref: "https://oclif.io/docs/commands#thiserrormessage-string--error-options-code-string-exit-number",      suggestions: ["Use these extra properties to provide additional context"],    })  }}
would result with the following output:
›   Error: An error has occurred!›   Code: OCLIF_ERR›   Try this: Use these extra properties to provide additional context›   Reference: https://oclif.io/docs/commands#thiserrormessage-string--error-options-code-string-exit-number
If these properties are not provided then nothing changes and the CLI will continue to display the single error message output as it did before. Additionally, as part of this exercise we’ve added documentation around Error Handling in oclif which should come in handy if the need arises to extend oclif’s default handling of errors.Customizing Help in oclifMay 5, 2020 · 2 min readOut of the box oclif provides a great help experience for CLIs.
But what if, as an oclif developer, you want to customize some or all of the output?
You can now customize your CLI's help output by implementing the HelpBase abstract class.
Getting started with custom help​
If you have not done so yet, update @oclif/core.
$ yarn add --latest @oclif/core
To get started, first define the filepath to your help class in oclif's config in package.json. This is a relative path to the help class, without a file extension.
For this example, the help class will be created in a file at "[project root]/src/help.ts".
{  // ...  "oclif": {    "helpClass": "./lib/help"    // ...  }  // ...}
From here there are two paths, implement the HelpBase abstract class yourself or overwrite the parts of the default Help class you want to customize (ex: how command usage is displayed). We recommend the latter approach but cover both in the new Help Classes docs.
Separating TOPICS & COMMANDS in the new default Help class​
Previously, topics and child commands were listed in help output under a single list heading called "COMMANDS". But we found this can be slightly confusing. Some topics are commands also (a.k.a. topic-commands) while others are simply organizational namespacing (and when ran just show their help).
The new default Help class splits the list of children into distinct lists of "TOPICS" and "COMMANDS", with the possibility of an item appearing in both if it a topic-command. This makes it clearer what is expected to be ran - "COMMANDS" - and what is providing structure - "TOPICS" - when looking at the help output.
VERSION  plugin-help-example/0.0.0 darwin-x64 node-v12.12.0USAGE  $ plugin-help-example [COMMAND]TOPICS  topic  this is a topic and has child topics or commandsCOMMANDS  hello  describe the command here  help   display help for plugin-help-example
We look forward to seeing what custom help features you implement in your oclif CLIs with this new feature!oclif TSLint to ESLint MigrationDecember 5, 2019 · 3 min readBack in February of this year, plans were announced to deprecate TSLint in favor of ESLint. TSLint's goal has become to work toward a “unified developer experience” by supporting ESLint development going forward.
What has changed in oclif​
To keep inline with the community, oclif has transitioned to ESLint for all our core libraries as well as all our official plugins.
Starting in v1.15.x, oclif will now optionally generate projects with ESLint for both TypeScript and JavaScript CLI’s.
ESLint does require Node to be on stable LTS version, at the time of writing, Node 8.10.x, Node 10.13.x & Node 12.x.x.
How does this affect you​
Existing CLI’s are unchanged, but any newly generated CLI's will only give the option of using ESLint. If you are running tslint in your CLI, we recommend you switch to ESLint as well.
In migrating our projects we took the following steps (for an example of these changes see this pull request).


Install eslint
$ yarn add eslint eslint-config-oclif eslint-config-oclif-typescript --dev


Add eslint related files


$ echo '{  "extends": [    "oclif",    "oclif-typescript"  ],  "rules": {  }}' > .eslintrc


Remove tslint and related packages
$ yarn remove @oclif/tslint tslint


Remove tslint related configuration files
$ rm tslint.json


Change lint script in our package.json from something like:
"lint": "tsc -p test --noEmit && tslint -p test -t stylish"
to
"lint": "eslint . --ext .ts --config .eslintrc"


To preserve the test compile (tsc -p test --noEmit) we also made the following updates to our scripts:
"pretest": "tsc -p test --noEmit"
In some cases we had our posttest duplicating the same steps as our lint script so it’s cleaner to have it reference the lint job directly with:
"posttest": "yarn lint"

Run yarn lint --fix. This attempts to auto-fix any linting violations automatically. In the case an auto-fix isn’t available it should be fixed manually or ignored (see the eslint configuration doc for more information)
Do a search in the codebase for tslint and remove any unnecessary tslint disabling comments, like:

/* tslint:disable:object-literal-sort-keys */
If you are on a version of Node that is not supported by ESLint, you will also need to update your Node engine. ESLint supports Node 8, 10, and 12 so you should upgrade to the most recent Node version compatible with your CLI and also supported by ESLint (see ESLint's Installation and Usage instructions).
When will this take effect​
These changes have taken effect in oclif v1.15.1. When you generate a new CLI or plugin it will now contain configuration for ESLint instead of TSLint.oclif's Current Node SupportOctober 31, 2019 · 3 min readTo maintain a healthy project trajectory, oclif follows and supports Node Active LTS release, currently Node 10 & Node 12. This means ensuring that oclif continues to play nice with coming Active LTS Node versions and other packages in the ecosystem. Moving forward also means leaving older versions behind. Starting in 2020, Node will stop maintaining Node 8 and it is our intent at that time to also follow suit. Let’s take a look at a few ways we will be supporting these changes.
CI Environments​
CLIs created with the oclif cli going forward will be generated with a CircleCI configuration with Node 10 & 12 and an Appveyor configuration using Node 10. We have also added Node latest to CircleCi to be an early warning detection against coming Node changes (Node latest is managed by CircleCI).
We have already updated every oclif repo's CI configs to reflect this.
If your existing CLI uses either Appveyor or CircleCI you can update your config files also, like so:
.circleci/config.yml​
Your CircleCI config should contain a node-latest job, aliased as test. From this, there should be two extensions of this job for the Active LTS Node versions, Node 10 and Node 12.
  node-10:    <<: *node-latest    docker:      - image: node:10  node-12:    <<: *node-latest    docker:      - image: node:12
Notice that these declarations only change the Docker Node images used to run that job.
Additionally, the jobs listed within workflows must also be updated to reflect our changes in configuration:
    jobs:      - node-latest      - node-10      - node-12
appveyor.yml​
For appveyor we are currently only testing the oldest Active LTS Node version, Node 10. Update the nodejs_version proppert in your appveyor.yml file to reflect this.
environment:  nodejs_version: "10"
Deprecating Node 8 & Updating packge.json engines​
In Jan 2020, Node will end its Node 8 maintenance. We will follow suit by setting the package.json engine property in oclif packages to >=10 and bumping the package's major versions.
Depending on how you ship your CLI you may wish to also bump the engines version in your CLI's package.json. You can read more about the implications of the engines property configuration in the npm documentation.
Also consider distributing your CLI with its own Node version.
Packaged Node Version​
When using dev-cli to pack your CLI it will use the Node version as specified in your package.json under the oclif.update.node.version property. This value should reflect an Active LTS Node version (dev-cli does not currently enforce versions).
Supporting the future​
As a community we may discover bumps along the way as we upgrade. If you notice something related to oclif please feel free to open an issue or submit a pull request under the relevant oclif package within the org.
We look forward to using the latest from Node and the community and keeping oclif healthy along the way.oclifconf 2019: A RecapSeptember 16, 2019 · 4 min readIn May, Heroku and Salesforce Open Source organized oclifconf, a conference for developers & product managers building CLI tools on top of the open source oclif framework. The speakers came from various tech companies, such as Adobe, Netlify, and Apollo, who have already built amazing CLI experiences. The topics covered everything from the incredible capabilities oclif has unlocked, to the community-built plugins extending its functionality, and even what the behavior of an adaptive CLI tool might look like.
Below is a listing of all of the talks from the event, along with a short summary. Enjoy!
The future of oclif by Jeff Dickey​

In its relatively short lifetime, oclif has already inspired many developers and companies to adopt its framework as a means for implementing their own command-line tooling. In this talk, Jeff Dickey, an oclif founding team member, recaps the project's history and inspiration. He also looks towards the future and outlines some features and improvements that the tool could adapt. This isn't so much a definitive roadmap of where oclif is headed, but rather, a call to inspiration for developers eager to contribute! And if you are interested in contributing, check out the open issues in the oclif GitHub repo and come say "Hello!" on Spectrum Chat.
Open Source Citizenship by Josh Simmons​

When it comes to open source, it's more than just individuals now. More and more frequently, large corporations are contributing to projects by donating to contributors, sponsoring events, or upstreaming contributions. But keeping open source projects and communities healthy requires more than just money and brainpower. Josh Simmons surveyed multiple open source communities and relays his findings as to what help maintainers and contributors actually need in this talk.
Building an enterprise-grade CLI with oclif by Thomas Dvornik​

Security and performance are all about trust. While oclif is an extremely extensible framework for building CLI tooling, there are additional requirements to fulfill for enterprise businesses to adopt it that might not be necessary for individual developers. Thomas Dvornik outlines what he and his colleagues at Salesforce have implemented as plugins to oclif to satisfy these needs, including encrypted OAuth, plugin signing, lazy loading dependencies, synchronizing weekly releases and deprecations across dozens of repositories, and establishing cross-team coding and documentation standards.
How Adobe I/O built an extensible CLI with oclif by Jesse MacFadyen​

Perhaps oclif's most appealing feature is its support for plugins. In Cordova's case, they've created a sophisticated telemetry system that helps Adobe developers see which commands users are using--and reports on which ones are erroring out. By embedding a feedback system into the tool, users are even able to quickly send their suggestions to a form, without ever leaving the terminal. Jesse MacFadyen demonstrates how oclif's plugin system can work beyond simply executing commands.
Integrating oclif with GraphQL and Apollo by Evans Hauser​

For Evans Hauser and the team at Apollo, oclif is best thought of as "React for the CLI." As a client paired with a strongly-typed API contract to a server, it can deliver structured and consistent commands to retrieve external data. What better mechanism to use for this transfer than GraphQL, a framework which empowers the client to ask precisely for the data it needs, and nothing more?
Adaptive Intent-based CLI State Machines by Shawn Wang​

In designing oclif, Jeff Dickey wrote out 12 CLI factors to keep in mind. In this talk, Shawn Wang outlines a 13th: state. State is hard, because it depends on context, and context depends on understanding what a user intends to do, not what they are asking. Shawn is working towards enabling oclif to better understand the commands a user has entered, so that it can predict and interpret future commands that might be entered next. This would enable CLI tools to not just interpret a users' commands, but to also interpret their intent.\n\nIntroducing `oclif init` commandApril 10, 2024 · 2 min readThanks to the contribution of @joshcanhelp we released a new command for the oclif CLI called oclif init in version 4.8.0
The oclif init command allows you to initialize oclif in an existing project directory by adding the bare minimum requirements: a few pieces of configuration, bin scripts, and a couple of dependencies (@oclif/core and ts-node). This is slightly different from oclif generate, which will create an entirely new oclif project based on our templates.
oclif init will add the following:

bin scripts: bin/run.js, bin/run.cmd, bin/dev.js, and bin/dev.cmd
oclif section to package.json with bin, dirname, commands, and topicSeparator set (See Configuring Your CLI for more)
@oclif/core to dependencies in your package.json (if it's not already there)
ts-node to devDependencies in your package.json (if it's not already there)

Once you've initialized oclif, you can use the bin scripts to execute your CLI. You can also use the other oclif commands like oclif generate command and oclif generate hook to start adding new functionality.

❯ oclif init --helpInitialize a new oclif CLIUSAGE  $ oclif init [--bin <value>] [--module-type ESM|CommonJS] [--package-manager npm|yarn|pnpm] [--topic-separator    colons|spaces] [-d <value>] [-y]FLAGS  -d, --output-dir=<value>        Directory to initialize the CLI in.  -y, --yes                       Use defaults for all prompts. Individual flags will override defaults.      --bin=<value>               Supply answer for prompt: Command bin name the CLI will export      --module-type=<option>      Supply answer for prompt: Select a module type                                  <options: ESM|CommonJS>      --package-manager=<option>  Supply answer for prompt: Select a package manager                                  <options: npm|yarn|pnpm>      --topic-separator=<option>  Supply answer for prompt: Select a topic separator                                  <options: colons|spaces>DESCRIPTION  Initialize a new oclif CLI  This will add the necessary oclif bin files, add oclif config to package.json, and install @oclif/core and ts-node.EXAMPLES  Initialize a new CLI in the current directory    $ oclif init  Initialize a new CLI in a different directory    $ oclif init --output-dir "/path/to/existing/project"  Supply answers for specific prompts    $ oclif init --topic-separator colons --bin mycli
Hope you enjoy the new command! If you come across any issues or have any new ideas for this command, head over to the oclif/oclif repo and open a new issue.
All our best,
The oclif teamoclif Spring 2024 UpdateMarch 29, 2024 · 4 min readHello oclif developers! It's been a while since we last uploaded a blog - and a lot has happened.
We've been focusing on these high-level areas over the past couple of years:

Improving @oclif/core
ESM Support
Improving and revitalizing oclif.io
Re-engaging the oclif community

Improving @oclif/core​
Since we announced @oclif/core over three years ago, we've released two new major versions, each packed with lots of features that we're really excited about.
Here are some of these changes:

Full support for ESM and interoperability with CommonJS (more on this topic below).
Configurable command discovery strategies that give you more control over how commands are loaded at runtime. Check out the docs.
A new preparse hook that allows you to manipulate the provided arguments before they're parsed. Salesforce used this hook to implement a neat --flags-dir feature that translates local files into flags.
A new Performance class that you can use to track performance inside of @oclif/core and your own CLI or plugin. Check out the docs.
A new flag type, Flags.option, that lets you define a flag with a preset list of options. Typescript then uses the options to infer the flag's type.
Flags now have a relationship property that allows you to define more complex relationships between flags. Check out the flags docs for more information.
Flags now have a defaultHelp property that allows you to set the human readable default value in the command help. This property is useful when your flag's parse method returns a complex type, such as an object or a class. Check out the flags docs for more.
Commands now have a hiddenAliases property that allows you to define aliases that you want to hide from the user. The property is super helpful when you're trying to wean users off a deprecated command.
You can now use bun or tsx as dev runtimes (as opposed to node or ts-node).
A command's usage, args, and flags are now shown whenever a user forgets to provide a required arg or flag, or when they provided a non-existent flag.

If you need help migrating to the latest version, head over to core's README which has links to the migration guides. Feel free to open a new discussion if you need more hands-on help from us or the community.
ESM Support​
Version 3 of @oclif/core introduced full support for developing ESM plugins and CLIs. It also offered full support for interoperability between CommonJS and ESM plugins.
Put more simply, you can now migrate your CLI to ESM while keeping individual plugins in CommonJS (or vice versa). The upgrade path is now much simpler for you. You also don't need to worry about any community plugins that have migrated to ESM before you did (such as all the @oclif plugins) or are staunchly sticking with CommonJS for the foreseeable future.
Read more about this topic here.
Improving and Revitalizing oclif.io​
Another area of focus for us has been improving our documentation site, oclif.io.
While improving the quality and accuracy of the documentation was our priority, we also took the time to upgrade to the latest version of docusaurus. This new version gave our site a much-needed facelift, as well as cool new features such as dark mode and announcements.
If you have any feedback or are running into issues, we want to hear about it. Just create an issue in the oclif.io repo.
Re-engaging the oclif Community​
Lastly, our biggest priority at the moment is to re-engage the oclif community. We understand how frustrating it has been over the years to see your issues and pull requests go unacknowledged. We apologize for not prioritizing the community, and are earnestly trying to make sure that every issue and pull request gets the attention it deserves going forward.
We also opened up GitHub discussions for @oclif/core and the oclif CLI, where you can now post your questions or ideas. We hope you take advantage of them, we love hearing from you!
One last thing: we intend to publicly post our roadmap so you have more visibility into what we're working on. Stay tuned!
All our best,
The oclif teamAnnouncing oclif v2!January 12, 2022 · 5 min readHello and happy new year! It's our great pleasure to announce that we have released oclif v2, which uses the new @oclif/core library! 🎉
oclif v2 includes many changes that improve the experience of both creating and using an oclif CLI.
Going forward, we don't plan to make any updates to oclif v1 and its corresponding libraries, except for critical security fixes. See the compatibility matrix for a list of these libraries. In order to give developers time to migrate from v1 to v2, we're not completely dropping support yet. But at some point in the future we'll archive the v1 repositories and deprecate their versions on npm.
What’s changing?​
Repository Changes​
All repositories under the oclif org now use main as their primary branch and oclif-v1 as the legacy branch. The main  branch corresponds to oclif v2 and the oclif-v1 branch to oclif v1. If you find any repos that don’t have a main branch, you can safely assume that they're not used in oclif v2 and will be deprecated in the future.
Consolidating Tools & Libraries​
The oclif-dev CLI has now been incorporated into oclif. You now no longer need to install a separate package to manage your entire CLI’s lifecycle.
The following libraries have been consolidated under @oclif/core and will be deprecated at some point in the future. Read the migration guide to learn how to update your CLI or plugin to use the new core library.

@oclif/command
@oclif/config
@oclif/error
@oclif/help
@oclif/parser

No more single vs multi command CLIs​
There's only one "type" of oclif v2 CLI, but it can have as few or as many commands as a developer wants. As a result, there’s only one command to generate CLIs, oclif generate, as opposed to the old oclif single and oclif multi commands.
Node > 12​
To ensure oclif CLIs are as secure as possible, all v2 libraries and plugins support only Node 12 or higher as of now. Going forward, they'll support only Node Maintenance or higher, as defined by Node's release schedule here: https://nodejs.org/en/about/releases/.
What’s new?​
New example CLI​
oclif-hello-world is our new example repo. This is also the repo that's used as a template when running oclif generate to create a new CLI. This repo will always be able to be referenced as an example of what an oclif v2 CLI should look like.
Spaced commands​
oclif CLIs can now use spaces, instead of colons, to separate topics and subcommands. To enable this feature, simply add “topicSeparator": " " to the oclif config in your package.json. See an example in our example repo.
// Old commands that use :$ mycli do:something
// New spaced commands$ mycli do something

Note: Spaced commands are backwards compatible. So if you enable spaced commands for your CLI, users will still be able to use : as a separator. This ensures that any existing scripts don't break.

New Help Output​
We’ve revamped the way command help is outputted to the terminal, making it both easier to implement and easier to read. See the difference between the old help output on the left and the new help output on the right in the screenshots below.
oclif v1oclif v2
Notice that there are new sections for flags and global flags, examples are displayed with better spacing, and there is a section at the bottom called Configuration Variables. This Configuration Variables section is not part of the new help by default. But we've added support for custom help sections, which is what the sf CLI uses to create the new section.
Async Command Parsing​
We’ve also improved the performance of new CLIs by rewriting how commands are parsed on initialization. The new parser is asynchronous, which makes CLIs with a lot of commands or installed  plugins much faster.
What’s coming next?​
Part of our charter for the release of oclif v2 includes improving our engagement with the oclif community. We know that over the past couple of years we’ve reduced our involvement, and a lot of issues and PRs have languished in limbo. Hopefully you’ve already seen increased activity and responses from oclif maintainers recently, but if you haven’t, please don’t hesitate to ping us by tagging @admins in oclif repos.
We also want to start interviewing members of the oclif community to acquire feedback and prioritize the features and fixes you deem most important!
Best,
The oclif team

Reference material​
Migration Guide​
This guide explains how to upgrade a CLI or plugin from the old oclif v1 libraries to the new @oclif/core library that oclif v2 uses.
https://github.com/oclif/core/blob/main/MIGRATION.md
Compatibility Matrix​
The following matrix shows how the v1 libraries and plugins relate to the new v2 ones. Use this matrix as a guide to know what to drop and which versions to switch when upgrading your plugins and CLIs to v2.
oclif "v1"oclif "v2"Utility CLIsoclif@<2@oclif/dev-cli@<2oclif@>=2Main packages@oclif/command@oclif/config@oclif/errors@oclif/parser@oclif/plugin-help@oclif/core@>=1Node LTSNode v8-14Node v12+ (at time of writing)TypeScripttypescript@<4typescript@>=4Main plugins@oclif/plugin-autocomplete@<1@oclif/plugin-commands@<2@oclif/plugin-help@<4@oclif/plugin-not-found@<2@oclif/plugin-plugins@<2@oclif/plugin-update@<2plugin-warn-if-update-available@<2plugin-which@<2@oclif/plugin-autocomplete@>=1@oclif/plugin-commands@>=2@oclif/plugin-help@>=4@oclif/plugin-not-found@>=2@oclif/plugin-plugins@>=2@oclif/plugin-update@>=2@oclif/plugin-warn-if-update-available@>=2@oclif/plugin-which@>=2Introducing @oclif/coreMarch 1, 2021 · 3 min readGreetings!
We hope this blog post finds you well.
Introducing...​
We are excited to announce the next iteration of the oclif project today: @oclif/core.
We have learned a lot in the last three years of developing oclif, developing on oclif and supporting millions of command runs a day via Heroku and Salesforce CLIs.
@oclif/core ("Core") simplifies the oclif development experience and introduces highly requested new features.
Core combines the essential oclif packages into one "core" package, aptly named @oclif/core.
Core also introduces:

A default command option
Colon or space command syntax
Async command parsing
Command piping to arguments

With the introduction of default command functionality, Core simplifies the oclif project and removes the notion of single or multi command CLIs. Core CLIs can have 1 or many commands.
Along with Core, we moved the oclif-dev CLI into the oclif CLI creating a single "utility" CLI. This CLI also introduces a new AWS S3 compatible publishing scheme.
What to expect in the near future​
Core is in pre-release beta and being actively developed for new internal Salesforce CLIs.
Much documentation needs to be written in the coming months including migration paths. Migration onto Core should be as painless as possible with many exports remaining entirely unchanged. Look for forthcoming blog posts and documentation on oclif.io.
Early this summer, tentively June 1, we will release Core v1. Core's release will coincide with major bumps to many other oclif plugin packages. See the compatibility matrix below.
At Core's v1 release, the current "main" oclif packages (namely: command, config, errors & parser) will go into maintenance mode until Jan 2022. They will receive only bug and security fixes and they remain compatible with current versions of the oclif and oclif-dev CLIs. Afterwhich, they will be archived.
Companioning Core, the next major release of the oclif CLI (literally oclif@2) will generate Core CLIs.
Going forward​
We are excited to release Core! We invite you to poke around the Core repo. It may appear to be a big change but Core keeps what you already enjoy about oclif while reducing development complexity, project dependencies, package coupling and bundle size and introduces many requested features previously too prickly to weave into the current oclif architecture.
Best,
The oclif team
Reference: Compatibility matrix​
oclif "v1"oclif "Core"Utility CLIsoclif@<2@oclif/dev-cli@<2oclif@>=2Main packages@oclif/core@<2@oclif/config@<2@oclif/errors@<2@oclif/parser@<4@oclif/plugin-help@<4@oclif/core@>=1Node LTSNode v8-14Node v12+TypeScripttypescript@<4typescript@>=4Main plugins@oclif/plugin-autocomplete@<1@oclif/plugin-commands@<2@oclif/plugin-help@<4@oclif/plugin-not-found@<2@oclif/plugin-plugins@<2@oclif/plugin-update@<2plugin-warn-if-update-available@<2plugin-which@<2@oclif/plugin-autocomplete@>=2@oclif/plugin-commands@>=2@oclif/plugin-help@>=4@oclif/plugin-not-found@>=2@oclif/plugin-plugins@>=2@oclif/plugin-update@>=2@oclif/plugin-warn-if-update-available@>=2@oclif/plugin-which@>=2oclif Summer 2020 UpdateAugust 26, 2020 · 2 min readHello oclif developers! We hope you are all doing well.
Earlier this year, we started our planning for oclifconf v2 and, like all conference, had to change course. We opted not to hold a virtual conference, however, we wanted to take some time to highlight a few oclif features shipped this year.
Feature: Help templating​
One of the most requested features, help templating enables oclif developers to customize the help output for their CLI.
Read the announcement.
Feature: Custom error delegation​
This feature both improved how oclif throws and handles errors and allows oclif developers to overwrite or interject in oclif’s error handling.
Read the announcement.
Feature: postrun hooks​
We have added a new lifecycle event postrun. Your CLI can now run a hook after a command has ran.
See our hook documentation.
Feature: Root index command​
Previously, oclif would display CLI help if only the binary name with no command ID was invoked, oclif now supports a "root index" command. If present, a command defined at src/commands/index.ts will be run if no command ID is found.
1 million weekly downloads​
While exact oclif usage metrics are hard to pin down, we use npm download statistics of oclif packages as a rough approximation. Earlier this year, oclif's command package hit 1 million weekly downloads for the first time!
This year has been presented its challenges on everyone. We want to thank you, oclif developers, whom have taken the time to use and improve the oclif project. We look forward to seeing you all - in person - in the future!
All our best,
The oclif teamPretty Printable ErrorsJuly 1, 2020 · One min readOften CLIs are used as handy tools and when things go wrong it’s useful to have additional context. In oclif we have added a couple of additional properties that can show extra context to the users when an error is displayed. The code, ref and suggestions will now be displayed if they are included. This will work with an existing oclif CLI by adding the latest @oclif/errors and @oclif/core to the CLI's package.json dependencies.
For example, using this.error with the additional properties:
class TestError extends Command {  async run() {    this.error("An error has occurred!", {      code: "OCLIF_ERR",      ref: "https://oclif.io/docs/commands#thiserrormessage-string--error-options-code-string-exit-number",      suggestions: ["Use these extra properties to provide additional context"],    })  }}
would result with the following output:
›   Error: An error has occurred!›   Code: OCLIF_ERR›   Try this: Use these extra properties to provide additional context›   Reference: https://oclif.io/docs/commands#thiserrormessage-string--error-options-code-string-exit-number
If these properties are not provided then nothing changes and the CLI will continue to display the single error message output as it did before. Additionally, as part of this exercise we’ve added documentation around Error Handling in oclif which should come in handy if the need arises to extend oclif’s default handling of errors.Customizing Help in oclifMay 5, 2020 · 2 min readOut of the box oclif provides a great help experience for CLIs.
But what if, as an oclif developer, you want to customize some or all of the output?
You can now customize your CLI's help output by implementing the HelpBase abstract class.
Getting started with custom help​
If you have not done so yet, update @oclif/core.
$ yarn add --latest @oclif/core
To get started, first define the filepath to your help class in oclif's config in package.json. This is a relative path to the help class, without a file extension.
For this example, the help class will be created in a file at "[project root]/src/help.ts".
{  // ...  "oclif": {    "helpClass": "./lib/help"    // ...  }  // ...}
From here there are two paths, implement the HelpBase abstract class yourself or overwrite the parts of the default Help class you want to customize (ex: how command usage is displayed). We recommend the latter approach but cover both in the new Help Classes docs.
Separating TOPICS & COMMANDS in the new default Help class​
Previously, topics and child commands were listed in help output under a single list heading called "COMMANDS". But we found this can be slightly confusing. Some topics are commands also (a.k.a. topic-commands) while others are simply organizational namespacing (and when ran just show their help).
The new default Help class splits the list of children into distinct lists of "TOPICS" and "COMMANDS", with the possibility of an item appearing in both if it a topic-command. This makes it clearer what is expected to be ran - "COMMANDS" - and what is providing structure - "TOPICS" - when looking at the help output.
VERSION  plugin-help-example/0.0.0 darwin-x64 node-v12.12.0USAGE  $ plugin-help-example [COMMAND]TOPICS  topic  this is a topic and has child topics or commandsCOMMANDS  hello  describe the command here  help   display help for plugin-help-example
We look forward to seeing what custom help features you implement in your oclif CLIs with this new feature!oclif TSLint to ESLint MigrationDecember 5, 2019 · 3 min readBack in February of this year, plans were announced to deprecate TSLint in favor of ESLint. TSLint's goal has become to work toward a “unified developer experience” by supporting ESLint development going forward.
What has changed in oclif​
To keep inline with the community, oclif has transitioned to ESLint for all our core libraries as well as all our official plugins.
Starting in v1.15.x, oclif will now optionally generate projects with ESLint for both TypeScript and JavaScript CLI’s.
ESLint does require Node to be on stable LTS version, at the time of writing, Node 8.10.x, Node 10.13.x & Node 12.x.x.
How does this affect you​
Existing CLI’s are unchanged, but any newly generated CLI's will only give the option of using ESLint. If you are running tslint in your CLI, we recommend you switch to ESLint as well.
In migrating our projects we took the following steps (for an example of these changes see this pull request).


Install eslint
$ yarn add eslint eslint-config-oclif eslint-config-oclif-typescript --dev


Add eslint related files


$ echo '{  "extends": [    "oclif",    "oclif-typescript"  ],  "rules": {  }}' > .eslintrc


Remove tslint and related packages
$ yarn remove @oclif/tslint tslint


Remove tslint related configuration files
$ rm tslint.json


Change lint script in our package.json from something like:
"lint": "tsc -p test --noEmit && tslint -p test -t stylish"
to
"lint": "eslint . --ext .ts --config .eslintrc"


To preserve the test compile (tsc -p test --noEmit) we also made the following updates to our scripts:
"pretest": "tsc -p test --noEmit"
In some cases we had our posttest duplicating the same steps as our lint script so it’s cleaner to have it reference the lint job directly with:
"posttest": "yarn lint"

Run yarn lint --fix. This attempts to auto-fix any linting violations automatically. In the case an auto-fix isn’t available it should be fixed manually or ignored (see the eslint configuration doc for more information)
Do a search in the codebase for tslint and remove any unnecessary tslint disabling comments, like:

/* tslint:disable:object-literal-sort-keys */
If you are on a version of Node that is not supported by ESLint, you will also need to update your Node engine. ESLint supports Node 8, 10, and 12 so you should upgrade to the most recent Node version compatible with your CLI and also supported by ESLint (see ESLint's Installation and Usage instructions).
When will this take effect​
These changes have taken effect in oclif v1.15.1. When you generate a new CLI or plugin it will now contain configuration for ESLint instead of TSLint.oclif's Current Node SupportOctober 31, 2019 · 3 min readTo maintain a healthy project trajectory, oclif follows and supports Node Active LTS release, currently Node 10 & Node 12. This means ensuring that oclif continues to play nice with coming Active LTS Node versions and other packages in the ecosystem. Moving forward also means leaving older versions behind. Starting in 2020, Node will stop maintaining Node 8 and it is our intent at that time to also follow suit. Let’s take a look at a few ways we will be supporting these changes.
CI Environments​
CLIs created with the oclif cli going forward will be generated with a CircleCI configuration with Node 10 & 12 and an Appveyor configuration using Node 10. We have also added Node latest to CircleCi to be an early warning detection against coming Node changes (Node latest is managed by CircleCI).
We have already updated every oclif repo's CI configs to reflect this.
If your existing CLI uses either Appveyor or CircleCI you can update your config files also, like so:
.circleci/config.yml​
Your CircleCI config should contain a node-latest job, aliased as test. From this, there should be two extensions of this job for the Active LTS Node versions, Node 10 and Node 12.
  node-10:    <<: *node-latest    docker:      - image: node:10  node-12:    <<: *node-latest    docker:      - image: node:12
Notice that these declarations only change the Docker Node images used to run that job.
Additionally, the jobs listed within workflows must also be updated to reflect our changes in configuration:
    jobs:      - node-latest      - node-10      - node-12
appveyor.yml​
For appveyor we are currently only testing the oldest Active LTS Node version, Node 10. Update the nodejs_version proppert in your appveyor.yml file to reflect this.
environment:  nodejs_version: "10"
Deprecating Node 8 & Updating packge.json engines​
In Jan 2020, Node will end its Node 8 maintenance. We will follow suit by setting the package.json engine property in oclif packages to >=10 and bumping the package's major versions.
Depending on how you ship your CLI you may wish to also bump the engines version in your CLI's package.json. You can read more about the implications of the engines property configuration in the npm documentation.
Also consider distributing your CLI with its own Node version.
Packaged Node Version​
When using dev-cli to pack your CLI it will use the Node version as specified in your package.json under the oclif.update.node.version property. This value should reflect an Active LTS Node version (dev-cli does not currently enforce versions).
Supporting the future​
As a community we may discover bumps along the way as we upgrade. If you notice something related to oclif please feel free to open an issue or submit a pull request under the relevant oclif package within the org.
We look forward to using the latest from Node and the community and keeping oclif healthy along the way.oclifconf 2019: A RecapSeptember 16, 2019 · 4 min readIn May, Heroku and Salesforce Open Source organized oclifconf, a conference for developers & product managers building CLI tools on top of the open source oclif framework. The speakers came from various tech companies, such as Adobe, Netlify, and Apollo, who have already built amazing CLI experiences. The topics covered everything from the incredible capabilities oclif has unlocked, to the community-built plugins extending its functionality, and even what the behavior of an adaptive CLI tool might look like.
Below is a listing of all of the talks from the event, along with a short summary. Enjoy!
The future of oclif by Jeff Dickey​

In its relatively short lifetime, oclif has already inspired many developers and companies to adopt its framework as a means for implementing their own command-line tooling. In this talk, Jeff Dickey, an oclif founding team member, recaps the project's history and inspiration. He also looks towards the future and outlines some features and improvements that the tool could adapt. This isn't so much a definitive roadmap of where oclif is headed, but rather, a call to inspiration for developers eager to contribute! And if you are interested in contributing, check out the open issues in the oclif GitHub repo and come say "Hello!" on Spectrum Chat.
Open Source Citizenship by Josh Simmons​

When it comes to open source, it's more than just individuals now. More and more frequently, large corporations are contributing to projects by donating to contributors, sponsoring events, or upstreaming contributions. But keeping open source projects and communities healthy requires more than just money and brainpower. Josh Simmons surveyed multiple open source communities and relays his findings as to what help maintainers and contributors actually need in this talk.
Building an enterprise-grade CLI with oclif by Thomas Dvornik​

Security and performance are all about trust. While oclif is an extremely extensible framework for building CLI tooling, there are additional requirements to fulfill for enterprise businesses to adopt it that might not be necessary for individual developers. Thomas Dvornik outlines what he and his colleagues at Salesforce have implemented as plugins to oclif to satisfy these needs, including encrypted OAuth, plugin signing, lazy loading dependencies, synchronizing weekly releases and deprecations across dozens of repositories, and establishing cross-team coding and documentation standards.
How Adobe I/O built an extensible CLI with oclif by Jesse MacFadyen​

Perhaps oclif's most appealing feature is its support for plugins. In Cordova's case, they've created a sophisticated telemetry system that helps Adobe developers see which commands users are using--and reports on which ones are erroring out. By embedding a feedback system into the tool, users are even able to quickly send their suggestions to a form, without ever leaving the terminal. Jesse MacFadyen demonstrates how oclif's plugin system can work beyond simply executing commands.
Integrating oclif with GraphQL and Apollo by Evans Hauser​

For Evans Hauser and the team at Apollo, oclif is best thought of as "React for the CLI." As a client paired with a strongly-typed API contract to a server, it can deliver structured and consistent commands to retrieve external data. What better mechanism to use for this transfer than GraphQL, a framework which empowers the client to ask precisely for the data it needs, and nothing more?
Adaptive Intent-based CLI State Machines by Shawn Wang​

In designing oclif, Jeff Dickey wrote out 12 CLI factors to keep in mind. In this talk, Shawn Wang outlines a 13th: state. State is hard, because it depends on context, and context depends on understanding what a user intends to do, not what they are asking. Shawn is working towards enabling oclif to better understand the commands a user has entered, so that it can predict and interpret future commands that might be entered next. This would enable CLI tools to not just interpret a users' commands, but to also interpret their intent.Older Entries\n\n\n\nIntroducing `oclif init` commandApril 10, 2024 · 2 min readThanks to the contribution of @joshcanhelp we released a new command for the oclif CLI called oclif init in version 4.8.0
The oclif init command allows you to initialize oclif in an existing project directory by adding the bare minimum requirements: a few pieces of configuration, bin scripts, and a couple of dependencies (@oclif/core and ts-node). This is slightly different from oclif generate, which will create an entirely new oclif project based on our templates.
oclif init will add the following:

bin scripts: bin/run.js, bin/run.cmd, bin/dev.js, and bin/dev.cmd
oclif section to package.json with bin, dirname, commands, and topicSeparator set (See Configuring Your CLI for more)
@oclif/core to dependencies in your package.json (if it's not already there)
ts-node to devDependencies in your package.json (if it's not already there)

Once you've initialized oclif, you can use the bin scripts to execute your CLI. You can also use the other oclif commands like oclif generate command and oclif generate hook to start adding new functionality.

❯ oclif init --helpInitialize a new oclif CLIUSAGE  $ oclif init [--bin <value>] [--module-type ESM|CommonJS] [--package-manager npm|yarn|pnpm] [--topic-separator    colons|spaces] [-d <value>] [-y]FLAGS  -d, --output-dir=<value>        Directory to initialize the CLI in.  -y, --yes                       Use defaults for all prompts. Individual flags will override defaults.      --bin=<value>               Supply answer for prompt: Command bin name the CLI will export      --module-type=<option>      Supply answer for prompt: Select a module type                                  <options: ESM|CommonJS>      --package-manager=<option>  Supply answer for prompt: Select a package manager                                  <options: npm|yarn|pnpm>      --topic-separator=<option>  Supply answer for prompt: Select a topic separator                                  <options: colons|spaces>DESCRIPTION  Initialize a new oclif CLI  This will add the necessary oclif bin files, add oclif config to package.json, and install @oclif/core and ts-node.EXAMPLES  Initialize a new CLI in the current directory    $ oclif init  Initialize a new CLI in a different directory    $ oclif init --output-dir "/path/to/existing/project"  Supply answers for specific prompts    $ oclif init --topic-separator colons --bin mycli
Hope you enjoy the new command! If you come across any issues or have any new ideas for this command, head over to the oclif/oclif repo and open a new issue.
All our best,
The oclif teamoclif Spring 2024 UpdateMarch 29, 2024 · 4 min readHello oclif developers! It's been a while since we last uploaded a blog - and a lot has happened.
We've been focusing on these high-level areas over the past couple of years:

Improving @oclif/core
ESM Support
Improving and revitalizing oclif.io
Re-engaging the oclif community

Improving @oclif/core​
Since we announced @oclif/core over three years ago, we've released two new major versions, each packed with lots of features that we're really excited about.
Here are some of these changes:

Full support for ESM and interoperability with CommonJS (more on this topic below).
Configurable command discovery strategies that give you more control over how commands are loaded at runtime. Check out the docs.
A new preparse hook that allows you to manipulate the provided arguments before they're parsed. Salesforce used this hook to implement a neat --flags-dir feature that translates local files into flags.
A new Performance class that you can use to track performance inside of @oclif/core and your own CLI or plugin. Check out the docs.
A new flag type, Flags.option, that lets you define a flag with a preset list of options. Typescript then uses the options to infer the flag's type.
Flags now have a relationship property that allows you to define more complex relationships between flags. Check out the flags docs for more information.
Flags now have a defaultHelp property that allows you to set the human readable default value in the command help. This property is useful when your flag's parse method returns a complex type, such as an object or a class. Check out the flags docs for more.
Commands now have a hiddenAliases property that allows you to define aliases that you want to hide from the user. The property is super helpful when you're trying to wean users off a deprecated command.
You can now use bun or tsx as dev runtimes (as opposed to node or ts-node).
A command's usage, args, and flags are now shown whenever a user forgets to provide a required arg or flag, or when they provided a non-existent flag.

If you need help migrating to the latest version, head over to core's README which has links to the migration guides. Feel free to open a new discussion if you need more hands-on help from us or the community.
ESM Support​
Version 3 of @oclif/core introduced full support for developing ESM plugins and CLIs. It also offered full support for interoperability between CommonJS and ESM plugins.
Put more simply, you can now migrate your CLI to ESM while keeping individual plugins in CommonJS (or vice versa). The upgrade path is now much simpler for you. You also don't need to worry about any community plugins that have migrated to ESM before you did (such as all the @oclif plugins) or are staunchly sticking with CommonJS for the foreseeable future.
Read more about this topic here.
Improving and Revitalizing oclif.io​
Another area of focus for us has been improving our documentation site, oclif.io.
While improving the quality and accuracy of the documentation was our priority, we also took the time to upgrade to the latest version of docusaurus. This new version gave our site a much-needed facelift, as well as cool new features such as dark mode and announcements.
If you have any feedback or are running into issues, we want to hear about it. Just create an issue in the oclif.io repo.
Re-engaging the oclif Community​
Lastly, our biggest priority at the moment is to re-engage the oclif community. We understand how frustrating it has been over the years to see your issues and pull requests go unacknowledged. We apologize for not prioritizing the community, and are earnestly trying to make sure that every issue and pull request gets the attention it deserves going forward.
We also opened up GitHub discussions for @oclif/core and the oclif CLI, where you can now post your questions or ideas. We hope you take advantage of them, we love hearing from you!
One last thing: we intend to publicly post our roadmap so you have more visibility into what we're working on. Stay tuned!
All our best,
The oclif teamAnnouncing oclif v2!January 12, 2022 · 5 min readHello and happy new year! It's our great pleasure to announce that we have released oclif v2, which uses the new @oclif/core library! 🎉
oclif v2 includes many changes that improve the experience of both creating and using an oclif CLI.
Going forward, we don't plan to make any updates to oclif v1 and its corresponding libraries, except for critical security fixes. See the compatibility matrix for a list of these libraries. In order to give developers time to migrate from v1 to v2, we're not completely dropping support yet. But at some point in the future we'll archive the v1 repositories and deprecate their versions on npm.
What’s changing?​
Repository Changes​
All repositories under the oclif org now use main as their primary branch and oclif-v1 as the legacy branch. The main  branch corresponds to oclif v2 and the oclif-v1 branch to oclif v1. If you find any repos that don’t have a main branch, you can safely assume that they're not used in oclif v2 and will be deprecated in the future.
Consolidating Tools & Libraries​
The oclif-dev CLI has now been incorporated into oclif. You now no longer need to install a separate package to manage your entire CLI’s lifecycle.
The following libraries have been consolidated under @oclif/core and will be deprecated at some point in the future. Read the migration guide to learn how to update your CLI or plugin to use the new core library.

@oclif/command
@oclif/config
@oclif/error
@oclif/help
@oclif/parser

No more single vs multi command CLIs​
There's only one "type" of oclif v2 CLI, but it can have as few or as many commands as a developer wants. As a result, there’s only one command to generate CLIs, oclif generate, as opposed to the old oclif single and oclif multi commands.
Node > 12​
To ensure oclif CLIs are as secure as possible, all v2 libraries and plugins support only Node 12 or higher as of now. Going forward, they'll support only Node Maintenance or higher, as defined by Node's release schedule here: https://nodejs.org/en/about/releases/.
What’s new?​
New example CLI​
oclif-hello-world is our new example repo. This is also the repo that's used as a template when running oclif generate to create a new CLI. This repo will always be able to be referenced as an example of what an oclif v2 CLI should look like.
Spaced commands​
oclif CLIs can now use spaces, instead of colons, to separate topics and subcommands. To enable this feature, simply add “topicSeparator": " " to the oclif config in your package.json. See an example in our example repo.
// Old commands that use :$ mycli do:something
// New spaced commands$ mycli do something

Note: Spaced commands are backwards compatible. So if you enable spaced commands for your CLI, users will still be able to use : as a separator. This ensures that any existing scripts don't break.

New Help Output​
We’ve revamped the way command help is outputted to the terminal, making it both easier to implement and easier to read. See the difference between the old help output on the left and the new help output on the right in the screenshots below.
oclif v1oclif v2
Notice that there are new sections for flags and global flags, examples are displayed with better spacing, and there is a section at the bottom called Configuration Variables. This Configuration Variables section is not part of the new help by default. But we've added support for custom help sections, which is what the sf CLI uses to create the new section.
Async Command Parsing​
We’ve also improved the performance of new CLIs by rewriting how commands are parsed on initialization. The new parser is asynchronous, which makes CLIs with a lot of commands or installed  plugins much faster.
What’s coming next?​
Part of our charter for the release of oclif v2 includes improving our engagement with the oclif community. We know that over the past couple of years we’ve reduced our involvement, and a lot of issues and PRs have languished in limbo. Hopefully you’ve already seen increased activity and responses from oclif maintainers recently, but if you haven’t, please don’t hesitate to ping us by tagging @admins in oclif repos.
We also want to start interviewing members of the oclif community to acquire feedback and prioritize the features and fixes you deem most important!
Best,
The oclif team

Reference material​
Migration Guide​
This guide explains how to upgrade a CLI or plugin from the old oclif v1 libraries to the new @oclif/core library that oclif v2 uses.
https://github.com/oclif/core/blob/main/MIGRATION.md
Compatibility Matrix​
The following matrix shows how the v1 libraries and plugins relate to the new v2 ones. Use this matrix as a guide to know what to drop and which versions to switch when upgrading your plugins and CLIs to v2.
oclif "v1"oclif "v2"Utility CLIsoclif@<2@oclif/dev-cli@<2oclif@>=2Main packages@oclif/command@oclif/config@oclif/errors@oclif/parser@oclif/plugin-help@oclif/core@>=1Node LTSNode v8-14Node v12+ (at time of writing)TypeScripttypescript@<4typescript@>=4Main plugins@oclif/plugin-autocomplete@<1@oclif/plugin-commands@<2@oclif/plugin-help@<4@oclif/plugin-not-found@<2@oclif/plugin-plugins@<2@oclif/plugin-update@<2plugin-warn-if-update-available@<2plugin-which@<2@oclif/plugin-autocomplete@>=1@oclif/plugin-commands@>=2@oclif/plugin-help@>=4@oclif/plugin-not-found@>=2@oclif/plugin-plugins@>=2@oclif/plugin-update@>=2@oclif/plugin-warn-if-update-available@>=2@oclif/plugin-which@>=2Introducing @oclif/coreMarch 1, 2021 · 3 min readGreetings!
We hope this blog post finds you well.
Introducing...​
We are excited to announce the next iteration of the oclif project today: @oclif/core.
We have learned a lot in the last three years of developing oclif, developing on oclif and supporting millions of command runs a day via Heroku and Salesforce CLIs.
@oclif/core ("Core") simplifies the oclif development experience and introduces highly requested new features.
Core combines the essential oclif packages into one "core" package, aptly named @oclif/core.
Core also introduces:

A default command option
Colon or space command syntax
Async command parsing
Command piping to arguments

With the introduction of default command functionality, Core simplifies the oclif project and removes the notion of single or multi command CLIs. Core CLIs can have 1 or many commands.
Along with Core, we moved the oclif-dev CLI into the oclif CLI creating a single "utility" CLI. This CLI also introduces a new AWS S3 compatible publishing scheme.
What to expect in the near future​
Core is in pre-release beta and being actively developed for new internal Salesforce CLIs.
Much documentation needs to be written in the coming months including migration paths. Migration onto Core should be as painless as possible with many exports remaining entirely unchanged. Look for forthcoming blog posts and documentation on oclif.io.
Early this summer, tentively June 1, we will release Core v1. Core's release will coincide with major bumps to many other oclif plugin packages. See the compatibility matrix below.
At Core's v1 release, the current "main" oclif packages (namely: command, config, errors & parser) will go into maintenance mode until Jan 2022. They will receive only bug and security fixes and they remain compatible with current versions of the oclif and oclif-dev CLIs. Afterwhich, they will be archived.
Companioning Core, the next major release of the oclif CLI (literally oclif@2) will generate Core CLIs.
Going forward​
We are excited to release Core! We invite you to poke around the Core repo. It may appear to be a big change but Core keeps what you already enjoy about oclif while reducing development complexity, project dependencies, package coupling and bundle size and introduces many requested features previously too prickly to weave into the current oclif architecture.
Best,
The oclif team
Reference: Compatibility matrix​
oclif "v1"oclif "Core"Utility CLIsoclif@<2@oclif/dev-cli@<2oclif@>=2Main packages@oclif/core@<2@oclif/config@<2@oclif/errors@<2@oclif/parser@<4@oclif/plugin-help@<4@oclif/core@>=1Node LTSNode v8-14Node v12+TypeScripttypescript@<4typescript@>=4Main plugins@oclif/plugin-autocomplete@<1@oclif/plugin-commands@<2@oclif/plugin-help@<4@oclif/plugin-not-found@<2@oclif/plugin-plugins@<2@oclif/plugin-update@<2plugin-warn-if-update-available@<2plugin-which@<2@oclif/plugin-autocomplete@>=2@oclif/plugin-commands@>=2@oclif/plugin-help@>=4@oclif/plugin-not-found@>=2@oclif/plugin-plugins@>=2@oclif/plugin-update@>=2@oclif/plugin-warn-if-update-available@>=2@oclif/plugin-which@>=2oclif Summer 2020 UpdateAugust 26, 2020 · 2 min readHello oclif developers! We hope you are all doing well.
Earlier this year, we started our planning for oclifconf v2 and, like all conference, had to change course. We opted not to hold a virtual conference, however, we wanted to take some time to highlight a few oclif features shipped this year.
Feature: Help templating​
One of the most requested features, help templating enables oclif developers to customize the help output for their CLI.
Read the announcement.
Feature: Custom error delegation​
This feature both improved how oclif throws and handles errors and allows oclif developers to overwrite or interject in oclif’s error handling.
Read the announcement.
Feature: postrun hooks​
We have added a new lifecycle event postrun. Your CLI can now run a hook after a command has ran.
See our hook documentation.
Feature: Root index command​
Previously, oclif would display CLI help if only the binary name with no command ID was invoked, oclif now supports a "root index" command. If present, a command defined at src/commands/index.ts will be run if no command ID is found.
1 million weekly downloads​
While exact oclif usage metrics are hard to pin down, we use npm download statistics of oclif packages as a rough approximation. Earlier this year, oclif's command package hit 1 million weekly downloads for the first time!
This year has been presented its challenges on everyone. We want to thank you, oclif developers, whom have taken the time to use and improve the oclif project. We look forward to seeing you all - in person - in the future!
All our best,
The oclif teamPretty Printable ErrorsJuly 1, 2020 · One min readOften CLIs are used as handy tools and when things go wrong it’s useful to have additional context. In oclif we have added a couple of additional properties that can show extra context to the users when an error is displayed. The code, ref and suggestions will now be displayed if they are included. This will work with an existing oclif CLI by adding the latest @oclif/errors and @oclif/core to the CLI's package.json dependencies.
For example, using this.error with the additional properties:
class TestError extends Command {  async run() {    this.error("An error has occurred!", {      code: "OCLIF_ERR",      ref: "https://oclif.io/docs/commands#thiserrormessage-string--error-options-code-string-exit-number",      suggestions: ["Use these extra properties to provide additional context"],    })  }}
would result with the following output:
›   Error: An error has occurred!›   Code: OCLIF_ERR›   Try this: Use these extra properties to provide additional context›   Reference: https://oclif.io/docs/commands#thiserrormessage-string--error-options-code-string-exit-number
If these properties are not provided then nothing changes and the CLI will continue to display the single error message output as it did before. Additionally, as part of this exercise we’ve added documentation around Error Handling in oclif which should come in handy if the need arises to extend oclif’s default handling of errors.Customizing Help in oclifMay 5, 2020 · 2 min readOut of the box oclif provides a great help experience for CLIs.
But what if, as an oclif developer, you want to customize some or all of the output?
You can now customize your CLI's help output by implementing the HelpBase abstract class.
Getting started with custom help​
If you have not done so yet, update @oclif/core.
$ yarn add --latest @oclif/core
To get started, first define the filepath to your help class in oclif's config in package.json. This is a relative path to the help class, without a file extension.
For this example, the help class will be created in a file at "[project root]/src/help.ts".
{  // ...  "oclif": {    "helpClass": "./lib/help"    // ...  }  // ...}
From here there are two paths, implement the HelpBase abstract class yourself or overwrite the parts of the default Help class you want to customize (ex: how command usage is displayed). We recommend the latter approach but cover both in the new Help Classes docs.
Separating TOPICS & COMMANDS in the new default Help class​
Previously, topics and child commands were listed in help output under a single list heading called "COMMANDS". But we found this can be slightly confusing. Some topics are commands also (a.k.a. topic-commands) while others are simply organizational namespacing (and when ran just show their help).
The new default Help class splits the list of children into distinct lists of "TOPICS" and "COMMANDS", with the possibility of an item appearing in both if it a topic-command. This makes it clearer what is expected to be ran - "COMMANDS" - and what is providing structure - "TOPICS" - when looking at the help output.
VERSION  plugin-help-example/0.0.0 darwin-x64 node-v12.12.0USAGE  $ plugin-help-example [COMMAND]TOPICS  topic  this is a topic and has child topics or commandsCOMMANDS  hello  describe the command here  help   display help for plugin-help-example
We look forward to seeing what custom help features you implement in your oclif CLIs with this new feature!oclif TSLint to ESLint MigrationDecember 5, 2019 · 3 min readBack in February of this year, plans were announced to deprecate TSLint in favor of ESLint. TSLint's goal has become to work toward a “unified developer experience” by supporting ESLint development going forward.
What has changed in oclif​
To keep inline with the community, oclif has transitioned to ESLint for all our core libraries as well as all our official plugins.
Starting in v1.15.x, oclif will now optionally generate projects with ESLint for both TypeScript and JavaScript CLI’s.
ESLint does require Node to be on stable LTS version, at the time of writing, Node 8.10.x, Node 10.13.x & Node 12.x.x.
How does this affect you​
Existing CLI’s are unchanged, but any newly generated CLI's will only give the option of using ESLint. If you are running tslint in your CLI, we recommend you switch to ESLint as well.
In migrating our projects we took the following steps (for an example of these changes see this pull request).


Install eslint
$ yarn add eslint eslint-config-oclif eslint-config-oclif-typescript --dev


Add eslint related files


$ echo '{  "extends": [    "oclif",    "oclif-typescript"  ],  "rules": {  }}' > .eslintrc


Remove tslint and related packages
$ yarn remove @oclif/tslint tslint


Remove tslint related configuration files
$ rm tslint.json


Change lint script in our package.json from something like:
"lint": "tsc -p test --noEmit && tslint -p test -t stylish"
to
"lint": "eslint . --ext .ts --config .eslintrc"


To preserve the test compile (tsc -p test --noEmit) we also made the following updates to our scripts:
"pretest": "tsc -p test --noEmit"
In some cases we had our posttest duplicating the same steps as our lint script so it’s cleaner to have it reference the lint job directly with:
"posttest": "yarn lint"

Run yarn lint --fix. This attempts to auto-fix any linting violations automatically. In the case an auto-fix isn’t available it should be fixed manually or ignored (see the eslint configuration doc for more information)
Do a search in the codebase for tslint and remove any unnecessary tslint disabling comments, like:

/* tslint:disable:object-literal-sort-keys */
If you are on a version of Node that is not supported by ESLint, you will also need to update your Node engine. ESLint supports Node 8, 10, and 12 so you should upgrade to the most recent Node version compatible with your CLI and also supported by ESLint (see ESLint's Installation and Usage instructions).
When will this take effect​
These changes have taken effect in oclif v1.15.1. When you generate a new CLI or plugin it will now contain configuration for ESLint instead of TSLint.oclif's Current Node SupportOctober 31, 2019 · 3 min readTo maintain a healthy project trajectory, oclif follows and supports Node Active LTS release, currently Node 10 & Node 12. This means ensuring that oclif continues to play nice with coming Active LTS Node versions and other packages in the ecosystem. Moving forward also means leaving older versions behind. Starting in 2020, Node will stop maintaining Node 8 and it is our intent at that time to also follow suit. Let’s take a look at a few ways we will be supporting these changes.
CI Environments​
CLIs created with the oclif cli going forward will be generated with a CircleCI configuration with Node 10 & 12 and an Appveyor configuration using Node 10. We have also added Node latest to CircleCi to be an early warning detection against coming Node changes (Node latest is managed by CircleCI).
We have already updated every oclif repo's CI configs to reflect this.
If your existing CLI uses either Appveyor or CircleCI you can update your config files also, like so:
.circleci/config.yml​
Your CircleCI config should contain a node-latest job, aliased as test. From this, there should be two extensions of this job for the Active LTS Node versions, Node 10 and Node 12.
  node-10:    <<: *node-latest    docker:      - image: node:10  node-12:    <<: *node-latest    docker:      - image: node:12
Notice that these declarations only change the Docker Node images used to run that job.
Additionally, the jobs listed within workflows must also be updated to reflect our changes in configuration:
    jobs:      - node-latest      - node-10      - node-12
appveyor.yml​
For appveyor we are currently only testing the oldest Active LTS Node version, Node 10. Update the nodejs_version proppert in your appveyor.yml file to reflect this.
environment:  nodejs_version: "10"
Deprecating Node 8 & Updating packge.json engines​
In Jan 2020, Node will end its Node 8 maintenance. We will follow suit by setting the package.json engine property in oclif packages to >=10 and bumping the package's major versions.
Depending on how you ship your CLI you may wish to also bump the engines version in your CLI's package.json. You can read more about the implications of the engines property configuration in the npm documentation.
Also consider distributing your CLI with its own Node version.
Packaged Node Version​
When using dev-cli to pack your CLI it will use the Node version as specified in your package.json under the oclif.update.node.version property. This value should reflect an Active LTS Node version (dev-cli does not currently enforce versions).
Supporting the future​
As a community we may discover bumps along the way as we upgrade. If you notice something related to oclif please feel free to open an issue or submit a pull request under the relevant oclif package within the org.
We look forward to using the latest from Node and the community and keeping oclif healthy along the way.oclifconf 2019: A RecapSeptember 16, 2019 · 4 min readIn May, Heroku and Salesforce Open Source organized oclifconf, a conference for developers & product managers building CLI tools on top of the open source oclif framework. The speakers came from various tech companies, such as Adobe, Netlify, and Apollo, who have already built amazing CLI experiences. The topics covered everything from the incredible capabilities oclif has unlocked, to the community-built plugins extending its functionality, and even what the behavior of an adaptive CLI tool might look like.
Below is a listing of all of the talks from the event, along with a short summary. Enjoy!
The future of oclif by Jeff Dickey​

In its relatively short lifetime, oclif has already inspired many developers and companies to adopt its framework as a means for implementing their own command-line tooling. In this talk, Jeff Dickey, an oclif founding team member, recaps the project's history and inspiration. He also looks towards the future and outlines some features and improvements that the tool could adapt. This isn't so much a definitive roadmap of where oclif is headed, but rather, a call to inspiration for developers eager to contribute! And if you are interested in contributing, check out the open issues in the oclif GitHub repo and come say "Hello!" on Spectrum Chat.
Open Source Citizenship by Josh Simmons​

When it comes to open source, it's more than just individuals now. More and more frequently, large corporations are contributing to projects by donating to contributors, sponsoring events, or upstreaming contributions. But keeping open source projects and communities healthy requires more than just money and brainpower. Josh Simmons surveyed multiple open source communities and relays his findings as to what help maintainers and contributors actually need in this talk.
Building an enterprise-grade CLI with oclif by Thomas Dvornik​

Security and performance are all about trust. While oclif is an extremely extensible framework for building CLI tooling, there are additional requirements to fulfill for enterprise businesses to adopt it that might not be necessary for individual developers. Thomas Dvornik outlines what he and his colleagues at Salesforce have implemented as plugins to oclif to satisfy these needs, including encrypted OAuth, plugin signing, lazy loading dependencies, synchronizing weekly releases and deprecations across dozens of repositories, and establishing cross-team coding and documentation standards.
How Adobe I/O built an extensible CLI with oclif by Jesse MacFadyen​

Perhaps oclif's most appealing feature is its support for plugins. In Cordova's case, they've created a sophisticated telemetry system that helps Adobe developers see which commands users are using--and reports on which ones are erroring out. By embedding a feedback system into the tool, users are even able to quickly send their suggestions to a form, without ever leaving the terminal. Jesse MacFadyen demonstrates how oclif's plugin system can work beyond simply executing commands.
Integrating oclif with GraphQL and Apollo by Evans Hauser​

For Evans Hauser and the team at Apollo, oclif is best thought of as "React for the CLI." As a client paired with a strongly-typed API contract to a server, it can deliver structured and consistent commands to retrieve external data. What better mechanism to use for this transfer than GraphQL, a framework which empowers the client to ask precisely for the data it needs, and nothing more?
Adaptive Intent-based CLI State Machines by Shawn Wang​

In designing oclif, Jeff Dickey wrote out 12 CLI factors to keep in mind. In this talk, Shawn Wang outlines a 13th: state. State is hard, because it depends on context, and context depends on understanding what a user intends to do, not what they are asking. Shawn is working towards enabling oclif to better understand the commands a user has entered, so that it can predict and interpret future commands that might be entered next. This would enable CLI tools to not just interpret a users' commands, but to also interpret their intent.\n\nIntroducing `oclif init` commandApril 10, 2024 · 2 min readThanks to the contribution of @joshcanhelp we released a new command for the oclif CLI called oclif init in version 4.8.0
The oclif init command allows you to initialize oclif in an existing project directory by adding the bare minimum requirements: a few pieces of configuration, bin scripts, and a couple of dependencies (@oclif/core and ts-node). This is slightly different from oclif generate, which will create an entirely new oclif project based on our templates.
oclif init will add the following:

bin scripts: bin/run.js, bin/run.cmd, bin/dev.js, and bin/dev.cmd
oclif section to package.json with bin, dirname, commands, and topicSeparator set (See Configuring Your CLI for more)
@oclif/core to dependencies in your package.json (if it's not already there)
ts-node to devDependencies in your package.json (if it's not already there)

Once you've initialized oclif, you can use the bin scripts to execute your CLI. You can also use the other oclif commands like oclif generate command and oclif generate hook to start adding new functionality.

❯ oclif init --helpInitialize a new oclif CLIUSAGE  $ oclif init [--bin <value>] [--module-type ESM|CommonJS] [--package-manager npm|yarn|pnpm] [--topic-separator    colons|spaces] [-d <value>] [-y]FLAGS  -d, --output-dir=<value>        Directory to initialize the CLI in.  -y, --yes                       Use defaults for all prompts. Individual flags will override defaults.      --bin=<value>               Supply answer for prompt: Command bin name the CLI will export      --module-type=<option>      Supply answer for prompt: Select a module type                                  <options: ESM|CommonJS>      --package-manager=<option>  Supply answer for prompt: Select a package manager                                  <options: npm|yarn|pnpm>      --topic-separator=<option>  Supply answer for prompt: Select a topic separator                                  <options: colons|spaces>DESCRIPTION  Initialize a new oclif CLI  This will add the necessary oclif bin files, add oclif config to package.json, and install @oclif/core and ts-node.EXAMPLES  Initialize a new CLI in the current directory    $ oclif init  Initialize a new CLI in a different directory    $ oclif init --output-dir "/path/to/existing/project"  Supply answers for specific prompts    $ oclif init --topic-separator colons --bin mycli
Hope you enjoy the new command! If you come across any issues or have any new ideas for this command, head over to the oclif/oclif repo and open a new issue.
All our best,
The oclif teamoclif Spring 2024 UpdateMarch 29, 2024 · 4 min readHello oclif developers! It's been a while since we last uploaded a blog - and a lot has happened.
We've been focusing on these high-level areas over the past couple of years:

Improving @oclif/core
ESM Support
Improving and revitalizing oclif.io
Re-engaging the oclif community

Improving @oclif/core​
Since we announced @oclif/core over three years ago, we've released two new major versions, each packed with lots of features that we're really excited about.
Here are some of these changes:

Full support for ESM and interoperability with CommonJS (more on this topic below).
Configurable command discovery strategies that give you more control over how commands are loaded at runtime. Check out the docs.
A new preparse hook that allows you to manipulate the provided arguments before they're parsed. Salesforce used this hook to implement a neat --flags-dir feature that translates local files into flags.
A new Performance class that you can use to track performance inside of @oclif/core and your own CLI or plugin. Check out the docs.
A new flag type, Flags.option, that lets you define a flag with a preset list of options. Typescript then uses the options to infer the flag's type.
Flags now have a relationship property that allows you to define more complex relationships between flags. Check out the flags docs for more information.
Flags now have a defaultHelp property that allows you to set the human readable default value in the command help. This property is useful when your flag's parse method returns a complex type, such as an object or a class. Check out the flags docs for more.
Commands now have a hiddenAliases property that allows you to define aliases that you want to hide from the user. The property is super helpful when you're trying to wean users off a deprecated command.
You can now use bun or tsx as dev runtimes (as opposed to node or ts-node).
A command's usage, args, and flags are now shown whenever a user forgets to provide a required arg or flag, or when they provided a non-existent flag.

If you need help migrating to the latest version, head over to core's README which has links to the migration guides. Feel free to open a new discussion if you need more hands-on help from us or the community.
ESM Support​
Version 3 of @oclif/core introduced full support for developing ESM plugins and CLIs. It also offered full support for interoperability between CommonJS and ESM plugins.
Put more simply, you can now migrate your CLI to ESM while keeping individual plugins in CommonJS (or vice versa). The upgrade path is now much simpler for you. You also don't need to worry about any community plugins that have migrated to ESM before you did (such as all the @oclif plugins) or are staunchly sticking with CommonJS for the foreseeable future.
Read more about this topic here.
Improving and Revitalizing oclif.io​
Another area of focus for us has been improving our documentation site, oclif.io.
While improving the quality and accuracy of the documentation was our priority, we also took the time to upgrade to the latest version of docusaurus. This new version gave our site a much-needed facelift, as well as cool new features such as dark mode and announcements.
If you have any feedback or are running into issues, we want to hear about it. Just create an issue in the oclif.io repo.
Re-engaging the oclif Community​
Lastly, our biggest priority at the moment is to re-engage the oclif community. We understand how frustrating it has been over the years to see your issues and pull requests go unacknowledged. We apologize for not prioritizing the community, and are earnestly trying to make sure that every issue and pull request gets the attention it deserves going forward.
We also opened up GitHub discussions for @oclif/core and the oclif CLI, where you can now post your questions or ideas. We hope you take advantage of them, we love hearing from you!
One last thing: we intend to publicly post our roadmap so you have more visibility into what we're working on. Stay tuned!
All our best,
The oclif teamAnnouncing oclif v2!January 12, 2022 · 5 min readHello and happy new year! It's our great pleasure to announce that we have released oclif v2, which uses the new @oclif/core library! 🎉
oclif v2 includes many changes that improve the experience of both creating and using an oclif CLI.
Going forward, we don't plan to make any updates to oclif v1 and its corresponding libraries, except for critical security fixes. See the compatibility matrix for a list of these libraries. In order to give developers time to migrate from v1 to v2, we're not completely dropping support yet. But at some point in the future we'll archive the v1 repositories and deprecate their versions on npm.
What’s changing?​
Repository Changes​
All repositories under the oclif org now use main as their primary branch and oclif-v1 as the legacy branch. The main  branch corresponds to oclif v2 and the oclif-v1 branch to oclif v1. If you find any repos that don’t have a main branch, you can safely assume that they're not used in oclif v2 and will be deprecated in the future.
Consolidating Tools & Libraries​
The oclif-dev CLI has now been incorporated into oclif. You now no longer need to install a separate package to manage your entire CLI’s lifecycle.
The following libraries have been consolidated under @oclif/core and will be deprecated at some point in the future. Read the migration guide to learn how to update your CLI or plugin to use the new core library.

@oclif/command
@oclif/config
@oclif/error
@oclif/help
@oclif/parser

No more single vs multi command CLIs​
There's only one "type" of oclif v2 CLI, but it can have as few or as many commands as a developer wants. As a result, there’s only one command to generate CLIs, oclif generate, as opposed to the old oclif single and oclif multi commands.
Node > 12​
To ensure oclif CLIs are as secure as possible, all v2 libraries and plugins support only Node 12 or higher as of now. Going forward, they'll support only Node Maintenance or higher, as defined by Node's release schedule here: https://nodejs.org/en/about/releases/.
What’s new?​
New example CLI​
oclif-hello-world is our new example repo. This is also the repo that's used as a template when running oclif generate to create a new CLI. This repo will always be able to be referenced as an example of what an oclif v2 CLI should look like.
Spaced commands​
oclif CLIs can now use spaces, instead of colons, to separate topics and subcommands. To enable this feature, simply add “topicSeparator": " " to the oclif config in your package.json. See an example in our example repo.
// Old commands that use :$ mycli do:something
// New spaced commands$ mycli do something

Note: Spaced commands are backwards compatible. So if you enable spaced commands for your CLI, users will still be able to use : as a separator. This ensures that any existing scripts don't break.

New Help Output​
We’ve revamped the way command help is outputted to the terminal, making it both easier to implement and easier to read. See the difference between the old help output on the left and the new help output on the right in the screenshots below.
oclif v1oclif v2
Notice that there are new sections for flags and global flags, examples are displayed with better spacing, and there is a section at the bottom called Configuration Variables. This Configuration Variables section is not part of the new help by default. But we've added support for custom help sections, which is what the sf CLI uses to create the new section.
Async Command Parsing​
We’ve also improved the performance of new CLIs by rewriting how commands are parsed on initialization. The new parser is asynchronous, which makes CLIs with a lot of commands or installed  plugins much faster.
What’s coming next?​
Part of our charter for the release of oclif v2 includes improving our engagement with the oclif community. We know that over the past couple of years we’ve reduced our involvement, and a lot of issues and PRs have languished in limbo. Hopefully you’ve already seen increased activity and responses from oclif maintainers recently, but if you haven’t, please don’t hesitate to ping us by tagging @admins in oclif repos.
We also want to start interviewing members of the oclif community to acquire feedback and prioritize the features and fixes you deem most important!
Best,
The oclif team

Reference material​
Migration Guide​
This guide explains how to upgrade a CLI or plugin from the old oclif v1 libraries to the new @oclif/core library that oclif v2 uses.
https://github.com/oclif/core/blob/main/MIGRATION.md
Compatibility Matrix​
The following matrix shows how the v1 libraries and plugins relate to the new v2 ones. Use this matrix as a guide to know what to drop and which versions to switch when upgrading your plugins and CLIs to v2.
oclif "v1"oclif "v2"Utility CLIsoclif@<2@oclif/dev-cli@<2oclif@>=2Main packages@oclif/command@oclif/config@oclif/errors@oclif/parser@oclif/plugin-help@oclif/core@>=1Node LTSNode v8-14Node v12+ (at time of writing)TypeScripttypescript@<4typescript@>=4Main plugins@oclif/plugin-autocomplete@<1@oclif/plugin-commands@<2@oclif/plugin-help@<4@oclif/plugin-not-found@<2@oclif/plugin-plugins@<2@oclif/plugin-update@<2plugin-warn-if-update-available@<2plugin-which@<2@oclif/plugin-autocomplete@>=1@oclif/plugin-commands@>=2@oclif/plugin-help@>=4@oclif/plugin-not-found@>=2@oclif/plugin-plugins@>=2@oclif/plugin-update@>=2@oclif/plugin-warn-if-update-available@>=2@oclif/plugin-which@>=2Introducing @oclif/coreMarch 1, 2021 · 3 min readGreetings!
We hope this blog post finds you well.
Introducing...​
We are excited to announce the next iteration of the oclif project today: @oclif/core.
We have learned a lot in the last three years of developing oclif, developing on oclif and supporting millions of command runs a day via Heroku and Salesforce CLIs.
@oclif/core ("Core") simplifies the oclif development experience and introduces highly requested new features.
Core combines the essential oclif packages into one "core" package, aptly named @oclif/core.
Core also introduces:

A default command option
Colon or space command syntax
Async command parsing
Command piping to arguments

With the introduction of default command functionality, Core simplifies the oclif project and removes the notion of single or multi command CLIs. Core CLIs can have 1 or many commands.
Along with Core, we moved the oclif-dev CLI into the oclif CLI creating a single "utility" CLI. This CLI also introduces a new AWS S3 compatible publishing scheme.
What to expect in the near future​
Core is in pre-release beta and being actively developed for new internal Salesforce CLIs.
Much documentation needs to be written in the coming months including migration paths. Migration onto Core should be as painless as possible with many exports remaining entirely unchanged. Look for forthcoming blog posts and documentation on oclif.io.
Early this summer, tentively June 1, we will release Core v1. Core's release will coincide with major bumps to many other oclif plugin packages. See the compatibility matrix below.
At Core's v1 release, the current "main" oclif packages (namely: command, config, errors & parser) will go into maintenance mode until Jan 2022. They will receive only bug and security fixes and they remain compatible with current versions of the oclif and oclif-dev CLIs. Afterwhich, they will be archived.
Companioning Core, the next major release of the oclif CLI (literally oclif@2) will generate Core CLIs.
Going forward​
We are excited to release Core! We invite you to poke around the Core repo. It may appear to be a big change but Core keeps what you already enjoy about oclif while reducing development complexity, project dependencies, package coupling and bundle size and introduces many requested features previously too prickly to weave into the current oclif architecture.
Best,
The oclif team
Reference: Compatibility matrix​
oclif "v1"oclif "Core"Utility CLIsoclif@<2@oclif/dev-cli@<2oclif@>=2Main packages@oclif/core@<2@oclif/config@<2@oclif/errors@<2@oclif/parser@<4@oclif/plugin-help@<4@oclif/core@>=1Node LTSNode v8-14Node v12+TypeScripttypescript@<4typescript@>=4Main plugins@oclif/plugin-autocomplete@<1@oclif/plugin-commands@<2@oclif/plugin-help@<4@oclif/plugin-not-found@<2@oclif/plugin-plugins@<2@oclif/plugin-update@<2plugin-warn-if-update-available@<2plugin-which@<2@oclif/plugin-autocomplete@>=2@oclif/plugin-commands@>=2@oclif/plugin-help@>=4@oclif/plugin-not-found@>=2@oclif/plugin-plugins@>=2@oclif/plugin-update@>=2@oclif/plugin-warn-if-update-available@>=2@oclif/plugin-which@>=2oclif Summer 2020 UpdateAugust 26, 2020 · 2 min readHello oclif developers! We hope you are all doing well.
Earlier this year, we started our planning for oclifconf v2 and, like all conference, had to change course. We opted not to hold a virtual conference, however, we wanted to take some time to highlight a few oclif features shipped this year.
Feature: Help templating​
One of the most requested features, help templating enables oclif developers to customize the help output for their CLI.
Read the announcement.
Feature: Custom error delegation​
This feature both improved how oclif throws and handles errors and allows oclif developers to overwrite or interject in oclif’s error handling.
Read the announcement.
Feature: postrun hooks​
We have added a new lifecycle event postrun. Your CLI can now run a hook after a command has ran.
See our hook documentation.
Feature: Root index command​
Previously, oclif would display CLI help if only the binary name with no command ID was invoked, oclif now supports a "root index" command. If present, a command defined at src/commands/index.ts will be run if no command ID is found.
1 million weekly downloads​
While exact oclif usage metrics are hard to pin down, we use npm download statistics of oclif packages as a rough approximation. Earlier this year, oclif's command package hit 1 million weekly downloads for the first time!
This year has been presented its challenges on everyone. We want to thank you, oclif developers, whom have taken the time to use and improve the oclif project. We look forward to seeing you all - in person - in the future!
All our best,
The oclif teamPretty Printable ErrorsJuly 1, 2020 · One min readOften CLIs are used as handy tools and when things go wrong it’s useful to have additional context. In oclif we have added a couple of additional properties that can show extra context to the users when an error is displayed. The code, ref and suggestions will now be displayed if they are included. This will work with an existing oclif CLI by adding the latest @oclif/errors and @oclif/core to the CLI's package.json dependencies.
For example, using this.error with the additional properties:
class TestError extends Command {  async run() {    this.error("An error has occurred!", {      code: "OCLIF_ERR",      ref: "https://oclif.io/docs/commands#thiserrormessage-string--error-options-code-string-exit-number",      suggestions: ["Use these extra properties to provide additional context"],    })  }}
would result with the following output:
›   Error: An error has occurred!›   Code: OCLIF_ERR›   Try this: Use these extra properties to provide additional context›   Reference: https://oclif.io/docs/commands#thiserrormessage-string--error-options-code-string-exit-number
If these properties are not provided then nothing changes and the CLI will continue to display the single error message output as it did before. Additionally, as part of this exercise we’ve added documentation around Error Handling in oclif which should come in handy if the need arises to extend oclif’s default handling of errors.Customizing Help in oclifMay 5, 2020 · 2 min readOut of the box oclif provides a great help experience for CLIs.
But what if, as an oclif developer, you want to customize some or all of the output?
You can now customize your CLI's help output by implementing the HelpBase abstract class.
Getting started with custom help​
If you have not done so yet, update @oclif/core.
$ yarn add --latest @oclif/core
To get started, first define the filepath to your help class in oclif's config in package.json. This is a relative path to the help class, without a file extension.
For this example, the help class will be created in a file at "[project root]/src/help.ts".
{  // ...  "oclif": {    "helpClass": "./lib/help"    // ...  }  // ...}
From here there are two paths, implement the HelpBase abstract class yourself or overwrite the parts of the default Help class you want to customize (ex: how command usage is displayed). We recommend the latter approach but cover both in the new Help Classes docs.
Separating TOPICS & COMMANDS in the new default Help class​
Previously, topics and child commands were listed in help output under a single list heading called "COMMANDS". But we found this can be slightly confusing. Some topics are commands also (a.k.a. topic-commands) while others are simply organizational namespacing (and when ran just show their help).
The new default Help class splits the list of children into distinct lists of "TOPICS" and "COMMANDS", with the possibility of an item appearing in both if it a topic-command. This makes it clearer what is expected to be ran - "COMMANDS" - and what is providing structure - "TOPICS" - when looking at the help output.
VERSION  plugin-help-example/0.0.0 darwin-x64 node-v12.12.0USAGE  $ plugin-help-example [COMMAND]TOPICS  topic  this is a topic and has child topics or commandsCOMMANDS  hello  describe the command here  help   display help for plugin-help-example
We look forward to seeing what custom help features you implement in your oclif CLIs with this new feature!oclif TSLint to ESLint MigrationDecember 5, 2019 · 3 min readBack in February of this year, plans were announced to deprecate TSLint in favor of ESLint. TSLint's goal has become to work toward a “unified developer experience” by supporting ESLint development going forward.
What has changed in oclif​
To keep inline with the community, oclif has transitioned to ESLint for all our core libraries as well as all our official plugins.
Starting in v1.15.x, oclif will now optionally generate projects with ESLint for both TypeScript and JavaScript CLI’s.
ESLint does require Node to be on stable LTS version, at the time of writing, Node 8.10.x, Node 10.13.x & Node 12.x.x.
How does this affect you​
Existing CLI’s are unchanged, but any newly generated CLI's will only give the option of using ESLint. If you are running tslint in your CLI, we recommend you switch to ESLint as well.
In migrating our projects we took the following steps (for an example of these changes see this pull request).


Install eslint
$ yarn add eslint eslint-config-oclif eslint-config-oclif-typescript --dev


Add eslint related files


$ echo '{  "extends": [    "oclif",    "oclif-typescript"  ],  "rules": {  }}' > .eslintrc


Remove tslint and related packages
$ yarn remove @oclif/tslint tslint


Remove tslint related configuration files
$ rm tslint.json


Change lint script in our package.json from something like:
"lint": "tsc -p test --noEmit && tslint -p test -t stylish"
to
"lint": "eslint . --ext .ts --config .eslintrc"


To preserve the test compile (tsc -p test --noEmit) we also made the following updates to our scripts:
"pretest": "tsc -p test --noEmit"
In some cases we had our posttest duplicating the same steps as our lint script so it’s cleaner to have it reference the lint job directly with:
"posttest": "yarn lint"

Run yarn lint --fix. This attempts to auto-fix any linting violations automatically. In the case an auto-fix isn’t available it should be fixed manually or ignored (see the eslint configuration doc for more information)
Do a search in the codebase for tslint and remove any unnecessary tslint disabling comments, like:

/* tslint:disable:object-literal-sort-keys */
If you are on a version of Node that is not supported by ESLint, you will also need to update your Node engine. ESLint supports Node 8, 10, and 12 so you should upgrade to the most recent Node version compatible with your CLI and also supported by ESLint (see ESLint's Installation and Usage instructions).
When will this take effect​
These changes have taken effect in oclif v1.15.1. When you generate a new CLI or plugin it will now contain configuration for ESLint instead of TSLint.oclif's Current Node SupportOctober 31, 2019 · 3 min readTo maintain a healthy project trajectory, oclif follows and supports Node Active LTS release, currently Node 10 & Node 12. This means ensuring that oclif continues to play nice with coming Active LTS Node versions and other packages in the ecosystem. Moving forward also means leaving older versions behind. Starting in 2020, Node will stop maintaining Node 8 and it is our intent at that time to also follow suit. Let’s take a look at a few ways we will be supporting these changes.
CI Environments​
CLIs created with the oclif cli going forward will be generated with a CircleCI configuration with Node 10 & 12 and an Appveyor configuration using Node 10. We have also added Node latest to CircleCi to be an early warning detection against coming Node changes (Node latest is managed by CircleCI).
We have already updated every oclif repo's CI configs to reflect this.
If your existing CLI uses either Appveyor or CircleCI you can update your config files also, like so:
.circleci/config.yml​
Your CircleCI config should contain a node-latest job, aliased as test. From this, there should be two extensions of this job for the Active LTS Node versions, Node 10 and Node 12.
  node-10:    <<: *node-latest    docker:      - image: node:10  node-12:    <<: *node-latest    docker:      - image: node:12
Notice that these declarations only change the Docker Node images used to run that job.
Additionally, the jobs listed within workflows must also be updated to reflect our changes in configuration:
    jobs:      - node-latest      - node-10      - node-12
appveyor.yml​
For appveyor we are currently only testing the oldest Active LTS Node version, Node 10. Update the nodejs_version proppert in your appveyor.yml file to reflect this.
environment:  nodejs_version: "10"
Deprecating Node 8 & Updating packge.json engines​
In Jan 2020, Node will end its Node 8 maintenance. We will follow suit by setting the package.json engine property in oclif packages to >=10 and bumping the package's major versions.
Depending on how you ship your CLI you may wish to also bump the engines version in your CLI's package.json. You can read more about the implications of the engines property configuration in the npm documentation.
Also consider distributing your CLI with its own Node version.
Packaged Node Version​
When using dev-cli to pack your CLI it will use the Node version as specified in your package.json under the oclif.update.node.version property. This value should reflect an Active LTS Node version (dev-cli does not currently enforce versions).
Supporting the future​
As a community we may discover bumps along the way as we upgrade. If you notice something related to oclif please feel free to open an issue or submit a pull request under the relevant oclif package within the org.
We look forward to using the latest from Node and the community and keeping oclif healthy along the way.oclifconf 2019: A RecapSeptember 16, 2019 · 4 min readIn May, Heroku and Salesforce Open Source organized oclifconf, a conference for developers & product managers building CLI tools on top of the open source oclif framework. The speakers came from various tech companies, such as Adobe, Netlify, and Apollo, who have already built amazing CLI experiences. The topics covered everything from the incredible capabilities oclif has unlocked, to the community-built plugins extending its functionality, and even what the behavior of an adaptive CLI tool might look like.
Below is a listing of all of the talks from the event, along with a short summary. Enjoy!
The future of oclif by Jeff Dickey​

In its relatively short lifetime, oclif has already inspired many developers and companies to adopt its framework as a means for implementing their own command-line tooling. In this talk, Jeff Dickey, an oclif founding team member, recaps the project's history and inspiration. He also looks towards the future and outlines some features and improvements that the tool could adapt. This isn't so much a definitive roadmap of where oclif is headed, but rather, a call to inspiration for developers eager to contribute! And if you are interested in contributing, check out the open issues in the oclif GitHub repo and come say "Hello!" on Spectrum Chat.
Open Source Citizenship by Josh Simmons​

When it comes to open source, it's more than just individuals now. More and more frequently, large corporations are contributing to projects by donating to contributors, sponsoring events, or upstreaming contributions. But keeping open source projects and communities healthy requires more than just money and brainpower. Josh Simmons surveyed multiple open source communities and relays his findings as to what help maintainers and contributors actually need in this talk.
Building an enterprise-grade CLI with oclif by Thomas Dvornik​

Security and performance are all about trust. While oclif is an extremely extensible framework for building CLI tooling, there are additional requirements to fulfill for enterprise businesses to adopt it that might not be necessary for individual developers. Thomas Dvornik outlines what he and his colleagues at Salesforce have implemented as plugins to oclif to satisfy these needs, including encrypted OAuth, plugin signing, lazy loading dependencies, synchronizing weekly releases and deprecations across dozens of repositories, and establishing cross-team coding and documentation standards.
How Adobe I/O built an extensible CLI with oclif by Jesse MacFadyen​

Perhaps oclif's most appealing feature is its support for plugins. In Cordova's case, they've created a sophisticated telemetry system that helps Adobe developers see which commands users are using--and reports on which ones are erroring out. By embedding a feedback system into the tool, users are even able to quickly send their suggestions to a form, without ever leaving the terminal. Jesse MacFadyen demonstrates how oclif's plugin system can work beyond simply executing commands.
Integrating oclif with GraphQL and Apollo by Evans Hauser​

For Evans Hauser and the team at Apollo, oclif is best thought of as "React for the CLI." As a client paired with a strongly-typed API contract to a server, it can deliver structured and consistent commands to retrieve external data. What better mechanism to use for this transfer than GraphQL, a framework which empowers the client to ask precisely for the data it needs, and nothing more?
Adaptive Intent-based CLI State Machines by Shawn Wang​

In designing oclif, Jeff Dickey wrote out 12 CLI factors to keep in mind. In this talk, Shawn Wang outlines a 13th: state. State is hard, because it depends on context, and context depends on understanding what a user intends to do, not what they are asking. Shawn is working towards enabling oclif to better understand the commands a user has entered, so that it can predict and interpret future commands that might be entered next. This would enable CLI tools to not just interpret a users' commands, but to also interpret their intent.Older Entries\n\n\n\nIntroducing `oclif init` commandApril 10, 2024 · 2 min readThanks to the contribution of @joshcanhelp we released a new command for the oclif CLI called oclif init in version 4.8.0
The oclif init command allows you to initialize oclif in an existing project directory by adding the bare minimum requirements: a few pieces of configuration, bin scripts, and a couple of dependencies (@oclif/core and ts-node). This is slightly different from oclif generate, which will create an entirely new oclif project based on our templates.
oclif init will add the following:

bin scripts: bin/run.js, bin/run.cmd, bin/dev.js, and bin/dev.cmd
oclif section to package.json with bin, dirname, commands, and topicSeparator set (See Configuring Your CLI for more)
@oclif/core to dependencies in your package.json (if it's not already there)
ts-node to devDependencies in your package.json (if it's not already there)

Once you've initialized oclif, you can use the bin scripts to execute your CLI. You can also use the other oclif commands like oclif generate command and oclif generate hook to start adding new functionality.

❯ oclif init --helpInitialize a new oclif CLIUSAGE  $ oclif init [--bin <value>] [--module-type ESM|CommonJS] [--package-manager npm|yarn|pnpm] [--topic-separator    colons|spaces] [-d <value>] [-y]FLAGS  -d, --output-dir=<value>        Directory to initialize the CLI in.  -y, --yes                       Use defaults for all prompts. Individual flags will override defaults.      --bin=<value>               Supply answer for prompt: Command bin name the CLI will export      --module-type=<option>      Supply answer for prompt: Select a module type                                  <options: ESM|CommonJS>      --package-manager=<option>  Supply answer for prompt: Select a package manager                                  <options: npm|yarn|pnpm>      --topic-separator=<option>  Supply answer for prompt: Select a topic separator                                  <options: colons|spaces>DESCRIPTION  Initialize a new oclif CLI  This will add the necessary oclif bin files, add oclif config to package.json, and install @oclif/core and ts-node.EXAMPLES  Initialize a new CLI in the current directory    $ oclif init  Initialize a new CLI in a different directory    $ oclif init --output-dir "/path/to/existing/project"  Supply answers for specific prompts    $ oclif init --topic-separator colons --bin mycli
Hope you enjoy the new command! If you come across any issues or have any new ideas for this command, head over to the oclif/oclif repo and open a new issue.
All our best,
The oclif teamoclif Spring 2024 UpdateMarch 29, 2024 · 4 min readHello oclif developers! It's been a while since we last uploaded a blog - and a lot has happened.
We've been focusing on these high-level areas over the past couple of years:

Improving @oclif/core
ESM Support
Improving and revitalizing oclif.io
Re-engaging the oclif community

Improving @oclif/core​
Since we announced @oclif/core over three years ago, we've released two new major versions, each packed with lots of features that we're really excited about.
Here are some of these changes:

Full support for ESM and interoperability with CommonJS (more on this topic below).
Configurable command discovery strategies that give you more control over how commands are loaded at runtime. Check out the docs.
A new preparse hook that allows you to manipulate the provided arguments before they're parsed. Salesforce used this hook to implement a neat --flags-dir feature that translates local files into flags.
A new Performance class that you can use to track performance inside of @oclif/core and your own CLI or plugin. Check out the docs.
A new flag type, Flags.option, that lets you define a flag with a preset list of options. Typescript then uses the options to infer the flag's type.
Flags now have a relationship property that allows you to define more complex relationships between flags. Check out the flags docs for more information.
Flags now have a defaultHelp property that allows you to set the human readable default value in the command help. This property is useful when your flag's parse method returns a complex type, such as an object or a class. Check out the flags docs for more.
Commands now have a hiddenAliases property that allows you to define aliases that you want to hide from the user. The property is super helpful when you're trying to wean users off a deprecated command.
You can now use bun or tsx as dev runtimes (as opposed to node or ts-node).
A command's usage, args, and flags are now shown whenever a user forgets to provide a required arg or flag, or when they provided a non-existent flag.

If you need help migrating to the latest version, head over to core's README which has links to the migration guides. Feel free to open a new discussion if you need more hands-on help from us or the community.
ESM Support​
Version 3 of @oclif/core introduced full support for developing ESM plugins and CLIs. It also offered full support for interoperability between CommonJS and ESM plugins.
Put more simply, you can now migrate your CLI to ESM while keeping individual plugins in CommonJS (or vice versa). The upgrade path is now much simpler for you. You also don't need to worry about any community plugins that have migrated to ESM before you did (such as all the @oclif plugins) or are staunchly sticking with CommonJS for the foreseeable future.
Read more about this topic here.
Improving and Revitalizing oclif.io​
Another area of focus for us has been improving our documentation site, oclif.io.
While improving the quality and accuracy of the documentation was our priority, we also took the time to upgrade to the latest version of docusaurus. This new version gave our site a much-needed facelift, as well as cool new features such as dark mode and announcements.
If you have any feedback or are running into issues, we want to hear about it. Just create an issue in the oclif.io repo.
Re-engaging the oclif Community​
Lastly, our biggest priority at the moment is to re-engage the oclif community. We understand how frustrating it has been over the years to see your issues and pull requests go unacknowledged. We apologize for not prioritizing the community, and are earnestly trying to make sure that every issue and pull request gets the attention it deserves going forward.
We also opened up GitHub discussions for @oclif/core and the oclif CLI, where you can now post your questions or ideas. We hope you take advantage of them, we love hearing from you!
One last thing: we intend to publicly post our roadmap so you have more visibility into what we're working on. Stay tuned!
All our best,
The oclif teamAnnouncing oclif v2!January 12, 2022 · 5 min readHello and happy new year! It's our great pleasure to announce that we have released oclif v2, which uses the new @oclif/core library! 🎉
oclif v2 includes many changes that improve the experience of both creating and using an oclif CLI.
Going forward, we don't plan to make any updates to oclif v1 and its corresponding libraries, except for critical security fixes. See the compatibility matrix for a list of these libraries. In order to give developers time to migrate from v1 to v2, we're not completely dropping support yet. But at some point in the future we'll archive the v1 repositories and deprecate their versions on npm.
What’s changing?​
Repository Changes​
All repositories under the oclif org now use main as their primary branch and oclif-v1 as the legacy branch. The main  branch corresponds to oclif v2 and the oclif-v1 branch to oclif v1. If you find any repos that don’t have a main branch, you can safely assume that they're not used in oclif v2 and will be deprecated in the future.
Consolidating Tools & Libraries​
The oclif-dev CLI has now been incorporated into oclif. You now no longer need to install a separate package to manage your entire CLI’s lifecycle.
The following libraries have been consolidated under @oclif/core and will be deprecated at some point in the future. Read the migration guide to learn how to update your CLI or plugin to use the new core library.

@oclif/command
@oclif/config
@oclif/error
@oclif/help
@oclif/parser

No more single vs multi command CLIs​
There's only one "type" of oclif v2 CLI, but it can have as few or as many commands as a developer wants. As a result, there’s only one command to generate CLIs, oclif generate, as opposed to the old oclif single and oclif multi commands.
Node > 12​
To ensure oclif CLIs are as secure as possible, all v2 libraries and plugins support only Node 12 or higher as of now. Going forward, they'll support only Node Maintenance or higher, as defined by Node's release schedule here: https://nodejs.org/en/about/releases/.
What’s new?​
New example CLI​
oclif-hello-world is our new example repo. This is also the repo that's used as a template when running oclif generate to create a new CLI. This repo will always be able to be referenced as an example of what an oclif v2 CLI should look like.
Spaced commands​
oclif CLIs can now use spaces, instead of colons, to separate topics and subcommands. To enable this feature, simply add “topicSeparator": " " to the oclif config in your package.json. See an example in our example repo.
// Old commands that use :$ mycli do:something
// New spaced commands$ mycli do something

Note: Spaced commands are backwards compatible. So if you enable spaced commands for your CLI, users will still be able to use : as a separator. This ensures that any existing scripts don't break.

New Help Output​
We’ve revamped the way command help is outputted to the terminal, making it both easier to implement and easier to read. See the difference between the old help output on the left and the new help output on the right in the screenshots below.
oclif v1oclif v2
Notice that there are new sections for flags and global flags, examples are displayed with better spacing, and there is a section at the bottom called Configuration Variables. This Configuration Variables section is not part of the new help by default. But we've added support for custom help sections, which is what the sf CLI uses to create the new section.
Async Command Parsing​
We’ve also improved the performance of new CLIs by rewriting how commands are parsed on initialization. The new parser is asynchronous, which makes CLIs with a lot of commands or installed  plugins much faster.
What’s coming next?​
Part of our charter for the release of oclif v2 includes improving our engagement with the oclif community. We know that over the past couple of years we’ve reduced our involvement, and a lot of issues and PRs have languished in limbo. Hopefully you’ve already seen increased activity and responses from oclif maintainers recently, but if you haven’t, please don’t hesitate to ping us by tagging @admins in oclif repos.
We also want to start interviewing members of the oclif community to acquire feedback and prioritize the features and fixes you deem most important!
Best,
The oclif team

Reference material​
Migration Guide​
This guide explains how to upgrade a CLI or plugin from the old oclif v1 libraries to the new @oclif/core library that oclif v2 uses.
https://github.com/oclif/core/blob/main/MIGRATION.md
Compatibility Matrix​
The following matrix shows how the v1 libraries and plugins relate to the new v2 ones. Use this matrix as a guide to know what to drop and which versions to switch when upgrading your plugins and CLIs to v2.
oclif "v1"oclif "v2"Utility CLIsoclif@<2@oclif/dev-cli@<2oclif@>=2Main packages@oclif/command@oclif/config@oclif/errors@oclif/parser@oclif/plugin-help@oclif/core@>=1Node LTSNode v8-14Node v12+ (at time of writing)TypeScripttypescript@<4typescript@>=4Main plugins@oclif/plugin-autocomplete@<1@oclif/plugin-commands@<2@oclif/plugin-help@<4@oclif/plugin-not-found@<2@oclif/plugin-plugins@<2@oclif/plugin-update@<2plugin-warn-if-update-available@<2plugin-which@<2@oclif/plugin-autocomplete@>=1@oclif/plugin-commands@>=2@oclif/plugin-help@>=4@oclif/plugin-not-found@>=2@oclif/plugin-plugins@>=2@oclif/plugin-update@>=2@oclif/plugin-warn-if-update-available@>=2@oclif/plugin-which@>=2Introducing @oclif/coreMarch 1, 2021 · 3 min readGreetings!
We hope this blog post finds you well.
Introducing...​
We are excited to announce the next iteration of the oclif project today: @oclif/core.
We have learned a lot in the last three years of developing oclif, developing on oclif and supporting millions of command runs a day via Heroku and Salesforce CLIs.
@oclif/core ("Core") simplifies the oclif development experience and introduces highly requested new features.
Core combines the essential oclif packages into one "core" package, aptly named @oclif/core.
Core also introduces:

A default command option
Colon or space command syntax
Async command parsing
Command piping to arguments

With the introduction of default command functionality, Core simplifies the oclif project and removes the notion of single or multi command CLIs. Core CLIs can have 1 or many commands.
Along with Core, we moved the oclif-dev CLI into the oclif CLI creating a single "utility" CLI. This CLI also introduces a new AWS S3 compatible publishing scheme.
What to expect in the near future​
Core is in pre-release beta and being actively developed for new internal Salesforce CLIs.
Much documentation needs to be written in the coming months including migration paths. Migration onto Core should be as painless as possible with many exports remaining entirely unchanged. Look for forthcoming blog posts and documentation on oclif.io.
Early this summer, tentively June 1, we will release Core v1. Core's release will coincide with major bumps to many other oclif plugin packages. See the compatibility matrix below.
At Core's v1 release, the current "main" oclif packages (namely: command, config, errors & parser) will go into maintenance mode until Jan 2022. They will receive only bug and security fixes and they remain compatible with current versions of the oclif and oclif-dev CLIs. Afterwhich, they will be archived.
Companioning Core, the next major release of the oclif CLI (literally oclif@2) will generate Core CLIs.
Going forward​
We are excited to release Core! We invite you to poke around the Core repo. It may appear to be a big change but Core keeps what you already enjoy about oclif while reducing development complexity, project dependencies, package coupling and bundle size and introduces many requested features previously too prickly to weave into the current oclif architecture.
Best,
The oclif team
Reference: Compatibility matrix​
oclif "v1"oclif "Core"Utility CLIsoclif@<2@oclif/dev-cli@<2oclif@>=2Main packages@oclif/core@<2@oclif/config@<2@oclif/errors@<2@oclif/parser@<4@oclif/plugin-help@<4@oclif/core@>=1Node LTSNode v8-14Node v12+TypeScripttypescript@<4typescript@>=4Main plugins@oclif/plugin-autocomplete@<1@oclif/plugin-commands@<2@oclif/plugin-help@<4@oclif/plugin-not-found@<2@oclif/plugin-plugins@<2@oclif/plugin-update@<2plugin-warn-if-update-available@<2plugin-which@<2@oclif/plugin-autocomplete@>=2@oclif/plugin-commands@>=2@oclif/plugin-help@>=4@oclif/plugin-not-found@>=2@oclif/plugin-plugins@>=2@oclif/plugin-update@>=2@oclif/plugin-warn-if-update-available@>=2@oclif/plugin-which@>=2oclif Summer 2020 UpdateAugust 26, 2020 · 2 min readHello oclif developers! We hope you are all doing well.
Earlier this year, we started our planning for oclifconf v2 and, like all conference, had to change course. We opted not to hold a virtual conference, however, we wanted to take some time to highlight a few oclif features shipped this year.
Feature: Help templating​
One of the most requested features, help templating enables oclif developers to customize the help output for their CLI.
Read the announcement.
Feature: Custom error delegation​
This feature both improved how oclif throws and handles errors and allows oclif developers to overwrite or interject in oclif’s error handling.
Read the announcement.
Feature: postrun hooks​
We have added a new lifecycle event postrun. Your CLI can now run a hook after a command has ran.
See our hook documentation.
Feature: Root index command​
Previously, oclif would display CLI help if only the binary name with no command ID was invoked, oclif now supports a "root index" command. If present, a command defined at src/commands/index.ts will be run if no command ID is found.
1 million weekly downloads​
While exact oclif usage metrics are hard to pin down, we use npm download statistics of oclif packages as a rough approximation. Earlier this year, oclif's command package hit 1 million weekly downloads for the first time!
This year has been presented its challenges on everyone. We want to thank you, oclif developers, whom have taken the time to use and improve the oclif project. We look forward to seeing you all - in person - in the future!
All our best,
The oclif teamPretty Printable ErrorsJuly 1, 2020 · One min readOften CLIs are used as handy tools and when things go wrong it’s useful to have additional context. In oclif we have added a couple of additional properties that can show extra context to the users when an error is displayed. The code, ref and suggestions will now be displayed if they are included. This will work with an existing oclif CLI by adding the latest @oclif/errors and @oclif/core to the CLI's package.json dependencies.
For example, using this.error with the additional properties:
class TestError extends Command {  async run() {    this.error("An error has occurred!", {      code: "OCLIF_ERR",      ref: "https://oclif.io/docs/commands#thiserrormessage-string--error-options-code-string-exit-number",      suggestions: ["Use these extra properties to provide additional context"],    })  }}
would result with the following output:
›   Error: An error has occurred!›   Code: OCLIF_ERR›   Try this: Use these extra properties to provide additional context›   Reference: https://oclif.io/docs/commands#thiserrormessage-string--error-options-code-string-exit-number
If these properties are not provided then nothing changes and the CLI will continue to display the single error message output as it did before. Additionally, as part of this exercise we’ve added documentation around Error Handling in oclif which should come in handy if the need arises to extend oclif’s default handling of errors.Customizing Help in oclifMay 5, 2020 · 2 min readOut of the box oclif provides a great help experience for CLIs.
But what if, as an oclif developer, you want to customize some or all of the output?
You can now customize your CLI's help output by implementing the HelpBase abstract class.
Getting started with custom help​
If you have not done so yet, update @oclif/core.
$ yarn add --latest @oclif/core
To get started, first define the filepath to your help class in oclif's config in package.json. This is a relative path to the help class, without a file extension.
For this example, the help class will be created in a file at "[project root]/src/help.ts".
{  // ...  "oclif": {    "helpClass": "./lib/help"    // ...  }  // ...}
From here there are two paths, implement the HelpBase abstract class yourself or overwrite the parts of the default Help class you want to customize (ex: how command usage is displayed). We recommend the latter approach but cover both in the new Help Classes docs.
Separating TOPICS & COMMANDS in the new default Help class​
Previously, topics and child commands were listed in help output under a single list heading called "COMMANDS". But we found this can be slightly confusing. Some topics are commands also (a.k.a. topic-commands) while others are simply organizational namespacing (and when ran just show their help).
The new default Help class splits the list of children into distinct lists of "TOPICS" and "COMMANDS", with the possibility of an item appearing in both if it a topic-command. This makes it clearer what is expected to be ran - "COMMANDS" - and what is providing structure - "TOPICS" - when looking at the help output.
VERSION  plugin-help-example/0.0.0 darwin-x64 node-v12.12.0USAGE  $ plugin-help-example [COMMAND]TOPICS  topic  this is a topic and has child topics or commandsCOMMANDS  hello  describe the command here  help   display help for plugin-help-example
We look forward to seeing what custom help features you implement in your oclif CLIs with this new feature!oclif TSLint to ESLint MigrationDecember 5, 2019 · 3 min readBack in February of this year, plans were announced to deprecate TSLint in favor of ESLint. TSLint's goal has become to work toward a “unified developer experience” by supporting ESLint development going forward.
What has changed in oclif​
To keep inline with the community, oclif has transitioned to ESLint for all our core libraries as well as all our official plugins.
Starting in v1.15.x, oclif will now optionally generate projects with ESLint for both TypeScript and JavaScript CLI’s.
ESLint does require Node to be on stable LTS version, at the time of writing, Node 8.10.x, Node 10.13.x & Node 12.x.x.
How does this affect you​
Existing CLI’s are unchanged, but any newly generated CLI's will only give the option of using ESLint. If you are running tslint in your CLI, we recommend you switch to ESLint as well.
In migrating our projects we took the following steps (for an example of these changes see this pull request).


Install eslint
$ yarn add eslint eslint-config-oclif eslint-config-oclif-typescript --dev


Add eslint related files


$ echo '{  "extends": [    "oclif",    "oclif-typescript"  ],  "rules": {  }}' > .eslintrc


Remove tslint and related packages
$ yarn remove @oclif/tslint tslint


Remove tslint related configuration files
$ rm tslint.json


Change lint script in our package.json from something like:
"lint": "tsc -p test --noEmit && tslint -p test -t stylish"
to
"lint": "eslint . --ext .ts --config .eslintrc"


To preserve the test compile (tsc -p test --noEmit) we also made the following updates to our scripts:
"pretest": "tsc -p test --noEmit"
In some cases we had our posttest duplicating the same steps as our lint script so it’s cleaner to have it reference the lint job directly with:
"posttest": "yarn lint"

Run yarn lint --fix. This attempts to auto-fix any linting violations automatically. In the case an auto-fix isn’t available it should be fixed manually or ignored (see the eslint configuration doc for more information)
Do a search in the codebase for tslint and remove any unnecessary tslint disabling comments, like:

/* tslint:disable:object-literal-sort-keys */
If you are on a version of Node that is not supported by ESLint, you will also need to update your Node engine. ESLint supports Node 8, 10, and 12 so you should upgrade to the most recent Node version compatible with your CLI and also supported by ESLint (see ESLint's Installation and Usage instructions).
When will this take effect​
These changes have taken effect in oclif v1.15.1. When you generate a new CLI or plugin it will now contain configuration for ESLint instead of TSLint.oclif's Current Node SupportOctober 31, 2019 · 3 min readTo maintain a healthy project trajectory, oclif follows and supports Node Active LTS release, currently Node 10 & Node 12. This means ensuring that oclif continues to play nice with coming Active LTS Node versions and other packages in the ecosystem. Moving forward also means leaving older versions behind. Starting in 2020, Node will stop maintaining Node 8 and it is our intent at that time to also follow suit. Let’s take a look at a few ways we will be supporting these changes.
CI Environments​
CLIs created with the oclif cli going forward will be generated with a CircleCI configuration with Node 10 & 12 and an Appveyor configuration using Node 10. We have also added Node latest to CircleCi to be an early warning detection against coming Node changes (Node latest is managed by CircleCI).
We have already updated every oclif repo's CI configs to reflect this.
If your existing CLI uses either Appveyor or CircleCI you can update your config files also, like so:
.circleci/config.yml​
Your CircleCI config should contain a node-latest job, aliased as test. From this, there should be two extensions of this job for the Active LTS Node versions, Node 10 and Node 12.
  node-10:    <<: *node-latest    docker:      - image: node:10  node-12:    <<: *node-latest    docker:      - image: node:12
Notice that these declarations only change the Docker Node images used to run that job.
Additionally, the jobs listed within workflows must also be updated to reflect our changes in configuration:
    jobs:      - node-latest      - node-10      - node-12
appveyor.yml​
For appveyor we are currently only testing the oldest Active LTS Node version, Node 10. Update the nodejs_version proppert in your appveyor.yml file to reflect this.
environment:  nodejs_version: "10"
Deprecating Node 8 & Updating packge.json engines​
In Jan 2020, Node will end its Node 8 maintenance. We will follow suit by setting the package.json engine property in oclif packages to >=10 and bumping the package's major versions.
Depending on how you ship your CLI you may wish to also bump the engines version in your CLI's package.json. You can read more about the implications of the engines property configuration in the npm documentation.
Also consider distributing your CLI with its own Node version.
Packaged Node Version​
When using dev-cli to pack your CLI it will use the Node version as specified in your package.json under the oclif.update.node.version property. This value should reflect an Active LTS Node version (dev-cli does not currently enforce versions).
Supporting the future​
As a community we may discover bumps along the way as we upgrade. If you notice something related to oclif please feel free to open an issue or submit a pull request under the relevant oclif package within the org.
We look forward to using the latest from Node and the community and keeping oclif healthy along the way.oclifconf 2019: A RecapSeptember 16, 2019 · 4 min readIn May, Heroku and Salesforce Open Source organized oclifconf, a conference for developers & product managers building CLI tools on top of the open source oclif framework. The speakers came from various tech companies, such as Adobe, Netlify, and Apollo, who have already built amazing CLI experiences. The topics covered everything from the incredible capabilities oclif has unlocked, to the community-built plugins extending its functionality, and even what the behavior of an adaptive CLI tool might look like.
Below is a listing of all of the talks from the event, along with a short summary. Enjoy!
The future of oclif by Jeff Dickey​

In its relatively short lifetime, oclif has already inspired many developers and companies to adopt its framework as a means for implementing their own command-line tooling. In this talk, Jeff Dickey, an oclif founding team member, recaps the project's history and inspiration. He also looks towards the future and outlines some features and improvements that the tool could adapt. This isn't so much a definitive roadmap of where oclif is headed, but rather, a call to inspiration for developers eager to contribute! And if you are interested in contributing, check out the open issues in the oclif GitHub repo and come say "Hello!" on Spectrum Chat.
Open Source Citizenship by Josh Simmons​

When it comes to open source, it's more than just individuals now. More and more frequently, large corporations are contributing to projects by donating to contributors, sponsoring events, or upstreaming contributions. But keeping open source projects and communities healthy requires more than just money and brainpower. Josh Simmons surveyed multiple open source communities and relays his findings as to what help maintainers and contributors actually need in this talk.
Building an enterprise-grade CLI with oclif by Thomas Dvornik​

Security and performance are all about trust. While oclif is an extremely extensible framework for building CLI tooling, there are additional requirements to fulfill for enterprise businesses to adopt it that might not be necessary for individual developers. Thomas Dvornik outlines what he and his colleagues at Salesforce have implemented as plugins to oclif to satisfy these needs, including encrypted OAuth, plugin signing, lazy loading dependencies, synchronizing weekly releases and deprecations across dozens of repositories, and establishing cross-team coding and documentation standards.
How Adobe I/O built an extensible CLI with oclif by Jesse MacFadyen​

Perhaps oclif's most appealing feature is its support for plugins. In Cordova's case, they've created a sophisticated telemetry system that helps Adobe developers see which commands users are using--and reports on which ones are erroring out. By embedding a feedback system into the tool, users are even able to quickly send their suggestions to a form, without ever leaving the terminal. Jesse MacFadyen demonstrates how oclif's plugin system can work beyond simply executing commands.
Integrating oclif with GraphQL and Apollo by Evans Hauser​

For Evans Hauser and the team at Apollo, oclif is best thought of as "React for the CLI." As a client paired with a strongly-typed API contract to a server, it can deliver structured and consistent commands to retrieve external data. What better mechanism to use for this transfer than GraphQL, a framework which empowers the client to ask precisely for the data it needs, and nothing more?
Adaptive Intent-based CLI State Machines by Shawn Wang​

In designing oclif, Jeff Dickey wrote out 12 CLI factors to keep in mind. In this talk, Shawn Wang outlines a 13th: state. State is hard, because it depends on context, and context depends on understanding what a user intends to do, not what they are asking. Shawn is working towards enabling oclif to better understand the commands a user has entered, so that it can predict and interpret future commands that might be entered next. This would enable CLI tools to not just interpret a users' commands, but to also interpret their intent.\n\nIntroducing `oclif init` commandApril 10, 2024 · 2 min readThanks to the contribution of @joshcanhelp we released a new command for the oclif CLI called oclif init in version 4.8.0
The oclif init command allows you to initialize oclif in an existing project directory by adding the bare minimum requirements: a few pieces of configuration, bin scripts, and a couple of dependencies (@oclif/core and ts-node). This is slightly different from oclif generate, which will create an entirely new oclif project based on our templates.
oclif init will add the following:

bin scripts: bin/run.js, bin/run.cmd, bin/dev.js, and bin/dev.cmd
oclif section to package.json with bin, dirname, commands, and topicSeparator set (See Configuring Your CLI for more)
@oclif/core to dependencies in your package.json (if it's not already there)
ts-node to devDependencies in your package.json (if it's not already there)

Once you've initialized oclif, you can use the bin scripts to execute your CLI. You can also use the other oclif commands like oclif generate command and oclif generate hook to start adding new functionality.

❯ oclif init --helpInitialize a new oclif CLIUSAGE  $ oclif init [--bin <value>] [--module-type ESM|CommonJS] [--package-manager npm|yarn|pnpm] [--topic-separator    colons|spaces] [-d <value>] [-y]FLAGS  -d, --output-dir=<value>        Directory to initialize the CLI in.  -y, --yes                       Use defaults for all prompts. Individual flags will override defaults.      --bin=<value>               Supply answer for prompt: Command bin name the CLI will export      --module-type=<option>      Supply answer for prompt: Select a module type                                  <options: ESM|CommonJS>      --package-manager=<option>  Supply answer for prompt: Select a package manager                                  <options: npm|yarn|pnpm>      --topic-separator=<option>  Supply answer for prompt: Select a topic separator                                  <options: colons|spaces>DESCRIPTION  Initialize a new oclif CLI  This will add the necessary oclif bin files, add oclif config to package.json, and install @oclif/core and ts-node.EXAMPLES  Initialize a new CLI in the current directory    $ oclif init  Initialize a new CLI in a different directory    $ oclif init --output-dir "/path/to/existing/project"  Supply answers for specific prompts    $ oclif init --topic-separator colons --bin mycli
Hope you enjoy the new command! If you come across any issues or have any new ideas for this command, head over to the oclif/oclif repo and open a new issue.
All our best,
The oclif teamoclif Spring 2024 UpdateMarch 29, 2024 · 4 min readHello oclif developers! It's been a while since we last uploaded a blog - and a lot has happened.
We've been focusing on these high-level areas over the past couple of years:

Improving @oclif/core
ESM Support
Improving and revitalizing oclif.io
Re-engaging the oclif community

Improving @oclif/core​
Since we announced @oclif/core over three years ago, we've released two new major versions, each packed with lots of features that we're really excited about.
Here are some of these changes:

Full support for ESM and interoperability with CommonJS (more on this topic below).
Configurable command discovery strategies that give you more control over how commands are loaded at runtime. Check out the docs.
A new preparse hook that allows you to manipulate the provided arguments before they're parsed. Salesforce used this hook to implement a neat --flags-dir feature that translates local files into flags.
A new Performance class that you can use to track performance inside of @oclif/core and your own CLI or plugin. Check out the docs.
A new flag type, Flags.option, that lets you define a flag with a preset list of options. Typescript then uses the options to infer the flag's type.
Flags now have a relationship property that allows you to define more complex relationships between flags. Check out the flags docs for more information.
Flags now have a defaultHelp property that allows you to set the human readable default value in the command help. This property is useful when your flag's parse method returns a complex type, such as an object or a class. Check out the flags docs for more.
Commands now have a hiddenAliases property that allows you to define aliases that you want to hide from the user. The property is super helpful when you're trying to wean users off a deprecated command.
You can now use bun or tsx as dev runtimes (as opposed to node or ts-node).
A command's usage, args, and flags are now shown whenever a user forgets to provide a required arg or flag, or when they provided a non-existent flag.

If you need help migrating to the latest version, head over to core's README which has links to the migration guides. Feel free to open a new discussion if you need more hands-on help from us or the community.
ESM Support​
Version 3 of @oclif/core introduced full support for developing ESM plugins and CLIs. It also offered full support for interoperability between CommonJS and ESM plugins.
Put more simply, you can now migrate your CLI to ESM while keeping individual plugins in CommonJS (or vice versa). The upgrade path is now much simpler for you. You also don't need to worry about any community plugins that have migrated to ESM before you did (such as all the @oclif plugins) or are staunchly sticking with CommonJS for the foreseeable future.
Read more about this topic here.
Improving and Revitalizing oclif.io​
Another area of focus for us has been improving our documentation site, oclif.io.
While improving the quality and accuracy of the documentation was our priority, we also took the time to upgrade to the latest version of docusaurus. This new version gave our site a much-needed facelift, as well as cool new features such as dark mode and announcements.
If you have any feedback or are running into issues, we want to hear about it. Just create an issue in the oclif.io repo.
Re-engaging the oclif Community​
Lastly, our biggest priority at the moment is to re-engage the oclif community. We understand how frustrating it has been over the years to see your issues and pull requests go unacknowledged. We apologize for not prioritizing the community, and are earnestly trying to make sure that every issue and pull request gets the attention it deserves going forward.
We also opened up GitHub discussions for @oclif/core and the oclif CLI, where you can now post your questions or ideas. We hope you take advantage of them, we love hearing from you!
One last thing: we intend to publicly post our roadmap so you have more visibility into what we're working on. Stay tuned!
All our best,
The oclif teamAnnouncing oclif v2!January 12, 2022 · 5 min readHello and happy new year! It's our great pleasure to announce that we have released oclif v2, which uses the new @oclif/core library! 🎉
oclif v2 includes many changes that improve the experience of both creating and using an oclif CLI.
Going forward, we don't plan to make any updates to oclif v1 and its corresponding libraries, except for critical security fixes. See the compatibility matrix for a list of these libraries. In order to give developers time to migrate from v1 to v2, we're not completely dropping support yet. But at some point in the future we'll archive the v1 repositories and deprecate their versions on npm.
What’s changing?​
Repository Changes​
All repositories under the oclif org now use main as their primary branch and oclif-v1 as the legacy branch. The main  branch corresponds to oclif v2 and the oclif-v1 branch to oclif v1. If you find any repos that don’t have a main branch, you can safely assume that they're not used in oclif v2 and will be deprecated in the future.
Consolidating Tools & Libraries​
The oclif-dev CLI has now been incorporated into oclif. You now no longer need to install a separate package to manage your entire CLI’s lifecycle.
The following libraries have been consolidated under @oclif/core and will be deprecated at some point in the future. Read the migration guide to learn how to update your CLI or plugin to use the new core library.

@oclif/command
@oclif/config
@oclif/error
@oclif/help
@oclif/parser

No more single vs multi command CLIs​
There's only one "type" of oclif v2 CLI, but it can have as few or as many commands as a developer wants. As a result, there’s only one command to generate CLIs, oclif generate, as opposed to the old oclif single and oclif multi commands.
Node > 12​
To ensure oclif CLIs are as secure as possible, all v2 libraries and plugins support only Node 12 or higher as of now. Going forward, they'll support only Node Maintenance or higher, as defined by Node's release schedule here: https://nodejs.org/en/about/releases/.
What’s new?​
New example CLI​
oclif-hello-world is our new example repo. This is also the repo that's used as a template when running oclif generate to create a new CLI. This repo will always be able to be referenced as an example of what an oclif v2 CLI should look like.
Spaced commands​
oclif CLIs can now use spaces, instead of colons, to separate topics and subcommands. To enable this feature, simply add “topicSeparator": " " to the oclif config in your package.json. See an example in our example repo.
// Old commands that use :$ mycli do:something
// New spaced commands$ mycli do something

Note: Spaced commands are backwards compatible. So if you enable spaced commands for your CLI, users will still be able to use : as a separator. This ensures that any existing scripts don't break.

New Help Output​
We’ve revamped the way command help is outputted to the terminal, making it both easier to implement and easier to read. See the difference between the old help output on the left and the new help output on the right in the screenshots below.
oclif v1oclif v2
Notice that there are new sections for flags and global flags, examples are displayed with better spacing, and there is a section at the bottom called Configuration Variables. This Configuration Variables section is not part of the new help by default. But we've added support for custom help sections, which is what the sf CLI uses to create the new section.
Async Command Parsing​
We’ve also improved the performance of new CLIs by rewriting how commands are parsed on initialization. The new parser is asynchronous, which makes CLIs with a lot of commands or installed  plugins much faster.
What’s coming next?​
Part of our charter for the release of oclif v2 includes improving our engagement with the oclif community. We know that over the past couple of years we’ve reduced our involvement, and a lot of issues and PRs have languished in limbo. Hopefully you’ve already seen increased activity and responses from oclif maintainers recently, but if you haven’t, please don’t hesitate to ping us by tagging @admins in oclif repos.
We also want to start interviewing members of the oclif community to acquire feedback and prioritize the features and fixes you deem most important!
Best,
The oclif team

Reference material​
Migration Guide​
This guide explains how to upgrade a CLI or plugin from the old oclif v1 libraries to the new @oclif/core library that oclif v2 uses.
https://github.com/oclif/core/blob/main/MIGRATION.md
Compatibility Matrix​
The following matrix shows how the v1 libraries and plugins relate to the new v2 ones. Use this matrix as a guide to know what to drop and which versions to switch when upgrading your plugins and CLIs to v2.
oclif "v1"oclif "v2"Utility CLIsoclif@<2@oclif/dev-cli@<2oclif@>=2Main packages@oclif/command@oclif/config@oclif/errors@oclif/parser@oclif/plugin-help@oclif/core@>=1Node LTSNode v8-14Node v12+ (at time of writing)TypeScripttypescript@<4typescript@>=4Main plugins@oclif/plugin-autocomplete@<1@oclif/plugin-commands@<2@oclif/plugin-help@<4@oclif/plugin-not-found@<2@oclif/plugin-plugins@<2@oclif/plugin-update@<2plugin-warn-if-update-available@<2plugin-which@<2@oclif/plugin-autocomplete@>=1@oclif/plugin-commands@>=2@oclif/plugin-help@>=4@oclif/plugin-not-found@>=2@oclif/plugin-plugins@>=2@oclif/plugin-update@>=2@oclif/plugin-warn-if-update-available@>=2@oclif/plugin-which@>=2Introducing @oclif/coreMarch 1, 2021 · 3 min readGreetings!
We hope this blog post finds you well.
Introducing...​
We are excited to announce the next iteration of the oclif project today: @oclif/core.
We have learned a lot in the last three years of developing oclif, developing on oclif and supporting millions of command runs a day via Heroku and Salesforce CLIs.
@oclif/core ("Core") simplifies the oclif development experience and introduces highly requested new features.
Core combines the essential oclif packages into one "core" package, aptly named @oclif/core.
Core also introduces:

A default command option
Colon or space command syntax
Async command parsing
Command piping to arguments

With the introduction of default command functionality, Core simplifies the oclif project and removes the notion of single or multi command CLIs. Core CLIs can have 1 or many commands.
Along with Core, we moved the oclif-dev CLI into the oclif CLI creating a single "utility" CLI. This CLI also introduces a new AWS S3 compatible publishing scheme.
What to expect in the near future​
Core is in pre-release beta and being actively developed for new internal Salesforce CLIs.
Much documentation needs to be written in the coming months including migration paths. Migration onto Core should be as painless as possible with many exports remaining entirely unchanged. Look for forthcoming blog posts and documentation on oclif.io.
Early this summer, tentively June 1, we will release Core v1. Core's release will coincide with major bumps to many other oclif plugin packages. See the compatibility matrix below.
At Core's v1 release, the current "main" oclif packages (namely: command, config, errors & parser) will go into maintenance mode until Jan 2022. They will receive only bug and security fixes and they remain compatible with current versions of the oclif and oclif-dev CLIs. Afterwhich, they will be archived.
Companioning Core, the next major release of the oclif CLI (literally oclif@2) will generate Core CLIs.
Going forward​
We are excited to release Core! We invite you to poke around the Core repo. It may appear to be a big change but Core keeps what you already enjoy about oclif while reducing development complexity, project dependencies, package coupling and bundle size and introduces many requested features previously too prickly to weave into the current oclif architecture.
Best,
The oclif team
Reference: Compatibility matrix​
oclif "v1"oclif "Core"Utility CLIsoclif@<2@oclif/dev-cli@<2oclif@>=2Main packages@oclif/core@<2@oclif/config@<2@oclif/errors@<2@oclif/parser@<4@oclif/plugin-help@<4@oclif/core@>=1Node LTSNode v8-14Node v12+TypeScripttypescript@<4typescript@>=4Main plugins@oclif/plugin-autocomplete@<1@oclif/plugin-commands@<2@oclif/plugin-help@<4@oclif/plugin-not-found@<2@oclif/plugin-plugins@<2@oclif/plugin-update@<2plugin-warn-if-update-available@<2plugin-which@<2@oclif/plugin-autocomplete@>=2@oclif/plugin-commands@>=2@oclif/plugin-help@>=4@oclif/plugin-not-found@>=2@oclif/plugin-plugins@>=2@oclif/plugin-update@>=2@oclif/plugin-warn-if-update-available@>=2@oclif/plugin-which@>=2oclif Summer 2020 UpdateAugust 26, 2020 · 2 min readHello oclif developers! We hope you are all doing well.
Earlier this year, we started our planning for oclifconf v2 and, like all conference, had to change course. We opted not to hold a virtual conference, however, we wanted to take some time to highlight a few oclif features shipped this year.
Feature: Help templating​
One of the most requested features, help templating enables oclif developers to customize the help output for their CLI.
Read the announcement.
Feature: Custom error delegation​
This feature both improved how oclif throws and handles errors and allows oclif developers to overwrite or interject in oclif’s error handling.
Read the announcement.
Feature: postrun hooks​
We have added a new lifecycle event postrun. Your CLI can now run a hook after a command has ran.
See our hook documentation.
Feature: Root index command​
Previously, oclif would display CLI help if only the binary name with no command ID was invoked, oclif now supports a "root index" command. If present, a command defined at src/commands/index.ts will be run if no command ID is found.
1 million weekly downloads​
While exact oclif usage metrics are hard to pin down, we use npm download statistics of oclif packages as a rough approximation. Earlier this year, oclif's command package hit 1 million weekly downloads for the first time!
This year has been presented its challenges on everyone. We want to thank you, oclif developers, whom have taken the time to use and improve the oclif project. We look forward to seeing you all - in person - in the future!
All our best,
The oclif teamPretty Printable ErrorsJuly 1, 2020 · One min readOften CLIs are used as handy tools and when things go wrong it’s useful to have additional context. In oclif we have added a couple of additional properties that can show extra context to the users when an error is displayed. The code, ref and suggestions will now be displayed if they are included. This will work with an existing oclif CLI by adding the latest @oclif/errors and @oclif/core to the CLI's package.json dependencies.
For example, using this.error with the additional properties:
class TestError extends Command {  async run() {    this.error("An error has occurred!", {      code: "OCLIF_ERR",      ref: "https://oclif.io/docs/commands#thiserrormessage-string--error-options-code-string-exit-number",      suggestions: ["Use these extra properties to provide additional context"],    })  }}
would result with the following output:
›   Error: An error has occurred!›   Code: OCLIF_ERR›   Try this: Use these extra properties to provide additional context›   Reference: https://oclif.io/docs/commands#thiserrormessage-string--error-options-code-string-exit-number
If these properties are not provided then nothing changes and the CLI will continue to display the single error message output as it did before. Additionally, as part of this exercise we’ve added documentation around Error Handling in oclif which should come in handy if the need arises to extend oclif’s default handling of errors.Customizing Help in oclifMay 5, 2020 · 2 min readOut of the box oclif provides a great help experience for CLIs.
But what if, as an oclif developer, you want to customize some or all of the output?
You can now customize your CLI's help output by implementing the HelpBase abstract class.
Getting started with custom help​
If you have not done so yet, update @oclif/core.
$ yarn add --latest @oclif/core
To get started, first define the filepath to your help class in oclif's config in package.json. This is a relative path to the help class, without a file extension.
For this example, the help class will be created in a file at "[project root]/src/help.ts".
{  // ...  "oclif": {    "helpClass": "./lib/help"    // ...  }  // ...}
From here there are two paths, implement the HelpBase abstract class yourself or overwrite the parts of the default Help class you want to customize (ex: how command usage is displayed). We recommend the latter approach but cover both in the new Help Classes docs.
Separating TOPICS & COMMANDS in the new default Help class​
Previously, topics and child commands were listed in help output under a single list heading called "COMMANDS". But we found this can be slightly confusing. Some topics are commands also (a.k.a. topic-commands) while others are simply organizational namespacing (and when ran just show their help).
The new default Help class splits the list of children into distinct lists of "TOPICS" and "COMMANDS", with the possibility of an item appearing in both if it a topic-command. This makes it clearer what is expected to be ran - "COMMANDS" - and what is providing structure - "TOPICS" - when looking at the help output.
VERSION  plugin-help-example/0.0.0 darwin-x64 node-v12.12.0USAGE  $ plugin-help-example [COMMAND]TOPICS  topic  this is a topic and has child topics or commandsCOMMANDS  hello  describe the command here  help   display help for plugin-help-example
We look forward to seeing what custom help features you implement in your oclif CLIs with this new feature!oclif TSLint to ESLint MigrationDecember 5, 2019 · 3 min readBack in February of this year, plans were announced to deprecate TSLint in favor of ESLint. TSLint's goal has become to work toward a “unified developer experience” by supporting ESLint development going forward.
What has changed in oclif​
To keep inline with the community, oclif has transitioned to ESLint for all our core libraries as well as all our official plugins.
Starting in v1.15.x, oclif will now optionally generate projects with ESLint for both TypeScript and JavaScript CLI’s.
ESLint does require Node to be on stable LTS version, at the time of writing, Node 8.10.x, Node 10.13.x & Node 12.x.x.
How does this affect you​
Existing CLI’s are unchanged, but any newly generated CLI's will only give the option of using ESLint. If you are running tslint in your CLI, we recommend you switch to ESLint as well.
In migrating our projects we took the following steps (for an example of these changes see this pull request).


Install eslint
$ yarn add eslint eslint-config-oclif eslint-config-oclif-typescript --dev


Add eslint related files


$ echo '{  "extends": [    "oclif",    "oclif-typescript"  ],  "rules": {  }}' > .eslintrc


Remove tslint and related packages
$ yarn remove @oclif/tslint tslint


Remove tslint related configuration files
$ rm tslint.json


Change lint script in our package.json from something like:
"lint": "tsc -p test --noEmit && tslint -p test -t stylish"
to
"lint": "eslint . --ext .ts --config .eslintrc"


To preserve the test compile (tsc -p test --noEmit) we also made the following updates to our scripts:
"pretest": "tsc -p test --noEmit"
In some cases we had our posttest duplicating the same steps as our lint script so it’s cleaner to have it reference the lint job directly with:
"posttest": "yarn lint"

Run yarn lint --fix. This attempts to auto-fix any linting violations automatically. In the case an auto-fix isn’t available it should be fixed manually or ignored (see the eslint configuration doc for more information)
Do a search in the codebase for tslint and remove any unnecessary tslint disabling comments, like:

/* tslint:disable:object-literal-sort-keys */
If you are on a version of Node that is not supported by ESLint, you will also need to update your Node engine. ESLint supports Node 8, 10, and 12 so you should upgrade to the most recent Node version compatible with your CLI and also supported by ESLint (see ESLint's Installation and Usage instructions).
When will this take effect​
These changes have taken effect in oclif v1.15.1. When you generate a new CLI or plugin it will now contain configuration for ESLint instead of TSLint.oclif's Current Node SupportOctober 31, 2019 · 3 min readTo maintain a healthy project trajectory, oclif follows and supports Node Active LTS release, currently Node 10 & Node 12. This means ensuring that oclif continues to play nice with coming Active LTS Node versions and other packages in the ecosystem. Moving forward also means leaving older versions behind. Starting in 2020, Node will stop maintaining Node 8 and it is our intent at that time to also follow suit. Let’s take a look at a few ways we will be supporting these changes.
CI Environments​
CLIs created with the oclif cli going forward will be generated with a CircleCI configuration with Node 10 & 12 and an Appveyor configuration using Node 10. We have also added Node latest to CircleCi to be an early warning detection against coming Node changes (Node latest is managed by CircleCI).
We have already updated every oclif repo's CI configs to reflect this.
If your existing CLI uses either Appveyor or CircleCI you can update your config files also, like so:
.circleci/config.yml​
Your CircleCI config should contain a node-latest job, aliased as test. From this, there should be two extensions of this job for the Active LTS Node versions, Node 10 and Node 12.
  node-10:    <<: *node-latest    docker:      - image: node:10  node-12:    <<: *node-latest    docker:      - image: node:12
Notice that these declarations only change the Docker Node images used to run that job.
Additionally, the jobs listed within workflows must also be updated to reflect our changes in configuration:
    jobs:      - node-latest      - node-10      - node-12
appveyor.yml​
For appveyor we are currently only testing the oldest Active LTS Node version, Node 10. Update the nodejs_version proppert in your appveyor.yml file to reflect this.
environment:  nodejs_version: "10"
Deprecating Node 8 & Updating packge.json engines​
In Jan 2020, Node will end its Node 8 maintenance. We will follow suit by setting the package.json engine property in oclif packages to >=10 and bumping the package's major versions.
Depending on how you ship your CLI you may wish to also bump the engines version in your CLI's package.json. You can read more about the implications of the engines property configuration in the npm documentation.
Also consider distributing your CLI with its own Node version.
Packaged Node Version​
When using dev-cli to pack your CLI it will use the Node version as specified in your package.json under the oclif.update.node.version property. This value should reflect an Active LTS Node version (dev-cli does not currently enforce versions).
Supporting the future​
As a community we may discover bumps along the way as we upgrade. If you notice something related to oclif please feel free to open an issue or submit a pull request under the relevant oclif package within the org.
We look forward to using the latest from Node and the community and keeping oclif healthy along the way.oclifconf 2019: A RecapSeptember 16, 2019 · 4 min readIn May, Heroku and Salesforce Open Source organized oclifconf, a conference for developers & product managers building CLI tools on top of the open source oclif framework. The speakers came from various tech companies, such as Adobe, Netlify, and Apollo, who have already built amazing CLI experiences. The topics covered everything from the incredible capabilities oclif has unlocked, to the community-built plugins extending its functionality, and even what the behavior of an adaptive CLI tool might look like.
Below is a listing of all of the talks from the event, along with a short summary. Enjoy!
The future of oclif by Jeff Dickey​

In its relatively short lifetime, oclif has already inspired many developers and companies to adopt its framework as a means for implementing their own command-line tooling. In this talk, Jeff Dickey, an oclif founding team member, recaps the project's history and inspiration. He also looks towards the future and outlines some features and improvements that the tool could adapt. This isn't so much a definitive roadmap of where oclif is headed, but rather, a call to inspiration for developers eager to contribute! And if you are interested in contributing, check out the open issues in the oclif GitHub repo and come say "Hello!" on Spectrum Chat.
Open Source Citizenship by Josh Simmons​

When it comes to open source, it's more than just individuals now. More and more frequently, large corporations are contributing to projects by donating to contributors, sponsoring events, or upstreaming contributions. But keeping open source projects and communities healthy requires more than just money and brainpower. Josh Simmons surveyed multiple open source communities and relays his findings as to what help maintainers and contributors actually need in this talk.
Building an enterprise-grade CLI with oclif by Thomas Dvornik​

Security and performance are all about trust. While oclif is an extremely extensible framework for building CLI tooling, there are additional requirements to fulfill for enterprise businesses to adopt it that might not be necessary for individual developers. Thomas Dvornik outlines what he and his colleagues at Salesforce have implemented as plugins to oclif to satisfy these needs, including encrypted OAuth, plugin signing, lazy loading dependencies, synchronizing weekly releases and deprecations across dozens of repositories, and establishing cross-team coding and documentation standards.
How Adobe I/O built an extensible CLI with oclif by Jesse MacFadyen​

Perhaps oclif's most appealing feature is its support for plugins. In Cordova's case, they've created a sophisticated telemetry system that helps Adobe developers see which commands users are using--and reports on which ones are erroring out. By embedding a feedback system into the tool, users are even able to quickly send their suggestions to a form, without ever leaving the terminal. Jesse MacFadyen demonstrates how oclif's plugin system can work beyond simply executing commands.
Integrating oclif with GraphQL and Apollo by Evans Hauser​

For Evans Hauser and the team at Apollo, oclif is best thought of as "React for the CLI." As a client paired with a strongly-typed API contract to a server, it can deliver structured and consistent commands to retrieve external data. What better mechanism to use for this transfer than GraphQL, a framework which empowers the client to ask precisely for the data it needs, and nothing more?
Adaptive Intent-based CLI State Machines by Shawn Wang​

In designing oclif, Jeff Dickey wrote out 12 CLI factors to keep in mind. In this talk, Shawn Wang outlines a 13th: state. State is hard, because it depends on context, and context depends on understanding what a user intends to do, not what they are asking. Shawn is working towards enabling oclif to better understand the commands a user has entered, so that it can predict and interpret future commands that might be entered next. This would enable CLI tools to not just interpret a users' commands, but to also interpret their intent.Older Entries\n\n\n\nIntroducing `oclif init` commandApril 10, 2024 · 2 min readThanks to the contribution of @joshcanhelp we released a new command for the oclif CLI called oclif init in version 4.8.0
The oclif init command allows you to initialize oclif in an existing project directory by adding the bare minimum requirements: a few pieces of configuration, bin scripts, and a couple of dependencies (@oclif/core and ts-node). This is slightly different from oclif generate, which will create an entirely new oclif project based on our templates.
oclif init will add the following:

bin scripts: bin/run.js, bin/run.cmd, bin/dev.js, and bin/dev.cmd
oclif section to package.json with bin, dirname, commands, and topicSeparator set (See Configuring Your CLI for more)
@oclif/core to dependencies in your package.json (if it's not already there)
ts-node to devDependencies in your package.json (if it's not already there)

Once you've initialized oclif, you can use the bin scripts to execute your CLI. You can also use the other oclif commands like oclif generate command and oclif generate hook to start adding new functionality.

❯ oclif init --helpInitialize a new oclif CLIUSAGE  $ oclif init [--bin <value>] [--module-type ESM|CommonJS] [--package-manager npm|yarn|pnpm] [--topic-separator    colons|spaces] [-d <value>] [-y]FLAGS  -d, --output-dir=<value>        Directory to initialize the CLI in.  -y, --yes                       Use defaults for all prompts. Individual flags will override defaults.      --bin=<value>               Supply answer for prompt: Command bin name the CLI will export      --module-type=<option>      Supply answer for prompt: Select a module type                                  <options: ESM|CommonJS>      --package-manager=<option>  Supply answer for prompt: Select a package manager                                  <options: npm|yarn|pnpm>      --topic-separator=<option>  Supply answer for prompt: Select a topic separator                                  <options: colons|spaces>DESCRIPTION  Initialize a new oclif CLI  This will add the necessary oclif bin files, add oclif config to package.json, and install @oclif/core and ts-node.EXAMPLES  Initialize a new CLI in the current directory    $ oclif init  Initialize a new CLI in a different directory    $ oclif init --output-dir "/path/to/existing/project"  Supply answers for specific prompts    $ oclif init --topic-separator colons --bin mycli
Hope you enjoy the new command! If you come across any issues or have any new ideas for this command, head over to the oclif/oclif repo and open a new issue.
All our best,
The oclif teamoclif Spring 2024 UpdateMarch 29, 2024 · 4 min readHello oclif developers! It's been a while since we last uploaded a blog - and a lot has happened.
We've been focusing on these high-level areas over the past couple of years:

Improving @oclif/core
ESM Support
Improving and revitalizing oclif.io
Re-engaging the oclif community

Improving @oclif/core​
Since we announced @oclif/core over three years ago, we've released two new major versions, each packed with lots of features that we're really excited about.
Here are some of these changes:

Full support for ESM and interoperability with CommonJS (more on this topic below).
Configurable command discovery strategies that give you more control over how commands are loaded at runtime. Check out the docs.
A new preparse hook that allows you to manipulate the provided arguments before they're parsed. Salesforce used this hook to implement a neat --flags-dir feature that translates local files into flags.
A new Performance class that you can use to track performance inside of @oclif/core and your own CLI or plugin. Check out the docs.
A new flag type, Flags.option, that lets you define a flag with a preset list of options. Typescript then uses the options to infer the flag's type.
Flags now have a relationship property that allows you to define more complex relationships between flags. Check out the flags docs for more information.
Flags now have a defaultHelp property that allows you to set the human readable default value in the command help. This property is useful when your flag's parse method returns a complex type, such as an object or a class. Check out the flags docs for more.
Commands now have a hiddenAliases property that allows you to define aliases that you want to hide from the user. The property is super helpful when you're trying to wean users off a deprecated command.
You can now use bun or tsx as dev runtimes (as opposed to node or ts-node).
A command's usage, args, and flags are now shown whenever a user forgets to provide a required arg or flag, or when they provided a non-existent flag.

If you need help migrating to the latest version, head over to core's README which has links to the migration guides. Feel free to open a new discussion if you need more hands-on help from us or the community.
ESM Support​
Version 3 of @oclif/core introduced full support for developing ESM plugins and CLIs. It also offered full support for interoperability between CommonJS and ESM plugins.
Put more simply, you can now migrate your CLI to ESM while keeping individual plugins in CommonJS (or vice versa). The upgrade path is now much simpler for you. You also don't need to worry about any community plugins that have migrated to ESM before you did (such as all the @oclif plugins) or are staunchly sticking with CommonJS for the foreseeable future.
Read more about this topic here.
Improving and Revitalizing oclif.io​
Another area of focus for us has been improving our documentation site, oclif.io.
While improving the quality and accuracy of the documentation was our priority, we also took the time to upgrade to the latest version of docusaurus. This new version gave our site a much-needed facelift, as well as cool new features such as dark mode and announcements.
If you have any feedback or are running into issues, we want to hear about it. Just create an issue in the oclif.io repo.
Re-engaging the oclif Community​
Lastly, our biggest priority at the moment is to re-engage the oclif community. We understand how frustrating it has been over the years to see your issues and pull requests go unacknowledged. We apologize for not prioritizing the community, and are earnestly trying to make sure that every issue and pull request gets the attention it deserves going forward.
We also opened up GitHub discussions for @oclif/core and the oclif CLI, where you can now post your questions or ideas. We hope you take advantage of them, we love hearing from you!
One last thing: we intend to publicly post our roadmap so you have more visibility into what we're working on. Stay tuned!
All our best,
The oclif teamAnnouncing oclif v2!January 12, 2022 · 5 min readHello and happy new year! It's our great pleasure to announce that we have released oclif v2, which uses the new @oclif/core library! 🎉
oclif v2 includes many changes that improve the experience of both creating and using an oclif CLI.
Going forward, we don't plan to make any updates to oclif v1 and its corresponding libraries, except for critical security fixes. See the compatibility matrix for a list of these libraries. In order to give developers time to migrate from v1 to v2, we're not completely dropping support yet. But at some point in the future we'll archive the v1 repositories and deprecate their versions on npm.
What’s changing?​
Repository Changes​
All repositories under the oclif org now use main as their primary branch and oclif-v1 as the legacy branch. The main  branch corresponds to oclif v2 and the oclif-v1 branch to oclif v1. If you find any repos that don’t have a main branch, you can safely assume that they're not used in oclif v2 and will be deprecated in the future.
Consolidating Tools & Libraries​
The oclif-dev CLI has now been incorporated into oclif. You now no longer need to install a separate package to manage your entire CLI’s lifecycle.
The following libraries have been consolidated under @oclif/core and will be deprecated at some point in the future. Read the migration guide to learn how to update your CLI or plugin to use the new core library.

@oclif/command
@oclif/config
@oclif/error
@oclif/help
@oclif/parser

No more single vs multi command CLIs​
There's only one "type" of oclif v2 CLI, but it can have as few or as many commands as a developer wants. As a result, there’s only one command to generate CLIs, oclif generate, as opposed to the old oclif single and oclif multi commands.
Node > 12​
To ensure oclif CLIs are as secure as possible, all v2 libraries and plugins support only Node 12 or higher as of now. Going forward, they'll support only Node Maintenance or higher, as defined by Node's release schedule here: https://nodejs.org/en/about/releases/.
What’s new?​
New example CLI​
oclif-hello-world is our new example repo. This is also the repo that's used as a template when running oclif generate to create a new CLI. This repo will always be able to be referenced as an example of what an oclif v2 CLI should look like.
Spaced commands​
oclif CLIs can now use spaces, instead of colons, to separate topics and subcommands. To enable this feature, simply add “topicSeparator": " " to the oclif config in your package.json. See an example in our example repo.
// Old commands that use :$ mycli do:something
// New spaced commands$ mycli do something

Note: Spaced commands are backwards compatible. So if you enable spaced commands for your CLI, users will still be able to use : as a separator. This ensures that any existing scripts don't break.

New Help Output​
We’ve revamped the way command help is outputted to the terminal, making it both easier to implement and easier to read. See the difference between the old help output on the left and the new help output on the right in the screenshots below.
oclif v1oclif v2
Notice that there are new sections for flags and global flags, examples are displayed with better spacing, and there is a section at the bottom called Configuration Variables. This Configuration Variables section is not part of the new help by default. But we've added support for custom help sections, which is what the sf CLI uses to create the new section.
Async Command Parsing​
We’ve also improved the performance of new CLIs by rewriting how commands are parsed on initialization. The new parser is asynchronous, which makes CLIs with a lot of commands or installed  plugins much faster.
What’s coming next?​
Part of our charter for the release of oclif v2 includes improving our engagement with the oclif community. We know that over the past couple of years we’ve reduced our involvement, and a lot of issues and PRs have languished in limbo. Hopefully you’ve already seen increased activity and responses from oclif maintainers recently, but if you haven’t, please don’t hesitate to ping us by tagging @admins in oclif repos.
We also want to start interviewing members of the oclif community to acquire feedback and prioritize the features and fixes you deem most important!
Best,
The oclif team

Reference material​
Migration Guide​
This guide explains how to upgrade a CLI or plugin from the old oclif v1 libraries to the new @oclif/core library that oclif v2 uses.
https://github.com/oclif/core/blob/main/MIGRATION.md
Compatibility Matrix​
The following matrix shows how the v1 libraries and plugins relate to the new v2 ones. Use this matrix as a guide to know what to drop and which versions to switch when upgrading your plugins and CLIs to v2.
oclif "v1"oclif "v2"Utility CLIsoclif@<2@oclif/dev-cli@<2oclif@>=2Main packages@oclif/command@oclif/config@oclif/errors@oclif/parser@oclif/plugin-help@oclif/core@>=1Node LTSNode v8-14Node v12+ (at time of writing)TypeScripttypescript@<4typescript@>=4Main plugins@oclif/plugin-autocomplete@<1@oclif/plugin-commands@<2@oclif/plugin-help@<4@oclif/plugin-not-found@<2@oclif/plugin-plugins@<2@oclif/plugin-update@<2plugin-warn-if-update-available@<2plugin-which@<2@oclif/plugin-autocomplete@>=1@oclif/plugin-commands@>=2@oclif/plugin-help@>=4@oclif/plugin-not-found@>=2@oclif/plugin-plugins@>=2@oclif/plugin-update@>=2@oclif/plugin-warn-if-update-available@>=2@oclif/plugin-which@>=2Introducing @oclif/coreMarch 1, 2021 · 3 min readGreetings!
We hope this blog post finds you well.
Introducing...​
We are excited to announce the next iteration of the oclif project today: @oclif/core.
We have learned a lot in the last three years of developing oclif, developing on oclif and supporting millions of command runs a day via Heroku and Salesforce CLIs.
@oclif/core ("Core") simplifies the oclif development experience and introduces highly requested new features.
Core combines the essential oclif packages into one "core" package, aptly named @oclif/core.
Core also introduces:

A default command option
Colon or space command syntax
Async command parsing
Command piping to arguments

With the introduction of default command functionality, Core simplifies the oclif project and removes the notion of single or multi command CLIs. Core CLIs can have 1 or many commands.
Along with Core, we moved the oclif-dev CLI into the oclif CLI creating a single "utility" CLI. This CLI also introduces a new AWS S3 compatible publishing scheme.
What to expect in the near future​
Core is in pre-release beta and being actively developed for new internal Salesforce CLIs.
Much documentation needs to be written in the coming months including migration paths. Migration onto Core should be as painless as possible with many exports remaining entirely unchanged. Look for forthcoming blog posts and documentation on oclif.io.
Early this summer, tentively June 1, we will release Core v1. Core's release will coincide with major bumps to many other oclif plugin packages. See the compatibility matrix below.
At Core's v1 release, the current "main" oclif packages (namely: command, config, errors & parser) will go into maintenance mode until Jan 2022. They will receive only bug and security fixes and they remain compatible with current versions of the oclif and oclif-dev CLIs. Afterwhich, they will be archived.
Companioning Core, the next major release of the oclif CLI (literally oclif@2) will generate Core CLIs.
Going forward​
We are excited to release Core! We invite you to poke around the Core repo. It may appear to be a big change but Core keeps what you already enjoy about oclif while reducing development complexity, project dependencies, package coupling and bundle size and introduces many requested features previously too prickly to weave into the current oclif architecture.
Best,
The oclif team
Reference: Compatibility matrix​
oclif "v1"oclif "Core"Utility CLIsoclif@<2@oclif/dev-cli@<2oclif@>=2Main packages@oclif/core@<2@oclif/config@<2@oclif/errors@<2@oclif/parser@<4@oclif/plugin-help@<4@oclif/core@>=1Node LTSNode v8-14Node v12+TypeScripttypescript@<4typescript@>=4Main plugins@oclif/plugin-autocomplete@<1@oclif/plugin-commands@<2@oclif/plugin-help@<4@oclif/plugin-not-found@<2@oclif/plugin-plugins@<2@oclif/plugin-update@<2plugin-warn-if-update-available@<2plugin-which@<2@oclif/plugin-autocomplete@>=2@oclif/plugin-commands@>=2@oclif/plugin-help@>=4@oclif/plugin-not-found@>=2@oclif/plugin-plugins@>=2@oclif/plugin-update@>=2@oclif/plugin-warn-if-update-available@>=2@oclif/plugin-which@>=2oclif Summer 2020 UpdateAugust 26, 2020 · 2 min readHello oclif developers! We hope you are all doing well.
Earlier this year, we started our planning for oclifconf v2 and, like all conference, had to change course. We opted not to hold a virtual conference, however, we wanted to take some time to highlight a few oclif features shipped this year.
Feature: Help templating​
One of the most requested features, help templating enables oclif developers to customize the help output for their CLI.
Read the announcement.
Feature: Custom error delegation​
This feature both improved how oclif throws and handles errors and allows oclif developers to overwrite or interject in oclif’s error handling.
Read the announcement.
Feature: postrun hooks​
We have added a new lifecycle event postrun. Your CLI can now run a hook after a command has ran.
See our hook documentation.
Feature: Root index command​
Previously, oclif would display CLI help if only the binary name with no command ID was invoked, oclif now supports a "root index" command. If present, a command defined at src/commands/index.ts will be run if no command ID is found.
1 million weekly downloads​
While exact oclif usage metrics are hard to pin down, we use npm download statistics of oclif packages as a rough approximation. Earlier this year, oclif's command package hit 1 million weekly downloads for the first time!
This year has been presented its challenges on everyone. We want to thank you, oclif developers, whom have taken the time to use and improve the oclif project. We look forward to seeing you all - in person - in the future!
All our best,
The oclif teamPretty Printable ErrorsJuly 1, 2020 · One min readOften CLIs are used as handy tools and when things go wrong it’s useful to have additional context. In oclif we have added a couple of additional properties that can show extra context to the users when an error is displayed. The code, ref and suggestions will now be displayed if they are included. This will work with an existing oclif CLI by adding the latest @oclif/errors and @oclif/core to the CLI's package.json dependencies.
For example, using this.error with the additional properties:
class TestError extends Command {  async run() {    this.error("An error has occurred!", {      code: "OCLIF_ERR",      ref: "https://oclif.io/docs/commands#thiserrormessage-string--error-options-code-string-exit-number",      suggestions: ["Use these extra properties to provide additional context"],    })  }}
would result with the following output:
›   Error: An error has occurred!›   Code: OCLIF_ERR›   Try this: Use these extra properties to provide additional context›   Reference: https://oclif.io/docs/commands#thiserrormessage-string--error-options-code-string-exit-number
If these properties are not provided then nothing changes and the CLI will continue to display the single error message output as it did before. Additionally, as part of this exercise we’ve added documentation around Error Handling in oclif which should come in handy if the need arises to extend oclif’s default handling of errors.Customizing Help in oclifMay 5, 2020 · 2 min readOut of the box oclif provides a great help experience for CLIs.
But what if, as an oclif developer, you want to customize some or all of the output?
You can now customize your CLI's help output by implementing the HelpBase abstract class.
Getting started with custom help​
If you have not done so yet, update @oclif/core.
$ yarn add --latest @oclif/core
To get started, first define the filepath to your help class in oclif's config in package.json. This is a relative path to the help class, without a file extension.
For this example, the help class will be created in a file at "[project root]/src/help.ts".
{  // ...  "oclif": {    "helpClass": "./lib/help"    // ...  }  // ...}
From here there are two paths, implement the HelpBase abstract class yourself or overwrite the parts of the default Help class you want to customize (ex: how command usage is displayed). We recommend the latter approach but cover both in the new Help Classes docs.
Separating TOPICS & COMMANDS in the new default Help class​
Previously, topics and child commands were listed in help output under a single list heading called "COMMANDS". But we found this can be slightly confusing. Some topics are commands also (a.k.a. topic-commands) while others are simply organizational namespacing (and when ran just show their help).
The new default Help class splits the list of children into distinct lists of "TOPICS" and "COMMANDS", with the possibility of an item appearing in both if it a topic-command. This makes it clearer what is expected to be ran - "COMMANDS" - and what is providing structure - "TOPICS" - when looking at the help output.
VERSION  plugin-help-example/0.0.0 darwin-x64 node-v12.12.0USAGE  $ plugin-help-example [COMMAND]TOPICS  topic  this is a topic and has child topics or commandsCOMMANDS  hello  describe the command here  help   display help for plugin-help-example
We look forward to seeing what custom help features you implement in your oclif CLIs with this new feature!oclif TSLint to ESLint MigrationDecember 5, 2019 · 3 min readBack in February of this year, plans were announced to deprecate TSLint in favor of ESLint. TSLint's goal has become to work toward a “unified developer experience” by supporting ESLint development going forward.
What has changed in oclif​
To keep inline with the community, oclif has transitioned to ESLint for all our core libraries as well as all our official plugins.
Starting in v1.15.x, oclif will now optionally generate projects with ESLint for both TypeScript and JavaScript CLI’s.
ESLint does require Node to be on stable LTS version, at the time of writing, Node 8.10.x, Node 10.13.x & Node 12.x.x.
How does this affect you​
Existing CLI’s are unchanged, but any newly generated CLI's will only give the option of using ESLint. If you are running tslint in your CLI, we recommend you switch to ESLint as well.
In migrating our projects we took the following steps (for an example of these changes see this pull request).


Install eslint
$ yarn add eslint eslint-config-oclif eslint-config-oclif-typescript --dev


Add eslint related files


$ echo '{  "extends": [    "oclif",    "oclif-typescript"  ],  "rules": {  }}' > .eslintrc


Remove tslint and related packages
$ yarn remove @oclif/tslint tslint


Remove tslint related configuration files
$ rm tslint.json


Change lint script in our package.json from something like:
"lint": "tsc -p test --noEmit && tslint -p test -t stylish"
to
"lint": "eslint . --ext .ts --config .eslintrc"


To preserve the test compile (tsc -p test --noEmit) we also made the following updates to our scripts:
"pretest": "tsc -p test --noEmit"
In some cases we had our posttest duplicating the same steps as our lint script so it’s cleaner to have it reference the lint job directly with:
"posttest": "yarn lint"

Run yarn lint --fix. This attempts to auto-fix any linting violations automatically. In the case an auto-fix isn’t available it should be fixed manually or ignored (see the eslint configuration doc for more information)
Do a search in the codebase for tslint and remove any unnecessary tslint disabling comments, like:

/* tslint:disable:object-literal-sort-keys */
If you are on a version of Node that is not supported by ESLint, you will also need to update your Node engine. ESLint supports Node 8, 10, and 12 so you should upgrade to the most recent Node version compatible with your CLI and also supported by ESLint (see ESLint's Installation and Usage instructions).
When will this take effect​
These changes have taken effect in oclif v1.15.1. When you generate a new CLI or plugin it will now contain configuration for ESLint instead of TSLint.oclif's Current Node SupportOctober 31, 2019 · 3 min readTo maintain a healthy project trajectory, oclif follows and supports Node Active LTS release, currently Node 10 & Node 12. This means ensuring that oclif continues to play nice with coming Active LTS Node versions and other packages in the ecosystem. Moving forward also means leaving older versions behind. Starting in 2020, Node will stop maintaining Node 8 and it is our intent at that time to also follow suit. Let’s take a look at a few ways we will be supporting these changes.
CI Environments​
CLIs created with the oclif cli going forward will be generated with a CircleCI configuration with Node 10 & 12 and an Appveyor configuration using Node 10. We have also added Node latest to CircleCi to be an early warning detection against coming Node changes (Node latest is managed by CircleCI).
We have already updated every oclif repo's CI configs to reflect this.
If your existing CLI uses either Appveyor or CircleCI you can update your config files also, like so:
.circleci/config.yml​
Your CircleCI config should contain a node-latest job, aliased as test. From this, there should be two extensions of this job for the Active LTS Node versions, Node 10 and Node 12.
  node-10:    <<: *node-latest    docker:      - image: node:10  node-12:    <<: *node-latest    docker:      - image: node:12
Notice that these declarations only change the Docker Node images used to run that job.
Additionally, the jobs listed within workflows must also be updated to reflect our changes in configuration:
    jobs:      - node-latest      - node-10      - node-12
appveyor.yml​
For appveyor we are currently only testing the oldest Active LTS Node version, Node 10. Update the nodejs_version proppert in your appveyor.yml file to reflect this.
environment:  nodejs_version: "10"
Deprecating Node 8 & Updating packge.json engines​
In Jan 2020, Node will end its Node 8 maintenance. We will follow suit by setting the package.json engine property in oclif packages to >=10 and bumping the package's major versions.
Depending on how you ship your CLI you may wish to also bump the engines version in your CLI's package.json. You can read more about the implications of the engines property configuration in the npm documentation.
Also consider distributing your CLI with its own Node version.
Packaged Node Version​
When using dev-cli to pack your CLI it will use the Node version as specified in your package.json under the oclif.update.node.version property. This value should reflect an Active LTS Node version (dev-cli does not currently enforce versions).
Supporting the future​
As a community we may discover bumps along the way as we upgrade. If you notice something related to oclif please feel free to open an issue or submit a pull request under the relevant oclif package within the org.
We look forward to using the latest from Node and the community and keeping oclif healthy along the way.oclifconf 2019: A RecapSeptember 16, 2019 · 4 min readIn May, Heroku and Salesforce Open Source organized oclifconf, a conference for developers & product managers building CLI tools on top of the open source oclif framework. The speakers came from various tech companies, such as Adobe, Netlify, and Apollo, who have already built amazing CLI experiences. The topics covered everything from the incredible capabilities oclif has unlocked, to the community-built plugins extending its functionality, and even what the behavior of an adaptive CLI tool might look like.
Below is a listing of all of the talks from the event, along with a short summary. Enjoy!
The future of oclif by Jeff Dickey​

In its relatively short lifetime, oclif has already inspired many developers and companies to adopt its framework as a means for implementing their own command-line tooling. In this talk, Jeff Dickey, an oclif founding team member, recaps the project's history and inspiration. He also looks towards the future and outlines some features and improvements that the tool could adapt. This isn't so much a definitive roadmap of where oclif is headed, but rather, a call to inspiration for developers eager to contribute! And if you are interested in contributing, check out the open issues in the oclif GitHub repo and come say "Hello!" on Spectrum Chat.
Open Source Citizenship by Josh Simmons​

When it comes to open source, it's more than just individuals now. More and more frequently, large corporations are contributing to projects by donating to contributors, sponsoring events, or upstreaming contributions. But keeping open source projects and communities healthy requires more than just money and brainpower. Josh Simmons surveyed multiple open source communities and relays his findings as to what help maintainers and contributors actually need in this talk.
Building an enterprise-grade CLI with oclif by Thomas Dvornik​

Security and performance are all about trust. While oclif is an extremely extensible framework for building CLI tooling, there are additional requirements to fulfill for enterprise businesses to adopt it that might not be necessary for individual developers. Thomas Dvornik outlines what he and his colleagues at Salesforce have implemented as plugins to oclif to satisfy these needs, including encrypted OAuth, plugin signing, lazy loading dependencies, synchronizing weekly releases and deprecations across dozens of repositories, and establishing cross-team coding and documentation standards.
How Adobe I/O built an extensible CLI with oclif by Jesse MacFadyen​

Perhaps oclif's most appealing feature is its support for plugins. In Cordova's case, they've created a sophisticated telemetry system that helps Adobe developers see which commands users are using--and reports on which ones are erroring out. By embedding a feedback system into the tool, users are even able to quickly send their suggestions to a form, without ever leaving the terminal. Jesse MacFadyen demonstrates how oclif's plugin system can work beyond simply executing commands.
Integrating oclif with GraphQL and Apollo by Evans Hauser​

For Evans Hauser and the team at Apollo, oclif is best thought of as "React for the CLI." As a client paired with a strongly-typed API contract to a server, it can deliver structured and consistent commands to retrieve external data. What better mechanism to use for this transfer than GraphQL, a framework which empowers the client to ask precisely for the data it needs, and nothing more?
Adaptive Intent-based CLI State Machines by Shawn Wang​

In designing oclif, Jeff Dickey wrote out 12 CLI factors to keep in mind. In this talk, Shawn Wang outlines a 13th: state. State is hard, because it depends on context, and context depends on understanding what a user intends to do, not what they are asking. Shawn is working towards enabling oclif to better understand the commands a user has entered, so that it can predict and interpret future commands that might be entered next. This would enable CLI tools to not just interpret a users' commands, but to also interpret their intent.\n\nIntroducing `oclif init` commandApril 10, 2024 · 2 min readThanks to the contribution of @joshcanhelp we released a new command for the oclif CLI called oclif init in version 4.8.0
The oclif init command allows you to initialize oclif in an existing project directory by adding the bare minimum requirements: a few pieces of configuration, bin scripts, and a couple of dependencies (@oclif/core and ts-node). This is slightly different from oclif generate, which will create an entirely new oclif project based on our templates.
oclif init will add the following:

bin scripts: bin/run.js, bin/run.cmd, bin/dev.js, and bin/dev.cmd
oclif section to package.json with bin, dirname, commands, and topicSeparator set (See Configuring Your CLI for more)
@oclif/core to dependencies in your package.json (if it's not already there)
ts-node to devDependencies in your package.json (if it's not already there)

Once you've initialized oclif, you can use the bin scripts to execute your CLI. You can also use the other oclif commands like oclif generate command and oclif generate hook to start adding new functionality.

❯ oclif init --helpInitialize a new oclif CLIUSAGE  $ oclif init [--bin <value>] [--module-type ESM|CommonJS] [--package-manager npm|yarn|pnpm] [--topic-separator    colons|spaces] [-d <value>] [-y]FLAGS  -d, --output-dir=<value>        Directory to initialize the CLI in.  -y, --yes                       Use defaults for all prompts. Individual flags will override defaults.      --bin=<value>               Supply answer for prompt: Command bin name the CLI will export      --module-type=<option>      Supply answer for prompt: Select a module type                                  <options: ESM|CommonJS>      --package-manager=<option>  Supply answer for prompt: Select a package manager                                  <options: npm|yarn|pnpm>      --topic-separator=<option>  Supply answer for prompt: Select a topic separator                                  <options: colons|spaces>DESCRIPTION  Initialize a new oclif CLI  This will add the necessary oclif bin files, add oclif config to package.json, and install @oclif/core and ts-node.EXAMPLES  Initialize a new CLI in the current directory    $ oclif init  Initialize a new CLI in a different directory    $ oclif init --output-dir "/path/to/existing/project"  Supply answers for specific prompts    $ oclif init --topic-separator colons --bin mycli
Hope you enjoy the new command! If you come across any issues or have any new ideas for this command, head over to the oclif/oclif repo and open a new issue.
All our best,
The oclif teamoclif Spring 2024 UpdateMarch 29, 2024 · 4 min readHello oclif developers! It's been a while since we last uploaded a blog - and a lot has happened.
We've been focusing on these high-level areas over the past couple of years:

Improving @oclif/core
ESM Support
Improving and revitalizing oclif.io
Re-engaging the oclif community

Improving @oclif/core​
Since we announced @oclif/core over three years ago, we've released two new major versions, each packed with lots of features that we're really excited about.
Here are some of these changes:

Full support for ESM and interoperability with CommonJS (more on this topic below).
Configurable command discovery strategies that give you more control over how commands are loaded at runtime. Check out the docs.
A new preparse hook that allows you to manipulate the provided arguments before they're parsed. Salesforce used this hook to implement a neat --flags-dir feature that translates local files into flags.
A new Performance class that you can use to track performance inside of @oclif/core and your own CLI or plugin. Check out the docs.
A new flag type, Flags.option, that lets you define a flag with a preset list of options. Typescript then uses the options to infer the flag's type.
Flags now have a relationship property that allows you to define more complex relationships between flags. Check out the flags docs for more information.
Flags now have a defaultHelp property that allows you to set the human readable default value in the command help. This property is useful when your flag's parse method returns a complex type, such as an object or a class. Check out the flags docs for more.
Commands now have a hiddenAliases property that allows you to define aliases that you want to hide from the user. The property is super helpful when you're trying to wean users off a deprecated command.
You can now use bun or tsx as dev runtimes (as opposed to node or ts-node).
A command's usage, args, and flags are now shown whenever a user forgets to provide a required arg or flag, or when they provided a non-existent flag.

If you need help migrating to the latest version, head over to core's README which has links to the migration guides. Feel free to open a new discussion if you need more hands-on help from us or the community.
ESM Support​
Version 3 of @oclif/core introduced full support for developing ESM plugins and CLIs. It also offered full support for interoperability between CommonJS and ESM plugins.
Put more simply, you can now migrate your CLI to ESM while keeping individual plugins in CommonJS (or vice versa). The upgrade path is now much simpler for you. You also don't need to worry about any community plugins that have migrated to ESM before you did (such as all the @oclif plugins) or are staunchly sticking with CommonJS for the foreseeable future.
Read more about this topic here.
Improving and Revitalizing oclif.io​
Another area of focus for us has been improving our documentation site, oclif.io.
While improving the quality and accuracy of the documentation was our priority, we also took the time to upgrade to the latest version of docusaurus. This new version gave our site a much-needed facelift, as well as cool new features such as dark mode and announcements.
If you have any feedback or are running into issues, we want to hear about it. Just create an issue in the oclif.io repo.
Re-engaging the oclif Community​
Lastly, our biggest priority at the moment is to re-engage the oclif community. We understand how frustrating it has been over the years to see your issues and pull requests go unacknowledged. We apologize for not prioritizing the community, and are earnestly trying to make sure that every issue and pull request gets the attention it deserves going forward.
We also opened up GitHub discussions for @oclif/core and the oclif CLI, where you can now post your questions or ideas. We hope you take advantage of them, we love hearing from you!
One last thing: we intend to publicly post our roadmap so you have more visibility into what we're working on. Stay tuned!
All our best,
The oclif teamAnnouncing oclif v2!January 12, 2022 · 5 min readHello and happy new year! It's our great pleasure to announce that we have released oclif v2, which uses the new @oclif/core library! 🎉
oclif v2 includes many changes that improve the experience of both creating and using an oclif CLI.
Going forward, we don't plan to make any updates to oclif v1 and its corresponding libraries, except for critical security fixes. See the compatibility matrix for a list of these libraries. In order to give developers time to migrate from v1 to v2, we're not completely dropping support yet. But at some point in the future we'll archive the v1 repositories and deprecate their versions on npm.
What’s changing?​
Repository Changes​
All repositories under the oclif org now use main as their primary branch and oclif-v1 as the legacy branch. The main  branch corresponds to oclif v2 and the oclif-v1 branch to oclif v1. If you find any repos that don’t have a main branch, you can safely assume that they're not used in oclif v2 and will be deprecated in the future.
Consolidating Tools & Libraries​
The oclif-dev CLI has now been incorporated into oclif. You now no longer need to install a separate package to manage your entire CLI’s lifecycle.
The following libraries have been consolidated under @oclif/core and will be deprecated at some point in the future. Read the migration guide to learn how to update your CLI or plugin to use the new core library.

@oclif/command
@oclif/config
@oclif/error
@oclif/help
@oclif/parser

No more single vs multi command CLIs​
There's only one "type" of oclif v2 CLI, but it can have as few or as many commands as a developer wants. As a result, there’s only one command to generate CLIs, oclif generate, as opposed to the old oclif single and oclif multi commands.
Node > 12​
To ensure oclif CLIs are as secure as possible, all v2 libraries and plugins support only Node 12 or higher as of now. Going forward, they'll support only Node Maintenance or higher, as defined by Node's release schedule here: https://nodejs.org/en/about/releases/.
What’s new?​
New example CLI​
oclif-hello-world is our new example repo. This is also the repo that's used as a template when running oclif generate to create a new CLI. This repo will always be able to be referenced as an example of what an oclif v2 CLI should look like.
Spaced commands​
oclif CLIs can now use spaces, instead of colons, to separate topics and subcommands. To enable this feature, simply add “topicSeparator": " " to the oclif config in your package.json. See an example in our example repo.
// Old commands that use :$ mycli do:something
// New spaced commands$ mycli do something

Note: Spaced commands are backwards compatible. So if you enable spaced commands for your CLI, users will still be able to use : as a separator. This ensures that any existing scripts don't break.

New Help Output​
We’ve revamped the way command help is outputted to the terminal, making it both easier to implement and easier to read. See the difference between the old help output on the left and the new help output on the right in the screenshots below.
oclif v1oclif v2
Notice that there are new sections for flags and global flags, examples are displayed with better spacing, and there is a section at the bottom called Configuration Variables. This Configuration Variables section is not part of the new help by default. But we've added support for custom help sections, which is what the sf CLI uses to create the new section.
Async Command Parsing​
We’ve also improved the performance of new CLIs by rewriting how commands are parsed on initialization. The new parser is asynchronous, which makes CLIs with a lot of commands or installed  plugins much faster.
What’s coming next?​
Part of our charter for the release of oclif v2 includes improving our engagement with the oclif community. We know that over the past couple of years we’ve reduced our involvement, and a lot of issues and PRs have languished in limbo. Hopefully you’ve already seen increased activity and responses from oclif maintainers recently, but if you haven’t, please don’t hesitate to ping us by tagging @admins in oclif repos.
We also want to start interviewing members of the oclif community to acquire feedback and prioritize the features and fixes you deem most important!
Best,
The oclif team

Reference material​
Migration Guide​
This guide explains how to upgrade a CLI or plugin from the old oclif v1 libraries to the new @oclif/core library that oclif v2 uses.
https://github.com/oclif/core/blob/main/MIGRATION.md
Compatibility Matrix​
The following matrix shows how the v1 libraries and plugins relate to the new v2 ones. Use this matrix as a guide to know what to drop and which versions to switch when upgrading your plugins and CLIs to v2.
oclif "v1"oclif "v2"Utility CLIsoclif@<2@oclif/dev-cli@<2oclif@>=2Main packages@oclif/command@oclif/config@oclif/errors@oclif/parser@oclif/plugin-help@oclif/core@>=1Node LTSNode v8-14Node v12+ (at time of writing)TypeScripttypescript@<4typescript@>=4Main plugins@oclif/plugin-autocomplete@<1@oclif/plugin-commands@<2@oclif/plugin-help@<4@oclif/plugin-not-found@<2@oclif/plugin-plugins@<2@oclif/plugin-update@<2plugin-warn-if-update-available@<2plugin-which@<2@oclif/plugin-autocomplete@>=1@oclif/plugin-commands@>=2@oclif/plugin-help@>=4@oclif/plugin-not-found@>=2@oclif/plugin-plugins@>=2@oclif/plugin-update@>=2@oclif/plugin-warn-if-update-available@>=2@oclif/plugin-which@>=2Introducing @oclif/coreMarch 1, 2021 · 3 min readGreetings!
We hope this blog post finds you well.
Introducing...​
We are excited to announce the next iteration of the oclif project today: @oclif/core.
We have learned a lot in the last three years of developing oclif, developing on oclif and supporting millions of command runs a day via Heroku and Salesforce CLIs.
@oclif/core ("Core") simplifies the oclif development experience and introduces highly requested new features.
Core combines the essential oclif packages into one "core" package, aptly named @oclif/core.
Core also introduces:

A default command option
Colon or space command syntax
Async command parsing
Command piping to arguments

With the introduction of default command functionality, Core simplifies the oclif project and removes the notion of single or multi command CLIs. Core CLIs can have 1 or many commands.
Along with Core, we moved the oclif-dev CLI into the oclif CLI creating a single "utility" CLI. This CLI also introduces a new AWS S3 compatible publishing scheme.
What to expect in the near future​
Core is in pre-release beta and being actively developed for new internal Salesforce CLIs.
Much documentation needs to be written in the coming months including migration paths. Migration onto Core should be as painless as possible with many exports remaining entirely unchanged. Look for forthcoming blog posts and documentation on oclif.io.
Early this summer, tentively June 1, we will release Core v1. Core's release will coincide with major bumps to many other oclif plugin packages. See the compatibility matrix below.
At Core's v1 release, the current "main" oclif packages (namely: command, config, errors & parser) will go into maintenance mode until Jan 2022. They will receive only bug and security fixes and they remain compatible with current versions of the oclif and oclif-dev CLIs. Afterwhich, they will be archived.
Companioning Core, the next major release of the oclif CLI (literally oclif@2) will generate Core CLIs.
Going forward​
We are excited to release Core! We invite you to poke around the Core repo. It may appear to be a big change but Core keeps what you already enjoy about oclif while reducing development complexity, project dependencies, package coupling and bundle size and introduces many requested features previously too prickly to weave into the current oclif architecture.
Best,
The oclif team
Reference: Compatibility matrix​
oclif "v1"oclif "Core"Utility CLIsoclif@<2@oclif/dev-cli@<2oclif@>=2Main packages@oclif/core@<2@oclif/config@<2@oclif/errors@<2@oclif/parser@<4@oclif/plugin-help@<4@oclif/core@>=1Node LTSNode v8-14Node v12+TypeScripttypescript@<4typescript@>=4Main plugins@oclif/plugin-autocomplete@<1@oclif/plugin-commands@<2@oclif/plugin-help@<4@oclif/plugin-not-found@<2@oclif/plugin-plugins@<2@oclif/plugin-update@<2plugin-warn-if-update-available@<2plugin-which@<2@oclif/plugin-autocomplete@>=2@oclif/plugin-commands@>=2@oclif/plugin-help@>=4@oclif/plugin-not-found@>=2@oclif/plugin-plugins@>=2@oclif/plugin-update@>=2@oclif/plugin-warn-if-update-available@>=2@oclif/plugin-which@>=2oclif Summer 2020 UpdateAugust 26, 2020 · 2 min readHello oclif developers! We hope you are all doing well.
Earlier this year, we started our planning for oclifconf v2 and, like all conference, had to change course. We opted not to hold a virtual conference, however, we wanted to take some time to highlight a few oclif features shipped this year.
Feature: Help templating​
One of the most requested features, help templating enables oclif developers to customize the help output for their CLI.
Read the announcement.
Feature: Custom error delegation​
This feature both improved how oclif throws and handles errors and allows oclif developers to overwrite or interject in oclif’s error handling.
Read the announcement.
Feature: postrun hooks​
We have added a new lifecycle event postrun. Your CLI can now run a hook after a command has ran.
See our hook documentation.
Feature: Root index command​
Previously, oclif would display CLI help if only the binary name with no command ID was invoked, oclif now supports a "root index" command. If present, a command defined at src/commands/index.ts will be run if no command ID is found.
1 million weekly downloads​
While exact oclif usage metrics are hard to pin down, we use npm download statistics of oclif packages as a rough approximation. Earlier this year, oclif's command package hit 1 million weekly downloads for the first time!
This year has been presented its challenges on everyone. We want to thank you, oclif developers, whom have taken the time to use and improve the oclif project. We look forward to seeing you all - in person - in the future!
All our best,
The oclif teamPretty Printable ErrorsJuly 1, 2020 · One min readOften CLIs are used as handy tools and when things go wrong it’s useful to have additional context. In oclif we have added a couple of additional properties that can show extra context to the users when an error is displayed. The code, ref and suggestions will now be displayed if they are included. This will work with an existing oclif CLI by adding the latest @oclif/errors and @oclif/core to the CLI's package.json dependencies.
For example, using this.error with the additional properties:
class TestError extends Command {  async run() {    this.error("An error has occurred!", {      code: "OCLIF_ERR",      ref: "https://oclif.io/docs/commands#thiserrormessage-string--error-options-code-string-exit-number",      suggestions: ["Use these extra properties to provide additional context"],    })  }}
would result with the following output:
›   Error: An error has occurred!›   Code: OCLIF_ERR›   Try this: Use these extra properties to provide additional context›   Reference: https://oclif.io/docs/commands#thiserrormessage-string--error-options-code-string-exit-number
If these properties are not provided then nothing changes and the CLI will continue to display the single error message output as it did before. Additionally, as part of this exercise we’ve added documentation around Error Handling in oclif which should come in handy if the need arises to extend oclif’s default handling of errors.Customizing Help in oclifMay 5, 2020 · 2 min readOut of the box oclif provides a great help experience for CLIs.
But what if, as an oclif developer, you want to customize some or all of the output?
You can now customize your CLI's help output by implementing the HelpBase abstract class.
Getting started with custom help​
If you have not done so yet, update @oclif/core.
$ yarn add --latest @oclif/core
To get started, first define the filepath to your help class in oclif's config in package.json. This is a relative path to the help class, without a file extension.
For this example, the help class will be created in a file at "[project root]/src/help.ts".
{  // ...  "oclif": {    "helpClass": "./lib/help"    // ...  }  // ...}
From here there are two paths, implement the HelpBase abstract class yourself or overwrite the parts of the default Help class you want to customize (ex: how command usage is displayed). We recommend the latter approach but cover both in the new Help Classes docs.
Separating TOPICS & COMMANDS in the new default Help class​
Previously, topics and child commands were listed in help output under a single list heading called "COMMANDS". But we found this can be slightly confusing. Some topics are commands also (a.k.a. topic-commands) while others are simply organizational namespacing (and when ran just show their help).
The new default Help class splits the list of children into distinct lists of "TOPICS" and "COMMANDS", with the possibility of an item appearing in both if it a topic-command. This makes it clearer what is expected to be ran - "COMMANDS" - and what is providing structure - "TOPICS" - when looking at the help output.
VERSION  plugin-help-example/0.0.0 darwin-x64 node-v12.12.0USAGE  $ plugin-help-example [COMMAND]TOPICS  topic  this is a topic and has child topics or commandsCOMMANDS  hello  describe the command here  help   display help for plugin-help-example
We look forward to seeing what custom help features you implement in your oclif CLIs with this new feature!oclif TSLint to ESLint MigrationDecember 5, 2019 · 3 min readBack in February of this year, plans were announced to deprecate TSLint in favor of ESLint. TSLint's goal has become to work toward a “unified developer experience” by supporting ESLint development going forward.
What has changed in oclif​
To keep inline with the community, oclif has transitioned to ESLint for all our core libraries as well as all our official plugins.
Starting in v1.15.x, oclif will now optionally generate projects with ESLint for both TypeScript and JavaScript CLI’s.
ESLint does require Node to be on stable LTS version, at the time of writing, Node 8.10.x, Node 10.13.x & Node 12.x.x.
How does this affect you​
Existing CLI’s are unchanged, but any newly generated CLI's will only give the option of using ESLint. If you are running tslint in your CLI, we recommend you switch to ESLint as well.
In migrating our projects we took the following steps (for an example of these changes see this pull request).


Install eslint
$ yarn add eslint eslint-config-oclif eslint-config-oclif-typescript --dev


Add eslint related files


$ echo '{  "extends": [    "oclif",    "oclif-typescript"  ],  "rules": {  }}' > .eslintrc


Remove tslint and related packages
$ yarn remove @oclif/tslint tslint


Remove tslint related configuration files
$ rm tslint.json


Change lint script in our package.json from something like:
"lint": "tsc -p test --noEmit && tslint -p test -t stylish"
to
"lint": "eslint . --ext .ts --config .eslintrc"


To preserve the test compile (tsc -p test --noEmit) we also made the following updates to our scripts:
"pretest": "tsc -p test --noEmit"
In some cases we had our posttest duplicating the same steps as our lint script so it’s cleaner to have it reference the lint job directly with:
"posttest": "yarn lint"

Run yarn lint --fix. This attempts to auto-fix any linting violations automatically. In the case an auto-fix isn’t available it should be fixed manually or ignored (see the eslint configuration doc for more information)
Do a search in the codebase for tslint and remove any unnecessary tslint disabling comments, like:

/* tslint:disable:object-literal-sort-keys */
If you are on a version of Node that is not supported by ESLint, you will also need to update your Node engine. ESLint supports Node 8, 10, and 12 so you should upgrade to the most recent Node version compatible with your CLI and also supported by ESLint (see ESLint's Installation and Usage instructions).
When will this take effect​
These changes have taken effect in oclif v1.15.1. When you generate a new CLI or plugin it will now contain configuration for ESLint instead of TSLint.oclif's Current Node SupportOctober 31, 2019 · 3 min readTo maintain a healthy project trajectory, oclif follows and supports Node Active LTS release, currently Node 10 & Node 12. This means ensuring that oclif continues to play nice with coming Active LTS Node versions and other packages in the ecosystem. Moving forward also means leaving older versions behind. Starting in 2020, Node will stop maintaining Node 8 and it is our intent at that time to also follow suit. Let’s take a look at a few ways we will be supporting these changes.
CI Environments​
CLIs created with the oclif cli going forward will be generated with a CircleCI configuration with Node 10 & 12 and an Appveyor configuration using Node 10. We have also added Node latest to CircleCi to be an early warning detection against coming Node changes (Node latest is managed by CircleCI).
We have already updated every oclif repo's CI configs to reflect this.
If your existing CLI uses either Appveyor or CircleCI you can update your config files also, like so:
.circleci/config.yml​
Your CircleCI config should contain a node-latest job, aliased as test. From this, there should be two extensions of this job for the Active LTS Node versions, Node 10 and Node 12.
  node-10:    <<: *node-latest    docker:      - image: node:10  node-12:    <<: *node-latest    docker:      - image: node:12
Notice that these declarations only change the Docker Node images used to run that job.
Additionally, the jobs listed within workflows must also be updated to reflect our changes in configuration:
    jobs:      - node-latest      - node-10      - node-12
appveyor.yml​
For appveyor we are currently only testing the oldest Active LTS Node version, Node 10. Update the nodejs_version proppert in your appveyor.yml file to reflect this.
environment:  nodejs_version: "10"
Deprecating Node 8 & Updating packge.json engines​
In Jan 2020, Node will end its Node 8 maintenance. We will follow suit by setting the package.json engine property in oclif packages to >=10 and bumping the package's major versions.
Depending on how you ship your CLI you may wish to also bump the engines version in your CLI's package.json. You can read more about the implications of the engines property configuration in the npm documentation.
Also consider distributing your CLI with its own Node version.
Packaged Node Version​
When using dev-cli to pack your CLI it will use the Node version as specified in your package.json under the oclif.update.node.version property. This value should reflect an Active LTS Node version (dev-cli does not currently enforce versions).
Supporting the future​
As a community we may discover bumps along the way as we upgrade. If you notice something related to oclif please feel free to open an issue or submit a pull request under the relevant oclif package within the org.
We look forward to using the latest from Node and the community and keeping oclif healthy along the way.oclifconf 2019: A RecapSeptember 16, 2019 · 4 min readIn May, Heroku and Salesforce Open Source organized oclifconf, a conference for developers & product managers building CLI tools on top of the open source oclif framework. The speakers came from various tech companies, such as Adobe, Netlify, and Apollo, who have already built amazing CLI experiences. The topics covered everything from the incredible capabilities oclif has unlocked, to the community-built plugins extending its functionality, and even what the behavior of an adaptive CLI tool might look like.
Below is a listing of all of the talks from the event, along with a short summary. Enjoy!
The future of oclif by Jeff Dickey​

In its relatively short lifetime, oclif has already inspired many developers and companies to adopt its framework as a means for implementing their own command-line tooling. In this talk, Jeff Dickey, an oclif founding team member, recaps the project's history and inspiration. He also looks towards the future and outlines some features and improvements that the tool could adapt. This isn't so much a definitive roadmap of where oclif is headed, but rather, a call to inspiration for developers eager to contribute! And if you are interested in contributing, check out the open issues in the oclif GitHub repo and come say "Hello!" on Spectrum Chat.
Open Source Citizenship by Josh Simmons​

When it comes to open source, it's more than just individuals now. More and more frequently, large corporations are contributing to projects by donating to contributors, sponsoring events, or upstreaming contributions. But keeping open source projects and communities healthy requires more than just money and brainpower. Josh Simmons surveyed multiple open source communities and relays his findings as to what help maintainers and contributors actually need in this talk.
Building an enterprise-grade CLI with oclif by Thomas Dvornik​

Security and performance are all about trust. While oclif is an extremely extensible framework for building CLI tooling, there are additional requirements to fulfill for enterprise businesses to adopt it that might not be necessary for individual developers. Thomas Dvornik outlines what he and his colleagues at Salesforce have implemented as plugins to oclif to satisfy these needs, including encrypted OAuth, plugin signing, lazy loading dependencies, synchronizing weekly releases and deprecations across dozens of repositories, and establishing cross-team coding and documentation standards.
How Adobe I/O built an extensible CLI with oclif by Jesse MacFadyen​

Perhaps oclif's most appealing feature is its support for plugins. In Cordova's case, they've created a sophisticated telemetry system that helps Adobe developers see which commands users are using--and reports on which ones are erroring out. By embedding a feedback system into the tool, users are even able to quickly send their suggestions to a form, without ever leaving the terminal. Jesse MacFadyen demonstrates how oclif's plugin system can work beyond simply executing commands.
Integrating oclif with GraphQL and Apollo by Evans Hauser​

For Evans Hauser and the team at Apollo, oclif is best thought of as "React for the CLI." As a client paired with a strongly-typed API contract to a server, it can deliver structured and consistent commands to retrieve external data. What better mechanism to use for this transfer than GraphQL, a framework which empowers the client to ask precisely for the data it needs, and nothing more?
Adaptive Intent-based CLI State Machines by Shawn Wang​

In designing oclif, Jeff Dickey wrote out 12 CLI factors to keep in mind. In this talk, Shawn Wang outlines a 13th: state. State is hard, because it depends on context, and context depends on understanding what a user intends to do, not what they are asking. Shawn is working towards enabling oclif to better understand the commands a user has entered, so that it can predict and interpret future commands that might be entered next. This would enable CLI tools to not just interpret a users' commands, but to also interpret their intent.Older Entries\n\n\n\nIntroducing `oclif init` commandApril 10, 2024 · 2 min readThanks to the contribution of @joshcanhelp we released a new command for the oclif CLI called oclif init in version 4.8.0
The oclif init command allows you to initialize oclif in an existing project directory by adding the bare minimum requirements: a few pieces of configuration, bin scripts, and a couple of dependencies (@oclif/core and ts-node). This is slightly different from oclif generate, which will create an entirely new oclif project based on our templates.
oclif init will add the following:

bin scripts: bin/run.js, bin/run.cmd, bin/dev.js, and bin/dev.cmd
oclif section to package.json with bin, dirname, commands, and topicSeparator set (See Configuring Your CLI for more)
@oclif/core to dependencies in your package.json (if it's not already there)
ts-node to devDependencies in your package.json (if it's not already there)

Once you've initialized oclif, you can use the bin scripts to execute your CLI. You can also use the other oclif commands like oclif generate command and oclif generate hook to start adding new functionality.

❯ oclif init --helpInitialize a new oclif CLIUSAGE  $ oclif init [--bin <value>] [--module-type ESM|CommonJS] [--package-manager npm|yarn|pnpm] [--topic-separator    colons|spaces] [-d <value>] [-y]FLAGS  -d, --output-dir=<value>        Directory to initialize the CLI in.  -y, --yes                       Use defaults for all prompts. Individual flags will override defaults.      --bin=<value>               Supply answer for prompt: Command bin name the CLI will export      --module-type=<option>      Supply answer for prompt: Select a module type                                  <options: ESM|CommonJS>      --package-manager=<option>  Supply answer for prompt: Select a package manager                                  <options: npm|yarn|pnpm>      --topic-separator=<option>  Supply answer for prompt: Select a topic separator                                  <options: colons|spaces>DESCRIPTION  Initialize a new oclif CLI  This will add the necessary oclif bin files, add oclif config to package.json, and install @oclif/core and ts-node.EXAMPLES  Initialize a new CLI in the current directory    $ oclif init  Initialize a new CLI in a different directory    $ oclif init --output-dir "/path/to/existing/project"  Supply answers for specific prompts    $ oclif init --topic-separator colons --bin mycli
Hope you enjoy the new command! If you come across any issues or have any new ideas for this command, head over to the oclif/oclif repo and open a new issue.
All our best,
The oclif teamoclif Spring 2024 UpdateMarch 29, 2024 · 4 min readHello oclif developers! It's been a while since we last uploaded a blog - and a lot has happened.
We've been focusing on these high-level areas over the past couple of years:

Improving @oclif/core
ESM Support
Improving and revitalizing oclif.io
Re-engaging the oclif community

Improving @oclif/core​
Since we announced @oclif/core over three years ago, we've released two new major versions, each packed with lots of features that we're really excited about.
Here are some of these changes:

Full support for ESM and interoperability with CommonJS (more on this topic below).
Configurable command discovery strategies that give you more control over how commands are loaded at runtime. Check out the docs.
A new preparse hook that allows you to manipulate the provided arguments before they're parsed. Salesforce used this hook to implement a neat --flags-dir feature that translates local files into flags.
A new Performance class that you can use to track performance inside of @oclif/core and your own CLI or plugin. Check out the docs.
A new flag type, Flags.option, that lets you define a flag with a preset list of options. Typescript then uses the options to infer the flag's type.
Flags now have a relationship property that allows you to define more complex relationships between flags. Check out the flags docs for more information.
Flags now have a defaultHelp property that allows you to set the human readable default value in the command help. This property is useful when your flag's parse method returns a complex type, such as an object or a class. Check out the flags docs for more.
Commands now have a hiddenAliases property that allows you to define aliases that you want to hide from the user. The property is super helpful when you're trying to wean users off a deprecated command.
You can now use bun or tsx as dev runtimes (as opposed to node or ts-node).
A command's usage, args, and flags are now shown whenever a user forgets to provide a required arg or flag, or when they provided a non-existent flag.

If you need help migrating to the latest version, head over to core's README which has links to the migration guides. Feel free to open a new discussion if you need more hands-on help from us or the community.
ESM Support​
Version 3 of @oclif/core introduced full support for developing ESM plugins and CLIs. It also offered full support for interoperability between CommonJS and ESM plugins.
Put more simply, you can now migrate your CLI to ESM while keeping individual plugins in CommonJS (or vice versa). The upgrade path is now much simpler for you. You also don't need to worry about any community plugins that have migrated to ESM before you did (such as all the @oclif plugins) or are staunchly sticking with CommonJS for the foreseeable future.
Read more about this topic here.
Improving and Revitalizing oclif.io​
Another area of focus for us has been improving our documentation site, oclif.io.
While improving the quality and accuracy of the documentation was our priority, we also took the time to upgrade to the latest version of docusaurus. This new version gave our site a much-needed facelift, as well as cool new features such as dark mode and announcements.
If you have any feedback or are running into issues, we want to hear about it. Just create an issue in the oclif.io repo.
Re-engaging the oclif Community​
Lastly, our biggest priority at the moment is to re-engage the oclif community. We understand how frustrating it has been over the years to see your issues and pull requests go unacknowledged. We apologize for not prioritizing the community, and are earnestly trying to make sure that every issue and pull request gets the attention it deserves going forward.
We also opened up GitHub discussions for @oclif/core and the oclif CLI, where you can now post your questions or ideas. We hope you take advantage of them, we love hearing from you!
One last thing: we intend to publicly post our roadmap so you have more visibility into what we're working on. Stay tuned!
All our best,
The oclif teamAnnouncing oclif v2!January 12, 2022 · 5 min readHello and happy new year! It's our great pleasure to announce that we have released oclif v2, which uses the new @oclif/core library! 🎉
oclif v2 includes many changes that improve the experience of both creating and using an oclif CLI.
Going forward, we don't plan to make any updates to oclif v1 and its corresponding libraries, except for critical security fixes. See the compatibility matrix for a list of these libraries. In order to give developers time to migrate from v1 to v2, we're not completely dropping support yet. But at some point in the future we'll archive the v1 repositories and deprecate their versions on npm.
What’s changing?​
Repository Changes​
All repositories under the oclif org now use main as their primary branch and oclif-v1 as the legacy branch. The main  branch corresponds to oclif v2 and the oclif-v1 branch to oclif v1. If you find any repos that don’t have a main branch, you can safely assume that they're not used in oclif v2 and will be deprecated in the future.
Consolidating Tools & Libraries​
The oclif-dev CLI has now been incorporated into oclif. You now no longer need to install a separate package to manage your entire CLI’s lifecycle.
The following libraries have been consolidated under @oclif/core and will be deprecated at some point in the future. Read the migration guide to learn how to update your CLI or plugin to use the new core library.

@oclif/command
@oclif/config
@oclif/error
@oclif/help
@oclif/parser

No more single vs multi command CLIs​
There's only one "type" of oclif v2 CLI, but it can have as few or as many commands as a developer wants. As a result, there’s only one command to generate CLIs, oclif generate, as opposed to the old oclif single and oclif multi commands.
Node > 12​
To ensure oclif CLIs are as secure as possible, all v2 libraries and plugins support only Node 12 or higher as of now. Going forward, they'll support only Node Maintenance or higher, as defined by Node's release schedule here: https://nodejs.org/en/about/releases/.
What’s new?​
New example CLI​
oclif-hello-world is our new example repo. This is also the repo that's used as a template when running oclif generate to create a new CLI. This repo will always be able to be referenced as an example of what an oclif v2 CLI should look like.
Spaced commands​
oclif CLIs can now use spaces, instead of colons, to separate topics and subcommands. To enable this feature, simply add “topicSeparator": " " to the oclif config in your package.json. See an example in our example repo.
// Old commands that use :$ mycli do:something
// New spaced commands$ mycli do something

Note: Spaced commands are backwards compatible. So if you enable spaced commands for your CLI, users will still be able to use : as a separator. This ensures that any existing scripts don't break.

New Help Output​
We’ve revamped the way command help is outputted to the terminal, making it both easier to implement and easier to read. See the difference between the old help output on the left and the new help output on the right in the screenshots below.
oclif v1oclif v2
Notice that there are new sections for flags and global flags, examples are displayed with better spacing, and there is a section at the bottom called Configuration Variables. This Configuration Variables section is not part of the new help by default. But we've added support for custom help sections, which is what the sf CLI uses to create the new section.
Async Command Parsing​
We’ve also improved the performance of new CLIs by rewriting how commands are parsed on initialization. The new parser is asynchronous, which makes CLIs with a lot of commands or installed  plugins much faster.
What’s coming next?​
Part of our charter for the release of oclif v2 includes improving our engagement with the oclif community. We know that over the past couple of years we’ve reduced our involvement, and a lot of issues and PRs have languished in limbo. Hopefully you’ve already seen increased activity and responses from oclif maintainers recently, but if you haven’t, please don’t hesitate to ping us by tagging @admins in oclif repos.
We also want to start interviewing members of the oclif community to acquire feedback and prioritize the features and fixes you deem most important!
Best,
The oclif team

Reference material​
Migration Guide​
This guide explains how to upgrade a CLI or plugin from the old oclif v1 libraries to the new @oclif/core library that oclif v2 uses.
https://github.com/oclif/core/blob/main/MIGRATION.md
Compatibility Matrix​
The following matrix shows how the v1 libraries and plugins relate to the new v2 ones. Use this matrix as a guide to know what to drop and which versions to switch when upgrading your plugins and CLIs to v2.
oclif "v1"oclif "v2"Utility CLIsoclif@<2@oclif/dev-cli@<2oclif@>=2Main packages@oclif/command@oclif/config@oclif/errors@oclif/parser@oclif/plugin-help@oclif/core@>=1Node LTSNode v8-14Node v12+ (at time of writing)TypeScripttypescript@<4typescript@>=4Main plugins@oclif/plugin-autocomplete@<1@oclif/plugin-commands@<2@oclif/plugin-help@<4@oclif/plugin-not-found@<2@oclif/plugin-plugins@<2@oclif/plugin-update@<2plugin-warn-if-update-available@<2plugin-which@<2@oclif/plugin-autocomplete@>=1@oclif/plugin-commands@>=2@oclif/plugin-help@>=4@oclif/plugin-not-found@>=2@oclif/plugin-plugins@>=2@oclif/plugin-update@>=2@oclif/plugin-warn-if-update-available@>=2@oclif/plugin-which@>=2Introducing @oclif/coreMarch 1, 2021 · 3 min readGreetings!
We hope this blog post finds you well.
Introducing...​
We are excited to announce the next iteration of the oclif project today: @oclif/core.
We have learned a lot in the last three years of developing oclif, developing on oclif and supporting millions of command runs a day via Heroku and Salesforce CLIs.
@oclif/core ("Core") simplifies the oclif development experience and introduces highly requested new features.
Core combines the essential oclif packages into one "core" package, aptly named @oclif/core.
Core also introduces:

A default command option
Colon or space command syntax
Async command parsing
Command piping to arguments

With the introduction of default command functionality, Core simplifies the oclif project and removes the notion of single or multi command CLIs. Core CLIs can have 1 or many commands.
Along with Core, we moved the oclif-dev CLI into the oclif CLI creating a single "utility" CLI. This CLI also introduces a new AWS S3 compatible publishing scheme.
What to expect in the near future​
Core is in pre-release beta and being actively developed for new internal Salesforce CLIs.
Much documentation needs to be written in the coming months including migration paths. Migration onto Core should be as painless as possible with many exports remaining entirely unchanged. Look for forthcoming blog posts and documentation on oclif.io.
Early this summer, tentively June 1, we will release Core v1. Core's release will coincide with major bumps to many other oclif plugin packages. See the compatibility matrix below.
At Core's v1 release, the current "main" oclif packages (namely: command, config, errors & parser) will go into maintenance mode until Jan 2022. They will receive only bug and security fixes and they remain compatible with current versions of the oclif and oclif-dev CLIs. Afterwhich, they will be archived.
Companioning Core, the next major release of the oclif CLI (literally oclif@2) will generate Core CLIs.
Going forward​
We are excited to release Core! We invite you to poke around the Core repo. It may appear to be a big change but Core keeps what you already enjoy about oclif while reducing development complexity, project dependencies, package coupling and bundle size and introduces many requested features previously too prickly to weave into the current oclif architecture.
Best,
The oclif team
Reference: Compatibility matrix​
oclif "v1"oclif "Core"Utility CLIsoclif@<2@oclif/dev-cli@<2oclif@>=2Main packages@oclif/core@<2@oclif/config@<2@oclif/errors@<2@oclif/parser@<4@oclif/plugin-help@<4@oclif/core@>=1Node LTSNode v8-14Node v12+TypeScripttypescript@<4typescript@>=4Main plugins@oclif/plugin-autocomplete@<1@oclif/plugin-commands@<2@oclif/plugin-help@<4@oclif/plugin-not-found@<2@oclif/plugin-plugins@<2@oclif/plugin-update@<2plugin-warn-if-update-available@<2plugin-which@<2@oclif/plugin-autocomplete@>=2@oclif/plugin-commands@>=2@oclif/plugin-help@>=4@oclif/plugin-not-found@>=2@oclif/plugin-plugins@>=2@oclif/plugin-update@>=2@oclif/plugin-warn-if-update-available@>=2@oclif/plugin-which@>=2oclif Summer 2020 UpdateAugust 26, 2020 · 2 min readHello oclif developers! We hope you are all doing well.
Earlier this year, we started our planning for oclifconf v2 and, like all conference, had to change course. We opted not to hold a virtual conference, however, we wanted to take some time to highlight a few oclif features shipped this year.
Feature: Help templating​
One of the most requested features, help templating enables oclif developers to customize the help output for their CLI.
Read the announcement.
Feature: Custom error delegation​
This feature both improved how oclif throws and handles errors and allows oclif developers to overwrite or interject in oclif’s error handling.
Read the announcement.
Feature: postrun hooks​
We have added a new lifecycle event postrun. Your CLI can now run a hook after a command has ran.
See our hook documentation.
Feature: Root index command​
Previously, oclif would display CLI help if only the binary name with no command ID was invoked, oclif now supports a "root index" command. If present, a command defined at src/commands/index.ts will be run if no command ID is found.
1 million weekly downloads​
While exact oclif usage metrics are hard to pin down, we use npm download statistics of oclif packages as a rough approximation. Earlier this year, oclif's command package hit 1 million weekly downloads for the first time!
This year has been presented its challenges on everyone. We want to thank you, oclif developers, whom have taken the time to use and improve the oclif project. We look forward to seeing you all - in person - in the future!
All our best,
The oclif teamPretty Printable ErrorsJuly 1, 2020 · One min readOften CLIs are used as handy tools and when things go wrong it’s useful to have additional context. In oclif we have added a couple of additional properties that can show extra context to the users when an error is displayed. The code, ref and suggestions will now be displayed if they are included. This will work with an existing oclif CLI by adding the latest @oclif/errors and @oclif/core to the CLI's package.json dependencies.
For example, using this.error with the additional properties:
class TestError extends Command {  async run() {    this.error("An error has occurred!", {      code: "OCLIF_ERR",      ref: "https://oclif.io/docs/commands#thiserrormessage-string--error-options-code-string-exit-number",      suggestions: ["Use these extra properties to provide additional context"],    })  }}
would result with the following output:
›   Error: An error has occurred!›   Code: OCLIF_ERR›   Try this: Use these extra properties to provide additional context›   Reference: https://oclif.io/docs/commands#thiserrormessage-string--error-options-code-string-exit-number
If these properties are not provided then nothing changes and the CLI will continue to display the single error message output as it did before. Additionally, as part of this exercise we’ve added documentation around Error Handling in oclif which should come in handy if the need arises to extend oclif’s default handling of errors.Customizing Help in oclifMay 5, 2020 · 2 min readOut of the box oclif provides a great help experience for CLIs.
But what if, as an oclif developer, you want to customize some or all of the output?
You can now customize your CLI's help output by implementing the HelpBase abstract class.
Getting started with custom help​
If you have not done so yet, update @oclif/core.
$ yarn add --latest @oclif/core
To get started, first define the filepath to your help class in oclif's config in package.json. This is a relative path to the help class, without a file extension.
For this example, the help class will be created in a file at "[project root]/src/help.ts".
{  // ...  "oclif": {    "helpClass": "./lib/help"    // ...  }  // ...}
From here there are two paths, implement the HelpBase abstract class yourself or overwrite the parts of the default Help class you want to customize (ex: how command usage is displayed). We recommend the latter approach but cover both in the new Help Classes docs.
Separating TOPICS & COMMANDS in the new default Help class​
Previously, topics and child commands were listed in help output under a single list heading called "COMMANDS". But we found this can be slightly confusing. Some topics are commands also (a.k.a. topic-commands) while others are simply organizational namespacing (and when ran just show their help).
The new default Help class splits the list of children into distinct lists of "TOPICS" and "COMMANDS", with the possibility of an item appearing in both if it a topic-command. This makes it clearer what is expected to be ran - "COMMANDS" - and what is providing structure - "TOPICS" - when looking at the help output.
VERSION  plugin-help-example/0.0.0 darwin-x64 node-v12.12.0USAGE  $ plugin-help-example [COMMAND]TOPICS  topic  this is a topic and has child topics or commandsCOMMANDS  hello  describe the command here  help   display help for plugin-help-example
We look forward to seeing what custom help features you implement in your oclif CLIs with this new feature!oclif TSLint to ESLint MigrationDecember 5, 2019 · 3 min readBack in February of this year, plans were announced to deprecate TSLint in favor of ESLint. TSLint's goal has become to work toward a “unified developer experience” by supporting ESLint development going forward.
What has changed in oclif​
To keep inline with the community, oclif has transitioned to ESLint for all our core libraries as well as all our official plugins.
Starting in v1.15.x, oclif will now optionally generate projects with ESLint for both TypeScript and JavaScript CLI’s.
ESLint does require Node to be on stable LTS version, at the time of writing, Node 8.10.x, Node 10.13.x & Node 12.x.x.
How does this affect you​
Existing CLI’s are unchanged, but any newly generated CLI's will only give the option of using ESLint. If you are running tslint in your CLI, we recommend you switch to ESLint as well.
In migrating our projects we took the following steps (for an example of these changes see this pull request).


Install eslint
$ yarn add eslint eslint-config-oclif eslint-config-oclif-typescript --dev


Add eslint related files


$ echo '{  "extends": [    "oclif",    "oclif-typescript"  ],  "rules": {  }}' > .eslintrc


Remove tslint and related packages
$ yarn remove @oclif/tslint tslint


Remove tslint related configuration files
$ rm tslint.json


Change lint script in our package.json from something like:
"lint": "tsc -p test --noEmit && tslint -p test -t stylish"
to
"lint": "eslint . --ext .ts --config .eslintrc"


To preserve the test compile (tsc -p test --noEmit) we also made the following updates to our scripts:
"pretest": "tsc -p test --noEmit"
In some cases we had our posttest duplicating the same steps as our lint script so it’s cleaner to have it reference the lint job directly with:
"posttest": "yarn lint"

Run yarn lint --fix. This attempts to auto-fix any linting violations automatically. In the case an auto-fix isn’t available it should be fixed manually or ignored (see the eslint configuration doc for more information)
Do a search in the codebase for tslint and remove any unnecessary tslint disabling comments, like:

/* tslint:disable:object-literal-sort-keys */
If you are on a version of Node that is not supported by ESLint, you will also need to update your Node engine. ESLint supports Node 8, 10, and 12 so you should upgrade to the most recent Node version compatible with your CLI and also supported by ESLint (see ESLint's Installation and Usage instructions).
When will this take effect​
These changes have taken effect in oclif v1.15.1. When you generate a new CLI or plugin it will now contain configuration for ESLint instead of TSLint.oclif's Current Node SupportOctober 31, 2019 · 3 min readTo maintain a healthy project trajectory, oclif follows and supports Node Active LTS release, currently Node 10 & Node 12. This means ensuring that oclif continues to play nice with coming Active LTS Node versions and other packages in the ecosystem. Moving forward also means leaving older versions behind. Starting in 2020, Node will stop maintaining Node 8 and it is our intent at that time to also follow suit. Let’s take a look at a few ways we will be supporting these changes.
CI Environments​
CLIs created with the oclif cli going forward will be generated with a CircleCI configuration with Node 10 & 12 and an Appveyor configuration using Node 10. We have also added Node latest to CircleCi to be an early warning detection against coming Node changes (Node latest is managed by CircleCI).
We have already updated every oclif repo's CI configs to reflect this.
If your existing CLI uses either Appveyor or CircleCI you can update your config files also, like so:
.circleci/config.yml​
Your CircleCI config should contain a node-latest job, aliased as test. From this, there should be two extensions of this job for the Active LTS Node versions, Node 10 and Node 12.
  node-10:    <<: *node-latest    docker:      - image: node:10  node-12:    <<: *node-latest    docker:      - image: node:12
Notice that these declarations only change the Docker Node images used to run that job.
Additionally, the jobs listed within workflows must also be updated to reflect our changes in configuration:
    jobs:      - node-latest      - node-10      - node-12
appveyor.yml​
For appveyor we are currently only testing the oldest Active LTS Node version, Node 10. Update the nodejs_version proppert in your appveyor.yml file to reflect this.
environment:  nodejs_version: "10"
Deprecating Node 8 & Updating packge.json engines​
In Jan 2020, Node will end its Node 8 maintenance. We will follow suit by setting the package.json engine property in oclif packages to >=10 and bumping the package's major versions.
Depending on how you ship your CLI you may wish to also bump the engines version in your CLI's package.json. You can read more about the implications of the engines property configuration in the npm documentation.
Also consider distributing your CLI with its own Node version.
Packaged Node Version​
When using dev-cli to pack your CLI it will use the Node version as specified in your package.json under the oclif.update.node.version property. This value should reflect an Active LTS Node version (dev-cli does not currently enforce versions).
Supporting the future​
As a community we may discover bumps along the way as we upgrade. If you notice something related to oclif please feel free to open an issue or submit a pull request under the relevant oclif package within the org.
We look forward to using the latest from Node and the community and keeping oclif healthy along the way.oclifconf 2019: A RecapSeptember 16, 2019 · 4 min readIn May, Heroku and Salesforce Open Source organized oclifconf, a conference for developers & product managers building CLI tools on top of the open source oclif framework. The speakers came from various tech companies, such as Adobe, Netlify, and Apollo, who have already built amazing CLI experiences. The topics covered everything from the incredible capabilities oclif has unlocked, to the community-built plugins extending its functionality, and even what the behavior of an adaptive CLI tool might look like.
Below is a listing of all of the talks from the event, along with a short summary. Enjoy!
The future of oclif by Jeff Dickey​

In its relatively short lifetime, oclif has already inspired many developers and companies to adopt its framework as a means for implementing their own command-line tooling. In this talk, Jeff Dickey, an oclif founding team member, recaps the project's history and inspiration. He also looks towards the future and outlines some features and improvements that the tool could adapt. This isn't so much a definitive roadmap of where oclif is headed, but rather, a call to inspiration for developers eager to contribute! And if you are interested in contributing, check out the open issues in the oclif GitHub repo and come say "Hello!" on Spectrum Chat.
Open Source Citizenship by Josh Simmons​

When it comes to open source, it's more than just individuals now. More and more frequently, large corporations are contributing to projects by donating to contributors, sponsoring events, or upstreaming contributions. But keeping open source projects and communities healthy requires more than just money and brainpower. Josh Simmons surveyed multiple open source communities and relays his findings as to what help maintainers and contributors actually need in this talk.
Building an enterprise-grade CLI with oclif by Thomas Dvornik​

Security and performance are all about trust. While oclif is an extremely extensible framework for building CLI tooling, there are additional requirements to fulfill for enterprise businesses to adopt it that might not be necessary for individual developers. Thomas Dvornik outlines what he and his colleagues at Salesforce have implemented as plugins to oclif to satisfy these needs, including encrypted OAuth, plugin signing, lazy loading dependencies, synchronizing weekly releases and deprecations across dozens of repositories, and establishing cross-team coding and documentation standards.
How Adobe I/O built an extensible CLI with oclif by Jesse MacFadyen​

Perhaps oclif's most appealing feature is its support for plugins. In Cordova's case, they've created a sophisticated telemetry system that helps Adobe developers see which commands users are using--and reports on which ones are erroring out. By embedding a feedback system into the tool, users are even able to quickly send their suggestions to a form, without ever leaving the terminal. Jesse MacFadyen demonstrates how oclif's plugin system can work beyond simply executing commands.
Integrating oclif with GraphQL and Apollo by Evans Hauser​

For Evans Hauser and the team at Apollo, oclif is best thought of as "React for the CLI." As a client paired with a strongly-typed API contract to a server, it can deliver structured and consistent commands to retrieve external data. What better mechanism to use for this transfer than GraphQL, a framework which empowers the client to ask precisely for the data it needs, and nothing more?
Adaptive Intent-based CLI State Machines by Shawn Wang​

In designing oclif, Jeff Dickey wrote out 12 CLI factors to keep in mind. In this talk, Shawn Wang outlines a 13th: state. State is hard, because it depends on context, and context depends on understanding what a user intends to do, not what they are asking. Shawn is working towards enabling oclif to better understand the commands a user has entered, so that it can predict and interpret future commands that might be entered next. This would enable CLI tools to not just interpret a users' commands, but to also interpret their intent.\n\nIntroducing `oclif init` commandApril 10, 2024 · 2 min readThanks to the contribution of @joshcanhelp we released a new command for the oclif CLI called oclif init in version 4.8.0
The oclif init command allows you to initialize oclif in an existing project directory by adding the bare minimum requirements: a few pieces of configuration, bin scripts, and a couple of dependencies (@oclif/core and ts-node). This is slightly different from oclif generate, which will create an entirely new oclif project based on our templates.
oclif init will add the following:

bin scripts: bin/run.js, bin/run.cmd, bin/dev.js, and bin/dev.cmd
oclif section to package.json with bin, dirname, commands, and topicSeparator set (See Configuring Your CLI for more)
@oclif/core to dependencies in your package.json (if it's not already there)
ts-node to devDependencies in your package.json (if it's not already there)

Once you've initialized oclif, you can use the bin scripts to execute your CLI. You can also use the other oclif commands like oclif generate command and oclif generate hook to start adding new functionality.

❯ oclif init --helpInitialize a new oclif CLIUSAGE  $ oclif init [--bin <value>] [--module-type ESM|CommonJS] [--package-manager npm|yarn|pnpm] [--topic-separator    colons|spaces] [-d <value>] [-y]FLAGS  -d, --output-dir=<value>        Directory to initialize the CLI in.  -y, --yes                       Use defaults for all prompts. Individual flags will override defaults.      --bin=<value>               Supply answer for prompt: Command bin name the CLI will export      --module-type=<option>      Supply answer for prompt: Select a module type                                  <options: ESM|CommonJS>      --package-manager=<option>  Supply answer for prompt: Select a package manager                                  <options: npm|yarn|pnpm>      --topic-separator=<option>  Supply answer for prompt: Select a topic separator                                  <options: colons|spaces>DESCRIPTION  Initialize a new oclif CLI  This will add the necessary oclif bin files, add oclif config to package.json, and install @oclif/core and ts-node.EXAMPLES  Initialize a new CLI in the current directory    $ oclif init  Initialize a new CLI in a different directory    $ oclif init --output-dir "/path/to/existing/project"  Supply answers for specific prompts    $ oclif init --topic-separator colons --bin mycli
Hope you enjoy the new command! If you come across any issues or have any new ideas for this command, head over to the oclif/oclif repo and open a new issue.
All our best,
The oclif teamoclif Spring 2024 UpdateMarch 29, 2024 · 4 min readHello oclif developers! It's been a while since we last uploaded a blog - and a lot has happened.
We've been focusing on these high-level areas over the past couple of years:

Improving @oclif/core
ESM Support
Improving and revitalizing oclif.io
Re-engaging the oclif community

Improving @oclif/core​
Since we announced @oclif/core over three years ago, we've released two new major versions, each packed with lots of features that we're really excited about.
Here are some of these changes:

Full support for ESM and interoperability with CommonJS (more on this topic below).
Configurable command discovery strategies that give you more control over how commands are loaded at runtime. Check out the docs.
A new preparse hook that allows you to manipulate the provided arguments before they're parsed. Salesforce used this hook to implement a neat --flags-dir feature that translates local files into flags.
A new Performance class that you can use to track performance inside of @oclif/core and your own CLI or plugin. Check out the docs.
A new flag type, Flags.option, that lets you define a flag with a preset list of options. Typescript then uses the options to infer the flag's type.
Flags now have a relationship property that allows you to define more complex relationships between flags. Check out the flags docs for more information.
Flags now have a defaultHelp property that allows you to set the human readable default value in the command help. This property is useful when your flag's parse method returns a complex type, such as an object or a class. Check out the flags docs for more.
Commands now have a hiddenAliases property that allows you to define aliases that you want to hide from the user. The property is super helpful when you're trying to wean users off a deprecated command.
You can now use bun or tsx as dev runtimes (as opposed to node or ts-node).
A command's usage, args, and flags are now shown whenever a user forgets to provide a required arg or flag, or when they provided a non-existent flag.

If you need help migrating to the latest version, head over to core's README which has links to the migration guides. Feel free to open a new discussion if you need more hands-on help from us or the community.
ESM Support​
Version 3 of @oclif/core introduced full support for developing ESM plugins and CLIs. It also offered full support for interoperability between CommonJS and ESM plugins.
Put more simply, you can now migrate your CLI to ESM while keeping individual plugins in CommonJS (or vice versa). The upgrade path is now much simpler for you. You also don't need to worry about any community plugins that have migrated to ESM before you did (such as all the @oclif plugins) or are staunchly sticking with CommonJS for the foreseeable future.
Read more about this topic here.
Improving and Revitalizing oclif.io​
Another area of focus for us has been improving our documentation site, oclif.io.
While improving the quality and accuracy of the documentation was our priority, we also took the time to upgrade to the latest version of docusaurus. This new version gave our site a much-needed facelift, as well as cool new features such as dark mode and announcements.
If you have any feedback or are running into issues, we want to hear about it. Just create an issue in the oclif.io repo.
Re-engaging the oclif Community​
Lastly, our biggest priority at the moment is to re-engage the oclif community. We understand how frustrating it has been over the years to see your issues and pull requests go unacknowledged. We apologize for not prioritizing the community, and are earnestly trying to make sure that every issue and pull request gets the attention it deserves going forward.
We also opened up GitHub discussions for @oclif/core and the oclif CLI, where you can now post your questions or ideas. We hope you take advantage of them, we love hearing from you!
One last thing: we intend to publicly post our roadmap so you have more visibility into what we're working on. Stay tuned!
All our best,
The oclif teamAnnouncing oclif v2!January 12, 2022 · 5 min readHello and happy new year! It's our great pleasure to announce that we have released oclif v2, which uses the new @oclif/core library! 🎉
oclif v2 includes many changes that improve the experience of both creating and using an oclif CLI.
Going forward, we don't plan to make any updates to oclif v1 and its corresponding libraries, except for critical security fixes. See the compatibility matrix for a list of these libraries. In order to give developers time to migrate from v1 to v2, we're not completely dropping support yet. But at some point in the future we'll archive the v1 repositories and deprecate their versions on npm.
What’s changing?​
Repository Changes​
All repositories under the oclif org now use main as their primary branch and oclif-v1 as the legacy branch. The main  branch corresponds to oclif v2 and the oclif-v1 branch to oclif v1. If you find any repos that don’t have a main branch, you can safely assume that they're not used in oclif v2 and will be deprecated in the future.
Consolidating Tools & Libraries​
The oclif-dev CLI has now been incorporated into oclif. You now no longer need to install a separate package to manage your entire CLI’s lifecycle.
The following libraries have been consolidated under @oclif/core and will be deprecated at some point in the future. Read the migration guide to learn how to update your CLI or plugin to use the new core library.

@oclif/command
@oclif/config
@oclif/error
@oclif/help
@oclif/parser

No more single vs multi command CLIs​
There's only one "type" of oclif v2 CLI, but it can have as few or as many commands as a developer wants. As a result, there’s only one command to generate CLIs, oclif generate, as opposed to the old oclif single and oclif multi commands.
Node > 12​
To ensure oclif CLIs are as secure as possible, all v2 libraries and plugins support only Node 12 or higher as of now. Going forward, they'll support only Node Maintenance or higher, as defined by Node's release schedule here: https://nodejs.org/en/about/releases/.
What’s new?​
New example CLI​
oclif-hello-world is our new example repo. This is also the repo that's used as a template when running oclif generate to create a new CLI. This repo will always be able to be referenced as an example of what an oclif v2 CLI should look like.
Spaced commands​
oclif CLIs can now use spaces, instead of colons, to separate topics and subcommands. To enable this feature, simply add “topicSeparator": " " to the oclif config in your package.json. See an example in our example repo.
// Old commands that use :$ mycli do:something
// New spaced commands$ mycli do something

Note: Spaced commands are backwards compatible. So if you enable spaced commands for your CLI, users will still be able to use : as a separator. This ensures that any existing scripts don't break.

New Help Output​
We’ve revamped the way command help is outputted to the terminal, making it both easier to implement and easier to read. See the difference between the old help output on the left and the new help output on the right in the screenshots below.
oclif v1oclif v2
Notice that there are new sections for flags and global flags, examples are displayed with better spacing, and there is a section at the bottom called Configuration Variables. This Configuration Variables section is not part of the new help by default. But we've added support for custom help sections, which is what the sf CLI uses to create the new section.
Async Command Parsing​
We’ve also improved the performance of new CLIs by rewriting how commands are parsed on initialization. The new parser is asynchronous, which makes CLIs with a lot of commands or installed  plugins much faster.
What’s coming next?​
Part of our charter for the release of oclif v2 includes improving our engagement with the oclif community. We know that over the past couple of years we’ve reduced our involvement, and a lot of issues and PRs have languished in limbo. Hopefully you’ve already seen increased activity and responses from oclif maintainers recently, but if you haven’t, please don’t hesitate to ping us by tagging @admins in oclif repos.
We also want to start interviewing members of the oclif community to acquire feedback and prioritize the features and fixes you deem most important!
Best,
The oclif team

Reference material​
Migration Guide​
This guide explains how to upgrade a CLI or plugin from the old oclif v1 libraries to the new @oclif/core library that oclif v2 uses.
https://github.com/oclif/core/blob/main/MIGRATION.md
Compatibility Matrix​
The following matrix shows how the v1 libraries and plugins relate to the new v2 ones. Use this matrix as a guide to know what to drop and which versions to switch when upgrading your plugins and CLIs to v2.
oclif "v1"oclif "v2"Utility CLIsoclif@<2@oclif/dev-cli@<2oclif@>=2Main packages@oclif/command@oclif/config@oclif/errors@oclif/parser@oclif/plugin-help@oclif/core@>=1Node LTSNode v8-14Node v12+ (at time of writing)TypeScripttypescript@<4typescript@>=4Main plugins@oclif/plugin-autocomplete@<1@oclif/plugin-commands@<2@oclif/plugin-help@<4@oclif/plugin-not-found@<2@oclif/plugin-plugins@<2@oclif/plugin-update@<2plugin-warn-if-update-available@<2plugin-which@<2@oclif/plugin-autocomplete@>=1@oclif/plugin-commands@>=2@oclif/plugin-help@>=4@oclif/plugin-not-found@>=2@oclif/plugin-plugins@>=2@oclif/plugin-update@>=2@oclif/plugin-warn-if-update-available@>=2@oclif/plugin-which@>=2Introducing @oclif/coreMarch 1, 2021 · 3 min readGreetings!
We hope this blog post finds you well.
Introducing...​
We are excited to announce the next iteration of the oclif project today: @oclif/core.
We have learned a lot in the last three years of developing oclif, developing on oclif and supporting millions of command runs a day via Heroku and Salesforce CLIs.
@oclif/core ("Core") simplifies the oclif development experience and introduces highly requested new features.
Core combines the essential oclif packages into one "core" package, aptly named @oclif/core.
Core also introduces:

A default command option
Colon or space command syntax
Async command parsing
Command piping to arguments

With the introduction of default command functionality, Core simplifies the oclif project and removes the notion of single or multi command CLIs. Core CLIs can have 1 or many commands.
Along with Core, we moved the oclif-dev CLI into the oclif CLI creating a single "utility" CLI. This CLI also introduces a new AWS S3 compatible publishing scheme.
What to expect in the near future​
Core is in pre-release beta and being actively developed for new internal Salesforce CLIs.
Much documentation needs to be written in the coming months including migration paths. Migration onto Core should be as painless as possible with many exports remaining entirely unchanged. Look for forthcoming blog posts and documentation on oclif.io.
Early this summer, tentively June 1, we will release Core v1. Core's release will coincide with major bumps to many other oclif plugin packages. See the compatibility matrix below.
At Core's v1 release, the current "main" oclif packages (namely: command, config, errors & parser) will go into maintenance mode until Jan 2022. They will receive only bug and security fixes and they remain compatible with current versions of the oclif and oclif-dev CLIs. Afterwhich, they will be archived.
Companioning Core, the next major release of the oclif CLI (literally oclif@2) will generate Core CLIs.
Going forward​
We are excited to release Core! We invite you to poke around the Core repo. It may appear to be a big change but Core keeps what you already enjoy about oclif while reducing development complexity, project dependencies, package coupling and bundle size and introduces many requested features previously too prickly to weave into the current oclif architecture.
Best,
The oclif team
Reference: Compatibility matrix​
oclif "v1"oclif "Core"Utility CLIsoclif@<2@oclif/dev-cli@<2oclif@>=2Main packages@oclif/core@<2@oclif/config@<2@oclif/errors@<2@oclif/parser@<4@oclif/plugin-help@<4@oclif/core@>=1Node LTSNode v8-14Node v12+TypeScripttypescript@<4typescript@>=4Main plugins@oclif/plugin-autocomplete@<1@oclif/plugin-commands@<2@oclif/plugin-help@<4@oclif/plugin-not-found@<2@oclif/plugin-plugins@<2@oclif/plugin-update@<2plugin-warn-if-update-available@<2plugin-which@<2@oclif/plugin-autocomplete@>=2@oclif/plugin-commands@>=2@oclif/plugin-help@>=4@oclif/plugin-not-found@>=2@oclif/plugin-plugins@>=2@oclif/plugin-update@>=2@oclif/plugin-warn-if-update-available@>=2@oclif/plugin-which@>=2oclif Summer 2020 UpdateAugust 26, 2020 · 2 min readHello oclif developers! We hope you are all doing well.
Earlier this year, we started our planning for oclifconf v2 and, like all conference, had to change course. We opted not to hold a virtual conference, however, we wanted to take some time to highlight a few oclif features shipped this year.
Feature: Help templating​
One of the most requested features, help templating enables oclif developers to customize the help output for their CLI.
Read the announcement.
Feature: Custom error delegation​
This feature both improved how oclif throws and handles errors and allows oclif developers to overwrite or interject in oclif’s error handling.
Read the announcement.
Feature: postrun hooks​
We have added a new lifecycle event postrun. Your CLI can now run a hook after a command has ran.
See our hook documentation.
Feature: Root index command​
Previously, oclif would display CLI help if only the binary name with no command ID was invoked, oclif now supports a "root index" command. If present, a command defined at src/commands/index.ts will be run if no command ID is found.
1 million weekly downloads​
While exact oclif usage metrics are hard to pin down, we use npm download statistics of oclif packages as a rough approximation. Earlier this year, oclif's command package hit 1 million weekly downloads for the first time!
This year has been presented its challenges on everyone. We want to thank you, oclif developers, whom have taken the time to use and improve the oclif project. We look forward to seeing you all - in person - in the future!
All our best,
The oclif teamPretty Printable ErrorsJuly 1, 2020 · One min readOften CLIs are used as handy tools and when things go wrong it’s useful to have additional context. In oclif we have added a couple of additional properties that can show extra context to the users when an error is displayed. The code, ref and suggestions will now be displayed if they are included. This will work with an existing oclif CLI by adding the latest @oclif/errors and @oclif/core to the CLI's package.json dependencies.
For example, using this.error with the additional properties:
class TestError extends Command {  async run() {    this.error("An error has occurred!", {      code: "OCLIF_ERR",      ref: "https://oclif.io/docs/commands#thiserrormessage-string--error-options-code-string-exit-number",      suggestions: ["Use these extra properties to provide additional context"],    })  }}
would result with the following output:
›   Error: An error has occurred!›   Code: OCLIF_ERR›   Try this: Use these extra properties to provide additional context›   Reference: https://oclif.io/docs/commands#thiserrormessage-string--error-options-code-string-exit-number
If these properties are not provided then nothing changes and the CLI will continue to display the single error message output as it did before. Additionally, as part of this exercise we’ve added documentation around Error Handling in oclif which should come in handy if the need arises to extend oclif’s default handling of errors.Customizing Help in oclifMay 5, 2020 · 2 min readOut of the box oclif provides a great help experience for CLIs.
But what if, as an oclif developer, you want to customize some or all of the output?
You can now customize your CLI's help output by implementing the HelpBase abstract class.
Getting started with custom help​
If you have not done so yet, update @oclif/core.
$ yarn add --latest @oclif/core
To get started, first define the filepath to your help class in oclif's config in package.json. This is a relative path to the help class, without a file extension.
For this example, the help class will be created in a file at "[project root]/src/help.ts".
{  // ...  "oclif": {    "helpClass": "./lib/help"    // ...  }  // ...}
From here there are two paths, implement the HelpBase abstract class yourself or overwrite the parts of the default Help class you want to customize (ex: how command usage is displayed). We recommend the latter approach but cover both in the new Help Classes docs.
Separating TOPICS & COMMANDS in the new default Help class​
Previously, topics and child commands were listed in help output under a single list heading called "COMMANDS". But we found this can be slightly confusing. Some topics are commands also (a.k.a. topic-commands) while others are simply organizational namespacing (and when ran just show their help).
The new default Help class splits the list of children into distinct lists of "TOPICS" and "COMMANDS", with the possibility of an item appearing in both if it a topic-command. This makes it clearer what is expected to be ran - "COMMANDS" - and what is providing structure - "TOPICS" - when looking at the help output.
VERSION  plugin-help-example/0.0.0 darwin-x64 node-v12.12.0USAGE  $ plugin-help-example [COMMAND]TOPICS  topic  this is a topic and has child topics or commandsCOMMANDS  hello  describe the command here  help   display help for plugin-help-example
We look forward to seeing what custom help features you implement in your oclif CLIs with this new feature!oclif TSLint to ESLint MigrationDecember 5, 2019 · 3 min readBack in February of this year, plans were announced to deprecate TSLint in favor of ESLint. TSLint's goal has become to work toward a “unified developer experience” by supporting ESLint development going forward.
What has changed in oclif​
To keep inline with the community, oclif has transitioned to ESLint for all our core libraries as well as all our official plugins.
Starting in v1.15.x, oclif will now optionally generate projects with ESLint for both TypeScript and JavaScript CLI’s.
ESLint does require Node to be on stable LTS version, at the time of writing, Node 8.10.x, Node 10.13.x & Node 12.x.x.
How does this affect you​
Existing CLI’s are unchanged, but any newly generated CLI's will only give the option of using ESLint. If you are running tslint in your CLI, we recommend you switch to ESLint as well.
In migrating our projects we took the following steps (for an example of these changes see this pull request).


Install eslint
$ yarn add eslint eslint-config-oclif eslint-config-oclif-typescript --dev


Add eslint related files


$ echo '{  "extends": [    "oclif",    "oclif-typescript"  ],  "rules": {  }}' > .eslintrc


Remove tslint and related packages
$ yarn remove @oclif/tslint tslint


Remove tslint related configuration files
$ rm tslint.json


Change lint script in our package.json from something like:
"lint": "tsc -p test --noEmit && tslint -p test -t stylish"
to
"lint": "eslint . --ext .ts --config .eslintrc"


To preserve the test compile (tsc -p test --noEmit) we also made the following updates to our scripts:
"pretest": "tsc -p test --noEmit"
In some cases we had our posttest duplicating the same steps as our lint script so it’s cleaner to have it reference the lint job directly with:
"posttest": "yarn lint"

Run yarn lint --fix. This attempts to auto-fix any linting violations automatically. In the case an auto-fix isn’t available it should be fixed manually or ignored (see the eslint configuration doc for more information)
Do a search in the codebase for tslint and remove any unnecessary tslint disabling comments, like:

/* tslint:disable:object-literal-sort-keys */
If you are on a version of Node that is not supported by ESLint, you will also need to update your Node engine. ESLint supports Node 8, 10, and 12 so you should upgrade to the most recent Node version compatible with your CLI and also supported by ESLint (see ESLint's Installation and Usage instructions).
When will this take effect​
These changes have taken effect in oclif v1.15.1. When you generate a new CLI or plugin it will now contain configuration for ESLint instead of TSLint.oclif's Current Node SupportOctober 31, 2019 · 3 min readTo maintain a healthy project trajectory, oclif follows and supports Node Active LTS release, currently Node 10 & Node 12. This means ensuring that oclif continues to play nice with coming Active LTS Node versions and other packages in the ecosystem. Moving forward also means leaving older versions behind. Starting in 2020, Node will stop maintaining Node 8 and it is our intent at that time to also follow suit. Let’s take a look at a few ways we will be supporting these changes.
CI Environments​
CLIs created with the oclif cli going forward will be generated with a CircleCI configuration with Node 10 & 12 and an Appveyor configuration using Node 10. We have also added Node latest to CircleCi to be an early warning detection against coming Node changes (Node latest is managed by CircleCI).
We have already updated every oclif repo's CI configs to reflect this.
If your existing CLI uses either Appveyor or CircleCI you can update your config files also, like so:
.circleci/config.yml​
Your CircleCI config should contain a node-latest job, aliased as test. From this, there should be two extensions of this job for the Active LTS Node versions, Node 10 and Node 12.
  node-10:    <<: *node-latest    docker:      - image: node:10  node-12:    <<: *node-latest    docker:      - image: node:12
Notice that these declarations only change the Docker Node images used to run that job.
Additionally, the jobs listed within workflows must also be updated to reflect our changes in configuration:
    jobs:      - node-latest      - node-10      - node-12
appveyor.yml​
For appveyor we are currently only testing the oldest Active LTS Node version, Node 10. Update the nodejs_version proppert in your appveyor.yml file to reflect this.
environment:  nodejs_version: "10"
Deprecating Node 8 & Updating packge.json engines​
In Jan 2020, Node will end its Node 8 maintenance. We will follow suit by setting the package.json engine property in oclif packages to >=10 and bumping the package's major versions.
Depending on how you ship your CLI you may wish to also bump the engines version in your CLI's package.json. You can read more about the implications of the engines property configuration in the npm documentation.
Also consider distributing your CLI with its own Node version.
Packaged Node Version​
When using dev-cli to pack your CLI it will use the Node version as specified in your package.json under the oclif.update.node.version property. This value should reflect an Active LTS Node version (dev-cli does not currently enforce versions).
Supporting the future​
As a community we may discover bumps along the way as we upgrade. If you notice something related to oclif please feel free to open an issue or submit a pull request under the relevant oclif package within the org.
We look forward to using the latest from Node and the community and keeping oclif healthy along the way.oclifconf 2019: A RecapSeptember 16, 2019 · 4 min readIn May, Heroku and Salesforce Open Source organized oclifconf, a conference for developers & product managers building CLI tools on top of the open source oclif framework. The speakers came from various tech companies, such as Adobe, Netlify, and Apollo, who have already built amazing CLI experiences. The topics covered everything from the incredible capabilities oclif has unlocked, to the community-built plugins extending its functionality, and even what the behavior of an adaptive CLI tool might look like.
Below is a listing of all of the talks from the event, along with a short summary. Enjoy!
The future of oclif by Jeff Dickey​

In its relatively short lifetime, oclif has already inspired many developers and companies to adopt its framework as a means for implementing their own command-line tooling. In this talk, Jeff Dickey, an oclif founding team member, recaps the project's history and inspiration. He also looks towards the future and outlines some features and improvements that the tool could adapt. This isn't so much a definitive roadmap of where oclif is headed, but rather, a call to inspiration for developers eager to contribute! And if you are interested in contributing, check out the open issues in the oclif GitHub repo and come say "Hello!" on Spectrum Chat.
Open Source Citizenship by Josh Simmons​

When it comes to open source, it's more than just individuals now. More and more frequently, large corporations are contributing to projects by donating to contributors, sponsoring events, or upstreaming contributions. But keeping open source projects and communities healthy requires more than just money and brainpower. Josh Simmons surveyed multiple open source communities and relays his findings as to what help maintainers and contributors actually need in this talk.
Building an enterprise-grade CLI with oclif by Thomas Dvornik​

Security and performance are all about trust. While oclif is an extremely extensible framework for building CLI tooling, there are additional requirements to fulfill for enterprise businesses to adopt it that might not be necessary for individual developers. Thomas Dvornik outlines what he and his colleagues at Salesforce have implemented as plugins to oclif to satisfy these needs, including encrypted OAuth, plugin signing, lazy loading dependencies, synchronizing weekly releases and deprecations across dozens of repositories, and establishing cross-team coding and documentation standards.
How Adobe I/O built an extensible CLI with oclif by Jesse MacFadyen​

Perhaps oclif's most appealing feature is its support for plugins. In Cordova's case, they've created a sophisticated telemetry system that helps Adobe developers see which commands users are using--and reports on which ones are erroring out. By embedding a feedback system into the tool, users are even able to quickly send their suggestions to a form, without ever leaving the terminal. Jesse MacFadyen demonstrates how oclif's plugin system can work beyond simply executing commands.
Integrating oclif with GraphQL and Apollo by Evans Hauser​

For Evans Hauser and the team at Apollo, oclif is best thought of as "React for the CLI." As a client paired with a strongly-typed API contract to a server, it can deliver structured and consistent commands to retrieve external data. What better mechanism to use for this transfer than GraphQL, a framework which empowers the client to ask precisely for the data it needs, and nothing more?
Adaptive Intent-based CLI State Machines by Shawn Wang​

In designing oclif, Jeff Dickey wrote out 12 CLI factors to keep in mind. In this talk, Shawn Wang outlines a 13th: state. State is hard, because it depends on context, and context depends on understanding what a user intends to do, not what they are asking. Shawn is working towards enabling oclif to better understand the commands a user has entered, so that it can predict and interpret future commands that might be entered next. This would enable CLI tools to not just interpret a users' commands, but to also interpret their intent.Older Entries\n\n\n\nCLI Flags ExplainedFebruary 20, 2019 · 5 min readCasey Watts and Jeff Dickeyoclif makes it easy to create a command line interface (CLI) in node. Most commands have parameters — also known as "flags", "args", and sometimes "options". This blog post explains what these parameters are and when to use them. We also have a new feature that makes it easier for users to detect typos when using parameters.
Note the following describes GNU-style flags. Not all CLIs follow this convention, but it is the most commonly used.
Parts of Speech​
Any command line interface command has a few standard "parts of speech".  As a user of CLI tools, knowing these parts of speech can help you make fewer typos. It can also help you understand complex commands other people share with you more quickly. If you are designing a CLI tool it is even more important to understand these parts of speech, so you can come up with the most ergonomic interface for your users.
Of the many ways you can pass data to a CLI command, three of them are parameters that are always to the "right" of the command. The three types of parameters are argument, short flag, and long flag.
Example ls​
One of the  most common and simplest unix commands is ls which "lists" the contents of a directory.
command​
ls
This command ls works on its own, as a standalone command. Without any parameters this command will list the contents of the current folder, using an implied . directory.
argument​
ls .ls ~/code/some-repo-name
If you pass a command argument to this command, like the directory name . (current folder) or ~/code/some-repo-name, it will list the contents of that directory instead.
An argument is anything to the right of a command that is not a flag. An argument can come before or after flags.
Long flag​
To list additional files that are normally hidden (like ~/.bashrc), you can use a flag on the ls command. ls --all is the long flag form. A long flag always uses a double dash, and it is always represented by multiple characters.
ls --allls . --all
Short flag​
There is also a short flag form of this flag: ls -a. The a is short for all in this case. A short flag always uses a single dash, and it is always represented by a single letter.
ls -als . -a
Short flags can stack too, so you don't need a separate dash for each one. Order does not matter for these, unless passing a flag argument.
ls -la
Flag arguments​
Many flags accept an option, which is a "flag argument" (as opposed to a "command argument"). In general a command's parameters can be in any order, but flags that accept options must have the option directly after the flag.
For an example, here the -x flag does not accept an option but the -f flag does. archive.tar is the option being passed to -f.
tar -x -f archive.tartar -xf archive.tar
A flag and its option can be separated by a space   or an equals sign =. Interestingly, short flags (but not long flags) can even skip the space, although many people find it much easier to read with the space or equals sign.
These three are all valid and equivalent:
tar -f archive.tartar -f=archive.tartar -farchive.tar
Long flags must have a space or equals sign to separate the flag from its option.
git log --pretty=onelinegit log --pretty oneline
Other Ways of Passing Data​
We've covered parameters, which are arguments, short flags and long flags. There are two other ways to pass data to a command: environment variables ("env vars"), or standard input ("stdin"). These won't be covered in this blog post.
Designing a Command​
Scenario: we want to design an oclif command that echos an input like "Casey", and returns "hi, Casey!". There are many ways the user could pass this in, and here we show an example of each type of input.
argument​
greet-me Casey
short flag with argument​
greet-me -n Caseygreet-me -n=Caseygreet-me -nCasey
long flag with argument​
greet-me --name=Caseygreet-me --name Casey
environment variable​
NAME=Casey greet-me
standard input​
echo "Casey" | greet-me
Command ergonomics​
Short flag vs long flag​
Many CLI commands allow for both long flag and short flag forms. In the Heroku CLI every flag has at least a long flag form and roughly half of the flags also have a short flag form.
The long flag form is easier to read, but takes more characters to type. It is often most useful when you want someone to understand a particular command statement quickly and easily, such as in a README.
The short flag form is quicker to type, and is often better for frequently used commands. Short flags are especially useful when stacking short flags together.Introducing oclifMarch 20, 2018 · One min readJeff Dickey
Coding for the browser takes serious time. You need to deal with front-end JS, CSS, design, product, and a ton more. On the other hand, building for a CLI takes a fraction of the effort. This makes CLIs particularly great for prototyping out new functionality, offering admin/internal tools, or power-user functionality.
Read More\n\nCLI Flags ExplainedFebruary 20, 2019 · 5 min readCasey Watts and Jeff Dickeyoclif makes it easy to create a command line interface (CLI) in node. Most commands have parameters — also known as "flags", "args", and sometimes "options". This blog post explains what these parameters are and when to use them. We also have a new feature that makes it easier for users to detect typos when using parameters.
Note the following describes GNU-style flags. Not all CLIs follow this convention, but it is the most commonly used.
Parts of Speech​
Any command line interface command has a few standard "parts of speech".  As a user of CLI tools, knowing these parts of speech can help you make fewer typos. It can also help you understand complex commands other people share with you more quickly. If you are designing a CLI tool it is even more important to understand these parts of speech, so you can come up with the most ergonomic interface for your users.
Of the many ways you can pass data to a CLI command, three of them are parameters that are always to the "right" of the command. The three types of parameters are argument, short flag, and long flag.
Example ls​
One of the  most common and simplest unix commands is ls which "lists" the contents of a directory.
command​
ls
This command ls works on its own, as a standalone command. Without any parameters this command will list the contents of the current folder, using an implied . directory.
argument​
ls .ls ~/code/some-repo-name
If you pass a command argument to this command, like the directory name . (current folder) or ~/code/some-repo-name, it will list the contents of that directory instead.
An argument is anything to the right of a command that is not a flag. An argument can come before or after flags.
Long flag​
To list additional files that are normally hidden (like ~/.bashrc), you can use a flag on the ls command. ls --all is the long flag form. A long flag always uses a double dash, and it is always represented by multiple characters.
ls --allls . --all
Short flag​
There is also a short flag form of this flag: ls -a. The a is short for all in this case. A short flag always uses a single dash, and it is always represented by a single letter.
ls -als . -a
Short flags can stack too, so you don't need a separate dash for each one. Order does not matter for these, unless passing a flag argument.
ls -la
Flag arguments​
Many flags accept an option, which is a "flag argument" (as opposed to a "command argument"). In general a command's parameters can be in any order, but flags that accept options must have the option directly after the flag.
For an example, here the -x flag does not accept an option but the -f flag does. archive.tar is the option being passed to -f.
tar -x -f archive.tartar -xf archive.tar
A flag and its option can be separated by a space   or an equals sign =. Interestingly, short flags (but not long flags) can even skip the space, although many people find it much easier to read with the space or equals sign.
These three are all valid and equivalent:
tar -f archive.tartar -f=archive.tartar -farchive.tar
Long flags must have a space or equals sign to separate the flag from its option.
git log --pretty=onelinegit log --pretty oneline
Other Ways of Passing Data​
We've covered parameters, which are arguments, short flags and long flags. There are two other ways to pass data to a command: environment variables ("env vars"), or standard input ("stdin"). These won't be covered in this blog post.
Designing a Command​
Scenario: we want to design an oclif command that echos an input like "Casey", and returns "hi, Casey!". There are many ways the user could pass this in, and here we show an example of each type of input.
argument​
greet-me Casey
short flag with argument​
greet-me -n Caseygreet-me -n=Caseygreet-me -nCasey
long flag with argument​
greet-me --name=Caseygreet-me --name Casey
environment variable​
NAME=Casey greet-me
standard input​
echo "Casey" | greet-me
Command ergonomics​
Short flag vs long flag​
Many CLI commands allow for both long flag and short flag forms. In the Heroku CLI every flag has at least a long flag form and roughly half of the flags also have a short flag form.
The long flag form is easier to read, but takes more characters to type. It is often most useful when you want someone to understand a particular command statement quickly and easily, such as in a README.
The short flag form is quicker to type, and is often better for frequently used commands. Short flags are especially useful when stacking short flags together.Introducing oclifMarch 20, 2018 · One min readJeff Dickey
Coding for the browser takes serious time. You need to deal with front-end JS, CSS, design, product, and a ton more. On the other hand, building for a CLI takes a fraction of the effort. This makes CLIs particularly great for prototyping out new functionality, offering admin/internal tools, or power-user functionality.
Read MoreNewer Entries\n\n\n\nGetting StartedFeaturesOn this pageFeaturesHere are some key features that set oclif apart from other CLI frameworks.
Flag and Argument Parsing​
No CLI framework is complete without a flag parser. We've built a custom flag parser from years of experimentation that we feel is flexible enough to make an easy, predictable user experience but without compromising type safety for the developer.
Configurable Topic Separators​
By default, topics are separated with colons, such as my:awesome:command. However, you can use spaces if you prefer, such as my awesome command.
Super Speed​
The overhead for running an oclif CLI command is almost nothing. The command requires few dependencies; for example, only 17 dependencies are required for a minimal setup. Also, only the command to be executed requires Node.js. Which means that a large CLI with many commands loads as fast as a small CLI with just a single command.
CLI Generator​
You can get started from scratch quickly; all you need is a single command to scaffold out a fully functional CLI. See Generator Commands.
Testing Helpers​
We've worked hard to make commands easily testable and easy to mock out stdout and stderr. The CLI generator automatically creates scaffolded tests.
Auto-documentation​
By default, you pass --help to a CLI command to get help, such as the flag options and argument information. This information is also automatically added to the README whenever the CLI's npm package is published. See the plugin-plugins as an example.
Plugins​
Using plugins, you can extend a CLI with new functionality, split it into modular components, and share its functionality among multiple CLIs. See Building your own plugin.
Hooks​
Use lifecycle hooks to run functionality anytime a CLI starts, or on custom triggers. Use hooks whenever you want to share custom functionality between various components of the CLI. See Hooks.
JSON Output​
Your CLI can opt in to using the --json flag, which causes commands to automatically suppress console logs and display their final results as valid JSON output. The --json flag is useful if you want to use your CLI for scripting in CI/CD environments. See JSON.
Flexible Taxonomy​
You can opt in to what we call flexible taxonomy. When enabled, this feature allows users to execute commands without adhering to your defined command taxonomy.
This feature makes your CLI more user-friendly, especially if you have long command names which users find difficult to remember. For example, users can find it hard to remember if a command is called project deploy metadata start or project start deploy metadata - with flexible taxonomy, it doesn't matter because both are valid!
TypeScript (or not)​
Everything in the core of oclif is written in TypeScript, and the CLI generator can build both fully configured TypeScript or plain JavaScript CLIs. Because of TypeScript static properties, the syntax is a bit cleaner in TypeScript — but everything works, no matter which language you choose. If you use plugins support, the CLI automatically uses ts-node to run the plugins, which makes it easy and fast to use TypeScript with minimal-to-no boilerplate needed for any oclif CLI.
Auto-Updating Installers​
oclif can package your CLI into different installers that don't require the user to already have Node.js installed on their computer. You can make these installers auto-updatable by using plugin-update.
Autocomplete​
Include terminal autocompletion for your CLI with the plugin-autocomplete. After the autocomplete feature is configured, users can complete command names and flag names by pressing the tab key.
$ my-cli p<tab><tab> # lists all commands starting with 'p' for completionEdit this pageLast updated on Dec 20, 2024 by Mike Donnalley\n\nGetting StartedFeaturesOn this pageFeaturesHere are some key features that set oclif apart from other CLI frameworks.
Flag and Argument Parsing​
No CLI framework is complete without a flag parser. We've built a custom flag parser from years of experimentation that we feel is flexible enough to make an easy, predictable user experience but without compromising type safety for the developer.
Configurable Topic Separators​
By default, topics are separated with colons, such as my:awesome:command. However, you can use spaces if you prefer, such as my awesome command.
Super Speed​
The overhead for running an oclif CLI command is almost nothing. The command requires few dependencies; for example, only 17 dependencies are required for a minimal setup. Also, only the command to be executed requires Node.js. Which means that a large CLI with many commands loads as fast as a small CLI with just a single command.
CLI Generator​
You can get started from scratch quickly; all you need is a single command to scaffold out a fully functional CLI. See Generator Commands.
Testing Helpers​
We've worked hard to make commands easily testable and easy to mock out stdout and stderr. The CLI generator automatically creates scaffolded tests.
Auto-documentation​
By default, you pass --help to a CLI command to get help, such as the flag options and argument information. This information is also automatically added to the README whenever the CLI's npm package is published. See the plugin-plugins as an example.
Plugins​
Using plugins, you can extend a CLI with new functionality, split it into modular components, and share its functionality among multiple CLIs. See Building your own plugin.
Hooks​
Use lifecycle hooks to run functionality anytime a CLI starts, or on custom triggers. Use hooks whenever you want to share custom functionality between various components of the CLI. See Hooks.
JSON Output​
Your CLI can opt in to using the --json flag, which causes commands to automatically suppress console logs and display their final results as valid JSON output. The --json flag is useful if you want to use your CLI for scripting in CI/CD environments. See JSON.
Flexible Taxonomy​
You can opt in to what we call flexible taxonomy. When enabled, this feature allows users to execute commands without adhering to your defined command taxonomy.
This feature makes your CLI more user-friendly, especially if you have long command names which users find difficult to remember. For example, users can find it hard to remember if a command is called project deploy metadata start or project start deploy metadata - with flexible taxonomy, it doesn't matter because both are valid!
TypeScript (or not)​
Everything in the core of oclif is written in TypeScript, and the CLI generator can build both fully configured TypeScript or plain JavaScript CLIs. Because of TypeScript static properties, the syntax is a bit cleaner in TypeScript — but everything works, no matter which language you choose. If you use plugins support, the CLI automatically uses ts-node to run the plugins, which makes it easy and fast to use TypeScript with minimal-to-no boilerplate needed for any oclif CLI.
Auto-Updating Installers​
oclif can package your CLI into different installers that don't require the user to already have Node.js installed on their computer. You can make these installers auto-updatable by using plugin-update.
Autocomplete​
Include terminal autocompletion for your CLI with the plugin-autocomplete. After the autocomplete feature is configured, users can complete command names and flag names by pressing the tab key.
$ my-cli p<tab><tab> # lists all commands starting with 'p' for completionEdit this pageLast updated on Dec 20, 2024 by Mike DonnalleyPreviousIntroductionNextFAQsFlag and Argument ParsingConfigurable Topic SeparatorsSuper SpeedCLI GeneratorTesting HelpersAuto-documentationPluginsHooksJSON OutputFlexible TaxonomyTypeScript (or not)Auto-Updating InstallersAutocomplete\n\n\n\nGetting StartedFeaturesOn this pageFeaturesHere are some key features that set oclif apart from other CLI frameworks.
Flag and Argument Parsing​
No CLI framework is complete without a flag parser. We've built a custom flag parser from years of experimentation that we feel is flexible enough to make an easy, predictable user experience but without compromising type safety for the developer.
Configurable Topic Separators​
By default, topics are separated with colons, such as my:awesome:command. However, you can use spaces if you prefer, such as my awesome command.
Super Speed​
The overhead for running an oclif CLI command is almost nothing. The command requires few dependencies; for example, only 17 dependencies are required for a minimal setup. Also, only the command to be executed requires Node.js. Which means that a large CLI with many commands loads as fast as a small CLI with just a single command.
CLI Generator​
You can get started from scratch quickly; all you need is a single command to scaffold out a fully functional CLI. See Generator Commands.
Testing Helpers​
We've worked hard to make commands easily testable and easy to mock out stdout and stderr. The CLI generator automatically creates scaffolded tests.
Auto-documentation​
By default, you pass --help to a CLI command to get help, such as the flag options and argument information. This information is also automatically added to the README whenever the CLI's npm package is published. See the plugin-plugins as an example.
Plugins​
Using plugins, you can extend a CLI with new functionality, split it into modular components, and share its functionality among multiple CLIs. See Building your own plugin.
Hooks​
Use lifecycle hooks to run functionality anytime a CLI starts, or on custom triggers. Use hooks whenever you want to share custom functionality between various components of the CLI. See Hooks.
JSON Output​
Your CLI can opt in to using the --json flag, which causes commands to automatically suppress console logs and display their final results as valid JSON output. The --json flag is useful if you want to use your CLI for scripting in CI/CD environments. See JSON.
Flexible Taxonomy​
You can opt in to what we call flexible taxonomy. When enabled, this feature allows users to execute commands without adhering to your defined command taxonomy.
This feature makes your CLI more user-friendly, especially if you have long command names which users find difficult to remember. For example, users can find it hard to remember if a command is called project deploy metadata start or project start deploy metadata - with flexible taxonomy, it doesn't matter because both are valid!
TypeScript (or not)​
Everything in the core of oclif is written in TypeScript, and the CLI generator can build both fully configured TypeScript or plain JavaScript CLIs. Because of TypeScript static properties, the syntax is a bit cleaner in TypeScript — but everything works, no matter which language you choose. If you use plugins support, the CLI automatically uses ts-node to run the plugins, which makes it easy and fast to use TypeScript with minimal-to-no boilerplate needed for any oclif CLI.
Auto-Updating Installers​
oclif can package your CLI into different installers that don't require the user to already have Node.js installed on their computer. You can make these installers auto-updatable by using plugin-update.
Autocomplete​
Include terminal autocompletion for your CLI with the plugin-autocomplete. After the autocomplete feature is configured, users can complete command names and flag names by pressing the tab key.
$ my-cli p<tab><tab> # lists all commands starting with 'p' for completionEdit this pageLast updated on Dec 20, 2024 by Mike Donnalley\n\nGetting StartedFeaturesOn this pageFeaturesHere are some key features that set oclif apart from other CLI frameworks.
Flag and Argument Parsing​
No CLI framework is complete without a flag parser. We've built a custom flag parser from years of experimentation that we feel is flexible enough to make an easy, predictable user experience but without compromising type safety for the developer.
Configurable Topic Separators​
By default, topics are separated with colons, such as my:awesome:command. However, you can use spaces if you prefer, such as my awesome command.
Super Speed​
The overhead for running an oclif CLI command is almost nothing. The command requires few dependencies; for example, only 17 dependencies are required for a minimal setup. Also, only the command to be executed requires Node.js. Which means that a large CLI with many commands loads as fast as a small CLI with just a single command.
CLI Generator​
You can get started from scratch quickly; all you need is a single command to scaffold out a fully functional CLI. See Generator Commands.
Testing Helpers​
We've worked hard to make commands easily testable and easy to mock out stdout and stderr. The CLI generator automatically creates scaffolded tests.
Auto-documentation​
By default, you pass --help to a CLI command to get help, such as the flag options and argument information. This information is also automatically added to the README whenever the CLI's npm package is published. See the plugin-plugins as an example.
Plugins​
Using plugins, you can extend a CLI with new functionality, split it into modular components, and share its functionality among multiple CLIs. See Building your own plugin.
Hooks​
Use lifecycle hooks to run functionality anytime a CLI starts, or on custom triggers. Use hooks whenever you want to share custom functionality between various components of the CLI. See Hooks.
JSON Output​
Your CLI can opt in to using the --json flag, which causes commands to automatically suppress console logs and display their final results as valid JSON output. The --json flag is useful if you want to use your CLI for scripting in CI/CD environments. See JSON.
Flexible Taxonomy​
You can opt in to what we call flexible taxonomy. When enabled, this feature allows users to execute commands without adhering to your defined command taxonomy.
This feature makes your CLI more user-friendly, especially if you have long command names which users find difficult to remember. For example, users can find it hard to remember if a command is called project deploy metadata start or project start deploy metadata - with flexible taxonomy, it doesn't matter because both are valid!
TypeScript (or not)​
Everything in the core of oclif is written in TypeScript, and the CLI generator can build both fully configured TypeScript or plain JavaScript CLIs. Because of TypeScript static properties, the syntax is a bit cleaner in TypeScript — but everything works, no matter which language you choose. If you use plugins support, the CLI automatically uses ts-node to run the plugins, which makes it easy and fast to use TypeScript with minimal-to-no boilerplate needed for any oclif CLI.
Auto-Updating Installers​
oclif can package your CLI into different installers that don't require the user to already have Node.js installed on their computer. You can make these installers auto-updatable by using plugin-update.
Autocomplete​
Include terminal autocompletion for your CLI with the plugin-autocomplete. After the autocomplete feature is configured, users can complete command names and flag names by pressing the tab key.
$ my-cli p<tab><tab> # lists all commands starting with 'p' for completionEdit this pageLast updated on Dec 20, 2024 by Mike DonnalleyPreviousIntroductionNextFAQsFlag and Argument ParsingConfigurable Topic SeparatorsSuper SpeedCLI GeneratorTesting HelpersAuto-documentationPluginsHooksJSON OutputFlexible TaxonomyTypeScript (or not)Auto-Updating InstallersAutocomplete\n\n\n\nGetting StartedFeaturesOn this pageFeaturesHere are some key features that set oclif apart from other CLI frameworks.
Flag and Argument Parsing​
No CLI framework is complete without a flag parser. We've built a custom flag parser from years of experimentation that we feel is flexible enough to make an easy, predictable user experience but without compromising type safety for the developer.
Configurable Topic Separators​
By default, topics are separated with colons, such as my:awesome:command. However, you can use spaces if you prefer, such as my awesome command.
Super Speed​
The overhead for running an oclif CLI command is almost nothing. The command requires few dependencies; for example, only 17 dependencies are required for a minimal setup. Also, only the command to be executed requires Node.js. Which means that a large CLI with many commands loads as fast as a small CLI with just a single command.
CLI Generator​
You can get started from scratch quickly; all you need is a single command to scaffold out a fully functional CLI. See Generator Commands.
Testing Helpers​
We've worked hard to make commands easily testable and easy to mock out stdout and stderr. The CLI generator automatically creates scaffolded tests.
Auto-documentation​
By default, you pass --help to a CLI command to get help, such as the flag options and argument information. This information is also automatically added to the README whenever the CLI's npm package is published. See the plugin-plugins as an example.
Plugins​
Using plugins, you can extend a CLI with new functionality, split it into modular components, and share its functionality among multiple CLIs. See Building your own plugin.
Hooks​
Use lifecycle hooks to run functionality anytime a CLI starts, or on custom triggers. Use hooks whenever you want to share custom functionality between various components of the CLI. See Hooks.
JSON Output​
Your CLI can opt in to using the --json flag, which causes commands to automatically suppress console logs and display their final results as valid JSON output. The --json flag is useful if you want to use your CLI for scripting in CI/CD environments. See JSON.
Flexible Taxonomy​
You can opt in to what we call flexible taxonomy. When enabled, this feature allows users to execute commands without adhering to your defined command taxonomy.
This feature makes your CLI more user-friendly, especially if you have long command names which users find difficult to remember. For example, users can find it hard to remember if a command is called project deploy metadata start or project start deploy metadata - with flexible taxonomy, it doesn't matter because both are valid!
TypeScript (or not)​
Everything in the core of oclif is written in TypeScript, and the CLI generator can build both fully configured TypeScript or plain JavaScript CLIs. Because of TypeScript static properties, the syntax is a bit cleaner in TypeScript — but everything works, no matter which language you choose. If you use plugins support, the CLI automatically uses ts-node to run the plugins, which makes it easy and fast to use TypeScript with minimal-to-no boilerplate needed for any oclif CLI.
Auto-Updating Installers​
oclif can package your CLI into different installers that don't require the user to already have Node.js installed on their computer. You can make these installers auto-updatable by using plugin-update.
Autocomplete​
Include terminal autocompletion for your CLI with the plugin-autocomplete. After the autocomplete feature is configured, users can complete command names and flag names by pressing the tab key.
$ my-cli p<tab><tab> # lists all commands starting with 'p' for completionEdit this pageLast updated on Dec 20, 2024 by Mike Donnalley\n\nGetting StartedFeaturesOn this pageFeaturesHere are some key features that set oclif apart from other CLI frameworks.
Flag and Argument Parsing​
No CLI framework is complete without a flag parser. We've built a custom flag parser from years of experimentation that we feel is flexible enough to make an easy, predictable user experience but without compromising type safety for the developer.
Configurable Topic Separators​
By default, topics are separated with colons, such as my:awesome:command. However, you can use spaces if you prefer, such as my awesome command.
Super Speed​
The overhead for running an oclif CLI command is almost nothing. The command requires few dependencies; for example, only 17 dependencies are required for a minimal setup. Also, only the command to be executed requires Node.js. Which means that a large CLI with many commands loads as fast as a small CLI with just a single command.
CLI Generator​
You can get started from scratch quickly; all you need is a single command to scaffold out a fully functional CLI. See Generator Commands.
Testing Helpers​
We've worked hard to make commands easily testable and easy to mock out stdout and stderr. The CLI generator automatically creates scaffolded tests.
Auto-documentation​
By default, you pass --help to a CLI command to get help, such as the flag options and argument information. This information is also automatically added to the README whenever the CLI's npm package is published. See the plugin-plugins as an example.
Plugins​
Using plugins, you can extend a CLI with new functionality, split it into modular components, and share its functionality among multiple CLIs. See Building your own plugin.
Hooks​
Use lifecycle hooks to run functionality anytime a CLI starts, or on custom triggers. Use hooks whenever you want to share custom functionality between various components of the CLI. See Hooks.
JSON Output​
Your CLI can opt in to using the --json flag, which causes commands to automatically suppress console logs and display their final results as valid JSON output. The --json flag is useful if you want to use your CLI for scripting in CI/CD environments. See JSON.
Flexible Taxonomy​
You can opt in to what we call flexible taxonomy. When enabled, this feature allows users to execute commands without adhering to your defined command taxonomy.
This feature makes your CLI more user-friendly, especially if you have long command names which users find difficult to remember. For example, users can find it hard to remember if a command is called project deploy metadata start or project start deploy metadata - with flexible taxonomy, it doesn't matter because both are valid!
TypeScript (or not)​
Everything in the core of oclif is written in TypeScript, and the CLI generator can build both fully configured TypeScript or plain JavaScript CLIs. Because of TypeScript static properties, the syntax is a bit cleaner in TypeScript — but everything works, no matter which language you choose. If you use plugins support, the CLI automatically uses ts-node to run the plugins, which makes it easy and fast to use TypeScript with minimal-to-no boilerplate needed for any oclif CLI.
Auto-Updating Installers​
oclif can package your CLI into different installers that don't require the user to already have Node.js installed on their computer. You can make these installers auto-updatable by using plugin-update.
Autocomplete​
Include terminal autocompletion for your CLI with the plugin-autocomplete. After the autocomplete feature is configured, users can complete command names and flag names by pressing the tab key.
$ my-cli p<tab><tab> # lists all commands starting with 'p' for completionEdit this pageLast updated on Dec 20, 2024 by Mike DonnalleyPreviousIntroductionNextFAQsFlag and Argument ParsingConfigurable Topic SeparatorsSuper SpeedCLI GeneratorTesting HelpersAuto-documentationPluginsHooksJSON OutputFlexible TaxonomyTypeScript (or not)Auto-Updating InstallersAutocomplete\n\n\n\nGetting StartedFeaturesOn this pageFeaturesHere are some key features that set oclif apart from other CLI frameworks.
Flag and Argument Parsing​
No CLI framework is complete without a flag parser. We've built a custom flag parser from years of experimentation that we feel is flexible enough to make an easy, predictable user experience but without compromising type safety for the developer.
Configurable Topic Separators​
By default, topics are separated with colons, such as my:awesome:command. However, you can use spaces if you prefer, such as my awesome command.
Super Speed​
The overhead for running an oclif CLI command is almost nothing. The command requires few dependencies; for example, only 17 dependencies are required for a minimal setup. Also, only the command to be executed requires Node.js. Which means that a large CLI with many commands loads as fast as a small CLI with just a single command.
CLI Generator​
You can get started from scratch quickly; all you need is a single command to scaffold out a fully functional CLI. See Generator Commands.
Testing Helpers​
We've worked hard to make commands easily testable and easy to mock out stdout and stderr. The CLI generator automatically creates scaffolded tests.
Auto-documentation​
By default, you pass --help to a CLI command to get help, such as the flag options and argument information. This information is also automatically added to the README whenever the CLI's npm package is published. See the plugin-plugins as an example.
Plugins​
Using plugins, you can extend a CLI with new functionality, split it into modular components, and share its functionality among multiple CLIs. See Building your own plugin.
Hooks​
Use lifecycle hooks to run functionality anytime a CLI starts, or on custom triggers. Use hooks whenever you want to share custom functionality between various components of the CLI. See Hooks.
JSON Output​
Your CLI can opt in to using the --json flag, which causes commands to automatically suppress console logs and display their final results as valid JSON output. The --json flag is useful if you want to use your CLI for scripting in CI/CD environments. See JSON.
Flexible Taxonomy​
You can opt in to what we call flexible taxonomy. When enabled, this feature allows users to execute commands without adhering to your defined command taxonomy.
This feature makes your CLI more user-friendly, especially if you have long command names which users find difficult to remember. For example, users can find it hard to remember if a command is called project deploy metadata start or project start deploy metadata - with flexible taxonomy, it doesn't matter because both are valid!
TypeScript (or not)​
Everything in the core of oclif is written in TypeScript, and the CLI generator can build both fully configured TypeScript or plain JavaScript CLIs. Because of TypeScript static properties, the syntax is a bit cleaner in TypeScript — but everything works, no matter which language you choose. If you use plugins support, the CLI automatically uses ts-node to run the plugins, which makes it easy and fast to use TypeScript with minimal-to-no boilerplate needed for any oclif CLI.
Auto-Updating Installers​
oclif can package your CLI into different installers that don't require the user to already have Node.js installed on their computer. You can make these installers auto-updatable by using plugin-update.
Autocomplete​
Include terminal autocompletion for your CLI with the plugin-autocomplete. After the autocomplete feature is configured, users can complete command names and flag names by pressing the tab key.
$ my-cli p<tab><tab> # lists all commands starting with 'p' for completionEdit this pageLast updated on Dec 20, 2024 by Mike Donnalley\n\nGetting StartedFeaturesOn this pageFeaturesHere are some key features that set oclif apart from other CLI frameworks.
Flag and Argument Parsing​
No CLI framework is complete without a flag parser. We've built a custom flag parser from years of experimentation that we feel is flexible enough to make an easy, predictable user experience but without compromising type safety for the developer.
Configurable Topic Separators​
By default, topics are separated with colons, such as my:awesome:command. However, you can use spaces if you prefer, such as my awesome command.
Super Speed​
The overhead for running an oclif CLI command is almost nothing. The command requires few dependencies; for example, only 17 dependencies are required for a minimal setup. Also, only the command to be executed requires Node.js. Which means that a large CLI with many commands loads as fast as a small CLI with just a single command.
CLI Generator​
You can get started from scratch quickly; all you need is a single command to scaffold out a fully functional CLI. See Generator Commands.
Testing Helpers​
We've worked hard to make commands easily testable and easy to mock out stdout and stderr. The CLI generator automatically creates scaffolded tests.
Auto-documentation​
By default, you pass --help to a CLI command to get help, such as the flag options and argument information. This information is also automatically added to the README whenever the CLI's npm package is published. See the plugin-plugins as an example.
Plugins​
Using plugins, you can extend a CLI with new functionality, split it into modular components, and share its functionality among multiple CLIs. See Building your own plugin.
Hooks​
Use lifecycle hooks to run functionality anytime a CLI starts, or on custom triggers. Use hooks whenever you want to share custom functionality between various components of the CLI. See Hooks.
JSON Output​
Your CLI can opt in to using the --json flag, which causes commands to automatically suppress console logs and display their final results as valid JSON output. The --json flag is useful if you want to use your CLI for scripting in CI/CD environments. See JSON.
Flexible Taxonomy​
You can opt in to what we call flexible taxonomy. When enabled, this feature allows users to execute commands without adhering to your defined command taxonomy.
This feature makes your CLI more user-friendly, especially if you have long command names which users find difficult to remember. For example, users can find it hard to remember if a command is called project deploy metadata start or project start deploy metadata - with flexible taxonomy, it doesn't matter because both are valid!
TypeScript (or not)​
Everything in the core of oclif is written in TypeScript, and the CLI generator can build both fully configured TypeScript or plain JavaScript CLIs. Because of TypeScript static properties, the syntax is a bit cleaner in TypeScript — but everything works, no matter which language you choose. If you use plugins support, the CLI automatically uses ts-node to run the plugins, which makes it easy and fast to use TypeScript with minimal-to-no boilerplate needed for any oclif CLI.
Auto-Updating Installers​
oclif can package your CLI into different installers that don't require the user to already have Node.js installed on their computer. You can make these installers auto-updatable by using plugin-update.
Autocomplete​
Include terminal autocompletion for your CLI with the plugin-autocomplete. After the autocomplete feature is configured, users can complete command names and flag names by pressing the tab key.
$ my-cli p<tab><tab> # lists all commands starting with 'p' for completionEdit this pageLast updated on Dec 20, 2024 by Mike DonnalleyPreviousIntroductionNextFAQsFlag and Argument ParsingConfigurable Topic SeparatorsSuper SpeedCLI GeneratorTesting HelpersAuto-documentationPluginsHooksJSON OutputFlexible TaxonomyTypeScript (or not)Auto-Updating InstallersAutocomplete\n\n\n\nGetting StartedFeaturesOn this pageFeaturesHere are some key features that set oclif apart from other CLI frameworks.
Flag and Argument Parsing​
No CLI framework is complete without a flag parser. We've built a custom flag parser from years of experimentation that we feel is flexible enough to make an easy, predictable user experience but without compromising type safety for the developer.
Configurable Topic Separators​
By default, topics are separated with colons, such as my:awesome:command. However, you can use spaces if you prefer, such as my awesome command.
Super Speed​
The overhead for running an oclif CLI command is almost nothing. The command requires few dependencies; for example, only 17 dependencies are required for a minimal setup. Also, only the command to be executed requires Node.js. Which means that a large CLI with many commands loads as fast as a small CLI with just a single command.
CLI Generator​
You can get started from scratch quickly; all you need is a single command to scaffold out a fully functional CLI. See Generator Commands.
Testing Helpers​
We've worked hard to make commands easily testable and easy to mock out stdout and stderr. The CLI generator automatically creates scaffolded tests.
Auto-documentation​
By default, you pass --help to a CLI command to get help, such as the flag options and argument information. This information is also automatically added to the README whenever the CLI's npm package is published. See the plugin-plugins as an example.
Plugins​
Using plugins, you can extend a CLI with new functionality, split it into modular components, and share its functionality among multiple CLIs. See Building your own plugin.
Hooks​
Use lifecycle hooks to run functionality anytime a CLI starts, or on custom triggers. Use hooks whenever you want to share custom functionality between various components of the CLI. See Hooks.
JSON Output​
Your CLI can opt in to using the --json flag, which causes commands to automatically suppress console logs and display their final results as valid JSON output. The --json flag is useful if you want to use your CLI for scripting in CI/CD environments. See JSON.
Flexible Taxonomy​
You can opt in to what we call flexible taxonomy. When enabled, this feature allows users to execute commands without adhering to your defined command taxonomy.
This feature makes your CLI more user-friendly, especially if you have long command names which users find difficult to remember. For example, users can find it hard to remember if a command is called project deploy metadata start or project start deploy metadata - with flexible taxonomy, it doesn't matter because both are valid!
TypeScript (or not)​
Everything in the core of oclif is written in TypeScript, and the CLI generator can build both fully configured TypeScript or plain JavaScript CLIs. Because of TypeScript static properties, the syntax is a bit cleaner in TypeScript — but everything works, no matter which language you choose. If you use plugins support, the CLI automatically uses ts-node to run the plugins, which makes it easy and fast to use TypeScript with minimal-to-no boilerplate needed for any oclif CLI.
Auto-Updating Installers​
oclif can package your CLI into different installers that don't require the user to already have Node.js installed on their computer. You can make these installers auto-updatable by using plugin-update.
Autocomplete​
Include terminal autocompletion for your CLI with the plugin-autocomplete. After the autocomplete feature is configured, users can complete command names and flag names by pressing the tab key.
$ my-cli p<tab><tab> # lists all commands starting with 'p' for completionEdit this pageLast updated on Dec 20, 2024 by Mike Donnalley\n\nGetting StartedFeaturesOn this pageFeaturesHere are some key features that set oclif apart from other CLI frameworks.
Flag and Argument Parsing​
No CLI framework is complete without a flag parser. We've built a custom flag parser from years of experimentation that we feel is flexible enough to make an easy, predictable user experience but without compromising type safety for the developer.
Configurable Topic Separators​
By default, topics are separated with colons, such as my:awesome:command. However, you can use spaces if you prefer, such as my awesome command.
Super Speed​
The overhead for running an oclif CLI command is almost nothing. The command requires few dependencies; for example, only 17 dependencies are required for a minimal setup. Also, only the command to be executed requires Node.js. Which means that a large CLI with many commands loads as fast as a small CLI with just a single command.
CLI Generator​
You can get started from scratch quickly; all you need is a single command to scaffold out a fully functional CLI. See Generator Commands.
Testing Helpers​
We've worked hard to make commands easily testable and easy to mock out stdout and stderr. The CLI generator automatically creates scaffolded tests.
Auto-documentation​
By default, you pass --help to a CLI command to get help, such as the flag options and argument information. This information is also automatically added to the README whenever the CLI's npm package is published. See the plugin-plugins as an example.
Plugins​
Using plugins, you can extend a CLI with new functionality, split it into modular components, and share its functionality among multiple CLIs. See Building your own plugin.
Hooks​
Use lifecycle hooks to run functionality anytime a CLI starts, or on custom triggers. Use hooks whenever you want to share custom functionality between various components of the CLI. See Hooks.
JSON Output​
Your CLI can opt in to using the --json flag, which causes commands to automatically suppress console logs and display their final results as valid JSON output. The --json flag is useful if you want to use your CLI for scripting in CI/CD environments. See JSON.
Flexible Taxonomy​
You can opt in to what we call flexible taxonomy. When enabled, this feature allows users to execute commands without adhering to your defined command taxonomy.
This feature makes your CLI more user-friendly, especially if you have long command names which users find difficult to remember. For example, users can find it hard to remember if a command is called project deploy metadata start or project start deploy metadata - with flexible taxonomy, it doesn't matter because both are valid!
TypeScript (or not)​
Everything in the core of oclif is written in TypeScript, and the CLI generator can build both fully configured TypeScript or plain JavaScript CLIs. Because of TypeScript static properties, the syntax is a bit cleaner in TypeScript — but everything works, no matter which language you choose. If you use plugins support, the CLI automatically uses ts-node to run the plugins, which makes it easy and fast to use TypeScript with minimal-to-no boilerplate needed for any oclif CLI.
Auto-Updating Installers​
oclif can package your CLI into different installers that don't require the user to already have Node.js installed on their computer. You can make these installers auto-updatable by using plugin-update.
Autocomplete​
Include terminal autocompletion for your CLI with the plugin-autocomplete. After the autocomplete feature is configured, users can complete command names and flag names by pressing the tab key.
$ my-cli p<tab><tab> # lists all commands starting with 'p' for completionEdit this pageLast updated on Dec 20, 2024 by Mike DonnalleyPreviousIntroductionNextFAQsFlag and Argument ParsingConfigurable Topic SeparatorsSuper SpeedCLI GeneratorTesting HelpersAuto-documentationPluginsHooksJSON OutputFlexible TaxonomyTypeScript (or not)Auto-Updating InstallersAutocomplete\n\n\n\nGetting StartedFeaturesOn this pageFeaturesHere are some key features that set oclif apart from other CLI frameworks.
Flag and Argument Parsing​
No CLI framework is complete without a flag parser. We've built a custom flag parser from years of experimentation that we feel is flexible enough to make an easy, predictable user experience but without compromising type safety for the developer.
Configurable Topic Separators​
By default, topics are separated with colons, such as my:awesome:command. However, you can use spaces if you prefer, such as my awesome command.
Super Speed​
The overhead for running an oclif CLI command is almost nothing. The command requires few dependencies; for example, only 17 dependencies are required for a minimal setup. Also, only the command to be executed requires Node.js. Which means that a large CLI with many commands loads as fast as a small CLI with just a single command.
CLI Generator​
You can get started from scratch quickly; all you need is a single command to scaffold out a fully functional CLI. See Generator Commands.
Testing Helpers​
We've worked hard to make commands easily testable and easy to mock out stdout and stderr. The CLI generator automatically creates scaffolded tests.
Auto-documentation​
By default, you pass --help to a CLI command to get help, such as the flag options and argument information. This information is also automatically added to the README whenever the CLI's npm package is published. See the plugin-plugins as an example.
Plugins​
Using plugins, you can extend a CLI with new functionality, split it into modular components, and share its functionality among multiple CLIs. See Building your own plugin.
Hooks​
Use lifecycle hooks to run functionality anytime a CLI starts, or on custom triggers. Use hooks whenever you want to share custom functionality between various components of the CLI. See Hooks.
JSON Output​
Your CLI can opt in to using the --json flag, which causes commands to automatically suppress console logs and display their final results as valid JSON output. The --json flag is useful if you want to use your CLI for scripting in CI/CD environments. See JSON.
Flexible Taxonomy​
You can opt in to what we call flexible taxonomy. When enabled, this feature allows users to execute commands without adhering to your defined command taxonomy.
This feature makes your CLI more user-friendly, especially if you have long command names which users find difficult to remember. For example, users can find it hard to remember if a command is called project deploy metadata start or project start deploy metadata - with flexible taxonomy, it doesn't matter because both are valid!
TypeScript (or not)​
Everything in the core of oclif is written in TypeScript, and the CLI generator can build both fully configured TypeScript or plain JavaScript CLIs. Because of TypeScript static properties, the syntax is a bit cleaner in TypeScript — but everything works, no matter which language you choose. If you use plugins support, the CLI automatically uses ts-node to run the plugins, which makes it easy and fast to use TypeScript with minimal-to-no boilerplate needed for any oclif CLI.
Auto-Updating Installers​
oclif can package your CLI into different installers that don't require the user to already have Node.js installed on their computer. You can make these installers auto-updatable by using plugin-update.
Autocomplete​
Include terminal autocompletion for your CLI with the plugin-autocomplete. After the autocomplete feature is configured, users can complete command names and flag names by pressing the tab key.
$ my-cli p<tab><tab> # lists all commands starting with 'p' for completionEdit this pageLast updated on Dec 20, 2024 by Mike Donnalley\n\nGetting StartedFeaturesOn this pageFeaturesHere are some key features that set oclif apart from other CLI frameworks.
Flag and Argument Parsing​
No CLI framework is complete without a flag parser. We've built a custom flag parser from years of experimentation that we feel is flexible enough to make an easy, predictable user experience but without compromising type safety for the developer.
Configurable Topic Separators​
By default, topics are separated with colons, such as my:awesome:command. However, you can use spaces if you prefer, such as my awesome command.
Super Speed​
The overhead for running an oclif CLI command is almost nothing. The command requires few dependencies; for example, only 17 dependencies are required for a minimal setup. Also, only the command to be executed requires Node.js. Which means that a large CLI with many commands loads as fast as a small CLI with just a single command.
CLI Generator​
You can get started from scratch quickly; all you need is a single command to scaffold out a fully functional CLI. See Generator Commands.
Testing Helpers​
We've worked hard to make commands easily testable and easy to mock out stdout and stderr. The CLI generator automatically creates scaffolded tests.
Auto-documentation​
By default, you pass --help to a CLI command to get help, such as the flag options and argument information. This information is also automatically added to the README whenever the CLI's npm package is published. See the plugin-plugins as an example.
Plugins​
Using plugins, you can extend a CLI with new functionality, split it into modular components, and share its functionality among multiple CLIs. See Building your own plugin.
Hooks​
Use lifecycle hooks to run functionality anytime a CLI starts, or on custom triggers. Use hooks whenever you want to share custom functionality between various components of the CLI. See Hooks.
JSON Output​
Your CLI can opt in to using the --json flag, which causes commands to automatically suppress console logs and display their final results as valid JSON output. The --json flag is useful if you want to use your CLI for scripting in CI/CD environments. See JSON.
Flexible Taxonomy​
You can opt in to what we call flexible taxonomy. When enabled, this feature allows users to execute commands without adhering to your defined command taxonomy.
This feature makes your CLI more user-friendly, especially if you have long command names which users find difficult to remember. For example, users can find it hard to remember if a command is called project deploy metadata start or project start deploy metadata - with flexible taxonomy, it doesn't matter because both are valid!
TypeScript (or not)​
Everything in the core of oclif is written in TypeScript, and the CLI generator can build both fully configured TypeScript or plain JavaScript CLIs. Because of TypeScript static properties, the syntax is a bit cleaner in TypeScript — but everything works, no matter which language you choose. If you use plugins support, the CLI automatically uses ts-node to run the plugins, which makes it easy and fast to use TypeScript with minimal-to-no boilerplate needed for any oclif CLI.
Auto-Updating Installers​
oclif can package your CLI into different installers that don't require the user to already have Node.js installed on their computer. You can make these installers auto-updatable by using plugin-update.
Autocomplete​
Include terminal autocompletion for your CLI with the plugin-autocomplete. After the autocomplete feature is configured, users can complete command names and flag names by pressing the tab key.
$ my-cli p<tab><tab> # lists all commands starting with 'p' for completionEdit this pageLast updated on Dec 20, 2024 by Mike DonnalleyPreviousIntroductionNextFAQsFlag and Argument ParsingConfigurable Topic SeparatorsSuper SpeedCLI GeneratorTesting HelpersAuto-documentationPluginsHooksJSON OutputFlexible TaxonomyTypeScript (or not)Auto-Updating InstallersAutocomplete\n\n\n\nGetting StartedFeaturesOn this pageFeaturesHere are some key features that set oclif apart from other CLI frameworks.
Flag and Argument Parsing​
No CLI framework is complete without a flag parser. We've built a custom flag parser from years of experimentation that we feel is flexible enough to make an easy, predictable user experience but without compromising type safety for the developer.
Configurable Topic Separators​
By default, topics are separated with colons, such as my:awesome:command. However, you can use spaces if you prefer, such as my awesome command.
Super Speed​
The overhead for running an oclif CLI command is almost nothing. The command requires few dependencies; for example, only 17 dependencies are required for a minimal setup. Also, only the command to be executed requires Node.js. Which means that a large CLI with many commands loads as fast as a small CLI with just a single command.
CLI Generator​
You can get started from scratch quickly; all you need is a single command to scaffold out a fully functional CLI. See Generator Commands.
Testing Helpers​
We've worked hard to make commands easily testable and easy to mock out stdout and stderr. The CLI generator automatically creates scaffolded tests.
Auto-documentation​
By default, you pass --help to a CLI command to get help, such as the flag options and argument information. This information is also automatically added to the README whenever the CLI's npm package is published. See the plugin-plugins as an example.
Plugins​
Using plugins, you can extend a CLI with new functionality, split it into modular components, and share its functionality among multiple CLIs. See Building your own plugin.
Hooks​
Use lifecycle hooks to run functionality anytime a CLI starts, or on custom triggers. Use hooks whenever you want to share custom functionality between various components of the CLI. See Hooks.
JSON Output​
Your CLI can opt in to using the --json flag, which causes commands to automatically suppress console logs and display their final results as valid JSON output. The --json flag is useful if you want to use your CLI for scripting in CI/CD environments. See JSON.
Flexible Taxonomy​
You can opt in to what we call flexible taxonomy. When enabled, this feature allows users to execute commands without adhering to your defined command taxonomy.
This feature makes your CLI more user-friendly, especially if you have long command names which users find difficult to remember. For example, users can find it hard to remember if a command is called project deploy metadata start or project start deploy metadata - with flexible taxonomy, it doesn't matter because both are valid!
TypeScript (or not)​
Everything in the core of oclif is written in TypeScript, and the CLI generator can build both fully configured TypeScript or plain JavaScript CLIs. Because of TypeScript static properties, the syntax is a bit cleaner in TypeScript — but everything works, no matter which language you choose. If you use plugins support, the CLI automatically uses ts-node to run the plugins, which makes it easy and fast to use TypeScript with minimal-to-no boilerplate needed for any oclif CLI.
Auto-Updating Installers​
oclif can package your CLI into different installers that don't require the user to already have Node.js installed on their computer. You can make these installers auto-updatable by using plugin-update.
Autocomplete​
Include terminal autocompletion for your CLI with the plugin-autocomplete. After the autocomplete feature is configured, users can complete command names and flag names by pressing the tab key.
$ my-cli p<tab><tab> # lists all commands starting with 'p' for completionEdit this pageLast updated on Dec 20, 2024 by Mike Donnalley\n\nGetting StartedFeaturesOn this pageFeaturesHere are some key features that set oclif apart from other CLI frameworks.
Flag and Argument Parsing​
No CLI framework is complete without a flag parser. We've built a custom flag parser from years of experimentation that we feel is flexible enough to make an easy, predictable user experience but without compromising type safety for the developer.
Configurable Topic Separators​
By default, topics are separated with colons, such as my:awesome:command. However, you can use spaces if you prefer, such as my awesome command.
Super Speed​
The overhead for running an oclif CLI command is almost nothing. The command requires few dependencies; for example, only 17 dependencies are required for a minimal setup. Also, only the command to be executed requires Node.js. Which means that a large CLI with many commands loads as fast as a small CLI with just a single command.
CLI Generator​
You can get started from scratch quickly; all you need is a single command to scaffold out a fully functional CLI. See Generator Commands.
Testing Helpers​
We've worked hard to make commands easily testable and easy to mock out stdout and stderr. The CLI generator automatically creates scaffolded tests.
Auto-documentation​
By default, you pass --help to a CLI command to get help, such as the flag options and argument information. This information is also automatically added to the README whenever the CLI's npm package is published. See the plugin-plugins as an example.
Plugins​
Using plugins, you can extend a CLI with new functionality, split it into modular components, and share its functionality among multiple CLIs. See Building your own plugin.
Hooks​
Use lifecycle hooks to run functionality anytime a CLI starts, or on custom triggers. Use hooks whenever you want to share custom functionality between various components of the CLI. See Hooks.
JSON Output​
Your CLI can opt in to using the --json flag, which causes commands to automatically suppress console logs and display their final results as valid JSON output. The --json flag is useful if you want to use your CLI for scripting in CI/CD environments. See JSON.
Flexible Taxonomy​
You can opt in to what we call flexible taxonomy. When enabled, this feature allows users to execute commands without adhering to your defined command taxonomy.
This feature makes your CLI more user-friendly, especially if you have long command names which users find difficult to remember. For example, users can find it hard to remember if a command is called project deploy metadata start or project start deploy metadata - with flexible taxonomy, it doesn't matter because both are valid!
TypeScript (or not)​
Everything in the core of oclif is written in TypeScript, and the CLI generator can build both fully configured TypeScript or plain JavaScript CLIs. Because of TypeScript static properties, the syntax is a bit cleaner in TypeScript — but everything works, no matter which language you choose. If you use plugins support, the CLI automatically uses ts-node to run the plugins, which makes it easy and fast to use TypeScript with minimal-to-no boilerplate needed for any oclif CLI.
Auto-Updating Installers​
oclif can package your CLI into different installers that don't require the user to already have Node.js installed on their computer. You can make these installers auto-updatable by using plugin-update.
Autocomplete​
Include terminal autocompletion for your CLI with the plugin-autocomplete. After the autocomplete feature is configured, users can complete command names and flag names by pressing the tab key.
$ my-cli p<tab><tab> # lists all commands starting with 'p' for completionEdit this pageLast updated on Dec 20, 2024 by Mike DonnalleyPreviousIntroductionNextFAQsFlag and Argument ParsingConfigurable Topic SeparatorsSuper SpeedCLI GeneratorTesting HelpersAuto-documentationPluginsHooksJSON OutputFlexible TaxonomyTypeScript (or not)Auto-Updating InstallersAutocomplete\n\n\n\nGetting StartedFeaturesOn this pageFeaturesHere are some key features that set oclif apart from other CLI frameworks.
Flag and Argument Parsing​
No CLI framework is complete without a flag parser. We've built a custom flag parser from years of experimentation that we feel is flexible enough to make an easy, predictable user experience but without compromising type safety for the developer.
Configurable Topic Separators​
By default, topics are separated with colons, such as my:awesome:command. However, you can use spaces if you prefer, such as my awesome command.
Super Speed​
The overhead for running an oclif CLI command is almost nothing. The command requires few dependencies; for example, only 17 dependencies are required for a minimal setup. Also, only the command to be executed requires Node.js. Which means that a large CLI with many commands loads as fast as a small CLI with just a single command.
CLI Generator​
You can get started from scratch quickly; all you need is a single command to scaffold out a fully functional CLI. See Generator Commands.
Testing Helpers​
We've worked hard to make commands easily testable and easy to mock out stdout and stderr. The CLI generator automatically creates scaffolded tests.
Auto-documentation​
By default, you pass --help to a CLI command to get help, such as the flag options and argument information. This information is also automatically added to the README whenever the CLI's npm package is published. See the plugin-plugins as an example.
Plugins​
Using plugins, you can extend a CLI with new functionality, split it into modular components, and share its functionality among multiple CLIs. See Building your own plugin.
Hooks​
Use lifecycle hooks to run functionality anytime a CLI starts, or on custom triggers. Use hooks whenever you want to share custom functionality between various components of the CLI. See Hooks.
JSON Output​
Your CLI can opt in to using the --json flag, which causes commands to automatically suppress console logs and display their final results as valid JSON output. The --json flag is useful if you want to use your CLI for scripting in CI/CD environments. See JSON.
Flexible Taxonomy​
You can opt in to what we call flexible taxonomy. When enabled, this feature allows users to execute commands without adhering to your defined command taxonomy.
This feature makes your CLI more user-friendly, especially if you have long command names which users find difficult to remember. For example, users can find it hard to remember if a command is called project deploy metadata start or project start deploy metadata - with flexible taxonomy, it doesn't matter because both are valid!
TypeScript (or not)​
Everything in the core of oclif is written in TypeScript, and the CLI generator can build both fully configured TypeScript or plain JavaScript CLIs. Because of TypeScript static properties, the syntax is a bit cleaner in TypeScript — but everything works, no matter which language you choose. If you use plugins support, the CLI automatically uses ts-node to run the plugins, which makes it easy and fast to use TypeScript with minimal-to-no boilerplate needed for any oclif CLI.
Auto-Updating Installers​
oclif can package your CLI into different installers that don't require the user to already have Node.js installed on their computer. You can make these installers auto-updatable by using plugin-update.
Autocomplete​
Include terminal autocompletion for your CLI with the plugin-autocomplete. After the autocomplete feature is configured, users can complete command names and flag names by pressing the tab key.
$ my-cli p<tab><tab> # lists all commands starting with 'p' for completionEdit this pageLast updated on Dec 20, 2024 by Mike Donnalley\n\nGetting StartedFeaturesOn this pageFeaturesHere are some key features that set oclif apart from other CLI frameworks.
Flag and Argument Parsing​
No CLI framework is complete without a flag parser. We've built a custom flag parser from years of experimentation that we feel is flexible enough to make an easy, predictable user experience but without compromising type safety for the developer.
Configurable Topic Separators​
By default, topics are separated with colons, such as my:awesome:command. However, you can use spaces if you prefer, such as my awesome command.
Super Speed​
The overhead for running an oclif CLI command is almost nothing. The command requires few dependencies; for example, only 17 dependencies are required for a minimal setup. Also, only the command to be executed requires Node.js. Which means that a large CLI with many commands loads as fast as a small CLI with just a single command.
CLI Generator​
You can get started from scratch quickly; all you need is a single command to scaffold out a fully functional CLI. See Generator Commands.
Testing Helpers​
We've worked hard to make commands easily testable and easy to mock out stdout and stderr. The CLI generator automatically creates scaffolded tests.
Auto-documentation​
By default, you pass --help to a CLI command to get help, such as the flag options and argument information. This information is also automatically added to the README whenever the CLI's npm package is published. See the plugin-plugins as an example.
Plugins​
Using plugins, you can extend a CLI with new functionality, split it into modular components, and share its functionality among multiple CLIs. See Building your own plugin.
Hooks​
Use lifecycle hooks to run functionality anytime a CLI starts, or on custom triggers. Use hooks whenever you want to share custom functionality between various components of the CLI. See Hooks.
JSON Output​
Your CLI can opt in to using the --json flag, which causes commands to automatically suppress console logs and display their final results as valid JSON output. The --json flag is useful if you want to use your CLI for scripting in CI/CD environments. See JSON.
Flexible Taxonomy​
You can opt in to what we call flexible taxonomy. When enabled, this feature allows users to execute commands without adhering to your defined command taxonomy.
This feature makes your CLI more user-friendly, especially if you have long command names which users find difficult to remember. For example, users can find it hard to remember if a command is called project deploy metadata start or project start deploy metadata - with flexible taxonomy, it doesn't matter because both are valid!
TypeScript (or not)​
Everything in the core of oclif is written in TypeScript, and the CLI generator can build both fully configured TypeScript or plain JavaScript CLIs. Because of TypeScript static properties, the syntax is a bit cleaner in TypeScript — but everything works, no matter which language you choose. If you use plugins support, the CLI automatically uses ts-node to run the plugins, which makes it easy and fast to use TypeScript with minimal-to-no boilerplate needed for any oclif CLI.
Auto-Updating Installers​
oclif can package your CLI into different installers that don't require the user to already have Node.js installed on their computer. You can make these installers auto-updatable by using plugin-update.
Autocomplete​
Include terminal autocompletion for your CLI with the plugin-autocomplete. After the autocomplete feature is configured, users can complete command names and flag names by pressing the tab key.
$ my-cli p<tab><tab> # lists all commands starting with 'p' for completionEdit this pageLast updated on Dec 20, 2024 by Mike DonnalleyPreviousIntroductionNextFAQsFlag and Argument ParsingConfigurable Topic SeparatorsSuper SpeedCLI GeneratorTesting HelpersAuto-documentationPluginsHooksJSON OutputFlexible TaxonomyTypeScript (or not)Auto-Updating InstallersAutocomplete\n\n\n\nAPI ReferencePluginsOn this pagePluginsPlugins are a great way to offer experimental functionality, allow users to extend your CLI, break up a CLI into modular components, or share functionality between CLIs.
Plugins can have commands or hooks just like a CLI. To add a plugin such as the not-found plugin plugin, first add it to your CLI with yarn add @oclif/plugin-not-found, then add the following to your package.json:
{  "name": "mycli",  "version": "0.0.0",  // ...  "dependencies": {    "@oclif/core": "^3",    "@oclif/plugin-help": "^6",    "@oclif/plugin-not-found": "^3",  }  "oclif": {    "plugins": [      "@oclif/plugin-help",      "@oclif/plugin-not-found"    ]  }}
Plugins can also be specified using minimatch patterns:
{  "name": "mycli",  "version": "0.0.0",  // ...  "dependencies": {    "@oclif/core": "^3",    "@oclif/plugin-help": "^6",    "@oclif/plugin-not-found": "^3",  }  "oclif": {    "plugins": [      "@oclif/plugin-*",    ]  }}
If you want users to be able to install their own plugins into your CLI, use the plugins plugin.
Useful Plugins​

@oclif/plugin-not-found - Display a friendly "did you mean" message if a command is not found.
@oclif/plugin-plugins - Allow users to add plugins to extend your CLI.
@oclif/plugin-update - Add autoupdate support to the CLI.
@oclif/plugin-help - Help plugin for oclif.
@oclif/plugin-warn-if-update-available - Show a warning message if user is running an out of date CLI.
@oclif/plugin-which - Show which plugin a command comes from.
@oclif/plugin-commands - Add a commands command to list all the commands.
@oclif/plugin-autocomplete - Add bash/zsh autocomplete.
@oclif/plugin-search - Add search command to your CLI.
@oclif/plugin-version - Add version command to your CLI.

Building your own plugin​
Writing code for plugins is essentially the same as writing within a CLI. They can export 3 different types: commands, hooks, and other plugins.
Run npx oclif generate mynewplugin to create a plugin in a new directory. This will come with a sample commands called hello and hello world.Edit this pageLast updated on Dec 20, 2024 by Mike Donnalley\n\nAPI ReferencePluginsOn this pagePluginsPlugins are a great way to offer experimental functionality, allow users to extend your CLI, break up a CLI into modular components, or share functionality between CLIs.
Plugins can have commands or hooks just like a CLI. To add a plugin such as the not-found plugin plugin, first add it to your CLI with yarn add @oclif/plugin-not-found, then add the following to your package.json:
{  "name": "mycli",  "version": "0.0.0",  // ...  "dependencies": {    "@oclif/core": "^3",    "@oclif/plugin-help": "^6",    "@oclif/plugin-not-found": "^3",  }  "oclif": {    "plugins": [      "@oclif/plugin-help",      "@oclif/plugin-not-found"    ]  }}
Plugins can also be specified using minimatch patterns:
{  "name": "mycli",  "version": "0.0.0",  // ...  "dependencies": {    "@oclif/core": "^3",    "@oclif/plugin-help": "^6",    "@oclif/plugin-not-found": "^3",  }  "oclif": {    "plugins": [      "@oclif/plugin-*",    ]  }}
If you want users to be able to install their own plugins into your CLI, use the plugins plugin.
Useful Plugins​

@oclif/plugin-not-found - Display a friendly "did you mean" message if a command is not found.
@oclif/plugin-plugins - Allow users to add plugins to extend your CLI.
@oclif/plugin-update - Add autoupdate support to the CLI.
@oclif/plugin-help - Help plugin for oclif.
@oclif/plugin-warn-if-update-available - Show a warning message if user is running an out of date CLI.
@oclif/plugin-which - Show which plugin a command comes from.
@oclif/plugin-commands - Add a commands command to list all the commands.
@oclif/plugin-autocomplete - Add bash/zsh autocomplete.
@oclif/plugin-search - Add search command to your CLI.
@oclif/plugin-version - Add version command to your CLI.

Building your own plugin​
Writing code for plugins is essentially the same as writing within a CLI. They can export 3 different types: commands, hooks, and other plugins.
Run npx oclif generate mynewplugin to create a plugin in a new directory. This will come with a sample commands called hello and hello world.Edit this pageLast updated on Dec 20, 2024 by Mike DonnalleyPreviousHooksNextHelp ClassesUseful PluginsBuilding your own plugin\n\n\n\nGetting StartedFeaturesOn this pageFeaturesHere are some key features that set oclif apart from other CLI frameworks.
Flag and Argument Parsing​
No CLI framework is complete without a flag parser. We've built a custom flag parser from years of experimentation that we feel is flexible enough to make an easy, predictable user experience but without compromising type safety for the developer.
Configurable Topic Separators​
By default, topics are separated with colons, such as my:awesome:command. However, you can use spaces if you prefer, such as my awesome command.
Super Speed​
The overhead for running an oclif CLI command is almost nothing. The command requires few dependencies; for example, only 17 dependencies are required for a minimal setup. Also, only the command to be executed requires Node.js. Which means that a large CLI with many commands loads as fast as a small CLI with just a single command.
CLI Generator​
You can get started from scratch quickly; all you need is a single command to scaffold out a fully functional CLI. See Generator Commands.
Testing Helpers​
We've worked hard to make commands easily testable and easy to mock out stdout and stderr. The CLI generator automatically creates scaffolded tests.
Auto-documentation​
By default, you pass --help to a CLI command to get help, such as the flag options and argument information. This information is also automatically added to the README whenever the CLI's npm package is published. See the plugin-plugins as an example.
Plugins​
Using plugins, you can extend a CLI with new functionality, split it into modular components, and share its functionality among multiple CLIs. See Building your own plugin.
Hooks​
Use lifecycle hooks to run functionality anytime a CLI starts, or on custom triggers. Use hooks whenever you want to share custom functionality between various components of the CLI. See Hooks.
JSON Output​
Your CLI can opt in to using the --json flag, which causes commands to automatically suppress console logs and display their final results as valid JSON output. The --json flag is useful if you want to use your CLI for scripting in CI/CD environments. See JSON.
Flexible Taxonomy​
You can opt in to what we call flexible taxonomy. When enabled, this feature allows users to execute commands without adhering to your defined command taxonomy.
This feature makes your CLI more user-friendly, especially if you have long command names which users find difficult to remember. For example, users can find it hard to remember if a command is called project deploy metadata start or project start deploy metadata - with flexible taxonomy, it doesn't matter because both are valid!
TypeScript (or not)​
Everything in the core of oclif is written in TypeScript, and the CLI generator can build both fully configured TypeScript or plain JavaScript CLIs. Because of TypeScript static properties, the syntax is a bit cleaner in TypeScript — but everything works, no matter which language you choose. If you use plugins support, the CLI automatically uses ts-node to run the plugins, which makes it easy and fast to use TypeScript with minimal-to-no boilerplate needed for any oclif CLI.
Auto-Updating Installers​
oclif can package your CLI into different installers that don't require the user to already have Node.js installed on their computer. You can make these installers auto-updatable by using plugin-update.
Autocomplete​
Include terminal autocompletion for your CLI with the plugin-autocomplete. After the autocomplete feature is configured, users can complete command names and flag names by pressing the tab key.
$ my-cli p<tab><tab> # lists all commands starting with 'p' for completionEdit this pageLast updated on Dec 20, 2024 by Mike Donnalley\n\nGetting StartedFeaturesOn this pageFeaturesHere are some key features that set oclif apart from other CLI frameworks.
Flag and Argument Parsing​
No CLI framework is complete without a flag parser. We've built a custom flag parser from years of experimentation that we feel is flexible enough to make an easy, predictable user experience but without compromising type safety for the developer.
Configurable Topic Separators​
By default, topics are separated with colons, such as my:awesome:command. However, you can use spaces if you prefer, such as my awesome command.
Super Speed​
The overhead for running an oclif CLI command is almost nothing. The command requires few dependencies; for example, only 17 dependencies are required for a minimal setup. Also, only the command to be executed requires Node.js. Which means that a large CLI with many commands loads as fast as a small CLI with just a single command.
CLI Generator​
You can get started from scratch quickly; all you need is a single command to scaffold out a fully functional CLI. See Generator Commands.
Testing Helpers​
We've worked hard to make commands easily testable and easy to mock out stdout and stderr. The CLI generator automatically creates scaffolded tests.
Auto-documentation​
By default, you pass --help to a CLI command to get help, such as the flag options and argument information. This information is also automatically added to the README whenever the CLI's npm package is published. See the plugin-plugins as an example.
Plugins​
Using plugins, you can extend a CLI with new functionality, split it into modular components, and share its functionality among multiple CLIs. See Building your own plugin.
Hooks​
Use lifecycle hooks to run functionality anytime a CLI starts, or on custom triggers. Use hooks whenever you want to share custom functionality between various components of the CLI. See Hooks.
JSON Output​
Your CLI can opt in to using the --json flag, which causes commands to automatically suppress console logs and display their final results as valid JSON output. The --json flag is useful if you want to use your CLI for scripting in CI/CD environments. See JSON.
Flexible Taxonomy​
You can opt in to what we call flexible taxonomy. When enabled, this feature allows users to execute commands without adhering to your defined command taxonomy.
This feature makes your CLI more user-friendly, especially if you have long command names which users find difficult to remember. For example, users can find it hard to remember if a command is called project deploy metadata start or project start deploy metadata - with flexible taxonomy, it doesn't matter because both are valid!
TypeScript (or not)​
Everything in the core of oclif is written in TypeScript, and the CLI generator can build both fully configured TypeScript or plain JavaScript CLIs. Because of TypeScript static properties, the syntax is a bit cleaner in TypeScript — but everything works, no matter which language you choose. If you use plugins support, the CLI automatically uses ts-node to run the plugins, which makes it easy and fast to use TypeScript with minimal-to-no boilerplate needed for any oclif CLI.
Auto-Updating Installers​
oclif can package your CLI into different installers that don't require the user to already have Node.js installed on their computer. You can make these installers auto-updatable by using plugin-update.
Autocomplete​
Include terminal autocompletion for your CLI with the plugin-autocomplete. After the autocomplete feature is configured, users can complete command names and flag names by pressing the tab key.
$ my-cli p<tab><tab> # lists all commands starting with 'p' for completionEdit this pageLast updated on Dec 20, 2024 by Mike DonnalleyPreviousIntroductionNextFAQsFlag and Argument ParsingConfigurable Topic SeparatorsSuper SpeedCLI GeneratorTesting HelpersAuto-documentationPluginsHooksJSON OutputFlexible TaxonomyTypeScript (or not)Auto-Updating InstallersAutocomplete\n\n\n\nGetting StartedFeaturesOn this pageFeaturesHere are some key features that set oclif apart from other CLI frameworks.
Flag and Argument Parsing​
No CLI framework is complete without a flag parser. We've built a custom flag parser from years of experimentation that we feel is flexible enough to make an easy, predictable user experience but without compromising type safety for the developer.
Configurable Topic Separators​
By default, topics are separated with colons, such as my:awesome:command. However, you can use spaces if you prefer, such as my awesome command.
Super Speed​
The overhead for running an oclif CLI command is almost nothing. The command requires few dependencies; for example, only 17 dependencies are required for a minimal setup. Also, only the command to be executed requires Node.js. Which means that a large CLI with many commands loads as fast as a small CLI with just a single command.
CLI Generator​
You can get started from scratch quickly; all you need is a single command to scaffold out a fully functional CLI. See Generator Commands.
Testing Helpers​
We've worked hard to make commands easily testable and easy to mock out stdout and stderr. The CLI generator automatically creates scaffolded tests.
Auto-documentation​
By default, you pass --help to a CLI command to get help, such as the flag options and argument information. This information is also automatically added to the README whenever the CLI's npm package is published. See the plugin-plugins as an example.
Plugins​
Using plugins, you can extend a CLI with new functionality, split it into modular components, and share its functionality among multiple CLIs. See Building your own plugin.
Hooks​
Use lifecycle hooks to run functionality anytime a CLI starts, or on custom triggers. Use hooks whenever you want to share custom functionality between various components of the CLI. See Hooks.
JSON Output​
Your CLI can opt in to using the --json flag, which causes commands to automatically suppress console logs and display their final results as valid JSON output. The --json flag is useful if you want to use your CLI for scripting in CI/CD environments. See JSON.
Flexible Taxonomy​
You can opt in to what we call flexible taxonomy. When enabled, this feature allows users to execute commands without adhering to your defined command taxonomy.
This feature makes your CLI more user-friendly, especially if you have long command names which users find difficult to remember. For example, users can find it hard to remember if a command is called project deploy metadata start or project start deploy metadata - with flexible taxonomy, it doesn't matter because both are valid!
TypeScript (or not)​
Everything in the core of oclif is written in TypeScript, and the CLI generator can build both fully configured TypeScript or plain JavaScript CLIs. Because of TypeScript static properties, the syntax is a bit cleaner in TypeScript — but everything works, no matter which language you choose. If you use plugins support, the CLI automatically uses ts-node to run the plugins, which makes it easy and fast to use TypeScript with minimal-to-no boilerplate needed for any oclif CLI.
Auto-Updating Installers​
oclif can package your CLI into different installers that don't require the user to already have Node.js installed on their computer. You can make these installers auto-updatable by using plugin-update.
Autocomplete​
Include terminal autocompletion for your CLI with the plugin-autocomplete. After the autocomplete feature is configured, users can complete command names and flag names by pressing the tab key.
$ my-cli p<tab><tab> # lists all commands starting with 'p' for completionEdit this pageLast updated on Dec 20, 2024 by Mike Donnalley\n\nGetting StartedFeaturesOn this pageFeaturesHere are some key features that set oclif apart from other CLI frameworks.
Flag and Argument Parsing​
No CLI framework is complete without a flag parser. We've built a custom flag parser from years of experimentation that we feel is flexible enough to make an easy, predictable user experience but without compromising type safety for the developer.
Configurable Topic Separators​
By default, topics are separated with colons, such as my:awesome:command. However, you can use spaces if you prefer, such as my awesome command.
Super Speed​
The overhead for running an oclif CLI command is almost nothing. The command requires few dependencies; for example, only 17 dependencies are required for a minimal setup. Also, only the command to be executed requires Node.js. Which means that a large CLI with many commands loads as fast as a small CLI with just a single command.
CLI Generator​
You can get started from scratch quickly; all you need is a single command to scaffold out a fully functional CLI. See Generator Commands.
Testing Helpers​
We've worked hard to make commands easily testable and easy to mock out stdout and stderr. The CLI generator automatically creates scaffolded tests.
Auto-documentation​
By default, you pass --help to a CLI command to get help, such as the flag options and argument information. This information is also automatically added to the README whenever the CLI's npm package is published. See the plugin-plugins as an example.
Plugins​
Using plugins, you can extend a CLI with new functionality, split it into modular components, and share its functionality among multiple CLIs. See Building your own plugin.
Hooks​
Use lifecycle hooks to run functionality anytime a CLI starts, or on custom triggers. Use hooks whenever you want to share custom functionality between various components of the CLI. See Hooks.
JSON Output​
Your CLI can opt in to using the --json flag, which causes commands to automatically suppress console logs and display their final results as valid JSON output. The --json flag is useful if you want to use your CLI for scripting in CI/CD environments. See JSON.
Flexible Taxonomy​
You can opt in to what we call flexible taxonomy. When enabled, this feature allows users to execute commands without adhering to your defined command taxonomy.
This feature makes your CLI more user-friendly, especially if you have long command names which users find difficult to remember. For example, users can find it hard to remember if a command is called project deploy metadata start or project start deploy metadata - with flexible taxonomy, it doesn't matter because both are valid!
TypeScript (or not)​
Everything in the core of oclif is written in TypeScript, and the CLI generator can build both fully configured TypeScript or plain JavaScript CLIs. Because of TypeScript static properties, the syntax is a bit cleaner in TypeScript — but everything works, no matter which language you choose. If you use plugins support, the CLI automatically uses ts-node to run the plugins, which makes it easy and fast to use TypeScript with minimal-to-no boilerplate needed for any oclif CLI.
Auto-Updating Installers​
oclif can package your CLI into different installers that don't require the user to already have Node.js installed on their computer. You can make these installers auto-updatable by using plugin-update.
Autocomplete​
Include terminal autocompletion for your CLI with the plugin-autocomplete. After the autocomplete feature is configured, users can complete command names and flag names by pressing the tab key.
$ my-cli p<tab><tab> # lists all commands starting with 'p' for completionEdit this pageLast updated on Dec 20, 2024 by Mike DonnalleyPreviousIntroductionNextFAQsFlag and Argument ParsingConfigurable Topic SeparatorsSuper SpeedCLI GeneratorTesting HelpersAuto-documentationPluginsHooksJSON OutputFlexible TaxonomyTypeScript (or not)Auto-Updating InstallersAutocomplete\n\n\n\nGuidesJSONJSONIf you want to use the --json flag to return JSON output to the user, then you can set the enableJsonFlag property on the Command class.
When this property is set and the user supplies the --json flag, the command will suppress all logs and instead log the return value to the console in JSON format. Note log suppression will only work if you use the logging methods on the Command class instance. In other words, this.log will be automatically suppressed but console.log will not be.
import {Command} from '@oclif/core'export class HelloCommand extends Command {  public static enableJsonFlag = true  public async run(): Promise<{ message: string }> {    this.log('hello, world!')    return { message: 'hello, world!' }  }}
$ my-cli hellohello, world!
$ my-cli hello --json{  "message": "hello, world!"}Edit this pageLast updated on Dec 20, 2024 by Mike Donnalley\n\nGuidesJSONJSONIf you want to use the --json flag to return JSON output to the user, then you can set the enableJsonFlag property on the Command class.
When this property is set and the user supplies the --json flag, the command will suppress all logs and instead log the return value to the console in JSON format. Note log suppression will only work if you use the logging methods on the Command class instance. In other words, this.log will be automatically suppressed but console.log will not be.
import {Command} from '@oclif/core'export class HelloCommand extends Command {  public static enableJsonFlag = true  public async run(): Promise<{ message: string }> {    this.log('hello, world!')    return { message: 'hello, world!' }  }}
$ my-cli hellohello, world!
$ my-cli hello --json{  "message": "hello, world!"}Edit this pageLast updated on Dec 20, 2024 by Mike DonnalleyPreviousJust-in-Time Plugin InstallationNextLogging\n\n\n\nGetting StartedFeaturesOn this pageFeaturesHere are some key features that set oclif apart from other CLI frameworks.
Flag and Argument Parsing​
No CLI framework is complete without a flag parser. We've built a custom flag parser from years of experimentation that we feel is flexible enough to make an easy, predictable user experience but without compromising type safety for the developer.
Configurable Topic Separators​
By default, topics are separated with colons, such as my:awesome:command. However, you can use spaces if you prefer, such as my awesome command.
Super Speed​
The overhead for running an oclif CLI command is almost nothing. The command requires few dependencies; for example, only 17 dependencies are required for a minimal setup. Also, only the command to be executed requires Node.js. Which means that a large CLI with many commands loads as fast as a small CLI with just a single command.
CLI Generator​
You can get started from scratch quickly; all you need is a single command to scaffold out a fully functional CLI. See Generator Commands.
Testing Helpers​
We've worked hard to make commands easily testable and easy to mock out stdout and stderr. The CLI generator automatically creates scaffolded tests.
Auto-documentation​
By default, you pass --help to a CLI command to get help, such as the flag options and argument information. This information is also automatically added to the README whenever the CLI's npm package is published. See the plugin-plugins as an example.
Plugins​
Using plugins, you can extend a CLI with new functionality, split it into modular components, and share its functionality among multiple CLIs. See Building your own plugin.
Hooks​
Use lifecycle hooks to run functionality anytime a CLI starts, or on custom triggers. Use hooks whenever you want to share custom functionality between various components of the CLI. See Hooks.
JSON Output​
Your CLI can opt in to using the --json flag, which causes commands to automatically suppress console logs and display their final results as valid JSON output. The --json flag is useful if you want to use your CLI for scripting in CI/CD environments. See JSON.
Flexible Taxonomy​
You can opt in to what we call flexible taxonomy. When enabled, this feature allows users to execute commands without adhering to your defined command taxonomy.
This feature makes your CLI more user-friendly, especially if you have long command names which users find difficult to remember. For example, users can find it hard to remember if a command is called project deploy metadata start or project start deploy metadata - with flexible taxonomy, it doesn't matter because both are valid!
TypeScript (or not)​
Everything in the core of oclif is written in TypeScript, and the CLI generator can build both fully configured TypeScript or plain JavaScript CLIs. Because of TypeScript static properties, the syntax is a bit cleaner in TypeScript — but everything works, no matter which language you choose. If you use plugins support, the CLI automatically uses ts-node to run the plugins, which makes it easy and fast to use TypeScript with minimal-to-no boilerplate needed for any oclif CLI.
Auto-Updating Installers​
oclif can package your CLI into different installers that don't require the user to already have Node.js installed on their computer. You can make these installers auto-updatable by using plugin-update.
Autocomplete​
Include terminal autocompletion for your CLI with the plugin-autocomplete. After the autocomplete feature is configured, users can complete command names and flag names by pressing the tab key.
$ my-cli p<tab><tab> # lists all commands starting with 'p' for completionEdit this pageLast updated on Dec 20, 2024 by Mike Donnalley\n\nGetting StartedFeaturesOn this pageFeaturesHere are some key features that set oclif apart from other CLI frameworks.
Flag and Argument Parsing​
No CLI framework is complete without a flag parser. We've built a custom flag parser from years of experimentation that we feel is flexible enough to make an easy, predictable user experience but without compromising type safety for the developer.
Configurable Topic Separators​
By default, topics are separated with colons, such as my:awesome:command. However, you can use spaces if you prefer, such as my awesome command.
Super Speed​
The overhead for running an oclif CLI command is almost nothing. The command requires few dependencies; for example, only 17 dependencies are required for a minimal setup. Also, only the command to be executed requires Node.js. Which means that a large CLI with many commands loads as fast as a small CLI with just a single command.
CLI Generator​
You can get started from scratch quickly; all you need is a single command to scaffold out a fully functional CLI. See Generator Commands.
Testing Helpers​
We've worked hard to make commands easily testable and easy to mock out stdout and stderr. The CLI generator automatically creates scaffolded tests.
Auto-documentation​
By default, you pass --help to a CLI command to get help, such as the flag options and argument information. This information is also automatically added to the README whenever the CLI's npm package is published. See the plugin-plugins as an example.
Plugins​
Using plugins, you can extend a CLI with new functionality, split it into modular components, and share its functionality among multiple CLIs. See Building your own plugin.
Hooks​
Use lifecycle hooks to run functionality anytime a CLI starts, or on custom triggers. Use hooks whenever you want to share custom functionality between various components of the CLI. See Hooks.
JSON Output​
Your CLI can opt in to using the --json flag, which causes commands to automatically suppress console logs and display their final results as valid JSON output. The --json flag is useful if you want to use your CLI for scripting in CI/CD environments. See JSON.
Flexible Taxonomy​
You can opt in to what we call flexible taxonomy. When enabled, this feature allows users to execute commands without adhering to your defined command taxonomy.
This feature makes your CLI more user-friendly, especially if you have long command names which users find difficult to remember. For example, users can find it hard to remember if a command is called project deploy metadata start or project start deploy metadata - with flexible taxonomy, it doesn't matter because both are valid!
TypeScript (or not)​
Everything in the core of oclif is written in TypeScript, and the CLI generator can build both fully configured TypeScript or plain JavaScript CLIs. Because of TypeScript static properties, the syntax is a bit cleaner in TypeScript — but everything works, no matter which language you choose. If you use plugins support, the CLI automatically uses ts-node to run the plugins, which makes it easy and fast to use TypeScript with minimal-to-no boilerplate needed for any oclif CLI.
Auto-Updating Installers​
oclif can package your CLI into different installers that don't require the user to already have Node.js installed on their computer. You can make these installers auto-updatable by using plugin-update.
Autocomplete​
Include terminal autocompletion for your CLI with the plugin-autocomplete. After the autocomplete feature is configured, users can complete command names and flag names by pressing the tab key.
$ my-cli p<tab><tab> # lists all commands starting with 'p' for completionEdit this pageLast updated on Dec 20, 2024 by Mike DonnalleyPreviousIntroductionNextFAQsFlag and Argument ParsingConfigurable Topic SeparatorsSuper SpeedCLI GeneratorTesting HelpersAuto-documentationPluginsHooksJSON OutputFlexible TaxonomyTypeScript (or not)Auto-Updating InstallersAutocomplete\n\n\n\nGuidesFlexible TaxonomyOn this pageFlexible TaxonomyIf you'd like for your customers to execute commands without adhering to the defined command taxonomy, you can enable flexibleTaxonomy and add a hook to the oclif section of your package.json:
{  "oclif": {    "flexibleTaxonomy": true,    "hooks": {      "command_incomplete": "./dist/hooks/command_incomplete.js"    }  }}
There are two main benefits to enabling flexible taxonomy:

It makes your CLI more user-friendly. For example, you might have a command, my-cli foobars list. If a user mistakenly enters my-cli list foobars then oclif will automatically know that it should execute foobars list instead of throwing an error.
It gives you the opportunity to prompt a user for the right command if they only provide part of a command. This makes individual commands more discoverable, especially if you have a large number of commands. See Hook Implementation for more details.

Hook Implementation​
When flexibleTaxonomy is enabled, oclif will run the command_incomplete hook anytime a user enters an incomplete command (e.g. the command is one two three but they only entered two). This hook gives you the opportunity to create an interactive user experience.
This example shows how you can use the inquirer package to prompt the user for which command they would like to run:
import { Hook, toConfiguredId, toStandardizedId } from '@oclif/core';import { select } from '@inquirer/prompts';const hook: Hook.CommandIncomplete = async function ({  config,  matches,  argv,}) {  const command = await select({    message: 'Which of these commands would you like to run?',    choices: matches.map((p) => toConfiguredId(p.id, config)),  });  if (argv.includes('--help') || argv.includes('-h')) {    return config.runCommand('help', [toStandardizedId(command, config)]);  }  return config.runCommand(toStandardizedId(command, config), argv);};export default hook;
This is the prompt that the user would see:
$ my-cli list? Which of these commands did you mean (Use arrow keys)❯ foobars list  config list  env listEdit this pageLast updated on Dec 20, 2024 by Mike Donnalley\n\nGuidesFlexible TaxonomyOn this pageFlexible TaxonomyIf you'd like for your customers to execute commands without adhering to the defined command taxonomy, you can enable flexibleTaxonomy and add a hook to the oclif section of your package.json:
{  "oclif": {    "flexibleTaxonomy": true,    "hooks": {      "command_incomplete": "./dist/hooks/command_incomplete.js"    }  }}
There are two main benefits to enabling flexible taxonomy:

It makes your CLI more user-friendly. For example, you might have a command, my-cli foobars list. If a user mistakenly enters my-cli list foobars then oclif will automatically know that it should execute foobars list instead of throwing an error.
It gives you the opportunity to prompt a user for the right command if they only provide part of a command. This makes individual commands more discoverable, especially if you have a large number of commands. See Hook Implementation for more details.

Hook Implementation​
When flexibleTaxonomy is enabled, oclif will run the command_incomplete hook anytime a user enters an incomplete command (e.g. the command is one two three but they only entered two). This hook gives you the opportunity to create an interactive user experience.
This example shows how you can use the inquirer package to prompt the user for which command they would like to run:
import { Hook, toConfiguredId, toStandardizedId } from '@oclif/core';import { select } from '@inquirer/prompts';const hook: Hook.CommandIncomplete = async function ({  config,  matches,  argv,}) {  const command = await select({    message: 'Which of these commands would you like to run?',    choices: matches.map((p) => toConfiguredId(p.id, config)),  });  if (argv.includes('--help') || argv.includes('-h')) {    return config.runCommand('help', [toStandardizedId(command, config)]);  }  return config.runCommand(toStandardizedId(command, config), argv);};export default hook;
This is the prompt that the user would see:
$ my-cli list? Which of these commands did you mean (Use arrow keys)❯ foobars list  config list  env listEdit this pageLast updated on Dec 20, 2024 by Mike DonnalleyPreviousFlag InheritanceNextJust-in-Time Plugin InstallationHook Implementation\n\n\n\nGetting StartedFeaturesOn this pageFeaturesHere are some key features that set oclif apart from other CLI frameworks.
Flag and Argument Parsing​
No CLI framework is complete without a flag parser. We've built a custom flag parser from years of experimentation that we feel is flexible enough to make an easy, predictable user experience but without compromising type safety for the developer.
Configurable Topic Separators​
By default, topics are separated with colons, such as my:awesome:command. However, you can use spaces if you prefer, such as my awesome command.
Super Speed​
The overhead for running an oclif CLI command is almost nothing. The command requires few dependencies; for example, only 17 dependencies are required for a minimal setup. Also, only the command to be executed requires Node.js. Which means that a large CLI with many commands loads as fast as a small CLI with just a single command.
CLI Generator​
You can get started from scratch quickly; all you need is a single command to scaffold out a fully functional CLI. See Generator Commands.
Testing Helpers​
We've worked hard to make commands easily testable and easy to mock out stdout and stderr. The CLI generator automatically creates scaffolded tests.
Auto-documentation​
By default, you pass --help to a CLI command to get help, such as the flag options and argument information. This information is also automatically added to the README whenever the CLI's npm package is published. See the plugin-plugins as an example.
Plugins​
Using plugins, you can extend a CLI with new functionality, split it into modular components, and share its functionality among multiple CLIs. See Building your own plugin.
Hooks​
Use lifecycle hooks to run functionality anytime a CLI starts, or on custom triggers. Use hooks whenever you want to share custom functionality between various components of the CLI. See Hooks.
JSON Output​
Your CLI can opt in to using the --json flag, which causes commands to automatically suppress console logs and display their final results as valid JSON output. The --json flag is useful if you want to use your CLI for scripting in CI/CD environments. See JSON.
Flexible Taxonomy​
You can opt in to what we call flexible taxonomy. When enabled, this feature allows users to execute commands without adhering to your defined command taxonomy.
This feature makes your CLI more user-friendly, especially if you have long command names which users find difficult to remember. For example, users can find it hard to remember if a command is called project deploy metadata start or project start deploy metadata - with flexible taxonomy, it doesn't matter because both are valid!
TypeScript (or not)​
Everything in the core of oclif is written in TypeScript, and the CLI generator can build both fully configured TypeScript or plain JavaScript CLIs. Because of TypeScript static properties, the syntax is a bit cleaner in TypeScript — but everything works, no matter which language you choose. If you use plugins support, the CLI automatically uses ts-node to run the plugins, which makes it easy and fast to use TypeScript with minimal-to-no boilerplate needed for any oclif CLI.
Auto-Updating Installers​
oclif can package your CLI into different installers that don't require the user to already have Node.js installed on their computer. You can make these installers auto-updatable by using plugin-update.
Autocomplete​
Include terminal autocompletion for your CLI with the plugin-autocomplete. After the autocomplete feature is configured, users can complete command names and flag names by pressing the tab key.
$ my-cli p<tab><tab> # lists all commands starting with 'p' for completionEdit this pageLast updated on Dec 20, 2024 by Mike Donnalley\n\nGetting StartedFeaturesOn this pageFeaturesHere are some key features that set oclif apart from other CLI frameworks.
Flag and Argument Parsing​
No CLI framework is complete without a flag parser. We've built a custom flag parser from years of experimentation that we feel is flexible enough to make an easy, predictable user experience but without compromising type safety for the developer.
Configurable Topic Separators​
By default, topics are separated with colons, such as my:awesome:command. However, you can use spaces if you prefer, such as my awesome command.
Super Speed​
The overhead for running an oclif CLI command is almost nothing. The command requires few dependencies; for example, only 17 dependencies are required for a minimal setup. Also, only the command to be executed requires Node.js. Which means that a large CLI with many commands loads as fast as a small CLI with just a single command.
CLI Generator​
You can get started from scratch quickly; all you need is a single command to scaffold out a fully functional CLI. See Generator Commands.
Testing Helpers​
We've worked hard to make commands easily testable and easy to mock out stdout and stderr. The CLI generator automatically creates scaffolded tests.
Auto-documentation​
By default, you pass --help to a CLI command to get help, such as the flag options and argument information. This information is also automatically added to the README whenever the CLI's npm package is published. See the plugin-plugins as an example.
Plugins​
Using plugins, you can extend a CLI with new functionality, split it into modular components, and share its functionality among multiple CLIs. See Building your own plugin.
Hooks​
Use lifecycle hooks to run functionality anytime a CLI starts, or on custom triggers. Use hooks whenever you want to share custom functionality between various components of the CLI. See Hooks.
JSON Output​
Your CLI can opt in to using the --json flag, which causes commands to automatically suppress console logs and display their final results as valid JSON output. The --json flag is useful if you want to use your CLI for scripting in CI/CD environments. See JSON.
Flexible Taxonomy​
You can opt in to what we call flexible taxonomy. When enabled, this feature allows users to execute commands without adhering to your defined command taxonomy.
This feature makes your CLI more user-friendly, especially if you have long command names which users find difficult to remember. For example, users can find it hard to remember if a command is called project deploy metadata start or project start deploy metadata - with flexible taxonomy, it doesn't matter because both are valid!
TypeScript (or not)​
Everything in the core of oclif is written in TypeScript, and the CLI generator can build both fully configured TypeScript or plain JavaScript CLIs. Because of TypeScript static properties, the syntax is a bit cleaner in TypeScript — but everything works, no matter which language you choose. If you use plugins support, the CLI automatically uses ts-node to run the plugins, which makes it easy and fast to use TypeScript with minimal-to-no boilerplate needed for any oclif CLI.
Auto-Updating Installers​
oclif can package your CLI into different installers that don't require the user to already have Node.js installed on their computer. You can make these installers auto-updatable by using plugin-update.
Autocomplete​
Include terminal autocompletion for your CLI with the plugin-autocomplete. After the autocomplete feature is configured, users can complete command names and flag names by pressing the tab key.
$ my-cli p<tab><tab> # lists all commands starting with 'p' for completionEdit this pageLast updated on Dec 20, 2024 by Mike DonnalleyPreviousIntroductionNextFAQsFlag and Argument ParsingConfigurable Topic SeparatorsSuper SpeedCLI GeneratorTesting HelpersAuto-documentationPluginsHooksJSON OutputFlexible TaxonomyTypeScript (or not)Auto-Updating InstallersAutocomplete\n\n\n\nGetting StartedFeaturesOn this pageFeaturesHere are some key features that set oclif apart from other CLI frameworks.
Flag and Argument Parsing​
No CLI framework is complete without a flag parser. We've built a custom flag parser from years of experimentation that we feel is flexible enough to make an easy, predictable user experience but without compromising type safety for the developer.
Configurable Topic Separators​
By default, topics are separated with colons, such as my:awesome:command. However, you can use spaces if you prefer, such as my awesome command.
Super Speed​
The overhead for running an oclif CLI command is almost nothing. The command requires few dependencies; for example, only 17 dependencies are required for a minimal setup. Also, only the command to be executed requires Node.js. Which means that a large CLI with many commands loads as fast as a small CLI with just a single command.
CLI Generator​
You can get started from scratch quickly; all you need is a single command to scaffold out a fully functional CLI. See Generator Commands.
Testing Helpers​
We've worked hard to make commands easily testable and easy to mock out stdout and stderr. The CLI generator automatically creates scaffolded tests.
Auto-documentation​
By default, you pass --help to a CLI command to get help, such as the flag options and argument information. This information is also automatically added to the README whenever the CLI's npm package is published. See the plugin-plugins as an example.
Plugins​
Using plugins, you can extend a CLI with new functionality, split it into modular components, and share its functionality among multiple CLIs. See Building your own plugin.
Hooks​
Use lifecycle hooks to run functionality anytime a CLI starts, or on custom triggers. Use hooks whenever you want to share custom functionality between various components of the CLI. See Hooks.
JSON Output​
Your CLI can opt in to using the --json flag, which causes commands to automatically suppress console logs and display their final results as valid JSON output. The --json flag is useful if you want to use your CLI for scripting in CI/CD environments. See JSON.
Flexible Taxonomy​
You can opt in to what we call flexible taxonomy. When enabled, this feature allows users to execute commands without adhering to your defined command taxonomy.
This feature makes your CLI more user-friendly, especially if you have long command names which users find difficult to remember. For example, users can find it hard to remember if a command is called project deploy metadata start or project start deploy metadata - with flexible taxonomy, it doesn't matter because both are valid!
TypeScript (or not)​
Everything in the core of oclif is written in TypeScript, and the CLI generator can build both fully configured TypeScript or plain JavaScript CLIs. Because of TypeScript static properties, the syntax is a bit cleaner in TypeScript — but everything works, no matter which language you choose. If you use plugins support, the CLI automatically uses ts-node to run the plugins, which makes it easy and fast to use TypeScript with minimal-to-no boilerplate needed for any oclif CLI.
Auto-Updating Installers​
oclif can package your CLI into different installers that don't require the user to already have Node.js installed on their computer. You can make these installers auto-updatable by using plugin-update.
Autocomplete​
Include terminal autocompletion for your CLI with the plugin-autocomplete. After the autocomplete feature is configured, users can complete command names and flag names by pressing the tab key.
$ my-cli p<tab><tab> # lists all commands starting with 'p' for completionEdit this pageLast updated on Dec 20, 2024 by Mike Donnalley\n\nGetting StartedFeaturesOn this pageFeaturesHere are some key features that set oclif apart from other CLI frameworks.
Flag and Argument Parsing​
No CLI framework is complete without a flag parser. We've built a custom flag parser from years of experimentation that we feel is flexible enough to make an easy, predictable user experience but without compromising type safety for the developer.
Configurable Topic Separators​
By default, topics are separated with colons, such as my:awesome:command. However, you can use spaces if you prefer, such as my awesome command.
Super Speed​
The overhead for running an oclif CLI command is almost nothing. The command requires few dependencies; for example, only 17 dependencies are required for a minimal setup. Also, only the command to be executed requires Node.js. Which means that a large CLI with many commands loads as fast as a small CLI with just a single command.
CLI Generator​
You can get started from scratch quickly; all you need is a single command to scaffold out a fully functional CLI. See Generator Commands.
Testing Helpers​
We've worked hard to make commands easily testable and easy to mock out stdout and stderr. The CLI generator automatically creates scaffolded tests.
Auto-documentation​
By default, you pass --help to a CLI command to get help, such as the flag options and argument information. This information is also automatically added to the README whenever the CLI's npm package is published. See the plugin-plugins as an example.
Plugins​
Using plugins, you can extend a CLI with new functionality, split it into modular components, and share its functionality among multiple CLIs. See Building your own plugin.
Hooks​
Use lifecycle hooks to run functionality anytime a CLI starts, or on custom triggers. Use hooks whenever you want to share custom functionality between various components of the CLI. See Hooks.
JSON Output​
Your CLI can opt in to using the --json flag, which causes commands to automatically suppress console logs and display their final results as valid JSON output. The --json flag is useful if you want to use your CLI for scripting in CI/CD environments. See JSON.
Flexible Taxonomy​
You can opt in to what we call flexible taxonomy. When enabled, this feature allows users to execute commands without adhering to your defined command taxonomy.
This feature makes your CLI more user-friendly, especially if you have long command names which users find difficult to remember. For example, users can find it hard to remember if a command is called project deploy metadata start or project start deploy metadata - with flexible taxonomy, it doesn't matter because both are valid!
TypeScript (or not)​
Everything in the core of oclif is written in TypeScript, and the CLI generator can build both fully configured TypeScript or plain JavaScript CLIs. Because of TypeScript static properties, the syntax is a bit cleaner in TypeScript — but everything works, no matter which language you choose. If you use plugins support, the CLI automatically uses ts-node to run the plugins, which makes it easy and fast to use TypeScript with minimal-to-no boilerplate needed for any oclif CLI.
Auto-Updating Installers​
oclif can package your CLI into different installers that don't require the user to already have Node.js installed on their computer. You can make these installers auto-updatable by using plugin-update.
Autocomplete​
Include terminal autocompletion for your CLI with the plugin-autocomplete. After the autocomplete feature is configured, users can complete command names and flag names by pressing the tab key.
$ my-cli p<tab><tab> # lists all commands starting with 'p' for completionEdit this pageLast updated on Dec 20, 2024 by Mike DonnalleyPreviousIntroductionNextFAQsFlag and Argument ParsingConfigurable Topic SeparatorsSuper SpeedCLI GeneratorTesting HelpersAuto-documentationPluginsHooksJSON OutputFlexible TaxonomyTypeScript (or not)Auto-Updating InstallersAutocomplete\n\n\n\nGuidesReleaseOn this pageReleaseThere are 2 main strategies for releasing oclif CLIs: npm and standalone tarballs. You can publish to one or both.
npm​
Just use npm publish like any other npm project. This includes a run.cmd script that will automatically be used for Windows users.
$ npm version (major|minor|patch) # bumps version, updates README, adds git tag$ npm publish$ npm install -g mynewcli$ mynewcli# OR$ npx mynewcli
You'll need to register with npm and have verified your email address in order to publish.
This workflow can be improved slightly by running npm version major|minor|patch before publishing which will create a git tag and bump the version automatically.
Standalone tarballs​
Build standalone tarballs with oclif pack tarballs from the root of your CLI. These include the node binary so the user does not have to already have node installed to use the CLI. It won't put this node binary on the PATH so the binary will not conflict with any node installation on the machine.
To publish, you can copy the files from ./dist or use oclif upload tarballs to copy the files to S3. You'll need to set oclif.update.s3.bucket in package.json to a valid S3 bucket and have credentials set in AWS_ACCESS_KEY_ID and AWS_SECRET_ACCESS_KEY environment vars.
After you've uploaded the tarballs to S3, you can promote the tarballs to a release channel within S3 using oclif promote. This allows you to quickly promote and demote a specific version between release channels. For example, the Salesforce CLI has separate stable and stable-rc channels that are updated weekly.
Brew​
Your formula can be distributed through Brew. The main caveat is you must set the CLIENT_HOME variable when you ship, otherwise it will break the update cycle. An example of this can be found in the heroku cli formula. By exporting a variable of the form CLI_NAME_OCLIF_CLIENT_HOME (where CLI_NAME is the name of your CLI), you force the update mechanism to look at the brew install location instead of the default (which is $XDG_DATA_HOME/.local/share/package_name/client).
Autoupdater​
These tarballs as well as the installers below can be made autoupdatable by adding the @oclif/plugin-update plugin. Just add this plugin and the CLI will autoupdate in the background or when mycli update is run.
If you don't want to use S3, you can still run oclif pack and it will build tarballs. To get the updater to work, set oclif.update.s3.host in package.json to a host that has the files built in ./dist from oclif pack. This host does not need to be an S3 host. To customize the URL paths, see the S3 templates in @oclif/core.
Autoupdate Channels​
You can have separate channels for releases that work like Google Chrome Channels (such as beta, dev, canary). To create a channel, just change the version in package.json from 1.0.0 to 1.0.0-beta (where "beta" is any string you like). Then when you pack with oclif pack, it will create beta tarballs. The user can change their channel with mycli update beta and will receive all the future releases on that channel.
In the Heroku CLI, we have it automatically build and release the beta channel on every commit to the master branch. Then we have it build and release stable channel whenever a git tag is created in our CI.
Windows installer​
Build a windows installer with oclif pack win. It will build into ./dist/win. This can be uploaded to S3 with oclif upload win and promoted within S3 with oclif promote --win.
oclif pack win depends on having 7zip and nsis installed. If you're in a mac or unix environment and don't have them, you can use homebrew to install them.
brew install nsisbrew install p7zip
Signing the installer​
To produce a signed installer you need to set the scoped <CLI>_WINDOWS_SIGNING_PASS env var (e.g. MY_CLI_WINDOWS_SIGNING_PASS) and set windows.name and windows.keypath in your package.json:
{  "oclif": {    "windows": {      "name": "My CLI",      "keypath": "path/to/private.key"    }  }}
Refer to Microsoft's documentation on how to acquire a verified digital signature for your CLI.
macOS installer​
Build a macOS .pkg installer with oclif pack macos. It will build into ./dist/macos. This can be uploaded to S3 with oclif upload macos and promoted within S3 with oclif promote --macos. You need to set the macOS identifier at oclif.macos.identifier in package.json (we use "com.heroku.cli" and "com.salesforce.cli" as the identifiers for the Heroku CLI and the Salesforce CLI, respectively).
Uploading to S3​
The upload command defaults to using the ACL setting public-read unless another policy is specified under oclif.update.s3.acl in package.json. However, when creating new S3 buckets, AWS's default recommendation can result in an access error (Code: AccessControlListNotSupported) when trying to upload with the public-read setting.
To address this, consider updating the oclif section of your package.json with the desired ACL setting. The example below demonstrates how to set the acl to bucket-owner-full-control:
{  "oclif": {    "bin": "myOclifApp",    "dirname": "myOclifApp-cli-data",    "update": {      "s3": {        "host": "https://s3.console.aws.amazon.com/",        "bucket": "myOclifApp-cli",        "acl": "bucket-owner-full-control"      }    },    "macos": {      "identifier": "com.myOclifApp.cli"    }  }}
Amazon has a userguide here for help how to configure Bucket Policy settings.
Signing the installer​
To be able to sign an "installer signing identity" has to be available on the build machine (read more on certificates here).
Make sure such a certificate is created in developer.apple.com and that the certificate is downloaded and installed in the KeyChain of the build machine.
The certificate name has to be specified in the oclif.macos.sign in package.json.
Example:
    "macos": {      "identifier": "com.myOclifApp",      "sign": "\"3rd Party Mac Developer Installer: myOclifCompany (R2315646)\""    },
Pay attention to the escaped quotation marks, the certificate name is passed on as an argument to the pkgbuild command so without quotation marks it might break.
For the Heroku CLI the certificate name is "Developer ID Installer: Heroku INC". And optionally set the keychain with OSX_KEYCHAIN.
Installed certificates on the build machine can be viewed in the Keychain Access app.
Ubuntu/Debian packages​
Build a deb package with oclif pack deb. Set the MYCLI_DEB_KEY to a gpg key id to create the gpg files. This will include all the files needed for an apt repository in ./dist/deb. They can be uploaded to S3 with oclif upload deb and promoted within S3 using oclif promote --deb.
Once it's published to S3, users can install with the following:
$ wget -qO- https://mys3bucket.s3.amazonaws.com/apt/release.key | apt-key add - # you will need to upload this file manually$ sudo echo "deb https://mys3bucket.s3.amazonaws.com/apt ./" > /etc/apt/sources.list.d/mycli.list$ sudo apt update$ sudo apt install -y mycli
This can be placed in a script for users to install with curl https://pathto/myscript | sh.
These will not autoupdate as Ubuntu already has a reliable way for users to update their package.
Snapcraft​
Snap is a great way to distribute Linux CLIs and comes built into Ubuntu 16+. The Heroku CLI's snapcraft.yml file can be easily modified to work with any oclif CLI.Edit this pageLast updated on Dec 20, 2024 by Mike Donnalley\n\nGuidesReleaseOn this pageReleaseThere are 2 main strategies for releasing oclif CLIs: npm and standalone tarballs. You can publish to one or both.
npm​
Just use npm publish like any other npm project. This includes a run.cmd script that will automatically be used for Windows users.
$ npm version (major|minor|patch) # bumps version, updates README, adds git tag$ npm publish$ npm install -g mynewcli$ mynewcli# OR$ npx mynewcli
You'll need to register with npm and have verified your email address in order to publish.
This workflow can be improved slightly by running npm version major|minor|patch before publishing which will create a git tag and bump the version automatically.
Standalone tarballs​
Build standalone tarballs with oclif pack tarballs from the root of your CLI. These include the node binary so the user does not have to already have node installed to use the CLI. It won't put this node binary on the PATH so the binary will not conflict with any node installation on the machine.
To publish, you can copy the files from ./dist or use oclif upload tarballs to copy the files to S3. You'll need to set oclif.update.s3.bucket in package.json to a valid S3 bucket and have credentials set in AWS_ACCESS_KEY_ID and AWS_SECRET_ACCESS_KEY environment vars.
After you've uploaded the tarballs to S3, you can promote the tarballs to a release channel within S3 using oclif promote. This allows you to quickly promote and demote a specific version between release channels. For example, the Salesforce CLI has separate stable and stable-rc channels that are updated weekly.
Brew​
Your formula can be distributed through Brew. The main caveat is you must set the CLIENT_HOME variable when you ship, otherwise it will break the update cycle. An example of this can be found in the heroku cli formula. By exporting a variable of the form CLI_NAME_OCLIF_CLIENT_HOME (where CLI_NAME is the name of your CLI), you force the update mechanism to look at the brew install location instead of the default (which is $XDG_DATA_HOME/.local/share/package_name/client).
Autoupdater​
These tarballs as well as the installers below can be made autoupdatable by adding the @oclif/plugin-update plugin. Just add this plugin and the CLI will autoupdate in the background or when mycli update is run.
If you don't want to use S3, you can still run oclif pack and it will build tarballs. To get the updater to work, set oclif.update.s3.host in package.json to a host that has the files built in ./dist from oclif pack. This host does not need to be an S3 host. To customize the URL paths, see the S3 templates in @oclif/core.
Autoupdate Channels​
You can have separate channels for releases that work like Google Chrome Channels (such as beta, dev, canary). To create a channel, just change the version in package.json from 1.0.0 to 1.0.0-beta (where "beta" is any string you like). Then when you pack with oclif pack, it will create beta tarballs. The user can change their channel with mycli update beta and will receive all the future releases on that channel.
In the Heroku CLI, we have it automatically build and release the beta channel on every commit to the master branch. Then we have it build and release stable channel whenever a git tag is created in our CI.
Windows installer​
Build a windows installer with oclif pack win. It will build into ./dist/win. This can be uploaded to S3 with oclif upload win and promoted within S3 with oclif promote --win.
oclif pack win depends on having 7zip and nsis installed. If you're in a mac or unix environment and don't have them, you can use homebrew to install them.
brew install nsisbrew install p7zip
Signing the installer​
To produce a signed installer you need to set the scoped <CLI>_WINDOWS_SIGNING_PASS env var (e.g. MY_CLI_WINDOWS_SIGNING_PASS) and set windows.name and windows.keypath in your package.json:
{  "oclif": {    "windows": {      "name": "My CLI",      "keypath": "path/to/private.key"    }  }}
Refer to Microsoft's documentation on how to acquire a verified digital signature for your CLI.
macOS installer​
Build a macOS .pkg installer with oclif pack macos. It will build into ./dist/macos. This can be uploaded to S3 with oclif upload macos and promoted within S3 with oclif promote --macos. You need to set the macOS identifier at oclif.macos.identifier in package.json (we use "com.heroku.cli" and "com.salesforce.cli" as the identifiers for the Heroku CLI and the Salesforce CLI, respectively).
Uploading to S3​
The upload command defaults to using the ACL setting public-read unless another policy is specified under oclif.update.s3.acl in package.json. However, when creating new S3 buckets, AWS's default recommendation can result in an access error (Code: AccessControlListNotSupported) when trying to upload with the public-read setting.
To address this, consider updating the oclif section of your package.json with the desired ACL setting. The example below demonstrates how to set the acl to bucket-owner-full-control:
{  "oclif": {    "bin": "myOclifApp",    "dirname": "myOclifApp-cli-data",    "update": {      "s3": {        "host": "https://s3.console.aws.amazon.com/",        "bucket": "myOclifApp-cli",        "acl": "bucket-owner-full-control"      }    },    "macos": {      "identifier": "com.myOclifApp.cli"    }  }}
Amazon has a userguide here for help how to configure Bucket Policy settings.
Signing the installer​
To be able to sign an "installer signing identity" has to be available on the build machine (read more on certificates here).
Make sure such a certificate is created in developer.apple.com and that the certificate is downloaded and installed in the KeyChain of the build machine.
The certificate name has to be specified in the oclif.macos.sign in package.json.
Example:
    "macos": {      "identifier": "com.myOclifApp",      "sign": "\"3rd Party Mac Developer Installer: myOclifCompany (R2315646)\""    },
Pay attention to the escaped quotation marks, the certificate name is passed on as an argument to the pkgbuild command so without quotation marks it might break.
For the Heroku CLI the certificate name is "Developer ID Installer: Heroku INC". And optionally set the keychain with OSX_KEYCHAIN.
Installed certificates on the build machine can be viewed in the Keychain Access app.
Ubuntu/Debian packages​
Build a deb package with oclif pack deb. Set the MYCLI_DEB_KEY to a gpg key id to create the gpg files. This will include all the files needed for an apt repository in ./dist/deb. They can be uploaded to S3 with oclif upload deb and promoted within S3 using oclif promote --deb.
Once it's published to S3, users can install with the following:
$ wget -qO- https://mys3bucket.s3.amazonaws.com/apt/release.key | apt-key add - # you will need to upload this file manually$ sudo echo "deb https://mys3bucket.s3.amazonaws.com/apt ./" > /etc/apt/sources.list.d/mycli.list$ sudo apt update$ sudo apt install -y mycli
This can be placed in a script for users to install with curl https://pathto/myscript | sh.
These will not autoupdate as Ubuntu already has a reliable way for users to update their package.
Snapcraft​
Snap is a great way to distribute Linux CLIs and comes built into Ubuntu 16+. The Heroku CLI's snapcraft.yml file can be easily modified to work with any oclif CLI.Edit this pageLast updated on Dec 20, 2024 by Mike DonnalleyPreviousNSIS Installer CustomizationNextRunning Commands ProgrammaticallynpmStandalone tarballsBrewAutoupdaterAutoupdate ChannelsWindows installerSigning the installermacOS installerUploading to S3Signing the installerUbuntu/Debian packagesSnapcraft\n\n\n\nGetting StartedFeaturesOn this pageFeaturesHere are some key features that set oclif apart from other CLI frameworks.
Flag and Argument Parsing​
No CLI framework is complete without a flag parser. We've built a custom flag parser from years of experimentation that we feel is flexible enough to make an easy, predictable user experience but without compromising type safety for the developer.
Configurable Topic Separators​
By default, topics are separated with colons, such as my:awesome:command. However, you can use spaces if you prefer, such as my awesome command.
Super Speed​
The overhead for running an oclif CLI command is almost nothing. The command requires few dependencies; for example, only 17 dependencies are required for a minimal setup. Also, only the command to be executed requires Node.js. Which means that a large CLI with many commands loads as fast as a small CLI with just a single command.
CLI Generator​
You can get started from scratch quickly; all you need is a single command to scaffold out a fully functional CLI. See Generator Commands.
Testing Helpers​
We've worked hard to make commands easily testable and easy to mock out stdout and stderr. The CLI generator automatically creates scaffolded tests.
Auto-documentation​
By default, you pass --help to a CLI command to get help, such as the flag options and argument information. This information is also automatically added to the README whenever the CLI's npm package is published. See the plugin-plugins as an example.
Plugins​
Using plugins, you can extend a CLI with new functionality, split it into modular components, and share its functionality among multiple CLIs. See Building your own plugin.
Hooks​
Use lifecycle hooks to run functionality anytime a CLI starts, or on custom triggers. Use hooks whenever you want to share custom functionality between various components of the CLI. See Hooks.
JSON Output​
Your CLI can opt in to using the --json flag, which causes commands to automatically suppress console logs and display their final results as valid JSON output. The --json flag is useful if you want to use your CLI for scripting in CI/CD environments. See JSON.
Flexible Taxonomy​
You can opt in to what we call flexible taxonomy. When enabled, this feature allows users to execute commands without adhering to your defined command taxonomy.
This feature makes your CLI more user-friendly, especially if you have long command names which users find difficult to remember. For example, users can find it hard to remember if a command is called project deploy metadata start or project start deploy metadata - with flexible taxonomy, it doesn't matter because both are valid!
TypeScript (or not)​
Everything in the core of oclif is written in TypeScript, and the CLI generator can build both fully configured TypeScript or plain JavaScript CLIs. Because of TypeScript static properties, the syntax is a bit cleaner in TypeScript — but everything works, no matter which language you choose. If you use plugins support, the CLI automatically uses ts-node to run the plugins, which makes it easy and fast to use TypeScript with minimal-to-no boilerplate needed for any oclif CLI.
Auto-Updating Installers​
oclif can package your CLI into different installers that don't require the user to already have Node.js installed on their computer. You can make these installers auto-updatable by using plugin-update.
Autocomplete​
Include terminal autocompletion for your CLI with the plugin-autocomplete. After the autocomplete feature is configured, users can complete command names and flag names by pressing the tab key.
$ my-cli p<tab><tab> # lists all commands starting with 'p' for completionEdit this pageLast updated on Dec 20, 2024 by Mike Donnalley\n\nGetting StartedFeaturesOn this pageFeaturesHere are some key features that set oclif apart from other CLI frameworks.
Flag and Argument Parsing​
No CLI framework is complete without a flag parser. We've built a custom flag parser from years of experimentation that we feel is flexible enough to make an easy, predictable user experience but without compromising type safety for the developer.
Configurable Topic Separators​
By default, topics are separated with colons, such as my:awesome:command. However, you can use spaces if you prefer, such as my awesome command.
Super Speed​
The overhead for running an oclif CLI command is almost nothing. The command requires few dependencies; for example, only 17 dependencies are required for a minimal setup. Also, only the command to be executed requires Node.js. Which means that a large CLI with many commands loads as fast as a small CLI with just a single command.
CLI Generator​
You can get started from scratch quickly; all you need is a single command to scaffold out a fully functional CLI. See Generator Commands.
Testing Helpers​
We've worked hard to make commands easily testable and easy to mock out stdout and stderr. The CLI generator automatically creates scaffolded tests.
Auto-documentation​
By default, you pass --help to a CLI command to get help, such as the flag options and argument information. This information is also automatically added to the README whenever the CLI's npm package is published. See the plugin-plugins as an example.
Plugins​
Using plugins, you can extend a CLI with new functionality, split it into modular components, and share its functionality among multiple CLIs. See Building your own plugin.
Hooks​
Use lifecycle hooks to run functionality anytime a CLI starts, or on custom triggers. Use hooks whenever you want to share custom functionality between various components of the CLI. See Hooks.
JSON Output​
Your CLI can opt in to using the --json flag, which causes commands to automatically suppress console logs and display their final results as valid JSON output. The --json flag is useful if you want to use your CLI for scripting in CI/CD environments. See JSON.
Flexible Taxonomy​
You can opt in to what we call flexible taxonomy. When enabled, this feature allows users to execute commands without adhering to your defined command taxonomy.
This feature makes your CLI more user-friendly, especially if you have long command names which users find difficult to remember. For example, users can find it hard to remember if a command is called project deploy metadata start or project start deploy metadata - with flexible taxonomy, it doesn't matter because both are valid!
TypeScript (or not)​
Everything in the core of oclif is written in TypeScript, and the CLI generator can build both fully configured TypeScript or plain JavaScript CLIs. Because of TypeScript static properties, the syntax is a bit cleaner in TypeScript — but everything works, no matter which language you choose. If you use plugins support, the CLI automatically uses ts-node to run the plugins, which makes it easy and fast to use TypeScript with minimal-to-no boilerplate needed for any oclif CLI.
Auto-Updating Installers​
oclif can package your CLI into different installers that don't require the user to already have Node.js installed on their computer. You can make these installers auto-updatable by using plugin-update.
Autocomplete​
Include terminal autocompletion for your CLI with the plugin-autocomplete. After the autocomplete feature is configured, users can complete command names and flag names by pressing the tab key.
$ my-cli p<tab><tab> # lists all commands starting with 'p' for completionEdit this pageLast updated on Dec 20, 2024 by Mike DonnalleyPreviousIntroductionNextFAQsFlag and Argument ParsingConfigurable Topic SeparatorsSuper SpeedCLI GeneratorTesting HelpersAuto-documentationPluginsHooksJSON OutputFlexible TaxonomyTypeScript (or not)Auto-Updating InstallersAutocomplete\n\n\n\nGetting StartedFAQsOn this pageFAQsWhy Node?​
There are a number of reasons why Node is the best choice for writing CLI code. At Salesforce, we've released the Heroku CLI in Ruby, Go, as well as Node. Read this article for details on that history. But in the end, we found that Node offers the best of everything.
First, JavaScript is the biggest language in the world. More people write in JavaScript than in any other programming language, and it has the biggest open-source community, by far. Because everyone can write it, you can find many useful libraries to help build your CLI.
We've also found that Node has the best cross-platform support of any language we've used. In general, if you write code on macOS, you rarely find issues making it also run on Windows.
Node has the best support for our plugins model. Plugins are a way to share code between CLIs, to modularize a CLI's codebase, and to allow users to add functionality to an existing CLI. With Node, we can have separate dependency versions sitting alongside one another. As a result, if you want to release an update to a dependency in one plugin, it doesn't affect how another plugin works. oclif takes this to an extreme so that even flag parsing is done at the individual plugin level. For example, if we ever want to make a breaking change to flag parsing (don't worry, we don't intend to!), you can update just one plugin and keep the old behavior in other plugins. This feature is very helpful for large CLI codebases where you want to migrate to new code slowly.
How can I create a single binary CLI, like with Go?​
Use pkg. Make sure you add the commands and other source files by setting pkg.scripts: "./lib/**/*.js" in package.json.
In Salesforce CLI, however, we prefer to ship a tarball and various installers that have Node baked in. Use oclif pack to create a set of tarballs for different platforms with Node built in. You probably must use @oclif/plugin-update in your CLI, otherwise the users won't have a way to update the CLI from the tarball without reinstalling it.
Should I use TypeScript or JavaScript?​
We suggest you use TypeScript, because we find the typing helpful when refactoring code and updating dependencies. It's nicer to get compilation errors rather than finding errors in production.
We've put a lot of care into making it easy to create a TypeScript CLI, even if you've never written TypeScript before. We generate CLIs and plugins that use ts-node, which makes it fast to run the TypeScript code without a compilation step. And you don't have to mess around with build configuration using oclif.
Still, the two languages are very similar today. The code you write in JavaScript will be nearly identical to what you would have in TypeScript, but with no type definitions of course.
What editor is best for oclif?​
If you already have a favorite editor, go ahead and keep using it. However, we typically recommend Visual Studio Code, or VS Code for short.
Microsoft has done a great job with this editor and it works particularly well for TypeScript projects. You get nice type checking, linting, and autocomplete, right out of the box.
Should I use npm or yarn?​
It doesn't make that much of a difference. If you're just getting started, keep it simple and use npm, which comes with Node. We like to use yarn internally, as it's a bit faster and we find the lockfiles friendlier.
How can I make the oclif generator run faster?​
If you're using npx, first install oclif by running npm install -g oclif. But to stay current with the latest updates, you must manually run npm update -g oclif to get new versions of the generator.
Why isn't Node X supported?​
The oclif project follows and supports Node's LTS support schedule, which allows oclif to stay current with Node's development.
How do I pronounce "oclif"?​
We say "oh-cliff".Edit this pageLast updated on Dec 20, 2024 by Mike Donnalley\n\nGetting StartedFAQsOn this pageFAQsWhy Node?​
There are a number of reasons why Node is the best choice for writing CLI code. At Salesforce, we've released the Heroku CLI in Ruby, Go, as well as Node. Read this article for details on that history. But in the end, we found that Node offers the best of everything.
First, JavaScript is the biggest language in the world. More people write in JavaScript than in any other programming language, and it has the biggest open-source community, by far. Because everyone can write it, you can find many useful libraries to help build your CLI.
We've also found that Node has the best cross-platform support of any language we've used. In general, if you write code on macOS, you rarely find issues making it also run on Windows.
Node has the best support for our plugins model. Plugins are a way to share code between CLIs, to modularize a CLI's codebase, and to allow users to add functionality to an existing CLI. With Node, we can have separate dependency versions sitting alongside one another. As a result, if you want to release an update to a dependency in one plugin, it doesn't affect how another plugin works. oclif takes this to an extreme so that even flag parsing is done at the individual plugin level. For example, if we ever want to make a breaking change to flag parsing (don't worry, we don't intend to!), you can update just one plugin and keep the old behavior in other plugins. This feature is very helpful for large CLI codebases where you want to migrate to new code slowly.
How can I create a single binary CLI, like with Go?​
Use pkg. Make sure you add the commands and other source files by setting pkg.scripts: "./lib/**/*.js" in package.json.
In Salesforce CLI, however, we prefer to ship a tarball and various installers that have Node baked in. Use oclif pack to create a set of tarballs for different platforms with Node built in. You probably must use @oclif/plugin-update in your CLI, otherwise the users won't have a way to update the CLI from the tarball without reinstalling it.
Should I use TypeScript or JavaScript?​
We suggest you use TypeScript, because we find the typing helpful when refactoring code and updating dependencies. It's nicer to get compilation errors rather than finding errors in production.
We've put a lot of care into making it easy to create a TypeScript CLI, even if you've never written TypeScript before. We generate CLIs and plugins that use ts-node, which makes it fast to run the TypeScript code without a compilation step. And you don't have to mess around with build configuration using oclif.
Still, the two languages are very similar today. The code you write in JavaScript will be nearly identical to what you would have in TypeScript, but with no type definitions of course.
What editor is best for oclif?​
If you already have a favorite editor, go ahead and keep using it. However, we typically recommend Visual Studio Code, or VS Code for short.
Microsoft has done a great job with this editor and it works particularly well for TypeScript projects. You get nice type checking, linting, and autocomplete, right out of the box.
Should I use npm or yarn?​
It doesn't make that much of a difference. If you're just getting started, keep it simple and use npm, which comes with Node. We like to use yarn internally, as it's a bit faster and we find the lockfiles friendlier.
How can I make the oclif generator run faster?​
If you're using npx, first install oclif by running npm install -g oclif. But to stay current with the latest updates, you must manually run npm update -g oclif to get new versions of the generator.
Why isn't Node X supported?​
The oclif project follows and supports Node's LTS support schedule, which allows oclif to stay current with Node's development.
How do I pronounce "oclif"?​
We say "oh-cliff".Edit this pageLast updated on Dec 20, 2024 by Mike DonnalleyPreviousFeaturesNextGenerator CommandsWhy Node?How can I create a single binary CLI, like with Go?Should I use TypeScript or JavaScript?What editor is best for oclif?Should I use npm or yarn?How can I make the oclif generator run faster?Why isn't Node X supported?How do I pronounce "oclif"?\n\n\n\nGetting StartedFAQsOn this pageFAQsWhy Node?​
There are a number of reasons why Node is the best choice for writing CLI code. At Salesforce, we've released the Heroku CLI in Ruby, Go, as well as Node. Read this article for details on that history. But in the end, we found that Node offers the best of everything.
First, JavaScript is the biggest language in the world. More people write in JavaScript than in any other programming language, and it has the biggest open-source community, by far. Because everyone can write it, you can find many useful libraries to help build your CLI.
We've also found that Node has the best cross-platform support of any language we've used. In general, if you write code on macOS, you rarely find issues making it also run on Windows.
Node has the best support for our plugins model. Plugins are a way to share code between CLIs, to modularize a CLI's codebase, and to allow users to add functionality to an existing CLI. With Node, we can have separate dependency versions sitting alongside one another. As a result, if you want to release an update to a dependency in one plugin, it doesn't affect how another plugin works. oclif takes this to an extreme so that even flag parsing is done at the individual plugin level. For example, if we ever want to make a breaking change to flag parsing (don't worry, we don't intend to!), you can update just one plugin and keep the old behavior in other plugins. This feature is very helpful for large CLI codebases where you want to migrate to new code slowly.
How can I create a single binary CLI, like with Go?​
Use pkg. Make sure you add the commands and other source files by setting pkg.scripts: "./lib/**/*.js" in package.json.
In Salesforce CLI, however, we prefer to ship a tarball and various installers that have Node baked in. Use oclif pack to create a set of tarballs for different platforms with Node built in. You probably must use @oclif/plugin-update in your CLI, otherwise the users won't have a way to update the CLI from the tarball without reinstalling it.
Should I use TypeScript or JavaScript?​
We suggest you use TypeScript, because we find the typing helpful when refactoring code and updating dependencies. It's nicer to get compilation errors rather than finding errors in production.
We've put a lot of care into making it easy to create a TypeScript CLI, even if you've never written TypeScript before. We generate CLIs and plugins that use ts-node, which makes it fast to run the TypeScript code without a compilation step. And you don't have to mess around with build configuration using oclif.
Still, the two languages are very similar today. The code you write in JavaScript will be nearly identical to what you would have in TypeScript, but with no type definitions of course.
What editor is best for oclif?​
If you already have a favorite editor, go ahead and keep using it. However, we typically recommend Visual Studio Code, or VS Code for short.
Microsoft has done a great job with this editor and it works particularly well for TypeScript projects. You get nice type checking, linting, and autocomplete, right out of the box.
Should I use npm or yarn?​
It doesn't make that much of a difference. If you're just getting started, keep it simple and use npm, which comes with Node. We like to use yarn internally, as it's a bit faster and we find the lockfiles friendlier.
How can I make the oclif generator run faster?​
If you're using npx, first install oclif by running npm install -g oclif. But to stay current with the latest updates, you must manually run npm update -g oclif to get new versions of the generator.
Why isn't Node X supported?​
The oclif project follows and supports Node's LTS support schedule, which allows oclif to stay current with Node's development.
How do I pronounce "oclif"?​
We say "oh-cliff".Edit this pageLast updated on Dec 20, 2024 by Mike Donnalley\n\nGetting StartedFAQsOn this pageFAQsWhy Node?​
There are a number of reasons why Node is the best choice for writing CLI code. At Salesforce, we've released the Heroku CLI in Ruby, Go, as well as Node. Read this article for details on that history. But in the end, we found that Node offers the best of everything.
First, JavaScript is the biggest language in the world. More people write in JavaScript than in any other programming language, and it has the biggest open-source community, by far. Because everyone can write it, you can find many useful libraries to help build your CLI.
We've also found that Node has the best cross-platform support of any language we've used. In general, if you write code on macOS, you rarely find issues making it also run on Windows.
Node has the best support for our plugins model. Plugins are a way to share code between CLIs, to modularize a CLI's codebase, and to allow users to add functionality to an existing CLI. With Node, we can have separate dependency versions sitting alongside one another. As a result, if you want to release an update to a dependency in one plugin, it doesn't affect how another plugin works. oclif takes this to an extreme so that even flag parsing is done at the individual plugin level. For example, if we ever want to make a breaking change to flag parsing (don't worry, we don't intend to!), you can update just one plugin and keep the old behavior in other plugins. This feature is very helpful for large CLI codebases where you want to migrate to new code slowly.
How can I create a single binary CLI, like with Go?​
Use pkg. Make sure you add the commands and other source files by setting pkg.scripts: "./lib/**/*.js" in package.json.
In Salesforce CLI, however, we prefer to ship a tarball and various installers that have Node baked in. Use oclif pack to create a set of tarballs for different platforms with Node built in. You probably must use @oclif/plugin-update in your CLI, otherwise the users won't have a way to update the CLI from the tarball without reinstalling it.
Should I use TypeScript or JavaScript?​
We suggest you use TypeScript, because we find the typing helpful when refactoring code and updating dependencies. It's nicer to get compilation errors rather than finding errors in production.
We've put a lot of care into making it easy to create a TypeScript CLI, even if you've never written TypeScript before. We generate CLIs and plugins that use ts-node, which makes it fast to run the TypeScript code without a compilation step. And you don't have to mess around with build configuration using oclif.
Still, the two languages are very similar today. The code you write in JavaScript will be nearly identical to what you would have in TypeScript, but with no type definitions of course.
What editor is best for oclif?​
If you already have a favorite editor, go ahead and keep using it. However, we typically recommend Visual Studio Code, or VS Code for short.
Microsoft has done a great job with this editor and it works particularly well for TypeScript projects. You get nice type checking, linting, and autocomplete, right out of the box.
Should I use npm or yarn?​
It doesn't make that much of a difference. If you're just getting started, keep it simple and use npm, which comes with Node. We like to use yarn internally, as it's a bit faster and we find the lockfiles friendlier.
How can I make the oclif generator run faster?​
If you're using npx, first install oclif by running npm install -g oclif. But to stay current with the latest updates, you must manually run npm update -g oclif to get new versions of the generator.
Why isn't Node X supported?​
The oclif project follows and supports Node's LTS support schedule, which allows oclif to stay current with Node's development.
How do I pronounce "oclif"?​
We say "oh-cliff".Edit this pageLast updated on Dec 20, 2024 by Mike DonnalleyPreviousFeaturesNextGenerator CommandsWhy Node?How can I create a single binary CLI, like with Go?Should I use TypeScript or JavaScript?What editor is best for oclif?Should I use npm or yarn?How can I make the oclif generator run faster?Why isn't Node X supported?How do I pronounce "oclif"?\n\n\n\nGetting StartedFAQsOn this pageFAQsWhy Node?​
There are a number of reasons why Node is the best choice for writing CLI code. At Salesforce, we've released the Heroku CLI in Ruby, Go, as well as Node. Read this article for details on that history. But in the end, we found that Node offers the best of everything.
First, JavaScript is the biggest language in the world. More people write in JavaScript than in any other programming language, and it has the biggest open-source community, by far. Because everyone can write it, you can find many useful libraries to help build your CLI.
We've also found that Node has the best cross-platform support of any language we've used. In general, if you write code on macOS, you rarely find issues making it also run on Windows.
Node has the best support for our plugins model. Plugins are a way to share code between CLIs, to modularize a CLI's codebase, and to allow users to add functionality to an existing CLI. With Node, we can have separate dependency versions sitting alongside one another. As a result, if you want to release an update to a dependency in one plugin, it doesn't affect how another plugin works. oclif takes this to an extreme so that even flag parsing is done at the individual plugin level. For example, if we ever want to make a breaking change to flag parsing (don't worry, we don't intend to!), you can update just one plugin and keep the old behavior in other plugins. This feature is very helpful for large CLI codebases where you want to migrate to new code slowly.
How can I create a single binary CLI, like with Go?​
Use pkg. Make sure you add the commands and other source files by setting pkg.scripts: "./lib/**/*.js" in package.json.
In Salesforce CLI, however, we prefer to ship a tarball and various installers that have Node baked in. Use oclif pack to create a set of tarballs for different platforms with Node built in. You probably must use @oclif/plugin-update in your CLI, otherwise the users won't have a way to update the CLI from the tarball without reinstalling it.
Should I use TypeScript or JavaScript?​
We suggest you use TypeScript, because we find the typing helpful when refactoring code and updating dependencies. It's nicer to get compilation errors rather than finding errors in production.
We've put a lot of care into making it easy to create a TypeScript CLI, even if you've never written TypeScript before. We generate CLIs and plugins that use ts-node, which makes it fast to run the TypeScript code without a compilation step. And you don't have to mess around with build configuration using oclif.
Still, the two languages are very similar today. The code you write in JavaScript will be nearly identical to what you would have in TypeScript, but with no type definitions of course.
What editor is best for oclif?​
If you already have a favorite editor, go ahead and keep using it. However, we typically recommend Visual Studio Code, or VS Code for short.
Microsoft has done a great job with this editor and it works particularly well for TypeScript projects. You get nice type checking, linting, and autocomplete, right out of the box.
Should I use npm or yarn?​
It doesn't make that much of a difference. If you're just getting started, keep it simple and use npm, which comes with Node. We like to use yarn internally, as it's a bit faster and we find the lockfiles friendlier.
How can I make the oclif generator run faster?​
If you're using npx, first install oclif by running npm install -g oclif. But to stay current with the latest updates, you must manually run npm update -g oclif to get new versions of the generator.
Why isn't Node X supported?​
The oclif project follows and supports Node's LTS support schedule, which allows oclif to stay current with Node's development.
How do I pronounce "oclif"?​
We say "oh-cliff".Edit this pageLast updated on Dec 20, 2024 by Mike Donnalley\n\nGetting StartedFAQsOn this pageFAQsWhy Node?​
There are a number of reasons why Node is the best choice for writing CLI code. At Salesforce, we've released the Heroku CLI in Ruby, Go, as well as Node. Read this article for details on that history. But in the end, we found that Node offers the best of everything.
First, JavaScript is the biggest language in the world. More people write in JavaScript than in any other programming language, and it has the biggest open-source community, by far. Because everyone can write it, you can find many useful libraries to help build your CLI.
We've also found that Node has the best cross-platform support of any language we've used. In general, if you write code on macOS, you rarely find issues making it also run on Windows.
Node has the best support for our plugins model. Plugins are a way to share code between CLIs, to modularize a CLI's codebase, and to allow users to add functionality to an existing CLI. With Node, we can have separate dependency versions sitting alongside one another. As a result, if you want to release an update to a dependency in one plugin, it doesn't affect how another plugin works. oclif takes this to an extreme so that even flag parsing is done at the individual plugin level. For example, if we ever want to make a breaking change to flag parsing (don't worry, we don't intend to!), you can update just one plugin and keep the old behavior in other plugins. This feature is very helpful for large CLI codebases where you want to migrate to new code slowly.
How can I create a single binary CLI, like with Go?​
Use pkg. Make sure you add the commands and other source files by setting pkg.scripts: "./lib/**/*.js" in package.json.
In Salesforce CLI, however, we prefer to ship a tarball and various installers that have Node baked in. Use oclif pack to create a set of tarballs for different platforms with Node built in. You probably must use @oclif/plugin-update in your CLI, otherwise the users won't have a way to update the CLI from the tarball without reinstalling it.
Should I use TypeScript or JavaScript?​
We suggest you use TypeScript, because we find the typing helpful when refactoring code and updating dependencies. It's nicer to get compilation errors rather than finding errors in production.
We've put a lot of care into making it easy to create a TypeScript CLI, even if you've never written TypeScript before. We generate CLIs and plugins that use ts-node, which makes it fast to run the TypeScript code without a compilation step. And you don't have to mess around with build configuration using oclif.
Still, the two languages are very similar today. The code you write in JavaScript will be nearly identical to what you would have in TypeScript, but with no type definitions of course.
What editor is best for oclif?​
If you already have a favorite editor, go ahead and keep using it. However, we typically recommend Visual Studio Code, or VS Code for short.
Microsoft has done a great job with this editor and it works particularly well for TypeScript projects. You get nice type checking, linting, and autocomplete, right out of the box.
Should I use npm or yarn?​
It doesn't make that much of a difference. If you're just getting started, keep it simple and use npm, which comes with Node. We like to use yarn internally, as it's a bit faster and we find the lockfiles friendlier.
How can I make the oclif generator run faster?​
If you're using npx, first install oclif by running npm install -g oclif. But to stay current with the latest updates, you must manually run npm update -g oclif to get new versions of the generator.
Why isn't Node X supported?​
The oclif project follows and supports Node's LTS support schedule, which allows oclif to stay current with Node's development.
How do I pronounce "oclif"?​
We say "oh-cliff".Edit this pageLast updated on Dec 20, 2024 by Mike DonnalleyPreviousFeaturesNextGenerator CommandsWhy Node?How can I create a single binary CLI, like with Go?Should I use TypeScript or JavaScript?What editor is best for oclif?Should I use npm or yarn?How can I make the oclif generator run faster?Why isn't Node X supported?How do I pronounce "oclif"?\n\n\n\nGetting StartedFAQsOn this pageFAQsWhy Node?​
There are a number of reasons why Node is the best choice for writing CLI code. At Salesforce, we've released the Heroku CLI in Ruby, Go, as well as Node. Read this article for details on that history. But in the end, we found that Node offers the best of everything.
First, JavaScript is the biggest language in the world. More people write in JavaScript than in any other programming language, and it has the biggest open-source community, by far. Because everyone can write it, you can find many useful libraries to help build your CLI.
We've also found that Node has the best cross-platform support of any language we've used. In general, if you write code on macOS, you rarely find issues making it also run on Windows.
Node has the best support for our plugins model. Plugins are a way to share code between CLIs, to modularize a CLI's codebase, and to allow users to add functionality to an existing CLI. With Node, we can have separate dependency versions sitting alongside one another. As a result, if you want to release an update to a dependency in one plugin, it doesn't affect how another plugin works. oclif takes this to an extreme so that even flag parsing is done at the individual plugin level. For example, if we ever want to make a breaking change to flag parsing (don't worry, we don't intend to!), you can update just one plugin and keep the old behavior in other plugins. This feature is very helpful for large CLI codebases where you want to migrate to new code slowly.
How can I create a single binary CLI, like with Go?​
Use pkg. Make sure you add the commands and other source files by setting pkg.scripts: "./lib/**/*.js" in package.json.
In Salesforce CLI, however, we prefer to ship a tarball and various installers that have Node baked in. Use oclif pack to create a set of tarballs for different platforms with Node built in. You probably must use @oclif/plugin-update in your CLI, otherwise the users won't have a way to update the CLI from the tarball without reinstalling it.
Should I use TypeScript or JavaScript?​
We suggest you use TypeScript, because we find the typing helpful when refactoring code and updating dependencies. It's nicer to get compilation errors rather than finding errors in production.
We've put a lot of care into making it easy to create a TypeScript CLI, even if you've never written TypeScript before. We generate CLIs and plugins that use ts-node, which makes it fast to run the TypeScript code without a compilation step. And you don't have to mess around with build configuration using oclif.
Still, the two languages are very similar today. The code you write in JavaScript will be nearly identical to what you would have in TypeScript, but with no type definitions of course.
What editor is best for oclif?​
If you already have a favorite editor, go ahead and keep using it. However, we typically recommend Visual Studio Code, or VS Code for short.
Microsoft has done a great job with this editor and it works particularly well for TypeScript projects. You get nice type checking, linting, and autocomplete, right out of the box.
Should I use npm or yarn?​
It doesn't make that much of a difference. If you're just getting started, keep it simple and use npm, which comes with Node. We like to use yarn internally, as it's a bit faster and we find the lockfiles friendlier.
How can I make the oclif generator run faster?​
If you're using npx, first install oclif by running npm install -g oclif. But to stay current with the latest updates, you must manually run npm update -g oclif to get new versions of the generator.
Why isn't Node X supported?​
The oclif project follows and supports Node's LTS support schedule, which allows oclif to stay current with Node's development.
How do I pronounce "oclif"?​
We say "oh-cliff".Edit this pageLast updated on Dec 20, 2024 by Mike Donnalley\n\nGetting StartedFAQsOn this pageFAQsWhy Node?​
There are a number of reasons why Node is the best choice for writing CLI code. At Salesforce, we've released the Heroku CLI in Ruby, Go, as well as Node. Read this article for details on that history. But in the end, we found that Node offers the best of everything.
First, JavaScript is the biggest language in the world. More people write in JavaScript than in any other programming language, and it has the biggest open-source community, by far. Because everyone can write it, you can find many useful libraries to help build your CLI.
We've also found that Node has the best cross-platform support of any language we've used. In general, if you write code on macOS, you rarely find issues making it also run on Windows.
Node has the best support for our plugins model. Plugins are a way to share code between CLIs, to modularize a CLI's codebase, and to allow users to add functionality to an existing CLI. With Node, we can have separate dependency versions sitting alongside one another. As a result, if you want to release an update to a dependency in one plugin, it doesn't affect how another plugin works. oclif takes this to an extreme so that even flag parsing is done at the individual plugin level. For example, if we ever want to make a breaking change to flag parsing (don't worry, we don't intend to!), you can update just one plugin and keep the old behavior in other plugins. This feature is very helpful for large CLI codebases where you want to migrate to new code slowly.
How can I create a single binary CLI, like with Go?​
Use pkg. Make sure you add the commands and other source files by setting pkg.scripts: "./lib/**/*.js" in package.json.
In Salesforce CLI, however, we prefer to ship a tarball and various installers that have Node baked in. Use oclif pack to create a set of tarballs for different platforms with Node built in. You probably must use @oclif/plugin-update in your CLI, otherwise the users won't have a way to update the CLI from the tarball without reinstalling it.
Should I use TypeScript or JavaScript?​
We suggest you use TypeScript, because we find the typing helpful when refactoring code and updating dependencies. It's nicer to get compilation errors rather than finding errors in production.
We've put a lot of care into making it easy to create a TypeScript CLI, even if you've never written TypeScript before. We generate CLIs and plugins that use ts-node, which makes it fast to run the TypeScript code without a compilation step. And you don't have to mess around with build configuration using oclif.
Still, the two languages are very similar today. The code you write in JavaScript will be nearly identical to what you would have in TypeScript, but with no type definitions of course.
What editor is best for oclif?​
If you already have a favorite editor, go ahead and keep using it. However, we typically recommend Visual Studio Code, or VS Code for short.
Microsoft has done a great job with this editor and it works particularly well for TypeScript projects. You get nice type checking, linting, and autocomplete, right out of the box.
Should I use npm or yarn?​
It doesn't make that much of a difference. If you're just getting started, keep it simple and use npm, which comes with Node. We like to use yarn internally, as it's a bit faster and we find the lockfiles friendlier.
How can I make the oclif generator run faster?​
If you're using npx, first install oclif by running npm install -g oclif. But to stay current with the latest updates, you must manually run npm update -g oclif to get new versions of the generator.
Why isn't Node X supported?​
The oclif project follows and supports Node's LTS support schedule, which allows oclif to stay current with Node's development.
How do I pronounce "oclif"?​
We say "oh-cliff".Edit this pageLast updated on Dec 20, 2024 by Mike DonnalleyPreviousFeaturesNextGenerator CommandsWhy Node?How can I create a single binary CLI, like with Go?Should I use TypeScript or JavaScript?What editor is best for oclif?Should I use npm or yarn?How can I make the oclif generator run faster?Why isn't Node X supported?How do I pronounce "oclif"?\n\n\n\nGetting StartedFAQsOn this pageFAQsWhy Node?​
There are a number of reasons why Node is the best choice for writing CLI code. At Salesforce, we've released the Heroku CLI in Ruby, Go, as well as Node. Read this article for details on that history. But in the end, we found that Node offers the best of everything.
First, JavaScript is the biggest language in the world. More people write in JavaScript than in any other programming language, and it has the biggest open-source community, by far. Because everyone can write it, you can find many useful libraries to help build your CLI.
We've also found that Node has the best cross-platform support of any language we've used. In general, if you write code on macOS, you rarely find issues making it also run on Windows.
Node has the best support for our plugins model. Plugins are a way to share code between CLIs, to modularize a CLI's codebase, and to allow users to add functionality to an existing CLI. With Node, we can have separate dependency versions sitting alongside one another. As a result, if you want to release an update to a dependency in one plugin, it doesn't affect how another plugin works. oclif takes this to an extreme so that even flag parsing is done at the individual plugin level. For example, if we ever want to make a breaking change to flag parsing (don't worry, we don't intend to!), you can update just one plugin and keep the old behavior in other plugins. This feature is very helpful for large CLI codebases where you want to migrate to new code slowly.
How can I create a single binary CLI, like with Go?​
Use pkg. Make sure you add the commands and other source files by setting pkg.scripts: "./lib/**/*.js" in package.json.
In Salesforce CLI, however, we prefer to ship a tarball and various installers that have Node baked in. Use oclif pack to create a set of tarballs for different platforms with Node built in. You probably must use @oclif/plugin-update in your CLI, otherwise the users won't have a way to update the CLI from the tarball without reinstalling it.
Should I use TypeScript or JavaScript?​
We suggest you use TypeScript, because we find the typing helpful when refactoring code and updating dependencies. It's nicer to get compilation errors rather than finding errors in production.
We've put a lot of care into making it easy to create a TypeScript CLI, even if you've never written TypeScript before. We generate CLIs and plugins that use ts-node, which makes it fast to run the TypeScript code without a compilation step. And you don't have to mess around with build configuration using oclif.
Still, the two languages are very similar today. The code you write in JavaScript will be nearly identical to what you would have in TypeScript, but with no type definitions of course.
What editor is best for oclif?​
If you already have a favorite editor, go ahead and keep using it. However, we typically recommend Visual Studio Code, or VS Code for short.
Microsoft has done a great job with this editor and it works particularly well for TypeScript projects. You get nice type checking, linting, and autocomplete, right out of the box.
Should I use npm or yarn?​
It doesn't make that much of a difference. If you're just getting started, keep it simple and use npm, which comes with Node. We like to use yarn internally, as it's a bit faster and we find the lockfiles friendlier.
How can I make the oclif generator run faster?​
If you're using npx, first install oclif by running npm install -g oclif. But to stay current with the latest updates, you must manually run npm update -g oclif to get new versions of the generator.
Why isn't Node X supported?​
The oclif project follows and supports Node's LTS support schedule, which allows oclif to stay current with Node's development.
How do I pronounce "oclif"?​
We say "oh-cliff".Edit this pageLast updated on Dec 20, 2024 by Mike Donnalley\n\nGetting StartedFAQsOn this pageFAQsWhy Node?​
There are a number of reasons why Node is the best choice for writing CLI code. At Salesforce, we've released the Heroku CLI in Ruby, Go, as well as Node. Read this article for details on that history. But in the end, we found that Node offers the best of everything.
First, JavaScript is the biggest language in the world. More people write in JavaScript than in any other programming language, and it has the biggest open-source community, by far. Because everyone can write it, you can find many useful libraries to help build your CLI.
We've also found that Node has the best cross-platform support of any language we've used. In general, if you write code on macOS, you rarely find issues making it also run on Windows.
Node has the best support for our plugins model. Plugins are a way to share code between CLIs, to modularize a CLI's codebase, and to allow users to add functionality to an existing CLI. With Node, we can have separate dependency versions sitting alongside one another. As a result, if you want to release an update to a dependency in one plugin, it doesn't affect how another plugin works. oclif takes this to an extreme so that even flag parsing is done at the individual plugin level. For example, if we ever want to make a breaking change to flag parsing (don't worry, we don't intend to!), you can update just one plugin and keep the old behavior in other plugins. This feature is very helpful for large CLI codebases where you want to migrate to new code slowly.
How can I create a single binary CLI, like with Go?​
Use pkg. Make sure you add the commands and other source files by setting pkg.scripts: "./lib/**/*.js" in package.json.
In Salesforce CLI, however, we prefer to ship a tarball and various installers that have Node baked in. Use oclif pack to create a set of tarballs for different platforms with Node built in. You probably must use @oclif/plugin-update in your CLI, otherwise the users won't have a way to update the CLI from the tarball without reinstalling it.
Should I use TypeScript or JavaScript?​
We suggest you use TypeScript, because we find the typing helpful when refactoring code and updating dependencies. It's nicer to get compilation errors rather than finding errors in production.
We've put a lot of care into making it easy to create a TypeScript CLI, even if you've never written TypeScript before. We generate CLIs and plugins that use ts-node, which makes it fast to run the TypeScript code without a compilation step. And you don't have to mess around with build configuration using oclif.
Still, the two languages are very similar today. The code you write in JavaScript will be nearly identical to what you would have in TypeScript, but with no type definitions of course.
What editor is best for oclif?​
If you already have a favorite editor, go ahead and keep using it. However, we typically recommend Visual Studio Code, or VS Code for short.
Microsoft has done a great job with this editor and it works particularly well for TypeScript projects. You get nice type checking, linting, and autocomplete, right out of the box.
Should I use npm or yarn?​
It doesn't make that much of a difference. If you're just getting started, keep it simple and use npm, which comes with Node. We like to use yarn internally, as it's a bit faster and we find the lockfiles friendlier.
How can I make the oclif generator run faster?​
If you're using npx, first install oclif by running npm install -g oclif. But to stay current with the latest updates, you must manually run npm update -g oclif to get new versions of the generator.
Why isn't Node X supported?​
The oclif project follows and supports Node's LTS support schedule, which allows oclif to stay current with Node's development.
How do I pronounce "oclif"?​
We say "oh-cliff".Edit this pageLast updated on Dec 20, 2024 by Mike DonnalleyPreviousFeaturesNextGenerator CommandsWhy Node?How can I create a single binary CLI, like with Go?Should I use TypeScript or JavaScript?What editor is best for oclif?Should I use npm or yarn?How can I make the oclif generator run faster?Why isn't Node X supported?How do I pronounce "oclif"?\n\n\n\nGetting StartedFAQsOn this pageFAQsWhy Node?​
There are a number of reasons why Node is the best choice for writing CLI code. At Salesforce, we've released the Heroku CLI in Ruby, Go, as well as Node. Read this article for details on that history. But in the end, we found that Node offers the best of everything.
First, JavaScript is the biggest language in the world. More people write in JavaScript than in any other programming language, and it has the biggest open-source community, by far. Because everyone can write it, you can find many useful libraries to help build your CLI.
We've also found that Node has the best cross-platform support of any language we've used. In general, if you write code on macOS, you rarely find issues making it also run on Windows.
Node has the best support for our plugins model. Plugins are a way to share code between CLIs, to modularize a CLI's codebase, and to allow users to add functionality to an existing CLI. With Node, we can have separate dependency versions sitting alongside one another. As a result, if you want to release an update to a dependency in one plugin, it doesn't affect how another plugin works. oclif takes this to an extreme so that even flag parsing is done at the individual plugin level. For example, if we ever want to make a breaking change to flag parsing (don't worry, we don't intend to!), you can update just one plugin and keep the old behavior in other plugins. This feature is very helpful for large CLI codebases where you want to migrate to new code slowly.
How can I create a single binary CLI, like with Go?​
Use pkg. Make sure you add the commands and other source files by setting pkg.scripts: "./lib/**/*.js" in package.json.
In Salesforce CLI, however, we prefer to ship a tarball and various installers that have Node baked in. Use oclif pack to create a set of tarballs for different platforms with Node built in. You probably must use @oclif/plugin-update in your CLI, otherwise the users won't have a way to update the CLI from the tarball without reinstalling it.
Should I use TypeScript or JavaScript?​
We suggest you use TypeScript, because we find the typing helpful when refactoring code and updating dependencies. It's nicer to get compilation errors rather than finding errors in production.
We've put a lot of care into making it easy to create a TypeScript CLI, even if you've never written TypeScript before. We generate CLIs and plugins that use ts-node, which makes it fast to run the TypeScript code without a compilation step. And you don't have to mess around with build configuration using oclif.
Still, the two languages are very similar today. The code you write in JavaScript will be nearly identical to what you would have in TypeScript, but with no type definitions of course.
What editor is best for oclif?​
If you already have a favorite editor, go ahead and keep using it. However, we typically recommend Visual Studio Code, or VS Code for short.
Microsoft has done a great job with this editor and it works particularly well for TypeScript projects. You get nice type checking, linting, and autocomplete, right out of the box.
Should I use npm or yarn?​
It doesn't make that much of a difference. If you're just getting started, keep it simple and use npm, which comes with Node. We like to use yarn internally, as it's a bit faster and we find the lockfiles friendlier.
How can I make the oclif generator run faster?​
If you're using npx, first install oclif by running npm install -g oclif. But to stay current with the latest updates, you must manually run npm update -g oclif to get new versions of the generator.
Why isn't Node X supported?​
The oclif project follows and supports Node's LTS support schedule, which allows oclif to stay current with Node's development.
How do I pronounce "oclif"?​
We say "oh-cliff".Edit this pageLast updated on Dec 20, 2024 by Mike Donnalley\n\nGetting StartedFAQsOn this pageFAQsWhy Node?​
There are a number of reasons why Node is the best choice for writing CLI code. At Salesforce, we've released the Heroku CLI in Ruby, Go, as well as Node. Read this article for details on that history. But in the end, we found that Node offers the best of everything.
First, JavaScript is the biggest language in the world. More people write in JavaScript than in any other programming language, and it has the biggest open-source community, by far. Because everyone can write it, you can find many useful libraries to help build your CLI.
We've also found that Node has the best cross-platform support of any language we've used. In general, if you write code on macOS, you rarely find issues making it also run on Windows.
Node has the best support for our plugins model. Plugins are a way to share code between CLIs, to modularize a CLI's codebase, and to allow users to add functionality to an existing CLI. With Node, we can have separate dependency versions sitting alongside one another. As a result, if you want to release an update to a dependency in one plugin, it doesn't affect how another plugin works. oclif takes this to an extreme so that even flag parsing is done at the individual plugin level. For example, if we ever want to make a breaking change to flag parsing (don't worry, we don't intend to!), you can update just one plugin and keep the old behavior in other plugins. This feature is very helpful for large CLI codebases where you want to migrate to new code slowly.
How can I create a single binary CLI, like with Go?​
Use pkg. Make sure you add the commands and other source files by setting pkg.scripts: "./lib/**/*.js" in package.json.
In Salesforce CLI, however, we prefer to ship a tarball and various installers that have Node baked in. Use oclif pack to create a set of tarballs for different platforms with Node built in. You probably must use @oclif/plugin-update in your CLI, otherwise the users won't have a way to update the CLI from the tarball without reinstalling it.
Should I use TypeScript or JavaScript?​
We suggest you use TypeScript, because we find the typing helpful when refactoring code and updating dependencies. It's nicer to get compilation errors rather than finding errors in production.
We've put a lot of care into making it easy to create a TypeScript CLI, even if you've never written TypeScript before. We generate CLIs and plugins that use ts-node, which makes it fast to run the TypeScript code without a compilation step. And you don't have to mess around with build configuration using oclif.
Still, the two languages are very similar today. The code you write in JavaScript will be nearly identical to what you would have in TypeScript, but with no type definitions of course.
What editor is best for oclif?​
If you already have a favorite editor, go ahead and keep using it. However, we typically recommend Visual Studio Code, or VS Code for short.
Microsoft has done a great job with this editor and it works particularly well for TypeScript projects. You get nice type checking, linting, and autocomplete, right out of the box.
Should I use npm or yarn?​
It doesn't make that much of a difference. If you're just getting started, keep it simple and use npm, which comes with Node. We like to use yarn internally, as it's a bit faster and we find the lockfiles friendlier.
How can I make the oclif generator run faster?​
If you're using npx, first install oclif by running npm install -g oclif. But to stay current with the latest updates, you must manually run npm update -g oclif to get new versions of the generator.
Why isn't Node X supported?​
The oclif project follows and supports Node's LTS support schedule, which allows oclif to stay current with Node's development.
How do I pronounce "oclif"?​
We say "oh-cliff".Edit this pageLast updated on Dec 20, 2024 by Mike DonnalleyPreviousFeaturesNextGenerator CommandsWhy Node?How can I create a single binary CLI, like with Go?Should I use TypeScript or JavaScript?What editor is best for oclif?Should I use npm or yarn?How can I make the oclif generator run faster?Why isn't Node X supported?How do I pronounce "oclif"?\n\n\n\nGetting StartedFAQsOn this pageFAQsWhy Node?​
There are a number of reasons why Node is the best choice for writing CLI code. At Salesforce, we've released the Heroku CLI in Ruby, Go, as well as Node. Read this article for details on that history. But in the end, we found that Node offers the best of everything.
First, JavaScript is the biggest language in the world. More people write in JavaScript than in any other programming language, and it has the biggest open-source community, by far. Because everyone can write it, you can find many useful libraries to help build your CLI.
We've also found that Node has the best cross-platform support of any language we've used. In general, if you write code on macOS, you rarely find issues making it also run on Windows.
Node has the best support for our plugins model. Plugins are a way to share code between CLIs, to modularize a CLI's codebase, and to allow users to add functionality to an existing CLI. With Node, we can have separate dependency versions sitting alongside one another. As a result, if you want to release an update to a dependency in one plugin, it doesn't affect how another plugin works. oclif takes this to an extreme so that even flag parsing is done at the individual plugin level. For example, if we ever want to make a breaking change to flag parsing (don't worry, we don't intend to!), you can update just one plugin and keep the old behavior in other plugins. This feature is very helpful for large CLI codebases where you want to migrate to new code slowly.
How can I create a single binary CLI, like with Go?​
Use pkg. Make sure you add the commands and other source files by setting pkg.scripts: "./lib/**/*.js" in package.json.
In Salesforce CLI, however, we prefer to ship a tarball and various installers that have Node baked in. Use oclif pack to create a set of tarballs for different platforms with Node built in. You probably must use @oclif/plugin-update in your CLI, otherwise the users won't have a way to update the CLI from the tarball without reinstalling it.
Should I use TypeScript or JavaScript?​
We suggest you use TypeScript, because we find the typing helpful when refactoring code and updating dependencies. It's nicer to get compilation errors rather than finding errors in production.
We've put a lot of care into making it easy to create a TypeScript CLI, even if you've never written TypeScript before. We generate CLIs and plugins that use ts-node, which makes it fast to run the TypeScript code without a compilation step. And you don't have to mess around with build configuration using oclif.
Still, the two languages are very similar today. The code you write in JavaScript will be nearly identical to what you would have in TypeScript, but with no type definitions of course.
What editor is best for oclif?​
If you already have a favorite editor, go ahead and keep using it. However, we typically recommend Visual Studio Code, or VS Code for short.
Microsoft has done a great job with this editor and it works particularly well for TypeScript projects. You get nice type checking, linting, and autocomplete, right out of the box.
Should I use npm or yarn?​
It doesn't make that much of a difference. If you're just getting started, keep it simple and use npm, which comes with Node. We like to use yarn internally, as it's a bit faster and we find the lockfiles friendlier.
How can I make the oclif generator run faster?​
If you're using npx, first install oclif by running npm install -g oclif. But to stay current with the latest updates, you must manually run npm update -g oclif to get new versions of the generator.
Why isn't Node X supported?​
The oclif project follows and supports Node's LTS support schedule, which allows oclif to stay current with Node's development.
How do I pronounce "oclif"?​
We say "oh-cliff".Edit this pageLast updated on Dec 20, 2024 by Mike Donnalley\n\nGetting StartedFAQsOn this pageFAQsWhy Node?​
There are a number of reasons why Node is the best choice for writing CLI code. At Salesforce, we've released the Heroku CLI in Ruby, Go, as well as Node. Read this article for details on that history. But in the end, we found that Node offers the best of everything.
First, JavaScript is the biggest language in the world. More people write in JavaScript than in any other programming language, and it has the biggest open-source community, by far. Because everyone can write it, you can find many useful libraries to help build your CLI.
We've also found that Node has the best cross-platform support of any language we've used. In general, if you write code on macOS, you rarely find issues making it also run on Windows.
Node has the best support for our plugins model. Plugins are a way to share code between CLIs, to modularize a CLI's codebase, and to allow users to add functionality to an existing CLI. With Node, we can have separate dependency versions sitting alongside one another. As a result, if you want to release an update to a dependency in one plugin, it doesn't affect how another plugin works. oclif takes this to an extreme so that even flag parsing is done at the individual plugin level. For example, if we ever want to make a breaking change to flag parsing (don't worry, we don't intend to!), you can update just one plugin and keep the old behavior in other plugins. This feature is very helpful for large CLI codebases where you want to migrate to new code slowly.
How can I create a single binary CLI, like with Go?​
Use pkg. Make sure you add the commands and other source files by setting pkg.scripts: "./lib/**/*.js" in package.json.
In Salesforce CLI, however, we prefer to ship a tarball and various installers that have Node baked in. Use oclif pack to create a set of tarballs for different platforms with Node built in. You probably must use @oclif/plugin-update in your CLI, otherwise the users won't have a way to update the CLI from the tarball without reinstalling it.
Should I use TypeScript or JavaScript?​
We suggest you use TypeScript, because we find the typing helpful when refactoring code and updating dependencies. It's nicer to get compilation errors rather than finding errors in production.
We've put a lot of care into making it easy to create a TypeScript CLI, even if you've never written TypeScript before. We generate CLIs and plugins that use ts-node, which makes it fast to run the TypeScript code without a compilation step. And you don't have to mess around with build configuration using oclif.
Still, the two languages are very similar today. The code you write in JavaScript will be nearly identical to what you would have in TypeScript, but with no type definitions of course.
What editor is best for oclif?​
If you already have a favorite editor, go ahead and keep using it. However, we typically recommend Visual Studio Code, or VS Code for short.
Microsoft has done a great job with this editor and it works particularly well for TypeScript projects. You get nice type checking, linting, and autocomplete, right out of the box.
Should I use npm or yarn?​
It doesn't make that much of a difference. If you're just getting started, keep it simple and use npm, which comes with Node. We like to use yarn internally, as it's a bit faster and we find the lockfiles friendlier.
How can I make the oclif generator run faster?​
If you're using npx, first install oclif by running npm install -g oclif. But to stay current with the latest updates, you must manually run npm update -g oclif to get new versions of the generator.
Why isn't Node X supported?​
The oclif project follows and supports Node's LTS support schedule, which allows oclif to stay current with Node's development.
How do I pronounce "oclif"?​
We say "oh-cliff".Edit this pageLast updated on Dec 20, 2024 by Mike DonnalleyPreviousFeaturesNextGenerator CommandsWhy Node?How can I create a single binary CLI, like with Go?Should I use TypeScript or JavaScript?What editor is best for oclif?Should I use npm or yarn?How can I make the oclif generator run faster?Why isn't Node X supported?How do I pronounce "oclif"?\n\n\n\nGetting StartedFAQsOn this pageFAQsWhy Node?​
There are a number of reasons why Node is the best choice for writing CLI code. At Salesforce, we've released the Heroku CLI in Ruby, Go, as well as Node. Read this article for details on that history. But in the end, we found that Node offers the best of everything.
First, JavaScript is the biggest language in the world. More people write in JavaScript than in any other programming language, and it has the biggest open-source community, by far. Because everyone can write it, you can find many useful libraries to help build your CLI.
We've also found that Node has the best cross-platform support of any language we've used. In general, if you write code on macOS, you rarely find issues making it also run on Windows.
Node has the best support for our plugins model. Plugins are a way to share code between CLIs, to modularize a CLI's codebase, and to allow users to add functionality to an existing CLI. With Node, we can have separate dependency versions sitting alongside one another. As a result, if you want to release an update to a dependency in one plugin, it doesn't affect how another plugin works. oclif takes this to an extreme so that even flag parsing is done at the individual plugin level. For example, if we ever want to make a breaking change to flag parsing (don't worry, we don't intend to!), you can update just one plugin and keep the old behavior in other plugins. This feature is very helpful for large CLI codebases where you want to migrate to new code slowly.
How can I create a single binary CLI, like with Go?​
Use pkg. Make sure you add the commands and other source files by setting pkg.scripts: "./lib/**/*.js" in package.json.
In Salesforce CLI, however, we prefer to ship a tarball and various installers that have Node baked in. Use oclif pack to create a set of tarballs for different platforms with Node built in. You probably must use @oclif/plugin-update in your CLI, otherwise the users won't have a way to update the CLI from the tarball without reinstalling it.
Should I use TypeScript or JavaScript?​
We suggest you use TypeScript, because we find the typing helpful when refactoring code and updating dependencies. It's nicer to get compilation errors rather than finding errors in production.
We've put a lot of care into making it easy to create a TypeScript CLI, even if you've never written TypeScript before. We generate CLIs and plugins that use ts-node, which makes it fast to run the TypeScript code without a compilation step. And you don't have to mess around with build configuration using oclif.
Still, the two languages are very similar today. The code you write in JavaScript will be nearly identical to what you would have in TypeScript, but with no type definitions of course.
What editor is best for oclif?​
If you already have a favorite editor, go ahead and keep using it. However, we typically recommend Visual Studio Code, or VS Code for short.
Microsoft has done a great job with this editor and it works particularly well for TypeScript projects. You get nice type checking, linting, and autocomplete, right out of the box.
Should I use npm or yarn?​
It doesn't make that much of a difference. If you're just getting started, keep it simple and use npm, which comes with Node. We like to use yarn internally, as it's a bit faster and we find the lockfiles friendlier.
How can I make the oclif generator run faster?​
If you're using npx, first install oclif by running npm install -g oclif. But to stay current with the latest updates, you must manually run npm update -g oclif to get new versions of the generator.
Why isn't Node X supported?​
The oclif project follows and supports Node's LTS support schedule, which allows oclif to stay current with Node's development.
How do I pronounce "oclif"?​
We say "oh-cliff".Edit this pageLast updated on Dec 20, 2024 by Mike Donnalley\n\nGetting StartedFAQsOn this pageFAQsWhy Node?​
There are a number of reasons why Node is the best choice for writing CLI code. At Salesforce, we've released the Heroku CLI in Ruby, Go, as well as Node. Read this article for details on that history. But in the end, we found that Node offers the best of everything.
First, JavaScript is the biggest language in the world. More people write in JavaScript than in any other programming language, and it has the biggest open-source community, by far. Because everyone can write it, you can find many useful libraries to help build your CLI.
We've also found that Node has the best cross-platform support of any language we've used. In general, if you write code on macOS, you rarely find issues making it also run on Windows.
Node has the best support for our plugins model. Plugins are a way to share code between CLIs, to modularize a CLI's codebase, and to allow users to add functionality to an existing CLI. With Node, we can have separate dependency versions sitting alongside one another. As a result, if you want to release an update to a dependency in one plugin, it doesn't affect how another plugin works. oclif takes this to an extreme so that even flag parsing is done at the individual plugin level. For example, if we ever want to make a breaking change to flag parsing (don't worry, we don't intend to!), you can update just one plugin and keep the old behavior in other plugins. This feature is very helpful for large CLI codebases where you want to migrate to new code slowly.
How can I create a single binary CLI, like with Go?​
Use pkg. Make sure you add the commands and other source files by setting pkg.scripts: "./lib/**/*.js" in package.json.
In Salesforce CLI, however, we prefer to ship a tarball and various installers that have Node baked in. Use oclif pack to create a set of tarballs for different platforms with Node built in. You probably must use @oclif/plugin-update in your CLI, otherwise the users won't have a way to update the CLI from the tarball without reinstalling it.
Should I use TypeScript or JavaScript?​
We suggest you use TypeScript, because we find the typing helpful when refactoring code and updating dependencies. It's nicer to get compilation errors rather than finding errors in production.
We've put a lot of care into making it easy to create a TypeScript CLI, even if you've never written TypeScript before. We generate CLIs and plugins that use ts-node, which makes it fast to run the TypeScript code without a compilation step. And you don't have to mess around with build configuration using oclif.
Still, the two languages are very similar today. The code you write in JavaScript will be nearly identical to what you would have in TypeScript, but with no type definitions of course.
What editor is best for oclif?​
If you already have a favorite editor, go ahead and keep using it. However, we typically recommend Visual Studio Code, or VS Code for short.
Microsoft has done a great job with this editor and it works particularly well for TypeScript projects. You get nice type checking, linting, and autocomplete, right out of the box.
Should I use npm or yarn?​
It doesn't make that much of a difference. If you're just getting started, keep it simple and use npm, which comes with Node. We like to use yarn internally, as it's a bit faster and we find the lockfiles friendlier.
How can I make the oclif generator run faster?​
If you're using npx, first install oclif by running npm install -g oclif. But to stay current with the latest updates, you must manually run npm update -g oclif to get new versions of the generator.
Why isn't Node X supported?​
The oclif project follows and supports Node's LTS support schedule, which allows oclif to stay current with Node's development.
How do I pronounce "oclif"?​
We say "oh-cliff".Edit this pageLast updated on Dec 20, 2024 by Mike DonnalleyPreviousFeaturesNextGenerator CommandsWhy Node?How can I create a single binary CLI, like with Go?Should I use TypeScript or JavaScript?What editor is best for oclif?Should I use npm or yarn?How can I make the oclif generator run faster?Why isn't Node X supported?How do I pronounce "oclif"?\n\n\n\nGetting StartedFAQsOn this pageFAQsWhy Node?​
There are a number of reasons why Node is the best choice for writing CLI code. At Salesforce, we've released the Heroku CLI in Ruby, Go, as well as Node. Read this article for details on that history. But in the end, we found that Node offers the best of everything.
First, JavaScript is the biggest language in the world. More people write in JavaScript than in any other programming language, and it has the biggest open-source community, by far. Because everyone can write it, you can find many useful libraries to help build your CLI.
We've also found that Node has the best cross-platform support of any language we've used. In general, if you write code on macOS, you rarely find issues making it also run on Windows.
Node has the best support for our plugins model. Plugins are a way to share code between CLIs, to modularize a CLI's codebase, and to allow users to add functionality to an existing CLI. With Node, we can have separate dependency versions sitting alongside one another. As a result, if you want to release an update to a dependency in one plugin, it doesn't affect how another plugin works. oclif takes this to an extreme so that even flag parsing is done at the individual plugin level. For example, if we ever want to make a breaking change to flag parsing (don't worry, we don't intend to!), you can update just one plugin and keep the old behavior in other plugins. This feature is very helpful for large CLI codebases where you want to migrate to new code slowly.
How can I create a single binary CLI, like with Go?​
Use pkg. Make sure you add the commands and other source files by setting pkg.scripts: "./lib/**/*.js" in package.json.
In Salesforce CLI, however, we prefer to ship a tarball and various installers that have Node baked in. Use oclif pack to create a set of tarballs for different platforms with Node built in. You probably must use @oclif/plugin-update in your CLI, otherwise the users won't have a way to update the CLI from the tarball without reinstalling it.
Should I use TypeScript or JavaScript?​
We suggest you use TypeScript, because we find the typing helpful when refactoring code and updating dependencies. It's nicer to get compilation errors rather than finding errors in production.
We've put a lot of care into making it easy to create a TypeScript CLI, even if you've never written TypeScript before. We generate CLIs and plugins that use ts-node, which makes it fast to run the TypeScript code without a compilation step. And you don't have to mess around with build configuration using oclif.
Still, the two languages are very similar today. The code you write in JavaScript will be nearly identical to what you would have in TypeScript, but with no type definitions of course.
What editor is best for oclif?​
If you already have a favorite editor, go ahead and keep using it. However, we typically recommend Visual Studio Code, or VS Code for short.
Microsoft has done a great job with this editor and it works particularly well for TypeScript projects. You get nice type checking, linting, and autocomplete, right out of the box.
Should I use npm or yarn?​
It doesn't make that much of a difference. If you're just getting started, keep it simple and use npm, which comes with Node. We like to use yarn internally, as it's a bit faster and we find the lockfiles friendlier.
How can I make the oclif generator run faster?​
If you're using npx, first install oclif by running npm install -g oclif. But to stay current with the latest updates, you must manually run npm update -g oclif to get new versions of the generator.
Why isn't Node X supported?​
The oclif project follows and supports Node's LTS support schedule, which allows oclif to stay current with Node's development.
How do I pronounce "oclif"?​
We say "oh-cliff".Edit this pageLast updated on Dec 20, 2024 by Mike Donnalley\n\nGetting StartedFAQsOn this pageFAQsWhy Node?​
There are a number of reasons why Node is the best choice for writing CLI code. At Salesforce, we've released the Heroku CLI in Ruby, Go, as well as Node. Read this article for details on that history. But in the end, we found that Node offers the best of everything.
First, JavaScript is the biggest language in the world. More people write in JavaScript than in any other programming language, and it has the biggest open-source community, by far. Because everyone can write it, you can find many useful libraries to help build your CLI.
We've also found that Node has the best cross-platform support of any language we've used. In general, if you write code on macOS, you rarely find issues making it also run on Windows.
Node has the best support for our plugins model. Plugins are a way to share code between CLIs, to modularize a CLI's codebase, and to allow users to add functionality to an existing CLI. With Node, we can have separate dependency versions sitting alongside one another. As a result, if you want to release an update to a dependency in one plugin, it doesn't affect how another plugin works. oclif takes this to an extreme so that even flag parsing is done at the individual plugin level. For example, if we ever want to make a breaking change to flag parsing (don't worry, we don't intend to!), you can update just one plugin and keep the old behavior in other plugins. This feature is very helpful for large CLI codebases where you want to migrate to new code slowly.
How can I create a single binary CLI, like with Go?​
Use pkg. Make sure you add the commands and other source files by setting pkg.scripts: "./lib/**/*.js" in package.json.
In Salesforce CLI, however, we prefer to ship a tarball and various installers that have Node baked in. Use oclif pack to create a set of tarballs for different platforms with Node built in. You probably must use @oclif/plugin-update in your CLI, otherwise the users won't have a way to update the CLI from the tarball without reinstalling it.
Should I use TypeScript or JavaScript?​
We suggest you use TypeScript, because we find the typing helpful when refactoring code and updating dependencies. It's nicer to get compilation errors rather than finding errors in production.
We've put a lot of care into making it easy to create a TypeScript CLI, even if you've never written TypeScript before. We generate CLIs and plugins that use ts-node, which makes it fast to run the TypeScript code without a compilation step. And you don't have to mess around with build configuration using oclif.
Still, the two languages are very similar today. The code you write in JavaScript will be nearly identical to what you would have in TypeScript, but with no type definitions of course.
What editor is best for oclif?​
If you already have a favorite editor, go ahead and keep using it. However, we typically recommend Visual Studio Code, or VS Code for short.
Microsoft has done a great job with this editor and it works particularly well for TypeScript projects. You get nice type checking, linting, and autocomplete, right out of the box.
Should I use npm or yarn?​
It doesn't make that much of a difference. If you're just getting started, keep it simple and use npm, which comes with Node. We like to use yarn internally, as it's a bit faster and we find the lockfiles friendlier.
How can I make the oclif generator run faster?​
If you're using npx, first install oclif by running npm install -g oclif. But to stay current with the latest updates, you must manually run npm update -g oclif to get new versions of the generator.
Why isn't Node X supported?​
The oclif project follows and supports Node's LTS support schedule, which allows oclif to stay current with Node's development.
How do I pronounce "oclif"?​
We say "oh-cliff".Edit this pageLast updated on Dec 20, 2024 by Mike DonnalleyPreviousFeaturesNextGenerator CommandsWhy Node?How can I create a single binary CLI, like with Go?Should I use TypeScript or JavaScript?What editor is best for oclif?Should I use npm or yarn?How can I make the oclif generator run faster?Why isn't Node X supported?How do I pronounce "oclif"?\n\n\n\nGetting StartedGenerator CommandsOn this pageGenerator CommandsUse these commands to generate the scaffoling for a new CLI, a command, or a hook. The scaffolding includes CLI configuration files, scripts, and sample TypeScript files for a simple  hello world command.
Run each command with the --help flag, but without its argument, to see the same information documented below; for example, oclif generate --help.

oclif generate NAME
oclif generate command NAME
oclif generate hook NAME

oclif generate NAME​
Generate a new CLI.
USAGE  $ oclif generate NAME [--author <value>] [--bin <value>] [--description <value>] [--license <value>]    [--module-type CommonJS|ESM] [--name <value>] [--owner <value>] [--package-manager npm|yarn|pnpm] [--repository    <value>] [-d <value>] [-y]ARGUMENTS  NAME  Directory name of new project.FLAGS  -d, --output-dir=<value>        Directory to build the CLI in.  -y, --yes                       Use defaults for all prompts. Individual flags will override defaults.      --author=<value>            Supply answer for prompt: Author      --bin=<value>               Supply answer for prompt: Command bin name the CLI will export      --description=<value>       Supply answer for prompt: Description      --license=<value>           Supply answer for prompt: License      --module-type=<option>      Supply answer for prompt: Select a module type                                  <options: CommonJS|ESM>      --name=<value>              Supply answer for prompt: NPM package name      --owner=<value>             Supply answer for prompt: Who is the GitHub owner of repository                                  (https://github.com/OWNER/repo)      --package-manager=<option>  Supply answer for prompt: Select a package manager                                  <options: npm|yarn|pnpm>      --repository=<value>        Supply answer for prompt: What is the GitHub name of repository                                  (https://github.com/owner/REPO)DESCRIPTION  Generate a new CLI  This will generate a fully functional oclif CLI that you can build on. It will prompt you for all the necessary  information to get started. If you want to skip the prompts, you can pass the --yes flag to accept the defaults for  all prompts. You can also pass individual flags to set specific values for prompts.  Head to oclif.io/docs/introduction to learn more about building CLIs with oclif.EXAMPLES  Generate a new CLI with prompts for all properties    $ oclif generate my-cli  Automatically accept default values for all prompts    $ oclif generate my-cli --yes  Supply answers for specific prompts    $ oclif generate my-cli --module-type CommonJS --author "John Doe"  Supply answers for specific prompts and accept default values for the rest    $ oclif generate my-cli --module-type CommonJS --author "John Doe" --yes
See code: src/commands/generate.ts
oclif generate command NAME​
Add a command to an existing CLI or plugin.
USAGE  $ oclif generate command NAME [--commands-dir <value>] [--force]ARGUMENTS  NAME  name of commandFLAGS  --commands-dir=<value>  [default: src/commands] The directory to create the command in.  --force                 Overwrite existing files.DESCRIPTION  Add a command to an existing CLI or plugin.
See code: src/commands/generate/command.ts
oclif generate hook NAME​
Add a hook to an existing CLI or plugin.
USAGE  $ oclif generate hook NAME [--event <value>] [--force]ARGUMENTS  NAME  Name of hook (snake_case).FLAGS  --event=<value>  [default: init] Event to run hook on.  --force          Overwrite existing files.DESCRIPTION  Add a hook to an existing CLI or plugin.
See code: src/commands/generate/hook.tsEdit this pageLast updated on Dec 20, 2024 by Mike Donnalley\n\nGetting StartedGenerator CommandsOn this pageGenerator CommandsUse these commands to generate the scaffoling for a new CLI, a command, or a hook. The scaffolding includes CLI configuration files, scripts, and sample TypeScript files for a simple  hello world command.
Run each command with the --help flag, but without its argument, to see the same information documented below; for example, oclif generate --help.

oclif generate NAME
oclif generate command NAME
oclif generate hook NAME

oclif generate NAME​
Generate a new CLI.
USAGE  $ oclif generate NAME [--author <value>] [--bin <value>] [--description <value>] [--license <value>]    [--module-type CommonJS|ESM] [--name <value>] [--owner <value>] [--package-manager npm|yarn|pnpm] [--repository    <value>] [-d <value>] [-y]ARGUMENTS  NAME  Directory name of new project.FLAGS  -d, --output-dir=<value>        Directory to build the CLI in.  -y, --yes                       Use defaults for all prompts. Individual flags will override defaults.      --author=<value>            Supply answer for prompt: Author      --bin=<value>               Supply answer for prompt: Command bin name the CLI will export      --description=<value>       Supply answer for prompt: Description      --license=<value>           Supply answer for prompt: License      --module-type=<option>      Supply answer for prompt: Select a module type                                  <options: CommonJS|ESM>      --name=<value>              Supply answer for prompt: NPM package name      --owner=<value>             Supply answer for prompt: Who is the GitHub owner of repository                                  (https://github.com/OWNER/repo)      --package-manager=<option>  Supply answer for prompt: Select a package manager                                  <options: npm|yarn|pnpm>      --repository=<value>        Supply answer for prompt: What is the GitHub name of repository                                  (https://github.com/owner/REPO)DESCRIPTION  Generate a new CLI  This will generate a fully functional oclif CLI that you can build on. It will prompt you for all the necessary  information to get started. If you want to skip the prompts, you can pass the --yes flag to accept the defaults for  all prompts. You can also pass individual flags to set specific values for prompts.  Head to oclif.io/docs/introduction to learn more about building CLIs with oclif.EXAMPLES  Generate a new CLI with prompts for all properties    $ oclif generate my-cli  Automatically accept default values for all prompts    $ oclif generate my-cli --yes  Supply answers for specific prompts    $ oclif generate my-cli --module-type CommonJS --author "John Doe"  Supply answers for specific prompts and accept default values for the rest    $ oclif generate my-cli --module-type CommonJS --author "John Doe" --yes
See code: src/commands/generate.ts
oclif generate command NAME​
Add a command to an existing CLI or plugin.
USAGE  $ oclif generate command NAME [--commands-dir <value>] [--force]ARGUMENTS  NAME  name of commandFLAGS  --commands-dir=<value>  [default: src/commands] The directory to create the command in.  --force                 Overwrite existing files.DESCRIPTION  Add a command to an existing CLI or plugin.
See code: src/commands/generate/command.ts
oclif generate hook NAME​
Add a hook to an existing CLI or plugin.
USAGE  $ oclif generate hook NAME [--event <value>] [--force]ARGUMENTS  NAME  Name of hook (snake_case).FLAGS  --event=<value>  [default: init] Event to run hook on.  --force          Overwrite existing files.DESCRIPTION  Add a hook to an existing CLI or plugin.
See code: src/commands/generate/hook.tsEdit this pageLast updated on Dec 20, 2024 by Mike DonnalleyPreviousFAQsNextTemplatesoclif generate NAMEoclif generate command NAMEoclif generate hook NAME\n\n\n\nGetting StartedGenerator CommandsOn this pageGenerator CommandsUse these commands to generate the scaffoling for a new CLI, a command, or a hook. The scaffolding includes CLI configuration files, scripts, and sample TypeScript files for a simple  hello world command.
Run each command with the --help flag, but without its argument, to see the same information documented below; for example, oclif generate --help.

oclif generate NAME
oclif generate command NAME
oclif generate hook NAME

oclif generate NAME​
Generate a new CLI.
USAGE  $ oclif generate NAME [--author <value>] [--bin <value>] [--description <value>] [--license <value>]    [--module-type CommonJS|ESM] [--name <value>] [--owner <value>] [--package-manager npm|yarn|pnpm] [--repository    <value>] [-d <value>] [-y]ARGUMENTS  NAME  Directory name of new project.FLAGS  -d, --output-dir=<value>        Directory to build the CLI in.  -y, --yes                       Use defaults for all prompts. Individual flags will override defaults.      --author=<value>            Supply answer for prompt: Author      --bin=<value>               Supply answer for prompt: Command bin name the CLI will export      --description=<value>       Supply answer for prompt: Description      --license=<value>           Supply answer for prompt: License      --module-type=<option>      Supply answer for prompt: Select a module type                                  <options: CommonJS|ESM>      --name=<value>              Supply answer for prompt: NPM package name      --owner=<value>             Supply answer for prompt: Who is the GitHub owner of repository                                  (https://github.com/OWNER/repo)      --package-manager=<option>  Supply answer for prompt: Select a package manager                                  <options: npm|yarn|pnpm>      --repository=<value>        Supply answer for prompt: What is the GitHub name of repository                                  (https://github.com/owner/REPO)DESCRIPTION  Generate a new CLI  This will generate a fully functional oclif CLI that you can build on. It will prompt you for all the necessary  information to get started. If you want to skip the prompts, you can pass the --yes flag to accept the defaults for  all prompts. You can also pass individual flags to set specific values for prompts.  Head to oclif.io/docs/introduction to learn more about building CLIs with oclif.EXAMPLES  Generate a new CLI with prompts for all properties    $ oclif generate my-cli  Automatically accept default values for all prompts    $ oclif generate my-cli --yes  Supply answers for specific prompts    $ oclif generate my-cli --module-type CommonJS --author "John Doe"  Supply answers for specific prompts and accept default values for the rest    $ oclif generate my-cli --module-type CommonJS --author "John Doe" --yes
See code: src/commands/generate.ts
oclif generate command NAME​
Add a command to an existing CLI or plugin.
USAGE  $ oclif generate command NAME [--commands-dir <value>] [--force]ARGUMENTS  NAME  name of commandFLAGS  --commands-dir=<value>  [default: src/commands] The directory to create the command in.  --force                 Overwrite existing files.DESCRIPTION  Add a command to an existing CLI or plugin.
See code: src/commands/generate/command.ts
oclif generate hook NAME​
Add a hook to an existing CLI or plugin.
USAGE  $ oclif generate hook NAME [--event <value>] [--force]ARGUMENTS  NAME  Name of hook (snake_case).FLAGS  --event=<value>  [default: init] Event to run hook on.  --force          Overwrite existing files.DESCRIPTION  Add a hook to an existing CLI or plugin.
See code: src/commands/generate/hook.tsEdit this pageLast updated on Dec 20, 2024 by Mike Donnalley\n\nGetting StartedGenerator CommandsOn this pageGenerator CommandsUse these commands to generate the scaffoling for a new CLI, a command, or a hook. The scaffolding includes CLI configuration files, scripts, and sample TypeScript files for a simple  hello world command.
Run each command with the --help flag, but without its argument, to see the same information documented below; for example, oclif generate --help.

oclif generate NAME
oclif generate command NAME
oclif generate hook NAME

oclif generate NAME​
Generate a new CLI.
USAGE  $ oclif generate NAME [--author <value>] [--bin <value>] [--description <value>] [--license <value>]    [--module-type CommonJS|ESM] [--name <value>] [--owner <value>] [--package-manager npm|yarn|pnpm] [--repository    <value>] [-d <value>] [-y]ARGUMENTS  NAME  Directory name of new project.FLAGS  -d, --output-dir=<value>        Directory to build the CLI in.  -y, --yes                       Use defaults for all prompts. Individual flags will override defaults.      --author=<value>            Supply answer for prompt: Author      --bin=<value>               Supply answer for prompt: Command bin name the CLI will export      --description=<value>       Supply answer for prompt: Description      --license=<value>           Supply answer for prompt: License      --module-type=<option>      Supply answer for prompt: Select a module type                                  <options: CommonJS|ESM>      --name=<value>              Supply answer for prompt: NPM package name      --owner=<value>             Supply answer for prompt: Who is the GitHub owner of repository                                  (https://github.com/OWNER/repo)      --package-manager=<option>  Supply answer for prompt: Select a package manager                                  <options: npm|yarn|pnpm>      --repository=<value>        Supply answer for prompt: What is the GitHub name of repository                                  (https://github.com/owner/REPO)DESCRIPTION  Generate a new CLI  This will generate a fully functional oclif CLI that you can build on. It will prompt you for all the necessary  information to get started. If you want to skip the prompts, you can pass the --yes flag to accept the defaults for  all prompts. You can also pass individual flags to set specific values for prompts.  Head to oclif.io/docs/introduction to learn more about building CLIs with oclif.EXAMPLES  Generate a new CLI with prompts for all properties    $ oclif generate my-cli  Automatically accept default values for all prompts    $ oclif generate my-cli --yes  Supply answers for specific prompts    $ oclif generate my-cli --module-type CommonJS --author "John Doe"  Supply answers for specific prompts and accept default values for the rest    $ oclif generate my-cli --module-type CommonJS --author "John Doe" --yes
See code: src/commands/generate.ts
oclif generate command NAME​
Add a command to an existing CLI or plugin.
USAGE  $ oclif generate command NAME [--commands-dir <value>] [--force]ARGUMENTS  NAME  name of commandFLAGS  --commands-dir=<value>  [default: src/commands] The directory to create the command in.  --force                 Overwrite existing files.DESCRIPTION  Add a command to an existing CLI or plugin.
See code: src/commands/generate/command.ts
oclif generate hook NAME​
Add a hook to an existing CLI or plugin.
USAGE  $ oclif generate hook NAME [--event <value>] [--force]ARGUMENTS  NAME  Name of hook (snake_case).FLAGS  --event=<value>  [default: init] Event to run hook on.  --force          Overwrite existing files.DESCRIPTION  Add a hook to an existing CLI or plugin.
See code: src/commands/generate/hook.tsEdit this pageLast updated on Dec 20, 2024 by Mike DonnalleyPreviousFAQsNextTemplatesoclif generate NAMEoclif generate command NAMEoclif generate hook NAME\n\n\n\nGetting StartedGenerator CommandsOn this pageGenerator CommandsUse these commands to generate the scaffoling for a new CLI, a command, or a hook. The scaffolding includes CLI configuration files, scripts, and sample TypeScript files for a simple  hello world command.
Run each command with the --help flag, but without its argument, to see the same information documented below; for example, oclif generate --help.

oclif generate NAME
oclif generate command NAME
oclif generate hook NAME

oclif generate NAME​
Generate a new CLI.
USAGE  $ oclif generate NAME [--author <value>] [--bin <value>] [--description <value>] [--license <value>]    [--module-type CommonJS|ESM] [--name <value>] [--owner <value>] [--package-manager npm|yarn|pnpm] [--repository    <value>] [-d <value>] [-y]ARGUMENTS  NAME  Directory name of new project.FLAGS  -d, --output-dir=<value>        Directory to build the CLI in.  -y, --yes                       Use defaults for all prompts. Individual flags will override defaults.      --author=<value>            Supply answer for prompt: Author      --bin=<value>               Supply answer for prompt: Command bin name the CLI will export      --description=<value>       Supply answer for prompt: Description      --license=<value>           Supply answer for prompt: License      --module-type=<option>      Supply answer for prompt: Select a module type                                  <options: CommonJS|ESM>      --name=<value>              Supply answer for prompt: NPM package name      --owner=<value>             Supply answer for prompt: Who is the GitHub owner of repository                                  (https://github.com/OWNER/repo)      --package-manager=<option>  Supply answer for prompt: Select a package manager                                  <options: npm|yarn|pnpm>      --repository=<value>        Supply answer for prompt: What is the GitHub name of repository                                  (https://github.com/owner/REPO)DESCRIPTION  Generate a new CLI  This will generate a fully functional oclif CLI that you can build on. It will prompt you for all the necessary  information to get started. If you want to skip the prompts, you can pass the --yes flag to accept the defaults for  all prompts. You can also pass individual flags to set specific values for prompts.  Head to oclif.io/docs/introduction to learn more about building CLIs with oclif.EXAMPLES  Generate a new CLI with prompts for all properties    $ oclif generate my-cli  Automatically accept default values for all prompts    $ oclif generate my-cli --yes  Supply answers for specific prompts    $ oclif generate my-cli --module-type CommonJS --author "John Doe"  Supply answers for specific prompts and accept default values for the rest    $ oclif generate my-cli --module-type CommonJS --author "John Doe" --yes
See code: src/commands/generate.ts
oclif generate command NAME​
Add a command to an existing CLI or plugin.
USAGE  $ oclif generate command NAME [--commands-dir <value>] [--force]ARGUMENTS  NAME  name of commandFLAGS  --commands-dir=<value>  [default: src/commands] The directory to create the command in.  --force                 Overwrite existing files.DESCRIPTION  Add a command to an existing CLI or plugin.
See code: src/commands/generate/command.ts
oclif generate hook NAME​
Add a hook to an existing CLI or plugin.
USAGE  $ oclif generate hook NAME [--event <value>] [--force]ARGUMENTS  NAME  Name of hook (snake_case).FLAGS  --event=<value>  [default: init] Event to run hook on.  --force          Overwrite existing files.DESCRIPTION  Add a hook to an existing CLI or plugin.
See code: src/commands/generate/hook.tsEdit this pageLast updated on Dec 20, 2024 by Mike Donnalley\n\nGetting StartedGenerator CommandsOn this pageGenerator CommandsUse these commands to generate the scaffoling for a new CLI, a command, or a hook. The scaffolding includes CLI configuration files, scripts, and sample TypeScript files for a simple  hello world command.
Run each command with the --help flag, but without its argument, to see the same information documented below; for example, oclif generate --help.

oclif generate NAME
oclif generate command NAME
oclif generate hook NAME

oclif generate NAME​
Generate a new CLI.
USAGE  $ oclif generate NAME [--author <value>] [--bin <value>] [--description <value>] [--license <value>]    [--module-type CommonJS|ESM] [--name <value>] [--owner <value>] [--package-manager npm|yarn|pnpm] [--repository    <value>] [-d <value>] [-y]ARGUMENTS  NAME  Directory name of new project.FLAGS  -d, --output-dir=<value>        Directory to build the CLI in.  -y, --yes                       Use defaults for all prompts. Individual flags will override defaults.      --author=<value>            Supply answer for prompt: Author      --bin=<value>               Supply answer for prompt: Command bin name the CLI will export      --description=<value>       Supply answer for prompt: Description      --license=<value>           Supply answer for prompt: License      --module-type=<option>      Supply answer for prompt: Select a module type                                  <options: CommonJS|ESM>      --name=<value>              Supply answer for prompt: NPM package name      --owner=<value>             Supply answer for prompt: Who is the GitHub owner of repository                                  (https://github.com/OWNER/repo)      --package-manager=<option>  Supply answer for prompt: Select a package manager                                  <options: npm|yarn|pnpm>      --repository=<value>        Supply answer for prompt: What is the GitHub name of repository                                  (https://github.com/owner/REPO)DESCRIPTION  Generate a new CLI  This will generate a fully functional oclif CLI that you can build on. It will prompt you for all the necessary  information to get started. If you want to skip the prompts, you can pass the --yes flag to accept the defaults for  all prompts. You can also pass individual flags to set specific values for prompts.  Head to oclif.io/docs/introduction to learn more about building CLIs with oclif.EXAMPLES  Generate a new CLI with prompts for all properties    $ oclif generate my-cli  Automatically accept default values for all prompts    $ oclif generate my-cli --yes  Supply answers for specific prompts    $ oclif generate my-cli --module-type CommonJS --author "John Doe"  Supply answers for specific prompts and accept default values for the rest    $ oclif generate my-cli --module-type CommonJS --author "John Doe" --yes
See code: src/commands/generate.ts
oclif generate command NAME​
Add a command to an existing CLI or plugin.
USAGE  $ oclif generate command NAME [--commands-dir <value>] [--force]ARGUMENTS  NAME  name of commandFLAGS  --commands-dir=<value>  [default: src/commands] The directory to create the command in.  --force                 Overwrite existing files.DESCRIPTION  Add a command to an existing CLI or plugin.
See code: src/commands/generate/command.ts
oclif generate hook NAME​
Add a hook to an existing CLI or plugin.
USAGE  $ oclif generate hook NAME [--event <value>] [--force]ARGUMENTS  NAME  Name of hook (snake_case).FLAGS  --event=<value>  [default: init] Event to run hook on.  --force          Overwrite existing files.DESCRIPTION  Add a hook to an existing CLI or plugin.
See code: src/commands/generate/hook.tsEdit this pageLast updated on Dec 20, 2024 by Mike DonnalleyPreviousFAQsNextTemplatesoclif generate NAMEoclif generate command NAMEoclif generate hook NAME\n\n\n\nGetting StartedGenerator CommandsOn this pageGenerator CommandsUse these commands to generate the scaffoling for a new CLI, a command, or a hook. The scaffolding includes CLI configuration files, scripts, and sample TypeScript files for a simple  hello world command.
Run each command with the --help flag, but without its argument, to see the same information documented below; for example, oclif generate --help.

oclif generate NAME
oclif generate command NAME
oclif generate hook NAME

oclif generate NAME​
Generate a new CLI.
USAGE  $ oclif generate NAME [--author <value>] [--bin <value>] [--description <value>] [--license <value>]    [--module-type CommonJS|ESM] [--name <value>] [--owner <value>] [--package-manager npm|yarn|pnpm] [--repository    <value>] [-d <value>] [-y]ARGUMENTS  NAME  Directory name of new project.FLAGS  -d, --output-dir=<value>        Directory to build the CLI in.  -y, --yes                       Use defaults for all prompts. Individual flags will override defaults.      --author=<value>            Supply answer for prompt: Author      --bin=<value>               Supply answer for prompt: Command bin name the CLI will export      --description=<value>       Supply answer for prompt: Description      --license=<value>           Supply answer for prompt: License      --module-type=<option>      Supply answer for prompt: Select a module type                                  <options: CommonJS|ESM>      --name=<value>              Supply answer for prompt: NPM package name      --owner=<value>             Supply answer for prompt: Who is the GitHub owner of repository                                  (https://github.com/OWNER/repo)      --package-manager=<option>  Supply answer for prompt: Select a package manager                                  <options: npm|yarn|pnpm>      --repository=<value>        Supply answer for prompt: What is the GitHub name of repository                                  (https://github.com/owner/REPO)DESCRIPTION  Generate a new CLI  This will generate a fully functional oclif CLI that you can build on. It will prompt you for all the necessary  information to get started. If you want to skip the prompts, you can pass the --yes flag to accept the defaults for  all prompts. You can also pass individual flags to set specific values for prompts.  Head to oclif.io/docs/introduction to learn more about building CLIs with oclif.EXAMPLES  Generate a new CLI with prompts for all properties    $ oclif generate my-cli  Automatically accept default values for all prompts    $ oclif generate my-cli --yes  Supply answers for specific prompts    $ oclif generate my-cli --module-type CommonJS --author "John Doe"  Supply answers for specific prompts and accept default values for the rest    $ oclif generate my-cli --module-type CommonJS --author "John Doe" --yes
See code: src/commands/generate.ts
oclif generate command NAME​
Add a command to an existing CLI or plugin.
USAGE  $ oclif generate command NAME [--commands-dir <value>] [--force]ARGUMENTS  NAME  name of commandFLAGS  --commands-dir=<value>  [default: src/commands] The directory to create the command in.  --force                 Overwrite existing files.DESCRIPTION  Add a command to an existing CLI or plugin.
See code: src/commands/generate/command.ts
oclif generate hook NAME​
Add a hook to an existing CLI or plugin.
USAGE  $ oclif generate hook NAME [--event <value>] [--force]ARGUMENTS  NAME  Name of hook (snake_case).FLAGS  --event=<value>  [default: init] Event to run hook on.  --force          Overwrite existing files.DESCRIPTION  Add a hook to an existing CLI or plugin.
See code: src/commands/generate/hook.tsEdit this pageLast updated on Dec 20, 2024 by Mike Donnalley\n\nGetting StartedGenerator CommandsOn this pageGenerator CommandsUse these commands to generate the scaffoling for a new CLI, a command, or a hook. The scaffolding includes CLI configuration files, scripts, and sample TypeScript files for a simple  hello world command.
Run each command with the --help flag, but without its argument, to see the same information documented below; for example, oclif generate --help.

oclif generate NAME
oclif generate command NAME
oclif generate hook NAME

oclif generate NAME​
Generate a new CLI.
USAGE  $ oclif generate NAME [--author <value>] [--bin <value>] [--description <value>] [--license <value>]    [--module-type CommonJS|ESM] [--name <value>] [--owner <value>] [--package-manager npm|yarn|pnpm] [--repository    <value>] [-d <value>] [-y]ARGUMENTS  NAME  Directory name of new project.FLAGS  -d, --output-dir=<value>        Directory to build the CLI in.  -y, --yes                       Use defaults for all prompts. Individual flags will override defaults.      --author=<value>            Supply answer for prompt: Author      --bin=<value>               Supply answer for prompt: Command bin name the CLI will export      --description=<value>       Supply answer for prompt: Description      --license=<value>           Supply answer for prompt: License      --module-type=<option>      Supply answer for prompt: Select a module type                                  <options: CommonJS|ESM>      --name=<value>              Supply answer for prompt: NPM package name      --owner=<value>             Supply answer for prompt: Who is the GitHub owner of repository                                  (https://github.com/OWNER/repo)      --package-manager=<option>  Supply answer for prompt: Select a package manager                                  <options: npm|yarn|pnpm>      --repository=<value>        Supply answer for prompt: What is the GitHub name of repository                                  (https://github.com/owner/REPO)DESCRIPTION  Generate a new CLI  This will generate a fully functional oclif CLI that you can build on. It will prompt you for all the necessary  information to get started. If you want to skip the prompts, you can pass the --yes flag to accept the defaults for  all prompts. You can also pass individual flags to set specific values for prompts.  Head to oclif.io/docs/introduction to learn more about building CLIs with oclif.EXAMPLES  Generate a new CLI with prompts for all properties    $ oclif generate my-cli  Automatically accept default values for all prompts    $ oclif generate my-cli --yes  Supply answers for specific prompts    $ oclif generate my-cli --module-type CommonJS --author "John Doe"  Supply answers for specific prompts and accept default values for the rest    $ oclif generate my-cli --module-type CommonJS --author "John Doe" --yes
See code: src/commands/generate.ts
oclif generate command NAME​
Add a command to an existing CLI or plugin.
USAGE  $ oclif generate command NAME [--commands-dir <value>] [--force]ARGUMENTS  NAME  name of commandFLAGS  --commands-dir=<value>  [default: src/commands] The directory to create the command in.  --force                 Overwrite existing files.DESCRIPTION  Add a command to an existing CLI or plugin.
See code: src/commands/generate/command.ts
oclif generate hook NAME​
Add a hook to an existing CLI or plugin.
USAGE  $ oclif generate hook NAME [--event <value>] [--force]ARGUMENTS  NAME  Name of hook (snake_case).FLAGS  --event=<value>  [default: init] Event to run hook on.  --force          Overwrite existing files.DESCRIPTION  Add a hook to an existing CLI or plugin.
See code: src/commands/generate/hook.tsEdit this pageLast updated on Dec 20, 2024 by Mike DonnalleyPreviousFAQsNextTemplatesoclif generate NAMEoclif generate command NAMEoclif generate hook NAME\n\n\n\nGetting StartedTemplatesOn this pageTemplatesWhen you run oclif generate, you're prompted whether you want to use either CommonJS or ESM for your CLI. CommonJS modules were the original way to package JavaScript and TypeScript packages for reuse in Node.js; ESM modules are now the official standard format. Both options produce the same CLI, with the same tsconfig file, bin scripts, sample commands, and so on.
Here's a brief rundown of everything that's included in your newly generated CLI.
Bin Scripts​
The generated CLI project contains 4 bin scripts that you can use for either production or development.

bin/run.js - Run the CLI in production (macOS and Linux)
bin/dev.js - Run the CLI in development (macOS and Linux)
bin/run.cmd - Run the CLI in production (Windows)
bin/dev.cmd - Run the CLI in development (Windows)

The bin entry in your package.json points to the bin/run.js file, which in turn tells npm to use that file when installing the CLI. If you create operating system-specific installers using oclif pack, then the appropriate run script is added to the final installer based on the target operating system.
We encourage you to use the dev scripts for your local development. Doing so causes oclif to auto-transpile your TypeScript at runtime so you don't have to worry about compiling your code before every command execution. The dev scripts also produce more verbose warnings and errors, which makes it easier to figure out what went wrong.
The dev.js script uses ts-node as the Node.js runtime. However, you can use any of the following if you prefer:

TypeScript Execute (tsx)
Bun
node - If you use node and ESM, make sure you're using a loader that allows it to use ESM modules, such as --loader ts-node/esm. See ESM for more information.

For all of these Node.js runtimes, you can point the hashbang (#!) in the dev.js and run.js files to a global installation of the runtime (such as ts-node) or to a locally installed one (node_modules/.bin/ts-node).
Configuration​
The generated CLI also comes with several configuration files that you can easily modify, or even remove, to suit your needs.

.eslintrc.json - Our recommended plugins and settings for eslint.
.eslintignore - Our recommended .eslintignore to go with our recommend eslint configuration.
.mocharc.json - Our recommended settings for mocha.
.prettierrc.json - Our recommended prettier settings - uses @oclif/prettier-config as the base.
tsconfig.json - Our recommended compiler options for TypeScript projects.
package.json - Our recommended scripts, dependencies, and oclif settings.

Example Commands​
The generated CLI project comes with two sample commands that you can use as a base to build your own.

hello - src/commands/hello/index.ts
hello world - src/commands/hello/world.ts

Example Tests​
Test files for each of the sample commands are generated under the tests folder.
These tests use @oclif/test and mocha. However, feel free to set up your tests with any testing utilities that better suit your needs.Edit this pageLast updated on Dec 20, 2024 by Mike Donnalley\n\nGetting StartedTemplatesOn this pageTemplatesWhen you run oclif generate, you're prompted whether you want to use either CommonJS or ESM for your CLI. CommonJS modules were the original way to package JavaScript and TypeScript packages for reuse in Node.js; ESM modules are now the official standard format. Both options produce the same CLI, with the same tsconfig file, bin scripts, sample commands, and so on.
Here's a brief rundown of everything that's included in your newly generated CLI.
Bin Scripts​
The generated CLI project contains 4 bin scripts that you can use for either production or development.

bin/run.js - Run the CLI in production (macOS and Linux)
bin/dev.js - Run the CLI in development (macOS and Linux)
bin/run.cmd - Run the CLI in production (Windows)
bin/dev.cmd - Run the CLI in development (Windows)

The bin entry in your package.json points to the bin/run.js file, which in turn tells npm to use that file when installing the CLI. If you create operating system-specific installers using oclif pack, then the appropriate run script is added to the final installer based on the target operating system.
We encourage you to use the dev scripts for your local development. Doing so causes oclif to auto-transpile your TypeScript at runtime so you don't have to worry about compiling your code before every command execution. The dev scripts also produce more verbose warnings and errors, which makes it easier to figure out what went wrong.
The dev.js script uses ts-node as the Node.js runtime. However, you can use any of the following if you prefer:

TypeScript Execute (tsx)
Bun
node - If you use node and ESM, make sure you're using a loader that allows it to use ESM modules, such as --loader ts-node/esm. See ESM for more information.

For all of these Node.js runtimes, you can point the hashbang (#!) in the dev.js and run.js files to a global installation of the runtime (such as ts-node) or to a locally installed one (node_modules/.bin/ts-node).
Configuration​
The generated CLI also comes with several configuration files that you can easily modify, or even remove, to suit your needs.

.eslintrc.json - Our recommended plugins and settings for eslint.
.eslintignore - Our recommended .eslintignore to go with our recommend eslint configuration.
.mocharc.json - Our recommended settings for mocha.
.prettierrc.json - Our recommended prettier settings - uses @oclif/prettier-config as the base.
tsconfig.json - Our recommended compiler options for TypeScript projects.
package.json - Our recommended scripts, dependencies, and oclif settings.

Example Commands​
The generated CLI project comes with two sample commands that you can use as a base to build your own.

hello - src/commands/hello/index.ts
hello world - src/commands/hello/world.ts

Example Tests​
Test files for each of the sample commands are generated under the tests folder.
These tests use @oclif/test and mocha. However, feel free to set up your tests with any testing utilities that better suit your needs.Edit this pageLast updated on Dec 20, 2024 by Mike DonnalleyPreviousGenerator CommandsNextGuidesBin ScriptsConfigurationExample CommandsExample Tests\n\n\n\nGetting StartedTemplatesOn this pageTemplatesWhen you run oclif generate, you're prompted whether you want to use either CommonJS or ESM for your CLI. CommonJS modules were the original way to package JavaScript and TypeScript packages for reuse in Node.js; ESM modules are now the official standard format. Both options produce the same CLI, with the same tsconfig file, bin scripts, sample commands, and so on.
Here's a brief rundown of everything that's included in your newly generated CLI.
Bin Scripts​
The generated CLI project contains 4 bin scripts that you can use for either production or development.

bin/run.js - Run the CLI in production (macOS and Linux)
bin/dev.js - Run the CLI in development (macOS and Linux)
bin/run.cmd - Run the CLI in production (Windows)
bin/dev.cmd - Run the CLI in development (Windows)

The bin entry in your package.json points to the bin/run.js file, which in turn tells npm to use that file when installing the CLI. If you create operating system-specific installers using oclif pack, then the appropriate run script is added to the final installer based on the target operating system.
We encourage you to use the dev scripts for your local development. Doing so causes oclif to auto-transpile your TypeScript at runtime so you don't have to worry about compiling your code before every command execution. The dev scripts also produce more verbose warnings and errors, which makes it easier to figure out what went wrong.
The dev.js script uses ts-node as the Node.js runtime. However, you can use any of the following if you prefer:

TypeScript Execute (tsx)
Bun
node - If you use node and ESM, make sure you're using a loader that allows it to use ESM modules, such as --loader ts-node/esm. See ESM for more information.

For all of these Node.js runtimes, you can point the hashbang (#!) in the dev.js and run.js files to a global installation of the runtime (such as ts-node) or to a locally installed one (node_modules/.bin/ts-node).
Configuration​
The generated CLI also comes with several configuration files that you can easily modify, or even remove, to suit your needs.

.eslintrc.json - Our recommended plugins and settings for eslint.
.eslintignore - Our recommended .eslintignore to go with our recommend eslint configuration.
.mocharc.json - Our recommended settings for mocha.
.prettierrc.json - Our recommended prettier settings - uses @oclif/prettier-config as the base.
tsconfig.json - Our recommended compiler options for TypeScript projects.
package.json - Our recommended scripts, dependencies, and oclif settings.

Example Commands​
The generated CLI project comes with two sample commands that you can use as a base to build your own.

hello - src/commands/hello/index.ts
hello world - src/commands/hello/world.ts

Example Tests​
Test files for each of the sample commands are generated under the tests folder.
These tests use @oclif/test and mocha. However, feel free to set up your tests with any testing utilities that better suit your needs.Edit this pageLast updated on Dec 20, 2024 by Mike Donnalley\n\nGetting StartedTemplatesOn this pageTemplatesWhen you run oclif generate, you're prompted whether you want to use either CommonJS or ESM for your CLI. CommonJS modules were the original way to package JavaScript and TypeScript packages for reuse in Node.js; ESM modules are now the official standard format. Both options produce the same CLI, with the same tsconfig file, bin scripts, sample commands, and so on.
Here's a brief rundown of everything that's included in your newly generated CLI.
Bin Scripts​
The generated CLI project contains 4 bin scripts that you can use for either production or development.

bin/run.js - Run the CLI in production (macOS and Linux)
bin/dev.js - Run the CLI in development (macOS and Linux)
bin/run.cmd - Run the CLI in production (Windows)
bin/dev.cmd - Run the CLI in development (Windows)

The bin entry in your package.json points to the bin/run.js file, which in turn tells npm to use that file when installing the CLI. If you create operating system-specific installers using oclif pack, then the appropriate run script is added to the final installer based on the target operating system.
We encourage you to use the dev scripts for your local development. Doing so causes oclif to auto-transpile your TypeScript at runtime so you don't have to worry about compiling your code before every command execution. The dev scripts also produce more verbose warnings and errors, which makes it easier to figure out what went wrong.
The dev.js script uses ts-node as the Node.js runtime. However, you can use any of the following if you prefer:

TypeScript Execute (tsx)
Bun
node - If you use node and ESM, make sure you're using a loader that allows it to use ESM modules, such as --loader ts-node/esm. See ESM for more information.

For all of these Node.js runtimes, you can point the hashbang (#!) in the dev.js and run.js files to a global installation of the runtime (such as ts-node) or to a locally installed one (node_modules/.bin/ts-node).
Configuration​
The generated CLI also comes with several configuration files that you can easily modify, or even remove, to suit your needs.

.eslintrc.json - Our recommended plugins and settings for eslint.
.eslintignore - Our recommended .eslintignore to go with our recommend eslint configuration.
.mocharc.json - Our recommended settings for mocha.
.prettierrc.json - Our recommended prettier settings - uses @oclif/prettier-config as the base.
tsconfig.json - Our recommended compiler options for TypeScript projects.
package.json - Our recommended scripts, dependencies, and oclif settings.

Example Commands​
The generated CLI project comes with two sample commands that you can use as a base to build your own.

hello - src/commands/hello/index.ts
hello world - src/commands/hello/world.ts

Example Tests​
Test files for each of the sample commands are generated under the tests folder.
These tests use @oclif/test and mocha. However, feel free to set up your tests with any testing utilities that better suit your needs.Edit this pageLast updated on Dec 20, 2024 by Mike DonnalleyPreviousGenerator CommandsNextGuidesBin ScriptsConfigurationExample CommandsExample Tests\n\n\n\nGetting StartedTemplatesOn this pageTemplatesWhen you run oclif generate, you're prompted whether you want to use either CommonJS or ESM for your CLI. CommonJS modules were the original way to package JavaScript and TypeScript packages for reuse in Node.js; ESM modules are now the official standard format. Both options produce the same CLI, with the same tsconfig file, bin scripts, sample commands, and so on.
Here's a brief rundown of everything that's included in your newly generated CLI.
Bin Scripts​
The generated CLI project contains 4 bin scripts that you can use for either production or development.

bin/run.js - Run the CLI in production (macOS and Linux)
bin/dev.js - Run the CLI in development (macOS and Linux)
bin/run.cmd - Run the CLI in production (Windows)
bin/dev.cmd - Run the CLI in development (Windows)

The bin entry in your package.json points to the bin/run.js file, which in turn tells npm to use that file when installing the CLI. If you create operating system-specific installers using oclif pack, then the appropriate run script is added to the final installer based on the target operating system.
We encourage you to use the dev scripts for your local development. Doing so causes oclif to auto-transpile your TypeScript at runtime so you don't have to worry about compiling your code before every command execution. The dev scripts also produce more verbose warnings and errors, which makes it easier to figure out what went wrong.
The dev.js script uses ts-node as the Node.js runtime. However, you can use any of the following if you prefer:

TypeScript Execute (tsx)
Bun
node - If you use node and ESM, make sure you're using a loader that allows it to use ESM modules, such as --loader ts-node/esm. See ESM for more information.

For all of these Node.js runtimes, you can point the hashbang (#!) in the dev.js and run.js files to a global installation of the runtime (such as ts-node) or to a locally installed one (node_modules/.bin/ts-node).
Configuration​
The generated CLI also comes with several configuration files that you can easily modify, or even remove, to suit your needs.

.eslintrc.json - Our recommended plugins and settings for eslint.
.eslintignore - Our recommended .eslintignore to go with our recommend eslint configuration.
.mocharc.json - Our recommended settings for mocha.
.prettierrc.json - Our recommended prettier settings - uses @oclif/prettier-config as the base.
tsconfig.json - Our recommended compiler options for TypeScript projects.
package.json - Our recommended scripts, dependencies, and oclif settings.

Example Commands​
The generated CLI project comes with two sample commands that you can use as a base to build your own.

hello - src/commands/hello/index.ts
hello world - src/commands/hello/world.ts

Example Tests​
Test files for each of the sample commands are generated under the tests folder.
These tests use @oclif/test and mocha. However, feel free to set up your tests with any testing utilities that better suit your needs.Edit this pageLast updated on Dec 20, 2024 by Mike Donnalley\n\nGetting StartedTemplatesOn this pageTemplatesWhen you run oclif generate, you're prompted whether you want to use either CommonJS or ESM for your CLI. CommonJS modules were the original way to package JavaScript and TypeScript packages for reuse in Node.js; ESM modules are now the official standard format. Both options produce the same CLI, with the same tsconfig file, bin scripts, sample commands, and so on.
Here's a brief rundown of everything that's included in your newly generated CLI.
Bin Scripts​
The generated CLI project contains 4 bin scripts that you can use for either production or development.

bin/run.js - Run the CLI in production (macOS and Linux)
bin/dev.js - Run the CLI in development (macOS and Linux)
bin/run.cmd - Run the CLI in production (Windows)
bin/dev.cmd - Run the CLI in development (Windows)

The bin entry in your package.json points to the bin/run.js file, which in turn tells npm to use that file when installing the CLI. If you create operating system-specific installers using oclif pack, then the appropriate run script is added to the final installer based on the target operating system.
We encourage you to use the dev scripts for your local development. Doing so causes oclif to auto-transpile your TypeScript at runtime so you don't have to worry about compiling your code before every command execution. The dev scripts also produce more verbose warnings and errors, which makes it easier to figure out what went wrong.
The dev.js script uses ts-node as the Node.js runtime. However, you can use any of the following if you prefer:

TypeScript Execute (tsx)
Bun
node - If you use node and ESM, make sure you're using a loader that allows it to use ESM modules, such as --loader ts-node/esm. See ESM for more information.

For all of these Node.js runtimes, you can point the hashbang (#!) in the dev.js and run.js files to a global installation of the runtime (such as ts-node) or to a locally installed one (node_modules/.bin/ts-node).
Configuration​
The generated CLI also comes with several configuration files that you can easily modify, or even remove, to suit your needs.

.eslintrc.json - Our recommended plugins and settings for eslint.
.eslintignore - Our recommended .eslintignore to go with our recommend eslint configuration.
.mocharc.json - Our recommended settings for mocha.
.prettierrc.json - Our recommended prettier settings - uses @oclif/prettier-config as the base.
tsconfig.json - Our recommended compiler options for TypeScript projects.
package.json - Our recommended scripts, dependencies, and oclif settings.

Example Commands​
The generated CLI project comes with two sample commands that you can use as a base to build your own.

hello - src/commands/hello/index.ts
hello world - src/commands/hello/world.ts

Example Tests​
Test files for each of the sample commands are generated under the tests folder.
These tests use @oclif/test and mocha. However, feel free to set up your tests with any testing utilities that better suit your needs.Edit this pageLast updated on Dec 20, 2024 by Mike DonnalleyPreviousGenerator CommandsNextGuidesBin ScriptsConfigurationExample CommandsExample Tests\n\n\n\nGetting StartedTemplatesOn this pageTemplatesWhen you run oclif generate, you're prompted whether you want to use either CommonJS or ESM for your CLI. CommonJS modules were the original way to package JavaScript and TypeScript packages for reuse in Node.js; ESM modules are now the official standard format. Both options produce the same CLI, with the same tsconfig file, bin scripts, sample commands, and so on.
Here's a brief rundown of everything that's included in your newly generated CLI.
Bin Scripts​
The generated CLI project contains 4 bin scripts that you can use for either production or development.

bin/run.js - Run the CLI in production (macOS and Linux)
bin/dev.js - Run the CLI in development (macOS and Linux)
bin/run.cmd - Run the CLI in production (Windows)
bin/dev.cmd - Run the CLI in development (Windows)

The bin entry in your package.json points to the bin/run.js file, which in turn tells npm to use that file when installing the CLI. If you create operating system-specific installers using oclif pack, then the appropriate run script is added to the final installer based on the target operating system.
We encourage you to use the dev scripts for your local development. Doing so causes oclif to auto-transpile your TypeScript at runtime so you don't have to worry about compiling your code before every command execution. The dev scripts also produce more verbose warnings and errors, which makes it easier to figure out what went wrong.
The dev.js script uses ts-node as the Node.js runtime. However, you can use any of the following if you prefer:

TypeScript Execute (tsx)
Bun
node - If you use node and ESM, make sure you're using a loader that allows it to use ESM modules, such as --loader ts-node/esm. See ESM for more information.

For all of these Node.js runtimes, you can point the hashbang (#!) in the dev.js and run.js files to a global installation of the runtime (such as ts-node) or to a locally installed one (node_modules/.bin/ts-node).
Configuration​
The generated CLI also comes with several configuration files that you can easily modify, or even remove, to suit your needs.

.eslintrc.json - Our recommended plugins and settings for eslint.
.eslintignore - Our recommended .eslintignore to go with our recommend eslint configuration.
.mocharc.json - Our recommended settings for mocha.
.prettierrc.json - Our recommended prettier settings - uses @oclif/prettier-config as the base.
tsconfig.json - Our recommended compiler options for TypeScript projects.
package.json - Our recommended scripts, dependencies, and oclif settings.

Example Commands​
The generated CLI project comes with two sample commands that you can use as a base to build your own.

hello - src/commands/hello/index.ts
hello world - src/commands/hello/world.ts

Example Tests​
Test files for each of the sample commands are generated under the tests folder.
These tests use @oclif/test and mocha. However, feel free to set up your tests with any testing utilities that better suit your needs.Edit this pageLast updated on Dec 20, 2024 by Mike Donnalley\n\nGetting StartedTemplatesOn this pageTemplatesWhen you run oclif generate, you're prompted whether you want to use either CommonJS or ESM for your CLI. CommonJS modules were the original way to package JavaScript and TypeScript packages for reuse in Node.js; ESM modules are now the official standard format. Both options produce the same CLI, with the same tsconfig file, bin scripts, sample commands, and so on.
Here's a brief rundown of everything that's included in your newly generated CLI.
Bin Scripts​
The generated CLI project contains 4 bin scripts that you can use for either production or development.

bin/run.js - Run the CLI in production (macOS and Linux)
bin/dev.js - Run the CLI in development (macOS and Linux)
bin/run.cmd - Run the CLI in production (Windows)
bin/dev.cmd - Run the CLI in development (Windows)

The bin entry in your package.json points to the bin/run.js file, which in turn tells npm to use that file when installing the CLI. If you create operating system-specific installers using oclif pack, then the appropriate run script is added to the final installer based on the target operating system.
We encourage you to use the dev scripts for your local development. Doing so causes oclif to auto-transpile your TypeScript at runtime so you don't have to worry about compiling your code before every command execution. The dev scripts also produce more verbose warnings and errors, which makes it easier to figure out what went wrong.
The dev.js script uses ts-node as the Node.js runtime. However, you can use any of the following if you prefer:

TypeScript Execute (tsx)
Bun
node - If you use node and ESM, make sure you're using a loader that allows it to use ESM modules, such as --loader ts-node/esm. See ESM for more information.

For all of these Node.js runtimes, you can point the hashbang (#!) in the dev.js and run.js files to a global installation of the runtime (such as ts-node) or to a locally installed one (node_modules/.bin/ts-node).
Configuration​
The generated CLI also comes with several configuration files that you can easily modify, or even remove, to suit your needs.

.eslintrc.json - Our recommended plugins and settings for eslint.
.eslintignore - Our recommended .eslintignore to go with our recommend eslint configuration.
.mocharc.json - Our recommended settings for mocha.
.prettierrc.json - Our recommended prettier settings - uses @oclif/prettier-config as the base.
tsconfig.json - Our recommended compiler options for TypeScript projects.
package.json - Our recommended scripts, dependencies, and oclif settings.

Example Commands​
The generated CLI project comes with two sample commands that you can use as a base to build your own.

hello - src/commands/hello/index.ts
hello world - src/commands/hello/world.ts

Example Tests​
Test files for each of the sample commands are generated under the tests folder.
These tests use @oclif/test and mocha. However, feel free to set up your tests with any testing utilities that better suit your needs.Edit this pageLast updated on Dec 20, 2024 by Mike DonnalleyPreviousGenerator CommandsNextGuidesBin ScriptsConfigurationExample CommandsExample Tests\n\n\n\n📄️ AliasesDefine aliases for commands, flags, and bins📄️ Custom Base ClassCreate an extendable Command class📄️ Configuring Your CLIAll about configuring oclif📄️ DebuggingHow to access debug logs📄️ Error HandlingCustomize error handling📄️ ESMUsing ESM in oclif📄️ Flag InheritanceHow to share flags📄️ Flexible TaxonomyUnlock new levels of user-friendliness📄️ Just-in-Time Plugin InstallationSupport for just-in-time plugin installation📄️ JSONNative support for `--json` flag📄️ Loggingoclif-generated logging and custom loggers📄️ NSIS Installer CustomizationCustom nsis installer script📄️ ReleaseHow to release your CLI📄️ Running Commands ProgrammaticallyIf you need to run a command from another, or programmatically run a command in another codebase, there are a couple options.📄️ Single Command CLIConfigure CLI to be a single command📄️ TestingHow to test your CLI📄️ ThemesMake help output pretty📄️ User ExperienceProvided user-experience utilities📄️ AliasesDefine aliases for commands, flags, and bins📄️ Custom Base ClassCreate an extendable Command class📄️ Configuring Your CLIAll about configuring oclif📄️ DebuggingHow to access debug logs📄️ Error HandlingCustomize error handling📄️ ESMUsing ESM in oclif📄️ Flag InheritanceHow to share flags📄️ Flexible TaxonomyUnlock new levels of user-friendliness📄️ Just-in-Time Plugin InstallationSupport for just-in-time plugin installation📄️ JSONNative support for `--json` flag📄️ Loggingoclif-generated logging and custom loggers📄️ NSIS Installer CustomizationCustom nsis installer script📄️ ReleaseHow to release your CLI📄️ Running Commands ProgrammaticallyIf you need to run a command from another, or programmatically run a command in another codebase, there are a couple options.📄️ Single Command CLIConfigure CLI to be a single command📄️ TestingHow to test your CLI📄️ ThemesMake help output pretty📄️ User ExperienceProvided user-experience utilities\n\nGuidesGuides📄️ AliasesDefine aliases for commands, flags, and bins📄️ Custom Base ClassCreate an extendable Command class📄️ Configuring Your CLIAll about configuring oclif📄️ DebuggingHow to access debug logs📄️ Error HandlingCustomize error handling📄️ ESMUsing ESM in oclif📄️ Flag InheritanceHow to share flags📄️ Flexible TaxonomyUnlock new levels of user-friendliness📄️ Just-in-Time Plugin InstallationSupport for just-in-time plugin installation📄️ JSONNative support for `--json` flag📄️ Loggingoclif-generated logging and custom loggers📄️ NSIS Installer CustomizationCustom nsis installer script📄️ ReleaseHow to release your CLI📄️ Running Commands ProgrammaticallyIf you need to run a command from another, or programmatically run a command in another codebase, there are a couple options.📄️ Single Command CLIConfigure CLI to be a single command📄️ TestingHow to test your CLI📄️ ThemesMake help output pretty📄️ User ExperienceProvided user-experience utilitiesPreviousTemplatesNextAliases\n\n\n\nGuidesAliasesOn this pageAliasesCommand Aliases​
Aliases let you define a string that maps to a command. This command can be run as mycli config, mycli config:index, or mycli config:list:
import {Command, Flags} from '@oclif/core'export class ConfigIndex extends Command {  static aliases = ['config:index', 'config:list']}
By default, aliases find the "real" command and just work.  If you're providing command aliases for backward compatibility but prefer users to use the "real" command, set deprecateAliases to true to warn users about the correct name
export class ConfigIndex extends Command {  static aliases = ['config:index', 'config:list']  static deprecateAliases = true}
Flag Aliases​
Like command aliases, but on an individual flag.  You can alias the name and short character, and optionally emit warnings when aliased names are used.
export class ConfigIndex extends Command {  static flags = {    'new-name': Flags.boolean({      char: 'c',      aliases: ['old-name', 'o'],      deprecateAliases: true    })  }}
Bin Aliases​
Creating a CLI that responds to different names or "aliases" is easy, simply add a binAliases property to your CLI's oclif property in package.json:
{  "name": "mycli",  "version": "0.0.0",  "description": "My CLI",  "main": "bin/run.js",  "bin": {    "mycli": "./bin/run.js",    "mycli-alias": "./bin/run.js"  },  "oclif": {    "binAliases": ["mycli", "mycli-alias"]  }}
Adding this property allows your CLI to respond to either of those names, and is used during the bundling and building process when shipping your CLI. Note that the bin section was also modified to include both aliases, which is how npm creates bin aliases. To create a unified experience, regardless of the installation method, a CLI author must change both to match. Bin aliases also play nicely with @oclif/plugin-autocomplete, so typing an alias and using autocomplete is the same experience as using the original name.Edit this pageLast updated on Dec 20, 2024 by Mike Donnalley\n\nGuidesAliasesOn this pageAliasesCommand Aliases​
Aliases let you define a string that maps to a command. This command can be run as mycli config, mycli config:index, or mycli config:list:
import {Command, Flags} from '@oclif/core'export class ConfigIndex extends Command {  static aliases = ['config:index', 'config:list']}
By default, aliases find the "real" command and just work.  If you're providing command aliases for backward compatibility but prefer users to use the "real" command, set deprecateAliases to true to warn users about the correct name
export class ConfigIndex extends Command {  static aliases = ['config:index', 'config:list']  static deprecateAliases = true}
Flag Aliases​
Like command aliases, but on an individual flag.  You can alias the name and short character, and optionally emit warnings when aliased names are used.
export class ConfigIndex extends Command {  static flags = {    'new-name': Flags.boolean({      char: 'c',      aliases: ['old-name', 'o'],      deprecateAliases: true    })  }}
Bin Aliases​
Creating a CLI that responds to different names or "aliases" is easy, simply add a binAliases property to your CLI's oclif property in package.json:
{  "name": "mycli",  "version": "0.0.0",  "description": "My CLI",  "main": "bin/run.js",  "bin": {    "mycli": "./bin/run.js",    "mycli-alias": "./bin/run.js"  },  "oclif": {    "binAliases": ["mycli", "mycli-alias"]  }}
Adding this property allows your CLI to respond to either of those names, and is used during the bundling and building process when shipping your CLI. Note that the bin section was also modified to include both aliases, which is how npm creates bin aliases. To create a unified experience, regardless of the installation method, a CLI author must change both to match. Bin aliases also play nicely with @oclif/plugin-autocomplete, so typing an alias and using autocomplete is the same experience as using the original name.Edit this pageLast updated on Dec 20, 2024 by Mike DonnalleyPreviousGuidesNextCustom Base ClassCommand AliasesFlag AliasesBin Aliases\n\n\n\nGuidesDebuggingDebuggingUse the debug for debugging. The CLI uses this module for all of its debugging. If you set the environment variable DEBUG=* it will print all the debug output to the screen.
Depending on your shell you may need to escape this with DEBUG=\*. On Windows you can't set environment variables in line, so you'll need to run set DEBUG=* before running the command.
Edit this pageLast updated on Dec 20, 2024 by Mike Donnalley\n\nGuidesDebuggingDebuggingUse the debug for debugging. The CLI uses this module for all of its debugging. If you set the environment variable DEBUG=* it will print all the debug output to the screen.
Depending on your shell you may need to escape this with DEBUG=\*. On Windows you can't set environment variables in line, so you'll need to run set DEBUG=* before running the command.
Edit this pageLast updated on Dec 20, 2024 by Mike DonnalleyPreviousConfiguring Your CLINextError Handling\n\n\n\nGuidesFlag InheritanceFlag InheritanceThere are some instances where you might want to define a flag once for all of your commands. In this case you can add a base flag to an abstract base Command class. For example,
import { Command, Flags } from '@oclif/core';export abstract class BaseCommand extends Command {  static baseFlags = {    interactive: Flags.boolean({      char: 'i',      description: 'Run command in interactive mode',      // Show this flag under a separate GLOBAL section in help.      helpGroup: 'GLOBAL',    }),  };}
Any command that extends BaseCommand will now have an --interactive flag on it.
If you are going to stack multiple layers of abstract Command classes, then you must spread the baseFlags to ensure that the flags are properly inherited. For example,
import { Command, Flags } from '@oclif/core';export abstract class FirstBaseCommand extends Command {  static baseFlags = {    interactive: Flags.boolean({      char: 'i',      description: 'Run command in interactive mode',      // Show this flag under a separate GLOBAL section in help.      helpGroup: 'GLOBAL',    }),  };}export abstract class SecondBaseCommand extends FirstBaseCommand {  static baseFlags = {    ...FirstBaseCommand.baseFlags,    'log-level': Flags.option({      default: 'info',      description: 'Specify log level',      helpGroup: 'GLOBAL',      options: ['debug', 'warn', 'error', 'info', 'trace'] as const,      summary: 'Specify level for logging.',      char: 'l',    })(),  };}export abstract class ThirdBaseCommand extends SecondBaseCommand {  static baseFlags = {    ...SecondBaseCommand.baseFlags,    verbose: Flags.boolean({      description: 'Show verbose output.',      char: 'v'    })  };}Edit this pageLast updated on Dec 20, 2024 by Mike Donnalley\n\nGuidesFlag InheritanceFlag InheritanceThere are some instances where you might want to define a flag once for all of your commands. In this case you can add a base flag to an abstract base Command class. For example,
import { Command, Flags } from '@oclif/core';export abstract class BaseCommand extends Command {  static baseFlags = {    interactive: Flags.boolean({      char: 'i',      description: 'Run command in interactive mode',      // Show this flag under a separate GLOBAL section in help.      helpGroup: 'GLOBAL',    }),  };}
Any command that extends BaseCommand will now have an --interactive flag on it.
If you are going to stack multiple layers of abstract Command classes, then you must spread the baseFlags to ensure that the flags are properly inherited. For example,
import { Command, Flags } from '@oclif/core';export abstract class FirstBaseCommand extends Command {  static baseFlags = {    interactive: Flags.boolean({      char: 'i',      description: 'Run command in interactive mode',      // Show this flag under a separate GLOBAL section in help.      helpGroup: 'GLOBAL',    }),  };}export abstract class SecondBaseCommand extends FirstBaseCommand {  static baseFlags = {    ...FirstBaseCommand.baseFlags,    'log-level': Flags.option({      default: 'info',      description: 'Specify log level',      helpGroup: 'GLOBAL',      options: ['debug', 'warn', 'error', 'info', 'trace'] as const,      summary: 'Specify level for logging.',      char: 'l',    })(),  };}export abstract class ThirdBaseCommand extends SecondBaseCommand {  static baseFlags = {    ...SecondBaseCommand.baseFlags,    verbose: Flags.boolean({      description: 'Show verbose output.',      char: 'v'    })  };}Edit this pageLast updated on Dec 20, 2024 by Mike DonnalleyPreviousESMNextFlexible Taxonomy\n\n\n\nGuidesJust-in-Time Plugin InstallationJust-in-Time Plugin InstallationSometimes you might want to have a plugin that isn't bundled in your CLI but gets installed the first time it's executed by the user - we call this just-in-time plugin installation, or JIT for short. This can be useful if you need to reduce the package size of your CLI while still allowing users access to all the plugins.
To use this feature you need to:

Add jitPlugins to the oclif section of your package.json

"oclif": {  "jitPlugins": {    "my-plugin": "^1.2.3",    "another-plugin": "^1.2.3",  }}


Ensure that your build process includes generating a manifest using oclif manifest. The manifest will include the information about all the commands owned by JIT plugins which allows users to run --help on those commands without having them installed yet. If the generated manifest doesn't get packed with your CLI, then the feature will not work.


Implement the jit_plugin_not_installed hook.


oclif attempts to be UX-agnostic, meaning that we don't want to impose any particular user experience on you. Any time a user experience is required we utilize hooks so that you can design the exact user experience you want your users to have.
In the case of JIT plugin installation, there are many possible user experiences that you might want - maybe you want to prompt the user for confirmation first, or maybe you want to log a specific message, etc...
Here's an example of how you might implement the hook,
import { Hook, Errors } from '@oclif/core';import confirm from '@inquirer/confirm';const hook: Hook.JitPluginNotInstalled = async function (opts) {  try {    const answer = await confirm({      message: `${opts.command.pluginName} not installed. Would you like to install?`    })    if (answer) {      await opts.config.runCommand('plugins:install', [`${opts.command.pluginName}@${opts.pluginVersion}`]);    }  } catch (error) {    throw new Errors.CLIError(`Could not install ${opts.command.pluginName}`, 'JitPluginInstallError');  }};export default hook;Edit this pageLast updated on Dec 20, 2024 by Mike Donnalley\n\nGuidesJust-in-Time Plugin InstallationJust-in-Time Plugin InstallationSometimes you might want to have a plugin that isn't bundled in your CLI but gets installed the first time it's executed by the user - we call this just-in-time plugin installation, or JIT for short. This can be useful if you need to reduce the package size of your CLI while still allowing users access to all the plugins.
To use this feature you need to:

Add jitPlugins to the oclif section of your package.json

"oclif": {  "jitPlugins": {    "my-plugin": "^1.2.3",    "another-plugin": "^1.2.3",  }}


Ensure that your build process includes generating a manifest using oclif manifest. The manifest will include the information about all the commands owned by JIT plugins which allows users to run --help on those commands without having them installed yet. If the generated manifest doesn't get packed with your CLI, then the feature will not work.


Implement the jit_plugin_not_installed hook.


oclif attempts to be UX-agnostic, meaning that we don't want to impose any particular user experience on you. Any time a user experience is required we utilize hooks so that you can design the exact user experience you want your users to have.
In the case of JIT plugin installation, there are many possible user experiences that you might want - maybe you want to prompt the user for confirmation first, or maybe you want to log a specific message, etc...
Here's an example of how you might implement the hook,
import { Hook, Errors } from '@oclif/core';import confirm from '@inquirer/confirm';const hook: Hook.JitPluginNotInstalled = async function (opts) {  try {    const answer = await confirm({      message: `${opts.command.pluginName} not installed. Would you like to install?`    })    if (answer) {      await opts.config.runCommand('plugins:install', [`${opts.command.pluginName}@${opts.pluginVersion}`]);    }  } catch (error) {    throw new Errors.CLIError(`Could not install ${opts.command.pluginName}`, 'JitPluginInstallError');  }};export default hook;Edit this pageLast updated on Dec 20, 2024 by Mike DonnalleyPreviousFlexible TaxonomyNextJSON\n\n\n\nGuidesLoggingLoggingBy default oclif uses debug to generate debug logs that can be viewed using the DEBUG environment variable. To see all the logs, you can set DEBUG=oclif*.
You can also provide oclif with a custom logger, if you prefer for oclif's logs to be sent to that instead of debug.
This is the interface that your logger must match:
export type Logger = {  debug: (formatter: unknown, ...args: unknown[]) => void  error: (formatter: unknown, ...args: unknown[]) => void  info: (formatter: unknown, ...args: unknown[]) => void  trace: (formatter: unknown, ...args: unknown[]) => void  warn: (formatter: unknown, ...args: unknown[]) => void  child: (namespace: string) => Logger  namespace: string}
And here's an example:
// oclif-logger.tsimport { format } from 'node:util';import { Interfaces } from '@oclif/core';import { Logger } from './my-cli-logger';export const customLogger = (namespace: string): Interfaces.Logger => {  const myLogger = new Logger(namespace);  return {    child: (ns: string, delimiter?: string) => customLogger(`${namespace}${delimiter ?? ':'}${ns}`),    debug: (formatter: unknown, ...args: unknown[]) => myLogger.debug(format(formatter, ...args)),    error: (formatter: unknown, ...args: unknown[]) => myLogger.error(format(formatter, ...args)),    info: (formatter: unknown, ...args: unknown[]) => myLogger.info(format(formatter, ...args)),    trace: (formatter: unknown, ...args: unknown[]) => myLogger.trace(format(formatter, ...args)),    warn: (formatter: unknown, ...args: unknown[]) => myLogger.warn(format(formatter, ...args)),    namespace,  };};export const logger = customLogger('my-cli');
You now need to provide this logger to oclif so that it can use it:
// bin/run.js#!/usr/bin/env nodeasync function main() {  const {execute} = await import('@oclif/core');  const { logger } = await import('../dist/oclif-logger.js');  await oclif.execute({    dir: import.meta.url,    loadOptions: {      root: import.meta.dirname,      logger,    },  });}await main();
You can also provide the logger to Config, in the event that you instantiate Config before calling run or execute
import {Config, run} from '@oclif/core'const config = await config.load({  logger,});await run(process.argv.slice(2), config)Edit this pageLast updated on Dec 20, 2024 by Mike Donnalley\n\nGuidesLoggingLoggingBy default oclif uses debug to generate debug logs that can be viewed using the DEBUG environment variable. To see all the logs, you can set DEBUG=oclif*.
You can also provide oclif with a custom logger, if you prefer for oclif's logs to be sent to that instead of debug.
This is the interface that your logger must match:
export type Logger = {  debug: (formatter: unknown, ...args: unknown[]) => void  error: (formatter: unknown, ...args: unknown[]) => void  info: (formatter: unknown, ...args: unknown[]) => void  trace: (formatter: unknown, ...args: unknown[]) => void  warn: (formatter: unknown, ...args: unknown[]) => void  child: (namespace: string) => Logger  namespace: string}
And here's an example:
// oclif-logger.tsimport { format } from 'node:util';import { Interfaces } from '@oclif/core';import { Logger } from './my-cli-logger';export const customLogger = (namespace: string): Interfaces.Logger => {  const myLogger = new Logger(namespace);  return {    child: (ns: string, delimiter?: string) => customLogger(`${namespace}${delimiter ?? ':'}${ns}`),    debug: (formatter: unknown, ...args: unknown[]) => myLogger.debug(format(formatter, ...args)),    error: (formatter: unknown, ...args: unknown[]) => myLogger.error(format(formatter, ...args)),    info: (formatter: unknown, ...args: unknown[]) => myLogger.info(format(formatter, ...args)),    trace: (formatter: unknown, ...args: unknown[]) => myLogger.trace(format(formatter, ...args)),    warn: (formatter: unknown, ...args: unknown[]) => myLogger.warn(format(formatter, ...args)),    namespace,  };};export const logger = customLogger('my-cli');
You now need to provide this logger to oclif so that it can use it:
// bin/run.js#!/usr/bin/env nodeasync function main() {  const {execute} = await import('@oclif/core');  const { logger } = await import('../dist/oclif-logger.js');  await oclif.execute({    dir: import.meta.url,    loadOptions: {      root: import.meta.dirname,      logger,    },  });}await main();
You can also provide the logger to Config, in the event that you instantiate Config before calling run or execute
import {Config, run} from '@oclif/core'const config = await config.load({  logger,});await run(process.argv.slice(2), config)Edit this pageLast updated on Dec 20, 2024 by Mike DonnalleyPreviousJSONNextNSIS Installer Customization\n\n\n\nGuidesNSIS Installer CustomizationNSIS Installer CustomizationSometimes you need to verify some dependencies, ensure there are no conflicting CLIs installed, or do some other custom logic before installing your CLI. For npm-scenarios, simply specify a preinstall script. But Windows installers don't include this script. You must instead write your own nsis modification to do these checks. See where this custom script gets placed in the installer in the oclif/oclif repo.
See how Salesforce CLI did this to prevent their new major version being installed on top of an older, and incompatible, version. In that package.json, they specified an nsis installer like this:
{  "name": "mycli",  "version": "0.0.0",  "description": "My CLI",  "main": "bin/run.js",  "bin": "./bin/run.js",  "oclif": {    "nsisCustomization": "scripts/nsis.nsi"  }}
And then their custom script was loaded into the installer during the packing phase of the CLI.Edit this pageLast updated on Dec 20, 2024 by Mike Donnalley\n\nGuidesNSIS Installer CustomizationNSIS Installer CustomizationSometimes you need to verify some dependencies, ensure there are no conflicting CLIs installed, or do some other custom logic before installing your CLI. For npm-scenarios, simply specify a preinstall script. But Windows installers don't include this script. You must instead write your own nsis modification to do these checks. See where this custom script gets placed in the installer in the oclif/oclif repo.
See how Salesforce CLI did this to prevent their new major version being installed on top of an older, and incompatible, version. In that package.json, they specified an nsis installer like this:
{  "name": "mycli",  "version": "0.0.0",  "description": "My CLI",  "main": "bin/run.js",  "bin": "./bin/run.js",  "oclif": {    "nsisCustomization": "scripts/nsis.nsi"  }}
And then their custom script was loaded into the installer during the packing phase of the CLI.Edit this pageLast updated on Dec 20, 2024 by Mike DonnalleyPreviousLoggingNextRelease\n\n\n\nGuidesRunning Commands ProgrammaticallyOn this pageRunning Commands ProgrammaticallyIf you need to run a command from another, or programmatically run a command in another codebase, there are a couple options.
First, it is generally a bad idea to run a command directly as the command exports a user interface, not a code interface. It's a design smell that should rarely (if ever) be used. Generally speaking, it's better to break up the code so that it can be called directly rather than as a command. We'll show this better method first.
Sharing code with modules​
For example, suppose you have a config list command that outputs config vars of an app to the terminal.
./src/commands/config/list.ts
export class ConfigList extends Command {  static flags = {    app: Flags.string({required: true})  }  async run() {    const {flags} = await this.parse(ConfigList)    const config = await api.get(`/apps/${flags.app}/config-vars`)    for (let [key, value] of Object.entries(config)) {      this.log(`${key}=${value}`)    }  }}
Then suppose you have another command, config update, that updates the app's configuration and finally displays the new config vars to the terminal.
Since both config list and config update need to display the config vars in the exact same way, you should create a new module, function, or class that's responsible for creating the display.
For example:
./src/commands/config/update.ts
import {displayConfigVars} from '../displayConfigVars'export class ConfigUpdate extends Command {  static flags = {    app: Flags.string({required: true})  }  async run() {    const {flags} = await this.parse(ConfigUpdate)    await this.doUpdate(flags.app)    await displayConfigVars(flags.app)  }}
./src/displayConfigVars.ts
export async function displayConfigVars(app: string) {  const config = await api.get(`/apps/${app}config-vars`)  for (let [key, value] of Object.entries(config)) {    this.log(`${key}=${value}`)  }}
This is the recommended way to share code. This can be extended further by putting shared code into its own npm package.
Calling commands directly​
Still, if you really want to call a command directly, it's easy to do. You have a couple of options.
If you know that the command you want to run is installed in the CLI, you can use this.config.runCommand. For this, we could write our config update command like so:
./src/commands/config/update.ts
export class ConfigUpdate extends Command {  static flags = {    app: Flags.string({required: true})  }  async run() {    const {flags} = await this.parse(ConfigUpdate)    await this.doUpdate(flags.app)    await this.config.runCommand('config:list', ['--global'])  }}
The second option is to import the command directly and execute it directly like so:
./src/commands/config/update.ts
import {ConfigList} from './config/list'export class ConfigUpdate extends Command {  static flags = {    app: Flags.string({required: true})  }  async run() {    const {flags} = await this.parse(ConfigUpdate)    await this.doUpdate(flags.app)    await ConfigList.run(['--global'])  }}
This works because commands have a static .run() method on them that can be used to instantiate the command and run the instance .run() method. It takes in the argv as input to the command.
But, again, we strongly encourage you to avoid these options. It's far better to extract any shared logic out of a Command class.Edit this pageLast updated on Dec 20, 2024 by Mike Donnalley\n\nGuidesRunning Commands ProgrammaticallyOn this pageRunning Commands ProgrammaticallyIf you need to run a command from another, or programmatically run a command in another codebase, there are a couple options.
First, it is generally a bad idea to run a command directly as the command exports a user interface, not a code interface. It's a design smell that should rarely (if ever) be used. Generally speaking, it's better to break up the code so that it can be called directly rather than as a command. We'll show this better method first.
Sharing code with modules​
For example, suppose you have a config list command that outputs config vars of an app to the terminal.
./src/commands/config/list.ts
export class ConfigList extends Command {  static flags = {    app: Flags.string({required: true})  }  async run() {    const {flags} = await this.parse(ConfigList)    const config = await api.get(`/apps/${flags.app}/config-vars`)    for (let [key, value] of Object.entries(config)) {      this.log(`${key}=${value}`)    }  }}
Then suppose you have another command, config update, that updates the app's configuration and finally displays the new config vars to the terminal.
Since both config list and config update need to display the config vars in the exact same way, you should create a new module, function, or class that's responsible for creating the display.
For example:
./src/commands/config/update.ts
import {displayConfigVars} from '../displayConfigVars'export class ConfigUpdate extends Command {  static flags = {    app: Flags.string({required: true})  }  async run() {    const {flags} = await this.parse(ConfigUpdate)    await this.doUpdate(flags.app)    await displayConfigVars(flags.app)  }}
./src/displayConfigVars.ts
export async function displayConfigVars(app: string) {  const config = await api.get(`/apps/${app}config-vars`)  for (let [key, value] of Object.entries(config)) {    this.log(`${key}=${value}`)  }}
This is the recommended way to share code. This can be extended further by putting shared code into its own npm package.
Calling commands directly​
Still, if you really want to call a command directly, it's easy to do. You have a couple of options.
If you know that the command you want to run is installed in the CLI, you can use this.config.runCommand. For this, we could write our config update command like so:
./src/commands/config/update.ts
export class ConfigUpdate extends Command {  static flags = {    app: Flags.string({required: true})  }  async run() {    const {flags} = await this.parse(ConfigUpdate)    await this.doUpdate(flags.app)    await this.config.runCommand('config:list', ['--global'])  }}
The second option is to import the command directly and execute it directly like so:
./src/commands/config/update.ts
import {ConfigList} from './config/list'export class ConfigUpdate extends Command {  static flags = {    app: Flags.string({required: true})  }  async run() {    const {flags} = await this.parse(ConfigUpdate)    await this.doUpdate(flags.app)    await ConfigList.run(['--global'])  }}
This works because commands have a static .run() method on them that can be used to instantiate the command and run the instance .run() method. It takes in the argv as input to the command.
But, again, we strongly encourage you to avoid these options. It's far better to extract any shared logic out of a Command class.Edit this pageLast updated on Dec 20, 2024 by Mike DonnalleyPreviousReleaseNextSingle Command CLISharing code with modulesCalling commands directly\n\n\n\nGuidesSingle Command CLISingle Command CLISometimes you may want your CLI's executable to also be the only command, similar to many bash utilities like ls or cat.
To support this, you will need to put your command logic into src/index.ts and add the following to the oclif section of your package.json:
{  "oclif": {    "commands": {      "strategy": "single",      "target": "./dist/index.js"    }  }}
where ./dist/index.js is a file that exports a Command class. See Command Discovery Strategies for more details.Edit this pageLast updated on Dec 20, 2024 by Mike Donnalley\n\nGuidesSingle Command CLISingle Command CLISometimes you may want your CLI's executable to also be the only command, similar to many bash utilities like ls or cat.
To support this, you will need to put your command logic into src/index.ts and add the following to the oclif section of your package.json:
{  "oclif": {    "commands": {      "strategy": "single",      "target": "./dist/index.js"    }  }}
where ./dist/index.js is a file that exports a Command class. See Command Discovery Strategies for more details.Edit this pageLast updated on Dec 20, 2024 by Mike DonnalleyPreviousRunning Commands ProgrammaticallyNextTesting\n\n\n\nGuidesTestingOn this pageTestingTesting in oclif can be done with any testing framework. You can run commands with MyCommand.run() which returns a promise you can wait on.
There are common tasks however when writing CLI tools. For this, we have @oclif/test, which provides a conventional set of utilities that we find useful for testing oclif CLIs.
Any CLI built with oclif will come preloaded with mocha (our preferred testing framework but you're free to use whatever you prefer) and @oclif/test as well as an example test that should work out of the box with npm test or yarn test.
As an example, let's look at this whoami command which makes an API call to get the current logged in user. If the user is not logged in, it exits with status 100.
src/commands/whoami.ts
import {Command} from '@oclif/core'export class Whoami extends Command {  async run() {    try {      let {body: account} = await this.api.get('/account')      this.log(account.email)    } catch (err) {      if (err.statusCode === 401) {        this.error('not logged in', {exit: 100})      }      throw err    }  }}
Another common tool we like to use in testing oclif CLIs is nock. Install the nock package as a devDependency.
Here is the test code
test/commands/whoami.test.ts
import {runCommand} from '@oclif/test'import {expect} from 'chai'import nock from 'nock'describe('whoami', () => {  it('shows user email when logged in', async () => {    nock('https://api.example.com')      .get('/account')      // user is logged in, return their name      .reply(200, {email: 'jeff@example.com'})    const {stdout} = await runCommand('whoami')    expect(stdout).to.equal('jeff@example.com')  })  it('exits with status 100 when not logged in', async () => {    nock('https://api.example.com')      .get('/account')      // HTTP 401 means the user is not logged in with valid credentials      .reply(401)    const {error} = await runCommand('whoami')    expect(error?.oclif?.exit).to.equal(100)  })})
For more on how to test with oclif, check out the docs for @oclif/test.
Code Coverage​
Code coverage is provided automatically for JavaScript and TypeScript projects via nyc. Just run yarn test and it will show the code coverage. The coverage can optionally be sent to codecov in the CI scripts as well.Edit this pageLast updated on Dec 20, 2024 by Mike Donnalley\n\nGuidesTestingOn this pageTestingTesting in oclif can be done with any testing framework. You can run commands with MyCommand.run() which returns a promise you can wait on.
There are common tasks however when writing CLI tools. For this, we have @oclif/test, which provides a conventional set of utilities that we find useful for testing oclif CLIs.
Any CLI built with oclif will come preloaded with mocha (our preferred testing framework but you're free to use whatever you prefer) and @oclif/test as well as an example test that should work out of the box with npm test or yarn test.
As an example, let's look at this whoami command which makes an API call to get the current logged in user. If the user is not logged in, it exits with status 100.
src/commands/whoami.ts
import {Command} from '@oclif/core'export class Whoami extends Command {  async run() {    try {      let {body: account} = await this.api.get('/account')      this.log(account.email)    } catch (err) {      if (err.statusCode === 401) {        this.error('not logged in', {exit: 100})      }      throw err    }  }}
Another common tool we like to use in testing oclif CLIs is nock. Install the nock package as a devDependency.
Here is the test code
test/commands/whoami.test.ts
import {runCommand} from '@oclif/test'import {expect} from 'chai'import nock from 'nock'describe('whoami', () => {  it('shows user email when logged in', async () => {    nock('https://api.example.com')      .get('/account')      // user is logged in, return their name      .reply(200, {email: 'jeff@example.com'})    const {stdout} = await runCommand('whoami')    expect(stdout).to.equal('jeff@example.com')  })  it('exits with status 100 when not logged in', async () => {    nock('https://api.example.com')      .get('/account')      // HTTP 401 means the user is not logged in with valid credentials      .reply(401)    const {error} = await runCommand('whoami')    expect(error?.oclif?.exit).to.equal(100)  })})
For more on how to test with oclif, check out the docs for @oclif/test.
Code Coverage​
Code coverage is provided automatically for JavaScript and TypeScript projects via nyc. Just run yarn test and it will show the code coverage. The coverage can optionally be sent to codecov in the CI scripts as well.Edit this pageLast updated on Dec 20, 2024 by Mike DonnalleyPreviousSingle Command CLINextThemesCode Coverage\n\n\n\nGuidesThemesOn this pageThemesoclif supports themes that you can ship with your CLI, which users can then override if they choose.
By default, the theme only applies to help and JSON output but you can extend the theme for your own purposes if you want. See Extending Themes section below.
theme.json​
The theme file takes the following shape:
{  "bin": "white",  "command": "cyan",  "commandSummary": "white",  "dollarSign": "white",  "flag": "white",  "flagDefaultValue": "blue",  "flagOptions": "white",  "flagRequired": "red",  "flagSeparator": "white",  "json": {    "brace": "magenta",    "bracket": "magenta",    "colon": "dim",    "comma": "dim",    "key": "yellow",    "string": "green",    "number": "green",    "boolean": "green",    "null": "red"  },  "sectionDescription": "white",  "sectionHeader": "underline",  "topic": "white",  "version": "white"}
Supported Theme Properties​
As mentioned, the theme only applies to help and JSON output by default. The following properties can be used:

alias: the aliases under the ALIASES section
bin: the name of your CLI's executable (e.g. sf, heroku)
command: the command's name
commandSummary: the command's summary
dollarSign: the $ printed before examples and usage
flag: flag names and short characters
flagDefaultValue: the [default: X] shown on flags with a default
flagOptions: the valid options for a flag
flagRequired: the (required) that shows on required flags
flagSeparator: the , that separates the short char and long flag names (e.g. -f, --foo)
json: the theme for JSON output

brace: the [ and ]
bracket: the { and }
colon: the :
comma: the ,
key: all keys
string: string values
number: number values
boolean: boolean values
null : null values


sectionDescription: the text inside of each section (e.g. everything under DESCRIPTION)
sectionHeader: the section header (e.g. DESCRIPTION)
topic: the topics under the TOPICS section
version: the VERSION section that shows under the root help (e.g. sf --help)

The values for each of these must be one of the following:

a hex code, e.g. #FF0000
a rgb, e.g. rgb(255,255,255)
a standard ANSI color (see https://github.com/chalk/chalk/#styles)

Any invalid values will be ignored.
Shipping a Theme​
Shipping a theme with your CLI is very simple.
First you need to create a new theme file (see above) in your CLI. Then, in your package.json, you just need to tell oclif where to find that file:
{  "files": [    "/theme.json",    "/oclif.manifest.json",    "/dist",  ],  "oclif": {    "theme": "theme.json"  }}
It's important that you also add the file to the list of files so that it will be packed with your CLI whenever you publish to npm or when pack your CLI using oclif pack.
Overriding Themes​
If you've shipped a theme with your CLI, users can then override the theme by creating their own theme.json in the config directory of your CLI (~/.config/<CLI> on unix, %LOCALAPPDATA%\<CLI> on windows.)
Users can specify one or all of the theme properties in their own theme.json, meaning that they can choose to only override a single property of the default theme.
Disabling Themes​
Themes can be disabled by using <CLI>_DISABLE_THEME environment variable.
Extending Themes​
By default oclif only uses the theme for the help output but you can use the theme for other purposes if you desire. For instance maybe you'd like to log colorized info: logs to the user during a command:
import {Command, ux} from '@oclif/core'export default class Hello extends Command {  public async run(): Promise<void> {    this.info('starting process!')    // do some stuff...    this.info('still making progress!')    // do some more stuff...    this.info('process complete!')  }  public info(msg: string): void {    this.log(ux.colorize(this.config.theme?.info, 'info:'), msg)  }}Edit this pageLast updated on Dec 20, 2024 by Mike Donnalley\n\nGuidesThemesOn this pageThemesoclif supports themes that you can ship with your CLI, which users can then override if they choose.
By default, the theme only applies to help and JSON output but you can extend the theme for your own purposes if you want. See Extending Themes section below.
theme.json​
The theme file takes the following shape:
{  "bin": "white",  "command": "cyan",  "commandSummary": "white",  "dollarSign": "white",  "flag": "white",  "flagDefaultValue": "blue",  "flagOptions": "white",  "flagRequired": "red",  "flagSeparator": "white",  "json": {    "brace": "magenta",    "bracket": "magenta",    "colon": "dim",    "comma": "dim",    "key": "yellow",    "string": "green",    "number": "green",    "boolean": "green",    "null": "red"  },  "sectionDescription": "white",  "sectionHeader": "underline",  "topic": "white",  "version": "white"}
Supported Theme Properties​
As mentioned, the theme only applies to help and JSON output by default. The following properties can be used:

alias: the aliases under the ALIASES section
bin: the name of your CLI's executable (e.g. sf, heroku)
command: the command's name
commandSummary: the command's summary
dollarSign: the $ printed before examples and usage
flag: flag names and short characters
flagDefaultValue: the [default: X] shown on flags with a default
flagOptions: the valid options for a flag
flagRequired: the (required) that shows on required flags
flagSeparator: the , that separates the short char and long flag names (e.g. -f, --foo)
json: the theme for JSON output

brace: the [ and ]
bracket: the { and }
colon: the :
comma: the ,
key: all keys
string: string values
number: number values
boolean: boolean values
null : null values


sectionDescription: the text inside of each section (e.g. everything under DESCRIPTION)
sectionHeader: the section header (e.g. DESCRIPTION)
topic: the topics under the TOPICS section
version: the VERSION section that shows under the root help (e.g. sf --help)

The values for each of these must be one of the following:

a hex code, e.g. #FF0000
a rgb, e.g. rgb(255,255,255)
a standard ANSI color (see https://github.com/chalk/chalk/#styles)

Any invalid values will be ignored.
Shipping a Theme​
Shipping a theme with your CLI is very simple.
First you need to create a new theme file (see above) in your CLI. Then, in your package.json, you just need to tell oclif where to find that file:
{  "files": [    "/theme.json",    "/oclif.manifest.json",    "/dist",  ],  "oclif": {    "theme": "theme.json"  }}
It's important that you also add the file to the list of files so that it will be packed with your CLI whenever you publish to npm or when pack your CLI using oclif pack.
Overriding Themes​
If you've shipped a theme with your CLI, users can then override the theme by creating their own theme.json in the config directory of your CLI (~/.config/<CLI> on unix, %LOCALAPPDATA%\<CLI> on windows.)
Users can specify one or all of the theme properties in their own theme.json, meaning that they can choose to only override a single property of the default theme.
Disabling Themes​
Themes can be disabled by using <CLI>_DISABLE_THEME environment variable.
Extending Themes​
By default oclif only uses the theme for the help output but you can use the theme for other purposes if you desire. For instance maybe you'd like to log colorized info: logs to the user during a command:
import {Command, ux} from '@oclif/core'export default class Hello extends Command {  public async run(): Promise<void> {    this.info('starting process!')    // do some stuff...    this.info('still making progress!')    // do some more stuff...    this.info('process complete!')  }  public info(msg: string): void {    this.log(ux.colorize(this.config.theme?.info, 'info:'), msg)  }}Edit this pageLast updated on Dec 20, 2024 by Mike DonnalleyPreviousTestingNextUser Experiencetheme.jsonSupported Theme PropertiesShipping a ThemeOverriding ThemesDisabling ThemesExtending Themes\n\n\n\nArchitectureCommand ExecutionCommand ExecutionBelow is a diagram that outlines at a high level the process that occurs every time a user executes an oclif command.
Edit this pageLast updated on Dec 20, 2024 by Mike Donnalley\n\nArchitectureCommand ExecutionCommand ExecutionBelow is a diagram that outlines at a high level the process that occurs every time a user executes an oclif command.
Edit this pageLast updated on Dec 20, 2024 by Mike DonnalleyPreviousPerformanceNextPlugin Loading\n\n\n\nArchitecturePlugin LoadingOn this pagePlugin LoadingBelow is a diagram that outlines how a plugin is loaded into the CLI.
There are a couple of important takeaways from this diagram:
Plugin Resolution Order​
Plugins are resolved in the following order:

User plugins (i.e. plugins installed by the users)
Dev plugins (i.e. plugins listed under devPlugins)
Core plugins (i.e. plugins listed under plugins)

Manifests Improve Performance​
When loading a plugin, oclif needs to require each command file in order to get the static properties of the command - the description, examples, flags, etc...
However, oclif can skip this step if the plugin has an oclif.manifest.json (generated by oclif manifest). The manifest caches all of these properties so that there's no need to require every single command on every command execution.
Plugin Loading Diagram​
Edit this pageLast updated on Dec 20, 2024 by Mike Donnalley\n\nArchitecturePlugin LoadingOn this pagePlugin LoadingBelow is a diagram that outlines how a plugin is loaded into the CLI.
There are a couple of important takeaways from this diagram:
Plugin Resolution Order​
Plugins are resolved in the following order:

User plugins (i.e. plugins installed by the users)
Dev plugins (i.e. plugins listed under devPlugins)
Core plugins (i.e. plugins listed under plugins)

Manifests Improve Performance​
When loading a plugin, oclif needs to require each command file in order to get the static properties of the command - the description, examples, flags, etc...
However, oclif can skip this step if the plugin has an oclif.manifest.json (generated by oclif manifest). The manifest caches all of these properties so that there's no need to require every single command on every command execution.
Plugin Loading Diagram​
Edit this pageLast updated on Dec 20, 2024 by Mike DonnalleyPreviousCommand ExecutionNextExamplesPlugin Resolution OrderManifests Improve PerformancePlugin Loading Diagram\n\n\n\nAlso SeeExamplesExamplesHere are some examples to get an idea of how to use oclif in various setups.

CommonJS plugin
ESM plugin
Using esbuild
Hook-only plugin
Edit this pageLast updated on Dec 20, 2024 by Mike Donnalley\n\nAlso SeeExamplesExamplesHere are some examples to get an idea of how to use oclif in various setups.

CommonJS plugin
ESM plugin
Using esbuild
Hook-only plugin
Edit this pageLast updated on Dec 20, 2024 by Mike DonnalleyPreviousPlugin LoadingNextExternal Links\n\n\n\nAlso SeeExternal LinksExternal Links
Salesforce Release Announcement
Heroku Release Announcement
Edit this pageLast updated on Dec 20, 2024 by Mike Donnalley\n\nAlso SeeExternal LinksExternal Links
Salesforce Release Announcement
Heroku Release Announcement
Edit this pageLast updated on Dec 20, 2024 by Mike DonnalleyPreviousExamplesNextRelated Repositories\n\n\n\nAlso SeeRelated RepositoriesRelated Repositories
oclif - oclif CLI
@oclif/core - Base library for oclif CLIs or plugins. This can be used directly without the generator.
@oclif/test - Test helper for oclif.
oclif.github.io - oclif.io documentation
Edit this pageLast updated on Dec 20, 2024 by Mike Donnalley\n\nAlso SeeRelated RepositoriesRelated Repositories
oclif - oclif CLI
@oclif/core - Base library for oclif CLIs or plugins. This can be used directly without the generator.
@oclif/test - Test helper for oclif.
oclif.github.io - oclif.io documentation
Edit this pageLast updated on Dec 20, 2024 by Mike DonnalleyPreviousExternal LinksNextHow We Work\n\n\n\nAlso SeeHow We WorkOn this pageHow We Workoclif is an open-source project built and maintained by Salesforce and an essential component of Salesforce's developer experiences, powering millions of users' CLIs a day via the Salesforce CLI, the Heroku CLI and others.
As an open-source project, oclif repos live on GitHub and are published to npmjs.com.
Code of Conduct & Community Guidelines​
We are thrilled to offer oclif as open-source. As such, please review our project Code of Conduct. If you have any questions or concerns, please contact us.
Issues​
Issues are made in their corresponding repo as appropriate. If you are unsure which repo an issue might belong to, make an issue in the oclif repo.
We triage issues as we can, usually with a week of when it was created (unfortunately, we can make no commitment to when an issue will be triaged).
An issue will be considered stale after a month has passed with no further feedback or input from the author after input from an oclif team member. Stale issues will be notified with a comment of its stale state and any actions needed to take to keep it alive.
An issue will be closed if:

It has been fixed via a PR
Has a “wont-fix”, “invalid” or “duplicate” label
A week has passed after a stale issue notification has been posted with no further feedback or input from the author

Pull Requests​
We review repo PRs as we can, usually with two weeks of when it was created (unfortunately, we can make no commitment to when a PR will be reviewed).
PRs reviewers may seek additional changes or clarifying input from the author as appropriate.
Note: It is often more conducive to first open an issue and solicit feedback on possible solutions for your PR. We hate to see PR’s we don’t end up accepting and this helps to avoid that!
A PR will be considered stale after a month has passed with no further feedback or input from the author after input from an oclif team member. Stale PRs will be notified with a comment of its stale state and any actions needed to take to keep it alive.
A PR will be closed if:

It has been merged
After a dialogue with the author informing them why the PR cannot be accepted
A week has passed after a stale PR notification has been posted with no further feedback or input from the author

Blog Posts​
We aim to announce most features via our blog. Be sure to check back regularly to see new announcements!
Feedback​
See our Feedback page.
Updates to How We Work​
Please check back periodically to review any updates to this page.Edit this pageLast updated on Dec 20, 2024 by Mike Donnalley\n\nAlso SeeHow We WorkOn this pageHow We Workoclif is an open-source project built and maintained by Salesforce and an essential component of Salesforce's developer experiences, powering millions of users' CLIs a day via the Salesforce CLI, the Heroku CLI and others.
As an open-source project, oclif repos live on GitHub and are published to npmjs.com.
Code of Conduct & Community Guidelines​
We are thrilled to offer oclif as open-source. As such, please review our project Code of Conduct. If you have any questions or concerns, please contact us.
Issues​
Issues are made in their corresponding repo as appropriate. If you are unsure which repo an issue might belong to, make an issue in the oclif repo.
We triage issues as we can, usually with a week of when it was created (unfortunately, we can make no commitment to when an issue will be triaged).
An issue will be considered stale after a month has passed with no further feedback or input from the author after input from an oclif team member. Stale issues will be notified with a comment of its stale state and any actions needed to take to keep it alive.
An issue will be closed if:

It has been fixed via a PR
Has a “wont-fix”, “invalid” or “duplicate” label
A week has passed after a stale issue notification has been posted with no further feedback or input from the author

Pull Requests​
We review repo PRs as we can, usually with two weeks of when it was created (unfortunately, we can make no commitment to when a PR will be reviewed).
PRs reviewers may seek additional changes or clarifying input from the author as appropriate.
Note: It is often more conducive to first open an issue and solicit feedback on possible solutions for your PR. We hate to see PR’s we don’t end up accepting and this helps to avoid that!
A PR will be considered stale after a month has passed with no further feedback or input from the author after input from an oclif team member. Stale PRs will be notified with a comment of its stale state and any actions needed to take to keep it alive.
A PR will be closed if:

It has been merged
After a dialogue with the author informing them why the PR cannot be accepted
A week has passed after a stale PR notification has been posted with no further feedback or input from the author

Blog Posts​
We aim to announce most features via our blog. Be sure to check back regularly to see new announcements!
Feedback​
See our Feedback page.
Updates to How We Work​
Please check back periodically to review any updates to this page.Edit this pageLast updated on Dec 20, 2024 by Mike DonnalleyPreviousRelated RepositoriesNextFeedbackCode of Conduct & Community GuidelinesIssuesPull RequestsBlog PostsFeedbackUpdates to How We Work\n\n\n\nAlso SeeFeedbackFeedbackIf you have any suggestions or just want to let us know what you think of oclif, send us a message at alm-cli@salesforce.com or file an issue in our repos.Edit this pageLast updated on Dec 20, 2024 by Mike Donnalley\n\nAlso SeeFeedbackFeedbackIf you have any suggestions or just want to let us know what you think of oclif, send us a message at alm-cli@salesforce.com or file an issue in our repos.Edit this pageLast updated on Dec 20, 2024 by Mike DonnalleyPreviousHow We Work\n\n\n\nGuidesConfiguring Your CLIOn this pageConfiguring Your CLIYou can configure the behavior of oclif inside your CLI or plugin's package.json or using an rc file.
If you use the package.json, all of the configuration options should be placed under the oclif section. For example:
{  "name": "my-cli",  "version": "1.2.3",  "dependencies": {    "@oclif/core": "^3"  },  "oclif": {    "bin": "mycli",    "dirname": "mycli",    "commands": "./dist/commands",    "topicSeparator": " "  }}
If you'd like to use an rc file, then you do not need to put the configuration under oclif. For instance:
//.oclifrc.jsmodule.exports = {  bin: "mycli",  dirname: "mycli",  commands: "./dist/commands",  topicSeparator: " "}
The following rc files are supported:
.oclifrc.oclifrc.json.oclifrc.js.oclifrc.mjs.oclifrc.cjsoclif.config.jsoclif.config.mjsoclif.config.cjs
Here's a list of all the options that you can configure.
PropertyDescriptionadditionalHelpFlagsArray of flags that should trigger help output in addition to --helpadditionalVersionFlagsArray of flags that should trigger version output in addition to --versionaliasesAliases for the plugin. This is used to support legacy plugins that have been renamedbinCLI bin name (e.g. sf, heroku, git, etc...)binAliasesAn array of strings that will all execute the CLI's bin. See Aliases for moredirnameDirectory name to use when determining CLI's config, cache, and data directories.commandsWhere oclif can find command classes. See Command Discovery Strategies for moredescriptionDescription of your plugin or CLI to show in helpdevPluginsList of plugins that will only be loaded in development. See Plugins for moreexitCodesConfigured exit codes. See Exit Codes section belowflexibleTaxonomySet to true to enable flexible taxonomyhelpClassLocation of compiled custom help classhelpOptionsSettings for configuring behavior of help output. See Help Options section belowhooksRegister your plugin or CLI's hooks. See hooks for morejitPluginsRegister plugins that can be installed just in time. See Just-in-Time Plugin Installation for moremacosSettings for building macos installer. See Releasing for morensisCustomizationA path to a .nsis file that's used to customize the installer for Windows. See nsis-custom for morepluginsList of plugins that should be loaded. See Plugins for morestateSet the state of your CLI or plugin to be shown in help (e.g. beta will show This CLI is in beta)themePath to theme file to include with your CLI. See Themes for moretopicSeparatorThe separator to use between topics - only colons (":") and spaces (" ") are supportedtopicsDefine your CLI's topics. See Topics for morewindowsSettings for building windows installer. See Releasing for more
Exit Codes​
You can configure the desired exit codes for the following errors:

default - default exit code for any error.
failedFlagParsing - exit code when oclif fails to parse a flag's value.
failedFlagValidation - exit code when a flag fails it's own validation.
invalidArgsSpec - exit code when a command defines an invalid args configuration.
nonExistentFlag - exit code when user provides a non-existent flag.
requiredArgs - exit code when user fails to provide a required arg.
unexpectedArgs - exit code when user provides unexpected args to a command.

Help Options​
You can configure the behavior of the help output with the following:

docopts - Use docopts as the usage. Defaults to true.
flagSortOrder - Order in which to sort flags in help output. Can be alphabetical (default) or none (flags will appear in the order they were defined).
hideAliasesFromRoot - If true, hide command aliases from the root help output. Defaults to false.
hideCommandSummaryInDescription - By default, the command summary is show at the top of the help and as the first line in the command description. Repeating the summary in the command description improves readability especially for long command help output. If there is no command.summary, the first line of the description is treated as the summary. Some CLIs, especially with very simple commands, may not want the duplication.
maxWidth - Maximum column width of the help output.
sections - Only show the help for the specified sections. Defaults to all sections.
sendToStderr - By default, the help output is sent to stdout. If this is true, it will be sent to stderr.
showFlagNameInTitle - By default, titles show flag values as <value>. Some CLI developers may prefer titles to show the flag name as the value. i.e. --myflag=myflag instead of --myflag=<value>. An individual flag can set this using flag.helpValue=flag.name.
showFlagOptionsInTitle - By default, option values on flags are shown in the flag's description. This is because long options list ruin the formatting of help. If a CLI knows all commands will not do this, it can be turned off at a help level using this property. An individual flag can set this using flag.helpValue=options.join('|').
stripAnsi - Strip ansi characters from help out to remove all formatting.
usageHeader - Override the header for the USAGE section.

If you want to further customize help, you can implement a Custom Help Class.Edit this pageLast updated on Dec 20, 2024 by Mike Donnalley\n\nGuidesConfiguring Your CLIOn this pageConfiguring Your CLIYou can configure the behavior of oclif inside your CLI or plugin's package.json or using an rc file.
If you use the package.json, all of the configuration options should be placed under the oclif section. For example:
{  "name": "my-cli",  "version": "1.2.3",  "dependencies": {    "@oclif/core": "^3"  },  "oclif": {    "bin": "mycli",    "dirname": "mycli",    "commands": "./dist/commands",    "topicSeparator": " "  }}
If you'd like to use an rc file, then you do not need to put the configuration under oclif. For instance:
//.oclifrc.jsmodule.exports = {  bin: "mycli",  dirname: "mycli",  commands: "./dist/commands",  topicSeparator: " "}
The following rc files are supported:
.oclifrc.oclifrc.json.oclifrc.js.oclifrc.mjs.oclifrc.cjsoclif.config.jsoclif.config.mjsoclif.config.cjs
Here's a list of all the options that you can configure.
PropertyDescriptionadditionalHelpFlagsArray of flags that should trigger help output in addition to --helpadditionalVersionFlagsArray of flags that should trigger version output in addition to --versionaliasesAliases for the plugin. This is used to support legacy plugins that have been renamedbinCLI bin name (e.g. sf, heroku, git, etc...)binAliasesAn array of strings that will all execute the CLI's bin. See Aliases for moredirnameDirectory name to use when determining CLI's config, cache, and data directories.commandsWhere oclif can find command classes. See Command Discovery Strategies for moredescriptionDescription of your plugin or CLI to show in helpdevPluginsList of plugins that will only be loaded in development. See Plugins for moreexitCodesConfigured exit codes. See Exit Codes section belowflexibleTaxonomySet to true to enable flexible taxonomyhelpClassLocation of compiled custom help classhelpOptionsSettings for configuring behavior of help output. See Help Options section belowhooksRegister your plugin or CLI's hooks. See hooks for morejitPluginsRegister plugins that can be installed just in time. See Just-in-Time Plugin Installation for moremacosSettings for building macos installer. See Releasing for morensisCustomizationA path to a .nsis file that's used to customize the installer for Windows. See nsis-custom for morepluginsList of plugins that should be loaded. See Plugins for morestateSet the state of your CLI or plugin to be shown in help (e.g. beta will show This CLI is in beta)themePath to theme file to include with your CLI. See Themes for moretopicSeparatorThe separator to use between topics - only colons (":") and spaces (" ") are supportedtopicsDefine your CLI's topics. See Topics for morewindowsSettings for building windows installer. See Releasing for more
Exit Codes​
You can configure the desired exit codes for the following errors:

default - default exit code for any error.
failedFlagParsing - exit code when oclif fails to parse a flag's value.
failedFlagValidation - exit code when a flag fails it's own validation.
invalidArgsSpec - exit code when a command defines an invalid args configuration.
nonExistentFlag - exit code when user provides a non-existent flag.
requiredArgs - exit code when user fails to provide a required arg.
unexpectedArgs - exit code when user provides unexpected args to a command.

Help Options​
You can configure the behavior of the help output with the following:

docopts - Use docopts as the usage. Defaults to true.
flagSortOrder - Order in which to sort flags in help output. Can be alphabetical (default) or none (flags will appear in the order they were defined).
hideAliasesFromRoot - If true, hide command aliases from the root help output. Defaults to false.
hideCommandSummaryInDescription - By default, the command summary is show at the top of the help and as the first line in the command description. Repeating the summary in the command description improves readability especially for long command help output. If there is no command.summary, the first line of the description is treated as the summary. Some CLIs, especially with very simple commands, may not want the duplication.
maxWidth - Maximum column width of the help output.
sections - Only show the help for the specified sections. Defaults to all sections.
sendToStderr - By default, the help output is sent to stdout. If this is true, it will be sent to stderr.
showFlagNameInTitle - By default, titles show flag values as <value>. Some CLI developers may prefer titles to show the flag name as the value. i.e. --myflag=myflag instead of --myflag=<value>. An individual flag can set this using flag.helpValue=flag.name.
showFlagOptionsInTitle - By default, option values on flags are shown in the flag's description. This is because long options list ruin the formatting of help. If a CLI knows all commands will not do this, it can be turned off at a help level using this property. An individual flag can set this using flag.helpValue=options.join('|').
stripAnsi - Strip ansi characters from help out to remove all formatting.
usageHeader - Override the header for the USAGE section.

If you want to further customize help, you can implement a Custom Help Class.Edit this pageLast updated on Dec 20, 2024 by Mike DonnalleyPreviousCustom Base ClassNextDebuggingExit CodesHelp Options\n\n\n\nGuidesAliasesOn this pageAliasesCommand Aliases​
Aliases let you define a string that maps to a command. This command can be run as mycli config, mycli config:index, or mycli config:list:
import {Command, Flags} from '@oclif/core'export class ConfigIndex extends Command {  static aliases = ['config:index', 'config:list']}
By default, aliases find the "real" command and just work.  If you're providing command aliases for backward compatibility but prefer users to use the "real" command, set deprecateAliases to true to warn users about the correct name
export class ConfigIndex extends Command {  static aliases = ['config:index', 'config:list']  static deprecateAliases = true}
Flag Aliases​
Like command aliases, but on an individual flag.  You can alias the name and short character, and optionally emit warnings when aliased names are used.
export class ConfigIndex extends Command {  static flags = {    'new-name': Flags.boolean({      char: 'c',      aliases: ['old-name', 'o'],      deprecateAliases: true    })  }}
Bin Aliases​
Creating a CLI that responds to different names or "aliases" is easy, simply add a binAliases property to your CLI's oclif property in package.json:
{  "name": "mycli",  "version": "0.0.0",  "description": "My CLI",  "main": "bin/run.js",  "bin": {    "mycli": "./bin/run.js",    "mycli-alias": "./bin/run.js"  },  "oclif": {    "binAliases": ["mycli", "mycli-alias"]  }}
Adding this property allows your CLI to respond to either of those names, and is used during the bundling and building process when shipping your CLI. Note that the bin section was also modified to include both aliases, which is how npm creates bin aliases. To create a unified experience, regardless of the installation method, a CLI author must change both to match. Bin aliases also play nicely with @oclif/plugin-autocomplete, so typing an alias and using autocomplete is the same experience as using the original name.Edit this pageLast updated on Dec 20, 2024 by Mike Donnalley\n\nGuidesAliasesOn this pageAliasesCommand Aliases​
Aliases let you define a string that maps to a command. This command can be run as mycli config, mycli config:index, or mycli config:list:
import {Command, Flags} from '@oclif/core'export class ConfigIndex extends Command {  static aliases = ['config:index', 'config:list']}
By default, aliases find the "real" command and just work.  If you're providing command aliases for backward compatibility but prefer users to use the "real" command, set deprecateAliases to true to warn users about the correct name
export class ConfigIndex extends Command {  static aliases = ['config:index', 'config:list']  static deprecateAliases = true}
Flag Aliases​
Like command aliases, but on an individual flag.  You can alias the name and short character, and optionally emit warnings when aliased names are used.
export class ConfigIndex extends Command {  static flags = {    'new-name': Flags.boolean({      char: 'c',      aliases: ['old-name', 'o'],      deprecateAliases: true    })  }}
Bin Aliases​
Creating a CLI that responds to different names or "aliases" is easy, simply add a binAliases property to your CLI's oclif property in package.json:
{  "name": "mycli",  "version": "0.0.0",  "description": "My CLI",  "main": "bin/run.js",  "bin": {    "mycli": "./bin/run.js",    "mycli-alias": "./bin/run.js"  },  "oclif": {    "binAliases": ["mycli", "mycli-alias"]  }}
Adding this property allows your CLI to respond to either of those names, and is used during the bundling and building process when shipping your CLI. Note that the bin section was also modified to include both aliases, which is how npm creates bin aliases. To create a unified experience, regardless of the installation method, a CLI author must change both to match. Bin aliases also play nicely with @oclif/plugin-autocomplete, so typing an alias and using autocomplete is the same experience as using the original name.Edit this pageLast updated on Dec 20, 2024 by Mike DonnalleyPreviousGuidesNextCustom Base ClassCommand AliasesFlag AliasesBin Aliases\n\n\n\nGuidesConfiguring Your CLIOn this pageConfiguring Your CLIYou can configure the behavior of oclif inside your CLI or plugin's package.json or using an rc file.
If you use the package.json, all of the configuration options should be placed under the oclif section. For example:
{  "name": "my-cli",  "version": "1.2.3",  "dependencies": {    "@oclif/core": "^3"  },  "oclif": {    "bin": "mycli",    "dirname": "mycli",    "commands": "./dist/commands",    "topicSeparator": " "  }}
If you'd like to use an rc file, then you do not need to put the configuration under oclif. For instance:
//.oclifrc.jsmodule.exports = {  bin: "mycli",  dirname: "mycli",  commands: "./dist/commands",  topicSeparator: " "}
The following rc files are supported:
.oclifrc.oclifrc.json.oclifrc.js.oclifrc.mjs.oclifrc.cjsoclif.config.jsoclif.config.mjsoclif.config.cjs
Here's a list of all the options that you can configure.
PropertyDescriptionadditionalHelpFlagsArray of flags that should trigger help output in addition to --helpadditionalVersionFlagsArray of flags that should trigger version output in addition to --versionaliasesAliases for the plugin. This is used to support legacy plugins that have been renamedbinCLI bin name (e.g. sf, heroku, git, etc...)binAliasesAn array of strings that will all execute the CLI's bin. See Aliases for moredirnameDirectory name to use when determining CLI's config, cache, and data directories.commandsWhere oclif can find command classes. See Command Discovery Strategies for moredescriptionDescription of your plugin or CLI to show in helpdevPluginsList of plugins that will only be loaded in development. See Plugins for moreexitCodesConfigured exit codes. See Exit Codes section belowflexibleTaxonomySet to true to enable flexible taxonomyhelpClassLocation of compiled custom help classhelpOptionsSettings for configuring behavior of help output. See Help Options section belowhooksRegister your plugin or CLI's hooks. See hooks for morejitPluginsRegister plugins that can be installed just in time. See Just-in-Time Plugin Installation for moremacosSettings for building macos installer. See Releasing for morensisCustomizationA path to a .nsis file that's used to customize the installer for Windows. See nsis-custom for morepluginsList of plugins that should be loaded. See Plugins for morestateSet the state of your CLI or plugin to be shown in help (e.g. beta will show This CLI is in beta)themePath to theme file to include with your CLI. See Themes for moretopicSeparatorThe separator to use between topics - only colons (":") and spaces (" ") are supportedtopicsDefine your CLI's topics. See Topics for morewindowsSettings for building windows installer. See Releasing for more
Exit Codes​
You can configure the desired exit codes for the following errors:

default - default exit code for any error.
failedFlagParsing - exit code when oclif fails to parse a flag's value.
failedFlagValidation - exit code when a flag fails it's own validation.
invalidArgsSpec - exit code when a command defines an invalid args configuration.
nonExistentFlag - exit code when user provides a non-existent flag.
requiredArgs - exit code when user fails to provide a required arg.
unexpectedArgs - exit code when user provides unexpected args to a command.

Help Options​
You can configure the behavior of the help output with the following:

docopts - Use docopts as the usage. Defaults to true.
flagSortOrder - Order in which to sort flags in help output. Can be alphabetical (default) or none (flags will appear in the order they were defined).
hideAliasesFromRoot - If true, hide command aliases from the root help output. Defaults to false.
hideCommandSummaryInDescription - By default, the command summary is show at the top of the help and as the first line in the command description. Repeating the summary in the command description improves readability especially for long command help output. If there is no command.summary, the first line of the description is treated as the summary. Some CLIs, especially with very simple commands, may not want the duplication.
maxWidth - Maximum column width of the help output.
sections - Only show the help for the specified sections. Defaults to all sections.
sendToStderr - By default, the help output is sent to stdout. If this is true, it will be sent to stderr.
showFlagNameInTitle - By default, titles show flag values as <value>. Some CLI developers may prefer titles to show the flag name as the value. i.e. --myflag=myflag instead of --myflag=<value>. An individual flag can set this using flag.helpValue=flag.name.
showFlagOptionsInTitle - By default, option values on flags are shown in the flag's description. This is because long options list ruin the formatting of help. If a CLI knows all commands will not do this, it can be turned off at a help level using this property. An individual flag can set this using flag.helpValue=options.join('|').
stripAnsi - Strip ansi characters from help out to remove all formatting.
usageHeader - Override the header for the USAGE section.

If you want to further customize help, you can implement a Custom Help Class.Edit this pageLast updated on Dec 20, 2024 by Mike Donnalley\n\nGuidesConfiguring Your CLIOn this pageConfiguring Your CLIYou can configure the behavior of oclif inside your CLI or plugin's package.json or using an rc file.
If you use the package.json, all of the configuration options should be placed under the oclif section. For example:
{  "name": "my-cli",  "version": "1.2.3",  "dependencies": {    "@oclif/core": "^3"  },  "oclif": {    "bin": "mycli",    "dirname": "mycli",    "commands": "./dist/commands",    "topicSeparator": " "  }}
If you'd like to use an rc file, then you do not need to put the configuration under oclif. For instance:
//.oclifrc.jsmodule.exports = {  bin: "mycli",  dirname: "mycli",  commands: "./dist/commands",  topicSeparator: " "}
The following rc files are supported:
.oclifrc.oclifrc.json.oclifrc.js.oclifrc.mjs.oclifrc.cjsoclif.config.jsoclif.config.mjsoclif.config.cjs
Here's a list of all the options that you can configure.
PropertyDescriptionadditionalHelpFlagsArray of flags that should trigger help output in addition to --helpadditionalVersionFlagsArray of flags that should trigger version output in addition to --versionaliasesAliases for the plugin. This is used to support legacy plugins that have been renamedbinCLI bin name (e.g. sf, heroku, git, etc...)binAliasesAn array of strings that will all execute the CLI's bin. See Aliases for moredirnameDirectory name to use when determining CLI's config, cache, and data directories.commandsWhere oclif can find command classes. See Command Discovery Strategies for moredescriptionDescription of your plugin or CLI to show in helpdevPluginsList of plugins that will only be loaded in development. See Plugins for moreexitCodesConfigured exit codes. See Exit Codes section belowflexibleTaxonomySet to true to enable flexible taxonomyhelpClassLocation of compiled custom help classhelpOptionsSettings for configuring behavior of help output. See Help Options section belowhooksRegister your plugin or CLI's hooks. See hooks for morejitPluginsRegister plugins that can be installed just in time. See Just-in-Time Plugin Installation for moremacosSettings for building macos installer. See Releasing for morensisCustomizationA path to a .nsis file that's used to customize the installer for Windows. See nsis-custom for morepluginsList of plugins that should be loaded. See Plugins for morestateSet the state of your CLI or plugin to be shown in help (e.g. beta will show This CLI is in beta)themePath to theme file to include with your CLI. See Themes for moretopicSeparatorThe separator to use between topics - only colons (":") and spaces (" ") are supportedtopicsDefine your CLI's topics. See Topics for morewindowsSettings for building windows installer. See Releasing for more
Exit Codes​
You can configure the desired exit codes for the following errors:

default - default exit code for any error.
failedFlagParsing - exit code when oclif fails to parse a flag's value.
failedFlagValidation - exit code when a flag fails it's own validation.
invalidArgsSpec - exit code when a command defines an invalid args configuration.
nonExistentFlag - exit code when user provides a non-existent flag.
requiredArgs - exit code when user fails to provide a required arg.
unexpectedArgs - exit code when user provides unexpected args to a command.

Help Options​
You can configure the behavior of the help output with the following:

docopts - Use docopts as the usage. Defaults to true.
flagSortOrder - Order in which to sort flags in help output. Can be alphabetical (default) or none (flags will appear in the order they were defined).
hideAliasesFromRoot - If true, hide command aliases from the root help output. Defaults to false.
hideCommandSummaryInDescription - By default, the command summary is show at the top of the help and as the first line in the command description. Repeating the summary in the command description improves readability especially for long command help output. If there is no command.summary, the first line of the description is treated as the summary. Some CLIs, especially with very simple commands, may not want the duplication.
maxWidth - Maximum column width of the help output.
sections - Only show the help for the specified sections. Defaults to all sections.
sendToStderr - By default, the help output is sent to stdout. If this is true, it will be sent to stderr.
showFlagNameInTitle - By default, titles show flag values as <value>. Some CLI developers may prefer titles to show the flag name as the value. i.e. --myflag=myflag instead of --myflag=<value>. An individual flag can set this using flag.helpValue=flag.name.
showFlagOptionsInTitle - By default, option values on flags are shown in the flag's description. This is because long options list ruin the formatting of help. If a CLI knows all commands will not do this, it can be turned off at a help level using this property. An individual flag can set this using flag.helpValue=options.join('|').
stripAnsi - Strip ansi characters from help out to remove all formatting.
usageHeader - Override the header for the USAGE section.

If you want to further customize help, you can implement a Custom Help Class.Edit this pageLast updated on Dec 20, 2024 by Mike DonnalleyPreviousCustom Base ClassNextDebuggingExit CodesHelp Options\n\n\n\nGuidesConfiguring Your CLIOn this pageConfiguring Your CLIYou can configure the behavior of oclif inside your CLI or plugin's package.json or using an rc file.
If you use the package.json, all of the configuration options should be placed under the oclif section. For example:
{  "name": "my-cli",  "version": "1.2.3",  "dependencies": {    "@oclif/core": "^3"  },  "oclif": {    "bin": "mycli",    "dirname": "mycli",    "commands": "./dist/commands",    "topicSeparator": " "  }}
If you'd like to use an rc file, then you do not need to put the configuration under oclif. For instance:
//.oclifrc.jsmodule.exports = {  bin: "mycli",  dirname: "mycli",  commands: "./dist/commands",  topicSeparator: " "}
The following rc files are supported:
.oclifrc.oclifrc.json.oclifrc.js.oclifrc.mjs.oclifrc.cjsoclif.config.jsoclif.config.mjsoclif.config.cjs
Here's a list of all the options that you can configure.
PropertyDescriptionadditionalHelpFlagsArray of flags that should trigger help output in addition to --helpadditionalVersionFlagsArray of flags that should trigger version output in addition to --versionaliasesAliases for the plugin. This is used to support legacy plugins that have been renamedbinCLI bin name (e.g. sf, heroku, git, etc...)binAliasesAn array of strings that will all execute the CLI's bin. See Aliases for moredirnameDirectory name to use when determining CLI's config, cache, and data directories.commandsWhere oclif can find command classes. See Command Discovery Strategies for moredescriptionDescription of your plugin or CLI to show in helpdevPluginsList of plugins that will only be loaded in development. See Plugins for moreexitCodesConfigured exit codes. See Exit Codes section belowflexibleTaxonomySet to true to enable flexible taxonomyhelpClassLocation of compiled custom help classhelpOptionsSettings for configuring behavior of help output. See Help Options section belowhooksRegister your plugin or CLI's hooks. See hooks for morejitPluginsRegister plugins that can be installed just in time. See Just-in-Time Plugin Installation for moremacosSettings for building macos installer. See Releasing for morensisCustomizationA path to a .nsis file that's used to customize the installer for Windows. See nsis-custom for morepluginsList of plugins that should be loaded. See Plugins for morestateSet the state of your CLI or plugin to be shown in help (e.g. beta will show This CLI is in beta)themePath to theme file to include with your CLI. See Themes for moretopicSeparatorThe separator to use between topics - only colons (":") and spaces (" ") are supportedtopicsDefine your CLI's topics. See Topics for morewindowsSettings for building windows installer. See Releasing for more
Exit Codes​
You can configure the desired exit codes for the following errors:

default - default exit code for any error.
failedFlagParsing - exit code when oclif fails to parse a flag's value.
failedFlagValidation - exit code when a flag fails it's own validation.
invalidArgsSpec - exit code when a command defines an invalid args configuration.
nonExistentFlag - exit code when user provides a non-existent flag.
requiredArgs - exit code when user fails to provide a required arg.
unexpectedArgs - exit code when user provides unexpected args to a command.

Help Options​
You can configure the behavior of the help output with the following:

docopts - Use docopts as the usage. Defaults to true.
flagSortOrder - Order in which to sort flags in help output. Can be alphabetical (default) or none (flags will appear in the order they were defined).
hideAliasesFromRoot - If true, hide command aliases from the root help output. Defaults to false.
hideCommandSummaryInDescription - By default, the command summary is show at the top of the help and as the first line in the command description. Repeating the summary in the command description improves readability especially for long command help output. If there is no command.summary, the first line of the description is treated as the summary. Some CLIs, especially with very simple commands, may not want the duplication.
maxWidth - Maximum column width of the help output.
sections - Only show the help for the specified sections. Defaults to all sections.
sendToStderr - By default, the help output is sent to stdout. If this is true, it will be sent to stderr.
showFlagNameInTitle - By default, titles show flag values as <value>. Some CLI developers may prefer titles to show the flag name as the value. i.e. --myflag=myflag instead of --myflag=<value>. An individual flag can set this using flag.helpValue=flag.name.
showFlagOptionsInTitle - By default, option values on flags are shown in the flag's description. This is because long options list ruin the formatting of help. If a CLI knows all commands will not do this, it can be turned off at a help level using this property. An individual flag can set this using flag.helpValue=options.join('|').
stripAnsi - Strip ansi characters from help out to remove all formatting.
usageHeader - Override the header for the USAGE section.

If you want to further customize help, you can implement a Custom Help Class.Edit this pageLast updated on Dec 20, 2024 by Mike Donnalley\n\nGuidesConfiguring Your CLIOn this pageConfiguring Your CLIYou can configure the behavior of oclif inside your CLI or plugin's package.json or using an rc file.
If you use the package.json, all of the configuration options should be placed under the oclif section. For example:
{  "name": "my-cli",  "version": "1.2.3",  "dependencies": {    "@oclif/core": "^3"  },  "oclif": {    "bin": "mycli",    "dirname": "mycli",    "commands": "./dist/commands",    "topicSeparator": " "  }}
If you'd like to use an rc file, then you do not need to put the configuration under oclif. For instance:
//.oclifrc.jsmodule.exports = {  bin: "mycli",  dirname: "mycli",  commands: "./dist/commands",  topicSeparator: " "}
The following rc files are supported:
.oclifrc.oclifrc.json.oclifrc.js.oclifrc.mjs.oclifrc.cjsoclif.config.jsoclif.config.mjsoclif.config.cjs
Here's a list of all the options that you can configure.
PropertyDescriptionadditionalHelpFlagsArray of flags that should trigger help output in addition to --helpadditionalVersionFlagsArray of flags that should trigger version output in addition to --versionaliasesAliases for the plugin. This is used to support legacy plugins that have been renamedbinCLI bin name (e.g. sf, heroku, git, etc...)binAliasesAn array of strings that will all execute the CLI's bin. See Aliases for moredirnameDirectory name to use when determining CLI's config, cache, and data directories.commandsWhere oclif can find command classes. See Command Discovery Strategies for moredescriptionDescription of your plugin or CLI to show in helpdevPluginsList of plugins that will only be loaded in development. See Plugins for moreexitCodesConfigured exit codes. See Exit Codes section belowflexibleTaxonomySet to true to enable flexible taxonomyhelpClassLocation of compiled custom help classhelpOptionsSettings for configuring behavior of help output. See Help Options section belowhooksRegister your plugin or CLI's hooks. See hooks for morejitPluginsRegister plugins that can be installed just in time. See Just-in-Time Plugin Installation for moremacosSettings for building macos installer. See Releasing for morensisCustomizationA path to a .nsis file that's used to customize the installer for Windows. See nsis-custom for morepluginsList of plugins that should be loaded. See Plugins for morestateSet the state of your CLI or plugin to be shown in help (e.g. beta will show This CLI is in beta)themePath to theme file to include with your CLI. See Themes for moretopicSeparatorThe separator to use between topics - only colons (":") and spaces (" ") are supportedtopicsDefine your CLI's topics. See Topics for morewindowsSettings for building windows installer. See Releasing for more
Exit Codes​
You can configure the desired exit codes for the following errors:

default - default exit code for any error.
failedFlagParsing - exit code when oclif fails to parse a flag's value.
failedFlagValidation - exit code when a flag fails it's own validation.
invalidArgsSpec - exit code when a command defines an invalid args configuration.
nonExistentFlag - exit code when user provides a non-existent flag.
requiredArgs - exit code when user fails to provide a required arg.
unexpectedArgs - exit code when user provides unexpected args to a command.

Help Options​
You can configure the behavior of the help output with the following:

docopts - Use docopts as the usage. Defaults to true.
flagSortOrder - Order in which to sort flags in help output. Can be alphabetical (default) or none (flags will appear in the order they were defined).
hideAliasesFromRoot - If true, hide command aliases from the root help output. Defaults to false.
hideCommandSummaryInDescription - By default, the command summary is show at the top of the help and as the first line in the command description. Repeating the summary in the command description improves readability especially for long command help output. If there is no command.summary, the first line of the description is treated as the summary. Some CLIs, especially with very simple commands, may not want the duplication.
maxWidth - Maximum column width of the help output.
sections - Only show the help for the specified sections. Defaults to all sections.
sendToStderr - By default, the help output is sent to stdout. If this is true, it will be sent to stderr.
showFlagNameInTitle - By default, titles show flag values as <value>. Some CLI developers may prefer titles to show the flag name as the value. i.e. --myflag=myflag instead of --myflag=<value>. An individual flag can set this using flag.helpValue=flag.name.
showFlagOptionsInTitle - By default, option values on flags are shown in the flag's description. This is because long options list ruin the formatting of help. If a CLI knows all commands will not do this, it can be turned off at a help level using this property. An individual flag can set this using flag.helpValue=options.join('|').
stripAnsi - Strip ansi characters from help out to remove all formatting.
usageHeader - Override the header for the USAGE section.

If you want to further customize help, you can implement a Custom Help Class.Edit this pageLast updated on Dec 20, 2024 by Mike DonnalleyPreviousCustom Base ClassNextDebuggingExit CodesHelp Options\n\n\n\nAPI ReferenceCommandsOn this pageCommandsA basic command looks like the following in TypeScript:
import {Command} from '@oclif/core'export class MyCommand extends Command {  static description = 'description of this example command'  async run(): Promise<void> {    console.log('running my command')  }}
The only part that is required is the run function. Accept user input with arguments and flags.
In JavaScript:
const {Command} = require('@oclif/core')class MyCommand extends Command {  async run() {    console.log('running my command')  }}MyCommand.description = 'description of this example command'module.exports = MyCommand
Note that the following examples will be in TypeScript. As JavaScript does not yet have static class properties, you will have to add them to the class after it is declared like we did with the description above.
Avoiding Timeouts​
In order to avoid command executions running indefinitely, oclif will terminate the node process 10 seconds after Command.run resolves. This means that all command logic inside the run method should either run synchronously or should return a Promise. This will allow the entire command to run before the 10 second timeout starts.
In other words, if you execute a promise in Command.run without a awaiting it, then the command will likely timeout before it's completed.
Other Command Options​
See the base class to get an idea of what methods can be called on a command.
import {Command, Flags} from '@oclif/core'export class MyCommand extends Command {  static summary = 'A brief overview of your command.'  static description = `An in-depth description of the command.It can be multiline.`  // hide the command from help  static hidden = false  // custom usage string for help  // this overrides the default usage  static usage = 'mycommand --myflag'  // examples to add to help  // <%= config.bin %> resolves to the executable name  // <%= command.id %> resolves to the command name  static examples = [    // Examples can be simple strings    '<%= config.bin %> <%= command.id %> --help',    // Or objects that provide a description of the example command    {      description: 'Force the command to execute',      command: '<%= config.bin %> <%= command.id %> --force',    }  ]  // this makes the parser not fail when it receives invalid arguments  // defaults to true  // set it to false if you need to accept a variable number of arguments  static strict = false  // define aliases that can execute this command.  static aliases = ['alternate:name:for:this:command']  // Set to true if you want to add the --json flag to your command.  // oclif will automatically suppress logs (if you use this.log, this.warn, or this.error) and  // display the JSON returned by the command's run method.  static enableJsonFlag = true  async run() {    // show a warning    this.warn('uh oh!')    // exit with an error message    this.error('uh oh!!!')    // exit with status code    this.exit(1)  }}
Command Methods​

Command Methods

this.log(message: string)
this.warn(message: string | Error)
this.error(message: string | Error, options?: {code?: string, exit?: number, ref?: string; suggestions?: string[];})
this.exit(code: number = 0)
this.logToStderr(message: string)
this.jsonEnabled()
this.toSuccessJson(result: unknown)
this.toErrorJson(result: unknown)



The following assumes you are in the run() method of an oclif command.
this.log(message: string)​
Output message to stdout (non-blocking). console.log() works fine too, but that is a blocking call and won't be automatically suppressed when the --json flag is present. This uses util.format() which behaves the same as console.log().
this.log('hello, world!')
this.warn(message: string | Error)​
Display an error or message as a warning
this.warn('uh oh!')this.warn(new Error('uh oh!'))
this.error(message: string | Error, options?: {code?: string, exit?: number, ref?: string; suggestions?: string[];})​
Display error and exit. Also add a code to error object or exit status.
this.error('uh oh!', {exit: 2})this.error(new Error('uh oh!'))
The options object has the following options:

exit — exit code to use
code — a unique error code for the type of error
suggestions —  an array of suggestions for a user to try next that may be useful or provide additional context
ref — a url to documentation related to this error or fixing it

The message, code, suggestions, ref properties will be displayed when an error is shown. Reusable Error classes can be created that display the optional outputs above by implementing the PrettyPrintableError interface from the Errors namespace from @oclif/core and this.error will handle them appropriately.
These errors are friendly and won't show a traceback unless debugging is enabled with DEBUG=*.
import {CLIError} from '@oclif/errors'throw new CLIError('my friendly error')
Any error caught by the command of this CLIError type will be shown without traceback.
this.exit(code: number = 0)​
Exit process. Defaults to status 0.
this.exit()this.exit(1)
this.logToStderr(message: string)​
Log a message to the terminal's stderr.
this.jsonEnabled()​
Returns to true if the --json flag is present and enableJsonFlag is set to true
this.toSuccessJson(result: unknown)​
Modify the command's success JSON output before it's displayed to the user.
this.toErrorJson(result: unknown)​
Modify the command's error JSON output before it's displayed to the user.Edit this pageLast updated on Dec 20, 2024 by Mike Donnalley\n\nAPI ReferenceCommandsOn this pageCommandsA basic command looks like the following in TypeScript:
import {Command} from '@oclif/core'export class MyCommand extends Command {  static description = 'description of this example command'  async run(): Promise<void> {    console.log('running my command')  }}
The only part that is required is the run function. Accept user input with arguments and flags.
In JavaScript:
const {Command} = require('@oclif/core')class MyCommand extends Command {  async run() {    console.log('running my command')  }}MyCommand.description = 'description of this example command'module.exports = MyCommand
Note that the following examples will be in TypeScript. As JavaScript does not yet have static class properties, you will have to add them to the class after it is declared like we did with the description above.
Avoiding Timeouts​
In order to avoid command executions running indefinitely, oclif will terminate the node process 10 seconds after Command.run resolves. This means that all command logic inside the run method should either run synchronously or should return a Promise. This will allow the entire command to run before the 10 second timeout starts.
In other words, if you execute a promise in Command.run without a awaiting it, then the command will likely timeout before it's completed.
Other Command Options​
See the base class to get an idea of what methods can be called on a command.
import {Command, Flags} from '@oclif/core'export class MyCommand extends Command {  static summary = 'A brief overview of your command.'  static description = `An in-depth description of the command.It can be multiline.`  // hide the command from help  static hidden = false  // custom usage string for help  // this overrides the default usage  static usage = 'mycommand --myflag'  // examples to add to help  // <%= config.bin %> resolves to the executable name  // <%= command.id %> resolves to the command name  static examples = [    // Examples can be simple strings    '<%= config.bin %> <%= command.id %> --help',    // Or objects that provide a description of the example command    {      description: 'Force the command to execute',      command: '<%= config.bin %> <%= command.id %> --force',    }  ]  // this makes the parser not fail when it receives invalid arguments  // defaults to true  // set it to false if you need to accept a variable number of arguments  static strict = false  // define aliases that can execute this command.  static aliases = ['alternate:name:for:this:command']  // Set to true if you want to add the --json flag to your command.  // oclif will automatically suppress logs (if you use this.log, this.warn, or this.error) and  // display the JSON returned by the command's run method.  static enableJsonFlag = true  async run() {    // show a warning    this.warn('uh oh!')    // exit with an error message    this.error('uh oh!!!')    // exit with status code    this.exit(1)  }}
Command Methods​

Command Methods

this.log(message: string)
this.warn(message: string | Error)
this.error(message: string | Error, options?: {code?: string, exit?: number, ref?: string; suggestions?: string[];})
this.exit(code: number = 0)
this.logToStderr(message: string)
this.jsonEnabled()
this.toSuccessJson(result: unknown)
this.toErrorJson(result: unknown)



The following assumes you are in the run() method of an oclif command.
this.log(message: string)​
Output message to stdout (non-blocking). console.log() works fine too, but that is a blocking call and won't be automatically suppressed when the --json flag is present. This uses util.format() which behaves the same as console.log().
this.log('hello, world!')
this.warn(message: string | Error)​
Display an error or message as a warning
this.warn('uh oh!')this.warn(new Error('uh oh!'))
this.error(message: string | Error, options?: {code?: string, exit?: number, ref?: string; suggestions?: string[];})​
Display error and exit. Also add a code to error object or exit status.
this.error('uh oh!', {exit: 2})this.error(new Error('uh oh!'))
The options object has the following options:

exit — exit code to use
code — a unique error code for the type of error
suggestions —  an array of suggestions for a user to try next that may be useful or provide additional context
ref — a url to documentation related to this error or fixing it

The message, code, suggestions, ref properties will be displayed when an error is shown. Reusable Error classes can be created that display the optional outputs above by implementing the PrettyPrintableError interface from the Errors namespace from @oclif/core and this.error will handle them appropriately.
These errors are friendly and won't show a traceback unless debugging is enabled with DEBUG=*.
import {CLIError} from '@oclif/errors'throw new CLIError('my friendly error')
Any error caught by the command of this CLIError type will be shown without traceback.
this.exit(code: number = 0)​
Exit process. Defaults to status 0.
this.exit()this.exit(1)
this.logToStderr(message: string)​
Log a message to the terminal's stderr.
this.jsonEnabled()​
Returns to true if the --json flag is present and enableJsonFlag is set to true
this.toSuccessJson(result: unknown)​
Modify the command's success JSON output before it's displayed to the user.
this.toErrorJson(result: unknown)​
Modify the command's error JSON output before it's displayed to the user.Edit this pageLast updated on Dec 20, 2024 by Mike DonnalleyPreviousAPI ReferenceNextCommand ArgumentsAvoiding TimeoutsOther Command OptionsCommand Methodsthis.log(message: string)this.warn(message: string | Error)this.error(message: string | Error, options?: {code?: string, exit?: number, ref?: string; suggestions?: string[];})this.exit(code: number = 0)this.logToStderr(message: string)this.jsonEnabled()this.toSuccessJson(result: unknown)this.toErrorJson(result: unknown)\n\n\n\nAPI ReferenceCommandsOn this pageCommandsA basic command looks like the following in TypeScript:
import {Command} from '@oclif/core'export class MyCommand extends Command {  static description = 'description of this example command'  async run(): Promise<void> {    console.log('running my command')  }}
The only part that is required is the run function. Accept user input with arguments and flags.
In JavaScript:
const {Command} = require('@oclif/core')class MyCommand extends Command {  async run() {    console.log('running my command')  }}MyCommand.description = 'description of this example command'module.exports = MyCommand
Note that the following examples will be in TypeScript. As JavaScript does not yet have static class properties, you will have to add them to the class after it is declared like we did with the description above.
Avoiding Timeouts​
In order to avoid command executions running indefinitely, oclif will terminate the node process 10 seconds after Command.run resolves. This means that all command logic inside the run method should either run synchronously or should return a Promise. This will allow the entire command to run before the 10 second timeout starts.
In other words, if you execute a promise in Command.run without a awaiting it, then the command will likely timeout before it's completed.
Other Command Options​
See the base class to get an idea of what methods can be called on a command.
import {Command, Flags} from '@oclif/core'export class MyCommand extends Command {  static summary = 'A brief overview of your command.'  static description = `An in-depth description of the command.It can be multiline.`  // hide the command from help  static hidden = false  // custom usage string for help  // this overrides the default usage  static usage = 'mycommand --myflag'  // examples to add to help  // <%= config.bin %> resolves to the executable name  // <%= command.id %> resolves to the command name  static examples = [    // Examples can be simple strings    '<%= config.bin %> <%= command.id %> --help',    // Or objects that provide a description of the example command    {      description: 'Force the command to execute',      command: '<%= config.bin %> <%= command.id %> --force',    }  ]  // this makes the parser not fail when it receives invalid arguments  // defaults to true  // set it to false if you need to accept a variable number of arguments  static strict = false  // define aliases that can execute this command.  static aliases = ['alternate:name:for:this:command']  // Set to true if you want to add the --json flag to your command.  // oclif will automatically suppress logs (if you use this.log, this.warn, or this.error) and  // display the JSON returned by the command's run method.  static enableJsonFlag = true  async run() {    // show a warning    this.warn('uh oh!')    // exit with an error message    this.error('uh oh!!!')    // exit with status code    this.exit(1)  }}
Command Methods​

Command Methods

this.log(message: string)
this.warn(message: string | Error)
this.error(message: string | Error, options?: {code?: string, exit?: number, ref?: string; suggestions?: string[];})
this.exit(code: number = 0)
this.logToStderr(message: string)
this.jsonEnabled()
this.toSuccessJson(result: unknown)
this.toErrorJson(result: unknown)



The following assumes you are in the run() method of an oclif command.
this.log(message: string)​
Output message to stdout (non-blocking). console.log() works fine too, but that is a blocking call and won't be automatically suppressed when the --json flag is present. This uses util.format() which behaves the same as console.log().
this.log('hello, world!')
this.warn(message: string | Error)​
Display an error or message as a warning
this.warn('uh oh!')this.warn(new Error('uh oh!'))
this.error(message: string | Error, options?: {code?: string, exit?: number, ref?: string; suggestions?: string[];})​
Display error and exit. Also add a code to error object or exit status.
this.error('uh oh!', {exit: 2})this.error(new Error('uh oh!'))
The options object has the following options:

exit — exit code to use
code — a unique error code for the type of error
suggestions —  an array of suggestions for a user to try next that may be useful or provide additional context
ref — a url to documentation related to this error or fixing it

The message, code, suggestions, ref properties will be displayed when an error is shown. Reusable Error classes can be created that display the optional outputs above by implementing the PrettyPrintableError interface from the Errors namespace from @oclif/core and this.error will handle them appropriately.
These errors are friendly and won't show a traceback unless debugging is enabled with DEBUG=*.
import {CLIError} from '@oclif/errors'throw new CLIError('my friendly error')
Any error caught by the command of this CLIError type will be shown without traceback.
this.exit(code: number = 0)​
Exit process. Defaults to status 0.
this.exit()this.exit(1)
this.logToStderr(message: string)​
Log a message to the terminal's stderr.
this.jsonEnabled()​
Returns to true if the --json flag is present and enableJsonFlag is set to true
this.toSuccessJson(result: unknown)​
Modify the command's success JSON output before it's displayed to the user.
this.toErrorJson(result: unknown)​
Modify the command's error JSON output before it's displayed to the user.Edit this pageLast updated on Dec 20, 2024 by Mike Donnalley\n\nAPI ReferenceCommandsOn this pageCommandsA basic command looks like the following in TypeScript:
import {Command} from '@oclif/core'export class MyCommand extends Command {  static description = 'description of this example command'  async run(): Promise<void> {    console.log('running my command')  }}
The only part that is required is the run function. Accept user input with arguments and flags.
In JavaScript:
const {Command} = require('@oclif/core')class MyCommand extends Command {  async run() {    console.log('running my command')  }}MyCommand.description = 'description of this example command'module.exports = MyCommand
Note that the following examples will be in TypeScript. As JavaScript does not yet have static class properties, you will have to add them to the class after it is declared like we did with the description above.
Avoiding Timeouts​
In order to avoid command executions running indefinitely, oclif will terminate the node process 10 seconds after Command.run resolves. This means that all command logic inside the run method should either run synchronously or should return a Promise. This will allow the entire command to run before the 10 second timeout starts.
In other words, if you execute a promise in Command.run without a awaiting it, then the command will likely timeout before it's completed.
Other Command Options​
See the base class to get an idea of what methods can be called on a command.
import {Command, Flags} from '@oclif/core'export class MyCommand extends Command {  static summary = 'A brief overview of your command.'  static description = `An in-depth description of the command.It can be multiline.`  // hide the command from help  static hidden = false  // custom usage string for help  // this overrides the default usage  static usage = 'mycommand --myflag'  // examples to add to help  // <%= config.bin %> resolves to the executable name  // <%= command.id %> resolves to the command name  static examples = [    // Examples can be simple strings    '<%= config.bin %> <%= command.id %> --help',    // Or objects that provide a description of the example command    {      description: 'Force the command to execute',      command: '<%= config.bin %> <%= command.id %> --force',    }  ]  // this makes the parser not fail when it receives invalid arguments  // defaults to true  // set it to false if you need to accept a variable number of arguments  static strict = false  // define aliases that can execute this command.  static aliases = ['alternate:name:for:this:command']  // Set to true if you want to add the --json flag to your command.  // oclif will automatically suppress logs (if you use this.log, this.warn, or this.error) and  // display the JSON returned by the command's run method.  static enableJsonFlag = true  async run() {    // show a warning    this.warn('uh oh!')    // exit with an error message    this.error('uh oh!!!')    // exit with status code    this.exit(1)  }}
Command Methods​

Command Methods

this.log(message: string)
this.warn(message: string | Error)
this.error(message: string | Error, options?: {code?: string, exit?: number, ref?: string; suggestions?: string[];})
this.exit(code: number = 0)
this.logToStderr(message: string)
this.jsonEnabled()
this.toSuccessJson(result: unknown)
this.toErrorJson(result: unknown)



The following assumes you are in the run() method of an oclif command.
this.log(message: string)​
Output message to stdout (non-blocking). console.log() works fine too, but that is a blocking call and won't be automatically suppressed when the --json flag is present. This uses util.format() which behaves the same as console.log().
this.log('hello, world!')
this.warn(message: string | Error)​
Display an error or message as a warning
this.warn('uh oh!')this.warn(new Error('uh oh!'))
this.error(message: string | Error, options?: {code?: string, exit?: number, ref?: string; suggestions?: string[];})​
Display error and exit. Also add a code to error object or exit status.
this.error('uh oh!', {exit: 2})this.error(new Error('uh oh!'))
The options object has the following options:

exit — exit code to use
code — a unique error code for the type of error
suggestions —  an array of suggestions for a user to try next that may be useful or provide additional context
ref — a url to documentation related to this error or fixing it

The message, code, suggestions, ref properties will be displayed when an error is shown. Reusable Error classes can be created that display the optional outputs above by implementing the PrettyPrintableError interface from the Errors namespace from @oclif/core and this.error will handle them appropriately.
These errors are friendly and won't show a traceback unless debugging is enabled with DEBUG=*.
import {CLIError} from '@oclif/errors'throw new CLIError('my friendly error')
Any error caught by the command of this CLIError type will be shown without traceback.
this.exit(code: number = 0)​
Exit process. Defaults to status 0.
this.exit()this.exit(1)
this.logToStderr(message: string)​
Log a message to the terminal's stderr.
this.jsonEnabled()​
Returns to true if the --json flag is present and enableJsonFlag is set to true
this.toSuccessJson(result: unknown)​
Modify the command's success JSON output before it's displayed to the user.
this.toErrorJson(result: unknown)​
Modify the command's error JSON output before it's displayed to the user.Edit this pageLast updated on Dec 20, 2024 by Mike DonnalleyPreviousAPI ReferenceNextCommand ArgumentsAvoiding TimeoutsOther Command OptionsCommand Methodsthis.log(message: string)this.warn(message: string | Error)this.error(message: string | Error, options?: {code?: string, exit?: number, ref?: string; suggestions?: string[];})this.exit(code: number = 0)this.logToStderr(message: string)this.jsonEnabled()this.toSuccessJson(result: unknown)this.toErrorJson(result: unknown)\n\n\n\nAPI ReferenceCommandsOn this pageCommandsA basic command looks like the following in TypeScript:
import {Command} from '@oclif/core'export class MyCommand extends Command {  static description = 'description of this example command'  async run(): Promise<void> {    console.log('running my command')  }}
The only part that is required is the run function. Accept user input with arguments and flags.
In JavaScript:
const {Command} = require('@oclif/core')class MyCommand extends Command {  async run() {    console.log('running my command')  }}MyCommand.description = 'description of this example command'module.exports = MyCommand
Note that the following examples will be in TypeScript. As JavaScript does not yet have static class properties, you will have to add them to the class after it is declared like we did with the description above.
Avoiding Timeouts​
In order to avoid command executions running indefinitely, oclif will terminate the node process 10 seconds after Command.run resolves. This means that all command logic inside the run method should either run synchronously or should return a Promise. This will allow the entire command to run before the 10 second timeout starts.
In other words, if you execute a promise in Command.run without a awaiting it, then the command will likely timeout before it's completed.
Other Command Options​
See the base class to get an idea of what methods can be called on a command.
import {Command, Flags} from '@oclif/core'export class MyCommand extends Command {  static summary = 'A brief overview of your command.'  static description = `An in-depth description of the command.It can be multiline.`  // hide the command from help  static hidden = false  // custom usage string for help  // this overrides the default usage  static usage = 'mycommand --myflag'  // examples to add to help  // <%= config.bin %> resolves to the executable name  // <%= command.id %> resolves to the command name  static examples = [    // Examples can be simple strings    '<%= config.bin %> <%= command.id %> --help',    // Or objects that provide a description of the example command    {      description: 'Force the command to execute',      command: '<%= config.bin %> <%= command.id %> --force',    }  ]  // this makes the parser not fail when it receives invalid arguments  // defaults to true  // set it to false if you need to accept a variable number of arguments  static strict = false  // define aliases that can execute this command.  static aliases = ['alternate:name:for:this:command']  // Set to true if you want to add the --json flag to your command.  // oclif will automatically suppress logs (if you use this.log, this.warn, or this.error) and  // display the JSON returned by the command's run method.  static enableJsonFlag = true  async run() {    // show a warning    this.warn('uh oh!')    // exit with an error message    this.error('uh oh!!!')    // exit with status code    this.exit(1)  }}
Command Methods​

Command Methods

this.log(message: string)
this.warn(message: string | Error)
this.error(message: string | Error, options?: {code?: string, exit?: number, ref?: string; suggestions?: string[];})
this.exit(code: number = 0)
this.logToStderr(message: string)
this.jsonEnabled()
this.toSuccessJson(result: unknown)
this.toErrorJson(result: unknown)



The following assumes you are in the run() method of an oclif command.
this.log(message: string)​
Output message to stdout (non-blocking). console.log() works fine too, but that is a blocking call and won't be automatically suppressed when the --json flag is present. This uses util.format() which behaves the same as console.log().
this.log('hello, world!')
this.warn(message: string | Error)​
Display an error or message as a warning
this.warn('uh oh!')this.warn(new Error('uh oh!'))
this.error(message: string | Error, options?: {code?: string, exit?: number, ref?: string; suggestions?: string[];})​
Display error and exit. Also add a code to error object or exit status.
this.error('uh oh!', {exit: 2})this.error(new Error('uh oh!'))
The options object has the following options:

exit — exit code to use
code — a unique error code for the type of error
suggestions —  an array of suggestions for a user to try next that may be useful or provide additional context
ref — a url to documentation related to this error or fixing it

The message, code, suggestions, ref properties will be displayed when an error is shown. Reusable Error classes can be created that display the optional outputs above by implementing the PrettyPrintableError interface from the Errors namespace from @oclif/core and this.error will handle them appropriately.
These errors are friendly and won't show a traceback unless debugging is enabled with DEBUG=*.
import {CLIError} from '@oclif/errors'throw new CLIError('my friendly error')
Any error caught by the command of this CLIError type will be shown without traceback.
this.exit(code: number = 0)​
Exit process. Defaults to status 0.
this.exit()this.exit(1)
this.logToStderr(message: string)​
Log a message to the terminal's stderr.
this.jsonEnabled()​
Returns to true if the --json flag is present and enableJsonFlag is set to true
this.toSuccessJson(result: unknown)​
Modify the command's success JSON output before it's displayed to the user.
this.toErrorJson(result: unknown)​
Modify the command's error JSON output before it's displayed to the user.Edit this pageLast updated on Dec 20, 2024 by Mike Donnalley\n\nAPI ReferenceCommandsOn this pageCommandsA basic command looks like the following in TypeScript:
import {Command} from '@oclif/core'export class MyCommand extends Command {  static description = 'description of this example command'  async run(): Promise<void> {    console.log('running my command')  }}
The only part that is required is the run function. Accept user input with arguments and flags.
In JavaScript:
const {Command} = require('@oclif/core')class MyCommand extends Command {  async run() {    console.log('running my command')  }}MyCommand.description = 'description of this example command'module.exports = MyCommand
Note that the following examples will be in TypeScript. As JavaScript does not yet have static class properties, you will have to add them to the class after it is declared like we did with the description above.
Avoiding Timeouts​
In order to avoid command executions running indefinitely, oclif will terminate the node process 10 seconds after Command.run resolves. This means that all command logic inside the run method should either run synchronously or should return a Promise. This will allow the entire command to run before the 10 second timeout starts.
In other words, if you execute a promise in Command.run without a awaiting it, then the command will likely timeout before it's completed.
Other Command Options​
See the base class to get an idea of what methods can be called on a command.
import {Command, Flags} from '@oclif/core'export class MyCommand extends Command {  static summary = 'A brief overview of your command.'  static description = `An in-depth description of the command.It can be multiline.`  // hide the command from help  static hidden = false  // custom usage string for help  // this overrides the default usage  static usage = 'mycommand --myflag'  // examples to add to help  // <%= config.bin %> resolves to the executable name  // <%= command.id %> resolves to the command name  static examples = [    // Examples can be simple strings    '<%= config.bin %> <%= command.id %> --help',    // Or objects that provide a description of the example command    {      description: 'Force the command to execute',      command: '<%= config.bin %> <%= command.id %> --force',    }  ]  // this makes the parser not fail when it receives invalid arguments  // defaults to true  // set it to false if you need to accept a variable number of arguments  static strict = false  // define aliases that can execute this command.  static aliases = ['alternate:name:for:this:command']  // Set to true if you want to add the --json flag to your command.  // oclif will automatically suppress logs (if you use this.log, this.warn, or this.error) and  // display the JSON returned by the command's run method.  static enableJsonFlag = true  async run() {    // show a warning    this.warn('uh oh!')    // exit with an error message    this.error('uh oh!!!')    // exit with status code    this.exit(1)  }}
Command Methods​

Command Methods

this.log(message: string)
this.warn(message: string | Error)
this.error(message: string | Error, options?: {code?: string, exit?: number, ref?: string; suggestions?: string[];})
this.exit(code: number = 0)
this.logToStderr(message: string)
this.jsonEnabled()
this.toSuccessJson(result: unknown)
this.toErrorJson(result: unknown)



The following assumes you are in the run() method of an oclif command.
this.log(message: string)​
Output message to stdout (non-blocking). console.log() works fine too, but that is a blocking call and won't be automatically suppressed when the --json flag is present. This uses util.format() which behaves the same as console.log().
this.log('hello, world!')
this.warn(message: string | Error)​
Display an error or message as a warning
this.warn('uh oh!')this.warn(new Error('uh oh!'))
this.error(message: string | Error, options?: {code?: string, exit?: number, ref?: string; suggestions?: string[];})​
Display error and exit. Also add a code to error object or exit status.
this.error('uh oh!', {exit: 2})this.error(new Error('uh oh!'))
The options object has the following options:

exit — exit code to use
code — a unique error code for the type of error
suggestions —  an array of suggestions for a user to try next that may be useful or provide additional context
ref — a url to documentation related to this error or fixing it

The message, code, suggestions, ref properties will be displayed when an error is shown. Reusable Error classes can be created that display the optional outputs above by implementing the PrettyPrintableError interface from the Errors namespace from @oclif/core and this.error will handle them appropriately.
These errors are friendly and won't show a traceback unless debugging is enabled with DEBUG=*.
import {CLIError} from '@oclif/errors'throw new CLIError('my friendly error')
Any error caught by the command of this CLIError type will be shown without traceback.
this.exit(code: number = 0)​
Exit process. Defaults to status 0.
this.exit()this.exit(1)
this.logToStderr(message: string)​
Log a message to the terminal's stderr.
this.jsonEnabled()​
Returns to true if the --json flag is present and enableJsonFlag is set to true
this.toSuccessJson(result: unknown)​
Modify the command's success JSON output before it's displayed to the user.
this.toErrorJson(result: unknown)​
Modify the command's error JSON output before it's displayed to the user.Edit this pageLast updated on Dec 20, 2024 by Mike DonnalleyPreviousAPI ReferenceNextCommand ArgumentsAvoiding TimeoutsOther Command OptionsCommand Methodsthis.log(message: string)this.warn(message: string | Error)this.error(message: string | Error, options?: {code?: string, exit?: number, ref?: string; suggestions?: string[];})this.exit(code: number = 0)this.logToStderr(message: string)this.jsonEnabled()this.toSuccessJson(result: unknown)this.toErrorJson(result: unknown)\n\n\n\nAPI ReferenceCommandsOn this pageCommandsA basic command looks like the following in TypeScript:
import {Command} from '@oclif/core'export class MyCommand extends Command {  static description = 'description of this example command'  async run(): Promise<void> {    console.log('running my command')  }}
The only part that is required is the run function. Accept user input with arguments and flags.
In JavaScript:
const {Command} = require('@oclif/core')class MyCommand extends Command {  async run() {    console.log('running my command')  }}MyCommand.description = 'description of this example command'module.exports = MyCommand
Note that the following examples will be in TypeScript. As JavaScript does not yet have static class properties, you will have to add them to the class after it is declared like we did with the description above.
Avoiding Timeouts​
In order to avoid command executions running indefinitely, oclif will terminate the node process 10 seconds after Command.run resolves. This means that all command logic inside the run method should either run synchronously or should return a Promise. This will allow the entire command to run before the 10 second timeout starts.
In other words, if you execute a promise in Command.run without a awaiting it, then the command will likely timeout before it's completed.
Other Command Options​
See the base class to get an idea of what methods can be called on a command.
import {Command, Flags} from '@oclif/core'export class MyCommand extends Command {  static summary = 'A brief overview of your command.'  static description = `An in-depth description of the command.It can be multiline.`  // hide the command from help  static hidden = false  // custom usage string for help  // this overrides the default usage  static usage = 'mycommand --myflag'  // examples to add to help  // <%= config.bin %> resolves to the executable name  // <%= command.id %> resolves to the command name  static examples = [    // Examples can be simple strings    '<%= config.bin %> <%= command.id %> --help',    // Or objects that provide a description of the example command    {      description: 'Force the command to execute',      command: '<%= config.bin %> <%= command.id %> --force',    }  ]  // this makes the parser not fail when it receives invalid arguments  // defaults to true  // set it to false if you need to accept a variable number of arguments  static strict = false  // define aliases that can execute this command.  static aliases = ['alternate:name:for:this:command']  // Set to true if you want to add the --json flag to your command.  // oclif will automatically suppress logs (if you use this.log, this.warn, or this.error) and  // display the JSON returned by the command's run method.  static enableJsonFlag = true  async run() {    // show a warning    this.warn('uh oh!')    // exit with an error message    this.error('uh oh!!!')    // exit with status code    this.exit(1)  }}
Command Methods​

Command Methods

this.log(message: string)
this.warn(message: string | Error)
this.error(message: string | Error, options?: {code?: string, exit?: number, ref?: string; suggestions?: string[];})
this.exit(code: number = 0)
this.logToStderr(message: string)
this.jsonEnabled()
this.toSuccessJson(result: unknown)
this.toErrorJson(result: unknown)



The following assumes you are in the run() method of an oclif command.
this.log(message: string)​
Output message to stdout (non-blocking). console.log() works fine too, but that is a blocking call and won't be automatically suppressed when the --json flag is present. This uses util.format() which behaves the same as console.log().
this.log('hello, world!')
this.warn(message: string | Error)​
Display an error or message as a warning
this.warn('uh oh!')this.warn(new Error('uh oh!'))
this.error(message: string | Error, options?: {code?: string, exit?: number, ref?: string; suggestions?: string[];})​
Display error and exit. Also add a code to error object or exit status.
this.error('uh oh!', {exit: 2})this.error(new Error('uh oh!'))
The options object has the following options:

exit — exit code to use
code — a unique error code for the type of error
suggestions —  an array of suggestions for a user to try next that may be useful or provide additional context
ref — a url to documentation related to this error or fixing it

The message, code, suggestions, ref properties will be displayed when an error is shown. Reusable Error classes can be created that display the optional outputs above by implementing the PrettyPrintableError interface from the Errors namespace from @oclif/core and this.error will handle them appropriately.
These errors are friendly and won't show a traceback unless debugging is enabled with DEBUG=*.
import {CLIError} from '@oclif/errors'throw new CLIError('my friendly error')
Any error caught by the command of this CLIError type will be shown without traceback.
this.exit(code: number = 0)​
Exit process. Defaults to status 0.
this.exit()this.exit(1)
this.logToStderr(message: string)​
Log a message to the terminal's stderr.
this.jsonEnabled()​
Returns to true if the --json flag is present and enableJsonFlag is set to true
this.toSuccessJson(result: unknown)​
Modify the command's success JSON output before it's displayed to the user.
this.toErrorJson(result: unknown)​
Modify the command's error JSON output before it's displayed to the user.Edit this pageLast updated on Dec 20, 2024 by Mike Donnalley\n\nAPI ReferenceCommandsOn this pageCommandsA basic command looks like the following in TypeScript:
import {Command} from '@oclif/core'export class MyCommand extends Command {  static description = 'description of this example command'  async run(): Promise<void> {    console.log('running my command')  }}
The only part that is required is the run function. Accept user input with arguments and flags.
In JavaScript:
const {Command} = require('@oclif/core')class MyCommand extends Command {  async run() {    console.log('running my command')  }}MyCommand.description = 'description of this example command'module.exports = MyCommand
Note that the following examples will be in TypeScript. As JavaScript does not yet have static class properties, you will have to add them to the class after it is declared like we did with the description above.
Avoiding Timeouts​
In order to avoid command executions running indefinitely, oclif will terminate the node process 10 seconds after Command.run resolves. This means that all command logic inside the run method should either run synchronously or should return a Promise. This will allow the entire command to run before the 10 second timeout starts.
In other words, if you execute a promise in Command.run without a awaiting it, then the command will likely timeout before it's completed.
Other Command Options​
See the base class to get an idea of what methods can be called on a command.
import {Command, Flags} from '@oclif/core'export class MyCommand extends Command {  static summary = 'A brief overview of your command.'  static description = `An in-depth description of the command.It can be multiline.`  // hide the command from help  static hidden = false  // custom usage string for help  // this overrides the default usage  static usage = 'mycommand --myflag'  // examples to add to help  // <%= config.bin %> resolves to the executable name  // <%= command.id %> resolves to the command name  static examples = [    // Examples can be simple strings    '<%= config.bin %> <%= command.id %> --help',    // Or objects that provide a description of the example command    {      description: 'Force the command to execute',      command: '<%= config.bin %> <%= command.id %> --force',    }  ]  // this makes the parser not fail when it receives invalid arguments  // defaults to true  // set it to false if you need to accept a variable number of arguments  static strict = false  // define aliases that can execute this command.  static aliases = ['alternate:name:for:this:command']  // Set to true if you want to add the --json flag to your command.  // oclif will automatically suppress logs (if you use this.log, this.warn, or this.error) and  // display the JSON returned by the command's run method.  static enableJsonFlag = true  async run() {    // show a warning    this.warn('uh oh!')    // exit with an error message    this.error('uh oh!!!')    // exit with status code    this.exit(1)  }}
Command Methods​

Command Methods

this.log(message: string)
this.warn(message: string | Error)
this.error(message: string | Error, options?: {code?: string, exit?: number, ref?: string; suggestions?: string[];})
this.exit(code: number = 0)
this.logToStderr(message: string)
this.jsonEnabled()
this.toSuccessJson(result: unknown)
this.toErrorJson(result: unknown)



The following assumes you are in the run() method of an oclif command.
this.log(message: string)​
Output message to stdout (non-blocking). console.log() works fine too, but that is a blocking call and won't be automatically suppressed when the --json flag is present. This uses util.format() which behaves the same as console.log().
this.log('hello, world!')
this.warn(message: string | Error)​
Display an error or message as a warning
this.warn('uh oh!')this.warn(new Error('uh oh!'))
this.error(message: string | Error, options?: {code?: string, exit?: number, ref?: string; suggestions?: string[];})​
Display error and exit. Also add a code to error object or exit status.
this.error('uh oh!', {exit: 2})this.error(new Error('uh oh!'))
The options object has the following options:

exit — exit code to use
code — a unique error code for the type of error
suggestions —  an array of suggestions for a user to try next that may be useful or provide additional context
ref — a url to documentation related to this error or fixing it

The message, code, suggestions, ref properties will be displayed when an error is shown. Reusable Error classes can be created that display the optional outputs above by implementing the PrettyPrintableError interface from the Errors namespace from @oclif/core and this.error will handle them appropriately.
These errors are friendly and won't show a traceback unless debugging is enabled with DEBUG=*.
import {CLIError} from '@oclif/errors'throw new CLIError('my friendly error')
Any error caught by the command of this CLIError type will be shown without traceback.
this.exit(code: number = 0)​
Exit process. Defaults to status 0.
this.exit()this.exit(1)
this.logToStderr(message: string)​
Log a message to the terminal's stderr.
this.jsonEnabled()​
Returns to true if the --json flag is present and enableJsonFlag is set to true
this.toSuccessJson(result: unknown)​
Modify the command's success JSON output before it's displayed to the user.
this.toErrorJson(result: unknown)​
Modify the command's error JSON output before it's displayed to the user.Edit this pageLast updated on Dec 20, 2024 by Mike DonnalleyPreviousAPI ReferenceNextCommand ArgumentsAvoiding TimeoutsOther Command OptionsCommand Methodsthis.log(message: string)this.warn(message: string | Error)this.error(message: string | Error, options?: {code?: string, exit?: number, ref?: string; suggestions?: string[];})this.exit(code: number = 0)this.logToStderr(message: string)this.jsonEnabled()this.toSuccessJson(result: unknown)this.toErrorJson(result: unknown)\n\n\n\nAPI ReferenceCommandsOn this pageCommandsA basic command looks like the following in TypeScript:
import {Command} from '@oclif/core'export class MyCommand extends Command {  static description = 'description of this example command'  async run(): Promise<void> {    console.log('running my command')  }}
The only part that is required is the run function. Accept user input with arguments and flags.
In JavaScript:
const {Command} = require('@oclif/core')class MyCommand extends Command {  async run() {    console.log('running my command')  }}MyCommand.description = 'description of this example command'module.exports = MyCommand
Note that the following examples will be in TypeScript. As JavaScript does not yet have static class properties, you will have to add them to the class after it is declared like we did with the description above.
Avoiding Timeouts​
In order to avoid command executions running indefinitely, oclif will terminate the node process 10 seconds after Command.run resolves. This means that all command logic inside the run method should either run synchronously or should return a Promise. This will allow the entire command to run before the 10 second timeout starts.
In other words, if you execute a promise in Command.run without a awaiting it, then the command will likely timeout before it's completed.
Other Command Options​
See the base class to get an idea of what methods can be called on a command.
import {Command, Flags} from '@oclif/core'export class MyCommand extends Command {  static summary = 'A brief overview of your command.'  static description = `An in-depth description of the command.It can be multiline.`  // hide the command from help  static hidden = false  // custom usage string for help  // this overrides the default usage  static usage = 'mycommand --myflag'  // examples to add to help  // <%= config.bin %> resolves to the executable name  // <%= command.id %> resolves to the command name  static examples = [    // Examples can be simple strings    '<%= config.bin %> <%= command.id %> --help',    // Or objects that provide a description of the example command    {      description: 'Force the command to execute',      command: '<%= config.bin %> <%= command.id %> --force',    }  ]  // this makes the parser not fail when it receives invalid arguments  // defaults to true  // set it to false if you need to accept a variable number of arguments  static strict = false  // define aliases that can execute this command.  static aliases = ['alternate:name:for:this:command']  // Set to true if you want to add the --json flag to your command.  // oclif will automatically suppress logs (if you use this.log, this.warn, or this.error) and  // display the JSON returned by the command's run method.  static enableJsonFlag = true  async run() {    // show a warning    this.warn('uh oh!')    // exit with an error message    this.error('uh oh!!!')    // exit with status code    this.exit(1)  }}
Command Methods​

Command Methods

this.log(message: string)
this.warn(message: string | Error)
this.error(message: string | Error, options?: {code?: string, exit?: number, ref?: string; suggestions?: string[];})
this.exit(code: number = 0)
this.logToStderr(message: string)
this.jsonEnabled()
this.toSuccessJson(result: unknown)
this.toErrorJson(result: unknown)



The following assumes you are in the run() method of an oclif command.
this.log(message: string)​
Output message to stdout (non-blocking). console.log() works fine too, but that is a blocking call and won't be automatically suppressed when the --json flag is present. This uses util.format() which behaves the same as console.log().
this.log('hello, world!')
this.warn(message: string | Error)​
Display an error or message as a warning
this.warn('uh oh!')this.warn(new Error('uh oh!'))
this.error(message: string | Error, options?: {code?: string, exit?: number, ref?: string; suggestions?: string[];})​
Display error and exit. Also add a code to error object or exit status.
this.error('uh oh!', {exit: 2})this.error(new Error('uh oh!'))
The options object has the following options:

exit — exit code to use
code — a unique error code for the type of error
suggestions —  an array of suggestions for a user to try next that may be useful or provide additional context
ref — a url to documentation related to this error or fixing it

The message, code, suggestions, ref properties will be displayed when an error is shown. Reusable Error classes can be created that display the optional outputs above by implementing the PrettyPrintableError interface from the Errors namespace from @oclif/core and this.error will handle them appropriately.
These errors are friendly and won't show a traceback unless debugging is enabled with DEBUG=*.
import {CLIError} from '@oclif/errors'throw new CLIError('my friendly error')
Any error caught by the command of this CLIError type will be shown without traceback.
this.exit(code: number = 0)​
Exit process. Defaults to status 0.
this.exit()this.exit(1)
this.logToStderr(message: string)​
Log a message to the terminal's stderr.
this.jsonEnabled()​
Returns to true if the --json flag is present and enableJsonFlag is set to true
this.toSuccessJson(result: unknown)​
Modify the command's success JSON output before it's displayed to the user.
this.toErrorJson(result: unknown)​
Modify the command's error JSON output before it's displayed to the user.Edit this pageLast updated on Dec 20, 2024 by Mike Donnalley\n\nAPI ReferenceCommandsOn this pageCommandsA basic command looks like the following in TypeScript:
import {Command} from '@oclif/core'export class MyCommand extends Command {  static description = 'description of this example command'  async run(): Promise<void> {    console.log('running my command')  }}
The only part that is required is the run function. Accept user input with arguments and flags.
In JavaScript:
const {Command} = require('@oclif/core')class MyCommand extends Command {  async run() {    console.log('running my command')  }}MyCommand.description = 'description of this example command'module.exports = MyCommand
Note that the following examples will be in TypeScript. As JavaScript does not yet have static class properties, you will have to add them to the class after it is declared like we did with the description above.
Avoiding Timeouts​
In order to avoid command executions running indefinitely, oclif will terminate the node process 10 seconds after Command.run resolves. This means that all command logic inside the run method should either run synchronously or should return a Promise. This will allow the entire command to run before the 10 second timeout starts.
In other words, if you execute a promise in Command.run without a awaiting it, then the command will likely timeout before it's completed.
Other Command Options​
See the base class to get an idea of what methods can be called on a command.
import {Command, Flags} from '@oclif/core'export class MyCommand extends Command {  static summary = 'A brief overview of your command.'  static description = `An in-depth description of the command.It can be multiline.`  // hide the command from help  static hidden = false  // custom usage string for help  // this overrides the default usage  static usage = 'mycommand --myflag'  // examples to add to help  // <%= config.bin %> resolves to the executable name  // <%= command.id %> resolves to the command name  static examples = [    // Examples can be simple strings    '<%= config.bin %> <%= command.id %> --help',    // Or objects that provide a description of the example command    {      description: 'Force the command to execute',      command: '<%= config.bin %> <%= command.id %> --force',    }  ]  // this makes the parser not fail when it receives invalid arguments  // defaults to true  // set it to false if you need to accept a variable number of arguments  static strict = false  // define aliases that can execute this command.  static aliases = ['alternate:name:for:this:command']  // Set to true if you want to add the --json flag to your command.  // oclif will automatically suppress logs (if you use this.log, this.warn, or this.error) and  // display the JSON returned by the command's run method.  static enableJsonFlag = true  async run() {    // show a warning    this.warn('uh oh!')    // exit with an error message    this.error('uh oh!!!')    // exit with status code    this.exit(1)  }}
Command Methods​

Command Methods

this.log(message: string)
this.warn(message: string | Error)
this.error(message: string | Error, options?: {code?: string, exit?: number, ref?: string; suggestions?: string[];})
this.exit(code: number = 0)
this.logToStderr(message: string)
this.jsonEnabled()
this.toSuccessJson(result: unknown)
this.toErrorJson(result: unknown)



The following assumes you are in the run() method of an oclif command.
this.log(message: string)​
Output message to stdout (non-blocking). console.log() works fine too, but that is a blocking call and won't be automatically suppressed when the --json flag is present. This uses util.format() which behaves the same as console.log().
this.log('hello, world!')
this.warn(message: string | Error)​
Display an error or message as a warning
this.warn('uh oh!')this.warn(new Error('uh oh!'))
this.error(message: string | Error, options?: {code?: string, exit?: number, ref?: string; suggestions?: string[];})​
Display error and exit. Also add a code to error object or exit status.
this.error('uh oh!', {exit: 2})this.error(new Error('uh oh!'))
The options object has the following options:

exit — exit code to use
code — a unique error code for the type of error
suggestions —  an array of suggestions for a user to try next that may be useful or provide additional context
ref — a url to documentation related to this error or fixing it

The message, code, suggestions, ref properties will be displayed when an error is shown. Reusable Error classes can be created that display the optional outputs above by implementing the PrettyPrintableError interface from the Errors namespace from @oclif/core and this.error will handle them appropriately.
These errors are friendly and won't show a traceback unless debugging is enabled with DEBUG=*.
import {CLIError} from '@oclif/errors'throw new CLIError('my friendly error')
Any error caught by the command of this CLIError type will be shown without traceback.
this.exit(code: number = 0)​
Exit process. Defaults to status 0.
this.exit()this.exit(1)
this.logToStderr(message: string)​
Log a message to the terminal's stderr.
this.jsonEnabled()​
Returns to true if the --json flag is present and enableJsonFlag is set to true
this.toSuccessJson(result: unknown)​
Modify the command's success JSON output before it's displayed to the user.
this.toErrorJson(result: unknown)​
Modify the command's error JSON output before it's displayed to the user.Edit this pageLast updated on Dec 20, 2024 by Mike DonnalleyPreviousAPI ReferenceNextCommand ArgumentsAvoiding TimeoutsOther Command OptionsCommand Methodsthis.log(message: string)this.warn(message: string | Error)this.error(message: string | Error, options?: {code?: string, exit?: number, ref?: string; suggestions?: string[];})this.exit(code: number = 0)this.logToStderr(message: string)this.jsonEnabled()this.toSuccessJson(result: unknown)this.toErrorJson(result: unknown)\n\n\n\nAPI ReferenceCommandsOn this pageCommandsA basic command looks like the following in TypeScript:
import {Command} from '@oclif/core'export class MyCommand extends Command {  static description = 'description of this example command'  async run(): Promise<void> {    console.log('running my command')  }}
The only part that is required is the run function. Accept user input with arguments and flags.
In JavaScript:
const {Command} = require('@oclif/core')class MyCommand extends Command {  async run() {    console.log('running my command')  }}MyCommand.description = 'description of this example command'module.exports = MyCommand
Note that the following examples will be in TypeScript. As JavaScript does not yet have static class properties, you will have to add them to the class after it is declared like we did with the description above.
Avoiding Timeouts​
In order to avoid command executions running indefinitely, oclif will terminate the node process 10 seconds after Command.run resolves. This means that all command logic inside the run method should either run synchronously or should return a Promise. This will allow the entire command to run before the 10 second timeout starts.
In other words, if you execute a promise in Command.run without a awaiting it, then the command will likely timeout before it's completed.
Other Command Options​
See the base class to get an idea of what methods can be called on a command.
import {Command, Flags} from '@oclif/core'export class MyCommand extends Command {  static summary = 'A brief overview of your command.'  static description = `An in-depth description of the command.It can be multiline.`  // hide the command from help  static hidden = false  // custom usage string for help  // this overrides the default usage  static usage = 'mycommand --myflag'  // examples to add to help  // <%= config.bin %> resolves to the executable name  // <%= command.id %> resolves to the command name  static examples = [    // Examples can be simple strings    '<%= config.bin %> <%= command.id %> --help',    // Or objects that provide a description of the example command    {      description: 'Force the command to execute',      command: '<%= config.bin %> <%= command.id %> --force',    }  ]  // this makes the parser not fail when it receives invalid arguments  // defaults to true  // set it to false if you need to accept a variable number of arguments  static strict = false  // define aliases that can execute this command.  static aliases = ['alternate:name:for:this:command']  // Set to true if you want to add the --json flag to your command.  // oclif will automatically suppress logs (if you use this.log, this.warn, or this.error) and  // display the JSON returned by the command's run method.  static enableJsonFlag = true  async run() {    // show a warning    this.warn('uh oh!')    // exit with an error message    this.error('uh oh!!!')    // exit with status code    this.exit(1)  }}
Command Methods​

Command Methods

this.log(message: string)
this.warn(message: string | Error)
this.error(message: string | Error, options?: {code?: string, exit?: number, ref?: string; suggestions?: string[];})
this.exit(code: number = 0)
this.logToStderr(message: string)
this.jsonEnabled()
this.toSuccessJson(result: unknown)
this.toErrorJson(result: unknown)



The following assumes you are in the run() method of an oclif command.
this.log(message: string)​
Output message to stdout (non-blocking). console.log() works fine too, but that is a blocking call and won't be automatically suppressed when the --json flag is present. This uses util.format() which behaves the same as console.log().
this.log('hello, world!')
this.warn(message: string | Error)​
Display an error or message as a warning
this.warn('uh oh!')this.warn(new Error('uh oh!'))
this.error(message: string | Error, options?: {code?: string, exit?: number, ref?: string; suggestions?: string[];})​
Display error and exit. Also add a code to error object or exit status.
this.error('uh oh!', {exit: 2})this.error(new Error('uh oh!'))
The options object has the following options:

exit — exit code to use
code — a unique error code for the type of error
suggestions —  an array of suggestions for a user to try next that may be useful or provide additional context
ref — a url to documentation related to this error or fixing it

The message, code, suggestions, ref properties will be displayed when an error is shown. Reusable Error classes can be created that display the optional outputs above by implementing the PrettyPrintableError interface from the Errors namespace from @oclif/core and this.error will handle them appropriately.
These errors are friendly and won't show a traceback unless debugging is enabled with DEBUG=*.
import {CLIError} from '@oclif/errors'throw new CLIError('my friendly error')
Any error caught by the command of this CLIError type will be shown without traceback.
this.exit(code: number = 0)​
Exit process. Defaults to status 0.
this.exit()this.exit(1)
this.logToStderr(message: string)​
Log a message to the terminal's stderr.
this.jsonEnabled()​
Returns to true if the --json flag is present and enableJsonFlag is set to true
this.toSuccessJson(result: unknown)​
Modify the command's success JSON output before it's displayed to the user.
this.toErrorJson(result: unknown)​
Modify the command's error JSON output before it's displayed to the user.Edit this pageLast updated on Dec 20, 2024 by Mike Donnalley\n\nAPI ReferenceCommandsOn this pageCommandsA basic command looks like the following in TypeScript:
import {Command} from '@oclif/core'export class MyCommand extends Command {  static description = 'description of this example command'  async run(): Promise<void> {    console.log('running my command')  }}
The only part that is required is the run function. Accept user input with arguments and flags.
In JavaScript:
const {Command} = require('@oclif/core')class MyCommand extends Command {  async run() {    console.log('running my command')  }}MyCommand.description = 'description of this example command'module.exports = MyCommand
Note that the following examples will be in TypeScript. As JavaScript does not yet have static class properties, you will have to add them to the class after it is declared like we did with the description above.
Avoiding Timeouts​
In order to avoid command executions running indefinitely, oclif will terminate the node process 10 seconds after Command.run resolves. This means that all command logic inside the run method should either run synchronously or should return a Promise. This will allow the entire command to run before the 10 second timeout starts.
In other words, if you execute a promise in Command.run without a awaiting it, then the command will likely timeout before it's completed.
Other Command Options​
See the base class to get an idea of what methods can be called on a command.
import {Command, Flags} from '@oclif/core'export class MyCommand extends Command {  static summary = 'A brief overview of your command.'  static description = `An in-depth description of the command.It can be multiline.`  // hide the command from help  static hidden = false  // custom usage string for help  // this overrides the default usage  static usage = 'mycommand --myflag'  // examples to add to help  // <%= config.bin %> resolves to the executable name  // <%= command.id %> resolves to the command name  static examples = [    // Examples can be simple strings    '<%= config.bin %> <%= command.id %> --help',    // Or objects that provide a description of the example command    {      description: 'Force the command to execute',      command: '<%= config.bin %> <%= command.id %> --force',    }  ]  // this makes the parser not fail when it receives invalid arguments  // defaults to true  // set it to false if you need to accept a variable number of arguments  static strict = false  // define aliases that can execute this command.  static aliases = ['alternate:name:for:this:command']  // Set to true if you want to add the --json flag to your command.  // oclif will automatically suppress logs (if you use this.log, this.warn, or this.error) and  // display the JSON returned by the command's run method.  static enableJsonFlag = true  async run() {    // show a warning    this.warn('uh oh!')    // exit with an error message    this.error('uh oh!!!')    // exit with status code    this.exit(1)  }}
Command Methods​

Command Methods

this.log(message: string)
this.warn(message: string | Error)
this.error(message: string | Error, options?: {code?: string, exit?: number, ref?: string; suggestions?: string[];})
this.exit(code: number = 0)
this.logToStderr(message: string)
this.jsonEnabled()
this.toSuccessJson(result: unknown)
this.toErrorJson(result: unknown)



The following assumes you are in the run() method of an oclif command.
this.log(message: string)​
Output message to stdout (non-blocking). console.log() works fine too, but that is a blocking call and won't be automatically suppressed when the --json flag is present. This uses util.format() which behaves the same as console.log().
this.log('hello, world!')
this.warn(message: string | Error)​
Display an error or message as a warning
this.warn('uh oh!')this.warn(new Error('uh oh!'))
this.error(message: string | Error, options?: {code?: string, exit?: number, ref?: string; suggestions?: string[];})​
Display error and exit. Also add a code to error object or exit status.
this.error('uh oh!', {exit: 2})this.error(new Error('uh oh!'))
The options object has the following options:

exit — exit code to use
code — a unique error code for the type of error
suggestions —  an array of suggestions for a user to try next that may be useful or provide additional context
ref — a url to documentation related to this error or fixing it

The message, code, suggestions, ref properties will be displayed when an error is shown. Reusable Error classes can be created that display the optional outputs above by implementing the PrettyPrintableError interface from the Errors namespace from @oclif/core and this.error will handle them appropriately.
These errors are friendly and won't show a traceback unless debugging is enabled with DEBUG=*.
import {CLIError} from '@oclif/errors'throw new CLIError('my friendly error')
Any error caught by the command of this CLIError type will be shown without traceback.
this.exit(code: number = 0)​
Exit process. Defaults to status 0.
this.exit()this.exit(1)
this.logToStderr(message: string)​
Log a message to the terminal's stderr.
this.jsonEnabled()​
Returns to true if the --json flag is present and enableJsonFlag is set to true
this.toSuccessJson(result: unknown)​
Modify the command's success JSON output before it's displayed to the user.
this.toErrorJson(result: unknown)​
Modify the command's error JSON output before it's displayed to the user.Edit this pageLast updated on Dec 20, 2024 by Mike DonnalleyPreviousAPI ReferenceNextCommand ArgumentsAvoiding TimeoutsOther Command OptionsCommand Methodsthis.log(message: string)this.warn(message: string | Error)this.error(message: string | Error, options?: {code?: string, exit?: number, ref?: string; suggestions?: string[];})this.exit(code: number = 0)this.logToStderr(message: string)this.jsonEnabled()this.toSuccessJson(result: unknown)this.toErrorJson(result: unknown)\n\n\n\nAPI ReferenceCommandsOn this pageCommandsA basic command looks like the following in TypeScript:
import {Command} from '@oclif/core'export class MyCommand extends Command {  static description = 'description of this example command'  async run(): Promise<void> {    console.log('running my command')  }}
The only part that is required is the run function. Accept user input with arguments and flags.
In JavaScript:
const {Command} = require('@oclif/core')class MyCommand extends Command {  async run() {    console.log('running my command')  }}MyCommand.description = 'description of this example command'module.exports = MyCommand
Note that the following examples will be in TypeScript. As JavaScript does not yet have static class properties, you will have to add them to the class after it is declared like we did with the description above.
Avoiding Timeouts​
In order to avoid command executions running indefinitely, oclif will terminate the node process 10 seconds after Command.run resolves. This means that all command logic inside the run method should either run synchronously or should return a Promise. This will allow the entire command to run before the 10 second timeout starts.
In other words, if you execute a promise in Command.run without a awaiting it, then the command will likely timeout before it's completed.
Other Command Options​
See the base class to get an idea of what methods can be called on a command.
import {Command, Flags} from '@oclif/core'export class MyCommand extends Command {  static summary = 'A brief overview of your command.'  static description = `An in-depth description of the command.It can be multiline.`  // hide the command from help  static hidden = false  // custom usage string for help  // this overrides the default usage  static usage = 'mycommand --myflag'  // examples to add to help  // <%= config.bin %> resolves to the executable name  // <%= command.id %> resolves to the command name  static examples = [    // Examples can be simple strings    '<%= config.bin %> <%= command.id %> --help',    // Or objects that provide a description of the example command    {      description: 'Force the command to execute',      command: '<%= config.bin %> <%= command.id %> --force',    }  ]  // this makes the parser not fail when it receives invalid arguments  // defaults to true  // set it to false if you need to accept a variable number of arguments  static strict = false  // define aliases that can execute this command.  static aliases = ['alternate:name:for:this:command']  // Set to true if you want to add the --json flag to your command.  // oclif will automatically suppress logs (if you use this.log, this.warn, or this.error) and  // display the JSON returned by the command's run method.  static enableJsonFlag = true  async run() {    // show a warning    this.warn('uh oh!')    // exit with an error message    this.error('uh oh!!!')    // exit with status code    this.exit(1)  }}
Command Methods​

Command Methods

this.log(message: string)
this.warn(message: string | Error)
this.error(message: string | Error, options?: {code?: string, exit?: number, ref?: string; suggestions?: string[];})
this.exit(code: number = 0)
this.logToStderr(message: string)
this.jsonEnabled()
this.toSuccessJson(result: unknown)
this.toErrorJson(result: unknown)



The following assumes you are in the run() method of an oclif command.
this.log(message: string)​
Output message to stdout (non-blocking). console.log() works fine too, but that is a blocking call and won't be automatically suppressed when the --json flag is present. This uses util.format() which behaves the same as console.log().
this.log('hello, world!')
this.warn(message: string | Error)​
Display an error or message as a warning
this.warn('uh oh!')this.warn(new Error('uh oh!'))
this.error(message: string | Error, options?: {code?: string, exit?: number, ref?: string; suggestions?: string[];})​
Display error and exit. Also add a code to error object or exit status.
this.error('uh oh!', {exit: 2})this.error(new Error('uh oh!'))
The options object has the following options:

exit — exit code to use
code — a unique error code for the type of error
suggestions —  an array of suggestions for a user to try next that may be useful or provide additional context
ref — a url to documentation related to this error or fixing it

The message, code, suggestions, ref properties will be displayed when an error is shown. Reusable Error classes can be created that display the optional outputs above by implementing the PrettyPrintableError interface from the Errors namespace from @oclif/core and this.error will handle them appropriately.
These errors are friendly and won't show a traceback unless debugging is enabled with DEBUG=*.
import {CLIError} from '@oclif/errors'throw new CLIError('my friendly error')
Any error caught by the command of this CLIError type will be shown without traceback.
this.exit(code: number = 0)​
Exit process. Defaults to status 0.
this.exit()this.exit(1)
this.logToStderr(message: string)​
Log a message to the terminal's stderr.
this.jsonEnabled()​
Returns to true if the --json flag is present and enableJsonFlag is set to true
this.toSuccessJson(result: unknown)​
Modify the command's success JSON output before it's displayed to the user.
this.toErrorJson(result: unknown)​
Modify the command's error JSON output before it's displayed to the user.Edit this pageLast updated on Dec 20, 2024 by Mike Donnalley\n\nAPI ReferenceCommandsOn this pageCommandsA basic command looks like the following in TypeScript:
import {Command} from '@oclif/core'export class MyCommand extends Command {  static description = 'description of this example command'  async run(): Promise<void> {    console.log('running my command')  }}
The only part that is required is the run function. Accept user input with arguments and flags.
In JavaScript:
const {Command} = require('@oclif/core')class MyCommand extends Command {  async run() {    console.log('running my command')  }}MyCommand.description = 'description of this example command'module.exports = MyCommand
Note that the following examples will be in TypeScript. As JavaScript does not yet have static class properties, you will have to add them to the class after it is declared like we did with the description above.
Avoiding Timeouts​
In order to avoid command executions running indefinitely, oclif will terminate the node process 10 seconds after Command.run resolves. This means that all command logic inside the run method should either run synchronously or should return a Promise. This will allow the entire command to run before the 10 second timeout starts.
In other words, if you execute a promise in Command.run without a awaiting it, then the command will likely timeout before it's completed.
Other Command Options​
See the base class to get an idea of what methods can be called on a command.
import {Command, Flags} from '@oclif/core'export class MyCommand extends Command {  static summary = 'A brief overview of your command.'  static description = `An in-depth description of the command.It can be multiline.`  // hide the command from help  static hidden = false  // custom usage string for help  // this overrides the default usage  static usage = 'mycommand --myflag'  // examples to add to help  // <%= config.bin %> resolves to the executable name  // <%= command.id %> resolves to the command name  static examples = [    // Examples can be simple strings    '<%= config.bin %> <%= command.id %> --help',    // Or objects that provide a description of the example command    {      description: 'Force the command to execute',      command: '<%= config.bin %> <%= command.id %> --force',    }  ]  // this makes the parser not fail when it receives invalid arguments  // defaults to true  // set it to false if you need to accept a variable number of arguments  static strict = false  // define aliases that can execute this command.  static aliases = ['alternate:name:for:this:command']  // Set to true if you want to add the --json flag to your command.  // oclif will automatically suppress logs (if you use this.log, this.warn, or this.error) and  // display the JSON returned by the command's run method.  static enableJsonFlag = true  async run() {    // show a warning    this.warn('uh oh!')    // exit with an error message    this.error('uh oh!!!')    // exit with status code    this.exit(1)  }}
Command Methods​

Command Methods

this.log(message: string)
this.warn(message: string | Error)
this.error(message: string | Error, options?: {code?: string, exit?: number, ref?: string; suggestions?: string[];})
this.exit(code: number = 0)
this.logToStderr(message: string)
this.jsonEnabled()
this.toSuccessJson(result: unknown)
this.toErrorJson(result: unknown)



The following assumes you are in the run() method of an oclif command.
this.log(message: string)​
Output message to stdout (non-blocking). console.log() works fine too, but that is a blocking call and won't be automatically suppressed when the --json flag is present. This uses util.format() which behaves the same as console.log().
this.log('hello, world!')
this.warn(message: string | Error)​
Display an error or message as a warning
this.warn('uh oh!')this.warn(new Error('uh oh!'))
this.error(message: string | Error, options?: {code?: string, exit?: number, ref?: string; suggestions?: string[];})​
Display error and exit. Also add a code to error object or exit status.
this.error('uh oh!', {exit: 2})this.error(new Error('uh oh!'))
The options object has the following options:

exit — exit code to use
code — a unique error code for the type of error
suggestions —  an array of suggestions for a user to try next that may be useful or provide additional context
ref — a url to documentation related to this error or fixing it

The message, code, suggestions, ref properties will be displayed when an error is shown. Reusable Error classes can be created that display the optional outputs above by implementing the PrettyPrintableError interface from the Errors namespace from @oclif/core and this.error will handle them appropriately.
These errors are friendly and won't show a traceback unless debugging is enabled with DEBUG=*.
import {CLIError} from '@oclif/errors'throw new CLIError('my friendly error')
Any error caught by the command of this CLIError type will be shown without traceback.
this.exit(code: number = 0)​
Exit process. Defaults to status 0.
this.exit()this.exit(1)
this.logToStderr(message: string)​
Log a message to the terminal's stderr.
this.jsonEnabled()​
Returns to true if the --json flag is present and enableJsonFlag is set to true
this.toSuccessJson(result: unknown)​
Modify the command's success JSON output before it's displayed to the user.
this.toErrorJson(result: unknown)​
Modify the command's error JSON output before it's displayed to the user.Edit this pageLast updated on Dec 20, 2024 by Mike DonnalleyPreviousAPI ReferenceNextCommand ArgumentsAvoiding TimeoutsOther Command OptionsCommand Methodsthis.log(message: string)this.warn(message: string | Error)this.error(message: string | Error, options?: {code?: string, exit?: number, ref?: string; suggestions?: string[];})this.exit(code: number = 0)this.logToStderr(message: string)this.jsonEnabled()this.toSuccessJson(result: unknown)this.toErrorJson(result: unknown)\n\n\n\nAPI ReferenceCommandsOn this pageCommandsA basic command looks like the following in TypeScript:
import {Command} from '@oclif/core'export class MyCommand extends Command {  static description = 'description of this example command'  async run(): Promise<void> {    console.log('running my command')  }}
The only part that is required is the run function. Accept user input with arguments and flags.
In JavaScript:
const {Command} = require('@oclif/core')class MyCommand extends Command {  async run() {    console.log('running my command')  }}MyCommand.description = 'description of this example command'module.exports = MyCommand
Note that the following examples will be in TypeScript. As JavaScript does not yet have static class properties, you will have to add them to the class after it is declared like we did with the description above.
Avoiding Timeouts​
In order to avoid command executions running indefinitely, oclif will terminate the node process 10 seconds after Command.run resolves. This means that all command logic inside the run method should either run synchronously or should return a Promise. This will allow the entire command to run before the 10 second timeout starts.
In other words, if you execute a promise in Command.run without a awaiting it, then the command will likely timeout before it's completed.
Other Command Options​
See the base class to get an idea of what methods can be called on a command.
import {Command, Flags} from '@oclif/core'export class MyCommand extends Command {  static summary = 'A brief overview of your command.'  static description = `An in-depth description of the command.It can be multiline.`  // hide the command from help  static hidden = false  // custom usage string for help  // this overrides the default usage  static usage = 'mycommand --myflag'  // examples to add to help  // <%= config.bin %> resolves to the executable name  // <%= command.id %> resolves to the command name  static examples = [    // Examples can be simple strings    '<%= config.bin %> <%= command.id %> --help',    // Or objects that provide a description of the example command    {      description: 'Force the command to execute',      command: '<%= config.bin %> <%= command.id %> --force',    }  ]  // this makes the parser not fail when it receives invalid arguments  // defaults to true  // set it to false if you need to accept a variable number of arguments  static strict = false  // define aliases that can execute this command.  static aliases = ['alternate:name:for:this:command']  // Set to true if you want to add the --json flag to your command.  // oclif will automatically suppress logs (if you use this.log, this.warn, or this.error) and  // display the JSON returned by the command's run method.  static enableJsonFlag = true  async run() {    // show a warning    this.warn('uh oh!')    // exit with an error message    this.error('uh oh!!!')    // exit with status code    this.exit(1)  }}
Command Methods​

Command Methods

this.log(message: string)
this.warn(message: string | Error)
this.error(message: string | Error, options?: {code?: string, exit?: number, ref?: string; suggestions?: string[];})
this.exit(code: number = 0)
this.logToStderr(message: string)
this.jsonEnabled()
this.toSuccessJson(result: unknown)
this.toErrorJson(result: unknown)



The following assumes you are in the run() method of an oclif command.
this.log(message: string)​
Output message to stdout (non-blocking). console.log() works fine too, but that is a blocking call and won't be automatically suppressed when the --json flag is present. This uses util.format() which behaves the same as console.log().
this.log('hello, world!')
this.warn(message: string | Error)​
Display an error or message as a warning
this.warn('uh oh!')this.warn(new Error('uh oh!'))
this.error(message: string | Error, options?: {code?: string, exit?: number, ref?: string; suggestions?: string[];})​
Display error and exit. Also add a code to error object or exit status.
this.error('uh oh!', {exit: 2})this.error(new Error('uh oh!'))
The options object has the following options:

exit — exit code to use
code — a unique error code for the type of error
suggestions —  an array of suggestions for a user to try next that may be useful or provide additional context
ref — a url to documentation related to this error or fixing it

The message, code, suggestions, ref properties will be displayed when an error is shown. Reusable Error classes can be created that display the optional outputs above by implementing the PrettyPrintableError interface from the Errors namespace from @oclif/core and this.error will handle them appropriately.
These errors are friendly and won't show a traceback unless debugging is enabled with DEBUG=*.
import {CLIError} from '@oclif/errors'throw new CLIError('my friendly error')
Any error caught by the command of this CLIError type will be shown without traceback.
this.exit(code: number = 0)​
Exit process. Defaults to status 0.
this.exit()this.exit(1)
this.logToStderr(message: string)​
Log a message to the terminal's stderr.
this.jsonEnabled()​
Returns to true if the --json flag is present and enableJsonFlag is set to true
this.toSuccessJson(result: unknown)​
Modify the command's success JSON output before it's displayed to the user.
this.toErrorJson(result: unknown)​
Modify the command's error JSON output before it's displayed to the user.Edit this pageLast updated on Dec 20, 2024 by Mike Donnalley\n\nAPI ReferenceCommandsOn this pageCommandsA basic command looks like the following in TypeScript:
import {Command} from '@oclif/core'export class MyCommand extends Command {  static description = 'description of this example command'  async run(): Promise<void> {    console.log('running my command')  }}
The only part that is required is the run function. Accept user input with arguments and flags.
In JavaScript:
const {Command} = require('@oclif/core')class MyCommand extends Command {  async run() {    console.log('running my command')  }}MyCommand.description = 'description of this example command'module.exports = MyCommand
Note that the following examples will be in TypeScript. As JavaScript does not yet have static class properties, you will have to add them to the class after it is declared like we did with the description above.
Avoiding Timeouts​
In order to avoid command executions running indefinitely, oclif will terminate the node process 10 seconds after Command.run resolves. This means that all command logic inside the run method should either run synchronously or should return a Promise. This will allow the entire command to run before the 10 second timeout starts.
In other words, if you execute a promise in Command.run without a awaiting it, then the command will likely timeout before it's completed.
Other Command Options​
See the base class to get an idea of what methods can be called on a command.
import {Command, Flags} from '@oclif/core'export class MyCommand extends Command {  static summary = 'A brief overview of your command.'  static description = `An in-depth description of the command.It can be multiline.`  // hide the command from help  static hidden = false  // custom usage string for help  // this overrides the default usage  static usage = 'mycommand --myflag'  // examples to add to help  // <%= config.bin %> resolves to the executable name  // <%= command.id %> resolves to the command name  static examples = [    // Examples can be simple strings    '<%= config.bin %> <%= command.id %> --help',    // Or objects that provide a description of the example command    {      description: 'Force the command to execute',      command: '<%= config.bin %> <%= command.id %> --force',    }  ]  // this makes the parser not fail when it receives invalid arguments  // defaults to true  // set it to false if you need to accept a variable number of arguments  static strict = false  // define aliases that can execute this command.  static aliases = ['alternate:name:for:this:command']  // Set to true if you want to add the --json flag to your command.  // oclif will automatically suppress logs (if you use this.log, this.warn, or this.error) and  // display the JSON returned by the command's run method.  static enableJsonFlag = true  async run() {    // show a warning    this.warn('uh oh!')    // exit with an error message    this.error('uh oh!!!')    // exit with status code    this.exit(1)  }}
Command Methods​

Command Methods

this.log(message: string)
this.warn(message: string | Error)
this.error(message: string | Error, options?: {code?: string, exit?: number, ref?: string; suggestions?: string[];})
this.exit(code: number = 0)
this.logToStderr(message: string)
this.jsonEnabled()
this.toSuccessJson(result: unknown)
this.toErrorJson(result: unknown)



The following assumes you are in the run() method of an oclif command.
this.log(message: string)​
Output message to stdout (non-blocking). console.log() works fine too, but that is a blocking call and won't be automatically suppressed when the --json flag is present. This uses util.format() which behaves the same as console.log().
this.log('hello, world!')
this.warn(message: string | Error)​
Display an error or message as a warning
this.warn('uh oh!')this.warn(new Error('uh oh!'))
this.error(message: string | Error, options?: {code?: string, exit?: number, ref?: string; suggestions?: string[];})​
Display error and exit. Also add a code to error object or exit status.
this.error('uh oh!', {exit: 2})this.error(new Error('uh oh!'))
The options object has the following options:

exit — exit code to use
code — a unique error code for the type of error
suggestions —  an array of suggestions for a user to try next that may be useful or provide additional context
ref — a url to documentation related to this error or fixing it

The message, code, suggestions, ref properties will be displayed when an error is shown. Reusable Error classes can be created that display the optional outputs above by implementing the PrettyPrintableError interface from the Errors namespace from @oclif/core and this.error will handle them appropriately.
These errors are friendly and won't show a traceback unless debugging is enabled with DEBUG=*.
import {CLIError} from '@oclif/errors'throw new CLIError('my friendly error')
Any error caught by the command of this CLIError type will be shown without traceback.
this.exit(code: number = 0)​
Exit process. Defaults to status 0.
this.exit()this.exit(1)
this.logToStderr(message: string)​
Log a message to the terminal's stderr.
this.jsonEnabled()​
Returns to true if the --json flag is present and enableJsonFlag is set to true
this.toSuccessJson(result: unknown)​
Modify the command's success JSON output before it's displayed to the user.
this.toErrorJson(result: unknown)​
Modify the command's error JSON output before it's displayed to the user.Edit this pageLast updated on Dec 20, 2024 by Mike DonnalleyPreviousAPI ReferenceNextCommand ArgumentsAvoiding TimeoutsOther Command OptionsCommand Methodsthis.log(message: string)this.warn(message: string | Error)this.error(message: string | Error, options?: {code?: string, exit?: number, ref?: string; suggestions?: string[];})this.exit(code: number = 0)this.logToStderr(message: string)this.jsonEnabled()this.toSuccessJson(result: unknown)this.toErrorJson(result: unknown)\n\n\n\nAPI ReferenceCommandsOn this pageCommandsA basic command looks like the following in TypeScript:
import {Command} from '@oclif/core'export class MyCommand extends Command {  static description = 'description of this example command'  async run(): Promise<void> {    console.log('running my command')  }}
The only part that is required is the run function. Accept user input with arguments and flags.
In JavaScript:
const {Command} = require('@oclif/core')class MyCommand extends Command {  async run() {    console.log('running my command')  }}MyCommand.description = 'description of this example command'module.exports = MyCommand
Note that the following examples will be in TypeScript. As JavaScript does not yet have static class properties, you will have to add them to the class after it is declared like we did with the description above.
Avoiding Timeouts​
In order to avoid command executions running indefinitely, oclif will terminate the node process 10 seconds after Command.run resolves. This means that all command logic inside the run method should either run synchronously or should return a Promise. This will allow the entire command to run before the 10 second timeout starts.
In other words, if you execute a promise in Command.run without a awaiting it, then the command will likely timeout before it's completed.
Other Command Options​
See the base class to get an idea of what methods can be called on a command.
import {Command, Flags} from '@oclif/core'export class MyCommand extends Command {  static summary = 'A brief overview of your command.'  static description = `An in-depth description of the command.It can be multiline.`  // hide the command from help  static hidden = false  // custom usage string for help  // this overrides the default usage  static usage = 'mycommand --myflag'  // examples to add to help  // <%= config.bin %> resolves to the executable name  // <%= command.id %> resolves to the command name  static examples = [    // Examples can be simple strings    '<%= config.bin %> <%= command.id %> --help',    // Or objects that provide a description of the example command    {      description: 'Force the command to execute',      command: '<%= config.bin %> <%= command.id %> --force',    }  ]  // this makes the parser not fail when it receives invalid arguments  // defaults to true  // set it to false if you need to accept a variable number of arguments  static strict = false  // define aliases that can execute this command.  static aliases = ['alternate:name:for:this:command']  // Set to true if you want to add the --json flag to your command.  // oclif will automatically suppress logs (if you use this.log, this.warn, or this.error) and  // display the JSON returned by the command's run method.  static enableJsonFlag = true  async run() {    // show a warning    this.warn('uh oh!')    // exit with an error message    this.error('uh oh!!!')    // exit with status code    this.exit(1)  }}
Command Methods​

Command Methods

this.log(message: string)
this.warn(message: string | Error)
this.error(message: string | Error, options?: {code?: string, exit?: number, ref?: string; suggestions?: string[];})
this.exit(code: number = 0)
this.logToStderr(message: string)
this.jsonEnabled()
this.toSuccessJson(result: unknown)
this.toErrorJson(result: unknown)



The following assumes you are in the run() method of an oclif command.
this.log(message: string)​
Output message to stdout (non-blocking). console.log() works fine too, but that is a blocking call and won't be automatically suppressed when the --json flag is present. This uses util.format() which behaves the same as console.log().
this.log('hello, world!')
this.warn(message: string | Error)​
Display an error or message as a warning
this.warn('uh oh!')this.warn(new Error('uh oh!'))
this.error(message: string | Error, options?: {code?: string, exit?: number, ref?: string; suggestions?: string[];})​
Display error and exit. Also add a code to error object or exit status.
this.error('uh oh!', {exit: 2})this.error(new Error('uh oh!'))
The options object has the following options:

exit — exit code to use
code — a unique error code for the type of error
suggestions —  an array of suggestions for a user to try next that may be useful or provide additional context
ref — a url to documentation related to this error or fixing it

The message, code, suggestions, ref properties will be displayed when an error is shown. Reusable Error classes can be created that display the optional outputs above by implementing the PrettyPrintableError interface from the Errors namespace from @oclif/core and this.error will handle them appropriately.
These errors are friendly and won't show a traceback unless debugging is enabled with DEBUG=*.
import {CLIError} from '@oclif/errors'throw new CLIError('my friendly error')
Any error caught by the command of this CLIError type will be shown without traceback.
this.exit(code: number = 0)​
Exit process. Defaults to status 0.
this.exit()this.exit(1)
this.logToStderr(message: string)​
Log a message to the terminal's stderr.
this.jsonEnabled()​
Returns to true if the --json flag is present and enableJsonFlag is set to true
this.toSuccessJson(result: unknown)​
Modify the command's success JSON output before it's displayed to the user.
this.toErrorJson(result: unknown)​
Modify the command's error JSON output before it's displayed to the user.Edit this pageLast updated on Dec 20, 2024 by Mike Donnalley\n\nAPI ReferenceCommandsOn this pageCommandsA basic command looks like the following in TypeScript:
import {Command} from '@oclif/core'export class MyCommand extends Command {  static description = 'description of this example command'  async run(): Promise<void> {    console.log('running my command')  }}
The only part that is required is the run function. Accept user input with arguments and flags.
In JavaScript:
const {Command} = require('@oclif/core')class MyCommand extends Command {  async run() {    console.log('running my command')  }}MyCommand.description = 'description of this example command'module.exports = MyCommand
Note that the following examples will be in TypeScript. As JavaScript does not yet have static class properties, you will have to add them to the class after it is declared like we did with the description above.
Avoiding Timeouts​
In order to avoid command executions running indefinitely, oclif will terminate the node process 10 seconds after Command.run resolves. This means that all command logic inside the run method should either run synchronously or should return a Promise. This will allow the entire command to run before the 10 second timeout starts.
In other words, if you execute a promise in Command.run without a awaiting it, then the command will likely timeout before it's completed.
Other Command Options​
See the base class to get an idea of what methods can be called on a command.
import {Command, Flags} from '@oclif/core'export class MyCommand extends Command {  static summary = 'A brief overview of your command.'  static description = `An in-depth description of the command.It can be multiline.`  // hide the command from help  static hidden = false  // custom usage string for help  // this overrides the default usage  static usage = 'mycommand --myflag'  // examples to add to help  // <%= config.bin %> resolves to the executable name  // <%= command.id %> resolves to the command name  static examples = [    // Examples can be simple strings    '<%= config.bin %> <%= command.id %> --help',    // Or objects that provide a description of the example command    {      description: 'Force the command to execute',      command: '<%= config.bin %> <%= command.id %> --force',    }  ]  // this makes the parser not fail when it receives invalid arguments  // defaults to true  // set it to false if you need to accept a variable number of arguments  static strict = false  // define aliases that can execute this command.  static aliases = ['alternate:name:for:this:command']  // Set to true if you want to add the --json flag to your command.  // oclif will automatically suppress logs (if you use this.log, this.warn, or this.error) and  // display the JSON returned by the command's run method.  static enableJsonFlag = true  async run() {    // show a warning    this.warn('uh oh!')    // exit with an error message    this.error('uh oh!!!')    // exit with status code    this.exit(1)  }}
Command Methods​

Command Methods

this.log(message: string)
this.warn(message: string | Error)
this.error(message: string | Error, options?: {code?: string, exit?: number, ref?: string; suggestions?: string[];})
this.exit(code: number = 0)
this.logToStderr(message: string)
this.jsonEnabled()
this.toSuccessJson(result: unknown)
this.toErrorJson(result: unknown)



The following assumes you are in the run() method of an oclif command.
this.log(message: string)​
Output message to stdout (non-blocking). console.log() works fine too, but that is a blocking call and won't be automatically suppressed when the --json flag is present. This uses util.format() which behaves the same as console.log().
this.log('hello, world!')
this.warn(message: string | Error)​
Display an error or message as a warning
this.warn('uh oh!')this.warn(new Error('uh oh!'))
this.error(message: string | Error, options?: {code?: string, exit?: number, ref?: string; suggestions?: string[];})​
Display error and exit. Also add a code to error object or exit status.
this.error('uh oh!', {exit: 2})this.error(new Error('uh oh!'))
The options object has the following options:

exit — exit code to use
code — a unique error code for the type of error
suggestions —  an array of suggestions for a user to try next that may be useful or provide additional context
ref — a url to documentation related to this error or fixing it

The message, code, suggestions, ref properties will be displayed when an error is shown. Reusable Error classes can be created that display the optional outputs above by implementing the PrettyPrintableError interface from the Errors namespace from @oclif/core and this.error will handle them appropriately.
These errors are friendly and won't show a traceback unless debugging is enabled with DEBUG=*.
import {CLIError} from '@oclif/errors'throw new CLIError('my friendly error')
Any error caught by the command of this CLIError type will be shown without traceback.
this.exit(code: number = 0)​
Exit process. Defaults to status 0.
this.exit()this.exit(1)
this.logToStderr(message: string)​
Log a message to the terminal's stderr.
this.jsonEnabled()​
Returns to true if the --json flag is present and enableJsonFlag is set to true
this.toSuccessJson(result: unknown)​
Modify the command's success JSON output before it's displayed to the user.
this.toErrorJson(result: unknown)​
Modify the command's error JSON output before it's displayed to the user.Edit this pageLast updated on Dec 20, 2024 by Mike DonnalleyPreviousAPI ReferenceNextCommand ArgumentsAvoiding TimeoutsOther Command OptionsCommand Methodsthis.log(message: string)this.warn(message: string | Error)this.error(message: string | Error, options?: {code?: string, exit?: number, ref?: string; suggestions?: string[];})this.exit(code: number = 0)this.logToStderr(message: string)this.jsonEnabled()this.toSuccessJson(result: unknown)this.toErrorJson(result: unknown)\n\n\n\nAPI ReferenceCommandsOn this pageCommandsA basic command looks like the following in TypeScript:
import {Command} from '@oclif/core'export class MyCommand extends Command {  static description = 'description of this example command'  async run(): Promise<void> {    console.log('running my command')  }}
The only part that is required is the run function. Accept user input with arguments and flags.
In JavaScript:
const {Command} = require('@oclif/core')class MyCommand extends Command {  async run() {    console.log('running my command')  }}MyCommand.description = 'description of this example command'module.exports = MyCommand
Note that the following examples will be in TypeScript. As JavaScript does not yet have static class properties, you will have to add them to the class after it is declared like we did with the description above.
Avoiding Timeouts​
In order to avoid command executions running indefinitely, oclif will terminate the node process 10 seconds after Command.run resolves. This means that all command logic inside the run method should either run synchronously or should return a Promise. This will allow the entire command to run before the 10 second timeout starts.
In other words, if you execute a promise in Command.run without a awaiting it, then the command will likely timeout before it's completed.
Other Command Options​
See the base class to get an idea of what methods can be called on a command.
import {Command, Flags} from '@oclif/core'export class MyCommand extends Command {  static summary = 'A brief overview of your command.'  static description = `An in-depth description of the command.It can be multiline.`  // hide the command from help  static hidden = false  // custom usage string for help  // this overrides the default usage  static usage = 'mycommand --myflag'  // examples to add to help  // <%= config.bin %> resolves to the executable name  // <%= command.id %> resolves to the command name  static examples = [    // Examples can be simple strings    '<%= config.bin %> <%= command.id %> --help',    // Or objects that provide a description of the example command    {      description: 'Force the command to execute',      command: '<%= config.bin %> <%= command.id %> --force',    }  ]  // this makes the parser not fail when it receives invalid arguments  // defaults to true  // set it to false if you need to accept a variable number of arguments  static strict = false  // define aliases that can execute this command.  static aliases = ['alternate:name:for:this:command']  // Set to true if you want to add the --json flag to your command.  // oclif will automatically suppress logs (if you use this.log, this.warn, or this.error) and  // display the JSON returned by the command's run method.  static enableJsonFlag = true  async run() {    // show a warning    this.warn('uh oh!')    // exit with an error message    this.error('uh oh!!!')    // exit with status code    this.exit(1)  }}
Command Methods​

Command Methods

this.log(message: string)
this.warn(message: string | Error)
this.error(message: string | Error, options?: {code?: string, exit?: number, ref?: string; suggestions?: string[];})
this.exit(code: number = 0)
this.logToStderr(message: string)
this.jsonEnabled()
this.toSuccessJson(result: unknown)
this.toErrorJson(result: unknown)



The following assumes you are in the run() method of an oclif command.
this.log(message: string)​
Output message to stdout (non-blocking). console.log() works fine too, but that is a blocking call and won't be automatically suppressed when the --json flag is present. This uses util.format() which behaves the same as console.log().
this.log('hello, world!')
this.warn(message: string | Error)​
Display an error or message as a warning
this.warn('uh oh!')this.warn(new Error('uh oh!'))
this.error(message: string | Error, options?: {code?: string, exit?: number, ref?: string; suggestions?: string[];})​
Display error and exit. Also add a code to error object or exit status.
this.error('uh oh!', {exit: 2})this.error(new Error('uh oh!'))
The options object has the following options:

exit — exit code to use
code — a unique error code for the type of error
suggestions —  an array of suggestions for a user to try next that may be useful or provide additional context
ref — a url to documentation related to this error or fixing it

The message, code, suggestions, ref properties will be displayed when an error is shown. Reusable Error classes can be created that display the optional outputs above by implementing the PrettyPrintableError interface from the Errors namespace from @oclif/core and this.error will handle them appropriately.
These errors are friendly and won't show a traceback unless debugging is enabled with DEBUG=*.
import {CLIError} from '@oclif/errors'throw new CLIError('my friendly error')
Any error caught by the command of this CLIError type will be shown without traceback.
this.exit(code: number = 0)​
Exit process. Defaults to status 0.
this.exit()this.exit(1)
this.logToStderr(message: string)​
Log a message to the terminal's stderr.
this.jsonEnabled()​
Returns to true if the --json flag is present and enableJsonFlag is set to true
this.toSuccessJson(result: unknown)​
Modify the command's success JSON output before it's displayed to the user.
this.toErrorJson(result: unknown)​
Modify the command's error JSON output before it's displayed to the user.Edit this pageLast updated on Dec 20, 2024 by Mike Donnalley\n\nAPI ReferenceCommandsOn this pageCommandsA basic command looks like the following in TypeScript:
import {Command} from '@oclif/core'export class MyCommand extends Command {  static description = 'description of this example command'  async run(): Promise<void> {    console.log('running my command')  }}
The only part that is required is the run function. Accept user input with arguments and flags.
In JavaScript:
const {Command} = require('@oclif/core')class MyCommand extends Command {  async run() {    console.log('running my command')  }}MyCommand.description = 'description of this example command'module.exports = MyCommand
Note that the following examples will be in TypeScript. As JavaScript does not yet have static class properties, you will have to add them to the class after it is declared like we did with the description above.
Avoiding Timeouts​
In order to avoid command executions running indefinitely, oclif will terminate the node process 10 seconds after Command.run resolves. This means that all command logic inside the run method should either run synchronously or should return a Promise. This will allow the entire command to run before the 10 second timeout starts.
In other words, if you execute a promise in Command.run without a awaiting it, then the command will likely timeout before it's completed.
Other Command Options​
See the base class to get an idea of what methods can be called on a command.
import {Command, Flags} from '@oclif/core'export class MyCommand extends Command {  static summary = 'A brief overview of your command.'  static description = `An in-depth description of the command.It can be multiline.`  // hide the command from help  static hidden = false  // custom usage string for help  // this overrides the default usage  static usage = 'mycommand --myflag'  // examples to add to help  // <%= config.bin %> resolves to the executable name  // <%= command.id %> resolves to the command name  static examples = [    // Examples can be simple strings    '<%= config.bin %> <%= command.id %> --help',    // Or objects that provide a description of the example command    {      description: 'Force the command to execute',      command: '<%= config.bin %> <%= command.id %> --force',    }  ]  // this makes the parser not fail when it receives invalid arguments  // defaults to true  // set it to false if you need to accept a variable number of arguments  static strict = false  // define aliases that can execute this command.  static aliases = ['alternate:name:for:this:command']  // Set to true if you want to add the --json flag to your command.  // oclif will automatically suppress logs (if you use this.log, this.warn, or this.error) and  // display the JSON returned by the command's run method.  static enableJsonFlag = true  async run() {    // show a warning    this.warn('uh oh!')    // exit with an error message    this.error('uh oh!!!')    // exit with status code    this.exit(1)  }}
Command Methods​

Command Methods

this.log(message: string)
this.warn(message: string | Error)
this.error(message: string | Error, options?: {code?: string, exit?: number, ref?: string; suggestions?: string[];})
this.exit(code: number = 0)
this.logToStderr(message: string)
this.jsonEnabled()
this.toSuccessJson(result: unknown)
this.toErrorJson(result: unknown)



The following assumes you are in the run() method of an oclif command.
this.log(message: string)​
Output message to stdout (non-blocking). console.log() works fine too, but that is a blocking call and won't be automatically suppressed when the --json flag is present. This uses util.format() which behaves the same as console.log().
this.log('hello, world!')
this.warn(message: string | Error)​
Display an error or message as a warning
this.warn('uh oh!')this.warn(new Error('uh oh!'))
this.error(message: string | Error, options?: {code?: string, exit?: number, ref?: string; suggestions?: string[];})​
Display error and exit. Also add a code to error object or exit status.
this.error('uh oh!', {exit: 2})this.error(new Error('uh oh!'))
The options object has the following options:

exit — exit code to use
code — a unique error code for the type of error
suggestions —  an array of suggestions for a user to try next that may be useful or provide additional context
ref — a url to documentation related to this error or fixing it

The message, code, suggestions, ref properties will be displayed when an error is shown. Reusable Error classes can be created that display the optional outputs above by implementing the PrettyPrintableError interface from the Errors namespace from @oclif/core and this.error will handle them appropriately.
These errors are friendly and won't show a traceback unless debugging is enabled with DEBUG=*.
import {CLIError} from '@oclif/errors'throw new CLIError('my friendly error')
Any error caught by the command of this CLIError type will be shown without traceback.
this.exit(code: number = 0)​
Exit process. Defaults to status 0.
this.exit()this.exit(1)
this.logToStderr(message: string)​
Log a message to the terminal's stderr.
this.jsonEnabled()​
Returns to true if the --json flag is present and enableJsonFlag is set to true
this.toSuccessJson(result: unknown)​
Modify the command's success JSON output before it's displayed to the user.
this.toErrorJson(result: unknown)​
Modify the command's error JSON output before it's displayed to the user.Edit this pageLast updated on Dec 20, 2024 by Mike DonnalleyPreviousAPI ReferenceNextCommand ArgumentsAvoiding TimeoutsOther Command OptionsCommand Methodsthis.log(message: string)this.warn(message: string | Error)this.error(message: string | Error, options?: {code?: string, exit?: number, ref?: string; suggestions?: string[];})this.exit(code: number = 0)this.logToStderr(message: string)this.jsonEnabled()this.toSuccessJson(result: unknown)this.toErrorJson(result: unknown)\n\n\n\nAPI ReferenceCommandsOn this pageCommandsA basic command looks like the following in TypeScript:
import {Command} from '@oclif/core'export class MyCommand extends Command {  static description = 'description of this example command'  async run(): Promise<void> {    console.log('running my command')  }}
The only part that is required is the run function. Accept user input with arguments and flags.
In JavaScript:
const {Command} = require('@oclif/core')class MyCommand extends Command {  async run() {    console.log('running my command')  }}MyCommand.description = 'description of this example command'module.exports = MyCommand
Note that the following examples will be in TypeScript. As JavaScript does not yet have static class properties, you will have to add them to the class after it is declared like we did with the description above.
Avoiding Timeouts​
In order to avoid command executions running indefinitely, oclif will terminate the node process 10 seconds after Command.run resolves. This means that all command logic inside the run method should either run synchronously or should return a Promise. This will allow the entire command to run before the 10 second timeout starts.
In other words, if you execute a promise in Command.run without a awaiting it, then the command will likely timeout before it's completed.
Other Command Options​
See the base class to get an idea of what methods can be called on a command.
import {Command, Flags} from '@oclif/core'export class MyCommand extends Command {  static summary = 'A brief overview of your command.'  static description = `An in-depth description of the command.It can be multiline.`  // hide the command from help  static hidden = false  // custom usage string for help  // this overrides the default usage  static usage = 'mycommand --myflag'  // examples to add to help  // <%= config.bin %> resolves to the executable name  // <%= command.id %> resolves to the command name  static examples = [    // Examples can be simple strings    '<%= config.bin %> <%= command.id %> --help',    // Or objects that provide a description of the example command    {      description: 'Force the command to execute',      command: '<%= config.bin %> <%= command.id %> --force',    }  ]  // this makes the parser not fail when it receives invalid arguments  // defaults to true  // set it to false if you need to accept a variable number of arguments  static strict = false  // define aliases that can execute this command.  static aliases = ['alternate:name:for:this:command']  // Set to true if you want to add the --json flag to your command.  // oclif will automatically suppress logs (if you use this.log, this.warn, or this.error) and  // display the JSON returned by the command's run method.  static enableJsonFlag = true  async run() {    // show a warning    this.warn('uh oh!')    // exit with an error message    this.error('uh oh!!!')    // exit with status code    this.exit(1)  }}
Command Methods​

Command Methods

this.log(message: string)
this.warn(message: string | Error)
this.error(message: string | Error, options?: {code?: string, exit?: number, ref?: string; suggestions?: string[];})
this.exit(code: number = 0)
this.logToStderr(message: string)
this.jsonEnabled()
this.toSuccessJson(result: unknown)
this.toErrorJson(result: unknown)



The following assumes you are in the run() method of an oclif command.
this.log(message: string)​
Output message to stdout (non-blocking). console.log() works fine too, but that is a blocking call and won't be automatically suppressed when the --json flag is present. This uses util.format() which behaves the same as console.log().
this.log('hello, world!')
this.warn(message: string | Error)​
Display an error or message as a warning
this.warn('uh oh!')this.warn(new Error('uh oh!'))
this.error(message: string | Error, options?: {code?: string, exit?: number, ref?: string; suggestions?: string[];})​
Display error and exit. Also add a code to error object or exit status.
this.error('uh oh!', {exit: 2})this.error(new Error('uh oh!'))
The options object has the following options:

exit — exit code to use
code — a unique error code for the type of error
suggestions —  an array of suggestions for a user to try next that may be useful or provide additional context
ref — a url to documentation related to this error or fixing it

The message, code, suggestions, ref properties will be displayed when an error is shown. Reusable Error classes can be created that display the optional outputs above by implementing the PrettyPrintableError interface from the Errors namespace from @oclif/core and this.error will handle them appropriately.
These errors are friendly and won't show a traceback unless debugging is enabled with DEBUG=*.
import {CLIError} from '@oclif/errors'throw new CLIError('my friendly error')
Any error caught by the command of this CLIError type will be shown without traceback.
this.exit(code: number = 0)​
Exit process. Defaults to status 0.
this.exit()this.exit(1)
this.logToStderr(message: string)​
Log a message to the terminal's stderr.
this.jsonEnabled()​
Returns to true if the --json flag is present and enableJsonFlag is set to true
this.toSuccessJson(result: unknown)​
Modify the command's success JSON output before it's displayed to the user.
this.toErrorJson(result: unknown)​
Modify the command's error JSON output before it's displayed to the user.Edit this pageLast updated on Dec 20, 2024 by Mike Donnalley\n\nAPI ReferenceCommandsOn this pageCommandsA basic command looks like the following in TypeScript:
import {Command} from '@oclif/core'export class MyCommand extends Command {  static description = 'description of this example command'  async run(): Promise<void> {    console.log('running my command')  }}
The only part that is required is the run function. Accept user input with arguments and flags.
In JavaScript:
const {Command} = require('@oclif/core')class MyCommand extends Command {  async run() {    console.log('running my command')  }}MyCommand.description = 'description of this example command'module.exports = MyCommand
Note that the following examples will be in TypeScript. As JavaScript does not yet have static class properties, you will have to add them to the class after it is declared like we did with the description above.
Avoiding Timeouts​
In order to avoid command executions running indefinitely, oclif will terminate the node process 10 seconds after Command.run resolves. This means that all command logic inside the run method should either run synchronously or should return a Promise. This will allow the entire command to run before the 10 second timeout starts.
In other words, if you execute a promise in Command.run without a awaiting it, then the command will likely timeout before it's completed.
Other Command Options​
See the base class to get an idea of what methods can be called on a command.
import {Command, Flags} from '@oclif/core'export class MyCommand extends Command {  static summary = 'A brief overview of your command.'  static description = `An in-depth description of the command.It can be multiline.`  // hide the command from help  static hidden = false  // custom usage string for help  // this overrides the default usage  static usage = 'mycommand --myflag'  // examples to add to help  // <%= config.bin %> resolves to the executable name  // <%= command.id %> resolves to the command name  static examples = [    // Examples can be simple strings    '<%= config.bin %> <%= command.id %> --help',    // Or objects that provide a description of the example command    {      description: 'Force the command to execute',      command: '<%= config.bin %> <%= command.id %> --force',    }  ]  // this makes the parser not fail when it receives invalid arguments  // defaults to true  // set it to false if you need to accept a variable number of arguments  static strict = false  // define aliases that can execute this command.  static aliases = ['alternate:name:for:this:command']  // Set to true if you want to add the --json flag to your command.  // oclif will automatically suppress logs (if you use this.log, this.warn, or this.error) and  // display the JSON returned by the command's run method.  static enableJsonFlag = true  async run() {    // show a warning    this.warn('uh oh!')    // exit with an error message    this.error('uh oh!!!')    // exit with status code    this.exit(1)  }}
Command Methods​

Command Methods

this.log(message: string)
this.warn(message: string | Error)
this.error(message: string | Error, options?: {code?: string, exit?: number, ref?: string; suggestions?: string[];})
this.exit(code: number = 0)
this.logToStderr(message: string)
this.jsonEnabled()
this.toSuccessJson(result: unknown)
this.toErrorJson(result: unknown)



The following assumes you are in the run() method of an oclif command.
this.log(message: string)​
Output message to stdout (non-blocking). console.log() works fine too, but that is a blocking call and won't be automatically suppressed when the --json flag is present. This uses util.format() which behaves the same as console.log().
this.log('hello, world!')
this.warn(message: string | Error)​
Display an error or message as a warning
this.warn('uh oh!')this.warn(new Error('uh oh!'))
this.error(message: string | Error, options?: {code?: string, exit?: number, ref?: string; suggestions?: string[];})​
Display error and exit. Also add a code to error object or exit status.
this.error('uh oh!', {exit: 2})this.error(new Error('uh oh!'))
The options object has the following options:

exit — exit code to use
code — a unique error code for the type of error
suggestions —  an array of suggestions for a user to try next that may be useful or provide additional context
ref — a url to documentation related to this error or fixing it

The message, code, suggestions, ref properties will be displayed when an error is shown. Reusable Error classes can be created that display the optional outputs above by implementing the PrettyPrintableError interface from the Errors namespace from @oclif/core and this.error will handle them appropriately.
These errors are friendly and won't show a traceback unless debugging is enabled with DEBUG=*.
import {CLIError} from '@oclif/errors'throw new CLIError('my friendly error')
Any error caught by the command of this CLIError type will be shown without traceback.
this.exit(code: number = 0)​
Exit process. Defaults to status 0.
this.exit()this.exit(1)
this.logToStderr(message: string)​
Log a message to the terminal's stderr.
this.jsonEnabled()​
Returns to true if the --json flag is present and enableJsonFlag is set to true
this.toSuccessJson(result: unknown)​
Modify the command's success JSON output before it's displayed to the user.
this.toErrorJson(result: unknown)​
Modify the command's error JSON output before it's displayed to the user.Edit this pageLast updated on Dec 20, 2024 by Mike DonnalleyPreviousAPI ReferenceNextCommand ArgumentsAvoiding TimeoutsOther Command OptionsCommand Methodsthis.log(message: string)this.warn(message: string | Error)this.error(message: string | Error, options?: {code?: string, exit?: number, ref?: string; suggestions?: string[];})this.exit(code: number = 0)this.logToStderr(message: string)this.jsonEnabled()this.toSuccessJson(result: unknown)this.toErrorJson(result: unknown)\n\n\n\nAPI ReferenceCommandsOn this pageCommandsA basic command looks like the following in TypeScript:
import {Command} from '@oclif/core'export class MyCommand extends Command {  static description = 'description of this example command'  async run(): Promise<void> {    console.log('running my command')  }}
The only part that is required is the run function. Accept user input with arguments and flags.
In JavaScript:
const {Command} = require('@oclif/core')class MyCommand extends Command {  async run() {    console.log('running my command')  }}MyCommand.description = 'description of this example command'module.exports = MyCommand
Note that the following examples will be in TypeScript. As JavaScript does not yet have static class properties, you will have to add them to the class after it is declared like we did with the description above.
Avoiding Timeouts​
In order to avoid command executions running indefinitely, oclif will terminate the node process 10 seconds after Command.run resolves. This means that all command logic inside the run method should either run synchronously or should return a Promise. This will allow the entire command to run before the 10 second timeout starts.
In other words, if you execute a promise in Command.run without a awaiting it, then the command will likely timeout before it's completed.
Other Command Options​
See the base class to get an idea of what methods can be called on a command.
import {Command, Flags} from '@oclif/core'export class MyCommand extends Command {  static summary = 'A brief overview of your command.'  static description = `An in-depth description of the command.It can be multiline.`  // hide the command from help  static hidden = false  // custom usage string for help  // this overrides the default usage  static usage = 'mycommand --myflag'  // examples to add to help  // <%= config.bin %> resolves to the executable name  // <%= command.id %> resolves to the command name  static examples = [    // Examples can be simple strings    '<%= config.bin %> <%= command.id %> --help',    // Or objects that provide a description of the example command    {      description: 'Force the command to execute',      command: '<%= config.bin %> <%= command.id %> --force',    }  ]  // this makes the parser not fail when it receives invalid arguments  // defaults to true  // set it to false if you need to accept a variable number of arguments  static strict = false  // define aliases that can execute this command.  static aliases = ['alternate:name:for:this:command']  // Set to true if you want to add the --json flag to your command.  // oclif will automatically suppress logs (if you use this.log, this.warn, or this.error) and  // display the JSON returned by the command's run method.  static enableJsonFlag = true  async run() {    // show a warning    this.warn('uh oh!')    // exit with an error message    this.error('uh oh!!!')    // exit with status code    this.exit(1)  }}
Command Methods​

Command Methods

this.log(message: string)
this.warn(message: string | Error)
this.error(message: string | Error, options?: {code?: string, exit?: number, ref?: string; suggestions?: string[];})
this.exit(code: number = 0)
this.logToStderr(message: string)
this.jsonEnabled()
this.toSuccessJson(result: unknown)
this.toErrorJson(result: unknown)



The following assumes you are in the run() method of an oclif command.
this.log(message: string)​
Output message to stdout (non-blocking). console.log() works fine too, but that is a blocking call and won't be automatically suppressed when the --json flag is present. This uses util.format() which behaves the same as console.log().
this.log('hello, world!')
this.warn(message: string | Error)​
Display an error or message as a warning
this.warn('uh oh!')this.warn(new Error('uh oh!'))
this.error(message: string | Error, options?: {code?: string, exit?: number, ref?: string; suggestions?: string[];})​
Display error and exit. Also add a code to error object or exit status.
this.error('uh oh!', {exit: 2})this.error(new Error('uh oh!'))
The options object has the following options:

exit — exit code to use
code — a unique error code for the type of error
suggestions —  an array of suggestions for a user to try next that may be useful or provide additional context
ref — a url to documentation related to this error or fixing it

The message, code, suggestions, ref properties will be displayed when an error is shown. Reusable Error classes can be created that display the optional outputs above by implementing the PrettyPrintableError interface from the Errors namespace from @oclif/core and this.error will handle them appropriately.
These errors are friendly and won't show a traceback unless debugging is enabled with DEBUG=*.
import {CLIError} from '@oclif/errors'throw new CLIError('my friendly error')
Any error caught by the command of this CLIError type will be shown without traceback.
this.exit(code: number = 0)​
Exit process. Defaults to status 0.
this.exit()this.exit(1)
this.logToStderr(message: string)​
Log a message to the terminal's stderr.
this.jsonEnabled()​
Returns to true if the --json flag is present and enableJsonFlag is set to true
this.toSuccessJson(result: unknown)​
Modify the command's success JSON output before it's displayed to the user.
this.toErrorJson(result: unknown)​
Modify the command's error JSON output before it's displayed to the user.Edit this pageLast updated on Dec 20, 2024 by Mike Donnalley\n\nAPI ReferenceCommandsOn this pageCommandsA basic command looks like the following in TypeScript:
import {Command} from '@oclif/core'export class MyCommand extends Command {  static description = 'description of this example command'  async run(): Promise<void> {    console.log('running my command')  }}
The only part that is required is the run function. Accept user input with arguments and flags.
In JavaScript:
const {Command} = require('@oclif/core')class MyCommand extends Command {  async run() {    console.log('running my command')  }}MyCommand.description = 'description of this example command'module.exports = MyCommand
Note that the following examples will be in TypeScript. As JavaScript does not yet have static class properties, you will have to add them to the class after it is declared like we did with the description above.
Avoiding Timeouts​
In order to avoid command executions running indefinitely, oclif will terminate the node process 10 seconds after Command.run resolves. This means that all command logic inside the run method should either run synchronously or should return a Promise. This will allow the entire command to run before the 10 second timeout starts.
In other words, if you execute a promise in Command.run without a awaiting it, then the command will likely timeout before it's completed.
Other Command Options​
See the base class to get an idea of what methods can be called on a command.
import {Command, Flags} from '@oclif/core'export class MyCommand extends Command {  static summary = 'A brief overview of your command.'  static description = `An in-depth description of the command.It can be multiline.`  // hide the command from help  static hidden = false  // custom usage string for help  // this overrides the default usage  static usage = 'mycommand --myflag'  // examples to add to help  // <%= config.bin %> resolves to the executable name  // <%= command.id %> resolves to the command name  static examples = [    // Examples can be simple strings    '<%= config.bin %> <%= command.id %> --help',    // Or objects that provide a description of the example command    {      description: 'Force the command to execute',      command: '<%= config.bin %> <%= command.id %> --force',    }  ]  // this makes the parser not fail when it receives invalid arguments  // defaults to true  // set it to false if you need to accept a variable number of arguments  static strict = false  // define aliases that can execute this command.  static aliases = ['alternate:name:for:this:command']  // Set to true if you want to add the --json flag to your command.  // oclif will automatically suppress logs (if you use this.log, this.warn, or this.error) and  // display the JSON returned by the command's run method.  static enableJsonFlag = true  async run() {    // show a warning    this.warn('uh oh!')    // exit with an error message    this.error('uh oh!!!')    // exit with status code    this.exit(1)  }}
Command Methods​

Command Methods

this.log(message: string)
this.warn(message: string | Error)
this.error(message: string | Error, options?: {code?: string, exit?: number, ref?: string; suggestions?: string[];})
this.exit(code: number = 0)
this.logToStderr(message: string)
this.jsonEnabled()
this.toSuccessJson(result: unknown)
this.toErrorJson(result: unknown)



The following assumes you are in the run() method of an oclif command.
this.log(message: string)​
Output message to stdout (non-blocking). console.log() works fine too, but that is a blocking call and won't be automatically suppressed when the --json flag is present. This uses util.format() which behaves the same as console.log().
this.log('hello, world!')
this.warn(message: string | Error)​
Display an error or message as a warning
this.warn('uh oh!')this.warn(new Error('uh oh!'))
this.error(message: string | Error, options?: {code?: string, exit?: number, ref?: string; suggestions?: string[];})​
Display error and exit. Also add a code to error object or exit status.
this.error('uh oh!', {exit: 2})this.error(new Error('uh oh!'))
The options object has the following options:

exit — exit code to use
code — a unique error code for the type of error
suggestions —  an array of suggestions for a user to try next that may be useful or provide additional context
ref — a url to documentation related to this error or fixing it

The message, code, suggestions, ref properties will be displayed when an error is shown. Reusable Error classes can be created that display the optional outputs above by implementing the PrettyPrintableError interface from the Errors namespace from @oclif/core and this.error will handle them appropriately.
These errors are friendly and won't show a traceback unless debugging is enabled with DEBUG=*.
import {CLIError} from '@oclif/errors'throw new CLIError('my friendly error')
Any error caught by the command of this CLIError type will be shown without traceback.
this.exit(code: number = 0)​
Exit process. Defaults to status 0.
this.exit()this.exit(1)
this.logToStderr(message: string)​
Log a message to the terminal's stderr.
this.jsonEnabled()​
Returns to true if the --json flag is present and enableJsonFlag is set to true
this.toSuccessJson(result: unknown)​
Modify the command's success JSON output before it's displayed to the user.
this.toErrorJson(result: unknown)​
Modify the command's error JSON output before it's displayed to the user.Edit this pageLast updated on Dec 20, 2024 by Mike DonnalleyPreviousAPI ReferenceNextCommand ArgumentsAvoiding TimeoutsOther Command OptionsCommand Methodsthis.log(message: string)this.warn(message: string | Error)this.error(message: string | Error, options?: {code?: string, exit?: number, ref?: string; suggestions?: string[];})this.exit(code: number = 0)this.logToStderr(message: string)this.jsonEnabled()this.toSuccessJson(result: unknown)this.toErrorJson(result: unknown)\n\n\n\nAPI ReferenceCommand FlagsOn this pageCommand FlagsFlag options are non-positional arguments passed to the command. Flags can either be option flags which take an argument, or boolean flags which do not. An option flag must have an argument.
For example, if this command was run like this:
$ mycli --force --file=./myfile
It would be declared like this:
import {Command, Flags} from '@oclif/core'export class MyCLI extends Command {  static flags = {    // can pass either --force or -f    force: Flags.boolean({char: 'f'}),    file: Flags.string(),  }  async run() {    const {flags} = await this.parse(MyCLI)    if (flags.force) console.log('--force is set')    if (flags.file) console.log(`--file is: ${flags.file}`)  }}
oclif supports a wide range of alternative flag inputs.
Here are the options flags can have:
static flags = {  name: Flags.string({    // The following can be set on both boolean and option flag (e.g. string, integer, url, custom, etc) types.    char: 'n',                                   // shorter flag version    summary: 'brief summary',                    // help summary for flag    helpLabel: '--my-flags',                     // The flag label to show in help. Defaults to "[-<char>] --<name>" where -<char> is only displayed if the char is defined.    helpGroup: 'THE BEST FLAGS',                 // Put flag into THE BEST FLAGS group in help    description: 'in-depth overview',            // help description for flag    hidden: false,                               // hide from help    multiple: false,                             // allow setting this flag multiple times    env: 'MY_NAME',                              // default to value of environment variable    options: ['a', 'b'],                         // only allow the value to be from a discrete set    parse: async input => 'output',              // instead of the user input, return a different value    default: 'world',                            // default value if flag not passed (can be an async function that returns a string or undefined)    defaultHelp: 'a dynamic value'               // dynamic default value to show in help output (e.g. current working directory). Can be an async function that returns a string or undefined    required: false,                             // make flag required    aliases: ['username', 'u'],                  // aliases for the flag - can be short char or long flags    charAliases: ['u', 'n'],                     // single character aliases for the flag    deprecated: false,                           // mark the flag as deprecated.    deprecateAliases: false,                     // emit deprecation warning anytime a flag alias is provided    noCacheDefault: false,                       // if true, the value returned by defaultHelp will not be cached in the oclif.manifest.json.    dependsOn: ['extra-flag'],                   // this flag requires another flag    exclusive: ['extra-flag'],                   // this flag cannot be specified alongside this other flag    exactlyOne: ['extra-flag', 'another-flag'],  // exactly one of these flags must be provided    relationships: [                             // define complex relationships between flags      // Make this flag dependent on all of these flags      {type: 'all', flags: ['flag-one', 'flag-two']}      // Make this flag dependent on at least one of these flags      {type: 'some', flags: ['flag-three', 'flag-four']}      // Make this flag exclusive of all these flags      {type: 'none', flags: ['flag-five', 'flag-six']}      // Make this flag dependent on all of these flags      {type: 'all', flags: [        'flag-one',        'flag-two',        // Include flag-seven but only when flag-eight is equal to FooBar        {name: 'flag-seven', when: async (flags) => flags['flag-eight'] === 'FooBar'}      ]}    ],    // The following properties cannot be set on boolean flags    helpValue: '<name>',                         // The flag value to show in help. Defaults to "<value>",    multipleNonGreedy: false,                    // Parse one value per flag to allow `-m val1 -m val2` but disallow `-m val1 val2`. Only respected if multiple is set to true    delimiter: ','                               // Delimiter to separate the values for a multiple value flag. Only respected if multiple is set to true. Default behavior is to separate on spaces.    allowStdin: false,                           // Allow input value to be read from stdin if the provided value is `-`. Can also be set to `only` to allow flag to always read from stdin even if no value is provided.  }),  // flag with no value (-f, --force)  force: Flags.boolean({    // Boolean flags take all the same properties described in the previous example    // in addition to:    allowNo: true // Support reversible boolean flag with `--no-` prefix (e.g. `--no-force`). This is disabled by default.  }),}
Custom Flags​
For larger CLIs, it can be useful to declare a custom flag that can be shared amongst multiple commands. Here is an example of a custom flag:
// src/flags.tsimport {Flags} from '@oclif/core'class Team {  public name: string;  // etc...}function getTeam(): Promise<Team> {  // imagine this reads a configuration file or something to find the team  return new Team()}export const team = Flags.custom<Team>({  char: 't',  description: 'team to use',  default: async () => getTeam(),})// src/commands/mycommand.tsimport {team} from '../flags'import {Command} from '@oclif/core'export class MyCLI extends Command {  static flags = {    team: team({      required: true,    }),  }  async run() {    const {flags} = await this.parse(MyCLI)    if (flags.team) console.log(`--team is ${flags.team.name}`)  }}
In the Salesforce CLI we make heavy use of custom flags. For example,

A salesforceId flag that ensures the provided string is a valid Salesforce Id.
A duration flag that converts a provided integer into a Duration instance that we use for working with time based values.

These and more are located here if you want to see more examples. You can also read the API docs.
Alternative Flag Inputs​
Here are some other ways the user can use input flags. This is assuming the command has flags like -f, --file=file and -v, --verbose (string and boolean flag):
$ mycli --verbose$ mycli -v$ mycli --file=foo$ mycli --file foo$ mycli -f foo$ mycli -f=foo$ mycli -ffoo$ mycli -vffoo
The last one seems a little odd at first glance, but it's relatively standard in unix and makes commands like tar -xvzfmytarball.tar.gz possible.
See our blog post CLI Flags Explained for a deeper dive into CLI flags.Edit this pageLast updated on Dec 20, 2024 by Mike Donnalley\n\nAPI ReferenceCommand FlagsOn this pageCommand FlagsFlag options are non-positional arguments passed to the command. Flags can either be option flags which take an argument, or boolean flags which do not. An option flag must have an argument.
For example, if this command was run like this:
$ mycli --force --file=./myfile
It would be declared like this:
import {Command, Flags} from '@oclif/core'export class MyCLI extends Command {  static flags = {    // can pass either --force or -f    force: Flags.boolean({char: 'f'}),    file: Flags.string(),  }  async run() {    const {flags} = await this.parse(MyCLI)    if (flags.force) console.log('--force is set')    if (flags.file) console.log(`--file is: ${flags.file}`)  }}
oclif supports a wide range of alternative flag inputs.
Here are the options flags can have:
static flags = {  name: Flags.string({    // The following can be set on both boolean and option flag (e.g. string, integer, url, custom, etc) types.    char: 'n',                                   // shorter flag version    summary: 'brief summary',                    // help summary for flag    helpLabel: '--my-flags',                     // The flag label to show in help. Defaults to "[-<char>] --<name>" where -<char> is only displayed if the char is defined.    helpGroup: 'THE BEST FLAGS',                 // Put flag into THE BEST FLAGS group in help    description: 'in-depth overview',            // help description for flag    hidden: false,                               // hide from help    multiple: false,                             // allow setting this flag multiple times    env: 'MY_NAME',                              // default to value of environment variable    options: ['a', 'b'],                         // only allow the value to be from a discrete set    parse: async input => 'output',              // instead of the user input, return a different value    default: 'world',                            // default value if flag not passed (can be an async function that returns a string or undefined)    defaultHelp: 'a dynamic value'               // dynamic default value to show in help output (e.g. current working directory). Can be an async function that returns a string or undefined    required: false,                             // make flag required    aliases: ['username', 'u'],                  // aliases for the flag - can be short char or long flags    charAliases: ['u', 'n'],                     // single character aliases for the flag    deprecated: false,                           // mark the flag as deprecated.    deprecateAliases: false,                     // emit deprecation warning anytime a flag alias is provided    noCacheDefault: false,                       // if true, the value returned by defaultHelp will not be cached in the oclif.manifest.json.    dependsOn: ['extra-flag'],                   // this flag requires another flag    exclusive: ['extra-flag'],                   // this flag cannot be specified alongside this other flag    exactlyOne: ['extra-flag', 'another-flag'],  // exactly one of these flags must be provided    relationships: [                             // define complex relationships between flags      // Make this flag dependent on all of these flags      {type: 'all', flags: ['flag-one', 'flag-two']}      // Make this flag dependent on at least one of these flags      {type: 'some', flags: ['flag-three', 'flag-four']}      // Make this flag exclusive of all these flags      {type: 'none', flags: ['flag-five', 'flag-six']}      // Make this flag dependent on all of these flags      {type: 'all', flags: [        'flag-one',        'flag-two',        // Include flag-seven but only when flag-eight is equal to FooBar        {name: 'flag-seven', when: async (flags) => flags['flag-eight'] === 'FooBar'}      ]}    ],    // The following properties cannot be set on boolean flags    helpValue: '<name>',                         // The flag value to show in help. Defaults to "<value>",    multipleNonGreedy: false,                    // Parse one value per flag to allow `-m val1 -m val2` but disallow `-m val1 val2`. Only respected if multiple is set to true    delimiter: ','                               // Delimiter to separate the values for a multiple value flag. Only respected if multiple is set to true. Default behavior is to separate on spaces.    allowStdin: false,                           // Allow input value to be read from stdin if the provided value is `-`. Can also be set to `only` to allow flag to always read from stdin even if no value is provided.  }),  // flag with no value (-f, --force)  force: Flags.boolean({    // Boolean flags take all the same properties described in the previous example    // in addition to:    allowNo: true // Support reversible boolean flag with `--no-` prefix (e.g. `--no-force`). This is disabled by default.  }),}
Custom Flags​
For larger CLIs, it can be useful to declare a custom flag that can be shared amongst multiple commands. Here is an example of a custom flag:
// src/flags.tsimport {Flags} from '@oclif/core'class Team {  public name: string;  // etc...}function getTeam(): Promise<Team> {  // imagine this reads a configuration file or something to find the team  return new Team()}export const team = Flags.custom<Team>({  char: 't',  description: 'team to use',  default: async () => getTeam(),})// src/commands/mycommand.tsimport {team} from '../flags'import {Command} from '@oclif/core'export class MyCLI extends Command {  static flags = {    team: team({      required: true,    }),  }  async run() {    const {flags} = await this.parse(MyCLI)    if (flags.team) console.log(`--team is ${flags.team.name}`)  }}
In the Salesforce CLI we make heavy use of custom flags. For example,

A salesforceId flag that ensures the provided string is a valid Salesforce Id.
A duration flag that converts a provided integer into a Duration instance that we use for working with time based values.

These and more are located here if you want to see more examples. You can also read the API docs.
Alternative Flag Inputs​
Here are some other ways the user can use input flags. This is assuming the command has flags like -f, --file=file and -v, --verbose (string and boolean flag):
$ mycli --verbose$ mycli -v$ mycli --file=foo$ mycli --file foo$ mycli -f foo$ mycli -f=foo$ mycli -ffoo$ mycli -vffoo
The last one seems a little odd at first glance, but it's relatively standard in unix and makes commands like tar -xvzfmytarball.tar.gz possible.
See our blog post CLI Flags Explained for a deeper dive into CLI flags.Edit this pageLast updated on Dec 20, 2024 by Mike DonnalleyPreviousCommand ArgumentsNextConfigCustom FlagsAlternative Flag Inputs\n\n\n\nAPI ReferenceCommand FlagsOn this pageCommand FlagsFlag options are non-positional arguments passed to the command. Flags can either be option flags which take an argument, or boolean flags which do not. An option flag must have an argument.
For example, if this command was run like this:
$ mycli --force --file=./myfile
It would be declared like this:
import {Command, Flags} from '@oclif/core'export class MyCLI extends Command {  static flags = {    // can pass either --force or -f    force: Flags.boolean({char: 'f'}),    file: Flags.string(),  }  async run() {    const {flags} = await this.parse(MyCLI)    if (flags.force) console.log('--force is set')    if (flags.file) console.log(`--file is: ${flags.file}`)  }}
oclif supports a wide range of alternative flag inputs.
Here are the options flags can have:
static flags = {  name: Flags.string({    // The following can be set on both boolean and option flag (e.g. string, integer, url, custom, etc) types.    char: 'n',                                   // shorter flag version    summary: 'brief summary',                    // help summary for flag    helpLabel: '--my-flags',                     // The flag label to show in help. Defaults to "[-<char>] --<name>" where -<char> is only displayed if the char is defined.    helpGroup: 'THE BEST FLAGS',                 // Put flag into THE BEST FLAGS group in help    description: 'in-depth overview',            // help description for flag    hidden: false,                               // hide from help    multiple: false,                             // allow setting this flag multiple times    env: 'MY_NAME',                              // default to value of environment variable    options: ['a', 'b'],                         // only allow the value to be from a discrete set    parse: async input => 'output',              // instead of the user input, return a different value    default: 'world',                            // default value if flag not passed (can be an async function that returns a string or undefined)    defaultHelp: 'a dynamic value'               // dynamic default value to show in help output (e.g. current working directory). Can be an async function that returns a string or undefined    required: false,                             // make flag required    aliases: ['username', 'u'],                  // aliases for the flag - can be short char or long flags    charAliases: ['u', 'n'],                     // single character aliases for the flag    deprecated: false,                           // mark the flag as deprecated.    deprecateAliases: false,                     // emit deprecation warning anytime a flag alias is provided    noCacheDefault: false,                       // if true, the value returned by defaultHelp will not be cached in the oclif.manifest.json.    dependsOn: ['extra-flag'],                   // this flag requires another flag    exclusive: ['extra-flag'],                   // this flag cannot be specified alongside this other flag    exactlyOne: ['extra-flag', 'another-flag'],  // exactly one of these flags must be provided    relationships: [                             // define complex relationships between flags      // Make this flag dependent on all of these flags      {type: 'all', flags: ['flag-one', 'flag-two']}      // Make this flag dependent on at least one of these flags      {type: 'some', flags: ['flag-three', 'flag-four']}      // Make this flag exclusive of all these flags      {type: 'none', flags: ['flag-five', 'flag-six']}      // Make this flag dependent on all of these flags      {type: 'all', flags: [        'flag-one',        'flag-two',        // Include flag-seven but only when flag-eight is equal to FooBar        {name: 'flag-seven', when: async (flags) => flags['flag-eight'] === 'FooBar'}      ]}    ],    // The following properties cannot be set on boolean flags    helpValue: '<name>',                         // The flag value to show in help. Defaults to "<value>",    multipleNonGreedy: false,                    // Parse one value per flag to allow `-m val1 -m val2` but disallow `-m val1 val2`. Only respected if multiple is set to true    delimiter: ','                               // Delimiter to separate the values for a multiple value flag. Only respected if multiple is set to true. Default behavior is to separate on spaces.    allowStdin: false,                           // Allow input value to be read from stdin if the provided value is `-`. Can also be set to `only` to allow flag to always read from stdin even if no value is provided.  }),  // flag with no value (-f, --force)  force: Flags.boolean({    // Boolean flags take all the same properties described in the previous example    // in addition to:    allowNo: true // Support reversible boolean flag with `--no-` prefix (e.g. `--no-force`). This is disabled by default.  }),}
Custom Flags​
For larger CLIs, it can be useful to declare a custom flag that can be shared amongst multiple commands. Here is an example of a custom flag:
// src/flags.tsimport {Flags} from '@oclif/core'class Team {  public name: string;  // etc...}function getTeam(): Promise<Team> {  // imagine this reads a configuration file or something to find the team  return new Team()}export const team = Flags.custom<Team>({  char: 't',  description: 'team to use',  default: async () => getTeam(),})// src/commands/mycommand.tsimport {team} from '../flags'import {Command} from '@oclif/core'export class MyCLI extends Command {  static flags = {    team: team({      required: true,    }),  }  async run() {    const {flags} = await this.parse(MyCLI)    if (flags.team) console.log(`--team is ${flags.team.name}`)  }}
In the Salesforce CLI we make heavy use of custom flags. For example,

A salesforceId flag that ensures the provided string is a valid Salesforce Id.
A duration flag that converts a provided integer into a Duration instance that we use for working with time based values.

These and more are located here if you want to see more examples. You can also read the API docs.
Alternative Flag Inputs​
Here are some other ways the user can use input flags. This is assuming the command has flags like -f, --file=file and -v, --verbose (string and boolean flag):
$ mycli --verbose$ mycli -v$ mycli --file=foo$ mycli --file foo$ mycli -f foo$ mycli -f=foo$ mycli -ffoo$ mycli -vffoo
The last one seems a little odd at first glance, but it's relatively standard in unix and makes commands like tar -xvzfmytarball.tar.gz possible.
See our blog post CLI Flags Explained for a deeper dive into CLI flags.Edit this pageLast updated on Dec 20, 2024 by Mike Donnalley\n\nAPI ReferenceCommand FlagsOn this pageCommand FlagsFlag options are non-positional arguments passed to the command. Flags can either be option flags which take an argument, or boolean flags which do not. An option flag must have an argument.
For example, if this command was run like this:
$ mycli --force --file=./myfile
It would be declared like this:
import {Command, Flags} from '@oclif/core'export class MyCLI extends Command {  static flags = {    // can pass either --force or -f    force: Flags.boolean({char: 'f'}),    file: Flags.string(),  }  async run() {    const {flags} = await this.parse(MyCLI)    if (flags.force) console.log('--force is set')    if (flags.file) console.log(`--file is: ${flags.file}`)  }}
oclif supports a wide range of alternative flag inputs.
Here are the options flags can have:
static flags = {  name: Flags.string({    // The following can be set on both boolean and option flag (e.g. string, integer, url, custom, etc) types.    char: 'n',                                   // shorter flag version    summary: 'brief summary',                    // help summary for flag    helpLabel: '--my-flags',                     // The flag label to show in help. Defaults to "[-<char>] --<name>" where -<char> is only displayed if the char is defined.    helpGroup: 'THE BEST FLAGS',                 // Put flag into THE BEST FLAGS group in help    description: 'in-depth overview',            // help description for flag    hidden: false,                               // hide from help    multiple: false,                             // allow setting this flag multiple times    env: 'MY_NAME',                              // default to value of environment variable    options: ['a', 'b'],                         // only allow the value to be from a discrete set    parse: async input => 'output',              // instead of the user input, return a different value    default: 'world',                            // default value if flag not passed (can be an async function that returns a string or undefined)    defaultHelp: 'a dynamic value'               // dynamic default value to show in help output (e.g. current working directory). Can be an async function that returns a string or undefined    required: false,                             // make flag required    aliases: ['username', 'u'],                  // aliases for the flag - can be short char or long flags    charAliases: ['u', 'n'],                     // single character aliases for the flag    deprecated: false,                           // mark the flag as deprecated.    deprecateAliases: false,                     // emit deprecation warning anytime a flag alias is provided    noCacheDefault: false,                       // if true, the value returned by defaultHelp will not be cached in the oclif.manifest.json.    dependsOn: ['extra-flag'],                   // this flag requires another flag    exclusive: ['extra-flag'],                   // this flag cannot be specified alongside this other flag    exactlyOne: ['extra-flag', 'another-flag'],  // exactly one of these flags must be provided    relationships: [                             // define complex relationships between flags      // Make this flag dependent on all of these flags      {type: 'all', flags: ['flag-one', 'flag-two']}      // Make this flag dependent on at least one of these flags      {type: 'some', flags: ['flag-three', 'flag-four']}      // Make this flag exclusive of all these flags      {type: 'none', flags: ['flag-five', 'flag-six']}      // Make this flag dependent on all of these flags      {type: 'all', flags: [        'flag-one',        'flag-two',        // Include flag-seven but only when flag-eight is equal to FooBar        {name: 'flag-seven', when: async (flags) => flags['flag-eight'] === 'FooBar'}      ]}    ],    // The following properties cannot be set on boolean flags    helpValue: '<name>',                         // The flag value to show in help. Defaults to "<value>",    multipleNonGreedy: false,                    // Parse one value per flag to allow `-m val1 -m val2` but disallow `-m val1 val2`. Only respected if multiple is set to true    delimiter: ','                               // Delimiter to separate the values for a multiple value flag. Only respected if multiple is set to true. Default behavior is to separate on spaces.    allowStdin: false,                           // Allow input value to be read from stdin if the provided value is `-`. Can also be set to `only` to allow flag to always read from stdin even if no value is provided.  }),  // flag with no value (-f, --force)  force: Flags.boolean({    // Boolean flags take all the same properties described in the previous example    // in addition to:    allowNo: true // Support reversible boolean flag with `--no-` prefix (e.g. `--no-force`). This is disabled by default.  }),}
Custom Flags​
For larger CLIs, it can be useful to declare a custom flag that can be shared amongst multiple commands. Here is an example of a custom flag:
// src/flags.tsimport {Flags} from '@oclif/core'class Team {  public name: string;  // etc...}function getTeam(): Promise<Team> {  // imagine this reads a configuration file or something to find the team  return new Team()}export const team = Flags.custom<Team>({  char: 't',  description: 'team to use',  default: async () => getTeam(),})// src/commands/mycommand.tsimport {team} from '../flags'import {Command} from '@oclif/core'export class MyCLI extends Command {  static flags = {    team: team({      required: true,    }),  }  async run() {    const {flags} = await this.parse(MyCLI)    if (flags.team) console.log(`--team is ${flags.team.name}`)  }}
In the Salesforce CLI we make heavy use of custom flags. For example,

A salesforceId flag that ensures the provided string is a valid Salesforce Id.
A duration flag that converts a provided integer into a Duration instance that we use for working with time based values.

These and more are located here if you want to see more examples. You can also read the API docs.
Alternative Flag Inputs​
Here are some other ways the user can use input flags. This is assuming the command has flags like -f, --file=file and -v, --verbose (string and boolean flag):
$ mycli --verbose$ mycli -v$ mycli --file=foo$ mycli --file foo$ mycli -f foo$ mycli -f=foo$ mycli -ffoo$ mycli -vffoo
The last one seems a little odd at first glance, but it's relatively standard in unix and makes commands like tar -xvzfmytarball.tar.gz possible.
See our blog post CLI Flags Explained for a deeper dive into CLI flags.Edit this pageLast updated on Dec 20, 2024 by Mike DonnalleyPreviousCommand ArgumentsNextConfigCustom FlagsAlternative Flag Inputs\n\n\n\nAPI ReferenceCommand FlagsOn this pageCommand FlagsFlag options are non-positional arguments passed to the command. Flags can either be option flags which take an argument, or boolean flags which do not. An option flag must have an argument.
For example, if this command was run like this:
$ mycli --force --file=./myfile
It would be declared like this:
import {Command, Flags} from '@oclif/core'export class MyCLI extends Command {  static flags = {    // can pass either --force or -f    force: Flags.boolean({char: 'f'}),    file: Flags.string(),  }  async run() {    const {flags} = await this.parse(MyCLI)    if (flags.force) console.log('--force is set')    if (flags.file) console.log(`--file is: ${flags.file}`)  }}
oclif supports a wide range of alternative flag inputs.
Here are the options flags can have:
static flags = {  name: Flags.string({    // The following can be set on both boolean and option flag (e.g. string, integer, url, custom, etc) types.    char: 'n',                                   // shorter flag version    summary: 'brief summary',                    // help summary for flag    helpLabel: '--my-flags',                     // The flag label to show in help. Defaults to "[-<char>] --<name>" where -<char> is only displayed if the char is defined.    helpGroup: 'THE BEST FLAGS',                 // Put flag into THE BEST FLAGS group in help    description: 'in-depth overview',            // help description for flag    hidden: false,                               // hide from help    multiple: false,                             // allow setting this flag multiple times    env: 'MY_NAME',                              // default to value of environment variable    options: ['a', 'b'],                         // only allow the value to be from a discrete set    parse: async input => 'output',              // instead of the user input, return a different value    default: 'world',                            // default value if flag not passed (can be an async function that returns a string or undefined)    defaultHelp: 'a dynamic value'               // dynamic default value to show in help output (e.g. current working directory). Can be an async function that returns a string or undefined    required: false,                             // make flag required    aliases: ['username', 'u'],                  // aliases for the flag - can be short char or long flags    charAliases: ['u', 'n'],                     // single character aliases for the flag    deprecated: false,                           // mark the flag as deprecated.    deprecateAliases: false,                     // emit deprecation warning anytime a flag alias is provided    noCacheDefault: false,                       // if true, the value returned by defaultHelp will not be cached in the oclif.manifest.json.    dependsOn: ['extra-flag'],                   // this flag requires another flag    exclusive: ['extra-flag'],                   // this flag cannot be specified alongside this other flag    exactlyOne: ['extra-flag', 'another-flag'],  // exactly one of these flags must be provided    relationships: [                             // define complex relationships between flags      // Make this flag dependent on all of these flags      {type: 'all', flags: ['flag-one', 'flag-two']}      // Make this flag dependent on at least one of these flags      {type: 'some', flags: ['flag-three', 'flag-four']}      // Make this flag exclusive of all these flags      {type: 'none', flags: ['flag-five', 'flag-six']}      // Make this flag dependent on all of these flags      {type: 'all', flags: [        'flag-one',        'flag-two',        // Include flag-seven but only when flag-eight is equal to FooBar        {name: 'flag-seven', when: async (flags) => flags['flag-eight'] === 'FooBar'}      ]}    ],    // The following properties cannot be set on boolean flags    helpValue: '<name>',                         // The flag value to show in help. Defaults to "<value>",    multipleNonGreedy: false,                    // Parse one value per flag to allow `-m val1 -m val2` but disallow `-m val1 val2`. Only respected if multiple is set to true    delimiter: ','                               // Delimiter to separate the values for a multiple value flag. Only respected if multiple is set to true. Default behavior is to separate on spaces.    allowStdin: false,                           // Allow input value to be read from stdin if the provided value is `-`. Can also be set to `only` to allow flag to always read from stdin even if no value is provided.  }),  // flag with no value (-f, --force)  force: Flags.boolean({    // Boolean flags take all the same properties described in the previous example    // in addition to:    allowNo: true // Support reversible boolean flag with `--no-` prefix (e.g. `--no-force`). This is disabled by default.  }),}
Custom Flags​
For larger CLIs, it can be useful to declare a custom flag that can be shared amongst multiple commands. Here is an example of a custom flag:
// src/flags.tsimport {Flags} from '@oclif/core'class Team {  public name: string;  // etc...}function getTeam(): Promise<Team> {  // imagine this reads a configuration file or something to find the team  return new Team()}export const team = Flags.custom<Team>({  char: 't',  description: 'team to use',  default: async () => getTeam(),})// src/commands/mycommand.tsimport {team} from '../flags'import {Command} from '@oclif/core'export class MyCLI extends Command {  static flags = {    team: team({      required: true,    }),  }  async run() {    const {flags} = await this.parse(MyCLI)    if (flags.team) console.log(`--team is ${flags.team.name}`)  }}
In the Salesforce CLI we make heavy use of custom flags. For example,

A salesforceId flag that ensures the provided string is a valid Salesforce Id.
A duration flag that converts a provided integer into a Duration instance that we use for working with time based values.

These and more are located here if you want to see more examples. You can also read the API docs.
Alternative Flag Inputs​
Here are some other ways the user can use input flags. This is assuming the command has flags like -f, --file=file and -v, --verbose (string and boolean flag):
$ mycli --verbose$ mycli -v$ mycli --file=foo$ mycli --file foo$ mycli -f foo$ mycli -f=foo$ mycli -ffoo$ mycli -vffoo
The last one seems a little odd at first glance, but it's relatively standard in unix and makes commands like tar -xvzfmytarball.tar.gz possible.
See our blog post CLI Flags Explained for a deeper dive into CLI flags.Edit this pageLast updated on Dec 20, 2024 by Mike Donnalley\n\nAPI ReferenceCommand FlagsOn this pageCommand FlagsFlag options are non-positional arguments passed to the command. Flags can either be option flags which take an argument, or boolean flags which do not. An option flag must have an argument.
For example, if this command was run like this:
$ mycli --force --file=./myfile
It would be declared like this:
import {Command, Flags} from '@oclif/core'export class MyCLI extends Command {  static flags = {    // can pass either --force or -f    force: Flags.boolean({char: 'f'}),    file: Flags.string(),  }  async run() {    const {flags} = await this.parse(MyCLI)    if (flags.force) console.log('--force is set')    if (flags.file) console.log(`--file is: ${flags.file}`)  }}
oclif supports a wide range of alternative flag inputs.
Here are the options flags can have:
static flags = {  name: Flags.string({    // The following can be set on both boolean and option flag (e.g. string, integer, url, custom, etc) types.    char: 'n',                                   // shorter flag version    summary: 'brief summary',                    // help summary for flag    helpLabel: '--my-flags',                     // The flag label to show in help. Defaults to "[-<char>] --<name>" where -<char> is only displayed if the char is defined.    helpGroup: 'THE BEST FLAGS',                 // Put flag into THE BEST FLAGS group in help    description: 'in-depth overview',            // help description for flag    hidden: false,                               // hide from help    multiple: false,                             // allow setting this flag multiple times    env: 'MY_NAME',                              // default to value of environment variable    options: ['a', 'b'],                         // only allow the value to be from a discrete set    parse: async input => 'output',              // instead of the user input, return a different value    default: 'world',                            // default value if flag not passed (can be an async function that returns a string or undefined)    defaultHelp: 'a dynamic value'               // dynamic default value to show in help output (e.g. current working directory). Can be an async function that returns a string or undefined    required: false,                             // make flag required    aliases: ['username', 'u'],                  // aliases for the flag - can be short char or long flags    charAliases: ['u', 'n'],                     // single character aliases for the flag    deprecated: false,                           // mark the flag as deprecated.    deprecateAliases: false,                     // emit deprecation warning anytime a flag alias is provided    noCacheDefault: false,                       // if true, the value returned by defaultHelp will not be cached in the oclif.manifest.json.    dependsOn: ['extra-flag'],                   // this flag requires another flag    exclusive: ['extra-flag'],                   // this flag cannot be specified alongside this other flag    exactlyOne: ['extra-flag', 'another-flag'],  // exactly one of these flags must be provided    relationships: [                             // define complex relationships between flags      // Make this flag dependent on all of these flags      {type: 'all', flags: ['flag-one', 'flag-two']}      // Make this flag dependent on at least one of these flags      {type: 'some', flags: ['flag-three', 'flag-four']}      // Make this flag exclusive of all these flags      {type: 'none', flags: ['flag-five', 'flag-six']}      // Make this flag dependent on all of these flags      {type: 'all', flags: [        'flag-one',        'flag-two',        // Include flag-seven but only when flag-eight is equal to FooBar        {name: 'flag-seven', when: async (flags) => flags['flag-eight'] === 'FooBar'}      ]}    ],    // The following properties cannot be set on boolean flags    helpValue: '<name>',                         // The flag value to show in help. Defaults to "<value>",    multipleNonGreedy: false,                    // Parse one value per flag to allow `-m val1 -m val2` but disallow `-m val1 val2`. Only respected if multiple is set to true    delimiter: ','                               // Delimiter to separate the values for a multiple value flag. Only respected if multiple is set to true. Default behavior is to separate on spaces.    allowStdin: false,                           // Allow input value to be read from stdin if the provided value is `-`. Can also be set to `only` to allow flag to always read from stdin even if no value is provided.  }),  // flag with no value (-f, --force)  force: Flags.boolean({    // Boolean flags take all the same properties described in the previous example    // in addition to:    allowNo: true // Support reversible boolean flag with `--no-` prefix (e.g. `--no-force`). This is disabled by default.  }),}
Custom Flags​
For larger CLIs, it can be useful to declare a custom flag that can be shared amongst multiple commands. Here is an example of a custom flag:
// src/flags.tsimport {Flags} from '@oclif/core'class Team {  public name: string;  // etc...}function getTeam(): Promise<Team> {  // imagine this reads a configuration file or something to find the team  return new Team()}export const team = Flags.custom<Team>({  char: 't',  description: 'team to use',  default: async () => getTeam(),})// src/commands/mycommand.tsimport {team} from '../flags'import {Command} from '@oclif/core'export class MyCLI extends Command {  static flags = {    team: team({      required: true,    }),  }  async run() {    const {flags} = await this.parse(MyCLI)    if (flags.team) console.log(`--team is ${flags.team.name}`)  }}
In the Salesforce CLI we make heavy use of custom flags. For example,

A salesforceId flag that ensures the provided string is a valid Salesforce Id.
A duration flag that converts a provided integer into a Duration instance that we use for working with time based values.

These and more are located here if you want to see more examples. You can also read the API docs.
Alternative Flag Inputs​
Here are some other ways the user can use input flags. This is assuming the command has flags like -f, --file=file and -v, --verbose (string and boolean flag):
$ mycli --verbose$ mycli -v$ mycli --file=foo$ mycli --file foo$ mycli -f foo$ mycli -f=foo$ mycli -ffoo$ mycli -vffoo
The last one seems a little odd at first glance, but it's relatively standard in unix and makes commands like tar -xvzfmytarball.tar.gz possible.
See our blog post CLI Flags Explained for a deeper dive into CLI flags.Edit this pageLast updated on Dec 20, 2024 by Mike DonnalleyPreviousCommand ArgumentsNextConfigCustom FlagsAlternative Flag Inputs\n\n\n\nAPI ReferenceCommand ArgumentsCommand ArgumentsArguments are positional arguments passed to the command. For example, if this command was run with mycli arg1 arg2 it would be declared like this:
import {Args, Command} from '@oclif/core'export class MyCLI extends Command {  static args = {    firstArg: Args.string(),    secondArg: Args.string(),  }  async run() {    // can get args as an object    const {args} = await this.parse(MyCLI)    this.log(`running my command with args: ${args.firstArg}, ${args.secondArg}`)    // can also get the args as an array    const {argv} = await this.parse(MyCLI)    this.log(`running my command with args: ${argv[0]}, ${argv[1]}`)  }}
Here are the options arguments can have:
static args = {  firstArg: Args.string(    {      name: 'file',                     // name of arg to show in help and reference with args[name]      required: false,                  // make the arg required with `required: true`      description: 'output file',       // help description      hidden: true,                     // hide this arg from help      parse: async input => 'output',   // instead of the user input, return a different value      default: 'world',                 // default value if no arg input. Can also be an async function.      defaultHelp: 'a dynamic value'    // dynamic default value to show in help output (e.g. current working directory). Can be an async function that returns a string or undefined      options: ['a', 'b'],              // only allow input to be from a discrete set      ignoreStdin: false,               // set to true to ignore any value provided by stdin      noCacheDefault: false             // if true, the value returned by defaultHelp will not be cached in the oclif.manifest.json.    }  ),}
Here are the types of args that Args exports:

string
integer
boolean
url
file
directory
custom

For variable length arguments, disable argument validation with static strict = false on the command.
import {Args, Command} from '@oclif/core'export class MyCLI extends Command {  static args = {    things: Args.string(),  }  static strict = false  async run() {    // If you're using strict=false you should use argv to access the provided args.    const {argv} = await this.parse(MyCLI)    this.log(`running my command with args: ${argv[0]}, ${argv[1]}`)  }}
Arguments can also be piped via stdin. This is particularly useful when creating scripts with your CLI commands. For example:
$ echo arg1 | myclirunning my command with args: arg1
This can behavior can be disabled on an argument by setting the ignoreStdin property to true on the argument's definition.Edit this pageLast updated on Dec 20, 2024 by Mike Donnalley\n\nAPI ReferenceCommand ArgumentsCommand ArgumentsArguments are positional arguments passed to the command. For example, if this command was run with mycli arg1 arg2 it would be declared like this:
import {Args, Command} from '@oclif/core'export class MyCLI extends Command {  static args = {    firstArg: Args.string(),    secondArg: Args.string(),  }  async run() {    // can get args as an object    const {args} = await this.parse(MyCLI)    this.log(`running my command with args: ${args.firstArg}, ${args.secondArg}`)    // can also get the args as an array    const {argv} = await this.parse(MyCLI)    this.log(`running my command with args: ${argv[0]}, ${argv[1]}`)  }}
Here are the options arguments can have:
static args = {  firstArg: Args.string(    {      name: 'file',                     // name of arg to show in help and reference with args[name]      required: false,                  // make the arg required with `required: true`      description: 'output file',       // help description      hidden: true,                     // hide this arg from help      parse: async input => 'output',   // instead of the user input, return a different value      default: 'world',                 // default value if no arg input. Can also be an async function.      defaultHelp: 'a dynamic value'    // dynamic default value to show in help output (e.g. current working directory). Can be an async function that returns a string or undefined      options: ['a', 'b'],              // only allow input to be from a discrete set      ignoreStdin: false,               // set to true to ignore any value provided by stdin      noCacheDefault: false             // if true, the value returned by defaultHelp will not be cached in the oclif.manifest.json.    }  ),}
Here are the types of args that Args exports:

string
integer
boolean
url
file
directory
custom

For variable length arguments, disable argument validation with static strict = false on the command.
import {Args, Command} from '@oclif/core'export class MyCLI extends Command {  static args = {    things: Args.string(),  }  static strict = false  async run() {    // If you're using strict=false you should use argv to access the provided args.    const {argv} = await this.parse(MyCLI)    this.log(`running my command with args: ${argv[0]}, ${argv[1]}`)  }}
Arguments can also be piped via stdin. This is particularly useful when creating scripts with your CLI commands. For example:
$ echo arg1 | myclirunning my command with args: arg1
This can behavior can be disabled on an argument by setting the ignoreStdin property to true on the argument's definition.Edit this pageLast updated on Dec 20, 2024 by Mike DonnalleyPreviousCommandsNextCommand Flags\n\n\n\nAPI ReferenceHooksOn this pageHooksoclif exposes lifecycle event hooks such as init and command_not_found. See below for a list of all the lifecycle events. In addition to these built-in events, you can create your own events and allow commands/plugins to watch for these custom events. It's a great way to allow multiple plugins to interact with each other.
Multiple hooks are run in parallel. This behavior may change in a future release.
A basic hook looks like the following in TypeScript:
import {Hook} from '@oclif/core'const hook: Hook.Init = async function (options) {  console.log(`example init hook running before ${options.id}`)}export default hook
The hook must also be declared with the event's name and hook's file path under oclif's settings in package.json:
"oclif": {  "commands": "./lib/commands",  "hooks": {    "init": "./lib/hooks/init/example"  }}
Multiple hooks of the same event type can be declared with an array.
"oclif": {  "commands": "./lib/commands",  "hooks": {    "init": [      "./lib/hooks/init/example",      "./lib/hooks/init/another_hook"    ]  }}
You can create hooks with oclif generate hook myhook --event=init.
Lifecycle Events​

init - runs when the CLI is initialized before a command is found to run
prerun - runs after init and after the command is found, but just before running the command itself
command_not_found - runs if a command is not found before the error is displayed
command_incomplete - runs if a command is not found but it is a partial of an existing command. Only works if flexible taxonomy is enabled. Useful for instances where you'd like to present a prompt with all the matching commands. See Salesforce CLI's implementation.
jit_plugin_not_installed - runs if a command from a JIT plugin is executed but the plugin isn't installed yet. See Salesforce CLI's implementation.
preparse - runs before flags and args are parsed and validated. Useful if you need to manipulate the input. See Salesforce CLI's implementation. This can only be implemented by the root CLI.
postrun - runs after the command only if the command finishes with no error
finally - runs after the command finishes, regardless of the command's exit status

Custom Events​
Custom events are just like lifecycle events, but you need to call this.config.runHook() to fire the event.
For example, you could define an analytics post function that you will run in your command after submitting analytics telemetry. First define:
src/hooks/analytics/post.ts
const hook = async function (options: {id: string}) {  // code to post options.id to analytics server}export default hook
package.json
  "oclif": {    "commands": "./lib/commands",    "hooks": {      "analytics": "./lib/hooks/analytics/post"    },  },
Then in any command you want to trigger the event:
export class extends Command {  async run() {    // emit analytics    await this.config.runHook('analytics', {id: 'my_command'})  }}
If you need to exit during a hook, use options.context.error() or options.context.exit(). Throwing an Error will not cause the CLI to exit - this is to prevent an issues such a single plugin's init hook causing a CLI to immediately fail on every command execution.Edit this pageLast updated on Dec 20, 2024 by Mike Donnalley\n\nAPI ReferenceHooksOn this pageHooksoclif exposes lifecycle event hooks such as init and command_not_found. See below for a list of all the lifecycle events. In addition to these built-in events, you can create your own events and allow commands/plugins to watch for these custom events. It's a great way to allow multiple plugins to interact with each other.
Multiple hooks are run in parallel. This behavior may change in a future release.
A basic hook looks like the following in TypeScript:
import {Hook} from '@oclif/core'const hook: Hook.Init = async function (options) {  console.log(`example init hook running before ${options.id}`)}export default hook
The hook must also be declared with the event's name and hook's file path under oclif's settings in package.json:
"oclif": {  "commands": "./lib/commands",  "hooks": {    "init": "./lib/hooks/init/example"  }}
Multiple hooks of the same event type can be declared with an array.
"oclif": {  "commands": "./lib/commands",  "hooks": {    "init": [      "./lib/hooks/init/example",      "./lib/hooks/init/another_hook"    ]  }}
You can create hooks with oclif generate hook myhook --event=init.
Lifecycle Events​

init - runs when the CLI is initialized before a command is found to run
prerun - runs after init and after the command is found, but just before running the command itself
command_not_found - runs if a command is not found before the error is displayed
command_incomplete - runs if a command is not found but it is a partial of an existing command. Only works if flexible taxonomy is enabled. Useful for instances where you'd like to present a prompt with all the matching commands. See Salesforce CLI's implementation.
jit_plugin_not_installed - runs if a command from a JIT plugin is executed but the plugin isn't installed yet. See Salesforce CLI's implementation.
preparse - runs before flags and args are parsed and validated. Useful if you need to manipulate the input. See Salesforce CLI's implementation. This can only be implemented by the root CLI.
postrun - runs after the command only if the command finishes with no error
finally - runs after the command finishes, regardless of the command's exit status

Custom Events​
Custom events are just like lifecycle events, but you need to call this.config.runHook() to fire the event.
For example, you could define an analytics post function that you will run in your command after submitting analytics telemetry. First define:
src/hooks/analytics/post.ts
const hook = async function (options: {id: string}) {  // code to post options.id to analytics server}export default hook
package.json
  "oclif": {    "commands": "./lib/commands",    "hooks": {      "analytics": "./lib/hooks/analytics/post"    },  },
Then in any command you want to trigger the event:
export class extends Command {  async run() {    // emit analytics    await this.config.runHook('analytics', {id: 'my_command'})  }}
If you need to exit during a hook, use options.context.error() or options.context.exit(). Throwing an Error will not cause the CLI to exit - this is to prevent an issues such a single plugin's init hook causing a CLI to immediately fail on every command execution.Edit this pageLast updated on Dec 20, 2024 by Mike DonnalleyPreviousTopic SeparatorsNextPluginsLifecycle EventsCustom Events\n\n\n\nAPI ReferenceHooksOn this pageHooksoclif exposes lifecycle event hooks such as init and command_not_found. See below for a list of all the lifecycle events. In addition to these built-in events, you can create your own events and allow commands/plugins to watch for these custom events. It's a great way to allow multiple plugins to interact with each other.
Multiple hooks are run in parallel. This behavior may change in a future release.
A basic hook looks like the following in TypeScript:
import {Hook} from '@oclif/core'const hook: Hook.Init = async function (options) {  console.log(`example init hook running before ${options.id}`)}export default hook
The hook must also be declared with the event's name and hook's file path under oclif's settings in package.json:
"oclif": {  "commands": "./lib/commands",  "hooks": {    "init": "./lib/hooks/init/example"  }}
Multiple hooks of the same event type can be declared with an array.
"oclif": {  "commands": "./lib/commands",  "hooks": {    "init": [      "./lib/hooks/init/example",      "./lib/hooks/init/another_hook"    ]  }}
You can create hooks with oclif generate hook myhook --event=init.
Lifecycle Events​

init - runs when the CLI is initialized before a command is found to run
prerun - runs after init and after the command is found, but just before running the command itself
command_not_found - runs if a command is not found before the error is displayed
command_incomplete - runs if a command is not found but it is a partial of an existing command. Only works if flexible taxonomy is enabled. Useful for instances where you'd like to present a prompt with all the matching commands. See Salesforce CLI's implementation.
jit_plugin_not_installed - runs if a command from a JIT plugin is executed but the plugin isn't installed yet. See Salesforce CLI's implementation.
preparse - runs before flags and args are parsed and validated. Useful if you need to manipulate the input. See Salesforce CLI's implementation. This can only be implemented by the root CLI.
postrun - runs after the command only if the command finishes with no error
finally - runs after the command finishes, regardless of the command's exit status

Custom Events​
Custom events are just like lifecycle events, but you need to call this.config.runHook() to fire the event.
For example, you could define an analytics post function that you will run in your command after submitting analytics telemetry. First define:
src/hooks/analytics/post.ts
const hook = async function (options: {id: string}) {  // code to post options.id to analytics server}export default hook
package.json
  "oclif": {    "commands": "./lib/commands",    "hooks": {      "analytics": "./lib/hooks/analytics/post"    },  },
Then in any command you want to trigger the event:
export class extends Command {  async run() {    // emit analytics    await this.config.runHook('analytics', {id: 'my_command'})  }}
If you need to exit during a hook, use options.context.error() or options.context.exit(). Throwing an Error will not cause the CLI to exit - this is to prevent an issues such a single plugin's init hook causing a CLI to immediately fail on every command execution.Edit this pageLast updated on Dec 20, 2024 by Mike Donnalley\n\nAPI ReferenceHooksOn this pageHooksoclif exposes lifecycle event hooks such as init and command_not_found. See below for a list of all the lifecycle events. In addition to these built-in events, you can create your own events and allow commands/plugins to watch for these custom events. It's a great way to allow multiple plugins to interact with each other.
Multiple hooks are run in parallel. This behavior may change in a future release.
A basic hook looks like the following in TypeScript:
import {Hook} from '@oclif/core'const hook: Hook.Init = async function (options) {  console.log(`example init hook running before ${options.id}`)}export default hook
The hook must also be declared with the event's name and hook's file path under oclif's settings in package.json:
"oclif": {  "commands": "./lib/commands",  "hooks": {    "init": "./lib/hooks/init/example"  }}
Multiple hooks of the same event type can be declared with an array.
"oclif": {  "commands": "./lib/commands",  "hooks": {    "init": [      "./lib/hooks/init/example",      "./lib/hooks/init/another_hook"    ]  }}
You can create hooks with oclif generate hook myhook --event=init.
Lifecycle Events​

init - runs when the CLI is initialized before a command is found to run
prerun - runs after init and after the command is found, but just before running the command itself
command_not_found - runs if a command is not found before the error is displayed
command_incomplete - runs if a command is not found but it is a partial of an existing command. Only works if flexible taxonomy is enabled. Useful for instances where you'd like to present a prompt with all the matching commands. See Salesforce CLI's implementation.
jit_plugin_not_installed - runs if a command from a JIT plugin is executed but the plugin isn't installed yet. See Salesforce CLI's implementation.
preparse - runs before flags and args are parsed and validated. Useful if you need to manipulate the input. See Salesforce CLI's implementation. This can only be implemented by the root CLI.
postrun - runs after the command only if the command finishes with no error
finally - runs after the command finishes, regardless of the command's exit status

Custom Events​
Custom events are just like lifecycle events, but you need to call this.config.runHook() to fire the event.
For example, you could define an analytics post function that you will run in your command after submitting analytics telemetry. First define:
src/hooks/analytics/post.ts
const hook = async function (options: {id: string}) {  // code to post options.id to analytics server}export default hook
package.json
  "oclif": {    "commands": "./lib/commands",    "hooks": {      "analytics": "./lib/hooks/analytics/post"    },  },
Then in any command you want to trigger the event:
export class extends Command {  async run() {    // emit analytics    await this.config.runHook('analytics', {id: 'my_command'})  }}
If you need to exit during a hook, use options.context.error() or options.context.exit(). Throwing an Error will not cause the CLI to exit - this is to prevent an issues such a single plugin's init hook causing a CLI to immediately fail on every command execution.Edit this pageLast updated on Dec 20, 2024 by Mike DonnalleyPreviousTopic SeparatorsNextPluginsLifecycle EventsCustom Events\n\n\n\nAPI ReferenceHooksOn this pageHooksoclif exposes lifecycle event hooks such as init and command_not_found. See below for a list of all the lifecycle events. In addition to these built-in events, you can create your own events and allow commands/plugins to watch for these custom events. It's a great way to allow multiple plugins to interact with each other.
Multiple hooks are run in parallel. This behavior may change in a future release.
A basic hook looks like the following in TypeScript:
import {Hook} from '@oclif/core'const hook: Hook.Init = async function (options) {  console.log(`example init hook running before ${options.id}`)}export default hook
The hook must also be declared with the event's name and hook's file path under oclif's settings in package.json:
"oclif": {  "commands": "./lib/commands",  "hooks": {    "init": "./lib/hooks/init/example"  }}
Multiple hooks of the same event type can be declared with an array.
"oclif": {  "commands": "./lib/commands",  "hooks": {    "init": [      "./lib/hooks/init/example",      "./lib/hooks/init/another_hook"    ]  }}
You can create hooks with oclif generate hook myhook --event=init.
Lifecycle Events​

init - runs when the CLI is initialized before a command is found to run
prerun - runs after init and after the command is found, but just before running the command itself
command_not_found - runs if a command is not found before the error is displayed
command_incomplete - runs if a command is not found but it is a partial of an existing command. Only works if flexible taxonomy is enabled. Useful for instances where you'd like to present a prompt with all the matching commands. See Salesforce CLI's implementation.
jit_plugin_not_installed - runs if a command from a JIT plugin is executed but the plugin isn't installed yet. See Salesforce CLI's implementation.
preparse - runs before flags and args are parsed and validated. Useful if you need to manipulate the input. See Salesforce CLI's implementation. This can only be implemented by the root CLI.
postrun - runs after the command only if the command finishes with no error
finally - runs after the command finishes, regardless of the command's exit status

Custom Events​
Custom events are just like lifecycle events, but you need to call this.config.runHook() to fire the event.
For example, you could define an analytics post function that you will run in your command after submitting analytics telemetry. First define:
src/hooks/analytics/post.ts
const hook = async function (options: {id: string}) {  // code to post options.id to analytics server}export default hook
package.json
  "oclif": {    "commands": "./lib/commands",    "hooks": {      "analytics": "./lib/hooks/analytics/post"    },  },
Then in any command you want to trigger the event:
export class extends Command {  async run() {    // emit analytics    await this.config.runHook('analytics', {id: 'my_command'})  }}
If you need to exit during a hook, use options.context.error() or options.context.exit(). Throwing an Error will not cause the CLI to exit - this is to prevent an issues such a single plugin's init hook causing a CLI to immediately fail on every command execution.Edit this pageLast updated on Dec 20, 2024 by Mike Donnalley\n\nAPI ReferenceHooksOn this pageHooksoclif exposes lifecycle event hooks such as init and command_not_found. See below for a list of all the lifecycle events. In addition to these built-in events, you can create your own events and allow commands/plugins to watch for these custom events. It's a great way to allow multiple plugins to interact with each other.
Multiple hooks are run in parallel. This behavior may change in a future release.
A basic hook looks like the following in TypeScript:
import {Hook} from '@oclif/core'const hook: Hook.Init = async function (options) {  console.log(`example init hook running before ${options.id}`)}export default hook
The hook must also be declared with the event's name and hook's file path under oclif's settings in package.json:
"oclif": {  "commands": "./lib/commands",  "hooks": {    "init": "./lib/hooks/init/example"  }}
Multiple hooks of the same event type can be declared with an array.
"oclif": {  "commands": "./lib/commands",  "hooks": {    "init": [      "./lib/hooks/init/example",      "./lib/hooks/init/another_hook"    ]  }}
You can create hooks with oclif generate hook myhook --event=init.
Lifecycle Events​

init - runs when the CLI is initialized before a command is found to run
prerun - runs after init and after the command is found, but just before running the command itself
command_not_found - runs if a command is not found before the error is displayed
command_incomplete - runs if a command is not found but it is a partial of an existing command. Only works if flexible taxonomy is enabled. Useful for instances where you'd like to present a prompt with all the matching commands. See Salesforce CLI's implementation.
jit_plugin_not_installed - runs if a command from a JIT plugin is executed but the plugin isn't installed yet. See Salesforce CLI's implementation.
preparse - runs before flags and args are parsed and validated. Useful if you need to manipulate the input. See Salesforce CLI's implementation. This can only be implemented by the root CLI.
postrun - runs after the command only if the command finishes with no error
finally - runs after the command finishes, regardless of the command's exit status

Custom Events​
Custom events are just like lifecycle events, but you need to call this.config.runHook() to fire the event.
For example, you could define an analytics post function that you will run in your command after submitting analytics telemetry. First define:
src/hooks/analytics/post.ts
const hook = async function (options: {id: string}) {  // code to post options.id to analytics server}export default hook
package.json
  "oclif": {    "commands": "./lib/commands",    "hooks": {      "analytics": "./lib/hooks/analytics/post"    },  },
Then in any command you want to trigger the event:
export class extends Command {  async run() {    // emit analytics    await this.config.runHook('analytics', {id: 'my_command'})  }}
If you need to exit during a hook, use options.context.error() or options.context.exit(). Throwing an Error will not cause the CLI to exit - this is to prevent an issues such a single plugin's init hook causing a CLI to immediately fail on every command execution.Edit this pageLast updated on Dec 20, 2024 by Mike DonnalleyPreviousTopic SeparatorsNextPluginsLifecycle EventsCustom Events\n\n\n\nAPI ReferenceHelp ClassesOn this pageHelp ClassesOut of the box oclif provides a great help experience for CLIs. Users can invoke help with the --help flag.
$ my-cli login --help
If you want your CLI to have an explicit help command, add @oclif/plugin-help as an oclif plugin in your config.
$ my-cli help
Custom Help​
To get started, first define the filepath to your help class in oclif's config in package.json. This is a relative path to the help class, without a file extension.
For this example, the help class will be created in a file at "[project root]/src/help.ts".
{  "oclif": {    "helpClass": "./dist/help"  }}
From here there are two paths, implement the HelpBase abstract class yourself or overwrite the parts of the default Help class you want to customize (ex: how command usage is displayed). We recommend the latter approach but cover both below.
Extending the HelpBase class​
The HelpBase abstract class provides a starting point requiring the minimum needed methods implemented to be compatible with oclif.
import {Command, HelpBase} from '@oclif/core';export default class CustomHelp extends HelpBase {  showHelp(args: string[]) {    console.log('This will be displayed in multi-command CLIs')  }  showCommandHelp(command: Command.Loadable) {    console.log('This will be displayed in single-command CLIs')  }}
The showHelp method is called by oclif to display help in multi-command CLIs, while showCommandHelp is called directly for single-command CLIs.
The class is instantiated with a config property that provides helpful context for constructing your custom output.
To see an example of what is possible take a look at the source code for the default Help class exported from @oclif/core.
Extending the default Help class​
The default Help class provides many method “hooks” that make it easy to override the particular parts of help's output you want to customize.
import {Command, Help, Interfaces} from '@oclif/core'export default class MyHelpClass extends Help {  // acts as a "router"  // and based on the args it receives  // calls one of showRootHelp, showTopicHelp,  // the formatting for an individual command  formatCommand(command: Command.Loadable): string {}  // the formatting for a list of commands  formatCommands(commands: Command.Loadable[]): string {}  // displayed for the root help  formatRoot(): string {}  // the formatting for an individual topic  formatTopic(topic: Interfaces.Topic): string {}  // the default implementations of showRootHelp  // showTopicHelp and showCommandHelp  // will call various format methods that  // provide the formatting for their corresponding  // help sections;  // these can be overwritten as well  // the formatting responsible for the header  // the formatting for a list of topics  protected formatTopics(topics: Interfaces.Topic[]): string {}  // display help for a command  showCommandHelp(command: Command.Loadable): void {}  // or showCommandHelp  showHelp(args: string[]): void {}  // display the root help of a CLI  showRootHelp(): void {}  // display help for a topic  showTopicHelp(topic: Interfaces.Topic): void {}}
To see the default implementation of these methods take a look at the default Help class exported from @oclif/core.
To start experimenting, define showCommandHelp in your custom help class and change the output.
import {Command, Help} from '@oclif/core';export default class MyHelpClass extends Help {  public showCommandHelp(command: Command.Loadable) {    console.log('Display my custom command help!')  }}
Then run help for any command.
$ my-cli login --helpDisplay my custom command help!Edit this pageLast updated on Dec 20, 2024 by Mike Donnalley\n\nAPI ReferenceHelp ClassesOn this pageHelp ClassesOut of the box oclif provides a great help experience for CLIs. Users can invoke help with the --help flag.
$ my-cli login --help
If you want your CLI to have an explicit help command, add @oclif/plugin-help as an oclif plugin in your config.
$ my-cli help
Custom Help​
To get started, first define the filepath to your help class in oclif's config in package.json. This is a relative path to the help class, without a file extension.
For this example, the help class will be created in a file at "[project root]/src/help.ts".
{  "oclif": {    "helpClass": "./dist/help"  }}
From here there are two paths, implement the HelpBase abstract class yourself or overwrite the parts of the default Help class you want to customize (ex: how command usage is displayed). We recommend the latter approach but cover both below.
Extending the HelpBase class​
The HelpBase abstract class provides a starting point requiring the minimum needed methods implemented to be compatible with oclif.
import {Command, HelpBase} from '@oclif/core';export default class CustomHelp extends HelpBase {  showHelp(args: string[]) {    console.log('This will be displayed in multi-command CLIs')  }  showCommandHelp(command: Command.Loadable) {    console.log('This will be displayed in single-command CLIs')  }}
The showHelp method is called by oclif to display help in multi-command CLIs, while showCommandHelp is called directly for single-command CLIs.
The class is instantiated with a config property that provides helpful context for constructing your custom output.
To see an example of what is possible take a look at the source code for the default Help class exported from @oclif/core.
Extending the default Help class​
The default Help class provides many method “hooks” that make it easy to override the particular parts of help's output you want to customize.
import {Command, Help, Interfaces} from '@oclif/core'export default class MyHelpClass extends Help {  // acts as a "router"  // and based on the args it receives  // calls one of showRootHelp, showTopicHelp,  // the formatting for an individual command  formatCommand(command: Command.Loadable): string {}  // the formatting for a list of commands  formatCommands(commands: Command.Loadable[]): string {}  // displayed for the root help  formatRoot(): string {}  // the formatting for an individual topic  formatTopic(topic: Interfaces.Topic): string {}  // the default implementations of showRootHelp  // showTopicHelp and showCommandHelp  // will call various format methods that  // provide the formatting for their corresponding  // help sections;  // these can be overwritten as well  // the formatting responsible for the header  // the formatting for a list of topics  protected formatTopics(topics: Interfaces.Topic[]): string {}  // display help for a command  showCommandHelp(command: Command.Loadable): void {}  // or showCommandHelp  showHelp(args: string[]): void {}  // display the root help of a CLI  showRootHelp(): void {}  // display help for a topic  showTopicHelp(topic: Interfaces.Topic): void {}}
To see the default implementation of these methods take a look at the default Help class exported from @oclif/core.
To start experimenting, define showCommandHelp in your custom help class and change the output.
import {Command, Help} from '@oclif/core';export default class MyHelpClass extends Help {  public showCommandHelp(command: Command.Loadable) {    console.log('Display my custom command help!')  }}
Then run help for any command.
$ my-cli login --helpDisplay my custom command help!Edit this pageLast updated on Dec 20, 2024 by Mike DonnalleyPreviousPluginsNextPerformanceCustom HelpExtending the HelpBase classExtending the default Help class\n\n\n\nAPI ReferenceHelp ClassesOn this pageHelp ClassesOut of the box oclif provides a great help experience for CLIs. Users can invoke help with the --help flag.
$ my-cli login --help
If you want your CLI to have an explicit help command, add @oclif/plugin-help as an oclif plugin in your config.
$ my-cli help
Custom Help​
To get started, first define the filepath to your help class in oclif's config in package.json. This is a relative path to the help class, without a file extension.
For this example, the help class will be created in a file at "[project root]/src/help.ts".
{  "oclif": {    "helpClass": "./dist/help"  }}
From here there are two paths, implement the HelpBase abstract class yourself or overwrite the parts of the default Help class you want to customize (ex: how command usage is displayed). We recommend the latter approach but cover both below.
Extending the HelpBase class​
The HelpBase abstract class provides a starting point requiring the minimum needed methods implemented to be compatible with oclif.
import {Command, HelpBase} from '@oclif/core';export default class CustomHelp extends HelpBase {  showHelp(args: string[]) {    console.log('This will be displayed in multi-command CLIs')  }  showCommandHelp(command: Command.Loadable) {    console.log('This will be displayed in single-command CLIs')  }}
The showHelp method is called by oclif to display help in multi-command CLIs, while showCommandHelp is called directly for single-command CLIs.
The class is instantiated with a config property that provides helpful context for constructing your custom output.
To see an example of what is possible take a look at the source code for the default Help class exported from @oclif/core.
Extending the default Help class​
The default Help class provides many method “hooks” that make it easy to override the particular parts of help's output you want to customize.
import {Command, Help, Interfaces} from '@oclif/core'export default class MyHelpClass extends Help {  // acts as a "router"  // and based on the args it receives  // calls one of showRootHelp, showTopicHelp,  // the formatting for an individual command  formatCommand(command: Command.Loadable): string {}  // the formatting for a list of commands  formatCommands(commands: Command.Loadable[]): string {}  // displayed for the root help  formatRoot(): string {}  // the formatting for an individual topic  formatTopic(topic: Interfaces.Topic): string {}  // the default implementations of showRootHelp  // showTopicHelp and showCommandHelp  // will call various format methods that  // provide the formatting for their corresponding  // help sections;  // these can be overwritten as well  // the formatting responsible for the header  // the formatting for a list of topics  protected formatTopics(topics: Interfaces.Topic[]): string {}  // display help for a command  showCommandHelp(command: Command.Loadable): void {}  // or showCommandHelp  showHelp(args: string[]): void {}  // display the root help of a CLI  showRootHelp(): void {}  // display help for a topic  showTopicHelp(topic: Interfaces.Topic): void {}}
To see the default implementation of these methods take a look at the default Help class exported from @oclif/core.
To start experimenting, define showCommandHelp in your custom help class and change the output.
import {Command, Help} from '@oclif/core';export default class MyHelpClass extends Help {  public showCommandHelp(command: Command.Loadable) {    console.log('Display my custom command help!')  }}
Then run help for any command.
$ my-cli login --helpDisplay my custom command help!Edit this pageLast updated on Dec 20, 2024 by Mike Donnalley\n\nAPI ReferenceHelp ClassesOn this pageHelp ClassesOut of the box oclif provides a great help experience for CLIs. Users can invoke help with the --help flag.
$ my-cli login --help
If you want your CLI to have an explicit help command, add @oclif/plugin-help as an oclif plugin in your config.
$ my-cli help
Custom Help​
To get started, first define the filepath to your help class in oclif's config in package.json. This is a relative path to the help class, without a file extension.
For this example, the help class will be created in a file at "[project root]/src/help.ts".
{  "oclif": {    "helpClass": "./dist/help"  }}
From here there are two paths, implement the HelpBase abstract class yourself or overwrite the parts of the default Help class you want to customize (ex: how command usage is displayed). We recommend the latter approach but cover both below.
Extending the HelpBase class​
The HelpBase abstract class provides a starting point requiring the minimum needed methods implemented to be compatible with oclif.
import {Command, HelpBase} from '@oclif/core';export default class CustomHelp extends HelpBase {  showHelp(args: string[]) {    console.log('This will be displayed in multi-command CLIs')  }  showCommandHelp(command: Command.Loadable) {    console.log('This will be displayed in single-command CLIs')  }}
The showHelp method is called by oclif to display help in multi-command CLIs, while showCommandHelp is called directly for single-command CLIs.
The class is instantiated with a config property that provides helpful context for constructing your custom output.
To see an example of what is possible take a look at the source code for the default Help class exported from @oclif/core.
Extending the default Help class​
The default Help class provides many method “hooks” that make it easy to override the particular parts of help's output you want to customize.
import {Command, Help, Interfaces} from '@oclif/core'export default class MyHelpClass extends Help {  // acts as a "router"  // and based on the args it receives  // calls one of showRootHelp, showTopicHelp,  // the formatting for an individual command  formatCommand(command: Command.Loadable): string {}  // the formatting for a list of commands  formatCommands(commands: Command.Loadable[]): string {}  // displayed for the root help  formatRoot(): string {}  // the formatting for an individual topic  formatTopic(topic: Interfaces.Topic): string {}  // the default implementations of showRootHelp  // showTopicHelp and showCommandHelp  // will call various format methods that  // provide the formatting for their corresponding  // help sections;  // these can be overwritten as well  // the formatting responsible for the header  // the formatting for a list of topics  protected formatTopics(topics: Interfaces.Topic[]): string {}  // display help for a command  showCommandHelp(command: Command.Loadable): void {}  // or showCommandHelp  showHelp(args: string[]): void {}  // display the root help of a CLI  showRootHelp(): void {}  // display help for a topic  showTopicHelp(topic: Interfaces.Topic): void {}}
To see the default implementation of these methods take a look at the default Help class exported from @oclif/core.
To start experimenting, define showCommandHelp in your custom help class and change the output.
import {Command, Help} from '@oclif/core';export default class MyHelpClass extends Help {  public showCommandHelp(command: Command.Loadable) {    console.log('Display my custom command help!')  }}
Then run help for any command.
$ my-cli login --helpDisplay my custom command help!Edit this pageLast updated on Dec 20, 2024 by Mike DonnalleyPreviousPluginsNextPerformanceCustom HelpExtending the HelpBase classExtending the default Help class\n\n\n\nAPI ReferenceHelp ClassesOn this pageHelp ClassesOut of the box oclif provides a great help experience for CLIs. Users can invoke help with the --help flag.
$ my-cli login --help
If you want your CLI to have an explicit help command, add @oclif/plugin-help as an oclif plugin in your config.
$ my-cli help
Custom Help​
To get started, first define the filepath to your help class in oclif's config in package.json. This is a relative path to the help class, without a file extension.
For this example, the help class will be created in a file at "[project root]/src/help.ts".
{  "oclif": {    "helpClass": "./dist/help"  }}
From here there are two paths, implement the HelpBase abstract class yourself or overwrite the parts of the default Help class you want to customize (ex: how command usage is displayed). We recommend the latter approach but cover both below.
Extending the HelpBase class​
The HelpBase abstract class provides a starting point requiring the minimum needed methods implemented to be compatible with oclif.
import {Command, HelpBase} from '@oclif/core';export default class CustomHelp extends HelpBase {  showHelp(args: string[]) {    console.log('This will be displayed in multi-command CLIs')  }  showCommandHelp(command: Command.Loadable) {    console.log('This will be displayed in single-command CLIs')  }}
The showHelp method is called by oclif to display help in multi-command CLIs, while showCommandHelp is called directly for single-command CLIs.
The class is instantiated with a config property that provides helpful context for constructing your custom output.
To see an example of what is possible take a look at the source code for the default Help class exported from @oclif/core.
Extending the default Help class​
The default Help class provides many method “hooks” that make it easy to override the particular parts of help's output you want to customize.
import {Command, Help, Interfaces} from '@oclif/core'export default class MyHelpClass extends Help {  // acts as a "router"  // and based on the args it receives  // calls one of showRootHelp, showTopicHelp,  // the formatting for an individual command  formatCommand(command: Command.Loadable): string {}  // the formatting for a list of commands  formatCommands(commands: Command.Loadable[]): string {}  // displayed for the root help  formatRoot(): string {}  // the formatting for an individual topic  formatTopic(topic: Interfaces.Topic): string {}  // the default implementations of showRootHelp  // showTopicHelp and showCommandHelp  // will call various format methods that  // provide the formatting for their corresponding  // help sections;  // these can be overwritten as well  // the formatting responsible for the header  // the formatting for a list of topics  protected formatTopics(topics: Interfaces.Topic[]): string {}  // display help for a command  showCommandHelp(command: Command.Loadable): void {}  // or showCommandHelp  showHelp(args: string[]): void {}  // display the root help of a CLI  showRootHelp(): void {}  // display help for a topic  showTopicHelp(topic: Interfaces.Topic): void {}}
To see the default implementation of these methods take a look at the default Help class exported from @oclif/core.
To start experimenting, define showCommandHelp in your custom help class and change the output.
import {Command, Help} from '@oclif/core';export default class MyHelpClass extends Help {  public showCommandHelp(command: Command.Loadable) {    console.log('Display my custom command help!')  }}
Then run help for any command.
$ my-cli login --helpDisplay my custom command help!Edit this pageLast updated on Dec 20, 2024 by Mike Donnalley\n\nAPI ReferenceHelp ClassesOn this pageHelp ClassesOut of the box oclif provides a great help experience for CLIs. Users can invoke help with the --help flag.
$ my-cli login --help
If you want your CLI to have an explicit help command, add @oclif/plugin-help as an oclif plugin in your config.
$ my-cli help
Custom Help​
To get started, first define the filepath to your help class in oclif's config in package.json. This is a relative path to the help class, without a file extension.
For this example, the help class will be created in a file at "[project root]/src/help.ts".
{  "oclif": {    "helpClass": "./dist/help"  }}
From here there are two paths, implement the HelpBase abstract class yourself or overwrite the parts of the default Help class you want to customize (ex: how command usage is displayed). We recommend the latter approach but cover both below.
Extending the HelpBase class​
The HelpBase abstract class provides a starting point requiring the minimum needed methods implemented to be compatible with oclif.
import {Command, HelpBase} from '@oclif/core';export default class CustomHelp extends HelpBase {  showHelp(args: string[]) {    console.log('This will be displayed in multi-command CLIs')  }  showCommandHelp(command: Command.Loadable) {    console.log('This will be displayed in single-command CLIs')  }}
The showHelp method is called by oclif to display help in multi-command CLIs, while showCommandHelp is called directly for single-command CLIs.
The class is instantiated with a config property that provides helpful context for constructing your custom output.
To see an example of what is possible take a look at the source code for the default Help class exported from @oclif/core.
Extending the default Help class​
The default Help class provides many method “hooks” that make it easy to override the particular parts of help's output you want to customize.
import {Command, Help, Interfaces} from '@oclif/core'export default class MyHelpClass extends Help {  // acts as a "router"  // and based on the args it receives  // calls one of showRootHelp, showTopicHelp,  // the formatting for an individual command  formatCommand(command: Command.Loadable): string {}  // the formatting for a list of commands  formatCommands(commands: Command.Loadable[]): string {}  // displayed for the root help  formatRoot(): string {}  // the formatting for an individual topic  formatTopic(topic: Interfaces.Topic): string {}  // the default implementations of showRootHelp  // showTopicHelp and showCommandHelp  // will call various format methods that  // provide the formatting for their corresponding  // help sections;  // these can be overwritten as well  // the formatting responsible for the header  // the formatting for a list of topics  protected formatTopics(topics: Interfaces.Topic[]): string {}  // display help for a command  showCommandHelp(command: Command.Loadable): void {}  // or showCommandHelp  showHelp(args: string[]): void {}  // display the root help of a CLI  showRootHelp(): void {}  // display help for a topic  showTopicHelp(topic: Interfaces.Topic): void {}}
To see the default implementation of these methods take a look at the default Help class exported from @oclif/core.
To start experimenting, define showCommandHelp in your custom help class and change the output.
import {Command, Help} from '@oclif/core';export default class MyHelpClass extends Help {  public showCommandHelp(command: Command.Loadable) {    console.log('Display my custom command help!')  }}
Then run help for any command.
$ my-cli login --helpDisplay my custom command help!Edit this pageLast updated on Dec 20, 2024 by Mike DonnalleyPreviousPluginsNextPerformanceCustom HelpExtending the HelpBase classExtending the default Help class\n\n\n\nAPI ReferenceHelp ClassesOn this pageHelp ClassesOut of the box oclif provides a great help experience for CLIs. Users can invoke help with the --help flag.
$ my-cli login --help
If you want your CLI to have an explicit help command, add @oclif/plugin-help as an oclif plugin in your config.
$ my-cli help
Custom Help​
To get started, first define the filepath to your help class in oclif's config in package.json. This is a relative path to the help class, without a file extension.
For this example, the help class will be created in a file at "[project root]/src/help.ts".
{  "oclif": {    "helpClass": "./dist/help"  }}
From here there are two paths, implement the HelpBase abstract class yourself or overwrite the parts of the default Help class you want to customize (ex: how command usage is displayed). We recommend the latter approach but cover both below.
Extending the HelpBase class​
The HelpBase abstract class provides a starting point requiring the minimum needed methods implemented to be compatible with oclif.
import {Command, HelpBase} from '@oclif/core';export default class CustomHelp extends HelpBase {  showHelp(args: string[]) {    console.log('This will be displayed in multi-command CLIs')  }  showCommandHelp(command: Command.Loadable) {    console.log('This will be displayed in single-command CLIs')  }}
The showHelp method is called by oclif to display help in multi-command CLIs, while showCommandHelp is called directly for single-command CLIs.
The class is instantiated with a config property that provides helpful context for constructing your custom output.
To see an example of what is possible take a look at the source code for the default Help class exported from @oclif/core.
Extending the default Help class​
The default Help class provides many method “hooks” that make it easy to override the particular parts of help's output you want to customize.
import {Command, Help, Interfaces} from '@oclif/core'export default class MyHelpClass extends Help {  // acts as a "router"  // and based on the args it receives  // calls one of showRootHelp, showTopicHelp,  // the formatting for an individual command  formatCommand(command: Command.Loadable): string {}  // the formatting for a list of commands  formatCommands(commands: Command.Loadable[]): string {}  // displayed for the root help  formatRoot(): string {}  // the formatting for an individual topic  formatTopic(topic: Interfaces.Topic): string {}  // the default implementations of showRootHelp  // showTopicHelp and showCommandHelp  // will call various format methods that  // provide the formatting for their corresponding  // help sections;  // these can be overwritten as well  // the formatting responsible for the header  // the formatting for a list of topics  protected formatTopics(topics: Interfaces.Topic[]): string {}  // display help for a command  showCommandHelp(command: Command.Loadable): void {}  // or showCommandHelp  showHelp(args: string[]): void {}  // display the root help of a CLI  showRootHelp(): void {}  // display help for a topic  showTopicHelp(topic: Interfaces.Topic): void {}}
To see the default implementation of these methods take a look at the default Help class exported from @oclif/core.
To start experimenting, define showCommandHelp in your custom help class and change the output.
import {Command, Help} from '@oclif/core';export default class MyHelpClass extends Help {  public showCommandHelp(command: Command.Loadable) {    console.log('Display my custom command help!')  }}
Then run help for any command.
$ my-cli login --helpDisplay my custom command help!Edit this pageLast updated on Dec 20, 2024 by Mike Donnalley\n\nAPI ReferenceHelp ClassesOn this pageHelp ClassesOut of the box oclif provides a great help experience for CLIs. Users can invoke help with the --help flag.
$ my-cli login --help
If you want your CLI to have an explicit help command, add @oclif/plugin-help as an oclif plugin in your config.
$ my-cli help
Custom Help​
To get started, first define the filepath to your help class in oclif's config in package.json. This is a relative path to the help class, without a file extension.
For this example, the help class will be created in a file at "[project root]/src/help.ts".
{  "oclif": {    "helpClass": "./dist/help"  }}
From here there are two paths, implement the HelpBase abstract class yourself or overwrite the parts of the default Help class you want to customize (ex: how command usage is displayed). We recommend the latter approach but cover both below.
Extending the HelpBase class​
The HelpBase abstract class provides a starting point requiring the minimum needed methods implemented to be compatible with oclif.
import {Command, HelpBase} from '@oclif/core';export default class CustomHelp extends HelpBase {  showHelp(args: string[]) {    console.log('This will be displayed in multi-command CLIs')  }  showCommandHelp(command: Command.Loadable) {    console.log('This will be displayed in single-command CLIs')  }}
The showHelp method is called by oclif to display help in multi-command CLIs, while showCommandHelp is called directly for single-command CLIs.
The class is instantiated with a config property that provides helpful context for constructing your custom output.
To see an example of what is possible take a look at the source code for the default Help class exported from @oclif/core.
Extending the default Help class​
The default Help class provides many method “hooks” that make it easy to override the particular parts of help's output you want to customize.
import {Command, Help, Interfaces} from '@oclif/core'export default class MyHelpClass extends Help {  // acts as a "router"  // and based on the args it receives  // calls one of showRootHelp, showTopicHelp,  // the formatting for an individual command  formatCommand(command: Command.Loadable): string {}  // the formatting for a list of commands  formatCommands(commands: Command.Loadable[]): string {}  // displayed for the root help  formatRoot(): string {}  // the formatting for an individual topic  formatTopic(topic: Interfaces.Topic): string {}  // the default implementations of showRootHelp  // showTopicHelp and showCommandHelp  // will call various format methods that  // provide the formatting for their corresponding  // help sections;  // these can be overwritten as well  // the formatting responsible for the header  // the formatting for a list of topics  protected formatTopics(topics: Interfaces.Topic[]): string {}  // display help for a command  showCommandHelp(command: Command.Loadable): void {}  // or showCommandHelp  showHelp(args: string[]): void {}  // display the root help of a CLI  showRootHelp(): void {}  // display help for a topic  showTopicHelp(topic: Interfaces.Topic): void {}}
To see the default implementation of these methods take a look at the default Help class exported from @oclif/core.
To start experimenting, define showCommandHelp in your custom help class and change the output.
import {Command, Help} from '@oclif/core';export default class MyHelpClass extends Help {  public showCommandHelp(command: Command.Loadable) {    console.log('Display my custom command help!')  }}
Then run help for any command.
$ my-cli login --helpDisplay my custom command help!Edit this pageLast updated on Dec 20, 2024 by Mike DonnalleyPreviousPluginsNextPerformanceCustom HelpExtending the HelpBase classExtending the default Help class\n\n\n\nGuidesCustom Base ClassCustom Base ClassUse inheritance to share functionality between common commands. Here is an example of a command base class that has some common shared flags.
For large CLIs with multiple plugins, it's useful to put this base class into its own npm package to be shared.
// src/baseCommand.tsimport {Command, Flags, Interfaces} from '@oclif/core'export type Flags<T extends typeof Command> = Interfaces.InferredFlags<typeof BaseCommand['baseFlags'] & T['flags']>export type Args<T extends typeof Command> = Interfaces.InferredArgs<T['args']>export abstract class BaseCommand<T extends typeof Command> extends Command {  // add the --json flag  static enableJsonFlag = true  // define flags that can be inherited by any command that extends BaseCommand  static baseFlags = {    'log-level': Flags.option({      default: 'info',      helpGroup: 'GLOBAL',      options: ['debug', 'warn', 'error', 'info', 'trace'] as const,      summary: 'Specify level for logging.',    })(),  }  protected flags!: Flags<T>  protected args!: Args<T>  public async init(): Promise<void> {    await super.init()    const {args, flags} = await this.parse({      flags: this.ctor.flags,      baseFlags: (super.ctor as typeof BaseCommand).baseFlags,      enableJsonFlag: this.ctor.enableJsonFlag,      args: this.ctor.args,      strict: this.ctor.strict,    })    this.flags = flags as Flags<T>    this.args = args as Args<T>  }  protected async catch(err: Error & {exitCode?: number}): Promise<any> {    // add any custom logic to handle errors from the command    // or simply return the parent class error handling    return super.catch(err)  }  protected async finally(_: Error | undefined): Promise<any> {    // called after run and catch regardless of whether or not the command errored    return super.finally(_)  }}// src/commands/my-command.tsexport default class MyCommand extends BaseCommand<typeof MyCommand> {  static summary = 'child class that extends BaseCommand'  static examples = [    '<%= config.bin %> <%= command.id %>',    '<%= config.bin %> <%= command.id %> --json',    '<%= config.bin %> <%= command.id %> --log-level debug',  ]  static flags = {    name: Flags.string({      char: 'n',      summary: 'Name to print.',      required: true,    }),  }  public async run(): Promise<Flags<typeof MyCommand>> {    for (const [flag, value] of Object.entries(this.flags)) {      this.log(`${flag}: ${value}`)    }    return this.flags  }}
For a more complex example, here's how we do this for the Salesforce CLI.Edit this pageLast updated on Dec 20, 2024 by Mike Donnalley\n\nGuidesCustom Base ClassCustom Base ClassUse inheritance to share functionality between common commands. Here is an example of a command base class that has some common shared flags.
For large CLIs with multiple plugins, it's useful to put this base class into its own npm package to be shared.
// src/baseCommand.tsimport {Command, Flags, Interfaces} from '@oclif/core'export type Flags<T extends typeof Command> = Interfaces.InferredFlags<typeof BaseCommand['baseFlags'] & T['flags']>export type Args<T extends typeof Command> = Interfaces.InferredArgs<T['args']>export abstract class BaseCommand<T extends typeof Command> extends Command {  // add the --json flag  static enableJsonFlag = true  // define flags that can be inherited by any command that extends BaseCommand  static baseFlags = {    'log-level': Flags.option({      default: 'info',      helpGroup: 'GLOBAL',      options: ['debug', 'warn', 'error', 'info', 'trace'] as const,      summary: 'Specify level for logging.',    })(),  }  protected flags!: Flags<T>  protected args!: Args<T>  public async init(): Promise<void> {    await super.init()    const {args, flags} = await this.parse({      flags: this.ctor.flags,      baseFlags: (super.ctor as typeof BaseCommand).baseFlags,      enableJsonFlag: this.ctor.enableJsonFlag,      args: this.ctor.args,      strict: this.ctor.strict,    })    this.flags = flags as Flags<T>    this.args = args as Args<T>  }  protected async catch(err: Error & {exitCode?: number}): Promise<any> {    // add any custom logic to handle errors from the command    // or simply return the parent class error handling    return super.catch(err)  }  protected async finally(_: Error | undefined): Promise<any> {    // called after run and catch regardless of whether or not the command errored    return super.finally(_)  }}// src/commands/my-command.tsexport default class MyCommand extends BaseCommand<typeof MyCommand> {  static summary = 'child class that extends BaseCommand'  static examples = [    '<%= config.bin %> <%= command.id %>',    '<%= config.bin %> <%= command.id %> --json',    '<%= config.bin %> <%= command.id %> --log-level debug',  ]  static flags = {    name: Flags.string({      char: 'n',      summary: 'Name to print.',      required: true,    }),  }  public async run(): Promise<Flags<typeof MyCommand>> {    for (const [flag, value] of Object.entries(this.flags)) {      this.log(`${flag}: ${value}`)    }    return this.flags  }}
For a more complex example, here's how we do this for the Salesforce CLI.Edit this pageLast updated on Dec 20, 2024 by Mike DonnalleyPreviousAliasesNextConfiguring Your CLI\n\n\n\nGuidesUser ExperienceUser Experienceoclif's philosophy is that developers should be free to design any user experience they want for their users. In other words, we try really hard to not make any UX decisions for you.
So many times we utilize hooks whenever a user experience is required (e.g. the provided command isn't found). That way, you can design the exact experience you want your users to have. In the case of error handling, you're able to override oclif's default behavior.
But to make it easy for you, @oclif/core exports a ux module that offers a small number of tools to implement your desired user experience.
If you need more complex user experiences, we suggest the following libraries:

For prompts: inquirer
For spinners: ora
For progress bars: cli-progress
For tables: tty-table, cliui
For trees: object-treeify
For colored JSON: color-json
For notifications: node-notifier
For links: terminal-link
For rendering react components: ink
Edit this pageLast updated on Dec 20, 2024 by Mike Donnalley\n\nGuidesUser ExperienceUser Experienceoclif's philosophy is that developers should be free to design any user experience they want for their users. In other words, we try really hard to not make any UX decisions for you.
So many times we utilize hooks whenever a user experience is required (e.g. the provided command isn't found). That way, you can design the exact experience you want your users to have. In the case of error handling, you're able to override oclif's default behavior.
But to make it easy for you, @oclif/core exports a ux module that offers a small number of tools to implement your desired user experience.
If you need more complex user experiences, we suggest the following libraries:

For prompts: inquirer
For spinners: ora
For progress bars: cli-progress
For tables: tty-table, cliui
For trees: object-treeify
For colored JSON: color-json
For notifications: node-notifier
For links: terminal-link
For rendering react components: ink
Edit this pageLast updated on Dec 20, 2024 by Mike DonnalleyPreviousThemesNextAPI Reference\n\n\n\nAPI ReferenceConfigOn this pageConfigInside a command, this.config provides access to the Config class, which contains useful properties and methods you can use in your command. Here are a list of its methods and properties:

name - name of CLI
version - Version of the CLI.
pjson - Parsed CLI package.json.
bin - CLI bin name
cacheDir - CLI cache directory

macOS: ~/Library/Caches/mycli
Unix: ~/.cache/mycli
Windows: %LOCALAPPDATA%\mycli
Can be overridden with XDG_CACHE_HOME


configDir - CLI config directory

Unix: ~/.config/mycli
Windows: %LOCALAPPDATA%\mycli
Can be overridden with XDG_CONFIG_HOME


dataDir - CLI data directory

Unix: ~/.data/mycli
Windows: %LOCALAPPDATA%\mycli
Can be overridden with XDG_DATA_HOME


dirname - dirname used with cacheDir|configDir|dataDir. Can be overridden in package.json.
errlog - path to error log inside of cacheDir
home - user home directory
platform - operating system darwin|linux|win32
arch - process architecture x64|x86
shell - current shell in use
userAgent - user-agent intended for http calls. example: mycli/1.2.3 (darwin-x64) node-9.0.0
windows - boolean
npmRegistry - current npm registry to use with the plugins plugin
plugins - loaded plugins
commands - all commands in CLI
default - default cli command
topics - all topics in CLI
commandIDs - string IDs of all commands
async runHook(event, opts) - trigger a hook
async runCommand(id, opts) - Run a command
scopedEnvVar(key) - Return the value of a scoped env var (e.g. \<CLI>_NPM_REGISTRY)
scopedEnvVarKey(key) - Return the name of a scoped env var (e.g. \<CLI>_NPM_REGISTRY)
scopedEnvVarTrue(key) - Return true/false value of scoped env var (e.g. \<CLI>_NPM_REGISTRY)

Custom User Configuration​
Often it's useful to have a custom configuration for your users. One way to implement this is to read a config.json file from the CLI's config directory:
import { Command } from "@oclif/core";import * as fs from "fs-extra";import * as path from "path";export class extends Command {  async run() {    const userConfig = await fs.readJSON(      path.join(this.config.configDir, "config.json")    );    this.log("User config:");    console.dir(userConfig);  }}
To share this logic between different commands, use a base class.Edit this pageLast updated on Dec 20, 2024 by Mike Donnalley\n\nAPI ReferenceConfigOn this pageConfigInside a command, this.config provides access to the Config class, which contains useful properties and methods you can use in your command. Here are a list of its methods and properties:

name - name of CLI
version - Version of the CLI.
pjson - Parsed CLI package.json.
bin - CLI bin name
cacheDir - CLI cache directory

macOS: ~/Library/Caches/mycli
Unix: ~/.cache/mycli
Windows: %LOCALAPPDATA%\mycli
Can be overridden with XDG_CACHE_HOME


configDir - CLI config directory

Unix: ~/.config/mycli
Windows: %LOCALAPPDATA%\mycli
Can be overridden with XDG_CONFIG_HOME


dataDir - CLI data directory

Unix: ~/.data/mycli
Windows: %LOCALAPPDATA%\mycli
Can be overridden with XDG_DATA_HOME


dirname - dirname used with cacheDir|configDir|dataDir. Can be overridden in package.json.
errlog - path to error log inside of cacheDir
home - user home directory
platform - operating system darwin|linux|win32
arch - process architecture x64|x86
shell - current shell in use
userAgent - user-agent intended for http calls. example: mycli/1.2.3 (darwin-x64) node-9.0.0
windows - boolean
npmRegistry - current npm registry to use with the plugins plugin
plugins - loaded plugins
commands - all commands in CLI
default - default cli command
topics - all topics in CLI
commandIDs - string IDs of all commands
async runHook(event, opts) - trigger a hook
async runCommand(id, opts) - Run a command
scopedEnvVar(key) - Return the value of a scoped env var (e.g. \<CLI>_NPM_REGISTRY)
scopedEnvVarKey(key) - Return the name of a scoped env var (e.g. \<CLI>_NPM_REGISTRY)
scopedEnvVarTrue(key) - Return true/false value of scoped env var (e.g. \<CLI>_NPM_REGISTRY)

Custom User Configuration​
Often it's useful to have a custom configuration for your users. One way to implement this is to read a config.json file from the CLI's config directory:
import { Command } from "@oclif/core";import * as fs from "fs-extra";import * as path from "path";export class extends Command {  async run() {    const userConfig = await fs.readJSON(      path.join(this.config.configDir, "config.json")    );    this.log("User config:");    console.dir(userConfig);  }}
To share this logic between different commands, use a base class.Edit this pageLast updated on Dec 20, 2024 by Mike DonnalleyPreviousCommand FlagsNextCommand Discovery StrategiesCustom User Configuration\n\n\n\nAPI ReferenceConfigOn this pageConfigInside a command, this.config provides access to the Config class, which contains useful properties and methods you can use in your command. Here are a list of its methods and properties:

name - name of CLI
version - Version of the CLI.
pjson - Parsed CLI package.json.
bin - CLI bin name
cacheDir - CLI cache directory

macOS: ~/Library/Caches/mycli
Unix: ~/.cache/mycli
Windows: %LOCALAPPDATA%\mycli
Can be overridden with XDG_CACHE_HOME


configDir - CLI config directory

Unix: ~/.config/mycli
Windows: %LOCALAPPDATA%\mycli
Can be overridden with XDG_CONFIG_HOME


dataDir - CLI data directory

Unix: ~/.data/mycli
Windows: %LOCALAPPDATA%\mycli
Can be overridden with XDG_DATA_HOME


dirname - dirname used with cacheDir|configDir|dataDir. Can be overridden in package.json.
errlog - path to error log inside of cacheDir
home - user home directory
platform - operating system darwin|linux|win32
arch - process architecture x64|x86
shell - current shell in use
userAgent - user-agent intended for http calls. example: mycli/1.2.3 (darwin-x64) node-9.0.0
windows - boolean
npmRegistry - current npm registry to use with the plugins plugin
plugins - loaded plugins
commands - all commands in CLI
default - default cli command
topics - all topics in CLI
commandIDs - string IDs of all commands
async runHook(event, opts) - trigger a hook
async runCommand(id, opts) - Run a command
scopedEnvVar(key) - Return the value of a scoped env var (e.g. \<CLI>_NPM_REGISTRY)
scopedEnvVarKey(key) - Return the name of a scoped env var (e.g. \<CLI>_NPM_REGISTRY)
scopedEnvVarTrue(key) - Return true/false value of scoped env var (e.g. \<CLI>_NPM_REGISTRY)

Custom User Configuration​
Often it's useful to have a custom configuration for your users. One way to implement this is to read a config.json file from the CLI's config directory:
import { Command } from "@oclif/core";import * as fs from "fs-extra";import * as path from "path";export class extends Command {  async run() {    const userConfig = await fs.readJSON(      path.join(this.config.configDir, "config.json")    );    this.log("User config:");    console.dir(userConfig);  }}
To share this logic between different commands, use a base class.Edit this pageLast updated on Dec 20, 2024 by Mike Donnalley\n\nAPI ReferenceConfigOn this pageConfigInside a command, this.config provides access to the Config class, which contains useful properties and methods you can use in your command. Here are a list of its methods and properties:

name - name of CLI
version - Version of the CLI.
pjson - Parsed CLI package.json.
bin - CLI bin name
cacheDir - CLI cache directory

macOS: ~/Library/Caches/mycli
Unix: ~/.cache/mycli
Windows: %LOCALAPPDATA%\mycli
Can be overridden with XDG_CACHE_HOME


configDir - CLI config directory

Unix: ~/.config/mycli
Windows: %LOCALAPPDATA%\mycli
Can be overridden with XDG_CONFIG_HOME


dataDir - CLI data directory

Unix: ~/.data/mycli
Windows: %LOCALAPPDATA%\mycli
Can be overridden with XDG_DATA_HOME


dirname - dirname used with cacheDir|configDir|dataDir. Can be overridden in package.json.
errlog - path to error log inside of cacheDir
home - user home directory
platform - operating system darwin|linux|win32
arch - process architecture x64|x86
shell - current shell in use
userAgent - user-agent intended for http calls. example: mycli/1.2.3 (darwin-x64) node-9.0.0
windows - boolean
npmRegistry - current npm registry to use with the plugins plugin
plugins - loaded plugins
commands - all commands in CLI
default - default cli command
topics - all topics in CLI
commandIDs - string IDs of all commands
async runHook(event, opts) - trigger a hook
async runCommand(id, opts) - Run a command
scopedEnvVar(key) - Return the value of a scoped env var (e.g. \<CLI>_NPM_REGISTRY)
scopedEnvVarKey(key) - Return the name of a scoped env var (e.g. \<CLI>_NPM_REGISTRY)
scopedEnvVarTrue(key) - Return true/false value of scoped env var (e.g. \<CLI>_NPM_REGISTRY)

Custom User Configuration​
Often it's useful to have a custom configuration for your users. One way to implement this is to read a config.json file from the CLI's config directory:
import { Command } from "@oclif/core";import * as fs from "fs-extra";import * as path from "path";export class extends Command {  async run() {    const userConfig = await fs.readJSON(      path.join(this.config.configDir, "config.json")    );    this.log("User config:");    console.dir(userConfig);  }}
To share this logic between different commands, use a base class.Edit this pageLast updated on Dec 20, 2024 by Mike DonnalleyPreviousCommand FlagsNextCommand Discovery StrategiesCustom User Configuration\n\n\n\nAPI ReferenceCommand Discovery StrategiesOn this pageCommand Discovery StrategiesWhen oclif loads a plugin is must find all the commands within that plugin that can be executed. There a three strategies for discovering these commands:

pattern - this is the default behavior that finds commands based on glob patterns.
explicit - find commands that are exported from a specified file.
single - CLI contains a single command executed by top-level bin.

pattern Strategy​
The pattern strategy tells oclif to use a predefined set of globs to find command files in a specified directory. This is the default behavior of oclif unless otherwise stated.
Plugins can point the commands property to a directory
{  "oclif": {    "commands": "./dist/commands",  }}
This will tell oclif to look for commands in that directory (this is skipped if an oclif.manifest.json is present)
Alternatively, you can set this configuration which will do the exact same thing:
{  "oclif": {    "commands": {      "strategy": "pattern",      "target": "./dist/commands"    }  }}
You also have the ability to set globPatterns, which override the glob patterns that oclif uses when searching for command files:
{  "oclif": {    "commands": {      "strategy": "pattern",      "target": "./dist/commands",      "globPatterns": [         "**/*.+(js|cjs|mjs|ts|tsx|mts|cts)",        "!**/*.+(d.*|test.*|spec.*|helpers.*)?(x)"      ]    }  }}
This is useful if you like to put test or helper files in the same directory as your command files.
explicit Strategy​
The explicit strategy tells oclif to import commands from a single file. In this case the target is the file that exports the commands and identifier is the name of the export (defaults to default).
To use this you would add a new file (e.g. src/commands.ts) and then add this configuration to the package.json
{  "oclif": {    "commands": {      "strategy": "explicit",      "target": "./dist/index.js",      "identifier": "COMMANDS",    }  }}
src/index.ts would then need to have an export with the same name as the identifier (if not set, it defaults to default) that's an object of command names to command classes, e.g.
import Hello from './commands/hello'import HelloWorld from './commands/hello/world'export const COMMANDS = {  hello: Hello,  'hello:world': HelloWorld,  howdy: Hello, // alias the `hello` command to `howdy`}
The explicit strategy is useful to those who can't rely on file paths because they've bundled their code (see Bundling) but it can also be used if you simply prefer to be more explicit about your commands instead of relying on oclif "magically" finding commands from the file system.
It can also be leveraged to create or modify commands at runtime (e.g. internationalize messages at runtime or add flags to a command based on an API spec - see dynamic commands section below).
Hooks​
Hooks can also be defined using the explicit strategy:
"oclif": {    "hooks": {      "init": {        "target": "./dist/index.js",        "identifier": "INIT_HOOK"      }    }}
// src/index.tsimport Hello from './commands/hello'import HelloWorld from './commands/hello/world'export {default as INIT_HOOK} from './hooks/init/init.js'export const COMMANDS = {  hello: Hello,  'hello:world': HelloWorld,  howdy: Hello, // alias the `hello` command to `howdy`}
That configuration is essentially telling oclif to look for an INIT_HOOK export inside of ./dist/index.js
Bundling​
We do not support bundling given the endless number of tools + configurations that could be used. But if you choose to use a bundler, like esbuild, there are a couple hard requirements - you must have a package.json in your root directory and a bin/run or bin/run.js bin script. This means that you will not be able to successfully bundle your entire CLI (src code, package.json, node_modules, etc) into a single file.
If you still want to use a bundler, you can reference this example repo.
Dynamic Commands​
You can also use the explicit strategy if you want to manipulate or create commands at runtime. Please note that such usage of the explicit strategy cannot be used with an oclif.manifest.json, which will have significant performance implications for your CLI in production.
Example:
// src/index.tsimport {Command, Flags} from '@oclif/core'import Hello from './commands/hello'import HelloWorld from './commands/hello/world'const dynamicCommands: Record<string, Command.Class> = {}if (process.env.DYNAMIC_COMMAND) {  dynamicCommands[process.env.DYNAMIC_COMMAND] = class extends Command {    static flags = {      flag1: Flags.boolean({description: 'flag1 description'}),    }    async run(): Promise<void> {      const {flags} = await this.parse(this.constructor as Command.Class)      this.log('hello from', this.id, flags)    }  }}export const COMMANDS = {  hello: Hello,  'hello:world': HelloWorld,  ...dynamicCommands,}
❯ DYNAMIC_COMMAND=foo:bar:baz bin/run.js foo bar baz --flag1hello from foo:bar:baz { flag1: true }
single Strategy​
The single strategy tells oclif that this CLI contains a single command that can be executed by the bin/run.js (e.g. ls or cat).
{  "oclif": {    "commands": {      "strategy": "single",      "target": "./dist/index.js"    }  }}
In this example, ./dist/index.js exports the command class.
Note about oclif.manifest.json​
For all strategies, the oclif.manifest.json will be used to load the commands instead of the default behavior of the strategy.Edit this pageLast updated on Dec 20, 2024 by Mike Donnalley\n\nAPI ReferenceCommand Discovery StrategiesOn this pageCommand Discovery StrategiesWhen oclif loads a plugin is must find all the commands within that plugin that can be executed. There a three strategies for discovering these commands:

pattern - this is the default behavior that finds commands based on glob patterns.
explicit - find commands that are exported from a specified file.
single - CLI contains a single command executed by top-level bin.

pattern Strategy​
The pattern strategy tells oclif to use a predefined set of globs to find command files in a specified directory. This is the default behavior of oclif unless otherwise stated.
Plugins can point the commands property to a directory
{  "oclif": {    "commands": "./dist/commands",  }}
This will tell oclif to look for commands in that directory (this is skipped if an oclif.manifest.json is present)
Alternatively, you can set this configuration which will do the exact same thing:
{  "oclif": {    "commands": {      "strategy": "pattern",      "target": "./dist/commands"    }  }}
You also have the ability to set globPatterns, which override the glob patterns that oclif uses when searching for command files:
{  "oclif": {    "commands": {      "strategy": "pattern",      "target": "./dist/commands",      "globPatterns": [         "**/*.+(js|cjs|mjs|ts|tsx|mts|cts)",        "!**/*.+(d.*|test.*|spec.*|helpers.*)?(x)"      ]    }  }}
This is useful if you like to put test or helper files in the same directory as your command files.
explicit Strategy​
The explicit strategy tells oclif to import commands from a single file. In this case the target is the file that exports the commands and identifier is the name of the export (defaults to default).
To use this you would add a new file (e.g. src/commands.ts) and then add this configuration to the package.json
{  "oclif": {    "commands": {      "strategy": "explicit",      "target": "./dist/index.js",      "identifier": "COMMANDS",    }  }}
src/index.ts would then need to have an export with the same name as the identifier (if not set, it defaults to default) that's an object of command names to command classes, e.g.
import Hello from './commands/hello'import HelloWorld from './commands/hello/world'export const COMMANDS = {  hello: Hello,  'hello:world': HelloWorld,  howdy: Hello, // alias the `hello` command to `howdy`}
The explicit strategy is useful to those who can't rely on file paths because they've bundled their code (see Bundling) but it can also be used if you simply prefer to be more explicit about your commands instead of relying on oclif "magically" finding commands from the file system.
It can also be leveraged to create or modify commands at runtime (e.g. internationalize messages at runtime or add flags to a command based on an API spec - see dynamic commands section below).
Hooks​
Hooks can also be defined using the explicit strategy:
"oclif": {    "hooks": {      "init": {        "target": "./dist/index.js",        "identifier": "INIT_HOOK"      }    }}
// src/index.tsimport Hello from './commands/hello'import HelloWorld from './commands/hello/world'export {default as INIT_HOOK} from './hooks/init/init.js'export const COMMANDS = {  hello: Hello,  'hello:world': HelloWorld,  howdy: Hello, // alias the `hello` command to `howdy`}
That configuration is essentially telling oclif to look for an INIT_HOOK export inside of ./dist/index.js
Bundling​
We do not support bundling given the endless number of tools + configurations that could be used. But if you choose to use a bundler, like esbuild, there are a couple hard requirements - you must have a package.json in your root directory and a bin/run or bin/run.js bin script. This means that you will not be able to successfully bundle your entire CLI (src code, package.json, node_modules, etc) into a single file.
If you still want to use a bundler, you can reference this example repo.
Dynamic Commands​
You can also use the explicit strategy if you want to manipulate or create commands at runtime. Please note that such usage of the explicit strategy cannot be used with an oclif.manifest.json, which will have significant performance implications for your CLI in production.
Example:
// src/index.tsimport {Command, Flags} from '@oclif/core'import Hello from './commands/hello'import HelloWorld from './commands/hello/world'const dynamicCommands: Record<string, Command.Class> = {}if (process.env.DYNAMIC_COMMAND) {  dynamicCommands[process.env.DYNAMIC_COMMAND] = class extends Command {    static flags = {      flag1: Flags.boolean({description: 'flag1 description'}),    }    async run(): Promise<void> {      const {flags} = await this.parse(this.constructor as Command.Class)      this.log('hello from', this.id, flags)    }  }}export const COMMANDS = {  hello: Hello,  'hello:world': HelloWorld,  ...dynamicCommands,}
❯ DYNAMIC_COMMAND=foo:bar:baz bin/run.js foo bar baz --flag1hello from foo:bar:baz { flag1: true }
single Strategy​
The single strategy tells oclif that this CLI contains a single command that can be executed by the bin/run.js (e.g. ls or cat).
{  "oclif": {    "commands": {      "strategy": "single",      "target": "./dist/index.js"    }  }}
In this example, ./dist/index.js exports the command class.
Note about oclif.manifest.json​
For all strategies, the oclif.manifest.json will be used to load the commands instead of the default behavior of the strategy.Edit this pageLast updated on Dec 20, 2024 by Mike DonnalleyPreviousConfigNextTopicspattern Strategyexplicit Strategysingle StrategyNote about oclif.manifest.json\n\n\n\nAPI ReferenceCommand Discovery StrategiesOn this pageCommand Discovery StrategiesWhen oclif loads a plugin is must find all the commands within that plugin that can be executed. There a three strategies for discovering these commands:

pattern - this is the default behavior that finds commands based on glob patterns.
explicit - find commands that are exported from a specified file.
single - CLI contains a single command executed by top-level bin.

pattern Strategy​
The pattern strategy tells oclif to use a predefined set of globs to find command files in a specified directory. This is the default behavior of oclif unless otherwise stated.
Plugins can point the commands property to a directory
{  "oclif": {    "commands": "./dist/commands",  }}
This will tell oclif to look for commands in that directory (this is skipped if an oclif.manifest.json is present)
Alternatively, you can set this configuration which will do the exact same thing:
{  "oclif": {    "commands": {      "strategy": "pattern",      "target": "./dist/commands"    }  }}
You also have the ability to set globPatterns, which override the glob patterns that oclif uses when searching for command files:
{  "oclif": {    "commands": {      "strategy": "pattern",      "target": "./dist/commands",      "globPatterns": [         "**/*.+(js|cjs|mjs|ts|tsx|mts|cts)",        "!**/*.+(d.*|test.*|spec.*|helpers.*)?(x)"      ]    }  }}
This is useful if you like to put test or helper files in the same directory as your command files.
explicit Strategy​
The explicit strategy tells oclif to import commands from a single file. In this case the target is the file that exports the commands and identifier is the name of the export (defaults to default).
To use this you would add a new file (e.g. src/commands.ts) and then add this configuration to the package.json
{  "oclif": {    "commands": {      "strategy": "explicit",      "target": "./dist/index.js",      "identifier": "COMMANDS",    }  }}
src/index.ts would then need to have an export with the same name as the identifier (if not set, it defaults to default) that's an object of command names to command classes, e.g.
import Hello from './commands/hello'import HelloWorld from './commands/hello/world'export const COMMANDS = {  hello: Hello,  'hello:world': HelloWorld,  howdy: Hello, // alias the `hello` command to `howdy`}
The explicit strategy is useful to those who can't rely on file paths because they've bundled their code (see Bundling) but it can also be used if you simply prefer to be more explicit about your commands instead of relying on oclif "magically" finding commands from the file system.
It can also be leveraged to create or modify commands at runtime (e.g. internationalize messages at runtime or add flags to a command based on an API spec - see dynamic commands section below).
Hooks​
Hooks can also be defined using the explicit strategy:
"oclif": {    "hooks": {      "init": {        "target": "./dist/index.js",        "identifier": "INIT_HOOK"      }    }}
// src/index.tsimport Hello from './commands/hello'import HelloWorld from './commands/hello/world'export {default as INIT_HOOK} from './hooks/init/init.js'export const COMMANDS = {  hello: Hello,  'hello:world': HelloWorld,  howdy: Hello, // alias the `hello` command to `howdy`}
That configuration is essentially telling oclif to look for an INIT_HOOK export inside of ./dist/index.js
Bundling​
We do not support bundling given the endless number of tools + configurations that could be used. But if you choose to use a bundler, like esbuild, there are a couple hard requirements - you must have a package.json in your root directory and a bin/run or bin/run.js bin script. This means that you will not be able to successfully bundle your entire CLI (src code, package.json, node_modules, etc) into a single file.
If you still want to use a bundler, you can reference this example repo.
Dynamic Commands​
You can also use the explicit strategy if you want to manipulate or create commands at runtime. Please note that such usage of the explicit strategy cannot be used with an oclif.manifest.json, which will have significant performance implications for your CLI in production.
Example:
// src/index.tsimport {Command, Flags} from '@oclif/core'import Hello from './commands/hello'import HelloWorld from './commands/hello/world'const dynamicCommands: Record<string, Command.Class> = {}if (process.env.DYNAMIC_COMMAND) {  dynamicCommands[process.env.DYNAMIC_COMMAND] = class extends Command {    static flags = {      flag1: Flags.boolean({description: 'flag1 description'}),    }    async run(): Promise<void> {      const {flags} = await this.parse(this.constructor as Command.Class)      this.log('hello from', this.id, flags)    }  }}export const COMMANDS = {  hello: Hello,  'hello:world': HelloWorld,  ...dynamicCommands,}
❯ DYNAMIC_COMMAND=foo:bar:baz bin/run.js foo bar baz --flag1hello from foo:bar:baz { flag1: true }
single Strategy​
The single strategy tells oclif that this CLI contains a single command that can be executed by the bin/run.js (e.g. ls or cat).
{  "oclif": {    "commands": {      "strategy": "single",      "target": "./dist/index.js"    }  }}
In this example, ./dist/index.js exports the command class.
Note about oclif.manifest.json​
For all strategies, the oclif.manifest.json will be used to load the commands instead of the default behavior of the strategy.Edit this pageLast updated on Dec 20, 2024 by Mike Donnalley\n\nAPI ReferenceCommand Discovery StrategiesOn this pageCommand Discovery StrategiesWhen oclif loads a plugin is must find all the commands within that plugin that can be executed. There a three strategies for discovering these commands:

pattern - this is the default behavior that finds commands based on glob patterns.
explicit - find commands that are exported from a specified file.
single - CLI contains a single command executed by top-level bin.

pattern Strategy​
The pattern strategy tells oclif to use a predefined set of globs to find command files in a specified directory. This is the default behavior of oclif unless otherwise stated.
Plugins can point the commands property to a directory
{  "oclif": {    "commands": "./dist/commands",  }}
This will tell oclif to look for commands in that directory (this is skipped if an oclif.manifest.json is present)
Alternatively, you can set this configuration which will do the exact same thing:
{  "oclif": {    "commands": {      "strategy": "pattern",      "target": "./dist/commands"    }  }}
You also have the ability to set globPatterns, which override the glob patterns that oclif uses when searching for command files:
{  "oclif": {    "commands": {      "strategy": "pattern",      "target": "./dist/commands",      "globPatterns": [         "**/*.+(js|cjs|mjs|ts|tsx|mts|cts)",        "!**/*.+(d.*|test.*|spec.*|helpers.*)?(x)"      ]    }  }}
This is useful if you like to put test or helper files in the same directory as your command files.
explicit Strategy​
The explicit strategy tells oclif to import commands from a single file. In this case the target is the file that exports the commands and identifier is the name of the export (defaults to default).
To use this you would add a new file (e.g. src/commands.ts) and then add this configuration to the package.json
{  "oclif": {    "commands": {      "strategy": "explicit",      "target": "./dist/index.js",      "identifier": "COMMANDS",    }  }}
src/index.ts would then need to have an export with the same name as the identifier (if not set, it defaults to default) that's an object of command names to command classes, e.g.
import Hello from './commands/hello'import HelloWorld from './commands/hello/world'export const COMMANDS = {  hello: Hello,  'hello:world': HelloWorld,  howdy: Hello, // alias the `hello` command to `howdy`}
The explicit strategy is useful to those who can't rely on file paths because they've bundled their code (see Bundling) but it can also be used if you simply prefer to be more explicit about your commands instead of relying on oclif "magically" finding commands from the file system.
It can also be leveraged to create or modify commands at runtime (e.g. internationalize messages at runtime or add flags to a command based on an API spec - see dynamic commands section below).
Hooks​
Hooks can also be defined using the explicit strategy:
"oclif": {    "hooks": {      "init": {        "target": "./dist/index.js",        "identifier": "INIT_HOOK"      }    }}
// src/index.tsimport Hello from './commands/hello'import HelloWorld from './commands/hello/world'export {default as INIT_HOOK} from './hooks/init/init.js'export const COMMANDS = {  hello: Hello,  'hello:world': HelloWorld,  howdy: Hello, // alias the `hello` command to `howdy`}
That configuration is essentially telling oclif to look for an INIT_HOOK export inside of ./dist/index.js
Bundling​
We do not support bundling given the endless number of tools + configurations that could be used. But if you choose to use a bundler, like esbuild, there are a couple hard requirements - you must have a package.json in your root directory and a bin/run or bin/run.js bin script. This means that you will not be able to successfully bundle your entire CLI (src code, package.json, node_modules, etc) into a single file.
If you still want to use a bundler, you can reference this example repo.
Dynamic Commands​
You can also use the explicit strategy if you want to manipulate or create commands at runtime. Please note that such usage of the explicit strategy cannot be used with an oclif.manifest.json, which will have significant performance implications for your CLI in production.
Example:
// src/index.tsimport {Command, Flags} from '@oclif/core'import Hello from './commands/hello'import HelloWorld from './commands/hello/world'const dynamicCommands: Record<string, Command.Class> = {}if (process.env.DYNAMIC_COMMAND) {  dynamicCommands[process.env.DYNAMIC_COMMAND] = class extends Command {    static flags = {      flag1: Flags.boolean({description: 'flag1 description'}),    }    async run(): Promise<void> {      const {flags} = await this.parse(this.constructor as Command.Class)      this.log('hello from', this.id, flags)    }  }}export const COMMANDS = {  hello: Hello,  'hello:world': HelloWorld,  ...dynamicCommands,}
❯ DYNAMIC_COMMAND=foo:bar:baz bin/run.js foo bar baz --flag1hello from foo:bar:baz { flag1: true }
single Strategy​
The single strategy tells oclif that this CLI contains a single command that can be executed by the bin/run.js (e.g. ls or cat).
{  "oclif": {    "commands": {      "strategy": "single",      "target": "./dist/index.js"    }  }}
In this example, ./dist/index.js exports the command class.
Note about oclif.manifest.json​
For all strategies, the oclif.manifest.json will be used to load the commands instead of the default behavior of the strategy.Edit this pageLast updated on Dec 20, 2024 by Mike DonnalleyPreviousConfigNextTopicspattern Strategyexplicit Strategysingle StrategyNote about oclif.manifest.json\n\n\n\nAPI ReferenceCommand Discovery StrategiesOn this pageCommand Discovery StrategiesWhen oclif loads a plugin is must find all the commands within that plugin that can be executed. There a three strategies for discovering these commands:

pattern - this is the default behavior that finds commands based on glob patterns.
explicit - find commands that are exported from a specified file.
single - CLI contains a single command executed by top-level bin.

pattern Strategy​
The pattern strategy tells oclif to use a predefined set of globs to find command files in a specified directory. This is the default behavior of oclif unless otherwise stated.
Plugins can point the commands property to a directory
{  "oclif": {    "commands": "./dist/commands",  }}
This will tell oclif to look for commands in that directory (this is skipped if an oclif.manifest.json is present)
Alternatively, you can set this configuration which will do the exact same thing:
{  "oclif": {    "commands": {      "strategy": "pattern",      "target": "./dist/commands"    }  }}
You also have the ability to set globPatterns, which override the glob patterns that oclif uses when searching for command files:
{  "oclif": {    "commands": {      "strategy": "pattern",      "target": "./dist/commands",      "globPatterns": [         "**/*.+(js|cjs|mjs|ts|tsx|mts|cts)",        "!**/*.+(d.*|test.*|spec.*|helpers.*)?(x)"      ]    }  }}
This is useful if you like to put test or helper files in the same directory as your command files.
explicit Strategy​
The explicit strategy tells oclif to import commands from a single file. In this case the target is the file that exports the commands and identifier is the name of the export (defaults to default).
To use this you would add a new file (e.g. src/commands.ts) and then add this configuration to the package.json
{  "oclif": {    "commands": {      "strategy": "explicit",      "target": "./dist/index.js",      "identifier": "COMMANDS",    }  }}
src/index.ts would then need to have an export with the same name as the identifier (if not set, it defaults to default) that's an object of command names to command classes, e.g.
import Hello from './commands/hello'import HelloWorld from './commands/hello/world'export const COMMANDS = {  hello: Hello,  'hello:world': HelloWorld,  howdy: Hello, // alias the `hello` command to `howdy`}
The explicit strategy is useful to those who can't rely on file paths because they've bundled their code (see Bundling) but it can also be used if you simply prefer to be more explicit about your commands instead of relying on oclif "magically" finding commands from the file system.
It can also be leveraged to create or modify commands at runtime (e.g. internationalize messages at runtime or add flags to a command based on an API spec - see dynamic commands section below).
Hooks​
Hooks can also be defined using the explicit strategy:
"oclif": {    "hooks": {      "init": {        "target": "./dist/index.js",        "identifier": "INIT_HOOK"      }    }}
// src/index.tsimport Hello from './commands/hello'import HelloWorld from './commands/hello/world'export {default as INIT_HOOK} from './hooks/init/init.js'export const COMMANDS = {  hello: Hello,  'hello:world': HelloWorld,  howdy: Hello, // alias the `hello` command to `howdy`}
That configuration is essentially telling oclif to look for an INIT_HOOK export inside of ./dist/index.js
Bundling​
We do not support bundling given the endless number of tools + configurations that could be used. But if you choose to use a bundler, like esbuild, there are a couple hard requirements - you must have a package.json in your root directory and a bin/run or bin/run.js bin script. This means that you will not be able to successfully bundle your entire CLI (src code, package.json, node_modules, etc) into a single file.
If you still want to use a bundler, you can reference this example repo.
Dynamic Commands​
You can also use the explicit strategy if you want to manipulate or create commands at runtime. Please note that such usage of the explicit strategy cannot be used with an oclif.manifest.json, which will have significant performance implications for your CLI in production.
Example:
// src/index.tsimport {Command, Flags} from '@oclif/core'import Hello from './commands/hello'import HelloWorld from './commands/hello/world'const dynamicCommands: Record<string, Command.Class> = {}if (process.env.DYNAMIC_COMMAND) {  dynamicCommands[process.env.DYNAMIC_COMMAND] = class extends Command {    static flags = {      flag1: Flags.boolean({description: 'flag1 description'}),    }    async run(): Promise<void> {      const {flags} = await this.parse(this.constructor as Command.Class)      this.log('hello from', this.id, flags)    }  }}export const COMMANDS = {  hello: Hello,  'hello:world': HelloWorld,  ...dynamicCommands,}
❯ DYNAMIC_COMMAND=foo:bar:baz bin/run.js foo bar baz --flag1hello from foo:bar:baz { flag1: true }
single Strategy​
The single strategy tells oclif that this CLI contains a single command that can be executed by the bin/run.js (e.g. ls or cat).
{  "oclif": {    "commands": {      "strategy": "single",      "target": "./dist/index.js"    }  }}
In this example, ./dist/index.js exports the command class.
Note about oclif.manifest.json​
For all strategies, the oclif.manifest.json will be used to load the commands instead of the default behavior of the strategy.Edit this pageLast updated on Dec 20, 2024 by Mike Donnalley\n\nAPI ReferenceCommand Discovery StrategiesOn this pageCommand Discovery StrategiesWhen oclif loads a plugin is must find all the commands within that plugin that can be executed. There a three strategies for discovering these commands:

pattern - this is the default behavior that finds commands based on glob patterns.
explicit - find commands that are exported from a specified file.
single - CLI contains a single command executed by top-level bin.

pattern Strategy​
The pattern strategy tells oclif to use a predefined set of globs to find command files in a specified directory. This is the default behavior of oclif unless otherwise stated.
Plugins can point the commands property to a directory
{  "oclif": {    "commands": "./dist/commands",  }}
This will tell oclif to look for commands in that directory (this is skipped if an oclif.manifest.json is present)
Alternatively, you can set this configuration which will do the exact same thing:
{  "oclif": {    "commands": {      "strategy": "pattern",      "target": "./dist/commands"    }  }}
You also have the ability to set globPatterns, which override the glob patterns that oclif uses when searching for command files:
{  "oclif": {    "commands": {      "strategy": "pattern",      "target": "./dist/commands",      "globPatterns": [         "**/*.+(js|cjs|mjs|ts|tsx|mts|cts)",        "!**/*.+(d.*|test.*|spec.*|helpers.*)?(x)"      ]    }  }}
This is useful if you like to put test or helper files in the same directory as your command files.
explicit Strategy​
The explicit strategy tells oclif to import commands from a single file. In this case the target is the file that exports the commands and identifier is the name of the export (defaults to default).
To use this you would add a new file (e.g. src/commands.ts) and then add this configuration to the package.json
{  "oclif": {    "commands": {      "strategy": "explicit",      "target": "./dist/index.js",      "identifier": "COMMANDS",    }  }}
src/index.ts would then need to have an export with the same name as the identifier (if not set, it defaults to default) that's an object of command names to command classes, e.g.
import Hello from './commands/hello'import HelloWorld from './commands/hello/world'export const COMMANDS = {  hello: Hello,  'hello:world': HelloWorld,  howdy: Hello, // alias the `hello` command to `howdy`}
The explicit strategy is useful to those who can't rely on file paths because they've bundled their code (see Bundling) but it can also be used if you simply prefer to be more explicit about your commands instead of relying on oclif "magically" finding commands from the file system.
It can also be leveraged to create or modify commands at runtime (e.g. internationalize messages at runtime or add flags to a command based on an API spec - see dynamic commands section below).
Hooks​
Hooks can also be defined using the explicit strategy:
"oclif": {    "hooks": {      "init": {        "target": "./dist/index.js",        "identifier": "INIT_HOOK"      }    }}
// src/index.tsimport Hello from './commands/hello'import HelloWorld from './commands/hello/world'export {default as INIT_HOOK} from './hooks/init/init.js'export const COMMANDS = {  hello: Hello,  'hello:world': HelloWorld,  howdy: Hello, // alias the `hello` command to `howdy`}
That configuration is essentially telling oclif to look for an INIT_HOOK export inside of ./dist/index.js
Bundling​
We do not support bundling given the endless number of tools + configurations that could be used. But if you choose to use a bundler, like esbuild, there are a couple hard requirements - you must have a package.json in your root directory and a bin/run or bin/run.js bin script. This means that you will not be able to successfully bundle your entire CLI (src code, package.json, node_modules, etc) into a single file.
If you still want to use a bundler, you can reference this example repo.
Dynamic Commands​
You can also use the explicit strategy if you want to manipulate or create commands at runtime. Please note that such usage of the explicit strategy cannot be used with an oclif.manifest.json, which will have significant performance implications for your CLI in production.
Example:
// src/index.tsimport {Command, Flags} from '@oclif/core'import Hello from './commands/hello'import HelloWorld from './commands/hello/world'const dynamicCommands: Record<string, Command.Class> = {}if (process.env.DYNAMIC_COMMAND) {  dynamicCommands[process.env.DYNAMIC_COMMAND] = class extends Command {    static flags = {      flag1: Flags.boolean({description: 'flag1 description'}),    }    async run(): Promise<void> {      const {flags} = await this.parse(this.constructor as Command.Class)      this.log('hello from', this.id, flags)    }  }}export const COMMANDS = {  hello: Hello,  'hello:world': HelloWorld,  ...dynamicCommands,}
❯ DYNAMIC_COMMAND=foo:bar:baz bin/run.js foo bar baz --flag1hello from foo:bar:baz { flag1: true }
single Strategy​
The single strategy tells oclif that this CLI contains a single command that can be executed by the bin/run.js (e.g. ls or cat).
{  "oclif": {    "commands": {      "strategy": "single",      "target": "./dist/index.js"    }  }}
In this example, ./dist/index.js exports the command class.
Note about oclif.manifest.json​
For all strategies, the oclif.manifest.json will be used to load the commands instead of the default behavior of the strategy.Edit this pageLast updated on Dec 20, 2024 by Mike DonnalleyPreviousConfigNextTopicspattern Strategyexplicit Strategysingle StrategyNote about oclif.manifest.json\n\n\n\nAPI ReferenceCommand Discovery StrategiesOn this pageCommand Discovery StrategiesWhen oclif loads a plugin is must find all the commands within that plugin that can be executed. There a three strategies for discovering these commands:

pattern - this is the default behavior that finds commands based on glob patterns.
explicit - find commands that are exported from a specified file.
single - CLI contains a single command executed by top-level bin.

pattern Strategy​
The pattern strategy tells oclif to use a predefined set of globs to find command files in a specified directory. This is the default behavior of oclif unless otherwise stated.
Plugins can point the commands property to a directory
{  "oclif": {    "commands": "./dist/commands",  }}
This will tell oclif to look for commands in that directory (this is skipped if an oclif.manifest.json is present)
Alternatively, you can set this configuration which will do the exact same thing:
{  "oclif": {    "commands": {      "strategy": "pattern",      "target": "./dist/commands"    }  }}
You also have the ability to set globPatterns, which override the glob patterns that oclif uses when searching for command files:
{  "oclif": {    "commands": {      "strategy": "pattern",      "target": "./dist/commands",      "globPatterns": [         "**/*.+(js|cjs|mjs|ts|tsx|mts|cts)",        "!**/*.+(d.*|test.*|spec.*|helpers.*)?(x)"      ]    }  }}
This is useful if you like to put test or helper files in the same directory as your command files.
explicit Strategy​
The explicit strategy tells oclif to import commands from a single file. In this case the target is the file that exports the commands and identifier is the name of the export (defaults to default).
To use this you would add a new file (e.g. src/commands.ts) and then add this configuration to the package.json
{  "oclif": {    "commands": {      "strategy": "explicit",      "target": "./dist/index.js",      "identifier": "COMMANDS",    }  }}
src/index.ts would then need to have an export with the same name as the identifier (if not set, it defaults to default) that's an object of command names to command classes, e.g.
import Hello from './commands/hello'import HelloWorld from './commands/hello/world'export const COMMANDS = {  hello: Hello,  'hello:world': HelloWorld,  howdy: Hello, // alias the `hello` command to `howdy`}
The explicit strategy is useful to those who can't rely on file paths because they've bundled their code (see Bundling) but it can also be used if you simply prefer to be more explicit about your commands instead of relying on oclif "magically" finding commands from the file system.
It can also be leveraged to create or modify commands at runtime (e.g. internationalize messages at runtime or add flags to a command based on an API spec - see dynamic commands section below).
Hooks​
Hooks can also be defined using the explicit strategy:
"oclif": {    "hooks": {      "init": {        "target": "./dist/index.js",        "identifier": "INIT_HOOK"      }    }}
// src/index.tsimport Hello from './commands/hello'import HelloWorld from './commands/hello/world'export {default as INIT_HOOK} from './hooks/init/init.js'export const COMMANDS = {  hello: Hello,  'hello:world': HelloWorld,  howdy: Hello, // alias the `hello` command to `howdy`}
That configuration is essentially telling oclif to look for an INIT_HOOK export inside of ./dist/index.js
Bundling​
We do not support bundling given the endless number of tools + configurations that could be used. But if you choose to use a bundler, like esbuild, there are a couple hard requirements - you must have a package.json in your root directory and a bin/run or bin/run.js bin script. This means that you will not be able to successfully bundle your entire CLI (src code, package.json, node_modules, etc) into a single file.
If you still want to use a bundler, you can reference this example repo.
Dynamic Commands​
You can also use the explicit strategy if you want to manipulate or create commands at runtime. Please note that such usage of the explicit strategy cannot be used with an oclif.manifest.json, which will have significant performance implications for your CLI in production.
Example:
// src/index.tsimport {Command, Flags} from '@oclif/core'import Hello from './commands/hello'import HelloWorld from './commands/hello/world'const dynamicCommands: Record<string, Command.Class> = {}if (process.env.DYNAMIC_COMMAND) {  dynamicCommands[process.env.DYNAMIC_COMMAND] = class extends Command {    static flags = {      flag1: Flags.boolean({description: 'flag1 description'}),    }    async run(): Promise<void> {      const {flags} = await this.parse(this.constructor as Command.Class)      this.log('hello from', this.id, flags)    }  }}export const COMMANDS = {  hello: Hello,  'hello:world': HelloWorld,  ...dynamicCommands,}
❯ DYNAMIC_COMMAND=foo:bar:baz bin/run.js foo bar baz --flag1hello from foo:bar:baz { flag1: true }
single Strategy​
The single strategy tells oclif that this CLI contains a single command that can be executed by the bin/run.js (e.g. ls or cat).
{  "oclif": {    "commands": {      "strategy": "single",      "target": "./dist/index.js"    }  }}
In this example, ./dist/index.js exports the command class.
Note about oclif.manifest.json​
For all strategies, the oclif.manifest.json will be used to load the commands instead of the default behavior of the strategy.Edit this pageLast updated on Dec 20, 2024 by Mike Donnalley\n\nAPI ReferenceCommand Discovery StrategiesOn this pageCommand Discovery StrategiesWhen oclif loads a plugin is must find all the commands within that plugin that can be executed. There a three strategies for discovering these commands:

pattern - this is the default behavior that finds commands based on glob patterns.
explicit - find commands that are exported from a specified file.
single - CLI contains a single command executed by top-level bin.

pattern Strategy​
The pattern strategy tells oclif to use a predefined set of globs to find command files in a specified directory. This is the default behavior of oclif unless otherwise stated.
Plugins can point the commands property to a directory
{  "oclif": {    "commands": "./dist/commands",  }}
This will tell oclif to look for commands in that directory (this is skipped if an oclif.manifest.json is present)
Alternatively, you can set this configuration which will do the exact same thing:
{  "oclif": {    "commands": {      "strategy": "pattern",      "target": "./dist/commands"    }  }}
You also have the ability to set globPatterns, which override the glob patterns that oclif uses when searching for command files:
{  "oclif": {    "commands": {      "strategy": "pattern",      "target": "./dist/commands",      "globPatterns": [         "**/*.+(js|cjs|mjs|ts|tsx|mts|cts)",        "!**/*.+(d.*|test.*|spec.*|helpers.*)?(x)"      ]    }  }}
This is useful if you like to put test or helper files in the same directory as your command files.
explicit Strategy​
The explicit strategy tells oclif to import commands from a single file. In this case the target is the file that exports the commands and identifier is the name of the export (defaults to default).
To use this you would add a new file (e.g. src/commands.ts) and then add this configuration to the package.json
{  "oclif": {    "commands": {      "strategy": "explicit",      "target": "./dist/index.js",      "identifier": "COMMANDS",    }  }}
src/index.ts would then need to have an export with the same name as the identifier (if not set, it defaults to default) that's an object of command names to command classes, e.g.
import Hello from './commands/hello'import HelloWorld from './commands/hello/world'export const COMMANDS = {  hello: Hello,  'hello:world': HelloWorld,  howdy: Hello, // alias the `hello` command to `howdy`}
The explicit strategy is useful to those who can't rely on file paths because they've bundled their code (see Bundling) but it can also be used if you simply prefer to be more explicit about your commands instead of relying on oclif "magically" finding commands from the file system.
It can also be leveraged to create or modify commands at runtime (e.g. internationalize messages at runtime or add flags to a command based on an API spec - see dynamic commands section below).
Hooks​
Hooks can also be defined using the explicit strategy:
"oclif": {    "hooks": {      "init": {        "target": "./dist/index.js",        "identifier": "INIT_HOOK"      }    }}
// src/index.tsimport Hello from './commands/hello'import HelloWorld from './commands/hello/world'export {default as INIT_HOOK} from './hooks/init/init.js'export const COMMANDS = {  hello: Hello,  'hello:world': HelloWorld,  howdy: Hello, // alias the `hello` command to `howdy`}
That configuration is essentially telling oclif to look for an INIT_HOOK export inside of ./dist/index.js
Bundling​
We do not support bundling given the endless number of tools + configurations that could be used. But if you choose to use a bundler, like esbuild, there are a couple hard requirements - you must have a package.json in your root directory and a bin/run or bin/run.js bin script. This means that you will not be able to successfully bundle your entire CLI (src code, package.json, node_modules, etc) into a single file.
If you still want to use a bundler, you can reference this example repo.
Dynamic Commands​
You can also use the explicit strategy if you want to manipulate or create commands at runtime. Please note that such usage of the explicit strategy cannot be used with an oclif.manifest.json, which will have significant performance implications for your CLI in production.
Example:
// src/index.tsimport {Command, Flags} from '@oclif/core'import Hello from './commands/hello'import HelloWorld from './commands/hello/world'const dynamicCommands: Record<string, Command.Class> = {}if (process.env.DYNAMIC_COMMAND) {  dynamicCommands[process.env.DYNAMIC_COMMAND] = class extends Command {    static flags = {      flag1: Flags.boolean({description: 'flag1 description'}),    }    async run(): Promise<void> {      const {flags} = await this.parse(this.constructor as Command.Class)      this.log('hello from', this.id, flags)    }  }}export const COMMANDS = {  hello: Hello,  'hello:world': HelloWorld,  ...dynamicCommands,}
❯ DYNAMIC_COMMAND=foo:bar:baz bin/run.js foo bar baz --flag1hello from foo:bar:baz { flag1: true }
single Strategy​
The single strategy tells oclif that this CLI contains a single command that can be executed by the bin/run.js (e.g. ls or cat).
{  "oclif": {    "commands": {      "strategy": "single",      "target": "./dist/index.js"    }  }}
In this example, ./dist/index.js exports the command class.
Note about oclif.manifest.json​
For all strategies, the oclif.manifest.json will be used to load the commands instead of the default behavior of the strategy.Edit this pageLast updated on Dec 20, 2024 by Mike DonnalleyPreviousConfigNextTopicspattern Strategyexplicit Strategysingle StrategyNote about oclif.manifest.json\n\n\n\nAPI ReferenceCommand Discovery StrategiesOn this pageCommand Discovery StrategiesWhen oclif loads a plugin is must find all the commands within that plugin that can be executed. There a three strategies for discovering these commands:

pattern - this is the default behavior that finds commands based on glob patterns.
explicit - find commands that are exported from a specified file.
single - CLI contains a single command executed by top-level bin.

pattern Strategy​
The pattern strategy tells oclif to use a predefined set of globs to find command files in a specified directory. This is the default behavior of oclif unless otherwise stated.
Plugins can point the commands property to a directory
{  "oclif": {    "commands": "./dist/commands",  }}
This will tell oclif to look for commands in that directory (this is skipped if an oclif.manifest.json is present)
Alternatively, you can set this configuration which will do the exact same thing:
{  "oclif": {    "commands": {      "strategy": "pattern",      "target": "./dist/commands"    }  }}
You also have the ability to set globPatterns, which override the glob patterns that oclif uses when searching for command files:
{  "oclif": {    "commands": {      "strategy": "pattern",      "target": "./dist/commands",      "globPatterns": [         "**/*.+(js|cjs|mjs|ts|tsx|mts|cts)",        "!**/*.+(d.*|test.*|spec.*|helpers.*)?(x)"      ]    }  }}
This is useful if you like to put test or helper files in the same directory as your command files.
explicit Strategy​
The explicit strategy tells oclif to import commands from a single file. In this case the target is the file that exports the commands and identifier is the name of the export (defaults to default).
To use this you would add a new file (e.g. src/commands.ts) and then add this configuration to the package.json
{  "oclif": {    "commands": {      "strategy": "explicit",      "target": "./dist/index.js",      "identifier": "COMMANDS",    }  }}
src/index.ts would then need to have an export with the same name as the identifier (if not set, it defaults to default) that's an object of command names to command classes, e.g.
import Hello from './commands/hello'import HelloWorld from './commands/hello/world'export const COMMANDS = {  hello: Hello,  'hello:world': HelloWorld,  howdy: Hello, // alias the `hello` command to `howdy`}
The explicit strategy is useful to those who can't rely on file paths because they've bundled their code (see Bundling) but it can also be used if you simply prefer to be more explicit about your commands instead of relying on oclif "magically" finding commands from the file system.
It can also be leveraged to create or modify commands at runtime (e.g. internationalize messages at runtime or add flags to a command based on an API spec - see dynamic commands section below).
Hooks​
Hooks can also be defined using the explicit strategy:
"oclif": {    "hooks": {      "init": {        "target": "./dist/index.js",        "identifier": "INIT_HOOK"      }    }}
// src/index.tsimport Hello from './commands/hello'import HelloWorld from './commands/hello/world'export {default as INIT_HOOK} from './hooks/init/init.js'export const COMMANDS = {  hello: Hello,  'hello:world': HelloWorld,  howdy: Hello, // alias the `hello` command to `howdy`}
That configuration is essentially telling oclif to look for an INIT_HOOK export inside of ./dist/index.js
Bundling​
We do not support bundling given the endless number of tools + configurations that could be used. But if you choose to use a bundler, like esbuild, there are a couple hard requirements - you must have a package.json in your root directory and a bin/run or bin/run.js bin script. This means that you will not be able to successfully bundle your entire CLI (src code, package.json, node_modules, etc) into a single file.
If you still want to use a bundler, you can reference this example repo.
Dynamic Commands​
You can also use the explicit strategy if you want to manipulate or create commands at runtime. Please note that such usage of the explicit strategy cannot be used with an oclif.manifest.json, which will have significant performance implications for your CLI in production.
Example:
// src/index.tsimport {Command, Flags} from '@oclif/core'import Hello from './commands/hello'import HelloWorld from './commands/hello/world'const dynamicCommands: Record<string, Command.Class> = {}if (process.env.DYNAMIC_COMMAND) {  dynamicCommands[process.env.DYNAMIC_COMMAND] = class extends Command {    static flags = {      flag1: Flags.boolean({description: 'flag1 description'}),    }    async run(): Promise<void> {      const {flags} = await this.parse(this.constructor as Command.Class)      this.log('hello from', this.id, flags)    }  }}export const COMMANDS = {  hello: Hello,  'hello:world': HelloWorld,  ...dynamicCommands,}
❯ DYNAMIC_COMMAND=foo:bar:baz bin/run.js foo bar baz --flag1hello from foo:bar:baz { flag1: true }
single Strategy​
The single strategy tells oclif that this CLI contains a single command that can be executed by the bin/run.js (e.g. ls or cat).
{  "oclif": {    "commands": {      "strategy": "single",      "target": "./dist/index.js"    }  }}
In this example, ./dist/index.js exports the command class.
Note about oclif.manifest.json​
For all strategies, the oclif.manifest.json will be used to load the commands instead of the default behavior of the strategy.Edit this pageLast updated on Dec 20, 2024 by Mike Donnalley\n\nAPI ReferenceCommand Discovery StrategiesOn this pageCommand Discovery StrategiesWhen oclif loads a plugin is must find all the commands within that plugin that can be executed. There a three strategies for discovering these commands:

pattern - this is the default behavior that finds commands based on glob patterns.
explicit - find commands that are exported from a specified file.
single - CLI contains a single command executed by top-level bin.

pattern Strategy​
The pattern strategy tells oclif to use a predefined set of globs to find command files in a specified directory. This is the default behavior of oclif unless otherwise stated.
Plugins can point the commands property to a directory
{  "oclif": {    "commands": "./dist/commands",  }}
This will tell oclif to look for commands in that directory (this is skipped if an oclif.manifest.json is present)
Alternatively, you can set this configuration which will do the exact same thing:
{  "oclif": {    "commands": {      "strategy": "pattern",      "target": "./dist/commands"    }  }}
You also have the ability to set globPatterns, which override the glob patterns that oclif uses when searching for command files:
{  "oclif": {    "commands": {      "strategy": "pattern",      "target": "./dist/commands",      "globPatterns": [         "**/*.+(js|cjs|mjs|ts|tsx|mts|cts)",        "!**/*.+(d.*|test.*|spec.*|helpers.*)?(x)"      ]    }  }}
This is useful if you like to put test or helper files in the same directory as your command files.
explicit Strategy​
The explicit strategy tells oclif to import commands from a single file. In this case the target is the file that exports the commands and identifier is the name of the export (defaults to default).
To use this you would add a new file (e.g. src/commands.ts) and then add this configuration to the package.json
{  "oclif": {    "commands": {      "strategy": "explicit",      "target": "./dist/index.js",      "identifier": "COMMANDS",    }  }}
src/index.ts would then need to have an export with the same name as the identifier (if not set, it defaults to default) that's an object of command names to command classes, e.g.
import Hello from './commands/hello'import HelloWorld from './commands/hello/world'export const COMMANDS = {  hello: Hello,  'hello:world': HelloWorld,  howdy: Hello, // alias the `hello` command to `howdy`}
The explicit strategy is useful to those who can't rely on file paths because they've bundled their code (see Bundling) but it can also be used if you simply prefer to be more explicit about your commands instead of relying on oclif "magically" finding commands from the file system.
It can also be leveraged to create or modify commands at runtime (e.g. internationalize messages at runtime or add flags to a command based on an API spec - see dynamic commands section below).
Hooks​
Hooks can also be defined using the explicit strategy:
"oclif": {    "hooks": {      "init": {        "target": "./dist/index.js",        "identifier": "INIT_HOOK"      }    }}
// src/index.tsimport Hello from './commands/hello'import HelloWorld from './commands/hello/world'export {default as INIT_HOOK} from './hooks/init/init.js'export const COMMANDS = {  hello: Hello,  'hello:world': HelloWorld,  howdy: Hello, // alias the `hello` command to `howdy`}
That configuration is essentially telling oclif to look for an INIT_HOOK export inside of ./dist/index.js
Bundling​
We do not support bundling given the endless number of tools + configurations that could be used. But if you choose to use a bundler, like esbuild, there are a couple hard requirements - you must have a package.json in your root directory and a bin/run or bin/run.js bin script. This means that you will not be able to successfully bundle your entire CLI (src code, package.json, node_modules, etc) into a single file.
If you still want to use a bundler, you can reference this example repo.
Dynamic Commands​
You can also use the explicit strategy if you want to manipulate or create commands at runtime. Please note that such usage of the explicit strategy cannot be used with an oclif.manifest.json, which will have significant performance implications for your CLI in production.
Example:
// src/index.tsimport {Command, Flags} from '@oclif/core'import Hello from './commands/hello'import HelloWorld from './commands/hello/world'const dynamicCommands: Record<string, Command.Class> = {}if (process.env.DYNAMIC_COMMAND) {  dynamicCommands[process.env.DYNAMIC_COMMAND] = class extends Command {    static flags = {      flag1: Flags.boolean({description: 'flag1 description'}),    }    async run(): Promise<void> {      const {flags} = await this.parse(this.constructor as Command.Class)      this.log('hello from', this.id, flags)    }  }}export const COMMANDS = {  hello: Hello,  'hello:world': HelloWorld,  ...dynamicCommands,}
❯ DYNAMIC_COMMAND=foo:bar:baz bin/run.js foo bar baz --flag1hello from foo:bar:baz { flag1: true }
single Strategy​
The single strategy tells oclif that this CLI contains a single command that can be executed by the bin/run.js (e.g. ls or cat).
{  "oclif": {    "commands": {      "strategy": "single",      "target": "./dist/index.js"    }  }}
In this example, ./dist/index.js exports the command class.
Note about oclif.manifest.json​
For all strategies, the oclif.manifest.json will be used to load the commands instead of the default behavior of the strategy.Edit this pageLast updated on Dec 20, 2024 by Mike DonnalleyPreviousConfigNextTopicspattern Strategyexplicit Strategysingle StrategyNote about oclif.manifest.json\n\n\n\nAPI ReferenceCommand Discovery StrategiesOn this pageCommand Discovery StrategiesWhen oclif loads a plugin is must find all the commands within that plugin that can be executed. There a three strategies for discovering these commands:

pattern - this is the default behavior that finds commands based on glob patterns.
explicit - find commands that are exported from a specified file.
single - CLI contains a single command executed by top-level bin.

pattern Strategy​
The pattern strategy tells oclif to use a predefined set of globs to find command files in a specified directory. This is the default behavior of oclif unless otherwise stated.
Plugins can point the commands property to a directory
{  "oclif": {    "commands": "./dist/commands",  }}
This will tell oclif to look for commands in that directory (this is skipped if an oclif.manifest.json is present)
Alternatively, you can set this configuration which will do the exact same thing:
{  "oclif": {    "commands": {      "strategy": "pattern",      "target": "./dist/commands"    }  }}
You also have the ability to set globPatterns, which override the glob patterns that oclif uses when searching for command files:
{  "oclif": {    "commands": {      "strategy": "pattern",      "target": "./dist/commands",      "globPatterns": [         "**/*.+(js|cjs|mjs|ts|tsx|mts|cts)",        "!**/*.+(d.*|test.*|spec.*|helpers.*)?(x)"      ]    }  }}
This is useful if you like to put test or helper files in the same directory as your command files.
explicit Strategy​
The explicit strategy tells oclif to import commands from a single file. In this case the target is the file that exports the commands and identifier is the name of the export (defaults to default).
To use this you would add a new file (e.g. src/commands.ts) and then add this configuration to the package.json
{  "oclif": {    "commands": {      "strategy": "explicit",      "target": "./dist/index.js",      "identifier": "COMMANDS",    }  }}
src/index.ts would then need to have an export with the same name as the identifier (if not set, it defaults to default) that's an object of command names to command classes, e.g.
import Hello from './commands/hello'import HelloWorld from './commands/hello/world'export const COMMANDS = {  hello: Hello,  'hello:world': HelloWorld,  howdy: Hello, // alias the `hello` command to `howdy`}
The explicit strategy is useful to those who can't rely on file paths because they've bundled their code (see Bundling) but it can also be used if you simply prefer to be more explicit about your commands instead of relying on oclif "magically" finding commands from the file system.
It can also be leveraged to create or modify commands at runtime (e.g. internationalize messages at runtime or add flags to a command based on an API spec - see dynamic commands section below).
Hooks​
Hooks can also be defined using the explicit strategy:
"oclif": {    "hooks": {      "init": {        "target": "./dist/index.js",        "identifier": "INIT_HOOK"      }    }}
// src/index.tsimport Hello from './commands/hello'import HelloWorld from './commands/hello/world'export {default as INIT_HOOK} from './hooks/init/init.js'export const COMMANDS = {  hello: Hello,  'hello:world': HelloWorld,  howdy: Hello, // alias the `hello` command to `howdy`}
That configuration is essentially telling oclif to look for an INIT_HOOK export inside of ./dist/index.js
Bundling​
We do not support bundling given the endless number of tools + configurations that could be used. But if you choose to use a bundler, like esbuild, there are a couple hard requirements - you must have a package.json in your root directory and a bin/run or bin/run.js bin script. This means that you will not be able to successfully bundle your entire CLI (src code, package.json, node_modules, etc) into a single file.
If you still want to use a bundler, you can reference this example repo.
Dynamic Commands​
You can also use the explicit strategy if you want to manipulate or create commands at runtime. Please note that such usage of the explicit strategy cannot be used with an oclif.manifest.json, which will have significant performance implications for your CLI in production.
Example:
// src/index.tsimport {Command, Flags} from '@oclif/core'import Hello from './commands/hello'import HelloWorld from './commands/hello/world'const dynamicCommands: Record<string, Command.Class> = {}if (process.env.DYNAMIC_COMMAND) {  dynamicCommands[process.env.DYNAMIC_COMMAND] = class extends Command {    static flags = {      flag1: Flags.boolean({description: 'flag1 description'}),    }    async run(): Promise<void> {      const {flags} = await this.parse(this.constructor as Command.Class)      this.log('hello from', this.id, flags)    }  }}export const COMMANDS = {  hello: Hello,  'hello:world': HelloWorld,  ...dynamicCommands,}
❯ DYNAMIC_COMMAND=foo:bar:baz bin/run.js foo bar baz --flag1hello from foo:bar:baz { flag1: true }
single Strategy​
The single strategy tells oclif that this CLI contains a single command that can be executed by the bin/run.js (e.g. ls or cat).
{  "oclif": {    "commands": {      "strategy": "single",      "target": "./dist/index.js"    }  }}
In this example, ./dist/index.js exports the command class.
Note about oclif.manifest.json​
For all strategies, the oclif.manifest.json will be used to load the commands instead of the default behavior of the strategy.Edit this pageLast updated on Dec 20, 2024 by Mike Donnalley\n\nAPI ReferenceCommand Discovery StrategiesOn this pageCommand Discovery StrategiesWhen oclif loads a plugin is must find all the commands within that plugin that can be executed. There a three strategies for discovering these commands:

pattern - this is the default behavior that finds commands based on glob patterns.
explicit - find commands that are exported from a specified file.
single - CLI contains a single command executed by top-level bin.

pattern Strategy​
The pattern strategy tells oclif to use a predefined set of globs to find command files in a specified directory. This is the default behavior of oclif unless otherwise stated.
Plugins can point the commands property to a directory
{  "oclif": {    "commands": "./dist/commands",  }}
This will tell oclif to look for commands in that directory (this is skipped if an oclif.manifest.json is present)
Alternatively, you can set this configuration which will do the exact same thing:
{  "oclif": {    "commands": {      "strategy": "pattern",      "target": "./dist/commands"    }  }}
You also have the ability to set globPatterns, which override the glob patterns that oclif uses when searching for command files:
{  "oclif": {    "commands": {      "strategy": "pattern",      "target": "./dist/commands",      "globPatterns": [         "**/*.+(js|cjs|mjs|ts|tsx|mts|cts)",        "!**/*.+(d.*|test.*|spec.*|helpers.*)?(x)"      ]    }  }}
This is useful if you like to put test or helper files in the same directory as your command files.
explicit Strategy​
The explicit strategy tells oclif to import commands from a single file. In this case the target is the file that exports the commands and identifier is the name of the export (defaults to default).
To use this you would add a new file (e.g. src/commands.ts) and then add this configuration to the package.json
{  "oclif": {    "commands": {      "strategy": "explicit",      "target": "./dist/index.js",      "identifier": "COMMANDS",    }  }}
src/index.ts would then need to have an export with the same name as the identifier (if not set, it defaults to default) that's an object of command names to command classes, e.g.
import Hello from './commands/hello'import HelloWorld from './commands/hello/world'export const COMMANDS = {  hello: Hello,  'hello:world': HelloWorld,  howdy: Hello, // alias the `hello` command to `howdy`}
The explicit strategy is useful to those who can't rely on file paths because they've bundled their code (see Bundling) but it can also be used if you simply prefer to be more explicit about your commands instead of relying on oclif "magically" finding commands from the file system.
It can also be leveraged to create or modify commands at runtime (e.g. internationalize messages at runtime or add flags to a command based on an API spec - see dynamic commands section below).
Hooks​
Hooks can also be defined using the explicit strategy:
"oclif": {    "hooks": {      "init": {        "target": "./dist/index.js",        "identifier": "INIT_HOOK"      }    }}
// src/index.tsimport Hello from './commands/hello'import HelloWorld from './commands/hello/world'export {default as INIT_HOOK} from './hooks/init/init.js'export const COMMANDS = {  hello: Hello,  'hello:world': HelloWorld,  howdy: Hello, // alias the `hello` command to `howdy`}
That configuration is essentially telling oclif to look for an INIT_HOOK export inside of ./dist/index.js
Bundling​
We do not support bundling given the endless number of tools + configurations that could be used. But if you choose to use a bundler, like esbuild, there are a couple hard requirements - you must have a package.json in your root directory and a bin/run or bin/run.js bin script. This means that you will not be able to successfully bundle your entire CLI (src code, package.json, node_modules, etc) into a single file.
If you still want to use a bundler, you can reference this example repo.
Dynamic Commands​
You can also use the explicit strategy if you want to manipulate or create commands at runtime. Please note that such usage of the explicit strategy cannot be used with an oclif.manifest.json, which will have significant performance implications for your CLI in production.
Example:
// src/index.tsimport {Command, Flags} from '@oclif/core'import Hello from './commands/hello'import HelloWorld from './commands/hello/world'const dynamicCommands: Record<string, Command.Class> = {}if (process.env.DYNAMIC_COMMAND) {  dynamicCommands[process.env.DYNAMIC_COMMAND] = class extends Command {    static flags = {      flag1: Flags.boolean({description: 'flag1 description'}),    }    async run(): Promise<void> {      const {flags} = await this.parse(this.constructor as Command.Class)      this.log('hello from', this.id, flags)    }  }}export const COMMANDS = {  hello: Hello,  'hello:world': HelloWorld,  ...dynamicCommands,}
❯ DYNAMIC_COMMAND=foo:bar:baz bin/run.js foo bar baz --flag1hello from foo:bar:baz { flag1: true }
single Strategy​
The single strategy tells oclif that this CLI contains a single command that can be executed by the bin/run.js (e.g. ls or cat).
{  "oclif": {    "commands": {      "strategy": "single",      "target": "./dist/index.js"    }  }}
In this example, ./dist/index.js exports the command class.
Note about oclif.manifest.json​
For all strategies, the oclif.manifest.json will be used to load the commands instead of the default behavior of the strategy.Edit this pageLast updated on Dec 20, 2024 by Mike DonnalleyPreviousConfigNextTopicspattern Strategyexplicit Strategysingle StrategyNote about oclif.manifest.json\n\n\n\nAPI ReferenceCommand Discovery StrategiesOn this pageCommand Discovery StrategiesWhen oclif loads a plugin is must find all the commands within that plugin that can be executed. There a three strategies for discovering these commands:

pattern - this is the default behavior that finds commands based on glob patterns.
explicit - find commands that are exported from a specified file.
single - CLI contains a single command executed by top-level bin.

pattern Strategy​
The pattern strategy tells oclif to use a predefined set of globs to find command files in a specified directory. This is the default behavior of oclif unless otherwise stated.
Plugins can point the commands property to a directory
{  "oclif": {    "commands": "./dist/commands",  }}
This will tell oclif to look for commands in that directory (this is skipped if an oclif.manifest.json is present)
Alternatively, you can set this configuration which will do the exact same thing:
{  "oclif": {    "commands": {      "strategy": "pattern",      "target": "./dist/commands"    }  }}
You also have the ability to set globPatterns, which override the glob patterns that oclif uses when searching for command files:
{  "oclif": {    "commands": {      "strategy": "pattern",      "target": "./dist/commands",      "globPatterns": [         "**/*.+(js|cjs|mjs|ts|tsx|mts|cts)",        "!**/*.+(d.*|test.*|spec.*|helpers.*)?(x)"      ]    }  }}
This is useful if you like to put test or helper files in the same directory as your command files.
explicit Strategy​
The explicit strategy tells oclif to import commands from a single file. In this case the target is the file that exports the commands and identifier is the name of the export (defaults to default).
To use this you would add a new file (e.g. src/commands.ts) and then add this configuration to the package.json
{  "oclif": {    "commands": {      "strategy": "explicit",      "target": "./dist/index.js",      "identifier": "COMMANDS",    }  }}
src/index.ts would then need to have an export with the same name as the identifier (if not set, it defaults to default) that's an object of command names to command classes, e.g.
import Hello from './commands/hello'import HelloWorld from './commands/hello/world'export const COMMANDS = {  hello: Hello,  'hello:world': HelloWorld,  howdy: Hello, // alias the `hello` command to `howdy`}
The explicit strategy is useful to those who can't rely on file paths because they've bundled their code (see Bundling) but it can also be used if you simply prefer to be more explicit about your commands instead of relying on oclif "magically" finding commands from the file system.
It can also be leveraged to create or modify commands at runtime (e.g. internationalize messages at runtime or add flags to a command based on an API spec - see dynamic commands section below).
Hooks​
Hooks can also be defined using the explicit strategy:
"oclif": {    "hooks": {      "init": {        "target": "./dist/index.js",        "identifier": "INIT_HOOK"      }    }}
// src/index.tsimport Hello from './commands/hello'import HelloWorld from './commands/hello/world'export {default as INIT_HOOK} from './hooks/init/init.js'export const COMMANDS = {  hello: Hello,  'hello:world': HelloWorld,  howdy: Hello, // alias the `hello` command to `howdy`}
That configuration is essentially telling oclif to look for an INIT_HOOK export inside of ./dist/index.js
Bundling​
We do not support bundling given the endless number of tools + configurations that could be used. But if you choose to use a bundler, like esbuild, there are a couple hard requirements - you must have a package.json in your root directory and a bin/run or bin/run.js bin script. This means that you will not be able to successfully bundle your entire CLI (src code, package.json, node_modules, etc) into a single file.
If you still want to use a bundler, you can reference this example repo.
Dynamic Commands​
You can also use the explicit strategy if you want to manipulate or create commands at runtime. Please note that such usage of the explicit strategy cannot be used with an oclif.manifest.json, which will have significant performance implications for your CLI in production.
Example:
// src/index.tsimport {Command, Flags} from '@oclif/core'import Hello from './commands/hello'import HelloWorld from './commands/hello/world'const dynamicCommands: Record<string, Command.Class> = {}if (process.env.DYNAMIC_COMMAND) {  dynamicCommands[process.env.DYNAMIC_COMMAND] = class extends Command {    static flags = {      flag1: Flags.boolean({description: 'flag1 description'}),    }    async run(): Promise<void> {      const {flags} = await this.parse(this.constructor as Command.Class)      this.log('hello from', this.id, flags)    }  }}export const COMMANDS = {  hello: Hello,  'hello:world': HelloWorld,  ...dynamicCommands,}
❯ DYNAMIC_COMMAND=foo:bar:baz bin/run.js foo bar baz --flag1hello from foo:bar:baz { flag1: true }
single Strategy​
The single strategy tells oclif that this CLI contains a single command that can be executed by the bin/run.js (e.g. ls or cat).
{  "oclif": {    "commands": {      "strategy": "single",      "target": "./dist/index.js"    }  }}
In this example, ./dist/index.js exports the command class.
Note about oclif.manifest.json​
For all strategies, the oclif.manifest.json will be used to load the commands instead of the default behavior of the strategy.Edit this pageLast updated on Dec 20, 2024 by Mike Donnalley\n\nAPI ReferenceCommand Discovery StrategiesOn this pageCommand Discovery StrategiesWhen oclif loads a plugin is must find all the commands within that plugin that can be executed. There a three strategies for discovering these commands:

pattern - this is the default behavior that finds commands based on glob patterns.
explicit - find commands that are exported from a specified file.
single - CLI contains a single command executed by top-level bin.

pattern Strategy​
The pattern strategy tells oclif to use a predefined set of globs to find command files in a specified directory. This is the default behavior of oclif unless otherwise stated.
Plugins can point the commands property to a directory
{  "oclif": {    "commands": "./dist/commands",  }}
This will tell oclif to look for commands in that directory (this is skipped if an oclif.manifest.json is present)
Alternatively, you can set this configuration which will do the exact same thing:
{  "oclif": {    "commands": {      "strategy": "pattern",      "target": "./dist/commands"    }  }}
You also have the ability to set globPatterns, which override the glob patterns that oclif uses when searching for command files:
{  "oclif": {    "commands": {      "strategy": "pattern",      "target": "./dist/commands",      "globPatterns": [         "**/*.+(js|cjs|mjs|ts|tsx|mts|cts)",        "!**/*.+(d.*|test.*|spec.*|helpers.*)?(x)"      ]    }  }}
This is useful if you like to put test or helper files in the same directory as your command files.
explicit Strategy​
The explicit strategy tells oclif to import commands from a single file. In this case the target is the file that exports the commands and identifier is the name of the export (defaults to default).
To use this you would add a new file (e.g. src/commands.ts) and then add this configuration to the package.json
{  "oclif": {    "commands": {      "strategy": "explicit",      "target": "./dist/index.js",      "identifier": "COMMANDS",    }  }}
src/index.ts would then need to have an export with the same name as the identifier (if not set, it defaults to default) that's an object of command names to command classes, e.g.
import Hello from './commands/hello'import HelloWorld from './commands/hello/world'export const COMMANDS = {  hello: Hello,  'hello:world': HelloWorld,  howdy: Hello, // alias the `hello` command to `howdy`}
The explicit strategy is useful to those who can't rely on file paths because they've bundled their code (see Bundling) but it can also be used if you simply prefer to be more explicit about your commands instead of relying on oclif "magically" finding commands from the file system.
It can also be leveraged to create or modify commands at runtime (e.g. internationalize messages at runtime or add flags to a command based on an API spec - see dynamic commands section below).
Hooks​
Hooks can also be defined using the explicit strategy:
"oclif": {    "hooks": {      "init": {        "target": "./dist/index.js",        "identifier": "INIT_HOOK"      }    }}
// src/index.tsimport Hello from './commands/hello'import HelloWorld from './commands/hello/world'export {default as INIT_HOOK} from './hooks/init/init.js'export const COMMANDS = {  hello: Hello,  'hello:world': HelloWorld,  howdy: Hello, // alias the `hello` command to `howdy`}
That configuration is essentially telling oclif to look for an INIT_HOOK export inside of ./dist/index.js
Bundling​
We do not support bundling given the endless number of tools + configurations that could be used. But if you choose to use a bundler, like esbuild, there are a couple hard requirements - you must have a package.json in your root directory and a bin/run or bin/run.js bin script. This means that you will not be able to successfully bundle your entire CLI (src code, package.json, node_modules, etc) into a single file.
If you still want to use a bundler, you can reference this example repo.
Dynamic Commands​
You can also use the explicit strategy if you want to manipulate or create commands at runtime. Please note that such usage of the explicit strategy cannot be used with an oclif.manifest.json, which will have significant performance implications for your CLI in production.
Example:
// src/index.tsimport {Command, Flags} from '@oclif/core'import Hello from './commands/hello'import HelloWorld from './commands/hello/world'const dynamicCommands: Record<string, Command.Class> = {}if (process.env.DYNAMIC_COMMAND) {  dynamicCommands[process.env.DYNAMIC_COMMAND] = class extends Command {    static flags = {      flag1: Flags.boolean({description: 'flag1 description'}),    }    async run(): Promise<void> {      const {flags} = await this.parse(this.constructor as Command.Class)      this.log('hello from', this.id, flags)    }  }}export const COMMANDS = {  hello: Hello,  'hello:world': HelloWorld,  ...dynamicCommands,}
❯ DYNAMIC_COMMAND=foo:bar:baz bin/run.js foo bar baz --flag1hello from foo:bar:baz { flag1: true }
single Strategy​
The single strategy tells oclif that this CLI contains a single command that can be executed by the bin/run.js (e.g. ls or cat).
{  "oclif": {    "commands": {      "strategy": "single",      "target": "./dist/index.js"    }  }}
In this example, ./dist/index.js exports the command class.
Note about oclif.manifest.json​
For all strategies, the oclif.manifest.json will be used to load the commands instead of the default behavior of the strategy.Edit this pageLast updated on Dec 20, 2024 by Mike DonnalleyPreviousConfigNextTopicspattern Strategyexplicit Strategysingle StrategyNote about oclif.manifest.json\n\n\n\nAPI ReferenceCommand Discovery StrategiesOn this pageCommand Discovery StrategiesWhen oclif loads a plugin is must find all the commands within that plugin that can be executed. There a three strategies for discovering these commands:

pattern - this is the default behavior that finds commands based on glob patterns.
explicit - find commands that are exported from a specified file.
single - CLI contains a single command executed by top-level bin.

pattern Strategy​
The pattern strategy tells oclif to use a predefined set of globs to find command files in a specified directory. This is the default behavior of oclif unless otherwise stated.
Plugins can point the commands property to a directory
{  "oclif": {    "commands": "./dist/commands",  }}
This will tell oclif to look for commands in that directory (this is skipped if an oclif.manifest.json is present)
Alternatively, you can set this configuration which will do the exact same thing:
{  "oclif": {    "commands": {      "strategy": "pattern",      "target": "./dist/commands"    }  }}
You also have the ability to set globPatterns, which override the glob patterns that oclif uses when searching for command files:
{  "oclif": {    "commands": {      "strategy": "pattern",      "target": "./dist/commands",      "globPatterns": [         "**/*.+(js|cjs|mjs|ts|tsx|mts|cts)",        "!**/*.+(d.*|test.*|spec.*|helpers.*)?(x)"      ]    }  }}
This is useful if you like to put test or helper files in the same directory as your command files.
explicit Strategy​
The explicit strategy tells oclif to import commands from a single file. In this case the target is the file that exports the commands and identifier is the name of the export (defaults to default).
To use this you would add a new file (e.g. src/commands.ts) and then add this configuration to the package.json
{  "oclif": {    "commands": {      "strategy": "explicit",      "target": "./dist/index.js",      "identifier": "COMMANDS",    }  }}
src/index.ts would then need to have an export with the same name as the identifier (if not set, it defaults to default) that's an object of command names to command classes, e.g.
import Hello from './commands/hello'import HelloWorld from './commands/hello/world'export const COMMANDS = {  hello: Hello,  'hello:world': HelloWorld,  howdy: Hello, // alias the `hello` command to `howdy`}
The explicit strategy is useful to those who can't rely on file paths because they've bundled their code (see Bundling) but it can also be used if you simply prefer to be more explicit about your commands instead of relying on oclif "magically" finding commands from the file system.
It can also be leveraged to create or modify commands at runtime (e.g. internationalize messages at runtime or add flags to a command based on an API spec - see dynamic commands section below).
Hooks​
Hooks can also be defined using the explicit strategy:
"oclif": {    "hooks": {      "init": {        "target": "./dist/index.js",        "identifier": "INIT_HOOK"      }    }}
// src/index.tsimport Hello from './commands/hello'import HelloWorld from './commands/hello/world'export {default as INIT_HOOK} from './hooks/init/init.js'export const COMMANDS = {  hello: Hello,  'hello:world': HelloWorld,  howdy: Hello, // alias the `hello` command to `howdy`}
That configuration is essentially telling oclif to look for an INIT_HOOK export inside of ./dist/index.js
Bundling​
We do not support bundling given the endless number of tools + configurations that could be used. But if you choose to use a bundler, like esbuild, there are a couple hard requirements - you must have a package.json in your root directory and a bin/run or bin/run.js bin script. This means that you will not be able to successfully bundle your entire CLI (src code, package.json, node_modules, etc) into a single file.
If you still want to use a bundler, you can reference this example repo.
Dynamic Commands​
You can also use the explicit strategy if you want to manipulate or create commands at runtime. Please note that such usage of the explicit strategy cannot be used with an oclif.manifest.json, which will have significant performance implications for your CLI in production.
Example:
// src/index.tsimport {Command, Flags} from '@oclif/core'import Hello from './commands/hello'import HelloWorld from './commands/hello/world'const dynamicCommands: Record<string, Command.Class> = {}if (process.env.DYNAMIC_COMMAND) {  dynamicCommands[process.env.DYNAMIC_COMMAND] = class extends Command {    static flags = {      flag1: Flags.boolean({description: 'flag1 description'}),    }    async run(): Promise<void> {      const {flags} = await this.parse(this.constructor as Command.Class)      this.log('hello from', this.id, flags)    }  }}export const COMMANDS = {  hello: Hello,  'hello:world': HelloWorld,  ...dynamicCommands,}
❯ DYNAMIC_COMMAND=foo:bar:baz bin/run.js foo bar baz --flag1hello from foo:bar:baz { flag1: true }
single Strategy​
The single strategy tells oclif that this CLI contains a single command that can be executed by the bin/run.js (e.g. ls or cat).
{  "oclif": {    "commands": {      "strategy": "single",      "target": "./dist/index.js"    }  }}
In this example, ./dist/index.js exports the command class.
Note about oclif.manifest.json​
For all strategies, the oclif.manifest.json will be used to load the commands instead of the default behavior of the strategy.Edit this pageLast updated on Dec 20, 2024 by Mike Donnalley\n\nAPI ReferenceCommand Discovery StrategiesOn this pageCommand Discovery StrategiesWhen oclif loads a plugin is must find all the commands within that plugin that can be executed. There a three strategies for discovering these commands:

pattern - this is the default behavior that finds commands based on glob patterns.
explicit - find commands that are exported from a specified file.
single - CLI contains a single command executed by top-level bin.

pattern Strategy​
The pattern strategy tells oclif to use a predefined set of globs to find command files in a specified directory. This is the default behavior of oclif unless otherwise stated.
Plugins can point the commands property to a directory
{  "oclif": {    "commands": "./dist/commands",  }}
This will tell oclif to look for commands in that directory (this is skipped if an oclif.manifest.json is present)
Alternatively, you can set this configuration which will do the exact same thing:
{  "oclif": {    "commands": {      "strategy": "pattern",      "target": "./dist/commands"    }  }}
You also have the ability to set globPatterns, which override the glob patterns that oclif uses when searching for command files:
{  "oclif": {    "commands": {      "strategy": "pattern",      "target": "./dist/commands",      "globPatterns": [         "**/*.+(js|cjs|mjs|ts|tsx|mts|cts)",        "!**/*.+(d.*|test.*|spec.*|helpers.*)?(x)"      ]    }  }}
This is useful if you like to put test or helper files in the same directory as your command files.
explicit Strategy​
The explicit strategy tells oclif to import commands from a single file. In this case the target is the file that exports the commands and identifier is the name of the export (defaults to default).
To use this you would add a new file (e.g. src/commands.ts) and then add this configuration to the package.json
{  "oclif": {    "commands": {      "strategy": "explicit",      "target": "./dist/index.js",      "identifier": "COMMANDS",    }  }}
src/index.ts would then need to have an export with the same name as the identifier (if not set, it defaults to default) that's an object of command names to command classes, e.g.
import Hello from './commands/hello'import HelloWorld from './commands/hello/world'export const COMMANDS = {  hello: Hello,  'hello:world': HelloWorld,  howdy: Hello, // alias the `hello` command to `howdy`}
The explicit strategy is useful to those who can't rely on file paths because they've bundled their code (see Bundling) but it can also be used if you simply prefer to be more explicit about your commands instead of relying on oclif "magically" finding commands from the file system.
It can also be leveraged to create or modify commands at runtime (e.g. internationalize messages at runtime or add flags to a command based on an API spec - see dynamic commands section below).
Hooks​
Hooks can also be defined using the explicit strategy:
"oclif": {    "hooks": {      "init": {        "target": "./dist/index.js",        "identifier": "INIT_HOOK"      }    }}
// src/index.tsimport Hello from './commands/hello'import HelloWorld from './commands/hello/world'export {default as INIT_HOOK} from './hooks/init/init.js'export const COMMANDS = {  hello: Hello,  'hello:world': HelloWorld,  howdy: Hello, // alias the `hello` command to `howdy`}
That configuration is essentially telling oclif to look for an INIT_HOOK export inside of ./dist/index.js
Bundling​
We do not support bundling given the endless number of tools + configurations that could be used. But if you choose to use a bundler, like esbuild, there are a couple hard requirements - you must have a package.json in your root directory and a bin/run or bin/run.js bin script. This means that you will not be able to successfully bundle your entire CLI (src code, package.json, node_modules, etc) into a single file.
If you still want to use a bundler, you can reference this example repo.
Dynamic Commands​
You can also use the explicit strategy if you want to manipulate or create commands at runtime. Please note that such usage of the explicit strategy cannot be used with an oclif.manifest.json, which will have significant performance implications for your CLI in production.
Example:
// src/index.tsimport {Command, Flags} from '@oclif/core'import Hello from './commands/hello'import HelloWorld from './commands/hello/world'const dynamicCommands: Record<string, Command.Class> = {}if (process.env.DYNAMIC_COMMAND) {  dynamicCommands[process.env.DYNAMIC_COMMAND] = class extends Command {    static flags = {      flag1: Flags.boolean({description: 'flag1 description'}),    }    async run(): Promise<void> {      const {flags} = await this.parse(this.constructor as Command.Class)      this.log('hello from', this.id, flags)    }  }}export const COMMANDS = {  hello: Hello,  'hello:world': HelloWorld,  ...dynamicCommands,}
❯ DYNAMIC_COMMAND=foo:bar:baz bin/run.js foo bar baz --flag1hello from foo:bar:baz { flag1: true }
single Strategy​
The single strategy tells oclif that this CLI contains a single command that can be executed by the bin/run.js (e.g. ls or cat).
{  "oclif": {    "commands": {      "strategy": "single",      "target": "./dist/index.js"    }  }}
In this example, ./dist/index.js exports the command class.
Note about oclif.manifest.json​
For all strategies, the oclif.manifest.json will be used to load the commands instead of the default behavior of the strategy.Edit this pageLast updated on Dec 20, 2024 by Mike DonnalleyPreviousConfigNextTopicspattern Strategyexplicit Strategysingle StrategyNote about oclif.manifest.json\n\n\n\nAPI ReferenceTopicsTopicsAs CLIs grow it can be useful to nest commands within topics. This is supported simply by placing command files in subdirectories. For example, with the Salesforce CLI we have a topic sf config with commands like sf config set and sf config get. The directory structure looks like this:
package.jsonsrc/└── commands/    └── config/        ├── index.ts        ├── set.ts        └── get.ts
The help descriptions will be the description of the first command within a directory. If you'd like to customize the help description, add it to the package.json like so:
{  "oclif": {    "topics": {      "apps:favorites": { "description": "manage favorite apps" },      "config": { "description": "manage heroku config variables" },    }  }}
Subtopics can be created by making subdirectories within topic directories, but for UX reasons we generally discourage going more than 1 or 2 levels deep even for the largest CLIs.Edit this pageLast updated on Dec 20, 2024 by Mike Donnalley\n\nAPI ReferenceTopicsTopicsAs CLIs grow it can be useful to nest commands within topics. This is supported simply by placing command files in subdirectories. For example, with the Salesforce CLI we have a topic sf config with commands like sf config set and sf config get. The directory structure looks like this:
package.jsonsrc/└── commands/    └── config/        ├── index.ts        ├── set.ts        └── get.ts
The help descriptions will be the description of the first command within a directory. If you'd like to customize the help description, add it to the package.json like so:
{  "oclif": {    "topics": {      "apps:favorites": { "description": "manage favorite apps" },      "config": { "description": "manage heroku config variables" },    }  }}
Subtopics can be created by making subdirectories within topic directories, but for UX reasons we generally discourage going more than 1 or 2 levels deep even for the largest CLIs.Edit this pageLast updated on Dec 20, 2024 by Mike DonnalleyPreviousCommand Discovery StrategiesNextTopic Separators\n\n\n\nAPI ReferenceTopic SeparatorsTopic SeparatorsBy default, topics will be separated with colons, e.g. my:awesome:command. However, you have the option to use spaces if you prefer, e.g. my awesome command.
To do this, simply set the topicSeparator property in the oclif section of your package.json
{  "oclif": {    "topicSeparator": " "  }}
Currently colons (":") and spaces (" ") are the only supported topic separators.Edit this pageLast updated on Dec 20, 2024 by Mike Donnalley\n\nAPI ReferenceTopic SeparatorsTopic SeparatorsBy default, topics will be separated with colons, e.g. my:awesome:command. However, you have the option to use spaces if you prefer, e.g. my awesome command.
To do this, simply set the topicSeparator property in the oclif section of your package.json
{  "oclif": {    "topicSeparator": " "  }}
Currently colons (":") and spaces (" ") are the only supported topic separators.Edit this pageLast updated on Dec 20, 2024 by Mike DonnalleyPreviousTopicsNextHooks\n\n\n\nAPI ReferencePluginsOn this pagePluginsPlugins are a great way to offer experimental functionality, allow users to extend your CLI, break up a CLI into modular components, or share functionality between CLIs.
Plugins can have commands or hooks just like a CLI. To add a plugin such as the not-found plugin plugin, first add it to your CLI with yarn add @oclif/plugin-not-found, then add the following to your package.json:
{  "name": "mycli",  "version": "0.0.0",  // ...  "dependencies": {    "@oclif/core": "^3",    "@oclif/plugin-help": "^6",    "@oclif/plugin-not-found": "^3",  }  "oclif": {    "plugins": [      "@oclif/plugin-help",      "@oclif/plugin-not-found"    ]  }}
Plugins can also be specified using minimatch patterns:
{  "name": "mycli",  "version": "0.0.0",  // ...  "dependencies": {    "@oclif/core": "^3",    "@oclif/plugin-help": "^6",    "@oclif/plugin-not-found": "^3",  }  "oclif": {    "plugins": [      "@oclif/plugin-*",    ]  }}
If you want users to be able to install their own plugins into your CLI, use the plugins plugin.
Useful Plugins​

@oclif/plugin-not-found - Display a friendly "did you mean" message if a command is not found.
@oclif/plugin-plugins - Allow users to add plugins to extend your CLI.
@oclif/plugin-update - Add autoupdate support to the CLI.
@oclif/plugin-help - Help plugin for oclif.
@oclif/plugin-warn-if-update-available - Show a warning message if user is running an out of date CLI.
@oclif/plugin-which - Show which plugin a command comes from.
@oclif/plugin-commands - Add a commands command to list all the commands.
@oclif/plugin-autocomplete - Add bash/zsh autocomplete.
@oclif/plugin-search - Add search command to your CLI.
@oclif/plugin-version - Add version command to your CLI.

Building your own plugin​
Writing code for plugins is essentially the same as writing within a CLI. They can export 3 different types: commands, hooks, and other plugins.
Run npx oclif generate mynewplugin to create a plugin in a new directory. This will come with a sample commands called hello and hello world.Edit this pageLast updated on Dec 20, 2024 by Mike Donnalley\n\nAPI ReferencePluginsOn this pagePluginsPlugins are a great way to offer experimental functionality, allow users to extend your CLI, break up a CLI into modular components, or share functionality between CLIs.
Plugins can have commands or hooks just like a CLI. To add a plugin such as the not-found plugin plugin, first add it to your CLI with yarn add @oclif/plugin-not-found, then add the following to your package.json:
{  "name": "mycli",  "version": "0.0.0",  // ...  "dependencies": {    "@oclif/core": "^3",    "@oclif/plugin-help": "^6",    "@oclif/plugin-not-found": "^3",  }  "oclif": {    "plugins": [      "@oclif/plugin-help",      "@oclif/plugin-not-found"    ]  }}
Plugins can also be specified using minimatch patterns:
{  "name": "mycli",  "version": "0.0.0",  // ...  "dependencies": {    "@oclif/core": "^3",    "@oclif/plugin-help": "^6",    "@oclif/plugin-not-found": "^3",  }  "oclif": {    "plugins": [      "@oclif/plugin-*",    ]  }}
If you want users to be able to install their own plugins into your CLI, use the plugins plugin.
Useful Plugins​

@oclif/plugin-not-found - Display a friendly "did you mean" message if a command is not found.
@oclif/plugin-plugins - Allow users to add plugins to extend your CLI.
@oclif/plugin-update - Add autoupdate support to the CLI.
@oclif/plugin-help - Help plugin for oclif.
@oclif/plugin-warn-if-update-available - Show a warning message if user is running an out of date CLI.
@oclif/plugin-which - Show which plugin a command comes from.
@oclif/plugin-commands - Add a commands command to list all the commands.
@oclif/plugin-autocomplete - Add bash/zsh autocomplete.
@oclif/plugin-search - Add search command to your CLI.
@oclif/plugin-version - Add version command to your CLI.

Building your own plugin​
Writing code for plugins is essentially the same as writing within a CLI. They can export 3 different types: commands, hooks, and other plugins.
Run npx oclif generate mynewplugin to create a plugin in a new directory. This will come with a sample commands called hello and hello world.Edit this pageLast updated on Dec 20, 2024 by Mike DonnalleyPreviousHooksNextHelp ClassesUseful PluginsBuilding your own plugin\n\n\n\nAPI ReferencePluginsOn this pagePluginsPlugins are a great way to offer experimental functionality, allow users to extend your CLI, break up a CLI into modular components, or share functionality between CLIs.
Plugins can have commands or hooks just like a CLI. To add a plugin such as the not-found plugin plugin, first add it to your CLI with yarn add @oclif/plugin-not-found, then add the following to your package.json:
{  "name": "mycli",  "version": "0.0.0",  // ...  "dependencies": {    "@oclif/core": "^3",    "@oclif/plugin-help": "^6",    "@oclif/plugin-not-found": "^3",  }  "oclif": {    "plugins": [      "@oclif/plugin-help",      "@oclif/plugin-not-found"    ]  }}
Plugins can also be specified using minimatch patterns:
{  "name": "mycli",  "version": "0.0.0",  // ...  "dependencies": {    "@oclif/core": "^3",    "@oclif/plugin-help": "^6",    "@oclif/plugin-not-found": "^3",  }  "oclif": {    "plugins": [      "@oclif/plugin-*",    ]  }}
If you want users to be able to install their own plugins into your CLI, use the plugins plugin.
Useful Plugins​

@oclif/plugin-not-found - Display a friendly "did you mean" message if a command is not found.
@oclif/plugin-plugins - Allow users to add plugins to extend your CLI.
@oclif/plugin-update - Add autoupdate support to the CLI.
@oclif/plugin-help - Help plugin for oclif.
@oclif/plugin-warn-if-update-available - Show a warning message if user is running an out of date CLI.
@oclif/plugin-which - Show which plugin a command comes from.
@oclif/plugin-commands - Add a commands command to list all the commands.
@oclif/plugin-autocomplete - Add bash/zsh autocomplete.
@oclif/plugin-search - Add search command to your CLI.
@oclif/plugin-version - Add version command to your CLI.

Building your own plugin​
Writing code for plugins is essentially the same as writing within a CLI. They can export 3 different types: commands, hooks, and other plugins.
Run npx oclif generate mynewplugin to create a plugin in a new directory. This will come with a sample commands called hello and hello world.Edit this pageLast updated on Dec 20, 2024 by Mike Donnalley\n\nAPI ReferencePluginsOn this pagePluginsPlugins are a great way to offer experimental functionality, allow users to extend your CLI, break up a CLI into modular components, or share functionality between CLIs.
Plugins can have commands or hooks just like a CLI. To add a plugin such as the not-found plugin plugin, first add it to your CLI with yarn add @oclif/plugin-not-found, then add the following to your package.json:
{  "name": "mycli",  "version": "0.0.0",  // ...  "dependencies": {    "@oclif/core": "^3",    "@oclif/plugin-help": "^6",    "@oclif/plugin-not-found": "^3",  }  "oclif": {    "plugins": [      "@oclif/plugin-help",      "@oclif/plugin-not-found"    ]  }}
Plugins can also be specified using minimatch patterns:
{  "name": "mycli",  "version": "0.0.0",  // ...  "dependencies": {    "@oclif/core": "^3",    "@oclif/plugin-help": "^6",    "@oclif/plugin-not-found": "^3",  }  "oclif": {    "plugins": [      "@oclif/plugin-*",    ]  }}
If you want users to be able to install their own plugins into your CLI, use the plugins plugin.
Useful Plugins​

@oclif/plugin-not-found - Display a friendly "did you mean" message if a command is not found.
@oclif/plugin-plugins - Allow users to add plugins to extend your CLI.
@oclif/plugin-update - Add autoupdate support to the CLI.
@oclif/plugin-help - Help plugin for oclif.
@oclif/plugin-warn-if-update-available - Show a warning message if user is running an out of date CLI.
@oclif/plugin-which - Show which plugin a command comes from.
@oclif/plugin-commands - Add a commands command to list all the commands.
@oclif/plugin-autocomplete - Add bash/zsh autocomplete.
@oclif/plugin-search - Add search command to your CLI.
@oclif/plugin-version - Add version command to your CLI.

Building your own plugin​
Writing code for plugins is essentially the same as writing within a CLI. They can export 3 different types: commands, hooks, and other plugins.
Run npx oclif generate mynewplugin to create a plugin in a new directory. This will come with a sample commands called hello and hello world.Edit this pageLast updated on Dec 20, 2024 by Mike DonnalleyPreviousHooksNextHelp ClassesUseful PluginsBuilding your own plugin\n\n\n\nAPI ReferencePerformanceOn this pagePerformanceoclif supports performance tracking out of the box - both for oclif and you own code. You can enable it in one of two ways depending on how you've implemented your bin scripts.
If you're using the bin scripts that come from the generator, you can simply set performanceEnabled on the settings module:
How to Enable​
#!/usr/bin/env nodeimport {execute, settings} from '@oclif/core'settings.performanceEnabled = trueawait execute({dir: import.meta.url})
You can also enable it on the Config class directly if that works better for your CLI:
import {Config, run} from '@oclif/core'import {fileUrlToPath} from 'node:url'const config = await Config.load({  root: resolve(fileURLToPath(import.meta.url), '..');,  enablePerf: true})await run(config)
Accessing oclif-specific performance metrics​
Once performance is enabled, you can see the in the debug output under the oclif:perf scope.
❯ DEBUG=oclif:perf sf version@salesforce/cli/2.35.6 darwin-arm64 node-v20.11.0  oclif:perf Process Uptime: 747.6823ms +0ms  oclif:perf Oclif Time: 302.1286ms +0ms  oclif:perf Init Time: 37.7735ms +0ms  oclif:perf Config Load Time: 294.5321ms +0ms  oclif:perf   • Root Plugin Load Time: 11.2781ms +0ms  oclif:perf   • Plugins Load Time: 274.6006ms +0ms  oclif:perf   • Commands Load Time: 6.7736ms +0ms  oclif:perf Core Plugin Load Time: 20.9403ms +0ms  oclif:perf User Plugin Load Time: 0.0000ms +0ms  oclif:perf Linked Plugin Load Time: 2.3124ms +0ms  oclif:perf Plugin Load Times: +0ms  oclif:perf   oclif-hello-world: 239.1951ms (no manifest!) +0ms  oclif:perf   @oclif/plugin-update: 18.8549ms +0ms  oclif:perf   @oclif/plugin-autocomplete: 17.5277ms +0ms  oclif:perf   @oclif/plugin-commands: 16.4917ms +0ms  oclif:perf   @oclif/plugin-not-found: 16.3310ms +0ms  oclif:perf   @oclif/plugin-search: 15.8846ms +0ms  oclif:perf   @oclif/plugin-version: 14.8063ms +0ms  oclif:perf   @salesforce/plugin-org: 14.5657ms +0ms  oclif:perf   @salesforce/plugin-data: 14.3991ms +0ms  oclif:perf   @oclif/plugin-warn-if-update-available: 14.3733ms +0ms  oclif:perf   @oclif/plugin-which: 14.1629ms +0ms  oclif:perf   @salesforce/plugin-apex: 13.9885ms +0ms  oclif:perf   @salesforce/plugin-auth: 13.6895ms +0ms  oclif:perf   @salesforce/plugin-deploy-retrieve: 13.6353ms +0ms  oclif:perf   @salesforce/plugin-limits: 13.1123ms +0ms  oclif:perf   @salesforce/plugin-packaging: 12.9777ms +0ms  oclif:perf   @salesforce/plugin-info: 12.7787ms +0ms  oclif:perf   @salesforce/plugin-marketplace: 12.1542ms +0ms  oclif:perf   @salesforce/plugin-source: 11.9480ms +0ms  oclif:perf   @salesforce/plugin-schema: 11.7775ms +0ms  oclif:perf   @salesforce/plugin-settings: 11.4785ms +0ms  oclif:perf   @salesforce/plugin-templates: 11.4225ms +0ms  oclif:perf   @salesforce/plugin-sobject: 11.3670ms +0ms  oclif:perf   root: 11.2781ms +0ms  oclif:perf   @salesforce/plugin-user: 10.8521ms +0ms  oclif:perf   @salesforce/plugin-telemetry: 10.5724ms +1ms  oclif:perf   @salesforce/plugin-trust: 10.4463ms +0ms  oclif:perf   @oclif/plugin-plugins: 2.0135ms +0ms  oclif:perf   @oclif/plugin-help: 1.9039ms +0ms  oclif:perf Hook Run Times: +0ms  oclif:perf   init: +0ms  oclif:perf     total: 37.4624ms +0ms  oclif:perf     oclif-hello-world(./dist/hooks/init/init): 7.9818ms +0ms  oclif:perf     @oclif/plugin-warn-if-update-available(./lib/hooks/init/check-update): 37.1145ms +0ms  oclif:perf     @salesforce/plugin-settings(./lib/hooks/init/load_config_meta): 29.3073ms +0ms  oclif:perf     @oclif/plugin-update(./dist/hooks/init.js): 33.1767ms +0ms  oclif:perf   prerun: +0ms  oclif:perf     total: 260.5702ms +0ms  oclif:perf     @salesforce/cli(./dist/hooks/prerun): 2.3582ms +0ms  oclif:perf     @salesforce/plugin-telemetry(./lib/hooks/telemetryPrerun.js): 260.2634ms +0ms  oclif:perf   preparse: +0ms  oclif:perf     total: 0.5351ms +0ms  oclif:perf     @salesforce/cli(/dist/hooks/preparse): 0.5045ms +0ms  oclif:perf   postrun: +0ms  oclif:perf     total: 0.3507ms +0ms  oclif:perf Command Load Time: 0.7478ms +0ms  oclif:perf Command Run Time: 264.2587ms +0ms
You can also access these metrics programmatically like so:
const {Performance, flush, handle, run, settings} = await import('@oclif/core')settings.performanceEnabled = trueawait run(process.argv.slice(2))  .catch(async (error) => handle(error))  .finally(async () => {    console.log('Performance', Performance.oclifPerf)    await flush()  })
Using Performance for your code​
You can also use the Performance class to capture performance metrics on your own code base.
To capture performance metrics for a block of code, you need to create a new marker using Performance.mark. You then need to call the .stop method the marker to finish timing that block of code.
Here's a brief example:
import {Performance} from '@oclif/core'// Create a new marker.// First argument is the owner of the marker (This allows Performance to be able to distinguish the origin of each marker)// Second argument is the name of the maker. Naming convention that oclif uses internally is <module>.<method>#scope. You are free, however, to name these however you like.const marker = Performance.mark('my-plugin', 'hello.run')// do things that take a while.// Add details to the marker that you might want to access latermarker?.addDetails({from: flags.from, person: args.person})// Stop the marker. This will capture the amount of time between the creation of the marker and the stopping of the marker.marker?.stop()
And a more thorough example:
// ./src/commands/hello/index.tsimport {Args, Command, Flags, Performance} from '@oclif/core'export default class Hello extends Command {  static args = {    person: Args.string({description: 'Person to say hello to', required: true}),  }  static flags = {    from: Flags.string({char: 'f', description: 'Who is saying hello', required: true}),  }  async run(): Promise<void> {    const {args, flags} = await this.parse(Hello)    const marker = Performance.mark('my-plugin', 'hello.run')    await new Promise((resolve) => {      setTimeout(resolve, 1000)    })    marker?.addDetails({from: flags.from, person: args.person})    marker?.stop()    this.log(`hello ${args.person} from ${flags.from}! (./src/commands/hello/index.ts)`)  }}
All the markers you create will be accessible on the static results property on Performance:
// bin/run.jsconst {Performance, flush, handle, run, settings} = await import('@oclif/core')settings.performanceEnabled = trueawait run(process.argv.slice(2))  .catch(async (error) => handle(error))  .finally(async () => {    console.log('Results', Performance.results)    await flush()  })
❯ bin/run.js hello reader --from oclifhello reader from oclif! (./src/commands/hello/index.ts)Results Map(1) {  'my-plugin' => [    {      details: {        from: oclif,        person: reader      },      duration: 1003.4971249999999,      method: 'run',      module: 'hello',      name: 'hello.run',      scope: undefined    }  ]}Edit this pageLast updated on Dec 20, 2024 by Mike Donnalley\n\nAPI ReferencePerformanceOn this pagePerformanceoclif supports performance tracking out of the box - both for oclif and you own code. You can enable it in one of two ways depending on how you've implemented your bin scripts.
If you're using the bin scripts that come from the generator, you can simply set performanceEnabled on the settings module:
How to Enable​
#!/usr/bin/env nodeimport {execute, settings} from '@oclif/core'settings.performanceEnabled = trueawait execute({dir: import.meta.url})
You can also enable it on the Config class directly if that works better for your CLI:
import {Config, run} from '@oclif/core'import {fileUrlToPath} from 'node:url'const config = await Config.load({  root: resolve(fileURLToPath(import.meta.url), '..');,  enablePerf: true})await run(config)
Accessing oclif-specific performance metrics​
Once performance is enabled, you can see the in the debug output under the oclif:perf scope.
❯ DEBUG=oclif:perf sf version@salesforce/cli/2.35.6 darwin-arm64 node-v20.11.0  oclif:perf Process Uptime: 747.6823ms +0ms  oclif:perf Oclif Time: 302.1286ms +0ms  oclif:perf Init Time: 37.7735ms +0ms  oclif:perf Config Load Time: 294.5321ms +0ms  oclif:perf   • Root Plugin Load Time: 11.2781ms +0ms  oclif:perf   • Plugins Load Time: 274.6006ms +0ms  oclif:perf   • Commands Load Time: 6.7736ms +0ms  oclif:perf Core Plugin Load Time: 20.9403ms +0ms  oclif:perf User Plugin Load Time: 0.0000ms +0ms  oclif:perf Linked Plugin Load Time: 2.3124ms +0ms  oclif:perf Plugin Load Times: +0ms  oclif:perf   oclif-hello-world: 239.1951ms (no manifest!) +0ms  oclif:perf   @oclif/plugin-update: 18.8549ms +0ms  oclif:perf   @oclif/plugin-autocomplete: 17.5277ms +0ms  oclif:perf   @oclif/plugin-commands: 16.4917ms +0ms  oclif:perf   @oclif/plugin-not-found: 16.3310ms +0ms  oclif:perf   @oclif/plugin-search: 15.8846ms +0ms  oclif:perf   @oclif/plugin-version: 14.8063ms +0ms  oclif:perf   @salesforce/plugin-org: 14.5657ms +0ms  oclif:perf   @salesforce/plugin-data: 14.3991ms +0ms  oclif:perf   @oclif/plugin-warn-if-update-available: 14.3733ms +0ms  oclif:perf   @oclif/plugin-which: 14.1629ms +0ms  oclif:perf   @salesforce/plugin-apex: 13.9885ms +0ms  oclif:perf   @salesforce/plugin-auth: 13.6895ms +0ms  oclif:perf   @salesforce/plugin-deploy-retrieve: 13.6353ms +0ms  oclif:perf   @salesforce/plugin-limits: 13.1123ms +0ms  oclif:perf   @salesforce/plugin-packaging: 12.9777ms +0ms  oclif:perf   @salesforce/plugin-info: 12.7787ms +0ms  oclif:perf   @salesforce/plugin-marketplace: 12.1542ms +0ms  oclif:perf   @salesforce/plugin-source: 11.9480ms +0ms  oclif:perf   @salesforce/plugin-schema: 11.7775ms +0ms  oclif:perf   @salesforce/plugin-settings: 11.4785ms +0ms  oclif:perf   @salesforce/plugin-templates: 11.4225ms +0ms  oclif:perf   @salesforce/plugin-sobject: 11.3670ms +0ms  oclif:perf   root: 11.2781ms +0ms  oclif:perf   @salesforce/plugin-user: 10.8521ms +0ms  oclif:perf   @salesforce/plugin-telemetry: 10.5724ms +1ms  oclif:perf   @salesforce/plugin-trust: 10.4463ms +0ms  oclif:perf   @oclif/plugin-plugins: 2.0135ms +0ms  oclif:perf   @oclif/plugin-help: 1.9039ms +0ms  oclif:perf Hook Run Times: +0ms  oclif:perf   init: +0ms  oclif:perf     total: 37.4624ms +0ms  oclif:perf     oclif-hello-world(./dist/hooks/init/init): 7.9818ms +0ms  oclif:perf     @oclif/plugin-warn-if-update-available(./lib/hooks/init/check-update): 37.1145ms +0ms  oclif:perf     @salesforce/plugin-settings(./lib/hooks/init/load_config_meta): 29.3073ms +0ms  oclif:perf     @oclif/plugin-update(./dist/hooks/init.js): 33.1767ms +0ms  oclif:perf   prerun: +0ms  oclif:perf     total: 260.5702ms +0ms  oclif:perf     @salesforce/cli(./dist/hooks/prerun): 2.3582ms +0ms  oclif:perf     @salesforce/plugin-telemetry(./lib/hooks/telemetryPrerun.js): 260.2634ms +0ms  oclif:perf   preparse: +0ms  oclif:perf     total: 0.5351ms +0ms  oclif:perf     @salesforce/cli(/dist/hooks/preparse): 0.5045ms +0ms  oclif:perf   postrun: +0ms  oclif:perf     total: 0.3507ms +0ms  oclif:perf Command Load Time: 0.7478ms +0ms  oclif:perf Command Run Time: 264.2587ms +0ms
You can also access these metrics programmatically like so:
const {Performance, flush, handle, run, settings} = await import('@oclif/core')settings.performanceEnabled = trueawait run(process.argv.slice(2))  .catch(async (error) => handle(error))  .finally(async () => {    console.log('Performance', Performance.oclifPerf)    await flush()  })
Using Performance for your code​
You can also use the Performance class to capture performance metrics on your own code base.
To capture performance metrics for a block of code, you need to create a new marker using Performance.mark. You then need to call the .stop method the marker to finish timing that block of code.
Here's a brief example:
import {Performance} from '@oclif/core'// Create a new marker.// First argument is the owner of the marker (This allows Performance to be able to distinguish the origin of each marker)// Second argument is the name of the maker. Naming convention that oclif uses internally is <module>.<method>#scope. You are free, however, to name these however you like.const marker = Performance.mark('my-plugin', 'hello.run')// do things that take a while.// Add details to the marker that you might want to access latermarker?.addDetails({from: flags.from, person: args.person})// Stop the marker. This will capture the amount of time between the creation of the marker and the stopping of the marker.marker?.stop()
And a more thorough example:
// ./src/commands/hello/index.tsimport {Args, Command, Flags, Performance} from '@oclif/core'export default class Hello extends Command {  static args = {    person: Args.string({description: 'Person to say hello to', required: true}),  }  static flags = {    from: Flags.string({char: 'f', description: 'Who is saying hello', required: true}),  }  async run(): Promise<void> {    const {args, flags} = await this.parse(Hello)    const marker = Performance.mark('my-plugin', 'hello.run')    await new Promise((resolve) => {      setTimeout(resolve, 1000)    })    marker?.addDetails({from: flags.from, person: args.person})    marker?.stop()    this.log(`hello ${args.person} from ${flags.from}! (./src/commands/hello/index.ts)`)  }}
All the markers you create will be accessible on the static results property on Performance:
// bin/run.jsconst {Performance, flush, handle, run, settings} = await import('@oclif/core')settings.performanceEnabled = trueawait run(process.argv.slice(2))  .catch(async (error) => handle(error))  .finally(async () => {    console.log('Results', Performance.results)    await flush()  })
❯ bin/run.js hello reader --from oclifhello reader from oclif! (./src/commands/hello/index.ts)Results Map(1) {  'my-plugin' => [    {      details: {        from: oclif,        person: reader      },      duration: 1003.4971249999999,      method: 'run',      module: 'hello',      name: 'hello.run',      scope: undefined    }  ]}Edit this pageLast updated on Dec 20, 2024 by Mike DonnalleyPreviousHelp ClassesNextCommand ExecutionHow to EnableAccessing oclif-specific performance metricsUsing Performance for your code\n\n\n\nAPI ReferencePerformanceOn this pagePerformanceoclif supports performance tracking out of the box - both for oclif and you own code. You can enable it in one of two ways depending on how you've implemented your bin scripts.
If you're using the bin scripts that come from the generator, you can simply set performanceEnabled on the settings module:
How to Enable​
#!/usr/bin/env nodeimport {execute, settings} from '@oclif/core'settings.performanceEnabled = trueawait execute({dir: import.meta.url})
You can also enable it on the Config class directly if that works better for your CLI:
import {Config, run} from '@oclif/core'import {fileUrlToPath} from 'node:url'const config = await Config.load({  root: resolve(fileURLToPath(import.meta.url), '..');,  enablePerf: true})await run(config)
Accessing oclif-specific performance metrics​
Once performance is enabled, you can see the in the debug output under the oclif:perf scope.
❯ DEBUG=oclif:perf sf version@salesforce/cli/2.35.6 darwin-arm64 node-v20.11.0  oclif:perf Process Uptime: 747.6823ms +0ms  oclif:perf Oclif Time: 302.1286ms +0ms  oclif:perf Init Time: 37.7735ms +0ms  oclif:perf Config Load Time: 294.5321ms +0ms  oclif:perf   • Root Plugin Load Time: 11.2781ms +0ms  oclif:perf   • Plugins Load Time: 274.6006ms +0ms  oclif:perf   • Commands Load Time: 6.7736ms +0ms  oclif:perf Core Plugin Load Time: 20.9403ms +0ms  oclif:perf User Plugin Load Time: 0.0000ms +0ms  oclif:perf Linked Plugin Load Time: 2.3124ms +0ms  oclif:perf Plugin Load Times: +0ms  oclif:perf   oclif-hello-world: 239.1951ms (no manifest!) +0ms  oclif:perf   @oclif/plugin-update: 18.8549ms +0ms  oclif:perf   @oclif/plugin-autocomplete: 17.5277ms +0ms  oclif:perf   @oclif/plugin-commands: 16.4917ms +0ms  oclif:perf   @oclif/plugin-not-found: 16.3310ms +0ms  oclif:perf   @oclif/plugin-search: 15.8846ms +0ms  oclif:perf   @oclif/plugin-version: 14.8063ms +0ms  oclif:perf   @salesforce/plugin-org: 14.5657ms +0ms  oclif:perf   @salesforce/plugin-data: 14.3991ms +0ms  oclif:perf   @oclif/plugin-warn-if-update-available: 14.3733ms +0ms  oclif:perf   @oclif/plugin-which: 14.1629ms +0ms  oclif:perf   @salesforce/plugin-apex: 13.9885ms +0ms  oclif:perf   @salesforce/plugin-auth: 13.6895ms +0ms  oclif:perf   @salesforce/plugin-deploy-retrieve: 13.6353ms +0ms  oclif:perf   @salesforce/plugin-limits: 13.1123ms +0ms  oclif:perf   @salesforce/plugin-packaging: 12.9777ms +0ms  oclif:perf   @salesforce/plugin-info: 12.7787ms +0ms  oclif:perf   @salesforce/plugin-marketplace: 12.1542ms +0ms  oclif:perf   @salesforce/plugin-source: 11.9480ms +0ms  oclif:perf   @salesforce/plugin-schema: 11.7775ms +0ms  oclif:perf   @salesforce/plugin-settings: 11.4785ms +0ms  oclif:perf   @salesforce/plugin-templates: 11.4225ms +0ms  oclif:perf   @salesforce/plugin-sobject: 11.3670ms +0ms  oclif:perf   root: 11.2781ms +0ms  oclif:perf   @salesforce/plugin-user: 10.8521ms +0ms  oclif:perf   @salesforce/plugin-telemetry: 10.5724ms +1ms  oclif:perf   @salesforce/plugin-trust: 10.4463ms +0ms  oclif:perf   @oclif/plugin-plugins: 2.0135ms +0ms  oclif:perf   @oclif/plugin-help: 1.9039ms +0ms  oclif:perf Hook Run Times: +0ms  oclif:perf   init: +0ms  oclif:perf     total: 37.4624ms +0ms  oclif:perf     oclif-hello-world(./dist/hooks/init/init): 7.9818ms +0ms  oclif:perf     @oclif/plugin-warn-if-update-available(./lib/hooks/init/check-update): 37.1145ms +0ms  oclif:perf     @salesforce/plugin-settings(./lib/hooks/init/load_config_meta): 29.3073ms +0ms  oclif:perf     @oclif/plugin-update(./dist/hooks/init.js): 33.1767ms +0ms  oclif:perf   prerun: +0ms  oclif:perf     total: 260.5702ms +0ms  oclif:perf     @salesforce/cli(./dist/hooks/prerun): 2.3582ms +0ms  oclif:perf     @salesforce/plugin-telemetry(./lib/hooks/telemetryPrerun.js): 260.2634ms +0ms  oclif:perf   preparse: +0ms  oclif:perf     total: 0.5351ms +0ms  oclif:perf     @salesforce/cli(/dist/hooks/preparse): 0.5045ms +0ms  oclif:perf   postrun: +0ms  oclif:perf     total: 0.3507ms +0ms  oclif:perf Command Load Time: 0.7478ms +0ms  oclif:perf Command Run Time: 264.2587ms +0ms
You can also access these metrics programmatically like so:
const {Performance, flush, handle, run, settings} = await import('@oclif/core')settings.performanceEnabled = trueawait run(process.argv.slice(2))  .catch(async (error) => handle(error))  .finally(async () => {    console.log('Performance', Performance.oclifPerf)    await flush()  })
Using Performance for your code​
You can also use the Performance class to capture performance metrics on your own code base.
To capture performance metrics for a block of code, you need to create a new marker using Performance.mark. You then need to call the .stop method the marker to finish timing that block of code.
Here's a brief example:
import {Performance} from '@oclif/core'// Create a new marker.// First argument is the owner of the marker (This allows Performance to be able to distinguish the origin of each marker)// Second argument is the name of the maker. Naming convention that oclif uses internally is <module>.<method>#scope. You are free, however, to name these however you like.const marker = Performance.mark('my-plugin', 'hello.run')// do things that take a while.// Add details to the marker that you might want to access latermarker?.addDetails({from: flags.from, person: args.person})// Stop the marker. This will capture the amount of time between the creation of the marker and the stopping of the marker.marker?.stop()
And a more thorough example:
// ./src/commands/hello/index.tsimport {Args, Command, Flags, Performance} from '@oclif/core'export default class Hello extends Command {  static args = {    person: Args.string({description: 'Person to say hello to', required: true}),  }  static flags = {    from: Flags.string({char: 'f', description: 'Who is saying hello', required: true}),  }  async run(): Promise<void> {    const {args, flags} = await this.parse(Hello)    const marker = Performance.mark('my-plugin', 'hello.run')    await new Promise((resolve) => {      setTimeout(resolve, 1000)    })    marker?.addDetails({from: flags.from, person: args.person})    marker?.stop()    this.log(`hello ${args.person} from ${flags.from}! (./src/commands/hello/index.ts)`)  }}
All the markers you create will be accessible on the static results property on Performance:
// bin/run.jsconst {Performance, flush, handle, run, settings} = await import('@oclif/core')settings.performanceEnabled = trueawait run(process.argv.slice(2))  .catch(async (error) => handle(error))  .finally(async () => {    console.log('Results', Performance.results)    await flush()  })
❯ bin/run.js hello reader --from oclifhello reader from oclif! (./src/commands/hello/index.ts)Results Map(1) {  'my-plugin' => [    {      details: {        from: oclif,        person: reader      },      duration: 1003.4971249999999,      method: 'run',      module: 'hello',      name: 'hello.run',      scope: undefined    }  ]}Edit this pageLast updated on Dec 20, 2024 by Mike Donnalley\n\nAPI ReferencePerformanceOn this pagePerformanceoclif supports performance tracking out of the box - both for oclif and you own code. You can enable it in one of two ways depending on how you've implemented your bin scripts.
If you're using the bin scripts that come from the generator, you can simply set performanceEnabled on the settings module:
How to Enable​
#!/usr/bin/env nodeimport {execute, settings} from '@oclif/core'settings.performanceEnabled = trueawait execute({dir: import.meta.url})
You can also enable it on the Config class directly if that works better for your CLI:
import {Config, run} from '@oclif/core'import {fileUrlToPath} from 'node:url'const config = await Config.load({  root: resolve(fileURLToPath(import.meta.url), '..');,  enablePerf: true})await run(config)
Accessing oclif-specific performance metrics​
Once performance is enabled, you can see the in the debug output under the oclif:perf scope.
❯ DEBUG=oclif:perf sf version@salesforce/cli/2.35.6 darwin-arm64 node-v20.11.0  oclif:perf Process Uptime: 747.6823ms +0ms  oclif:perf Oclif Time: 302.1286ms +0ms  oclif:perf Init Time: 37.7735ms +0ms  oclif:perf Config Load Time: 294.5321ms +0ms  oclif:perf   • Root Plugin Load Time: 11.2781ms +0ms  oclif:perf   • Plugins Load Time: 274.6006ms +0ms  oclif:perf   • Commands Load Time: 6.7736ms +0ms  oclif:perf Core Plugin Load Time: 20.9403ms +0ms  oclif:perf User Plugin Load Time: 0.0000ms +0ms  oclif:perf Linked Plugin Load Time: 2.3124ms +0ms  oclif:perf Plugin Load Times: +0ms  oclif:perf   oclif-hello-world: 239.1951ms (no manifest!) +0ms  oclif:perf   @oclif/plugin-update: 18.8549ms +0ms  oclif:perf   @oclif/plugin-autocomplete: 17.5277ms +0ms  oclif:perf   @oclif/plugin-commands: 16.4917ms +0ms  oclif:perf   @oclif/plugin-not-found: 16.3310ms +0ms  oclif:perf   @oclif/plugin-search: 15.8846ms +0ms  oclif:perf   @oclif/plugin-version: 14.8063ms +0ms  oclif:perf   @salesforce/plugin-org: 14.5657ms +0ms  oclif:perf   @salesforce/plugin-data: 14.3991ms +0ms  oclif:perf   @oclif/plugin-warn-if-update-available: 14.3733ms +0ms  oclif:perf   @oclif/plugin-which: 14.1629ms +0ms  oclif:perf   @salesforce/plugin-apex: 13.9885ms +0ms  oclif:perf   @salesforce/plugin-auth: 13.6895ms +0ms  oclif:perf   @salesforce/plugin-deploy-retrieve: 13.6353ms +0ms  oclif:perf   @salesforce/plugin-limits: 13.1123ms +0ms  oclif:perf   @salesforce/plugin-packaging: 12.9777ms +0ms  oclif:perf   @salesforce/plugin-info: 12.7787ms +0ms  oclif:perf   @salesforce/plugin-marketplace: 12.1542ms +0ms  oclif:perf   @salesforce/plugin-source: 11.9480ms +0ms  oclif:perf   @salesforce/plugin-schema: 11.7775ms +0ms  oclif:perf   @salesforce/plugin-settings: 11.4785ms +0ms  oclif:perf   @salesforce/plugin-templates: 11.4225ms +0ms  oclif:perf   @salesforce/plugin-sobject: 11.3670ms +0ms  oclif:perf   root: 11.2781ms +0ms  oclif:perf   @salesforce/plugin-user: 10.8521ms +0ms  oclif:perf   @salesforce/plugin-telemetry: 10.5724ms +1ms  oclif:perf   @salesforce/plugin-trust: 10.4463ms +0ms  oclif:perf   @oclif/plugin-plugins: 2.0135ms +0ms  oclif:perf   @oclif/plugin-help: 1.9039ms +0ms  oclif:perf Hook Run Times: +0ms  oclif:perf   init: +0ms  oclif:perf     total: 37.4624ms +0ms  oclif:perf     oclif-hello-world(./dist/hooks/init/init): 7.9818ms +0ms  oclif:perf     @oclif/plugin-warn-if-update-available(./lib/hooks/init/check-update): 37.1145ms +0ms  oclif:perf     @salesforce/plugin-settings(./lib/hooks/init/load_config_meta): 29.3073ms +0ms  oclif:perf     @oclif/plugin-update(./dist/hooks/init.js): 33.1767ms +0ms  oclif:perf   prerun: +0ms  oclif:perf     total: 260.5702ms +0ms  oclif:perf     @salesforce/cli(./dist/hooks/prerun): 2.3582ms +0ms  oclif:perf     @salesforce/plugin-telemetry(./lib/hooks/telemetryPrerun.js): 260.2634ms +0ms  oclif:perf   preparse: +0ms  oclif:perf     total: 0.5351ms +0ms  oclif:perf     @salesforce/cli(/dist/hooks/preparse): 0.5045ms +0ms  oclif:perf   postrun: +0ms  oclif:perf     total: 0.3507ms +0ms  oclif:perf Command Load Time: 0.7478ms +0ms  oclif:perf Command Run Time: 264.2587ms +0ms
You can also access these metrics programmatically like so:
const {Performance, flush, handle, run, settings} = await import('@oclif/core')settings.performanceEnabled = trueawait run(process.argv.slice(2))  .catch(async (error) => handle(error))  .finally(async () => {    console.log('Performance', Performance.oclifPerf)    await flush()  })
Using Performance for your code​
You can also use the Performance class to capture performance metrics on your own code base.
To capture performance metrics for a block of code, you need to create a new marker using Performance.mark. You then need to call the .stop method the marker to finish timing that block of code.
Here's a brief example:
import {Performance} from '@oclif/core'// Create a new marker.// First argument is the owner of the marker (This allows Performance to be able to distinguish the origin of each marker)// Second argument is the name of the maker. Naming convention that oclif uses internally is <module>.<method>#scope. You are free, however, to name these however you like.const marker = Performance.mark('my-plugin', 'hello.run')// do things that take a while.// Add details to the marker that you might want to access latermarker?.addDetails({from: flags.from, person: args.person})// Stop the marker. This will capture the amount of time between the creation of the marker and the stopping of the marker.marker?.stop()
And a more thorough example:
// ./src/commands/hello/index.tsimport {Args, Command, Flags, Performance} from '@oclif/core'export default class Hello extends Command {  static args = {    person: Args.string({description: 'Person to say hello to', required: true}),  }  static flags = {    from: Flags.string({char: 'f', description: 'Who is saying hello', required: true}),  }  async run(): Promise<void> {    const {args, flags} = await this.parse(Hello)    const marker = Performance.mark('my-plugin', 'hello.run')    await new Promise((resolve) => {      setTimeout(resolve, 1000)    })    marker?.addDetails({from: flags.from, person: args.person})    marker?.stop()    this.log(`hello ${args.person} from ${flags.from}! (./src/commands/hello/index.ts)`)  }}
All the markers you create will be accessible on the static results property on Performance:
// bin/run.jsconst {Performance, flush, handle, run, settings} = await import('@oclif/core')settings.performanceEnabled = trueawait run(process.argv.slice(2))  .catch(async (error) => handle(error))  .finally(async () => {    console.log('Results', Performance.results)    await flush()  })
❯ bin/run.js hello reader --from oclifhello reader from oclif! (./src/commands/hello/index.ts)Results Map(1) {  'my-plugin' => [    {      details: {        from: oclif,        person: reader      },      duration: 1003.4971249999999,      method: 'run',      module: 'hello',      name: 'hello.run',      scope: undefined    }  ]}Edit this pageLast updated on Dec 20, 2024 by Mike DonnalleyPreviousHelp ClassesNextCommand ExecutionHow to EnableAccessing oclif-specific performance metricsUsing Performance for your code\n\n\n\nAPI ReferencePerformanceOn this pagePerformanceoclif supports performance tracking out of the box - both for oclif and you own code. You can enable it in one of two ways depending on how you've implemented your bin scripts.
If you're using the bin scripts that come from the generator, you can simply set performanceEnabled on the settings module:
How to Enable​
#!/usr/bin/env nodeimport {execute, settings} from '@oclif/core'settings.performanceEnabled = trueawait execute({dir: import.meta.url})
You can also enable it on the Config class directly if that works better for your CLI:
import {Config, run} from '@oclif/core'import {fileUrlToPath} from 'node:url'const config = await Config.load({  root: resolve(fileURLToPath(import.meta.url), '..');,  enablePerf: true})await run(config)
Accessing oclif-specific performance metrics​
Once performance is enabled, you can see the in the debug output under the oclif:perf scope.
❯ DEBUG=oclif:perf sf version@salesforce/cli/2.35.6 darwin-arm64 node-v20.11.0  oclif:perf Process Uptime: 747.6823ms +0ms  oclif:perf Oclif Time: 302.1286ms +0ms  oclif:perf Init Time: 37.7735ms +0ms  oclif:perf Config Load Time: 294.5321ms +0ms  oclif:perf   • Root Plugin Load Time: 11.2781ms +0ms  oclif:perf   • Plugins Load Time: 274.6006ms +0ms  oclif:perf   • Commands Load Time: 6.7736ms +0ms  oclif:perf Core Plugin Load Time: 20.9403ms +0ms  oclif:perf User Plugin Load Time: 0.0000ms +0ms  oclif:perf Linked Plugin Load Time: 2.3124ms +0ms  oclif:perf Plugin Load Times: +0ms  oclif:perf   oclif-hello-world: 239.1951ms (no manifest!) +0ms  oclif:perf   @oclif/plugin-update: 18.8549ms +0ms  oclif:perf   @oclif/plugin-autocomplete: 17.5277ms +0ms  oclif:perf   @oclif/plugin-commands: 16.4917ms +0ms  oclif:perf   @oclif/plugin-not-found: 16.3310ms +0ms  oclif:perf   @oclif/plugin-search: 15.8846ms +0ms  oclif:perf   @oclif/plugin-version: 14.8063ms +0ms  oclif:perf   @salesforce/plugin-org: 14.5657ms +0ms  oclif:perf   @salesforce/plugin-data: 14.3991ms +0ms  oclif:perf   @oclif/plugin-warn-if-update-available: 14.3733ms +0ms  oclif:perf   @oclif/plugin-which: 14.1629ms +0ms  oclif:perf   @salesforce/plugin-apex: 13.9885ms +0ms  oclif:perf   @salesforce/plugin-auth: 13.6895ms +0ms  oclif:perf   @salesforce/plugin-deploy-retrieve: 13.6353ms +0ms  oclif:perf   @salesforce/plugin-limits: 13.1123ms +0ms  oclif:perf   @salesforce/plugin-packaging: 12.9777ms +0ms  oclif:perf   @salesforce/plugin-info: 12.7787ms +0ms  oclif:perf   @salesforce/plugin-marketplace: 12.1542ms +0ms  oclif:perf   @salesforce/plugin-source: 11.9480ms +0ms  oclif:perf   @salesforce/plugin-schema: 11.7775ms +0ms  oclif:perf   @salesforce/plugin-settings: 11.4785ms +0ms  oclif:perf   @salesforce/plugin-templates: 11.4225ms +0ms  oclif:perf   @salesforce/plugin-sobject: 11.3670ms +0ms  oclif:perf   root: 11.2781ms +0ms  oclif:perf   @salesforce/plugin-user: 10.8521ms +0ms  oclif:perf   @salesforce/plugin-telemetry: 10.5724ms +1ms  oclif:perf   @salesforce/plugin-trust: 10.4463ms +0ms  oclif:perf   @oclif/plugin-plugins: 2.0135ms +0ms  oclif:perf   @oclif/plugin-help: 1.9039ms +0ms  oclif:perf Hook Run Times: +0ms  oclif:perf   init: +0ms  oclif:perf     total: 37.4624ms +0ms  oclif:perf     oclif-hello-world(./dist/hooks/init/init): 7.9818ms +0ms  oclif:perf     @oclif/plugin-warn-if-update-available(./lib/hooks/init/check-update): 37.1145ms +0ms  oclif:perf     @salesforce/plugin-settings(./lib/hooks/init/load_config_meta): 29.3073ms +0ms  oclif:perf     @oclif/plugin-update(./dist/hooks/init.js): 33.1767ms +0ms  oclif:perf   prerun: +0ms  oclif:perf     total: 260.5702ms +0ms  oclif:perf     @salesforce/cli(./dist/hooks/prerun): 2.3582ms +0ms  oclif:perf     @salesforce/plugin-telemetry(./lib/hooks/telemetryPrerun.js): 260.2634ms +0ms  oclif:perf   preparse: +0ms  oclif:perf     total: 0.5351ms +0ms  oclif:perf     @salesforce/cli(/dist/hooks/preparse): 0.5045ms +0ms  oclif:perf   postrun: +0ms  oclif:perf     total: 0.3507ms +0ms  oclif:perf Command Load Time: 0.7478ms +0ms  oclif:perf Command Run Time: 264.2587ms +0ms
You can also access these metrics programmatically like so:
const {Performance, flush, handle, run, settings} = await import('@oclif/core')settings.performanceEnabled = trueawait run(process.argv.slice(2))  .catch(async (error) => handle(error))  .finally(async () => {    console.log('Performance', Performance.oclifPerf)    await flush()  })
Using Performance for your code​
You can also use the Performance class to capture performance metrics on your own code base.
To capture performance metrics for a block of code, you need to create a new marker using Performance.mark. You then need to call the .stop method the marker to finish timing that block of code.
Here's a brief example:
import {Performance} from '@oclif/core'// Create a new marker.// First argument is the owner of the marker (This allows Performance to be able to distinguish the origin of each marker)// Second argument is the name of the maker. Naming convention that oclif uses internally is <module>.<method>#scope. You are free, however, to name these however you like.const marker = Performance.mark('my-plugin', 'hello.run')// do things that take a while.// Add details to the marker that you might want to access latermarker?.addDetails({from: flags.from, person: args.person})// Stop the marker. This will capture the amount of time between the creation of the marker and the stopping of the marker.marker?.stop()
And a more thorough example:
// ./src/commands/hello/index.tsimport {Args, Command, Flags, Performance} from '@oclif/core'export default class Hello extends Command {  static args = {    person: Args.string({description: 'Person to say hello to', required: true}),  }  static flags = {    from: Flags.string({char: 'f', description: 'Who is saying hello', required: true}),  }  async run(): Promise<void> {    const {args, flags} = await this.parse(Hello)    const marker = Performance.mark('my-plugin', 'hello.run')    await new Promise((resolve) => {      setTimeout(resolve, 1000)    })    marker?.addDetails({from: flags.from, person: args.person})    marker?.stop()    this.log(`hello ${args.person} from ${flags.from}! (./src/commands/hello/index.ts)`)  }}
All the markers you create will be accessible on the static results property on Performance:
// bin/run.jsconst {Performance, flush, handle, run, settings} = await import('@oclif/core')settings.performanceEnabled = trueawait run(process.argv.slice(2))  .catch(async (error) => handle(error))  .finally(async () => {    console.log('Results', Performance.results)    await flush()  })
❯ bin/run.js hello reader --from oclifhello reader from oclif! (./src/commands/hello/index.ts)Results Map(1) {  'my-plugin' => [    {      details: {        from: oclif,        person: reader      },      duration: 1003.4971249999999,      method: 'run',      module: 'hello',      name: 'hello.run',      scope: undefined    }  ]}Edit this pageLast updated on Dec 20, 2024 by Mike Donnalley\n\nAPI ReferencePerformanceOn this pagePerformanceoclif supports performance tracking out of the box - both for oclif and you own code. You can enable it in one of two ways depending on how you've implemented your bin scripts.
If you're using the bin scripts that come from the generator, you can simply set performanceEnabled on the settings module:
How to Enable​
#!/usr/bin/env nodeimport {execute, settings} from '@oclif/core'settings.performanceEnabled = trueawait execute({dir: import.meta.url})
You can also enable it on the Config class directly if that works better for your CLI:
import {Config, run} from '@oclif/core'import {fileUrlToPath} from 'node:url'const config = await Config.load({  root: resolve(fileURLToPath(import.meta.url), '..');,  enablePerf: true})await run(config)
Accessing oclif-specific performance metrics​
Once performance is enabled, you can see the in the debug output under the oclif:perf scope.
❯ DEBUG=oclif:perf sf version@salesforce/cli/2.35.6 darwin-arm64 node-v20.11.0  oclif:perf Process Uptime: 747.6823ms +0ms  oclif:perf Oclif Time: 302.1286ms +0ms  oclif:perf Init Time: 37.7735ms +0ms  oclif:perf Config Load Time: 294.5321ms +0ms  oclif:perf   • Root Plugin Load Time: 11.2781ms +0ms  oclif:perf   • Plugins Load Time: 274.6006ms +0ms  oclif:perf   • Commands Load Time: 6.7736ms +0ms  oclif:perf Core Plugin Load Time: 20.9403ms +0ms  oclif:perf User Plugin Load Time: 0.0000ms +0ms  oclif:perf Linked Plugin Load Time: 2.3124ms +0ms  oclif:perf Plugin Load Times: +0ms  oclif:perf   oclif-hello-world: 239.1951ms (no manifest!) +0ms  oclif:perf   @oclif/plugin-update: 18.8549ms +0ms  oclif:perf   @oclif/plugin-autocomplete: 17.5277ms +0ms  oclif:perf   @oclif/plugin-commands: 16.4917ms +0ms  oclif:perf   @oclif/plugin-not-found: 16.3310ms +0ms  oclif:perf   @oclif/plugin-search: 15.8846ms +0ms  oclif:perf   @oclif/plugin-version: 14.8063ms +0ms  oclif:perf   @salesforce/plugin-org: 14.5657ms +0ms  oclif:perf   @salesforce/plugin-data: 14.3991ms +0ms  oclif:perf   @oclif/plugin-warn-if-update-available: 14.3733ms +0ms  oclif:perf   @oclif/plugin-which: 14.1629ms +0ms  oclif:perf   @salesforce/plugin-apex: 13.9885ms +0ms  oclif:perf   @salesforce/plugin-auth: 13.6895ms +0ms  oclif:perf   @salesforce/plugin-deploy-retrieve: 13.6353ms +0ms  oclif:perf   @salesforce/plugin-limits: 13.1123ms +0ms  oclif:perf   @salesforce/plugin-packaging: 12.9777ms +0ms  oclif:perf   @salesforce/plugin-info: 12.7787ms +0ms  oclif:perf   @salesforce/plugin-marketplace: 12.1542ms +0ms  oclif:perf   @salesforce/plugin-source: 11.9480ms +0ms  oclif:perf   @salesforce/plugin-schema: 11.7775ms +0ms  oclif:perf   @salesforce/plugin-settings: 11.4785ms +0ms  oclif:perf   @salesforce/plugin-templates: 11.4225ms +0ms  oclif:perf   @salesforce/plugin-sobject: 11.3670ms +0ms  oclif:perf   root: 11.2781ms +0ms  oclif:perf   @salesforce/plugin-user: 10.8521ms +0ms  oclif:perf   @salesforce/plugin-telemetry: 10.5724ms +1ms  oclif:perf   @salesforce/plugin-trust: 10.4463ms +0ms  oclif:perf   @oclif/plugin-plugins: 2.0135ms +0ms  oclif:perf   @oclif/plugin-help: 1.9039ms +0ms  oclif:perf Hook Run Times: +0ms  oclif:perf   init: +0ms  oclif:perf     total: 37.4624ms +0ms  oclif:perf     oclif-hello-world(./dist/hooks/init/init): 7.9818ms +0ms  oclif:perf     @oclif/plugin-warn-if-update-available(./lib/hooks/init/check-update): 37.1145ms +0ms  oclif:perf     @salesforce/plugin-settings(./lib/hooks/init/load_config_meta): 29.3073ms +0ms  oclif:perf     @oclif/plugin-update(./dist/hooks/init.js): 33.1767ms +0ms  oclif:perf   prerun: +0ms  oclif:perf     total: 260.5702ms +0ms  oclif:perf     @salesforce/cli(./dist/hooks/prerun): 2.3582ms +0ms  oclif:perf     @salesforce/plugin-telemetry(./lib/hooks/telemetryPrerun.js): 260.2634ms +0ms  oclif:perf   preparse: +0ms  oclif:perf     total: 0.5351ms +0ms  oclif:perf     @salesforce/cli(/dist/hooks/preparse): 0.5045ms +0ms  oclif:perf   postrun: +0ms  oclif:perf     total: 0.3507ms +0ms  oclif:perf Command Load Time: 0.7478ms +0ms  oclif:perf Command Run Time: 264.2587ms +0ms
You can also access these metrics programmatically like so:
const {Performance, flush, handle, run, settings} = await import('@oclif/core')settings.performanceEnabled = trueawait run(process.argv.slice(2))  .catch(async (error) => handle(error))  .finally(async () => {    console.log('Performance', Performance.oclifPerf)    await flush()  })
Using Performance for your code​
You can also use the Performance class to capture performance metrics on your own code base.
To capture performance metrics for a block of code, you need to create a new marker using Performance.mark. You then need to call the .stop method the marker to finish timing that block of code.
Here's a brief example:
import {Performance} from '@oclif/core'// Create a new marker.// First argument is the owner of the marker (This allows Performance to be able to distinguish the origin of each marker)// Second argument is the name of the maker. Naming convention that oclif uses internally is <module>.<method>#scope. You are free, however, to name these however you like.const marker = Performance.mark('my-plugin', 'hello.run')// do things that take a while.// Add details to the marker that you might want to access latermarker?.addDetails({from: flags.from, person: args.person})// Stop the marker. This will capture the amount of time between the creation of the marker and the stopping of the marker.marker?.stop()
And a more thorough example:
// ./src/commands/hello/index.tsimport {Args, Command, Flags, Performance} from '@oclif/core'export default class Hello extends Command {  static args = {    person: Args.string({description: 'Person to say hello to', required: true}),  }  static flags = {    from: Flags.string({char: 'f', description: 'Who is saying hello', required: true}),  }  async run(): Promise<void> {    const {args, flags} = await this.parse(Hello)    const marker = Performance.mark('my-plugin', 'hello.run')    await new Promise((resolve) => {      setTimeout(resolve, 1000)    })    marker?.addDetails({from: flags.from, person: args.person})    marker?.stop()    this.log(`hello ${args.person} from ${flags.from}! (./src/commands/hello/index.ts)`)  }}
All the markers you create will be accessible on the static results property on Performance:
// bin/run.jsconst {Performance, flush, handle, run, settings} = await import('@oclif/core')settings.performanceEnabled = trueawait run(process.argv.slice(2))  .catch(async (error) => handle(error))  .finally(async () => {    console.log('Results', Performance.results)    await flush()  })
❯ bin/run.js hello reader --from oclifhello reader from oclif! (./src/commands/hello/index.ts)Results Map(1) {  'my-plugin' => [    {      details: {        from: oclif,        person: reader      },      duration: 1003.4971249999999,      method: 'run',      module: 'hello',      name: 'hello.run',      scope: undefined    }  ]}Edit this pageLast updated on Dec 20, 2024 by Mike DonnalleyPreviousHelp ClassesNextCommand ExecutionHow to EnableAccessing oclif-specific performance metricsUsing Performance for your code\n\n\n\nAPI ReferencePerformanceOn this pagePerformanceoclif supports performance tracking out of the box - both for oclif and you own code. You can enable it in one of two ways depending on how you've implemented your bin scripts.
If you're using the bin scripts that come from the generator, you can simply set performanceEnabled on the settings module:
How to Enable​
#!/usr/bin/env nodeimport {execute, settings} from '@oclif/core'settings.performanceEnabled = trueawait execute({dir: import.meta.url})
You can also enable it on the Config class directly if that works better for your CLI:
import {Config, run} from '@oclif/core'import {fileUrlToPath} from 'node:url'const config = await Config.load({  root: resolve(fileURLToPath(import.meta.url), '..');,  enablePerf: true})await run(config)
Accessing oclif-specific performance metrics​
Once performance is enabled, you can see the in the debug output under the oclif:perf scope.
❯ DEBUG=oclif:perf sf version@salesforce/cli/2.35.6 darwin-arm64 node-v20.11.0  oclif:perf Process Uptime: 747.6823ms +0ms  oclif:perf Oclif Time: 302.1286ms +0ms  oclif:perf Init Time: 37.7735ms +0ms  oclif:perf Config Load Time: 294.5321ms +0ms  oclif:perf   • Root Plugin Load Time: 11.2781ms +0ms  oclif:perf   • Plugins Load Time: 274.6006ms +0ms  oclif:perf   • Commands Load Time: 6.7736ms +0ms  oclif:perf Core Plugin Load Time: 20.9403ms +0ms  oclif:perf User Plugin Load Time: 0.0000ms +0ms  oclif:perf Linked Plugin Load Time: 2.3124ms +0ms  oclif:perf Plugin Load Times: +0ms  oclif:perf   oclif-hello-world: 239.1951ms (no manifest!) +0ms  oclif:perf   @oclif/plugin-update: 18.8549ms +0ms  oclif:perf   @oclif/plugin-autocomplete: 17.5277ms +0ms  oclif:perf   @oclif/plugin-commands: 16.4917ms +0ms  oclif:perf   @oclif/plugin-not-found: 16.3310ms +0ms  oclif:perf   @oclif/plugin-search: 15.8846ms +0ms  oclif:perf   @oclif/plugin-version: 14.8063ms +0ms  oclif:perf   @salesforce/plugin-org: 14.5657ms +0ms  oclif:perf   @salesforce/plugin-data: 14.3991ms +0ms  oclif:perf   @oclif/plugin-warn-if-update-available: 14.3733ms +0ms  oclif:perf   @oclif/plugin-which: 14.1629ms +0ms  oclif:perf   @salesforce/plugin-apex: 13.9885ms +0ms  oclif:perf   @salesforce/plugin-auth: 13.6895ms +0ms  oclif:perf   @salesforce/plugin-deploy-retrieve: 13.6353ms +0ms  oclif:perf   @salesforce/plugin-limits: 13.1123ms +0ms  oclif:perf   @salesforce/plugin-packaging: 12.9777ms +0ms  oclif:perf   @salesforce/plugin-info: 12.7787ms +0ms  oclif:perf   @salesforce/plugin-marketplace: 12.1542ms +0ms  oclif:perf   @salesforce/plugin-source: 11.9480ms +0ms  oclif:perf   @salesforce/plugin-schema: 11.7775ms +0ms  oclif:perf   @salesforce/plugin-settings: 11.4785ms +0ms  oclif:perf   @salesforce/plugin-templates: 11.4225ms +0ms  oclif:perf   @salesforce/plugin-sobject: 11.3670ms +0ms  oclif:perf   root: 11.2781ms +0ms  oclif:perf   @salesforce/plugin-user: 10.8521ms +0ms  oclif:perf   @salesforce/plugin-telemetry: 10.5724ms +1ms  oclif:perf   @salesforce/plugin-trust: 10.4463ms +0ms  oclif:perf   @oclif/plugin-plugins: 2.0135ms +0ms  oclif:perf   @oclif/plugin-help: 1.9039ms +0ms  oclif:perf Hook Run Times: +0ms  oclif:perf   init: +0ms  oclif:perf     total: 37.4624ms +0ms  oclif:perf     oclif-hello-world(./dist/hooks/init/init): 7.9818ms +0ms  oclif:perf     @oclif/plugin-warn-if-update-available(./lib/hooks/init/check-update): 37.1145ms +0ms  oclif:perf     @salesforce/plugin-settings(./lib/hooks/init/load_config_meta): 29.3073ms +0ms  oclif:perf     @oclif/plugin-update(./dist/hooks/init.js): 33.1767ms +0ms  oclif:perf   prerun: +0ms  oclif:perf     total: 260.5702ms +0ms  oclif:perf     @salesforce/cli(./dist/hooks/prerun): 2.3582ms +0ms  oclif:perf     @salesforce/plugin-telemetry(./lib/hooks/telemetryPrerun.js): 260.2634ms +0ms  oclif:perf   preparse: +0ms  oclif:perf     total: 0.5351ms +0ms  oclif:perf     @salesforce/cli(/dist/hooks/preparse): 0.5045ms +0ms  oclif:perf   postrun: +0ms  oclif:perf     total: 0.3507ms +0ms  oclif:perf Command Load Time: 0.7478ms +0ms  oclif:perf Command Run Time: 264.2587ms +0ms
You can also access these metrics programmatically like so:
const {Performance, flush, handle, run, settings} = await import('@oclif/core')settings.performanceEnabled = trueawait run(process.argv.slice(2))  .catch(async (error) => handle(error))  .finally(async () => {    console.log('Performance', Performance.oclifPerf)    await flush()  })
Using Performance for your code​
You can also use the Performance class to capture performance metrics on your own code base.
To capture performance metrics for a block of code, you need to create a new marker using Performance.mark. You then need to call the .stop method the marker to finish timing that block of code.
Here's a brief example:
import {Performance} from '@oclif/core'// Create a new marker.// First argument is the owner of the marker (This allows Performance to be able to distinguish the origin of each marker)// Second argument is the name of the maker. Naming convention that oclif uses internally is <module>.<method>#scope. You are free, however, to name these however you like.const marker = Performance.mark('my-plugin', 'hello.run')// do things that take a while.// Add details to the marker that you might want to access latermarker?.addDetails({from: flags.from, person: args.person})// Stop the marker. This will capture the amount of time between the creation of the marker and the stopping of the marker.marker?.stop()
And a more thorough example:
// ./src/commands/hello/index.tsimport {Args, Command, Flags, Performance} from '@oclif/core'export default class Hello extends Command {  static args = {    person: Args.string({description: 'Person to say hello to', required: true}),  }  static flags = {    from: Flags.string({char: 'f', description: 'Who is saying hello', required: true}),  }  async run(): Promise<void> {    const {args, flags} = await this.parse(Hello)    const marker = Performance.mark('my-plugin', 'hello.run')    await new Promise((resolve) => {      setTimeout(resolve, 1000)    })    marker?.addDetails({from: flags.from, person: args.person})    marker?.stop()    this.log(`hello ${args.person} from ${flags.from}! (./src/commands/hello/index.ts)`)  }}
All the markers you create will be accessible on the static results property on Performance:
// bin/run.jsconst {Performance, flush, handle, run, settings} = await import('@oclif/core')settings.performanceEnabled = trueawait run(process.argv.slice(2))  .catch(async (error) => handle(error))  .finally(async () => {    console.log('Results', Performance.results)    await flush()  })
❯ bin/run.js hello reader --from oclifhello reader from oclif! (./src/commands/hello/index.ts)Results Map(1) {  'my-plugin' => [    {      details: {        from: oclif,        person: reader      },      duration: 1003.4971249999999,      method: 'run',      module: 'hello',      name: 'hello.run',      scope: undefined    }  ]}Edit this pageLast updated on Dec 20, 2024 by Mike Donnalley\n\nAPI ReferencePerformanceOn this pagePerformanceoclif supports performance tracking out of the box - both for oclif and you own code. You can enable it in one of two ways depending on how you've implemented your bin scripts.
If you're using the bin scripts that come from the generator, you can simply set performanceEnabled on the settings module:
How to Enable​
#!/usr/bin/env nodeimport {execute, settings} from '@oclif/core'settings.performanceEnabled = trueawait execute({dir: import.meta.url})
You can also enable it on the Config class directly if that works better for your CLI:
import {Config, run} from '@oclif/core'import {fileUrlToPath} from 'node:url'const config = await Config.load({  root: resolve(fileURLToPath(import.meta.url), '..');,  enablePerf: true})await run(config)
Accessing oclif-specific performance metrics​
Once performance is enabled, you can see the in the debug output under the oclif:perf scope.
❯ DEBUG=oclif:perf sf version@salesforce/cli/2.35.6 darwin-arm64 node-v20.11.0  oclif:perf Process Uptime: 747.6823ms +0ms  oclif:perf Oclif Time: 302.1286ms +0ms  oclif:perf Init Time: 37.7735ms +0ms  oclif:perf Config Load Time: 294.5321ms +0ms  oclif:perf   • Root Plugin Load Time: 11.2781ms +0ms  oclif:perf   • Plugins Load Time: 274.6006ms +0ms  oclif:perf   • Commands Load Time: 6.7736ms +0ms  oclif:perf Core Plugin Load Time: 20.9403ms +0ms  oclif:perf User Plugin Load Time: 0.0000ms +0ms  oclif:perf Linked Plugin Load Time: 2.3124ms +0ms  oclif:perf Plugin Load Times: +0ms  oclif:perf   oclif-hello-world: 239.1951ms (no manifest!) +0ms  oclif:perf   @oclif/plugin-update: 18.8549ms +0ms  oclif:perf   @oclif/plugin-autocomplete: 17.5277ms +0ms  oclif:perf   @oclif/plugin-commands: 16.4917ms +0ms  oclif:perf   @oclif/plugin-not-found: 16.3310ms +0ms  oclif:perf   @oclif/plugin-search: 15.8846ms +0ms  oclif:perf   @oclif/plugin-version: 14.8063ms +0ms  oclif:perf   @salesforce/plugin-org: 14.5657ms +0ms  oclif:perf   @salesforce/plugin-data: 14.3991ms +0ms  oclif:perf   @oclif/plugin-warn-if-update-available: 14.3733ms +0ms  oclif:perf   @oclif/plugin-which: 14.1629ms +0ms  oclif:perf   @salesforce/plugin-apex: 13.9885ms +0ms  oclif:perf   @salesforce/plugin-auth: 13.6895ms +0ms  oclif:perf   @salesforce/plugin-deploy-retrieve: 13.6353ms +0ms  oclif:perf   @salesforce/plugin-limits: 13.1123ms +0ms  oclif:perf   @salesforce/plugin-packaging: 12.9777ms +0ms  oclif:perf   @salesforce/plugin-info: 12.7787ms +0ms  oclif:perf   @salesforce/plugin-marketplace: 12.1542ms +0ms  oclif:perf   @salesforce/plugin-source: 11.9480ms +0ms  oclif:perf   @salesforce/plugin-schema: 11.7775ms +0ms  oclif:perf   @salesforce/plugin-settings: 11.4785ms +0ms  oclif:perf   @salesforce/plugin-templates: 11.4225ms +0ms  oclif:perf   @salesforce/plugin-sobject: 11.3670ms +0ms  oclif:perf   root: 11.2781ms +0ms  oclif:perf   @salesforce/plugin-user: 10.8521ms +0ms  oclif:perf   @salesforce/plugin-telemetry: 10.5724ms +1ms  oclif:perf   @salesforce/plugin-trust: 10.4463ms +0ms  oclif:perf   @oclif/plugin-plugins: 2.0135ms +0ms  oclif:perf   @oclif/plugin-help: 1.9039ms +0ms  oclif:perf Hook Run Times: +0ms  oclif:perf   init: +0ms  oclif:perf     total: 37.4624ms +0ms  oclif:perf     oclif-hello-world(./dist/hooks/init/init): 7.9818ms +0ms  oclif:perf     @oclif/plugin-warn-if-update-available(./lib/hooks/init/check-update): 37.1145ms +0ms  oclif:perf     @salesforce/plugin-settings(./lib/hooks/init/load_config_meta): 29.3073ms +0ms  oclif:perf     @oclif/plugin-update(./dist/hooks/init.js): 33.1767ms +0ms  oclif:perf   prerun: +0ms  oclif:perf     total: 260.5702ms +0ms  oclif:perf     @salesforce/cli(./dist/hooks/prerun): 2.3582ms +0ms  oclif:perf     @salesforce/plugin-telemetry(./lib/hooks/telemetryPrerun.js): 260.2634ms +0ms  oclif:perf   preparse: +0ms  oclif:perf     total: 0.5351ms +0ms  oclif:perf     @salesforce/cli(/dist/hooks/preparse): 0.5045ms +0ms  oclif:perf   postrun: +0ms  oclif:perf     total: 0.3507ms +0ms  oclif:perf Command Load Time: 0.7478ms +0ms  oclif:perf Command Run Time: 264.2587ms +0ms
You can also access these metrics programmatically like so:
const {Performance, flush, handle, run, settings} = await import('@oclif/core')settings.performanceEnabled = trueawait run(process.argv.slice(2))  .catch(async (error) => handle(error))  .finally(async () => {    console.log('Performance', Performance.oclifPerf)    await flush()  })
Using Performance for your code​
You can also use the Performance class to capture performance metrics on your own code base.
To capture performance metrics for a block of code, you need to create a new marker using Performance.mark. You then need to call the .stop method the marker to finish timing that block of code.
Here's a brief example:
import {Performance} from '@oclif/core'// Create a new marker.// First argument is the owner of the marker (This allows Performance to be able to distinguish the origin of each marker)// Second argument is the name of the maker. Naming convention that oclif uses internally is <module>.<method>#scope. You are free, however, to name these however you like.const marker = Performance.mark('my-plugin', 'hello.run')// do things that take a while.// Add details to the marker that you might want to access latermarker?.addDetails({from: flags.from, person: args.person})// Stop the marker. This will capture the amount of time between the creation of the marker and the stopping of the marker.marker?.stop()
And a more thorough example:
// ./src/commands/hello/index.tsimport {Args, Command, Flags, Performance} from '@oclif/core'export default class Hello extends Command {  static args = {    person: Args.string({description: 'Person to say hello to', required: true}),  }  static flags = {    from: Flags.string({char: 'f', description: 'Who is saying hello', required: true}),  }  async run(): Promise<void> {    const {args, flags} = await this.parse(Hello)    const marker = Performance.mark('my-plugin', 'hello.run')    await new Promise((resolve) => {      setTimeout(resolve, 1000)    })    marker?.addDetails({from: flags.from, person: args.person})    marker?.stop()    this.log(`hello ${args.person} from ${flags.from}! (./src/commands/hello/index.ts)`)  }}
All the markers you create will be accessible on the static results property on Performance:
// bin/run.jsconst {Performance, flush, handle, run, settings} = await import('@oclif/core')settings.performanceEnabled = trueawait run(process.argv.slice(2))  .catch(async (error) => handle(error))  .finally(async () => {    console.log('Results', Performance.results)    await flush()  })
❯ bin/run.js hello reader --from oclifhello reader from oclif! (./src/commands/hello/index.ts)Results Map(1) {  'my-plugin' => [    {      details: {        from: oclif,        person: reader      },      duration: 1003.4971249999999,      method: 'run',      module: 'hello',      name: 'hello.run',      scope: undefined    }  ]}Edit this pageLast updated on Dec 20, 2024 by Mike DonnalleyPreviousHelp ClassesNextCommand ExecutionHow to EnableAccessing oclif-specific performance metricsUsing Performance for your code\n\n\n\nIntroducing `oclif init` commandApril 10, 2024 · 2 min readThanks to the contribution of @joshcanhelp we released a new command for the oclif CLI called oclif init in version 4.8.0
The oclif init command allows you to initialize oclif in an existing project directory by adding the bare minimum requirements: a few pieces of configuration, bin scripts, and a couple of dependencies (@oclif/core and ts-node). This is slightly different from oclif generate, which will create an entirely new oclif project based on our templates.
oclif init will add the following:

bin scripts: bin/run.js, bin/run.cmd, bin/dev.js, and bin/dev.cmd
oclif section to package.json with bin, dirname, commands, and topicSeparator set (See Configuring Your CLI for more)
@oclif/core to dependencies in your package.json (if it's not already there)
ts-node to devDependencies in your package.json (if it's not already there)

Once you've initialized oclif, you can use the bin scripts to execute your CLI. You can also use the other oclif commands like oclif generate command and oclif generate hook to start adding new functionality.

❯ oclif init --helpInitialize a new oclif CLIUSAGE  $ oclif init [--bin <value>] [--module-type ESM|CommonJS] [--package-manager npm|yarn|pnpm] [--topic-separator    colons|spaces] [-d <value>] [-y]FLAGS  -d, --output-dir=<value>        Directory to initialize the CLI in.  -y, --yes                       Use defaults for all prompts. Individual flags will override defaults.      --bin=<value>               Supply answer for prompt: Command bin name the CLI will export      --module-type=<option>      Supply answer for prompt: Select a module type                                  <options: ESM|CommonJS>      --package-manager=<option>  Supply answer for prompt: Select a package manager                                  <options: npm|yarn|pnpm>      --topic-separator=<option>  Supply answer for prompt: Select a topic separator                                  <options: colons|spaces>DESCRIPTION  Initialize a new oclif CLI  This will add the necessary oclif bin files, add oclif config to package.json, and install @oclif/core and ts-node.EXAMPLES  Initialize a new CLI in the current directory    $ oclif init  Initialize a new CLI in a different directory    $ oclif init --output-dir "/path/to/existing/project"  Supply answers for specific prompts    $ oclif init --topic-separator colons --bin mycli
Hope you enjoy the new command! If you come across any issues or have any new ideas for this command, head over to the oclif/oclif repo and open a new issue.
All our best,
The oclif team\n\nIntroducing `oclif init` commandApril 10, 2024 · 2 min readThanks to the contribution of @joshcanhelp we released a new command for the oclif CLI called oclif init in version 4.8.0
The oclif init command allows you to initialize oclif in an existing project directory by adding the bare minimum requirements: a few pieces of configuration, bin scripts, and a couple of dependencies (@oclif/core and ts-node). This is slightly different from oclif generate, which will create an entirely new oclif project based on our templates.
oclif init will add the following:

bin scripts: bin/run.js, bin/run.cmd, bin/dev.js, and bin/dev.cmd
oclif section to package.json with bin, dirname, commands, and topicSeparator set (See Configuring Your CLI for more)
@oclif/core to dependencies in your package.json (if it's not already there)
ts-node to devDependencies in your package.json (if it's not already there)

Once you've initialized oclif, you can use the bin scripts to execute your CLI. You can also use the other oclif commands like oclif generate command and oclif generate hook to start adding new functionality.

❯ oclif init --helpInitialize a new oclif CLIUSAGE  $ oclif init [--bin <value>] [--module-type ESM|CommonJS] [--package-manager npm|yarn|pnpm] [--topic-separator    colons|spaces] [-d <value>] [-y]FLAGS  -d, --output-dir=<value>        Directory to initialize the CLI in.  -y, --yes                       Use defaults for all prompts. Individual flags will override defaults.      --bin=<value>               Supply answer for prompt: Command bin name the CLI will export      --module-type=<option>      Supply answer for prompt: Select a module type                                  <options: ESM|CommonJS>      --package-manager=<option>  Supply answer for prompt: Select a package manager                                  <options: npm|yarn|pnpm>      --topic-separator=<option>  Supply answer for prompt: Select a topic separator                                  <options: colons|spaces>DESCRIPTION  Initialize a new oclif CLI  This will add the necessary oclif bin files, add oclif config to package.json, and install @oclif/core and ts-node.EXAMPLES  Initialize a new CLI in the current directory    $ oclif init  Initialize a new CLI in a different directory    $ oclif init --output-dir "/path/to/existing/project"  Supply answers for specific prompts    $ oclif init --topic-separator colons --bin mycli
Hope you enjoy the new command! If you come across any issues or have any new ideas for this command, head over to the oclif/oclif repo and open a new issue.
All our best,
The oclif teamOlder Postoclif Spring 2024 Update\n\n\n\noclif Spring 2024 UpdateMarch 29, 2024 · 4 min readHello oclif developers! It's been a while since we last uploaded a blog - and a lot has happened.
We've been focusing on these high-level areas over the past couple of years:

Improving @oclif/core
ESM Support
Improving and revitalizing oclif.io
Re-engaging the oclif community

Improving @oclif/core​
Since we announced @oclif/core over three years ago, we've released two new major versions, each packed with lots of features that we're really excited about.
Here are some of these changes:

Full support for ESM and interoperability with CommonJS (more on this topic below).
Configurable command discovery strategies that give you more control over how commands are loaded at runtime. Check out the docs.
A new preparse hook that allows you to manipulate the provided arguments before they're parsed. Salesforce used this hook to implement a neat --flags-dir feature that translates local files into flags.
A new Performance class that you can use to track performance inside of @oclif/core and your own CLI or plugin. Check out the docs.
A new flag type, Flags.option, that lets you define a flag with a preset list of options. Typescript then uses the options to infer the flag's type.
Flags now have a relationship property that allows you to define more complex relationships between flags. Check out the flags docs for more information.
Flags now have a defaultHelp property that allows you to set the human readable default value in the command help. This property is useful when your flag's parse method returns a complex type, such as an object or a class. Check out the flags docs for more.
Commands now have a hiddenAliases property that allows you to define aliases that you want to hide from the user. The property is super helpful when you're trying to wean users off a deprecated command.
You can now use bun or tsx as dev runtimes (as opposed to node or ts-node).
A command's usage, args, and flags are now shown whenever a user forgets to provide a required arg or flag, or when they provided a non-existent flag.

If you need help migrating to the latest version, head over to core's README which has links to the migration guides. Feel free to open a new discussion if you need more hands-on help from us or the community.
ESM Support​
Version 3 of @oclif/core introduced full support for developing ESM plugins and CLIs. It also offered full support for interoperability between CommonJS and ESM plugins.
Put more simply, you can now migrate your CLI to ESM while keeping individual plugins in CommonJS (or vice versa). The upgrade path is now much simpler for you. You also don't need to worry about any community plugins that have migrated to ESM before you did (such as all the @oclif plugins) or are staunchly sticking with CommonJS for the foreseeable future.
Read more about this topic here.
Improving and Revitalizing oclif.io​
Another area of focus for us has been improving our documentation site, oclif.io.
While improving the quality and accuracy of the documentation was our priority, we also took the time to upgrade to the latest version of docusaurus. This new version gave our site a much-needed facelift, as well as cool new features such as dark mode and announcements.
If you have any feedback or are running into issues, we want to hear about it. Just create an issue in the oclif.io repo.
Re-engaging the oclif Community​
Lastly, our biggest priority at the moment is to re-engage the oclif community. We understand how frustrating it has been over the years to see your issues and pull requests go unacknowledged. We apologize for not prioritizing the community, and are earnestly trying to make sure that every issue and pull request gets the attention it deserves going forward.
We also opened up GitHub discussions for @oclif/core and the oclif CLI, where you can now post your questions or ideas. We hope you take advantage of them, we love hearing from you!
One last thing: we intend to publicly post our roadmap so you have more visibility into what we're working on. Stay tuned!
All our best,
The oclif team\n\noclif Spring 2024 UpdateMarch 29, 2024 · 4 min readHello oclif developers! It's been a while since we last uploaded a blog - and a lot has happened.
We've been focusing on these high-level areas over the past couple of years:

Improving @oclif/core
ESM Support
Improving and revitalizing oclif.io
Re-engaging the oclif community

Improving @oclif/core​
Since we announced @oclif/core over three years ago, we've released two new major versions, each packed with lots of features that we're really excited about.
Here are some of these changes:

Full support for ESM and interoperability with CommonJS (more on this topic below).
Configurable command discovery strategies that give you more control over how commands are loaded at runtime. Check out the docs.
A new preparse hook that allows you to manipulate the provided arguments before they're parsed. Salesforce used this hook to implement a neat --flags-dir feature that translates local files into flags.
A new Performance class that you can use to track performance inside of @oclif/core and your own CLI or plugin. Check out the docs.
A new flag type, Flags.option, that lets you define a flag with a preset list of options. Typescript then uses the options to infer the flag's type.
Flags now have a relationship property that allows you to define more complex relationships between flags. Check out the flags docs for more information.
Flags now have a defaultHelp property that allows you to set the human readable default value in the command help. This property is useful when your flag's parse method returns a complex type, such as an object or a class. Check out the flags docs for more.
Commands now have a hiddenAliases property that allows you to define aliases that you want to hide from the user. The property is super helpful when you're trying to wean users off a deprecated command.
You can now use bun or tsx as dev runtimes (as opposed to node or ts-node).
A command's usage, args, and flags are now shown whenever a user forgets to provide a required arg or flag, or when they provided a non-existent flag.

If you need help migrating to the latest version, head over to core's README which has links to the migration guides. Feel free to open a new discussion if you need more hands-on help from us or the community.
ESM Support​
Version 3 of @oclif/core introduced full support for developing ESM plugins and CLIs. It also offered full support for interoperability between CommonJS and ESM plugins.
Put more simply, you can now migrate your CLI to ESM while keeping individual plugins in CommonJS (or vice versa). The upgrade path is now much simpler for you. You also don't need to worry about any community plugins that have migrated to ESM before you did (such as all the @oclif plugins) or are staunchly sticking with CommonJS for the foreseeable future.
Read more about this topic here.
Improving and Revitalizing oclif.io​
Another area of focus for us has been improving our documentation site, oclif.io.
While improving the quality and accuracy of the documentation was our priority, we also took the time to upgrade to the latest version of docusaurus. This new version gave our site a much-needed facelift, as well as cool new features such as dark mode and announcements.
If you have any feedback or are running into issues, we want to hear about it. Just create an issue in the oclif.io repo.
Re-engaging the oclif Community​
Lastly, our biggest priority at the moment is to re-engage the oclif community. We understand how frustrating it has been over the years to see your issues and pull requests go unacknowledged. We apologize for not prioritizing the community, and are earnestly trying to make sure that every issue and pull request gets the attention it deserves going forward.
We also opened up GitHub discussions for @oclif/core and the oclif CLI, where you can now post your questions or ideas. We hope you take advantage of them, we love hearing from you!
One last thing: we intend to publicly post our roadmap so you have more visibility into what we're working on. Stay tuned!
All our best,
The oclif teamNewer PostIntroducing `oclif init` commandOlder PostAnnouncing oclif v2!\n\n\n\noclif Spring 2024 UpdateMarch 29, 2024 · 4 min readHello oclif developers! It's been a while since we last uploaded a blog - and a lot has happened.
We've been focusing on these high-level areas over the past couple of years:

Improving @oclif/core
ESM Support
Improving and revitalizing oclif.io
Re-engaging the oclif community

Improving @oclif/core​
Since we announced @oclif/core over three years ago, we've released two new major versions, each packed with lots of features that we're really excited about.
Here are some of these changes:

Full support for ESM and interoperability with CommonJS (more on this topic below).
Configurable command discovery strategies that give you more control over how commands are loaded at runtime. Check out the docs.
A new preparse hook that allows you to manipulate the provided arguments before they're parsed. Salesforce used this hook to implement a neat --flags-dir feature that translates local files into flags.
A new Performance class that you can use to track performance inside of @oclif/core and your own CLI or plugin. Check out the docs.
A new flag type, Flags.option, that lets you define a flag with a preset list of options. Typescript then uses the options to infer the flag's type.
Flags now have a relationship property that allows you to define more complex relationships between flags. Check out the flags docs for more information.
Flags now have a defaultHelp property that allows you to set the human readable default value in the command help. This property is useful when your flag's parse method returns a complex type, such as an object or a class. Check out the flags docs for more.
Commands now have a hiddenAliases property that allows you to define aliases that you want to hide from the user. The property is super helpful when you're trying to wean users off a deprecated command.
You can now use bun or tsx as dev runtimes (as opposed to node or ts-node).
A command's usage, args, and flags are now shown whenever a user forgets to provide a required arg or flag, or when they provided a non-existent flag.

If you need help migrating to the latest version, head over to core's README which has links to the migration guides. Feel free to open a new discussion if you need more hands-on help from us or the community.
ESM Support​
Version 3 of @oclif/core introduced full support for developing ESM plugins and CLIs. It also offered full support for interoperability between CommonJS and ESM plugins.
Put more simply, you can now migrate your CLI to ESM while keeping individual plugins in CommonJS (or vice versa). The upgrade path is now much simpler for you. You also don't need to worry about any community plugins that have migrated to ESM before you did (such as all the @oclif plugins) or are staunchly sticking with CommonJS for the foreseeable future.
Read more about this topic here.
Improving and Revitalizing oclif.io​
Another area of focus for us has been improving our documentation site, oclif.io.
While improving the quality and accuracy of the documentation was our priority, we also took the time to upgrade to the latest version of docusaurus. This new version gave our site a much-needed facelift, as well as cool new features such as dark mode and announcements.
If you have any feedback or are running into issues, we want to hear about it. Just create an issue in the oclif.io repo.
Re-engaging the oclif Community​
Lastly, our biggest priority at the moment is to re-engage the oclif community. We understand how frustrating it has been over the years to see your issues and pull requests go unacknowledged. We apologize for not prioritizing the community, and are earnestly trying to make sure that every issue and pull request gets the attention it deserves going forward.
We also opened up GitHub discussions for @oclif/core and the oclif CLI, where you can now post your questions or ideas. We hope you take advantage of them, we love hearing from you!
One last thing: we intend to publicly post our roadmap so you have more visibility into what we're working on. Stay tuned!
All our best,
The oclif team\n\noclif Spring 2024 UpdateMarch 29, 2024 · 4 min readHello oclif developers! It's been a while since we last uploaded a blog - and a lot has happened.
We've been focusing on these high-level areas over the past couple of years:

Improving @oclif/core
ESM Support
Improving and revitalizing oclif.io
Re-engaging the oclif community

Improving @oclif/core​
Since we announced @oclif/core over three years ago, we've released two new major versions, each packed with lots of features that we're really excited about.
Here are some of these changes:

Full support for ESM and interoperability with CommonJS (more on this topic below).
Configurable command discovery strategies that give you more control over how commands are loaded at runtime. Check out the docs.
A new preparse hook that allows you to manipulate the provided arguments before they're parsed. Salesforce used this hook to implement a neat --flags-dir feature that translates local files into flags.
A new Performance class that you can use to track performance inside of @oclif/core and your own CLI or plugin. Check out the docs.
A new flag type, Flags.option, that lets you define a flag with a preset list of options. Typescript then uses the options to infer the flag's type.
Flags now have a relationship property that allows you to define more complex relationships between flags. Check out the flags docs for more information.
Flags now have a defaultHelp property that allows you to set the human readable default value in the command help. This property is useful when your flag's parse method returns a complex type, such as an object or a class. Check out the flags docs for more.
Commands now have a hiddenAliases property that allows you to define aliases that you want to hide from the user. The property is super helpful when you're trying to wean users off a deprecated command.
You can now use bun or tsx as dev runtimes (as opposed to node or ts-node).
A command's usage, args, and flags are now shown whenever a user forgets to provide a required arg or flag, or when they provided a non-existent flag.

If you need help migrating to the latest version, head over to core's README which has links to the migration guides. Feel free to open a new discussion if you need more hands-on help from us or the community.
ESM Support​
Version 3 of @oclif/core introduced full support for developing ESM plugins and CLIs. It also offered full support for interoperability between CommonJS and ESM plugins.
Put more simply, you can now migrate your CLI to ESM while keeping individual plugins in CommonJS (or vice versa). The upgrade path is now much simpler for you. You also don't need to worry about any community plugins that have migrated to ESM before you did (such as all the @oclif plugins) or are staunchly sticking with CommonJS for the foreseeable future.
Read more about this topic here.
Improving and Revitalizing oclif.io​
Another area of focus for us has been improving our documentation site, oclif.io.
While improving the quality and accuracy of the documentation was our priority, we also took the time to upgrade to the latest version of docusaurus. This new version gave our site a much-needed facelift, as well as cool new features such as dark mode and announcements.
If you have any feedback or are running into issues, we want to hear about it. Just create an issue in the oclif.io repo.
Re-engaging the oclif Community​
Lastly, our biggest priority at the moment is to re-engage the oclif community. We understand how frustrating it has been over the years to see your issues and pull requests go unacknowledged. We apologize for not prioritizing the community, and are earnestly trying to make sure that every issue and pull request gets the attention it deserves going forward.
We also opened up GitHub discussions for @oclif/core and the oclif CLI, where you can now post your questions or ideas. We hope you take advantage of them, we love hearing from you!
One last thing: we intend to publicly post our roadmap so you have more visibility into what we're working on. Stay tuned!
All our best,
The oclif teamNewer PostIntroducing `oclif init` commandOlder PostAnnouncing oclif v2!\n\n\n\noclif Spring 2024 UpdateMarch 29, 2024 · 4 min readHello oclif developers! It's been a while since we last uploaded a blog - and a lot has happened.
We've been focusing on these high-level areas over the past couple of years:

Improving @oclif/core
ESM Support
Improving and revitalizing oclif.io
Re-engaging the oclif community

Improving @oclif/core​
Since we announced @oclif/core over three years ago, we've released two new major versions, each packed with lots of features that we're really excited about.
Here are some of these changes:

Full support for ESM and interoperability with CommonJS (more on this topic below).
Configurable command discovery strategies that give you more control over how commands are loaded at runtime. Check out the docs.
A new preparse hook that allows you to manipulate the provided arguments before they're parsed. Salesforce used this hook to implement a neat --flags-dir feature that translates local files into flags.
A new Performance class that you can use to track performance inside of @oclif/core and your own CLI or plugin. Check out the docs.
A new flag type, Flags.option, that lets you define a flag with a preset list of options. Typescript then uses the options to infer the flag's type.
Flags now have a relationship property that allows you to define more complex relationships between flags. Check out the flags docs for more information.
Flags now have a defaultHelp property that allows you to set the human readable default value in the command help. This property is useful when your flag's parse method returns a complex type, such as an object or a class. Check out the flags docs for more.
Commands now have a hiddenAliases property that allows you to define aliases that you want to hide from the user. The property is super helpful when you're trying to wean users off a deprecated command.
You can now use bun or tsx as dev runtimes (as opposed to node or ts-node).
A command's usage, args, and flags are now shown whenever a user forgets to provide a required arg or flag, or when they provided a non-existent flag.

If you need help migrating to the latest version, head over to core's README which has links to the migration guides. Feel free to open a new discussion if you need more hands-on help from us or the community.
ESM Support​
Version 3 of @oclif/core introduced full support for developing ESM plugins and CLIs. It also offered full support for interoperability between CommonJS and ESM plugins.
Put more simply, you can now migrate your CLI to ESM while keeping individual plugins in CommonJS (or vice versa). The upgrade path is now much simpler for you. You also don't need to worry about any community plugins that have migrated to ESM before you did (such as all the @oclif plugins) or are staunchly sticking with CommonJS for the foreseeable future.
Read more about this topic here.
Improving and Revitalizing oclif.io​
Another area of focus for us has been improving our documentation site, oclif.io.
While improving the quality and accuracy of the documentation was our priority, we also took the time to upgrade to the latest version of docusaurus. This new version gave our site a much-needed facelift, as well as cool new features such as dark mode and announcements.
If you have any feedback or are running into issues, we want to hear about it. Just create an issue in the oclif.io repo.
Re-engaging the oclif Community​
Lastly, our biggest priority at the moment is to re-engage the oclif community. We understand how frustrating it has been over the years to see your issues and pull requests go unacknowledged. We apologize for not prioritizing the community, and are earnestly trying to make sure that every issue and pull request gets the attention it deserves going forward.
We also opened up GitHub discussions for @oclif/core and the oclif CLI, where you can now post your questions or ideas. We hope you take advantage of them, we love hearing from you!
One last thing: we intend to publicly post our roadmap so you have more visibility into what we're working on. Stay tuned!
All our best,
The oclif team\n\noclif Spring 2024 UpdateMarch 29, 2024 · 4 min readHello oclif developers! It's been a while since we last uploaded a blog - and a lot has happened.
We've been focusing on these high-level areas over the past couple of years:

Improving @oclif/core
ESM Support
Improving and revitalizing oclif.io
Re-engaging the oclif community

Improving @oclif/core​
Since we announced @oclif/core over three years ago, we've released two new major versions, each packed with lots of features that we're really excited about.
Here are some of these changes:

Full support for ESM and interoperability with CommonJS (more on this topic below).
Configurable command discovery strategies that give you more control over how commands are loaded at runtime. Check out the docs.
A new preparse hook that allows you to manipulate the provided arguments before they're parsed. Salesforce used this hook to implement a neat --flags-dir feature that translates local files into flags.
A new Performance class that you can use to track performance inside of @oclif/core and your own CLI or plugin. Check out the docs.
A new flag type, Flags.option, that lets you define a flag with a preset list of options. Typescript then uses the options to infer the flag's type.
Flags now have a relationship property that allows you to define more complex relationships between flags. Check out the flags docs for more information.
Flags now have a defaultHelp property that allows you to set the human readable default value in the command help. This property is useful when your flag's parse method returns a complex type, such as an object or a class. Check out the flags docs for more.
Commands now have a hiddenAliases property that allows you to define aliases that you want to hide from the user. The property is super helpful when you're trying to wean users off a deprecated command.
You can now use bun or tsx as dev runtimes (as opposed to node or ts-node).
A command's usage, args, and flags are now shown whenever a user forgets to provide a required arg or flag, or when they provided a non-existent flag.

If you need help migrating to the latest version, head over to core's README which has links to the migration guides. Feel free to open a new discussion if you need more hands-on help from us or the community.
ESM Support​
Version 3 of @oclif/core introduced full support for developing ESM plugins and CLIs. It also offered full support for interoperability between CommonJS and ESM plugins.
Put more simply, you can now migrate your CLI to ESM while keeping individual plugins in CommonJS (or vice versa). The upgrade path is now much simpler for you. You also don't need to worry about any community plugins that have migrated to ESM before you did (such as all the @oclif plugins) or are staunchly sticking with CommonJS for the foreseeable future.
Read more about this topic here.
Improving and Revitalizing oclif.io​
Another area of focus for us has been improving our documentation site, oclif.io.
While improving the quality and accuracy of the documentation was our priority, we also took the time to upgrade to the latest version of docusaurus. This new version gave our site a much-needed facelift, as well as cool new features such as dark mode and announcements.
If you have any feedback or are running into issues, we want to hear about it. Just create an issue in the oclif.io repo.
Re-engaging the oclif Community​
Lastly, our biggest priority at the moment is to re-engage the oclif community. We understand how frustrating it has been over the years to see your issues and pull requests go unacknowledged. We apologize for not prioritizing the community, and are earnestly trying to make sure that every issue and pull request gets the attention it deserves going forward.
We also opened up GitHub discussions for @oclif/core and the oclif CLI, where you can now post your questions or ideas. We hope you take advantage of them, we love hearing from you!
One last thing: we intend to publicly post our roadmap so you have more visibility into what we're working on. Stay tuned!
All our best,
The oclif teamNewer PostIntroducing `oclif init` commandOlder PostAnnouncing oclif v2!\n\n\n\noclif Spring 2024 UpdateMarch 29, 2024 · 4 min readHello oclif developers! It's been a while since we last uploaded a blog - and a lot has happened.
We've been focusing on these high-level areas over the past couple of years:

Improving @oclif/core
ESM Support
Improving and revitalizing oclif.io
Re-engaging the oclif community

Improving @oclif/core​
Since we announced @oclif/core over three years ago, we've released two new major versions, each packed with lots of features that we're really excited about.
Here are some of these changes:

Full support for ESM and interoperability with CommonJS (more on this topic below).
Configurable command discovery strategies that give you more control over how commands are loaded at runtime. Check out the docs.
A new preparse hook that allows you to manipulate the provided arguments before they're parsed. Salesforce used this hook to implement a neat --flags-dir feature that translates local files into flags.
A new Performance class that you can use to track performance inside of @oclif/core and your own CLI or plugin. Check out the docs.
A new flag type, Flags.option, that lets you define a flag with a preset list of options. Typescript then uses the options to infer the flag's type.
Flags now have a relationship property that allows you to define more complex relationships between flags. Check out the flags docs for more information.
Flags now have a defaultHelp property that allows you to set the human readable default value in the command help. This property is useful when your flag's parse method returns a complex type, such as an object or a class. Check out the flags docs for more.
Commands now have a hiddenAliases property that allows you to define aliases that you want to hide from the user. The property is super helpful when you're trying to wean users off a deprecated command.
You can now use bun or tsx as dev runtimes (as opposed to node or ts-node).
A command's usage, args, and flags are now shown whenever a user forgets to provide a required arg or flag, or when they provided a non-existent flag.

If you need help migrating to the latest version, head over to core's README which has links to the migration guides. Feel free to open a new discussion if you need more hands-on help from us or the community.
ESM Support​
Version 3 of @oclif/core introduced full support for developing ESM plugins and CLIs. It also offered full support for interoperability between CommonJS and ESM plugins.
Put more simply, you can now migrate your CLI to ESM while keeping individual plugins in CommonJS (or vice versa). The upgrade path is now much simpler for you. You also don't need to worry about any community plugins that have migrated to ESM before you did (such as all the @oclif plugins) or are staunchly sticking with CommonJS for the foreseeable future.
Read more about this topic here.
Improving and Revitalizing oclif.io​
Another area of focus for us has been improving our documentation site, oclif.io.
While improving the quality and accuracy of the documentation was our priority, we also took the time to upgrade to the latest version of docusaurus. This new version gave our site a much-needed facelift, as well as cool new features such as dark mode and announcements.
If you have any feedback or are running into issues, we want to hear about it. Just create an issue in the oclif.io repo.
Re-engaging the oclif Community​
Lastly, our biggest priority at the moment is to re-engage the oclif community. We understand how frustrating it has been over the years to see your issues and pull requests go unacknowledged. We apologize for not prioritizing the community, and are earnestly trying to make sure that every issue and pull request gets the attention it deserves going forward.
We also opened up GitHub discussions for @oclif/core and the oclif CLI, where you can now post your questions or ideas. We hope you take advantage of them, we love hearing from you!
One last thing: we intend to publicly post our roadmap so you have more visibility into what we're working on. Stay tuned!
All our best,
The oclif team\n\noclif Spring 2024 UpdateMarch 29, 2024 · 4 min readHello oclif developers! It's been a while since we last uploaded a blog - and a lot has happened.
We've been focusing on these high-level areas over the past couple of years:

Improving @oclif/core
ESM Support
Improving and revitalizing oclif.io
Re-engaging the oclif community

Improving @oclif/core​
Since we announced @oclif/core over three years ago, we've released two new major versions, each packed with lots of features that we're really excited about.
Here are some of these changes:

Full support for ESM and interoperability with CommonJS (more on this topic below).
Configurable command discovery strategies that give you more control over how commands are loaded at runtime. Check out the docs.
A new preparse hook that allows you to manipulate the provided arguments before they're parsed. Salesforce used this hook to implement a neat --flags-dir feature that translates local files into flags.
A new Performance class that you can use to track performance inside of @oclif/core and your own CLI or plugin. Check out the docs.
A new flag type, Flags.option, that lets you define a flag with a preset list of options. Typescript then uses the options to infer the flag's type.
Flags now have a relationship property that allows you to define more complex relationships between flags. Check out the flags docs for more information.
Flags now have a defaultHelp property that allows you to set the human readable default value in the command help. This property is useful when your flag's parse method returns a complex type, such as an object or a class. Check out the flags docs for more.
Commands now have a hiddenAliases property that allows you to define aliases that you want to hide from the user. The property is super helpful when you're trying to wean users off a deprecated command.
You can now use bun or tsx as dev runtimes (as opposed to node or ts-node).
A command's usage, args, and flags are now shown whenever a user forgets to provide a required arg or flag, or when they provided a non-existent flag.

If you need help migrating to the latest version, head over to core's README which has links to the migration guides. Feel free to open a new discussion if you need more hands-on help from us or the community.
ESM Support​
Version 3 of @oclif/core introduced full support for developing ESM plugins and CLIs. It also offered full support for interoperability between CommonJS and ESM plugins.
Put more simply, you can now migrate your CLI to ESM while keeping individual plugins in CommonJS (or vice versa). The upgrade path is now much simpler for you. You also don't need to worry about any community plugins that have migrated to ESM before you did (such as all the @oclif plugins) or are staunchly sticking with CommonJS for the foreseeable future.
Read more about this topic here.
Improving and Revitalizing oclif.io​
Another area of focus for us has been improving our documentation site, oclif.io.
While improving the quality and accuracy of the documentation was our priority, we also took the time to upgrade to the latest version of docusaurus. This new version gave our site a much-needed facelift, as well as cool new features such as dark mode and announcements.
If you have any feedback or are running into issues, we want to hear about it. Just create an issue in the oclif.io repo.
Re-engaging the oclif Community​
Lastly, our biggest priority at the moment is to re-engage the oclif community. We understand how frustrating it has been over the years to see your issues and pull requests go unacknowledged. We apologize for not prioritizing the community, and are earnestly trying to make sure that every issue and pull request gets the attention it deserves going forward.
We also opened up GitHub discussions for @oclif/core and the oclif CLI, where you can now post your questions or ideas. We hope you take advantage of them, we love hearing from you!
One last thing: we intend to publicly post our roadmap so you have more visibility into what we're working on. Stay tuned!
All our best,
The oclif teamNewer PostIntroducing `oclif init` commandOlder PostAnnouncing oclif v2!\n\n\n\noclif Spring 2024 UpdateMarch 29, 2024 · 4 min readHello oclif developers! It's been a while since we last uploaded a blog - and a lot has happened.
We've been focusing on these high-level areas over the past couple of years:

Improving @oclif/core
ESM Support
Improving and revitalizing oclif.io
Re-engaging the oclif community

Improving @oclif/core​
Since we announced @oclif/core over three years ago, we've released two new major versions, each packed with lots of features that we're really excited about.
Here are some of these changes:

Full support for ESM and interoperability with CommonJS (more on this topic below).
Configurable command discovery strategies that give you more control over how commands are loaded at runtime. Check out the docs.
A new preparse hook that allows you to manipulate the provided arguments before they're parsed. Salesforce used this hook to implement a neat --flags-dir feature that translates local files into flags.
A new Performance class that you can use to track performance inside of @oclif/core and your own CLI or plugin. Check out the docs.
A new flag type, Flags.option, that lets you define a flag with a preset list of options. Typescript then uses the options to infer the flag's type.
Flags now have a relationship property that allows you to define more complex relationships between flags. Check out the flags docs for more information.
Flags now have a defaultHelp property that allows you to set the human readable default value in the command help. This property is useful when your flag's parse method returns a complex type, such as an object or a class. Check out the flags docs for more.
Commands now have a hiddenAliases property that allows you to define aliases that you want to hide from the user. The property is super helpful when you're trying to wean users off a deprecated command.
You can now use bun or tsx as dev runtimes (as opposed to node or ts-node).
A command's usage, args, and flags are now shown whenever a user forgets to provide a required arg or flag, or when they provided a non-existent flag.

If you need help migrating to the latest version, head over to core's README which has links to the migration guides. Feel free to open a new discussion if you need more hands-on help from us or the community.
ESM Support​
Version 3 of @oclif/core introduced full support for developing ESM plugins and CLIs. It also offered full support for interoperability between CommonJS and ESM plugins.
Put more simply, you can now migrate your CLI to ESM while keeping individual plugins in CommonJS (or vice versa). The upgrade path is now much simpler for you. You also don't need to worry about any community plugins that have migrated to ESM before you did (such as all the @oclif plugins) or are staunchly sticking with CommonJS for the foreseeable future.
Read more about this topic here.
Improving and Revitalizing oclif.io​
Another area of focus for us has been improving our documentation site, oclif.io.
While improving the quality and accuracy of the documentation was our priority, we also took the time to upgrade to the latest version of docusaurus. This new version gave our site a much-needed facelift, as well as cool new features such as dark mode and announcements.
If you have any feedback or are running into issues, we want to hear about it. Just create an issue in the oclif.io repo.
Re-engaging the oclif Community​
Lastly, our biggest priority at the moment is to re-engage the oclif community. We understand how frustrating it has been over the years to see your issues and pull requests go unacknowledged. We apologize for not prioritizing the community, and are earnestly trying to make sure that every issue and pull request gets the attention it deserves going forward.
We also opened up GitHub discussions for @oclif/core and the oclif CLI, where you can now post your questions or ideas. We hope you take advantage of them, we love hearing from you!
One last thing: we intend to publicly post our roadmap so you have more visibility into what we're working on. Stay tuned!
All our best,
The oclif team\n\noclif Spring 2024 UpdateMarch 29, 2024 · 4 min readHello oclif developers! It's been a while since we last uploaded a blog - and a lot has happened.
We've been focusing on these high-level areas over the past couple of years:

Improving @oclif/core
ESM Support
Improving and revitalizing oclif.io
Re-engaging the oclif community

Improving @oclif/core​
Since we announced @oclif/core over three years ago, we've released two new major versions, each packed with lots of features that we're really excited about.
Here are some of these changes:

Full support for ESM and interoperability with CommonJS (more on this topic below).
Configurable command discovery strategies that give you more control over how commands are loaded at runtime. Check out the docs.
A new preparse hook that allows you to manipulate the provided arguments before they're parsed. Salesforce used this hook to implement a neat --flags-dir feature that translates local files into flags.
A new Performance class that you can use to track performance inside of @oclif/core and your own CLI or plugin. Check out the docs.
A new flag type, Flags.option, that lets you define a flag with a preset list of options. Typescript then uses the options to infer the flag's type.
Flags now have a relationship property that allows you to define more complex relationships between flags. Check out the flags docs for more information.
Flags now have a defaultHelp property that allows you to set the human readable default value in the command help. This property is useful when your flag's parse method returns a complex type, such as an object or a class. Check out the flags docs for more.
Commands now have a hiddenAliases property that allows you to define aliases that you want to hide from the user. The property is super helpful when you're trying to wean users off a deprecated command.
You can now use bun or tsx as dev runtimes (as opposed to node or ts-node).
A command's usage, args, and flags are now shown whenever a user forgets to provide a required arg or flag, or when they provided a non-existent flag.

If you need help migrating to the latest version, head over to core's README which has links to the migration guides. Feel free to open a new discussion if you need more hands-on help from us or the community.
ESM Support​
Version 3 of @oclif/core introduced full support for developing ESM plugins and CLIs. It also offered full support for interoperability between CommonJS and ESM plugins.
Put more simply, you can now migrate your CLI to ESM while keeping individual plugins in CommonJS (or vice versa). The upgrade path is now much simpler for you. You also don't need to worry about any community plugins that have migrated to ESM before you did (such as all the @oclif plugins) or are staunchly sticking with CommonJS for the foreseeable future.
Read more about this topic here.
Improving and Revitalizing oclif.io​
Another area of focus for us has been improving our documentation site, oclif.io.
While improving the quality and accuracy of the documentation was our priority, we also took the time to upgrade to the latest version of docusaurus. This new version gave our site a much-needed facelift, as well as cool new features such as dark mode and announcements.
If you have any feedback or are running into issues, we want to hear about it. Just create an issue in the oclif.io repo.
Re-engaging the oclif Community​
Lastly, our biggest priority at the moment is to re-engage the oclif community. We understand how frustrating it has been over the years to see your issues and pull requests go unacknowledged. We apologize for not prioritizing the community, and are earnestly trying to make sure that every issue and pull request gets the attention it deserves going forward.
We also opened up GitHub discussions for @oclif/core and the oclif CLI, where you can now post your questions or ideas. We hope you take advantage of them, we love hearing from you!
One last thing: we intend to publicly post our roadmap so you have more visibility into what we're working on. Stay tuned!
All our best,
The oclif teamNewer PostIntroducing `oclif init` commandOlder PostAnnouncing oclif v2!\n\n\n\nAnnouncing oclif v2!January 12, 2022 · 5 min readHello and happy new year! It's our great pleasure to announce that we have released oclif v2, which uses the new @oclif/core library! 🎉
oclif v2 includes many changes that improve the experience of both creating and using an oclif CLI.
Going forward, we don't plan to make any updates to oclif v1 and its corresponding libraries, except for critical security fixes. See the compatibility matrix for a list of these libraries. In order to give developers time to migrate from v1 to v2, we're not completely dropping support yet. But at some point in the future we'll archive the v1 repositories and deprecate their versions on npm.
What’s changing?​
Repository Changes​
All repositories under the oclif org now use main as their primary branch and oclif-v1 as the legacy branch. The main  branch corresponds to oclif v2 and the oclif-v1 branch to oclif v1. If you find any repos that don’t have a main branch, you can safely assume that they're not used in oclif v2 and will be deprecated in the future.
Consolidating Tools & Libraries​
The oclif-dev CLI has now been incorporated into oclif. You now no longer need to install a separate package to manage your entire CLI’s lifecycle.
The following libraries have been consolidated under @oclif/core and will be deprecated at some point in the future. Read the migration guide to learn how to update your CLI or plugin to use the new core library.

@oclif/command
@oclif/config
@oclif/error
@oclif/help
@oclif/parser

No more single vs multi command CLIs​
There's only one "type" of oclif v2 CLI, but it can have as few or as many commands as a developer wants. As a result, there’s only one command to generate CLIs, oclif generate, as opposed to the old oclif single and oclif multi commands.
Node > 12​
To ensure oclif CLIs are as secure as possible, all v2 libraries and plugins support only Node 12 or higher as of now. Going forward, they'll support only Node Maintenance or higher, as defined by Node's release schedule here: https://nodejs.org/en/about/releases/.
What’s new?​
New example CLI​
oclif-hello-world is our new example repo. This is also the repo that's used as a template when running oclif generate to create a new CLI. This repo will always be able to be referenced as an example of what an oclif v2 CLI should look like.
Spaced commands​
oclif CLIs can now use spaces, instead of colons, to separate topics and subcommands. To enable this feature, simply add “topicSeparator": " " to the oclif config in your package.json. See an example in our example repo.
// Old commands that use :$ mycli do:something
// New spaced commands$ mycli do something

Note: Spaced commands are backwards compatible. So if you enable spaced commands for your CLI, users will still be able to use : as a separator. This ensures that any existing scripts don't break.

New Help Output​
We’ve revamped the way command help is outputted to the terminal, making it both easier to implement and easier to read. See the difference between the old help output on the left and the new help output on the right in the screenshots below.
oclif v1oclif v2
Notice that there are new sections for flags and global flags, examples are displayed with better spacing, and there is a section at the bottom called Configuration Variables. This Configuration Variables section is not part of the new help by default. But we've added support for custom help sections, which is what the sf CLI uses to create the new section.
Async Command Parsing​
We’ve also improved the performance of new CLIs by rewriting how commands are parsed on initialization. The new parser is asynchronous, which makes CLIs with a lot of commands or installed  plugins much faster.
What’s coming next?​
Part of our charter for the release of oclif v2 includes improving our engagement with the oclif community. We know that over the past couple of years we’ve reduced our involvement, and a lot of issues and PRs have languished in limbo. Hopefully you’ve already seen increased activity and responses from oclif maintainers recently, but if you haven’t, please don’t hesitate to ping us by tagging @admins in oclif repos.
We also want to start interviewing members of the oclif community to acquire feedback and prioritize the features and fixes you deem most important!
Best,
The oclif team

Reference material​
Migration Guide​
This guide explains how to upgrade a CLI or plugin from the old oclif v1 libraries to the new @oclif/core library that oclif v2 uses.
https://github.com/oclif/core/blob/main/MIGRATION.md
Compatibility Matrix​
The following matrix shows how the v1 libraries and plugins relate to the new v2 ones. Use this matrix as a guide to know what to drop and which versions to switch when upgrading your plugins and CLIs to v2.
oclif "v1"oclif "v2"Utility CLIsoclif@<2@oclif/dev-cli@<2oclif@>=2Main packages@oclif/command@oclif/config@oclif/errors@oclif/parser@oclif/plugin-help@oclif/core@>=1Node LTSNode v8-14Node v12+ (at time of writing)TypeScripttypescript@<4typescript@>=4Main plugins@oclif/plugin-autocomplete@<1@oclif/plugin-commands@<2@oclif/plugin-help@<4@oclif/plugin-not-found@<2@oclif/plugin-plugins@<2@oclif/plugin-update@<2plugin-warn-if-update-available@<2plugin-which@<2@oclif/plugin-autocomplete@>=1@oclif/plugin-commands@>=2@oclif/plugin-help@>=4@oclif/plugin-not-found@>=2@oclif/plugin-plugins@>=2@oclif/plugin-update@>=2@oclif/plugin-warn-if-update-available@>=2@oclif/plugin-which@>=2\n\nAnnouncing oclif v2!January 12, 2022 · 5 min readHello and happy new year! It's our great pleasure to announce that we have released oclif v2, which uses the new @oclif/core library! 🎉
oclif v2 includes many changes that improve the experience of both creating and using an oclif CLI.
Going forward, we don't plan to make any updates to oclif v1 and its corresponding libraries, except for critical security fixes. See the compatibility matrix for a list of these libraries. In order to give developers time to migrate from v1 to v2, we're not completely dropping support yet. But at some point in the future we'll archive the v1 repositories and deprecate their versions on npm.
What’s changing?​
Repository Changes​
All repositories under the oclif org now use main as their primary branch and oclif-v1 as the legacy branch. The main  branch corresponds to oclif v2 and the oclif-v1 branch to oclif v1. If you find any repos that don’t have a main branch, you can safely assume that they're not used in oclif v2 and will be deprecated in the future.
Consolidating Tools & Libraries​
The oclif-dev CLI has now been incorporated into oclif. You now no longer need to install a separate package to manage your entire CLI’s lifecycle.
The following libraries have been consolidated under @oclif/core and will be deprecated at some point in the future. Read the migration guide to learn how to update your CLI or plugin to use the new core library.

@oclif/command
@oclif/config
@oclif/error
@oclif/help
@oclif/parser

No more single vs multi command CLIs​
There's only one "type" of oclif v2 CLI, but it can have as few or as many commands as a developer wants. As a result, there’s only one command to generate CLIs, oclif generate, as opposed to the old oclif single and oclif multi commands.
Node > 12​
To ensure oclif CLIs are as secure as possible, all v2 libraries and plugins support only Node 12 or higher as of now. Going forward, they'll support only Node Maintenance or higher, as defined by Node's release schedule here: https://nodejs.org/en/about/releases/.
What’s new?​
New example CLI​
oclif-hello-world is our new example repo. This is also the repo that's used as a template when running oclif generate to create a new CLI. This repo will always be able to be referenced as an example of what an oclif v2 CLI should look like.
Spaced commands​
oclif CLIs can now use spaces, instead of colons, to separate topics and subcommands. To enable this feature, simply add “topicSeparator": " " to the oclif config in your package.json. See an example in our example repo.
// Old commands that use :$ mycli do:something
// New spaced commands$ mycli do something

Note: Spaced commands are backwards compatible. So if you enable spaced commands for your CLI, users will still be able to use : as a separator. This ensures that any existing scripts don't break.

New Help Output​
We’ve revamped the way command help is outputted to the terminal, making it both easier to implement and easier to read. See the difference between the old help output on the left and the new help output on the right in the screenshots below.
oclif v1oclif v2
Notice that there are new sections for flags and global flags, examples are displayed with better spacing, and there is a section at the bottom called Configuration Variables. This Configuration Variables section is not part of the new help by default. But we've added support for custom help sections, which is what the sf CLI uses to create the new section.
Async Command Parsing​
We’ve also improved the performance of new CLIs by rewriting how commands are parsed on initialization. The new parser is asynchronous, which makes CLIs with a lot of commands or installed  plugins much faster.
What’s coming next?​
Part of our charter for the release of oclif v2 includes improving our engagement with the oclif community. We know that over the past couple of years we’ve reduced our involvement, and a lot of issues and PRs have languished in limbo. Hopefully you’ve already seen increased activity and responses from oclif maintainers recently, but if you haven’t, please don’t hesitate to ping us by tagging @admins in oclif repos.
We also want to start interviewing members of the oclif community to acquire feedback and prioritize the features and fixes you deem most important!
Best,
The oclif team

Reference material​
Migration Guide​
This guide explains how to upgrade a CLI or plugin from the old oclif v1 libraries to the new @oclif/core library that oclif v2 uses.
https://github.com/oclif/core/blob/main/MIGRATION.md
Compatibility Matrix​
The following matrix shows how the v1 libraries and plugins relate to the new v2 ones. Use this matrix as a guide to know what to drop and which versions to switch when upgrading your plugins and CLIs to v2.
oclif "v1"oclif "v2"Utility CLIsoclif@<2@oclif/dev-cli@<2oclif@>=2Main packages@oclif/command@oclif/config@oclif/errors@oclif/parser@oclif/plugin-help@oclif/core@>=1Node LTSNode v8-14Node v12+ (at time of writing)TypeScripttypescript@<4typescript@>=4Main plugins@oclif/plugin-autocomplete@<1@oclif/plugin-commands@<2@oclif/plugin-help@<4@oclif/plugin-not-found@<2@oclif/plugin-plugins@<2@oclif/plugin-update@<2plugin-warn-if-update-available@<2plugin-which@<2@oclif/plugin-autocomplete@>=1@oclif/plugin-commands@>=2@oclif/plugin-help@>=4@oclif/plugin-not-found@>=2@oclif/plugin-plugins@>=2@oclif/plugin-update@>=2@oclif/plugin-warn-if-update-available@>=2@oclif/plugin-which@>=2Newer Postoclif Spring 2024 UpdateOlder PostIntroducing @oclif/core\n\n\n\nAnnouncing oclif v2!January 12, 2022 · 5 min readHello and happy new year! It's our great pleasure to announce that we have released oclif v2, which uses the new @oclif/core library! 🎉
oclif v2 includes many changes that improve the experience of both creating and using an oclif CLI.
Going forward, we don't plan to make any updates to oclif v1 and its corresponding libraries, except for critical security fixes. See the compatibility matrix for a list of these libraries. In order to give developers time to migrate from v1 to v2, we're not completely dropping support yet. But at some point in the future we'll archive the v1 repositories and deprecate their versions on npm.
What’s changing?​
Repository Changes​
All repositories under the oclif org now use main as their primary branch and oclif-v1 as the legacy branch. The main  branch corresponds to oclif v2 and the oclif-v1 branch to oclif v1. If you find any repos that don’t have a main branch, you can safely assume that they're not used in oclif v2 and will be deprecated in the future.
Consolidating Tools & Libraries​
The oclif-dev CLI has now been incorporated into oclif. You now no longer need to install a separate package to manage your entire CLI’s lifecycle.
The following libraries have been consolidated under @oclif/core and will be deprecated at some point in the future. Read the migration guide to learn how to update your CLI or plugin to use the new core library.

@oclif/command
@oclif/config
@oclif/error
@oclif/help
@oclif/parser

No more single vs multi command CLIs​
There's only one "type" of oclif v2 CLI, but it can have as few or as many commands as a developer wants. As a result, there’s only one command to generate CLIs, oclif generate, as opposed to the old oclif single and oclif multi commands.
Node > 12​
To ensure oclif CLIs are as secure as possible, all v2 libraries and plugins support only Node 12 or higher as of now. Going forward, they'll support only Node Maintenance or higher, as defined by Node's release schedule here: https://nodejs.org/en/about/releases/.
What’s new?​
New example CLI​
oclif-hello-world is our new example repo. This is also the repo that's used as a template when running oclif generate to create a new CLI. This repo will always be able to be referenced as an example of what an oclif v2 CLI should look like.
Spaced commands​
oclif CLIs can now use spaces, instead of colons, to separate topics and subcommands. To enable this feature, simply add “topicSeparator": " " to the oclif config in your package.json. See an example in our example repo.
// Old commands that use :$ mycli do:something
// New spaced commands$ mycli do something

Note: Spaced commands are backwards compatible. So if you enable spaced commands for your CLI, users will still be able to use : as a separator. This ensures that any existing scripts don't break.

New Help Output​
We’ve revamped the way command help is outputted to the terminal, making it both easier to implement and easier to read. See the difference between the old help output on the left and the new help output on the right in the screenshots below.
oclif v1oclif v2
Notice that there are new sections for flags and global flags, examples are displayed with better spacing, and there is a section at the bottom called Configuration Variables. This Configuration Variables section is not part of the new help by default. But we've added support for custom help sections, which is what the sf CLI uses to create the new section.
Async Command Parsing​
We’ve also improved the performance of new CLIs by rewriting how commands are parsed on initialization. The new parser is asynchronous, which makes CLIs with a lot of commands or installed  plugins much faster.
What’s coming next?​
Part of our charter for the release of oclif v2 includes improving our engagement with the oclif community. We know that over the past couple of years we’ve reduced our involvement, and a lot of issues and PRs have languished in limbo. Hopefully you’ve already seen increased activity and responses from oclif maintainers recently, but if you haven’t, please don’t hesitate to ping us by tagging @admins in oclif repos.
We also want to start interviewing members of the oclif community to acquire feedback and prioritize the features and fixes you deem most important!
Best,
The oclif team

Reference material​
Migration Guide​
This guide explains how to upgrade a CLI or plugin from the old oclif v1 libraries to the new @oclif/core library that oclif v2 uses.
https://github.com/oclif/core/blob/main/MIGRATION.md
Compatibility Matrix​
The following matrix shows how the v1 libraries and plugins relate to the new v2 ones. Use this matrix as a guide to know what to drop and which versions to switch when upgrading your plugins and CLIs to v2.
oclif "v1"oclif "v2"Utility CLIsoclif@<2@oclif/dev-cli@<2oclif@>=2Main packages@oclif/command@oclif/config@oclif/errors@oclif/parser@oclif/plugin-help@oclif/core@>=1Node LTSNode v8-14Node v12+ (at time of writing)TypeScripttypescript@<4typescript@>=4Main plugins@oclif/plugin-autocomplete@<1@oclif/plugin-commands@<2@oclif/plugin-help@<4@oclif/plugin-not-found@<2@oclif/plugin-plugins@<2@oclif/plugin-update@<2plugin-warn-if-update-available@<2plugin-which@<2@oclif/plugin-autocomplete@>=1@oclif/plugin-commands@>=2@oclif/plugin-help@>=4@oclif/plugin-not-found@>=2@oclif/plugin-plugins@>=2@oclif/plugin-update@>=2@oclif/plugin-warn-if-update-available@>=2@oclif/plugin-which@>=2\n\nAnnouncing oclif v2!January 12, 2022 · 5 min readHello and happy new year! It's our great pleasure to announce that we have released oclif v2, which uses the new @oclif/core library! 🎉
oclif v2 includes many changes that improve the experience of both creating and using an oclif CLI.
Going forward, we don't plan to make any updates to oclif v1 and its corresponding libraries, except for critical security fixes. See the compatibility matrix for a list of these libraries. In order to give developers time to migrate from v1 to v2, we're not completely dropping support yet. But at some point in the future we'll archive the v1 repositories and deprecate their versions on npm.
What’s changing?​
Repository Changes​
All repositories under the oclif org now use main as their primary branch and oclif-v1 as the legacy branch. The main  branch corresponds to oclif v2 and the oclif-v1 branch to oclif v1. If you find any repos that don’t have a main branch, you can safely assume that they're not used in oclif v2 and will be deprecated in the future.
Consolidating Tools & Libraries​
The oclif-dev CLI has now been incorporated into oclif. You now no longer need to install a separate package to manage your entire CLI’s lifecycle.
The following libraries have been consolidated under @oclif/core and will be deprecated at some point in the future. Read the migration guide to learn how to update your CLI or plugin to use the new core library.

@oclif/command
@oclif/config
@oclif/error
@oclif/help
@oclif/parser

No more single vs multi command CLIs​
There's only one "type" of oclif v2 CLI, but it can have as few or as many commands as a developer wants. As a result, there’s only one command to generate CLIs, oclif generate, as opposed to the old oclif single and oclif multi commands.
Node > 12​
To ensure oclif CLIs are as secure as possible, all v2 libraries and plugins support only Node 12 or higher as of now. Going forward, they'll support only Node Maintenance or higher, as defined by Node's release schedule here: https://nodejs.org/en/about/releases/.
What’s new?​
New example CLI​
oclif-hello-world is our new example repo. This is also the repo that's used as a template when running oclif generate to create a new CLI. This repo will always be able to be referenced as an example of what an oclif v2 CLI should look like.
Spaced commands​
oclif CLIs can now use spaces, instead of colons, to separate topics and subcommands. To enable this feature, simply add “topicSeparator": " " to the oclif config in your package.json. See an example in our example repo.
// Old commands that use :$ mycli do:something
// New spaced commands$ mycli do something

Note: Spaced commands are backwards compatible. So if you enable spaced commands for your CLI, users will still be able to use : as a separator. This ensures that any existing scripts don't break.

New Help Output​
We’ve revamped the way command help is outputted to the terminal, making it both easier to implement and easier to read. See the difference between the old help output on the left and the new help output on the right in the screenshots below.
oclif v1oclif v2
Notice that there are new sections for flags and global flags, examples are displayed with better spacing, and there is a section at the bottom called Configuration Variables. This Configuration Variables section is not part of the new help by default. But we've added support for custom help sections, which is what the sf CLI uses to create the new section.
Async Command Parsing​
We’ve also improved the performance of new CLIs by rewriting how commands are parsed on initialization. The new parser is asynchronous, which makes CLIs with a lot of commands or installed  plugins much faster.
What’s coming next?​
Part of our charter for the release of oclif v2 includes improving our engagement with the oclif community. We know that over the past couple of years we’ve reduced our involvement, and a lot of issues and PRs have languished in limbo. Hopefully you’ve already seen increased activity and responses from oclif maintainers recently, but if you haven’t, please don’t hesitate to ping us by tagging @admins in oclif repos.
We also want to start interviewing members of the oclif community to acquire feedback and prioritize the features and fixes you deem most important!
Best,
The oclif team

Reference material​
Migration Guide​
This guide explains how to upgrade a CLI or plugin from the old oclif v1 libraries to the new @oclif/core library that oclif v2 uses.
https://github.com/oclif/core/blob/main/MIGRATION.md
Compatibility Matrix​
The following matrix shows how the v1 libraries and plugins relate to the new v2 ones. Use this matrix as a guide to know what to drop and which versions to switch when upgrading your plugins and CLIs to v2.
oclif "v1"oclif "v2"Utility CLIsoclif@<2@oclif/dev-cli@<2oclif@>=2Main packages@oclif/command@oclif/config@oclif/errors@oclif/parser@oclif/plugin-help@oclif/core@>=1Node LTSNode v8-14Node v12+ (at time of writing)TypeScripttypescript@<4typescript@>=4Main plugins@oclif/plugin-autocomplete@<1@oclif/plugin-commands@<2@oclif/plugin-help@<4@oclif/plugin-not-found@<2@oclif/plugin-plugins@<2@oclif/plugin-update@<2plugin-warn-if-update-available@<2plugin-which@<2@oclif/plugin-autocomplete@>=1@oclif/plugin-commands@>=2@oclif/plugin-help@>=4@oclif/plugin-not-found@>=2@oclif/plugin-plugins@>=2@oclif/plugin-update@>=2@oclif/plugin-warn-if-update-available@>=2@oclif/plugin-which@>=2Newer Postoclif Spring 2024 UpdateOlder PostIntroducing @oclif/core\n\n\n\nAnnouncing oclif v2!January 12, 2022 · 5 min readHello and happy new year! It's our great pleasure to announce that we have released oclif v2, which uses the new @oclif/core library! 🎉
oclif v2 includes many changes that improve the experience of both creating and using an oclif CLI.
Going forward, we don't plan to make any updates to oclif v1 and its corresponding libraries, except for critical security fixes. See the compatibility matrix for a list of these libraries. In order to give developers time to migrate from v1 to v2, we're not completely dropping support yet. But at some point in the future we'll archive the v1 repositories and deprecate their versions on npm.
What’s changing?​
Repository Changes​
All repositories under the oclif org now use main as their primary branch and oclif-v1 as the legacy branch. The main  branch corresponds to oclif v2 and the oclif-v1 branch to oclif v1. If you find any repos that don’t have a main branch, you can safely assume that they're not used in oclif v2 and will be deprecated in the future.
Consolidating Tools & Libraries​
The oclif-dev CLI has now been incorporated into oclif. You now no longer need to install a separate package to manage your entire CLI’s lifecycle.
The following libraries have been consolidated under @oclif/core and will be deprecated at some point in the future. Read the migration guide to learn how to update your CLI or plugin to use the new core library.

@oclif/command
@oclif/config
@oclif/error
@oclif/help
@oclif/parser

No more single vs multi command CLIs​
There's only one "type" of oclif v2 CLI, but it can have as few or as many commands as a developer wants. As a result, there’s only one command to generate CLIs, oclif generate, as opposed to the old oclif single and oclif multi commands.
Node > 12​
To ensure oclif CLIs are as secure as possible, all v2 libraries and plugins support only Node 12 or higher as of now. Going forward, they'll support only Node Maintenance or higher, as defined by Node's release schedule here: https://nodejs.org/en/about/releases/.
What’s new?​
New example CLI​
oclif-hello-world is our new example repo. This is also the repo that's used as a template when running oclif generate to create a new CLI. This repo will always be able to be referenced as an example of what an oclif v2 CLI should look like.
Spaced commands​
oclif CLIs can now use spaces, instead of colons, to separate topics and subcommands. To enable this feature, simply add “topicSeparator": " " to the oclif config in your package.json. See an example in our example repo.
// Old commands that use :$ mycli do:something
// New spaced commands$ mycli do something

Note: Spaced commands are backwards compatible. So if you enable spaced commands for your CLI, users will still be able to use : as a separator. This ensures that any existing scripts don't break.

New Help Output​
We’ve revamped the way command help is outputted to the terminal, making it both easier to implement and easier to read. See the difference between the old help output on the left and the new help output on the right in the screenshots below.
oclif v1oclif v2
Notice that there are new sections for flags and global flags, examples are displayed with better spacing, and there is a section at the bottom called Configuration Variables. This Configuration Variables section is not part of the new help by default. But we've added support for custom help sections, which is what the sf CLI uses to create the new section.
Async Command Parsing​
We’ve also improved the performance of new CLIs by rewriting how commands are parsed on initialization. The new parser is asynchronous, which makes CLIs with a lot of commands or installed  plugins much faster.
What’s coming next?​
Part of our charter for the release of oclif v2 includes improving our engagement with the oclif community. We know that over the past couple of years we’ve reduced our involvement, and a lot of issues and PRs have languished in limbo. Hopefully you’ve already seen increased activity and responses from oclif maintainers recently, but if you haven’t, please don’t hesitate to ping us by tagging @admins in oclif repos.
We also want to start interviewing members of the oclif community to acquire feedback and prioritize the features and fixes you deem most important!
Best,
The oclif team

Reference material​
Migration Guide​
This guide explains how to upgrade a CLI or plugin from the old oclif v1 libraries to the new @oclif/core library that oclif v2 uses.
https://github.com/oclif/core/blob/main/MIGRATION.md
Compatibility Matrix​
The following matrix shows how the v1 libraries and plugins relate to the new v2 ones. Use this matrix as a guide to know what to drop and which versions to switch when upgrading your plugins and CLIs to v2.
oclif "v1"oclif "v2"Utility CLIsoclif@<2@oclif/dev-cli@<2oclif@>=2Main packages@oclif/command@oclif/config@oclif/errors@oclif/parser@oclif/plugin-help@oclif/core@>=1Node LTSNode v8-14Node v12+ (at time of writing)TypeScripttypescript@<4typescript@>=4Main plugins@oclif/plugin-autocomplete@<1@oclif/plugin-commands@<2@oclif/plugin-help@<4@oclif/plugin-not-found@<2@oclif/plugin-plugins@<2@oclif/plugin-update@<2plugin-warn-if-update-available@<2plugin-which@<2@oclif/plugin-autocomplete@>=1@oclif/plugin-commands@>=2@oclif/plugin-help@>=4@oclif/plugin-not-found@>=2@oclif/plugin-plugins@>=2@oclif/plugin-update@>=2@oclif/plugin-warn-if-update-available@>=2@oclif/plugin-which@>=2\n\nAnnouncing oclif v2!January 12, 2022 · 5 min readHello and happy new year! It's our great pleasure to announce that we have released oclif v2, which uses the new @oclif/core library! 🎉
oclif v2 includes many changes that improve the experience of both creating and using an oclif CLI.
Going forward, we don't plan to make any updates to oclif v1 and its corresponding libraries, except for critical security fixes. See the compatibility matrix for a list of these libraries. In order to give developers time to migrate from v1 to v2, we're not completely dropping support yet. But at some point in the future we'll archive the v1 repositories and deprecate their versions on npm.
What’s changing?​
Repository Changes​
All repositories under the oclif org now use main as their primary branch and oclif-v1 as the legacy branch. The main  branch corresponds to oclif v2 and the oclif-v1 branch to oclif v1. If you find any repos that don’t have a main branch, you can safely assume that they're not used in oclif v2 and will be deprecated in the future.
Consolidating Tools & Libraries​
The oclif-dev CLI has now been incorporated into oclif. You now no longer need to install a separate package to manage your entire CLI’s lifecycle.
The following libraries have been consolidated under @oclif/core and will be deprecated at some point in the future. Read the migration guide to learn how to update your CLI or plugin to use the new core library.

@oclif/command
@oclif/config
@oclif/error
@oclif/help
@oclif/parser

No more single vs multi command CLIs​
There's only one "type" of oclif v2 CLI, but it can have as few or as many commands as a developer wants. As a result, there’s only one command to generate CLIs, oclif generate, as opposed to the old oclif single and oclif multi commands.
Node > 12​
To ensure oclif CLIs are as secure as possible, all v2 libraries and plugins support only Node 12 or higher as of now. Going forward, they'll support only Node Maintenance or higher, as defined by Node's release schedule here: https://nodejs.org/en/about/releases/.
What’s new?​
New example CLI​
oclif-hello-world is our new example repo. This is also the repo that's used as a template when running oclif generate to create a new CLI. This repo will always be able to be referenced as an example of what an oclif v2 CLI should look like.
Spaced commands​
oclif CLIs can now use spaces, instead of colons, to separate topics and subcommands. To enable this feature, simply add “topicSeparator": " " to the oclif config in your package.json. See an example in our example repo.
// Old commands that use :$ mycli do:something
// New spaced commands$ mycli do something

Note: Spaced commands are backwards compatible. So if you enable spaced commands for your CLI, users will still be able to use : as a separator. This ensures that any existing scripts don't break.

New Help Output​
We’ve revamped the way command help is outputted to the terminal, making it both easier to implement and easier to read. See the difference between the old help output on the left and the new help output on the right in the screenshots below.
oclif v1oclif v2
Notice that there are new sections for flags and global flags, examples are displayed with better spacing, and there is a section at the bottom called Configuration Variables. This Configuration Variables section is not part of the new help by default. But we've added support for custom help sections, which is what the sf CLI uses to create the new section.
Async Command Parsing​
We’ve also improved the performance of new CLIs by rewriting how commands are parsed on initialization. The new parser is asynchronous, which makes CLIs with a lot of commands or installed  plugins much faster.
What’s coming next?​
Part of our charter for the release of oclif v2 includes improving our engagement with the oclif community. We know that over the past couple of years we’ve reduced our involvement, and a lot of issues and PRs have languished in limbo. Hopefully you’ve already seen increased activity and responses from oclif maintainers recently, but if you haven’t, please don’t hesitate to ping us by tagging @admins in oclif repos.
We also want to start interviewing members of the oclif community to acquire feedback and prioritize the features and fixes you deem most important!
Best,
The oclif team

Reference material​
Migration Guide​
This guide explains how to upgrade a CLI or plugin from the old oclif v1 libraries to the new @oclif/core library that oclif v2 uses.
https://github.com/oclif/core/blob/main/MIGRATION.md
Compatibility Matrix​
The following matrix shows how the v1 libraries and plugins relate to the new v2 ones. Use this matrix as a guide to know what to drop and which versions to switch when upgrading your plugins and CLIs to v2.
oclif "v1"oclif "v2"Utility CLIsoclif@<2@oclif/dev-cli@<2oclif@>=2Main packages@oclif/command@oclif/config@oclif/errors@oclif/parser@oclif/plugin-help@oclif/core@>=1Node LTSNode v8-14Node v12+ (at time of writing)TypeScripttypescript@<4typescript@>=4Main plugins@oclif/plugin-autocomplete@<1@oclif/plugin-commands@<2@oclif/plugin-help@<4@oclif/plugin-not-found@<2@oclif/plugin-plugins@<2@oclif/plugin-update@<2plugin-warn-if-update-available@<2plugin-which@<2@oclif/plugin-autocomplete@>=1@oclif/plugin-commands@>=2@oclif/plugin-help@>=4@oclif/plugin-not-found@>=2@oclif/plugin-plugins@>=2@oclif/plugin-update@>=2@oclif/plugin-warn-if-update-available@>=2@oclif/plugin-which@>=2Newer Postoclif Spring 2024 UpdateOlder PostIntroducing @oclif/core\n\n\n\nAnnouncing oclif v2!January 12, 2022 · 5 min readHello and happy new year! It's our great pleasure to announce that we have released oclif v2, which uses the new @oclif/core library! 🎉
oclif v2 includes many changes that improve the experience of both creating and using an oclif CLI.
Going forward, we don't plan to make any updates to oclif v1 and its corresponding libraries, except for critical security fixes. See the compatibility matrix for a list of these libraries. In order to give developers time to migrate from v1 to v2, we're not completely dropping support yet. But at some point in the future we'll archive the v1 repositories and deprecate their versions on npm.
What’s changing?​
Repository Changes​
All repositories under the oclif org now use main as their primary branch and oclif-v1 as the legacy branch. The main  branch corresponds to oclif v2 and the oclif-v1 branch to oclif v1. If you find any repos that don’t have a main branch, you can safely assume that they're not used in oclif v2 and will be deprecated in the future.
Consolidating Tools & Libraries​
The oclif-dev CLI has now been incorporated into oclif. You now no longer need to install a separate package to manage your entire CLI’s lifecycle.
The following libraries have been consolidated under @oclif/core and will be deprecated at some point in the future. Read the migration guide to learn how to update your CLI or plugin to use the new core library.

@oclif/command
@oclif/config
@oclif/error
@oclif/help
@oclif/parser

No more single vs multi command CLIs​
There's only one "type" of oclif v2 CLI, but it can have as few or as many commands as a developer wants. As a result, there’s only one command to generate CLIs, oclif generate, as opposed to the old oclif single and oclif multi commands.
Node > 12​
To ensure oclif CLIs are as secure as possible, all v2 libraries and plugins support only Node 12 or higher as of now. Going forward, they'll support only Node Maintenance or higher, as defined by Node's release schedule here: https://nodejs.org/en/about/releases/.
What’s new?​
New example CLI​
oclif-hello-world is our new example repo. This is also the repo that's used as a template when running oclif generate to create a new CLI. This repo will always be able to be referenced as an example of what an oclif v2 CLI should look like.
Spaced commands​
oclif CLIs can now use spaces, instead of colons, to separate topics and subcommands. To enable this feature, simply add “topicSeparator": " " to the oclif config in your package.json. See an example in our example repo.
// Old commands that use :$ mycli do:something
// New spaced commands$ mycli do something

Note: Spaced commands are backwards compatible. So if you enable spaced commands for your CLI, users will still be able to use : as a separator. This ensures that any existing scripts don't break.

New Help Output​
We’ve revamped the way command help is outputted to the terminal, making it both easier to implement and easier to read. See the difference between the old help output on the left and the new help output on the right in the screenshots below.
oclif v1oclif v2
Notice that there are new sections for flags and global flags, examples are displayed with better spacing, and there is a section at the bottom called Configuration Variables. This Configuration Variables section is not part of the new help by default. But we've added support for custom help sections, which is what the sf CLI uses to create the new section.
Async Command Parsing​
We’ve also improved the performance of new CLIs by rewriting how commands are parsed on initialization. The new parser is asynchronous, which makes CLIs with a lot of commands or installed  plugins much faster.
What’s coming next?​
Part of our charter for the release of oclif v2 includes improving our engagement with the oclif community. We know that over the past couple of years we’ve reduced our involvement, and a lot of issues and PRs have languished in limbo. Hopefully you’ve already seen increased activity and responses from oclif maintainers recently, but if you haven’t, please don’t hesitate to ping us by tagging @admins in oclif repos.
We also want to start interviewing members of the oclif community to acquire feedback and prioritize the features and fixes you deem most important!
Best,
The oclif team

Reference material​
Migration Guide​
This guide explains how to upgrade a CLI or plugin from the old oclif v1 libraries to the new @oclif/core library that oclif v2 uses.
https://github.com/oclif/core/blob/main/MIGRATION.md
Compatibility Matrix​
The following matrix shows how the v1 libraries and plugins relate to the new v2 ones. Use this matrix as a guide to know what to drop and which versions to switch when upgrading your plugins and CLIs to v2.
oclif "v1"oclif "v2"Utility CLIsoclif@<2@oclif/dev-cli@<2oclif@>=2Main packages@oclif/command@oclif/config@oclif/errors@oclif/parser@oclif/plugin-help@oclif/core@>=1Node LTSNode v8-14Node v12+ (at time of writing)TypeScripttypescript@<4typescript@>=4Main plugins@oclif/plugin-autocomplete@<1@oclif/plugin-commands@<2@oclif/plugin-help@<4@oclif/plugin-not-found@<2@oclif/plugin-plugins@<2@oclif/plugin-update@<2plugin-warn-if-update-available@<2plugin-which@<2@oclif/plugin-autocomplete@>=1@oclif/plugin-commands@>=2@oclif/plugin-help@>=4@oclif/plugin-not-found@>=2@oclif/plugin-plugins@>=2@oclif/plugin-update@>=2@oclif/plugin-warn-if-update-available@>=2@oclif/plugin-which@>=2\n\nAnnouncing oclif v2!January 12, 2022 · 5 min readHello and happy new year! It's our great pleasure to announce that we have released oclif v2, which uses the new @oclif/core library! 🎉
oclif v2 includes many changes that improve the experience of both creating and using an oclif CLI.
Going forward, we don't plan to make any updates to oclif v1 and its corresponding libraries, except for critical security fixes. See the compatibility matrix for a list of these libraries. In order to give developers time to migrate from v1 to v2, we're not completely dropping support yet. But at some point in the future we'll archive the v1 repositories and deprecate their versions on npm.
What’s changing?​
Repository Changes​
All repositories under the oclif org now use main as their primary branch and oclif-v1 as the legacy branch. The main  branch corresponds to oclif v2 and the oclif-v1 branch to oclif v1. If you find any repos that don’t have a main branch, you can safely assume that they're not used in oclif v2 and will be deprecated in the future.
Consolidating Tools & Libraries​
The oclif-dev CLI has now been incorporated into oclif. You now no longer need to install a separate package to manage your entire CLI’s lifecycle.
The following libraries have been consolidated under @oclif/core and will be deprecated at some point in the future. Read the migration guide to learn how to update your CLI or plugin to use the new core library.

@oclif/command
@oclif/config
@oclif/error
@oclif/help
@oclif/parser

No more single vs multi command CLIs​
There's only one "type" of oclif v2 CLI, but it can have as few or as many commands as a developer wants. As a result, there’s only one command to generate CLIs, oclif generate, as opposed to the old oclif single and oclif multi commands.
Node > 12​
To ensure oclif CLIs are as secure as possible, all v2 libraries and plugins support only Node 12 or higher as of now. Going forward, they'll support only Node Maintenance or higher, as defined by Node's release schedule here: https://nodejs.org/en/about/releases/.
What’s new?​
New example CLI​
oclif-hello-world is our new example repo. This is also the repo that's used as a template when running oclif generate to create a new CLI. This repo will always be able to be referenced as an example of what an oclif v2 CLI should look like.
Spaced commands​
oclif CLIs can now use spaces, instead of colons, to separate topics and subcommands. To enable this feature, simply add “topicSeparator": " " to the oclif config in your package.json. See an example in our example repo.
// Old commands that use :$ mycli do:something
// New spaced commands$ mycli do something

Note: Spaced commands are backwards compatible. So if you enable spaced commands for your CLI, users will still be able to use : as a separator. This ensures that any existing scripts don't break.

New Help Output​
We’ve revamped the way command help is outputted to the terminal, making it both easier to implement and easier to read. See the difference between the old help output on the left and the new help output on the right in the screenshots below.
oclif v1oclif v2
Notice that there are new sections for flags and global flags, examples are displayed with better spacing, and there is a section at the bottom called Configuration Variables. This Configuration Variables section is not part of the new help by default. But we've added support for custom help sections, which is what the sf CLI uses to create the new section.
Async Command Parsing​
We’ve also improved the performance of new CLIs by rewriting how commands are parsed on initialization. The new parser is asynchronous, which makes CLIs with a lot of commands or installed  plugins much faster.
What’s coming next?​
Part of our charter for the release of oclif v2 includes improving our engagement with the oclif community. We know that over the past couple of years we’ve reduced our involvement, and a lot of issues and PRs have languished in limbo. Hopefully you’ve already seen increased activity and responses from oclif maintainers recently, but if you haven’t, please don’t hesitate to ping us by tagging @admins in oclif repos.
We also want to start interviewing members of the oclif community to acquire feedback and prioritize the features and fixes you deem most important!
Best,
The oclif team

Reference material​
Migration Guide​
This guide explains how to upgrade a CLI or plugin from the old oclif v1 libraries to the new @oclif/core library that oclif v2 uses.
https://github.com/oclif/core/blob/main/MIGRATION.md
Compatibility Matrix​
The following matrix shows how the v1 libraries and plugins relate to the new v2 ones. Use this matrix as a guide to know what to drop and which versions to switch when upgrading your plugins and CLIs to v2.
oclif "v1"oclif "v2"Utility CLIsoclif@<2@oclif/dev-cli@<2oclif@>=2Main packages@oclif/command@oclif/config@oclif/errors@oclif/parser@oclif/plugin-help@oclif/core@>=1Node LTSNode v8-14Node v12+ (at time of writing)TypeScripttypescript@<4typescript@>=4Main plugins@oclif/plugin-autocomplete@<1@oclif/plugin-commands@<2@oclif/plugin-help@<4@oclif/plugin-not-found@<2@oclif/plugin-plugins@<2@oclif/plugin-update@<2plugin-warn-if-update-available@<2plugin-which@<2@oclif/plugin-autocomplete@>=1@oclif/plugin-commands@>=2@oclif/plugin-help@>=4@oclif/plugin-not-found@>=2@oclif/plugin-plugins@>=2@oclif/plugin-update@>=2@oclif/plugin-warn-if-update-available@>=2@oclif/plugin-which@>=2Newer Postoclif Spring 2024 UpdateOlder PostIntroducing @oclif/core\n\n\n\nAnnouncing oclif v2!January 12, 2022 · 5 min readHello and happy new year! It's our great pleasure to announce that we have released oclif v2, which uses the new @oclif/core library! 🎉
oclif v2 includes many changes that improve the experience of both creating and using an oclif CLI.
Going forward, we don't plan to make any updates to oclif v1 and its corresponding libraries, except for critical security fixes. See the compatibility matrix for a list of these libraries. In order to give developers time to migrate from v1 to v2, we're not completely dropping support yet. But at some point in the future we'll archive the v1 repositories and deprecate their versions on npm.
What’s changing?​
Repository Changes​
All repositories under the oclif org now use main as their primary branch and oclif-v1 as the legacy branch. The main  branch corresponds to oclif v2 and the oclif-v1 branch to oclif v1. If you find any repos that don’t have a main branch, you can safely assume that they're not used in oclif v2 and will be deprecated in the future.
Consolidating Tools & Libraries​
The oclif-dev CLI has now been incorporated into oclif. You now no longer need to install a separate package to manage your entire CLI’s lifecycle.
The following libraries have been consolidated under @oclif/core and will be deprecated at some point in the future. Read the migration guide to learn how to update your CLI or plugin to use the new core library.

@oclif/command
@oclif/config
@oclif/error
@oclif/help
@oclif/parser

No more single vs multi command CLIs​
There's only one "type" of oclif v2 CLI, but it can have as few or as many commands as a developer wants. As a result, there’s only one command to generate CLIs, oclif generate, as opposed to the old oclif single and oclif multi commands.
Node > 12​
To ensure oclif CLIs are as secure as possible, all v2 libraries and plugins support only Node 12 or higher as of now. Going forward, they'll support only Node Maintenance or higher, as defined by Node's release schedule here: https://nodejs.org/en/about/releases/.
What’s new?​
New example CLI​
oclif-hello-world is our new example repo. This is also the repo that's used as a template when running oclif generate to create a new CLI. This repo will always be able to be referenced as an example of what an oclif v2 CLI should look like.
Spaced commands​
oclif CLIs can now use spaces, instead of colons, to separate topics and subcommands. To enable this feature, simply add “topicSeparator": " " to the oclif config in your package.json. See an example in our example repo.
// Old commands that use :$ mycli do:something
// New spaced commands$ mycli do something

Note: Spaced commands are backwards compatible. So if you enable spaced commands for your CLI, users will still be able to use : as a separator. This ensures that any existing scripts don't break.

New Help Output​
We’ve revamped the way command help is outputted to the terminal, making it both easier to implement and easier to read. See the difference between the old help output on the left and the new help output on the right in the screenshots below.
oclif v1oclif v2
Notice that there are new sections for flags and global flags, examples are displayed with better spacing, and there is a section at the bottom called Configuration Variables. This Configuration Variables section is not part of the new help by default. But we've added support for custom help sections, which is what the sf CLI uses to create the new section.
Async Command Parsing​
We’ve also improved the performance of new CLIs by rewriting how commands are parsed on initialization. The new parser is asynchronous, which makes CLIs with a lot of commands or installed  plugins much faster.
What’s coming next?​
Part of our charter for the release of oclif v2 includes improving our engagement with the oclif community. We know that over the past couple of years we’ve reduced our involvement, and a lot of issues and PRs have languished in limbo. Hopefully you’ve already seen increased activity and responses from oclif maintainers recently, but if you haven’t, please don’t hesitate to ping us by tagging @admins in oclif repos.
We also want to start interviewing members of the oclif community to acquire feedback and prioritize the features and fixes you deem most important!
Best,
The oclif team

Reference material​
Migration Guide​
This guide explains how to upgrade a CLI or plugin from the old oclif v1 libraries to the new @oclif/core library that oclif v2 uses.
https://github.com/oclif/core/blob/main/MIGRATION.md
Compatibility Matrix​
The following matrix shows how the v1 libraries and plugins relate to the new v2 ones. Use this matrix as a guide to know what to drop and which versions to switch when upgrading your plugins and CLIs to v2.
oclif "v1"oclif "v2"Utility CLIsoclif@<2@oclif/dev-cli@<2oclif@>=2Main packages@oclif/command@oclif/config@oclif/errors@oclif/parser@oclif/plugin-help@oclif/core@>=1Node LTSNode v8-14Node v12+ (at time of writing)TypeScripttypescript@<4typescript@>=4Main plugins@oclif/plugin-autocomplete@<1@oclif/plugin-commands@<2@oclif/plugin-help@<4@oclif/plugin-not-found@<2@oclif/plugin-plugins@<2@oclif/plugin-update@<2plugin-warn-if-update-available@<2plugin-which@<2@oclif/plugin-autocomplete@>=1@oclif/plugin-commands@>=2@oclif/plugin-help@>=4@oclif/plugin-not-found@>=2@oclif/plugin-plugins@>=2@oclif/plugin-update@>=2@oclif/plugin-warn-if-update-available@>=2@oclif/plugin-which@>=2\n\nAnnouncing oclif v2!January 12, 2022 · 5 min readHello and happy new year! It's our great pleasure to announce that we have released oclif v2, which uses the new @oclif/core library! 🎉
oclif v2 includes many changes that improve the experience of both creating and using an oclif CLI.
Going forward, we don't plan to make any updates to oclif v1 and its corresponding libraries, except for critical security fixes. See the compatibility matrix for a list of these libraries. In order to give developers time to migrate from v1 to v2, we're not completely dropping support yet. But at some point in the future we'll archive the v1 repositories and deprecate their versions on npm.
What’s changing?​
Repository Changes​
All repositories under the oclif org now use main as their primary branch and oclif-v1 as the legacy branch. The main  branch corresponds to oclif v2 and the oclif-v1 branch to oclif v1. If you find any repos that don’t have a main branch, you can safely assume that they're not used in oclif v2 and will be deprecated in the future.
Consolidating Tools & Libraries​
The oclif-dev CLI has now been incorporated into oclif. You now no longer need to install a separate package to manage your entire CLI’s lifecycle.
The following libraries have been consolidated under @oclif/core and will be deprecated at some point in the future. Read the migration guide to learn how to update your CLI or plugin to use the new core library.

@oclif/command
@oclif/config
@oclif/error
@oclif/help
@oclif/parser

No more single vs multi command CLIs​
There's only one "type" of oclif v2 CLI, but it can have as few or as many commands as a developer wants. As a result, there’s only one command to generate CLIs, oclif generate, as opposed to the old oclif single and oclif multi commands.
Node > 12​
To ensure oclif CLIs are as secure as possible, all v2 libraries and plugins support only Node 12 or higher as of now. Going forward, they'll support only Node Maintenance or higher, as defined by Node's release schedule here: https://nodejs.org/en/about/releases/.
What’s new?​
New example CLI​
oclif-hello-world is our new example repo. This is also the repo that's used as a template when running oclif generate to create a new CLI. This repo will always be able to be referenced as an example of what an oclif v2 CLI should look like.
Spaced commands​
oclif CLIs can now use spaces, instead of colons, to separate topics and subcommands. To enable this feature, simply add “topicSeparator": " " to the oclif config in your package.json. See an example in our example repo.
// Old commands that use :$ mycli do:something
// New spaced commands$ mycli do something

Note: Spaced commands are backwards compatible. So if you enable spaced commands for your CLI, users will still be able to use : as a separator. This ensures that any existing scripts don't break.

New Help Output​
We’ve revamped the way command help is outputted to the terminal, making it both easier to implement and easier to read. See the difference between the old help output on the left and the new help output on the right in the screenshots below.
oclif v1oclif v2
Notice that there are new sections for flags and global flags, examples are displayed with better spacing, and there is a section at the bottom called Configuration Variables. This Configuration Variables section is not part of the new help by default. But we've added support for custom help sections, which is what the sf CLI uses to create the new section.
Async Command Parsing​
We’ve also improved the performance of new CLIs by rewriting how commands are parsed on initialization. The new parser is asynchronous, which makes CLIs with a lot of commands or installed  plugins much faster.
What’s coming next?​
Part of our charter for the release of oclif v2 includes improving our engagement with the oclif community. We know that over the past couple of years we’ve reduced our involvement, and a lot of issues and PRs have languished in limbo. Hopefully you’ve already seen increased activity and responses from oclif maintainers recently, but if you haven’t, please don’t hesitate to ping us by tagging @admins in oclif repos.
We also want to start interviewing members of the oclif community to acquire feedback and prioritize the features and fixes you deem most important!
Best,
The oclif team

Reference material​
Migration Guide​
This guide explains how to upgrade a CLI or plugin from the old oclif v1 libraries to the new @oclif/core library that oclif v2 uses.
https://github.com/oclif/core/blob/main/MIGRATION.md
Compatibility Matrix​
The following matrix shows how the v1 libraries and plugins relate to the new v2 ones. Use this matrix as a guide to know what to drop and which versions to switch when upgrading your plugins and CLIs to v2.
oclif "v1"oclif "v2"Utility CLIsoclif@<2@oclif/dev-cli@<2oclif@>=2Main packages@oclif/command@oclif/config@oclif/errors@oclif/parser@oclif/plugin-help@oclif/core@>=1Node LTSNode v8-14Node v12+ (at time of writing)TypeScripttypescript@<4typescript@>=4Main plugins@oclif/plugin-autocomplete@<1@oclif/plugin-commands@<2@oclif/plugin-help@<4@oclif/plugin-not-found@<2@oclif/plugin-plugins@<2@oclif/plugin-update@<2plugin-warn-if-update-available@<2plugin-which@<2@oclif/plugin-autocomplete@>=1@oclif/plugin-commands@>=2@oclif/plugin-help@>=4@oclif/plugin-not-found@>=2@oclif/plugin-plugins@>=2@oclif/plugin-update@>=2@oclif/plugin-warn-if-update-available@>=2@oclif/plugin-which@>=2Newer Postoclif Spring 2024 UpdateOlder PostIntroducing @oclif/core\n\n\n\nAnnouncing oclif v2!January 12, 2022 · 5 min readHello and happy new year! It's our great pleasure to announce that we have released oclif v2, which uses the new @oclif/core library! 🎉
oclif v2 includes many changes that improve the experience of both creating and using an oclif CLI.
Going forward, we don't plan to make any updates to oclif v1 and its corresponding libraries, except for critical security fixes. See the compatibility matrix for a list of these libraries. In order to give developers time to migrate from v1 to v2, we're not completely dropping support yet. But at some point in the future we'll archive the v1 repositories and deprecate their versions on npm.
What’s changing?​
Repository Changes​
All repositories under the oclif org now use main as their primary branch and oclif-v1 as the legacy branch. The main  branch corresponds to oclif v2 and the oclif-v1 branch to oclif v1. If you find any repos that don’t have a main branch, you can safely assume that they're not used in oclif v2 and will be deprecated in the future.
Consolidating Tools & Libraries​
The oclif-dev CLI has now been incorporated into oclif. You now no longer need to install a separate package to manage your entire CLI’s lifecycle.
The following libraries have been consolidated under @oclif/core and will be deprecated at some point in the future. Read the migration guide to learn how to update your CLI or plugin to use the new core library.

@oclif/command
@oclif/config
@oclif/error
@oclif/help
@oclif/parser

No more single vs multi command CLIs​
There's only one "type" of oclif v2 CLI, but it can have as few or as many commands as a developer wants. As a result, there’s only one command to generate CLIs, oclif generate, as opposed to the old oclif single and oclif multi commands.
Node > 12​
To ensure oclif CLIs are as secure as possible, all v2 libraries and plugins support only Node 12 or higher as of now. Going forward, they'll support only Node Maintenance or higher, as defined by Node's release schedule here: https://nodejs.org/en/about/releases/.
What’s new?​
New example CLI​
oclif-hello-world is our new example repo. This is also the repo that's used as a template when running oclif generate to create a new CLI. This repo will always be able to be referenced as an example of what an oclif v2 CLI should look like.
Spaced commands​
oclif CLIs can now use spaces, instead of colons, to separate topics and subcommands. To enable this feature, simply add “topicSeparator": " " to the oclif config in your package.json. See an example in our example repo.
// Old commands that use :$ mycli do:something
// New spaced commands$ mycli do something

Note: Spaced commands are backwards compatible. So if you enable spaced commands for your CLI, users will still be able to use : as a separator. This ensures that any existing scripts don't break.

New Help Output​
We’ve revamped the way command help is outputted to the terminal, making it both easier to implement and easier to read. See the difference between the old help output on the left and the new help output on the right in the screenshots below.
oclif v1oclif v2
Notice that there are new sections for flags and global flags, examples are displayed with better spacing, and there is a section at the bottom called Configuration Variables. This Configuration Variables section is not part of the new help by default. But we've added support for custom help sections, which is what the sf CLI uses to create the new section.
Async Command Parsing​
We’ve also improved the performance of new CLIs by rewriting how commands are parsed on initialization. The new parser is asynchronous, which makes CLIs with a lot of commands or installed  plugins much faster.
What’s coming next?​
Part of our charter for the release of oclif v2 includes improving our engagement with the oclif community. We know that over the past couple of years we’ve reduced our involvement, and a lot of issues and PRs have languished in limbo. Hopefully you’ve already seen increased activity and responses from oclif maintainers recently, but if you haven’t, please don’t hesitate to ping us by tagging @admins in oclif repos.
We also want to start interviewing members of the oclif community to acquire feedback and prioritize the features and fixes you deem most important!
Best,
The oclif team

Reference material​
Migration Guide​
This guide explains how to upgrade a CLI or plugin from the old oclif v1 libraries to the new @oclif/core library that oclif v2 uses.
https://github.com/oclif/core/blob/main/MIGRATION.md
Compatibility Matrix​
The following matrix shows how the v1 libraries and plugins relate to the new v2 ones. Use this matrix as a guide to know what to drop and which versions to switch when upgrading your plugins and CLIs to v2.
oclif "v1"oclif "v2"Utility CLIsoclif@<2@oclif/dev-cli@<2oclif@>=2Main packages@oclif/command@oclif/config@oclif/errors@oclif/parser@oclif/plugin-help@oclif/core@>=1Node LTSNode v8-14Node v12+ (at time of writing)TypeScripttypescript@<4typescript@>=4Main plugins@oclif/plugin-autocomplete@<1@oclif/plugin-commands@<2@oclif/plugin-help@<4@oclif/plugin-not-found@<2@oclif/plugin-plugins@<2@oclif/plugin-update@<2plugin-warn-if-update-available@<2plugin-which@<2@oclif/plugin-autocomplete@>=1@oclif/plugin-commands@>=2@oclif/plugin-help@>=4@oclif/plugin-not-found@>=2@oclif/plugin-plugins@>=2@oclif/plugin-update@>=2@oclif/plugin-warn-if-update-available@>=2@oclif/plugin-which@>=2\n\nAnnouncing oclif v2!January 12, 2022 · 5 min readHello and happy new year! It's our great pleasure to announce that we have released oclif v2, which uses the new @oclif/core library! 🎉
oclif v2 includes many changes that improve the experience of both creating and using an oclif CLI.
Going forward, we don't plan to make any updates to oclif v1 and its corresponding libraries, except for critical security fixes. See the compatibility matrix for a list of these libraries. In order to give developers time to migrate from v1 to v2, we're not completely dropping support yet. But at some point in the future we'll archive the v1 repositories and deprecate their versions on npm.
What’s changing?​
Repository Changes​
All repositories under the oclif org now use main as their primary branch and oclif-v1 as the legacy branch. The main  branch corresponds to oclif v2 and the oclif-v1 branch to oclif v1. If you find any repos that don’t have a main branch, you can safely assume that they're not used in oclif v2 and will be deprecated in the future.
Consolidating Tools & Libraries​
The oclif-dev CLI has now been incorporated into oclif. You now no longer need to install a separate package to manage your entire CLI’s lifecycle.
The following libraries have been consolidated under @oclif/core and will be deprecated at some point in the future. Read the migration guide to learn how to update your CLI or plugin to use the new core library.

@oclif/command
@oclif/config
@oclif/error
@oclif/help
@oclif/parser

No more single vs multi command CLIs​
There's only one "type" of oclif v2 CLI, but it can have as few or as many commands as a developer wants. As a result, there’s only one command to generate CLIs, oclif generate, as opposed to the old oclif single and oclif multi commands.
Node > 12​
To ensure oclif CLIs are as secure as possible, all v2 libraries and plugins support only Node 12 or higher as of now. Going forward, they'll support only Node Maintenance or higher, as defined by Node's release schedule here: https://nodejs.org/en/about/releases/.
What’s new?​
New example CLI​
oclif-hello-world is our new example repo. This is also the repo that's used as a template when running oclif generate to create a new CLI. This repo will always be able to be referenced as an example of what an oclif v2 CLI should look like.
Spaced commands​
oclif CLIs can now use spaces, instead of colons, to separate topics and subcommands. To enable this feature, simply add “topicSeparator": " " to the oclif config in your package.json. See an example in our example repo.
// Old commands that use :$ mycli do:something
// New spaced commands$ mycli do something

Note: Spaced commands are backwards compatible. So if you enable spaced commands for your CLI, users will still be able to use : as a separator. This ensures that any existing scripts don't break.

New Help Output​
We’ve revamped the way command help is outputted to the terminal, making it both easier to implement and easier to read. See the difference between the old help output on the left and the new help output on the right in the screenshots below.
oclif v1oclif v2
Notice that there are new sections for flags and global flags, examples are displayed with better spacing, and there is a section at the bottom called Configuration Variables. This Configuration Variables section is not part of the new help by default. But we've added support for custom help sections, which is what the sf CLI uses to create the new section.
Async Command Parsing​
We’ve also improved the performance of new CLIs by rewriting how commands are parsed on initialization. The new parser is asynchronous, which makes CLIs with a lot of commands or installed  plugins much faster.
What’s coming next?​
Part of our charter for the release of oclif v2 includes improving our engagement with the oclif community. We know that over the past couple of years we’ve reduced our involvement, and a lot of issues and PRs have languished in limbo. Hopefully you’ve already seen increased activity and responses from oclif maintainers recently, but if you haven’t, please don’t hesitate to ping us by tagging @admins in oclif repos.
We also want to start interviewing members of the oclif community to acquire feedback and prioritize the features and fixes you deem most important!
Best,
The oclif team

Reference material​
Migration Guide​
This guide explains how to upgrade a CLI or plugin from the old oclif v1 libraries to the new @oclif/core library that oclif v2 uses.
https://github.com/oclif/core/blob/main/MIGRATION.md
Compatibility Matrix​
The following matrix shows how the v1 libraries and plugins relate to the new v2 ones. Use this matrix as a guide to know what to drop and which versions to switch when upgrading your plugins and CLIs to v2.
oclif "v1"oclif "v2"Utility CLIsoclif@<2@oclif/dev-cli@<2oclif@>=2Main packages@oclif/command@oclif/config@oclif/errors@oclif/parser@oclif/plugin-help@oclif/core@>=1Node LTSNode v8-14Node v12+ (at time of writing)TypeScripttypescript@<4typescript@>=4Main plugins@oclif/plugin-autocomplete@<1@oclif/plugin-commands@<2@oclif/plugin-help@<4@oclif/plugin-not-found@<2@oclif/plugin-plugins@<2@oclif/plugin-update@<2plugin-warn-if-update-available@<2plugin-which@<2@oclif/plugin-autocomplete@>=1@oclif/plugin-commands@>=2@oclif/plugin-help@>=4@oclif/plugin-not-found@>=2@oclif/plugin-plugins@>=2@oclif/plugin-update@>=2@oclif/plugin-warn-if-update-available@>=2@oclif/plugin-which@>=2Newer Postoclif Spring 2024 UpdateOlder PostIntroducing @oclif/core\n\n\n\n