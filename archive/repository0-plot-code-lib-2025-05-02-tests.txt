tests/unit/plot-generation.test.js
# tests/unit/plot-generation.test.js
import { describe, test, expect, vi } from "vitest";
import fs from "fs";
import { main, renderSVG } from "@src/lib/main.js";
import sharp from "sharp";

// Mock sharp globally to simulate PNG conversion
vi.mock("sharp", () => ({
  default: vi.fn(() => ({
    png: () => ({
      toBuffer: async () => Buffer.from("PNG")
    })
  }))
}));

// Helper function to test error logs
function expectErrorLog(consoleSpy, expectedSubstring) {
  const logged = consoleSpy.mock.calls[0][0];
  expect(logged).toContain(expectedSubstring);
  expect(logged).toMatch(/\[.*\]/); // timestamp present
}


describe("Main Module Import", () => {
  test("should be non-null", () => {
    expect(main).not.toBeNull();
  });
});

describe("Plot Generation CLI Logging", () => {
  test("should log SVG output when --expression is provided", async () => {
    const consoleSpy = vi.spyOn(console, "log").mockImplementation(() => {});
    await main(["--expression", "y=sin(x)"]);
    const logged = consoleSpy.mock.calls[0][0];
    expect(logged.startsWith("<svg")).toBe(true);
    expect(logged).toContain('xmlns="http://www.w3.org/2000/svg"');
    consoleSpy.mockRestore();
  });

  test("should use default error log when no expression provided", async () => {
    const consoleSpy = vi.spyOn(console, "error").mockImplementation(() => {});
    await main([]);
    expect(consoleSpy).toHaveBeenCalled();
    expect(consoleSpy.mock.calls[0][0]).toContain("--expression flag is required");
    consoleSpy.mockRestore();
  });
});

describe("SVG Render Feature", () => {
  test("single expression generates SVG with fixed height 400 and custom width", () => {
    const expressions = ["y=sin(x)"];
    const svg = renderSVG({ expressions, width: 800, height: 400 });
    expect(svg.startsWith("<svg")).toBe(true);
    expect(svg).toContain('xmlns="http://www.w3.org/2000/svg"');
    expect(svg).toContain('width="800"');
    expect(svg).toContain('height="400"');
  });

  test("multiple expressions generate SVG with total height equal to number of expressions * segment height (using --height fallback)", () => {
    const expressions = ["y=sin(x)", "y=cos(x)"];
    const segHeight = 150;
    const totalHeight = expressions.length * segHeight;
    const svg = renderSVG({ expressions, width: 640, segmentHeight: segHeight });
    expect(svg.startsWith("<svg")).toBe(true);
    expect(svg).toContain('xmlns="http://www.w3.org/2000/svg"');
    expect(svg).toContain(`height="${totalHeight}"`);
  });

  test("multiple expressions with segmentHeight flag provided via CLI should use that value", async () => {
    const consoleSpy = vi.spyOn(console, "log").mockImplementation(() => {});
    await main(["--expression", "y=sin(x); y=cos(x)", "--width", "640", "--segmentHeight", "120"]);
    const logged = consoleSpy.mock.calls[0][0];
    expect(logged).toContain('height="240"');
    consoleSpy.mockRestore();
  });

  test("multiple expressions without segmentHeight flag should use --height as fallback", async () => {
    const consoleSpy = vi.spyOn(console, "log").mockImplementation(() => {});
    await main(["--expression", "y=sin(x); y=cos(x)", "--width", "640", "--height", "130"]);
    const logged = consoleSpy.mock.calls[0][0];
    expect(logged).toContain('height="260"');
    consoleSpy.mockRestore();
  });

  test("single expression with custom height override remains unaffected by segmentHeight flag", () => {
    const expressions = ["y=tan(x)"];
    const customHeight = 500;
    const svg = renderSVG({ expressions, width: 800, height: customHeight });
    expect(svg.startsWith("<svg")).toBe(true);
    expect(svg).toContain(`height="${customHeight}"`);
  });

  test("renders range information when --range is provided", () => {
    const expressions = ["y=x"];
    const range = "x=-5:5";
    const svg = renderSVG({ expressions, width: 640, height: 400, range });
    expect(svg).toContain("Range: x=-5:5");
  });

  test("renders x-axis and y-axis labels for single expression", () => {
    const expressions = ["y=exp(x)"];
    const xlabel = "Time (s)";
    const ylabel = "Amplitude";
    const customHeight = 500;
    const svg = renderSVG({ expressions, width: 800, height: customHeight, xlabel, ylabel });
    expect(svg).toContain(`<text x="${800/2}" y="${customHeight - 10}" text-anchor="middle" font-size="14"`);
    expect(svg).toContain(`<text x="15" y="${customHeight/2}" text-anchor="middle" transform="rotate(-90,15,${customHeight/2})" font-size="14"`);
  });

  test("renders x-axis and y-axis labels for multiple expressions", () => {
    const expressions = ["y=exp(x)", "y=log(x)"];
    const segHeight = 120;
    const totalHeight = expressions.length * segHeight;
    const xlabel = "Distance";
    const ylabel = "Value";
    const svg = renderSVG({ expressions, width: 640, segmentHeight: segHeight, xlabel, ylabel });
    expect(svg).toContain(`<text x="${640/2}" y="${totalHeight - 10}" text-anchor="middle" font-size="14"`);
    expect(svg).toContain(`<text x="15" y="${totalHeight/2}" text-anchor="middle" transform="rotate(-90,15,${totalHeight/2})" font-size="14"`);
  });

  test("logs error for empty --xlabel value", async () => {
    const consoleSpy = vi.spyOn(console, "error").mockImplementation(() => {});
    await main(["--expression", "y=sin(x)", "--xlabel", ""]);
    expect(consoleSpy.mock.calls[0][0]).toContain("--xlabel flag provided with empty value");
    consoleSpy.mockRestore();
  });

  test("logs error for empty --ylabel value", async () => {
    const consoleSpy = vi.spyOn(console, "error").mockImplementation(() => {});
    await main(["--expression", "y=sin(x)", "--ylabel", ""]);
    expect(consoleSpy.mock.calls[0][0]).toContain("--ylabel flag provided with empty value");
    consoleSpy.mockRestore();
  });

  test("renders custom style attributes for text, line, and background", () => {
    const expressions = ["y=sin(x)"];
    const textColor = "red";
    const lineColor = "blue";
    const backgroundColor = "#efefef";
    const svg = renderSVG({ expressions, width: 800, height: 400, textColor, lineColor, backgroundColor });
    expect(svg).toContain(`fill="${textColor}"`);
    expect(svg).toContain(`stroke="${lineColor}"`);
    expect(svg).toContain(`<rect width="800" height="400" fill="${backgroundColor}"`);
  });

  test("logs error for empty --textColor value", async () => {
    const consoleSpy = vi.spyOn(console, "error").mockImplementation(() => {});
    await main(["--expression", "y=sin(x)", "--textColor", ""]);
    expect(consoleSpy.mock.calls[0][0]).toContain("--textColor flag provided with empty value");
    consoleSpy.mockRestore();
  });

  test("logs error for empty --lineColor value", async () => {
    const consoleSpy = vi.spyOn(console, "error").mockImplementation(() => {});
    await main(["--expression", "y=sin(x)", "--lineColor", ""]);
    expect(consoleSpy.mock.calls[0][0]).toContain("--lineColor flag provided with empty value");
    consoleSpy.mockRestore();
  });

  test("logs error for empty --backgroundColor value", async () => {
    const consoleSpy = vi.spyOn(console, "error").mockImplementation(() => {});
    await main(["--expression", "y=sin(x)", "--backgroundColor", ""]);
    expect(consoleSpy.mock.calls[0][0]).toContain("--backgroundColor flag provided with empty value");
    consoleSpy.mockRestore();
  });

  // New tests for annotation support
  test("renders annotation element with correct attributes", () => {
    const expressions = ["y=sin(x)"];
    const annotation = "Data collected on 2025-05-02";
    const textColor = "green";
    const svg = renderSVG({ expressions, width: 800, height: 400, annotation, textColor });
    expect(svg).toContain(`<text x="${800 - 100}" y="20" font-size="14" fill="${textColor}">${annotation}</text>`);
  });

  test("does not render annotation element when flag is absent", () => {
    const expressions = ["y=sin(x)"];
    const svg = renderSVG({ expressions, width: 800, height: 400 });
    expect(svg).not.toContain("TestAnnotation");
  });

  test("CLI annotation flag outputs SVG with annotation element", async () => {
    const consoleSpy = vi.spyOn(console, "log").mockImplementation(() => {});
    await main(["--expression", "y=sin(x)", "--width", "800", "--height", "400", "--annotation", "TestAnnotation", "--textColor", "purple"]);
    const logged = consoleSpy.mock.calls[0][0];
    expect(logged).toContain(`<text x="${800 - 100}" y="20" font-size="14" fill="purple">TestAnnotation</text>`);
    consoleSpy.mockRestore();
  });

  // New tests for title support
  test("renders title element correctly for single expression", () => {
    const expressions = ["y=sin(x)"];
    const title = "Test Title";
    const svg = renderSVG({ expressions, width: 800, height: 400, title, textColor: "purple" });
    expect(svg).toContain(`<text x="${800/2}" y="30" text-anchor="middle" font-size="18" fill="purple">Test Title</text>`);
  });

  test("CLI title flag outputs SVG with title element in multi-expression mode", async () => {
    const consoleSpy = vi.spyOn(console, "log").mockImplementation(() => {});
    await main(["--expression", "y=sin(x); y=cos(x)", "--width", "800", "--segmentHeight", "150", "--title", "Multi Expr Title", "--textColor", "orange"]);
    const logged = consoleSpy.mock.calls[0][0];
    expect(logged).toContain(`<text x="${800/2}" y="30" text-anchor="middle" font-size="18" fill="orange">Multi Expr Title</text>`);
    consoleSpy.mockRestore();
  });

  // New test for autoSegment dynamic calculation when no explicit segmentHeight is provided
  test("autoSegment computes correct segment height with additional flags", async () => {
    const consoleSpy = vi.spyOn(console, "log").mockImplementation(() => {});
    // For expression length ~8, floor(8/10)=0 so base=100, plus 5 flags * 20 = 100, total = 200 per expression
    await main([
      "--expression", "y=sin(x); y=cos(x)",
      "--width", "800",
      "--autoSegment", "true",
      "--xlabel", "Time",
      "--ylabel", "Value",
      "--range", "x=-5:5",
      "--annotation", "Note",
      "--title", "Title",
      "--textColor", "black"
    ]);
    const logged = consoleSpy.mock.calls[0][0];
    // With two expressions, height should be 2 * 200 = 400
    expect(logged).toContain('height="400"');
    consoleSpy.mockRestore();
  });

  // New tests for viewBox and grouping <g> elements
  test("SVG output includes dynamic viewBox attribute for single expression", () => {
    const expressions = ["y=sin(x)"];
    const svg = renderSVG({ expressions, width: 800, height: 400 });
    expect(svg).toContain('viewBox="0 0 800 400"');
    expect(svg).toContain('<g id="expr-1">');
  });

  test("each expression is wrapped in a <g> with unique id for multiple expressions", () => {
    const expressions = ["y=sin(x)", "y=cos(x)"];
    const svg = renderSVG({ expressions, width: 640, segmentHeight: 150 });
    expect(svg).toContain('<g id="expr-1">');
    expect(svg).toContain('<g id="expr-2">');
  });
});

describe("CLI Numeric Validations", () => {
  test("logs error for negative --width value", async () => {
    const consoleSpy = vi.spyOn(console, "error").mockImplementation(() => {});
    await main(["--expression", "y=sin(x)", "--width", "-640"]);
    expectErrorLog(consoleSpy, "--width must be a positive number");
    consoleSpy.mockRestore();
  });

  test("logs error for zero --height value", async () => {
    const consoleSpy = vi.spyOn(console, "error").mockImplementation(() => {});
    await main(["--expression", "y=sin(x)", "--height", "0"]);
    expectErrorLog(consoleSpy, "--height must be a positive number");
    consoleSpy.mockRestore();
  });

  test("logs error for non-numeric --segmentHeight value", async () => {
    const consoleSpy = vi.spyOn(console, "error").mockImplementation(() => {});
    await main(["--expression", "y=sin(x); y=cos(x)", "--segmentHeight", "abc"]);
    expectErrorLog(consoleSpy, "--segmentHeight must be a positive number");
    consoleSpy.mockRestore();
  });

  test("in multi-expression mode, --segmentHeight takes precedence over --height", async () => {
    const consoleSpy = vi.spyOn(console, "log").mockImplementation(() => {});
    await main(["--expression", "y=sin(x); y=cos(x)", "--width", "640", "--height", "200", "--segmentHeight", "120"]);
    const logged = consoleSpy.mock.calls[0][0];
    // 2 expressions * 120 = 240
    expect(logged).toContain('height="240"');
    consoleSpy.mockRestore();
  });

  test("logs error for missing --file flag in PNG mode", async () => {
    const consoleSpy = vi.spyOn(console, "error").mockImplementation(() => {});
    await main(["--expression", "y=sin(x)", "--outputFormat", "png"]);
    expectErrorLog(consoleSpy, "--file flag is required when using png output format");
    consoleSpy.mockRestore();
  });
});

describe("Default Main Execution", () => {
  test("should terminate without error when --expression is missing", () => {
    process.argv = ["node", "src/lib/main.js"];
    main();
  });
});

describe("Default main", () => {
  test("should terminate without error", () => {
    process.argv = ["node", "src/lib/main.js"];
    main();
  });
});
